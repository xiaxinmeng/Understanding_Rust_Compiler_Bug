{"sha": "9de20198aedb3c3419ee503755e04bcc198d3a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZTIwMTk4YWVkYjNjMzQxOWVlNTAzNzU1ZTA0YmNjMTk4ZDNhOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-04T20:41:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-04T20:41:25Z"}, "message": "auto merge of #16251 : apoelstra/rust/tcp-fix, r=alexcrichton\n\nReplacement for PR #16208 (make sockaddr* struct padding explicit) to make PR #15763 (fix nested returns) merge without breaking TCP code.", "tree": {"sha": "fecc3bedaa0363e5facb0bccee82ebc8ed34585d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fecc3bedaa0363e5facb0bccee82ebc8ed34585d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de20198aedb3c3419ee503755e04bcc198d3a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de20198aedb3c3419ee503755e04bcc198d3a94", "html_url": "https://github.com/rust-lang/rust/commit/9de20198aedb3c3419ee503755e04bcc198d3a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de20198aedb3c3419ee503755e04bcc198d3a94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4", "html_url": "https://github.com/rust-lang/rust/commit/efe1f7ee9efb5da5613f2cff4f9b810d2d5992d4"}, {"sha": "30452d4cda331610418d4dc01023f2d1cdc1ee43", "url": "https://api.github.com/repos/rust-lang/rust/commits/30452d4cda331610418d4dc01023f2d1cdc1ee43", "html_url": "https://github.com/rust-lang/rust/commit/30452d4cda331610418d4dc01023f2d1cdc1ee43"}], "stats": {"total": 100, "additions": 53, "deletions": 47}, "files": [{"sha": "a5332c8d077154ccdc9416b63ffb3b8316860327", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=9de20198aedb3c3419ee503755e04bcc198d3a94", "patch": "@@ -66,26 +66,27 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n     }\n }\n \n-fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr,\n+                    storage: &mut libc::sockaddr_storage)\n+                    -> libc::socklen_t {\n     unsafe {\n-        let storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match ip_to_inaddr(addr.ip) {\n             InAddr(inaddr) => {\n-                let storage: *mut libc::sockaddr_in = mem::transmute(&storage);\n+                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = inaddr;\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n             In6Addr(inaddr) => {\n-                let storage: *mut libc::sockaddr_in6 = mem::transmute(&storage);\n+                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n                 (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n                 (*storage).sin6_port = htons(addr.port);\n                 (*storage).sin6_addr = inaddr;\n                 mem::size_of::<libc::sockaddr_in6>()\n             }\n         };\n-        return (storage, len);\n+        return len as libc::socklen_t;\n     }\n }\n \n@@ -277,9 +278,9 @@ impl TcpStream {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpStream::new(Inner::new(fd));\n \n-        let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *const _ as *const libc::sockaddr;\n-        let len = len as libc::socklen_t;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match timeout {\n             Some(timeout) => {\n@@ -457,9 +458,9 @@ impl TcpListener {\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n         let ret = TcpListener { inner: Inner::new(fd) };\n \n-        let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *const _ as *const libc::sockaddr;\n-        let len = len as libc::socklen_t;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         // On platforms with Berkeley-derived sockets, this allows\n         // to quickly rebind a socket, without needing to wait for\n@@ -566,9 +567,9 @@ impl UdpSocket {\n             write_deadline: 0,\n         };\n \n-        let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *const _ as *const libc::sockaddr;\n-        let len = len as libc::socklen_t;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n             -1 => Err(last_error()),\n@@ -656,9 +657,9 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     }\n \n     fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n-        let (dst, dstlen) = addr_to_sockaddr(dst);\n-        let dstp = &dst as *const _ as *const libc::sockaddr;\n-        let dstlen = dstlen as libc::socklen_t;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let dstlen = addr_to_sockaddr(dst, &mut storage);\n+        let dstp = &storage as *const _ as *const libc::sockaddr;\n \n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();"}, {"sha": "bc3f917a3dcc358f49a793a0f02a561b2cef1209", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=9de20198aedb3c3419ee503755e04bcc198d3a94", "patch": "@@ -29,12 +29,13 @@ fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     }\n }\n \n-fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> {\n+fn addr_to_sockaddr_un(addr: &CString,\n+                       storage: &mut libc::sockaddr_storage)\n+                       -> IoResult<libc::socklen_t> {\n     // the sun_path length is limited to SUN_LEN (with null)\n     assert!(mem::size_of::<libc::sockaddr_storage>() >=\n             mem::size_of::<libc::sockaddr_un>());\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let s: &mut libc::sockaddr_un = unsafe { mem::transmute(&mut storage) };\n+    let s = unsafe { &mut *(storage as *mut _ as *mut libc::sockaddr_un) };\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n@@ -53,7 +54,7 @@ fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint\n \n     // count the null terminator\n     let len = mem::size_of::<libc::sa_family_t>() + len + 1;\n-    return Ok((storage, len));\n+    return Ok(len as libc::socklen_t);\n }\n \n struct Inner {\n@@ -76,10 +77,10 @@ impl Drop for Inner {\n \n fn connect(addr: &CString, ty: libc::c_int,\n            timeout: Option<u64>) -> IoResult<Inner> {\n-    let (addr, len) = try!(addr_to_sockaddr_un(addr));\n+    let mut storage = unsafe { mem::zeroed() };\n+    let len = try!(addr_to_sockaddr_un(addr, &mut storage));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *const _ as *const libc::sockaddr;\n-    let len = len as libc::socklen_t;\n+    let addrp = &storage as *const _ as *const libc::sockaddr;\n \n     match timeout {\n         None => {\n@@ -96,11 +97,12 @@ fn connect(addr: &CString, ty: libc::c_int,\n }\n \n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n-    let (addr, len) = try!(addr_to_sockaddr_un(addr));\n+    let mut storage = unsafe { mem::zeroed() };\n+    let len = try!(addr_to_sockaddr_un(addr, &mut storage));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *const _;\n+    let addrp = &storage as *const _ as *const libc::sockaddr;\n     match unsafe {\n-        libc::bind(inner.fd, addrp as *const _, len as libc::socklen_t)\n+        libc::bind(inner.fd, addrp, len)\n     } {\n         -1 => Err(super::last_error()),\n         _  => Ok(inner)"}, {"sha": "16451f7edd9abbd75dac839790cc1ec6da807bfd", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de20198aedb3c3419ee503755e04bcc198d3a94/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=9de20198aedb3c3419ee503755e04bcc198d3a94", "patch": "@@ -75,17 +75,17 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+fn addr_to_sockaddr(addr: rtio::SocketAddr,\n+                    storage: &mut libc::sockaddr_storage)\n+                    -> libc::socklen_t {\n     unsafe {\n-        let mut storage: libc::sockaddr_storage = mem::zeroed();\n         let len = match addr.ip {\n             rtio::Ipv4Addr(a, b, c, d) => {\n                 let ip = (a as u32 << 24) |\n                          (b as u32 << 16) |\n                          (c as u32 <<  8) |\n                          (d as u32 <<  0);\n-                let storage: &mut libc::sockaddr_in =\n-                    mem::transmute(&mut storage);\n+                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = libc::in_addr {\n@@ -95,11 +95,10 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 mem::size_of::<libc::sockaddr_in>()\n             }\n             rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-                let storage: &mut libc::sockaddr_in6 =\n-                    mem::transmute(&mut storage);\n-                storage.sin6_family = libc::AF_INET6 as libc::sa_family_t;\n-                storage.sin6_port = htons(addr.port);\n-                storage.sin6_addr = libc::in6_addr {\n+                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n+                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n+                (*storage).sin6_port = htons(addr.port);\n+                (*storage).sin6_addr = libc::in6_addr {\n                     s6_addr: [\n                         htons(a),\n                         htons(b),\n@@ -114,7 +113,7 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 mem::size_of::<libc::sockaddr_in6>()\n             }\n         };\n-        return (storage, len);\n+        return len as libc::socklen_t\n     }\n }\n \n@@ -203,8 +202,9 @@ impl TcpWatcher {\n                    timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n         let tcp = TcpWatcher::new(io);\n         let cx = ConnectCtx { status: -1, task: None, timer: None };\n-        let (addr, _len) = addr_to_sockaddr(address);\n-        let addr_p = &addr as *const _ as *const libc::sockaddr;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let _len = addr_to_sockaddr(address, &mut storage);\n+        let addr_p = &storage as *const _ as *const libc::sockaddr;\n         cx.connect(tcp, timeout, io, |req, tcp, cb| {\n             unsafe { uvll::uv_tcp_connect(req.handle, tcp.handle, addr_p, cb) }\n         })\n@@ -361,10 +361,11 @@ impl TcpListener {\n             outgoing: tx,\n             incoming: rx,\n         };\n-        let (addr, _len) = addr_to_sockaddr(address);\n+        let mut storage = unsafe { mem::zeroed() };\n+        let _len = addr_to_sockaddr(address, &mut storage);\n         let res = unsafe {\n-            let addr_p = &addr as *const libc::sockaddr_storage;\n-            uvll::uv_tcp_bind(l.handle, addr_p as *const libc::sockaddr)\n+            let addr_p = &storage as *const _ as *const libc::sockaddr;\n+            uvll::uv_tcp_bind(l.handle, addr_p)\n         };\n         return match res {\n             0 => Ok(l.install()),\n@@ -513,10 +514,11 @@ impl UdpWatcher {\n         assert_eq!(unsafe {\n             uvll::uv_udp_init(io.uv_loop(), udp.handle)\n         }, 0);\n-        let (addr, _len) = addr_to_sockaddr(address);\n+        let mut storage = unsafe { mem::zeroed() };\n+        let _len = addr_to_sockaddr(address, &mut storage);\n         let result = unsafe {\n-            let addr_p = &addr as *const libc::sockaddr_storage;\n-            uvll::uv_udp_bind(udp.handle, addr_p as *const libc::sockaddr, 0u32)\n+            let addr_p = &storage as *const _ as *const libc::sockaddr;\n+            uvll::uv_udp_bind(udp.handle, addr_p, 0u32)\n         };\n         return match result {\n             0 => Ok(udp),\n@@ -614,8 +616,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         let guard = try!(self.write_access.grant(m));\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n-        let (addr, _len) = addr_to_sockaddr(dst);\n-        let addr_p = &addr as *const _ as *const libc::sockaddr;\n+        let mut storage = unsafe { mem::zeroed() };\n+        let _len = addr_to_sockaddr(dst, &mut storage);\n+        let addr_p = &storage as *const _ as *const libc::sockaddr;\n \n         // see comments in StreamWatcher::write for why we may allocate a buffer\n         // here."}]}