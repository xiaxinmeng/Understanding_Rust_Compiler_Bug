{"sha": "02f925100759256b87324ca07d7ff174330f60ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZjkyNTEwMDc1OTI1NmI4NzMyNGNhMDdkN2ZmMTc0MzMwZjYwYWQ=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-15T14:26:32Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-15T22:30:46Z"}, "message": "Refactor rewrite for ConrtolFlow", "tree": {"sha": "bd5bd3202d1c77103aa2a0fb88a30f30a2574833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd5bd3202d1c77103aa2a0fb88a30f30a2574833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f925100759256b87324ca07d7ff174330f60ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f925100759256b87324ca07d7ff174330f60ad", "html_url": "https://github.com/rust-lang/rust/commit/02f925100759256b87324ca07d7ff174330f60ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f925100759256b87324ca07d7ff174330f60ad/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5", "html_url": "https://github.com/rust-lang/rust/commit/02c1996e3e6ef6f692d3b05fcf0a01429874a8a5"}], "stats": {"total": 240, "additions": 156, "deletions": 84}, "files": [{"sha": "70e7e294aa33bc341230a57a28c9d7045a7fef40", "filename": "src/expr.rs", "status": "modified", "additions": 156, "deletions": 84, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/02f925100759256b87324ca07d7ff174330f60ad/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f925100759256b87324ca07d7ff174330f60ad/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=02f925100759256b87324ca07d7ff174330f60ad", "patch": "@@ -151,41 +151,17 @@ fn format_expr(\n                 shape,\n             )\n         }\n-        ast::ExprKind::While(ref cond, ref block, label) => {\n-            ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n-        }\n-        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_while(Some(pat), cond, block, label, expr.span).rewrite(context, shape)\n-        }\n-        ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_for(pat, cond, block, label, expr.span).rewrite(context, shape)\n-        }\n-        ast::ExprKind::Loop(ref block, label) => {\n-            ControlFlow::new_loop(block, label, expr.span).rewrite(context, shape)\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::ForLoop(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) => {\n+            to_control_flow(expr, expr_type).and_then(|control_flow| {\n+                control_flow.rewrite(context, shape)\n+            })\n         }\n         ast::ExprKind::Block(ref block) => block.rewrite(context, shape),\n-        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-            ControlFlow::new_if(\n-                cond,\n-                None,\n-                if_block,\n-                else_block.as_ref().map(|e| &**e),\n-                expr_type == ExprType::SubExpression,\n-                false,\n-                expr.span,\n-            ).rewrite(context, shape)\n-        }\n-        ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n-            ControlFlow::new_if(\n-                cond,\n-                Some(pat),\n-                if_block,\n-                else_block.as_ref().map(|e| &**e),\n-                expr_type == ExprType::SubExpression,\n-                false,\n-                expr.span,\n-            ).rewrite(context, shape)\n-        }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n             rewrite_match(context, cond, arms, shape, expr.span)\n         }\n@@ -856,6 +832,32 @@ impl Rewrite for ast::Stmt {\n     }\n }\n \n+// Rewrite condition if the given expression has one.\n+fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Option<String> {\n+    match expr.node {\n+        ast::ExprKind::Match(ref cond, _) => {\n+            // `match `cond` {`\n+            let cond_shape = match context.config.control_style() {\n+                Style::Legacy => try_opt!(shape.shrink_left(6).and_then(|s| s.sub_width(2))),\n+                Style::Rfc => try_opt!(shape.offset_left(8)),\n+            };\n+            cond.rewrite(context, cond_shape)\n+        }\n+        ast::ExprKind::Block(ref block) if block.stmts.len() == 1 => {\n+            stmt_expr(&block.stmts[0]).and_then(|e| rewrite_cond(context, e, shape))\n+        }\n+        _ => {\n+            to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n+                let alt_block_sep = String::from(\"\\n\") +\n+                    &shape.indent.block_only().to_string(context.config);\n+                control_flow\n+                    .rewrite_cond(context, shape, &alt_block_sep)\n+                    .and_then(|rw| Some(rw.0))\n+            })\n+        }\n+    }\n+}\n+\n // Abstraction over control flow expressions\n #[derive(Debug)]\n struct ControlFlow<'a> {\n@@ -873,6 +875,56 @@ struct ControlFlow<'a> {\n     span: Span,\n }\n \n+fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<ControlFlow<'a>> {\n+    match expr.node {\n+        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n+            Some(ControlFlow::new_if(\n+                cond,\n+                None,\n+                if_block,\n+                else_block.as_ref().map(|e| &**e),\n+                expr_type == ExprType::SubExpression,\n+                false,\n+                expr.span,\n+            ))\n+        }\n+        ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n+            Some(ControlFlow::new_if(\n+                cond,\n+                Some(pat),\n+                if_block,\n+                else_block.as_ref().map(|e| &**e),\n+                expr_type == ExprType::SubExpression,\n+                false,\n+                expr.span,\n+            ))\n+        }\n+        ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n+            Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n+        }\n+        ast::ExprKind::Loop(ref block, label) => Some(\n+            ControlFlow::new_loop(block, label, expr.span),\n+        ),\n+        ast::ExprKind::While(ref cond, ref block, label) => Some(ControlFlow::new_while(\n+            None,\n+            cond,\n+            block,\n+            label,\n+            expr.span,\n+        )),\n+        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n+            Some(ControlFlow::new_while(\n+                Some(pat),\n+                cond,\n+                block,\n+                label,\n+                expr.span,\n+            ))\n+        }\n+        _ => None,\n+    }\n+}\n+\n impl<'a> ControlFlow<'a> {\n     fn new_if(\n         cond: &'a ast::Expr,\n@@ -1021,9 +1073,13 @@ impl<'a> ControlFlow<'a> {\n     }\n }\n \n-impl<'a> Rewrite for ControlFlow<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n+impl<'a> ControlFlow<'a> {\n+    fn rewrite_cond(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        alt_block_sep: &str,\n+    ) -> Option<(String, usize)> {\n         let constr_shape = if self.nested_if {\n             // We are part of an if-elseif-else chain. Our constraints are tightened.\n             // 7 = \"} else \" .len()\n@@ -1067,38 +1123,13 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n-            if trial.is_some() &&\n-                trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width()\n-            {\n-                return trial;\n+            if let Some(cond_str) = trial {\n+                if cond_str.len() <= context.config.single_line_if_else_max_width() {\n+                    return Some((cond_str, 0));\n+                }\n             }\n         }\n \n-        let used_width = if pat_expr_string.contains('\\n') {\n-            last_line_width(&pat_expr_string)\n-        } else {\n-            // 2 = spaces after keyword and condition.\n-            label_string.len() + self.keyword.len() + pat_expr_string.len() + 2\n-        };\n-\n-        let block_width = shape.width.checked_sub(used_width).unwrap_or(0);\n-        // This is used only for the empty block case: `{}`. So, we use 1 if we know\n-        // we should avoid the single line case.\n-        let block_width = if self.else_block.is_some() || self.nested_if {\n-            min(1, block_width)\n-        } else {\n-            block_width\n-        };\n-\n-        let block_shape = Shape {\n-            width: block_width,\n-            ..shape\n-        };\n-        let mut block_context = context.clone();\n-        block_context.is_if_else_block = self.else_block.is_some();\n-\n-        let block_str = try_opt!(self.block.rewrite(&block_context, block_shape));\n-\n         let cond_span = if let Some(cond) = self.cond {\n             cond.span\n         } else {\n@@ -1123,34 +1154,75 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         let after_cond_comment =\n             extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n-        let alt_block_sep = String::from(\"\\n\") +\n-            &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n         } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n                    force_newline_brace\n         {\n-            alt_block_sep.as_str()\n+            alt_block_sep\n         } else {\n             \" \"\n         };\n \n-        let mut result =\n-            format!(\"{}{}{}{}{}{}\",\n-                                 label_string,\n-                                 self.keyword,\n-                                 between_kwd_cond_comment\n-                                     .as_ref()\n-                                     .map_or(if pat_expr_string.is_empty() ||\n-                                                pat_expr_string.starts_with('\\n') {\n-                                                 \"\"\n-                                             } else {\n-                                                 \" \"\n-                                             },\n-                                             |s| &**s),\n-                                 pat_expr_string,\n-                                 after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n-                                 block_str);\n+        let used_width = if pat_expr_string.contains('\\n') {\n+            last_line_width(&pat_expr_string)\n+        } else {\n+            // 2 = spaces after keyword and condition.\n+            label_string.len() + self.keyword.len() + pat_expr_string.len() + 2\n+        };\n+\n+        Some((\n+            format!(\n+                \"{}{}{}{}{}\",\n+                label_string,\n+                self.keyword,\n+                between_kwd_cond_comment.as_ref().map_or(\n+                    if pat_expr_string.is_empty() ||\n+                        pat_expr_string.starts_with('\\n')\n+                    {\n+                        \"\"\n+                    } else {\n+                        \" \"\n+                    },\n+                    |s| &**s,\n+                ),\n+                pat_expr_string,\n+                after_cond_comment.as_ref().map_or(block_sep, |s| &**s)\n+            ),\n+            used_width,\n+        ))\n+    }\n+}\n+\n+impl<'a> Rewrite for ControlFlow<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n+\n+        let alt_block_sep = String::from(\"\\n\") +\n+            &shape.indent.block_only().to_string(context.config);\n+        let (cond_str, used_width) = try_opt!(self.rewrite_cond(context, shape, &alt_block_sep));\n+        // If `used_width` is 0, it indicates that whole control flow is written in a single line.\n+        if used_width == 0 {\n+            return Some(cond_str);\n+        }\n+\n+        let block_width = shape.width.checked_sub(used_width).unwrap_or(0);\n+        // This is used only for the empty block case: `{}`. So, we use 1 if we know\n+        // we should avoid the single line case.\n+        let block_width = if self.else_block.is_some() || self.nested_if {\n+            min(1, block_width)\n+        } else {\n+            block_width\n+        };\n+        let block_shape = Shape {\n+            width: block_width,\n+            ..shape\n+        };\n+        let mut block_context = context.clone();\n+        block_context.is_if_else_block = self.else_block.is_some();\n+        let block_str = try_opt!(self.block.rewrite(&block_context, block_shape));\n+\n+        let mut result = format!(\"{}{}\", cond_str, block_str);\n \n         if let Some(else_block) = self.else_block {\n             let shape = Shape::indented(shape.indent, context.config);"}]}