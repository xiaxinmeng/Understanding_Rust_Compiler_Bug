{"sha": "2d81989974a134025be733115574bee8084095b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkODE5ODk5NzRhMTM0MDI1YmU3MzMxMTU1NzRiZWU4MDg0MDk1YjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-13T09:20:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-13T09:20:48Z"}, "message": "Auto merge of #54955 - RalfJung:miri-validate2, r=oli-obk\n\nmiri engine: Fix run-time validation\n\nThis fixes all false positives that came up when actually enabling this in miri.\n\nr? @oli-obk", "tree": {"sha": "1c3f94bae341c25a83fa00cf397e3ff96805bbef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c3f94bae341c25a83fa00cf397e3ff96805bbef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d81989974a134025be733115574bee8084095b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d81989974a134025be733115574bee8084095b4", "html_url": "https://github.com/rust-lang/rust/commit/2d81989974a134025be733115574bee8084095b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d81989974a134025be733115574bee8084095b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb3b47aa424447e20a7dd372fa3e883a62e5abb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3b47aa424447e20a7dd372fa3e883a62e5abb3", "html_url": "https://github.com/rust-lang/rust/commit/fb3b47aa424447e20a7dd372fa3e883a62e5abb3"}, {"sha": "6426cbe382f0379fe5c2ab987c94c4ad9dcc4c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/6426cbe382f0379fe5c2ab987c94c4ad9dcc4c42", "html_url": "https://github.com/rust-lang/rust/commit/6426cbe382f0379fe5c2ab987c94c4ad9dcc4c42"}], "stats": {"total": 452, "additions": 329, "deletions": 123}, "files": [{"sha": "abe736a4fe6137495924e2bb29fe366085c6f6aa", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -825,16 +825,6 @@ name = \"getopts\"\n version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"getset\"\n-version = \"0.0.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"proc-macro2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.13.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"git2\"\n version = \"0.7.5\"\n@@ -1303,7 +1293,7 @@ dependencies = [\n  \"compiletest_rs 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"vergen 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vergen 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3072,13 +3062,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"vergen\"\n-version = \"2.0.0\"\n+version = \"3.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chrono 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getset 0.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3245,7 +3234,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a70b146671de62ec8c8ed572219ca5d594d9b06c0b364d5e67b722fc559b48c\"\n \"checksum fwdansi 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34dd4c507af68d37ffef962063dfa1944ce0dd4d5b82043dbab1dabe088610c3\"\n \"checksum getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b900c08c1939860ce8b54dc6a89e26e00c04c380fd0e09796799bd7f12861e05\"\n-\"checksum getset 0.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"54c7f36a235738bb25904d6a2b3dbb28f6f5736cd3918c4bf80d6bb236200782\"\n \"checksum git2 0.7.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"591f8be1674b421644b6c030969520bc3fa12114d2eb467471982ed3e9584e71\"\n \"checksum git2-curl 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b502f6b1b467957403d168f0039e0c46fa6a1220efa2adaef25d5b267b5fe024\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n@@ -3419,7 +3407,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum utf8-ranges 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fd70f467df6810094968e2fce0ee1bd0e87157aceb026a8c083bcf5e25b9efe4\"\n \"checksum vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"def296d3eb3b12371b2c7d0e83bfe1403e4db2d7a0bba324a12b21c4ee13143d\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n-\"checksum vergen 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a16834fc61e1492c07dae49b6c14b55f8b1d43a5f5f9e9a2ecc063f47b9f93c\"\n+\"checksum vergen 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1b9696d96ec5d68984d060af80d7ba0ed4eb533978a0efb05ed4b8465f20d04f\"\n \"checksum version_check 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7716c242968ee87e5542f8021178248f267f295a5c4803beae8b8b7fd9bc6051\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum wait-timeout 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b9f3bf741a801531993db6478b95682117471f76916f5e690dd8d45395b09349\""}, {"sha": "2cfd058831f054da31b36d3ac8b66ee24df658cc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -33,7 +33,7 @@ use rustc::mir::interpret::{\n     Scalar, Allocation, AllocId, ConstValue,\n };\n use interpret::{self,\n-    Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    PlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind,\n     snapshot,\n };\n@@ -55,13 +55,14 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     let param_env = tcx.param_env(instance.def_id());\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n     // insert a stack frame so any queries have the correct substs\n+    // cannot use `push_stack_frame`; if we do `const_prop` explodes\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n         instance,\n         span,\n         mir,\n-        return_place: Place::null(tcx),\n+        return_place: None,\n         return_to_block: StackPopCleanup::Goto(None), // never pop\n         stmt: 0,\n     });\n@@ -82,7 +83,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         instance,\n         mir.span,\n         mir,\n-        Place::null(tcx),\n+        None,\n         StackPopCleanup::Goto(None), // never pop\n     )?;\n     Ok(ecx)\n@@ -187,7 +188,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         cid.instance,\n         mir.span,\n         mir,\n-        Place::Ptr(*ret),\n+        Some(ret.into()),\n         StackPopCleanup::None { cleanup: false },\n     )?;\n \n@@ -342,7 +343,11 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation<()>)>;\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n-    const ENFORCE_VALIDITY: bool = false; // for now, we don't\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n+        false // for now, we don't enforce validity\n+    }\n \n     fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "b5137e914dc91f629f8c8d36b9574eb76643287f", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -322,7 +322,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n-                self.copy_op(src, dest)\n+                let val = self.read_value(src)?;\n+                self.write_value(*val, dest)\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait"}, {"sha": "85a8376134aa472cd80115ca9d5fa5b0766e9af5", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -31,7 +31,7 @@ use rustc::mir::interpret::{\n use syntax::source_map::{self, Span};\n \n use super::{\n-    Value, Operand, MemPlace, MPlaceTy, Place, ScalarMaybeUndef,\n+    Value, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n     Memory, Machine\n };\n \n@@ -73,8 +73,9 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n     /// Work to perform when returning from this function\n     pub return_to_block: StackPopCleanup,\n \n-    /// The location where the result of the current stack frame should be written to.\n-    pub return_place: Place<Tag>,\n+    /// The location where the result of the current stack frame should be written to,\n+    /// and its layout in the caller.\n+    pub return_place: Option<PlaceTy<'tcx, Tag>>,\n \n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`.\n@@ -97,7 +98,8 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=()> {\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n-    /// that may never return).\n+    /// that may never return). Also store layout of return place so\n+    /// we can validate it at that layout.\n     Goto(Option<mir::BasicBlock>),\n     /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n     /// `cleanup` says whether locals are deallocated.  Static computation\n@@ -330,22 +332,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n-    /// Only the `meta` part of the place matters.\n+    /// Only the \"meta\" (metadata) part of the place matters.\n+    /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n         metadata: Option<Scalar<M::PointerTag>>,\n         layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n-        let metadata = match metadata {\n-            None => {\n-                assert!(!layout.is_unsized());\n-                return Ok(layout.size_and_align())\n-            }\n-            Some(metadata) => {\n-                assert!(layout.is_unsized());\n-                metadata\n-            }\n-        };\n+    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+        if !layout.is_unsized() {\n+            return Ok(Some(layout.size_and_align()));\n+        }\n         match layout.ty.sty {\n             ty::Adt(..) | ty::Tuple(..) => {\n                 // First get the size of all statically known fields.\n@@ -365,9 +361,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 );\n \n                 // Recurse to get the size of the dynamically sized field (must be\n-                // the last field).\n+                // the last field).  Can't have foreign types here, how would we\n+                // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1)?;\n-                let (unsized_size, unsized_align) = self.size_and_align_of(Some(metadata), field)?;\n+                let (unsized_size, unsized_align) = self.size_and_align_of(metadata, field)?\n+                    .expect(\"Fields cannot be extern types\");\n \n                 // FIXME (#26403, #27023): We should be adding padding\n                 // to `sized_size` (to accommodate the `unsized_align`\n@@ -394,18 +392,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 //\n                 //   `(size + (align-1)) & -align`\n \n-                Ok((size.abi_align(align), align))\n+                Ok(Some((size.abi_align(align), align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.to_ptr()?;\n+                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\").to_ptr()?;\n                 // the second entry in the vtable is the dynamic size of the object.\n-                self.read_size_and_align_from_vtable(vtable)\n+                Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len = metadata.to_usize(self)?;\n+                let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n                 let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                Ok((elem_size * len, align))\n+                Ok(Some((elem_size * len, align)))\n+            }\n+\n+            ty::Foreign(_) => {\n+                Ok(None)\n             }\n \n             _ => bug!(\"size_and_align_of::<{:?}> not supported\", layout.ty),\n@@ -415,7 +417,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn size_and_align_of_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n+    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n         self.size_and_align_of(mplace.meta, mplace.layout)\n     }\n \n@@ -424,7 +426,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         instance: ty::Instance<'tcx>,\n         span: source_map::Span,\n         mir: &'mir mir::Mir<'tcx>,\n-        return_place: Place<M::PointerTag>,\n+        return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n@@ -509,15 +511,38 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             }\n             StackPopCleanup::None { cleanup } => {\n                 if !cleanup {\n-                    // Leak the locals\n+                    // Leak the locals. Also skip validation, this is only used by\n+                    // static/const computation which does its own (stronger) final\n+                    // validation.\n                     return Ok(());\n                 }\n             }\n         }\n-        // deallocate all locals that are backed by an allocation\n+        // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n             self.deallocate_local(local)?;\n         }\n+        // Validate the return value.\n+        if let Some(return_place) = frame.return_place {\n+            if M::enforce_validity(self) {\n+                // Data got changed, better make sure it matches the type!\n+                // It is still possible that the return place held invalid data while\n+                // the function is running, but that's okay because nobody could have\n+                // accessed that same data from the \"outside\" to observe any broken\n+                // invariant -- that is, unless a function somehow has a ptr to\n+                // its return place... but the way MIR is currently generated, the\n+                // return place is always a local and then this cannot happen.\n+                self.validate_operand(\n+                    self.place_to_op(return_place)?,\n+                    &mut vec![],\n+                    None,\n+                    /*const_mode*/false,\n+                )?;\n+            }\n+        } else {\n+            // Uh, that shouln't happen... the function did not intend to return\n+            return err!(Unreachable);\n+        }\n \n         Ok(())\n     }"}, {"sha": "5fa0fef36935df82138ccb5b87358c2fc4626d63", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -151,11 +151,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 self.write_scalar(val, dest)?;\n             }\n             \"transmute\" => {\n-                // Go through an allocation, to make sure the completely different layouts\n-                // do not pose a problem.  (When the user transmutes through a union,\n-                // there will not be a layout mismatch.)\n-                let dest = self.force_allocation(dest)?;\n-                self.copy_op(args[0], dest.into())?;\n+                self.copy_op_transmute(args[0], dest)?;\n             }\n \n             _ => return Ok(false),"}, {"sha": "560698f3f57a22249661ac13f568ec6a4a5b0100", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -86,7 +86,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    const ENFORCE_VALIDITY: bool;\n+    fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs."}, {"sha": "4b0c0c3ee6173fdb8ce38c409012cdded050b52b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n-    /// However, this still checks that there are no relocations on the egdes.\n+    /// However, this still checks that there are no relocations on the *egdes*.\n     #[inline]\n     fn get_bytes_with_undef_and_ptr(\n         &self,\n@@ -842,6 +842,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    pub fn check_bytes(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        allow_ptr_and_undef: bool,\n+    ) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        if size.bytes() == 0 {\n+            self.check_align(ptr, align)?;\n+            return Ok(());\n+        }\n+        let ptr = ptr.to_ptr()?;\n+        // Check bounds, align and relocations on the edges\n+        self.get_bytes_with_undef_and_ptr(ptr, size, align)?;\n+        // Check undef and ptr\n+        if !allow_ptr_and_undef {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(ptr, size)?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1, 1).unwrap();"}, {"sha": "e4055947b6421ffaee8b4b3438b2003da87ce19b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 141, "deletions": 38, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -256,12 +256,6 @@ impl<'tcx, Tag: ::std::fmt::Debug> Place<Tag> {\n }\n \n impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n-    /// Produces a Place that will error if attempted to be read from or written to\n-    #[inline]\n-    pub fn null(cx: impl HasDataLayout, layout: TyLayout<'tcx>) -> Self {\n-        PlaceTy { place: Place::from_scalar_ptr(Scalar::ptr_null(cx), layout.align), layout }\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n@@ -325,9 +319,9 @@ where\n         // Offset may need adjustment for unsized fields\n         let (meta, offset) = if field_layout.is_unsized() {\n             // re-use parent metadata to determine dynamic field layout\n-            let (_, align) = self.size_and_align_of(base.meta, field_layout)?;\n+            let (_, align) = self.size_and_align_of(base.meta, field_layout)?\n+                .expect(\"Fields cannot be extern types\");\n             (base.meta, offset.abi_align(align))\n-\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n@@ -565,9 +559,15 @@ where\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => PlaceTy {\n-                place: self.frame().return_place,\n-                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+                Some(return_place) =>\n+                    // We use our layout to verify our assumption; caller will validate\n+                    // their layout on return.\n+                    PlaceTy {\n+                        place: *return_place,\n+                        layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+                    },\n+                None => return err!(InvalidNullPointerUsage),\n             },\n             Local(local) => PlaceTy {\n                 place: Place::Local {\n@@ -599,18 +599,47 @@ where\n     }\n \n     /// Write a value to a place\n+    #[inline(always)]\n     pub fn write_value(\n         &mut self,\n         src_val: Value<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n-        // Check that the value actually is okay for that type\n-        if M::ENFORCE_VALIDITY {\n-            // Something changed somewhere, better make sure it matches the type!\n-            let op = OpTy { op: Operand::Immediate(src_val), layout: dest.layout };\n-            self.validate_operand(op, &mut vec![], None, /*const_mode*/false)?;\n+        self.write_value_no_validate(src_val, dest)?;\n+\n+        if M::enforce_validity(self) {\n+            // Data got changed, better make sure it matches the type!\n+            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Write a value to a place.\n+    /// If you use this you are responsible for validating that things got copied at the\n+    /// right type.\n+    fn write_value_no_validate(\n+        &mut self,\n+        src_val: Value<M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        if cfg!(debug_assertions) {\n+            // This is a very common path, avoid some checks in release mode\n+            assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n+            match src_val {\n+                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n+                    assert_eq!(self.pointer_size(), dest.layout.size,\n+                        \"Size mismatch when writing pointer\"),\n+                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                    assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n+                        \"Size mismatch when writing bits\"),\n+                Value::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size\n+                Value::ScalarPair(_, _) => {\n+                    // FIXME: Can we check anything here?\n+                }\n+            }\n         }\n+        trace!(\"write_value: {:?} <- {:?}: {}\", *dest, src_val, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n         // but not factored as a separate function.\n@@ -627,15 +656,16 @@ where\n             },\n             Place::Ptr(mplace) => mplace, // already in memory\n         };\n+        let dest = MPlaceTy { mplace, layout: dest.layout };\n \n         // This is already in memory, write there.\n-        let dest = MPlaceTy { mplace, layout: dest.layout };\n-        self.write_value_to_mplace(src_val, dest)\n+        self.write_value_to_mplace_no_validate(src_val, dest)\n     }\n \n-    /// Write a value to memory. This does NOT do validation, so you better had already\n-    /// done that before calling this!\n-    fn write_value_to_mplace(\n+    /// Write a value to memory.\n+    /// If you use this you are responsible for validating that things git copied at the\n+    /// right type.\n+    fn write_value_to_mplace_no_validate(\n         &mut self,\n         value: Value<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n@@ -653,8 +683,17 @@ where\n         }\n \n         let ptr = ptr.to_ptr()?;\n+        // FIXME: We should check that there are dest.layout.size many bytes available in\n+        // memory.  The code below is not sufficient, with enough padding it might not\n+        // cover all the bytes!\n         match value {\n             Value::Scalar(scalar) => {\n+                match dest.layout.abi {\n+                    layout::Abi::Scalar(_) => {}, // fine\n+                    _ => bug!(\"write_value_to_mplace: invalid Scalar layout: {:#?}\",\n+                            dest.layout)\n+                }\n+\n                 self.memory.write_scalar(\n                     ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n                 )\n@@ -670,45 +709,109 @@ where\n                 let b_offset = a_size.abi_align(b_align);\n                 let b_ptr = ptr.offset(b_offset, &self)?.into();\n \n+                // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n+                // but that does not work: We could be a newtype around a pair, then the\n+                // fields do not match the `ScalarPair` components.\n+\n                 self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n                 self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n             }\n         }\n     }\n \n-    /// Copy the data from an operand to a place\n+    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Use `copy_op_transmute` if the layouts could disagree.\n+    #[inline(always)]\n     pub fn copy_op(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+        self.copy_op_no_validate(src, dest)?;\n+\n+        if M::enforce_validity(self) {\n+            // Data got changed, better make sure it matches the type!\n+            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Also, if you use this you are responsible for validating that things git copied at the\n+    /// right type.\n+    fn copy_op_no_validate(\n+        &mut self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n             \"Cannot copy unsized data\");\n-        assert_eq!(src.layout.size, dest.layout.size,\n-            \"Size mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        // We do NOT compare the types for equality, because well-typed code can\n+        // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n+        assert!(src.layout.details == dest.layout.details,\n+            \"Layout mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let (src_ptr, src_align) = match self.try_read_value(src)? {\n-            Ok(src_val) =>\n-                // Yay, we got a value that we can write directly.  We write with the\n-                // *source layout*, because that was used to load, and if they do not match\n-                // this is a transmute we want to support.\n-                return self.write_value(src_val, PlaceTy { place: *dest, layout: src.layout }),\n-            Err(mplace) => mplace.to_scalar_ptr_align(),\n+        let src = match self.try_read_value(src)? {\n+            Ok(src_val) => {\n+                // Yay, we got a value that we can write directly.\n+                return self.write_value_no_validate(src_val, dest);\n+            }\n+            Err(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n-        trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n+        trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n+\n         let dest = self.force_allocation(dest)?;\n+        let (src_ptr, src_align) = src.to_scalar_ptr_align();\n         let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n         self.memory.copy(\n             src_ptr, src_align,\n             dest_ptr, dest_align,\n-            src.layout.size, false\n+            dest.layout.size, false\n+        )?;\n+\n+        Ok(())\n+    }\n+\n+    /// Copy the data from an operand to a place.  The layouts may disagree, but they must\n+    /// have the same size.\n+    pub fn copy_op_transmute(\n+        &mut self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        if src.layout.details == dest.layout.details {\n+            // Fast path: Just use normal `copy_op`\n+            return self.copy_op(src, dest);\n+        }\n+        // We still require the sizes to match\n+        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot copy unsized data\");\n+        assert!(src.layout.size == dest.layout.size,\n+            \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+\n+        // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n+        // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n+        // We have to write them to `dest` at the offsets they were *read at*, which is\n+        // not necessarily the same as the offsets in `dest.layout`!\n+        // Hence we do the copy with the source layout on both sides.  We also make sure to write\n+        // into memory, because if `dest` is a local we would not even have a way to write\n+        // at the `src` offsets; the fact that we came from a different layout would\n+        // just be lost.\n+        let dest = self.force_allocation(dest)?;\n+        self.copy_op_no_validate(\n+            src,\n+            PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n         )?;\n-        if M::ENFORCE_VALIDITY {\n-            // Something changed somewhere, better make sure it matches the type!\n+\n+        if M::enforce_validity(self) {\n+            // Data got changed, better make sure it matches the type!\n             self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n         }\n+\n         Ok(())\n     }\n \n@@ -734,7 +837,7 @@ where\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n                         // We don't have to validate as we can assume the local\n                         // was already valid for its type.\n-                        self.write_value_to_mplace(value, ptr)?;\n+                        self.write_value_to_mplace_no_validate(value, ptr)?;\n                         let mplace = ptr.mplace;\n                         // Update the local\n                         *self.stack[frame].locals[local].access_mut()? ="}, {"sha": "11d5785bc565dbd502a54eb7711c0b96fca8ca94", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -337,7 +337,7 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n-    return_place: Place<(), AllocIdSnapshot<'a>>,\n+    return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n     locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n@@ -362,7 +362,7 @@ impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir,\n         } = self;\n \n         (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n+        (return_place.as_ref().map(|r| &**r), locals, block, stmt).hash_stable(hcx, hasher);\n     }\n }\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n@@ -388,7 +388,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             block,\n             stmt: *stmt,\n-            return_place: return_place.snapshot(ctx),\n+            return_place: return_place.map(|r| r.snapshot(ctx)),\n             locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n         }\n     }"}, {"sha": "a339fa34ae1f64cc6fd45cc176c788f5cd8dad4f", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Value, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -39,7 +39,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.dump_place(self.frame().return_place);\n+                self.frame().return_place.map(|r| self.dump_place(*r));\n                 self.pop_stack_frame()?\n             }\n \n@@ -222,7 +222,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         if !Self::check_argument_compat(caller_arg.layout, callee_arg.layout) {\n             return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n         }\n-        self.copy_op(caller_arg, callee_arg)\n+        // We allow some transmutes here\n+        self.copy_op_transmute(caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n@@ -285,15 +286,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     None => return Ok(()),\n                 };\n \n-                let return_place = match dest {\n-                    Some(place) => *place,\n-                    None => Place::null(&self), // any access will error. good!\n-                };\n                 self.push_stack_frame(\n                     instance,\n                     span,\n                     mir,\n-                    return_place,\n+                    dest,\n                     StackPopCleanup::Goto(ret),\n                 )?;\n \n@@ -382,10 +379,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             ));\n                         }\n                     } else {\n-                        // FIXME: The caller thinks this function cannot return. How do\n-                        // we verify that the callee agrees?\n-                        // On the plus side, the the callee ever writes to its return place,\n-                        // that will be detected as UB (because we set that to NULL above).\n+                        let callee_layout =\n+                            self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?;\n+                        if !callee_layout.abi.is_uninhabited() {\n+                            return err!(FunctionRetMismatch(\n+                                self.tcx.types.never, callee_layout.ty\n+                            ));\n+                        }\n                     }\n                     Ok(())\n                 })();\n@@ -451,14 +451,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n-        let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n+        let dest = MPlaceTy::dangling(self.layout_of(ty)?, &self);\n \n         self.eval_fn_call(\n             instance,\n             span,\n             Abi::Rust,\n             &[arg],\n-            Some(dest),\n+            Some(dest.into()),\n             Some(target),\n         )\n     }"}, {"sha": "c446980d04995025ed3e8bbae9a604100af6ea2e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -208,7 +208,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // for safe ptrs, also check the ptr values itself\n                 if !ty.is_unsafe_ptr() {\n                     // Make sure this is non-NULL and aligned\n-                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?;\n+                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?\n+                        // for the purpose of validity, consider foreign types to have\n+                        // alignment and size determined by the layout (size will be 0,\n+                        // alignment should take attributes into account).\n+                        .unwrap_or_else(|| place.layout.size_and_align());\n                     match self.memory.check_align(place.ptr, align) {\n                         Ok(_) => {},\n                         Err(err) => match err.kind {\n@@ -218,7 +222,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                 return validation_failure!(\"unaligned reference\", path),\n                             _ =>\n                                 return validation_failure!(\n-                                    \"dangling (deallocated) reference\", path\n+                                    \"dangling (out-of-bounds) reference (might be NULL at \\\n+                                     run-time)\",\n+                                    path\n                                 ),\n                         }\n                     }\n@@ -490,9 +496,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     }\n                     // Special handling for arrays/slices of builtin integer types\n                     ty::Array(tys, ..) | ty::Slice(tys) if {\n-                        // This optimization applies only for integer types\n+                        // This optimization applies only for integer and floating point types\n+                        // (i.e., types that can hold arbitrary bytes).\n                         match tys.sty {\n-                            ty::Int(..) | ty::Uint(..) => true,\n+                            ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n                             _ => false,\n                         }\n                     } => {\n@@ -504,9 +511,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // This is the size in bytes of the whole array.\n                         let size = Size::from_bytes(ty_size * len);\n \n-                        match self.memory.read_bytes(dest.ptr, size) {\n+                        // In run-time mode, we accept pointers in here.  This is actually more\n+                        // permissive than a per-element check would be, e.g. we accept\n+                        // an &[u8] that contains a pointer even though bytewise checking would\n+                        // reject it.  However, that's good: We don't inherently want\n+                        // to reject those pointers, we just do not have the machinery to\n+                        // talk about parts of a pointer.\n+                        // We also accept undef, for consistency with the type-based checks.\n+                        match self.memory.check_bytes(\n+                            dest.ptr,\n+                            size,\n+                            /*allow_ptr_and_undef*/!const_mode,\n+                        ) {\n                             // In the happy case, we needn't check anything else.\n-                            Ok(_) => {},\n+                            Ok(()) => {},\n                             // Some error happened, try to provide a more detailed description.\n                             Err(err) => {\n                                 // For some errors we might be able to provide extra information\n@@ -553,11 +571,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n-                    PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n+                if let Some(upvar) = self.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n+                    PathElem::ClosureVar(upvar.debug_name)\n                 } else {\n-                    // The closure is not local, so we cannot get the name\n+                    // Sometimes the index is beyond the number of freevars (seen\n+                    // for a generator).\n                     PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n                 }\n             }"}, {"sha": "584dc0691698ae520ee7a4e90f44804da0e797e8", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -21,6 +21,9 @@ const NULL: &u16 = unsafe { mem::transmute(0usize) };\n const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n //~^ ERROR this constant likely exhibits undefined behavior\n \n+const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n //~^ ERROR this constant likely exhibits undefined behavior\n "}, {"sha": "8bcb6d190b89a8b3e7a977b342cdd6b95bad0f68", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -25,11 +25,19 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-ref.rs:24:1\n    |\n+LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a raw memory access tried to access part of a pointer value as raw bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-ref.rs:27:1\n+   |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "309211d19d461fc321234fc8fdd7286e2e62ea2e", "filename": "src/test/ui/consts/const-eval/ub-upvars.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_transmute,const_let)]\n+\n+use std::mem;\n+\n+const BAD_UPVAR: &FnOnce() = &{ //~ ERROR this constant likely exhibits undefined behavior\n+    let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n+    let another_var = 13;\n+    move || { let _ = bad_ref; let _ = another_var; }\n+};\n+\n+fn main() {}"}, {"sha": "3ae140d6e1c2003f3134ffeaf7e930d098d869ce", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d81989974a134025be733115574bee8084095b4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -0,0 +1,15 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-upvars.rs:15:1\n+   |\n+LL | / const BAD_UPVAR: &FnOnce() = &{ //~ ERROR this constant likely exhibits undefined behavior\n+LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n+LL | |     let another_var = 13;\n+LL | |     move || { let _ = bad_ref; let _ = another_var; }\n+LL | | };\n+   | |__^ type validation failed: encountered 0 at .<deref>.<closure-var(bad_ref)>, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "26f9d617c347185433b77c481a5c50c55d9b72ce", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=2d81989974a134025be733115574bee8084095b4", "patch": "@@ -1 +1 @@\n-Subproject commit cc275c63a90d4bea394e76607b2e10611eb1be36\n+Subproject commit 26f9d617c347185433b77c481a5c50c55d9b72ce"}]}