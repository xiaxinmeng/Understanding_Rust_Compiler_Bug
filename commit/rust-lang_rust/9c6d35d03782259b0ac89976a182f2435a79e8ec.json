{"sha": "9c6d35d03782259b0ac89976a182f2435a79e8ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNmQzNWQwMzc4MjI1OWIwYWM4OTk3NmExODJmMjQzNWE3OWU4ZWM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-20T15:23:46Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-15T17:22:32Z"}, "message": "evaluate projections outside the outer probe in recursive evaluation", "tree": {"sha": "81e6b4d981f17b317bb29c7476d7db2d20418770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e6b4d981f17b317bb29c7476d7db2d20418770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c6d35d03782259b0ac89976a182f2435a79e8ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6d35d03782259b0ac89976a182f2435a79e8ec", "html_url": "https://github.com/rust-lang/rust/commit/9c6d35d03782259b0ac89976a182f2435a79e8ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c6d35d03782259b0ac89976a182f2435a79e8ec/comments", "author": null, "committer": null, "parents": [{"sha": "f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418", "html_url": "https://github.com/rust-lang/rust/commit/f37b4fe84fa2a2aac501a5e9a2f2361ffead0418"}], "stats": {"total": 233, "additions": 77, "deletions": 156}, "files": [{"sha": "d4154b5953770ace920f2beaeb6f0c37eb564bca", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 46, "deletions": 156, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/9c6d35d03782259b0ac89976a182f2435a79e8ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6d35d03782259b0ac89976a182f2435a79e8ec/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9c6d35d03782259b0ac89976a182f2435a79e8ec", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! See `README.md` for high-level documentation\n-#![allow(dead_code)] // FIXME -- just temporarily\n \n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n@@ -190,7 +189,6 @@ pub enum MethodMatchedData {\n /// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n-    PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(DefId),\n@@ -403,8 +401,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-            .may_apply()\n+        self.infcx.probe(|_| {\n+            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+                .may_apply()\n+        })\n     }\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n@@ -415,7 +415,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            match self.evaluate_predicate_recursively(stack, obligation) {\n+            let eval = self.evaluate_predicate_recursively(stack, obligation);\n+            debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n+                   obligation, eval);\n+            match eval {\n                 EvaluatedToErr => { return EvaluatedToErr; }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n                 EvaluatedToUnknown => {\n@@ -454,10 +457,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::Equate(ref p) => {\n-                let result = self.infcx.probe(|_| {\n-                    self.infcx.equality_predicate(obligation.cause.span, p)\n-                });\n-                match result {\n+                // does this code ever run?\n+                match self.infcx.equality_predicate(obligation.cause.span, p) {\n                     Ok(()) => EvaluatedToOk,\n                     Err(_) => EvaluatedToErr\n                 }\n@@ -489,21 +490,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::Projection(ref data) => {\n-                self.infcx.probe(|_| {\n-                    let project_obligation = obligation.with(data.clone());\n-                    match project::poly_project_and_unify_type(self, &project_obligation) {\n-                        Ok(Some(subobligations)) => {\n-                            self.evaluate_predicates_recursively(previous_stack,\n-                                                                 subobligations.iter())\n-                        }\n-                        Ok(None) => {\n-                            EvaluatedToAmbig\n-                        }\n-                        Err(_) => {\n-                            EvaluatedToErr\n-                        }\n+                let project_obligation = obligation.with(data.clone());\n+                match project::poly_project_and_unify_type(self, &project_obligation) {\n+                    Ok(Some(subobligations)) => {\n+                        self.evaluate_predicates_recursively(previous_stack,\n+                                                             subobligations.iter())\n                     }\n-                })\n+                    Ok(None) => {\n+                        EvaluatedToAmbig\n+                    }\n+                    Err(_) => {\n+                        EvaluatedToErr\n+                    }\n+                }\n             }\n         }\n     }\n@@ -610,40 +609,36 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match self.candidate_from_obligation(stack) {\n-            Ok(Some(c)) => self.winnow_candidate(stack, &c),\n+            Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Ok(None) => EvaluatedToAmbig,\n             Err(..) => EvaluatedToErr\n         }\n     }\n \n-    /// Evaluates whether the impl with id `impl_def_id` could be applied to the self type\n-    /// `obligation_self_ty`. This can be used either for trait or inherent impls.\n-    pub fn evaluate_impl(&mut self,\n-                         impl_def_id: DefId,\n-                         obligation: &TraitObligation<'tcx>)\n-                         -> bool\n+    /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n+    /// obligations are met. Returns true if `candidate` remains viable after this further\n+    /// scrutiny.\n+    fn evaluate_candidate<'o>(&mut self,\n+                              stack: &TraitObligationStack<'o, 'tcx>,\n+                              candidate: &SelectionCandidate<'tcx>)\n+                              -> EvaluationResult\n     {\n-        debug!(\"evaluate_impl(impl_def_id={:?}, obligation={:?})\",\n-               impl_def_id,\n-               obligation);\n-\n-        self.infcx.probe(|snapshot| {\n-            match self.match_impl(impl_def_id, obligation, snapshot) {\n-                Ok((substs, skol_map)) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id,\n-                                                       substs,\n-                                                       obligation.cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       skol_map,\n-                                                       snapshot);\n-                    self.winnow_selection(TraitObligationStackList::empty(),\n-                                          VtableImpl(vtable_impl)).may_apply()\n-                }\n-                Err(()) => {\n-                    false\n+        debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n+               stack.obligation.recursion_depth, candidate);\n+        let result = self.infcx.probe(|_| {\n+            let candidate = (*candidate).clone();\n+            match self.confirm_candidate(stack.obligation, candidate) {\n+                Ok(selection) => {\n+                    self.evaluate_predicates_recursively(\n+                        stack.list(),\n+                        selection.nested_obligations().iter())\n                 }\n+                Err(..) => EvaluatedToErr\n             }\n-        })\n+        });\n+        debug!(\"evaluate_candidate: depth={} result={:?}\",\n+               stack.obligation.recursion_depth, result);\n+        result\n     }\n \n     fn pick_evaluation_cache(&self) -> &EvaluationCache<'tcx> {\n@@ -779,7 +774,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Instead, we select the right impl now but report `Bar does\n         // not implement Clone`.\n         if candidates.len() > 1 {\n-            candidates.retain(|c| self.winnow_candidate(stack, c).may_apply())\n+            candidates.retain(|c| self.evaluate_candidate(stack, c).may_apply())\n         }\n \n         // If there are STILL multiple candidate, we can further reduce\n@@ -1184,9 +1179,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(obligations) => {\n                     self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n-                Err(()) => {\n-                    EvaluatedToErr\n-                }\n+                Err(()) => EvaluatedToErr\n             }\n         })\n     }\n@@ -1525,37 +1518,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // attempt to evaluate recursive bounds to see if they are\n     // satisfied.\n \n-    /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n-    /// obligations are met. Returns true if `candidate` remains viable after this further\n-    /// scrutiny.\n-    fn winnow_candidate<'o>(&mut self,\n-                            stack: &TraitObligationStack<'o, 'tcx>,\n-                            candidate: &SelectionCandidate<'tcx>)\n-                            -> EvaluationResult\n-    {\n-        debug!(\"winnow_candidate: candidate={:?}\", candidate);\n-        let result = self.infcx.probe(|_| {\n-            let candidate = (*candidate).clone();\n-            match self.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => self.winnow_selection(stack.list(),\n-                                                       selection),\n-                Err(..) => EvaluatedToErr\n-            }\n-        });\n-        debug!(\"winnow_candidate depth={} result={:?}\",\n-               stack.obligation.recursion_depth, result);\n-        result\n-    }\n-\n-    fn winnow_selection<'o>(&mut self,\n-                            stack: TraitObligationStackList<'o,'tcx>,\n-                            selection: Selection<'tcx>)\n-                            -> EvaluationResult\n-    {\n-        self.evaluate_predicates_recursively(stack,\n-                                             selection.nested_obligations().iter())\n-    }\n-\n     /// Returns true if `candidate_i` should be dropped in favor of\n     /// `candidate_j`.  Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n@@ -1581,9 +1543,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\");\n                 }\n-                &PhantomFnCandidate => {\n-                    self.tcx().sess.bug(\"PhantomFn didn't short-circuit selection\");\n-                }\n                 &ImplCandidate(..) |\n                 &ClosureCandidate(..) |\n                 &FnPointerCandidate(..) |\n@@ -2013,7 +1972,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n-            PhantomFnCandidate |\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: vec![] }))\n             }\n@@ -2788,74 +2746,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Determines whether the self type declared against\n-    /// `impl_def_id` matches `obligation_self_ty`. If successful,\n-    /// returns the substitutions used to make them match. See\n-    /// `match_impl()`. For example, if `impl_def_id` is declared\n-    /// as:\n-    ///\n-    ///    impl<T:Copy> Foo for Box<T> { ... }\n-    ///\n-    /// and `obligation_self_ty` is `int`, we'd get back an `Err(_)`\n-    /// result. But if `obligation_self_ty` were `Box<int>`, we'd get\n-    /// back `Ok(T=int)`.\n-    fn match_inherent_impl(&mut self,\n-                           impl_def_id: DefId,\n-                           obligation_cause: &ObligationCause,\n-                           obligation_self_ty: Ty<'tcx>)\n-                           -> Result<Substs<'tcx>,()>\n-    {\n-        // Create fresh type variables for each type parameter declared\n-        // on the impl etc.\n-        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n-                                                         obligation_cause.span,\n-                                                         impl_def_id);\n-\n-        // Find the self type for the impl.\n-        let impl_self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n-        let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n-\n-        debug!(\"match_impl_self_types(obligation_self_ty={:?}, impl_self_ty={:?})\",\n-               obligation_self_ty,\n-               impl_self_ty);\n-\n-        match self.match_self_types(obligation_cause,\n-                                    impl_self_ty,\n-                                    obligation_self_ty) {\n-            Ok(()) => {\n-                debug!(\"Matched impl_substs={:?}\", impl_substs);\n-                Ok(impl_substs)\n-            }\n-            Err(()) => {\n-                debug!(\"NoMatch\");\n-                Err(())\n-            }\n-        }\n-    }\n-\n-    fn match_self_types(&mut self,\n-                        cause: &ObligationCause,\n-\n-                        // The self type provided by the impl/caller-obligation:\n-                        provided_self_ty: Ty<'tcx>,\n-\n-                        // The self type the obligation is for:\n-                        required_self_ty: Ty<'tcx>)\n-                        -> Result<(),()>\n-    {\n-        // FIXME(#5781) -- equating the types is stronger than\n-        // necessary. Should consider variance of trait w/r/t Self.\n-\n-        let origin = infer::RelateSelfType(cause.span);\n-        match self.infcx.eq_types(false,\n-                                  origin,\n-                                  provided_self_ty,\n-                                  required_self_ty) {\n-            Ok(()) => Ok(()),\n-            Err(_) => Err(()),\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n "}, {"sha": "4b52378e5088932e4db0cefa0af93ba6c830e14d", "filename": "src/test/run-pass/coherence-rfc447-constrained.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c6d35d03782259b0ac89976a182f2435a79e8ec/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c6d35d03782259b0ac89976a182f2435a79e8ec/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-rfc447-constrained.rs?ref=9c6d35d03782259b0ac89976a182f2435a79e8ec", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that trait matching can handle impls whose types are only\n+// constrained by a projection.\n+\n+trait IsU32 {}\n+impl IsU32 for u32 {}\n+\n+trait Mirror { type Image: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type Image = T; }\n+\n+trait Bar {}\n+impl<U: Mirror, V: Mirror<Image=L>, L: Mirror<Image=U>> Bar for V\n+    where U::Image: IsU32 {}\n+\n+trait Foo { fn name() -> &'static str; }\n+impl Foo for u64 { fn name() -> &'static str { \"u64\" } }\n+impl<T: Bar> Foo for T { fn name() -> &'static str { \"Bar\" }}\n+\n+fn main() {\n+    assert_eq!(<u64 as Foo>::name(), \"u64\");\n+    assert_eq!(<u32 as Foo>::name(), \"Bar\");\n+}"}]}