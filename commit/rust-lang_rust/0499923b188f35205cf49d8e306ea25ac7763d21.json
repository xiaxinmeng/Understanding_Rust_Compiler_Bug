{"sha": "0499923b188f35205cf49d8e306ea25ac7763d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OTk5MjNiMTg4ZjM1MjA1Y2Y0OWQ4ZTMwNmVhMjVhYzc3NjNkMjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-12T07:24:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-12T09:23:56Z"}, "message": "more informative error message from invalid_value lint", "tree": {"sha": "b52cec018d72b7a96c6550b57f01947ec96c84cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52cec018d72b7a96c6550b57f01947ec96c84cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0499923b188f35205cf49d8e306ea25ac7763d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0499923b188f35205cf49d8e306ea25ac7763d21", "html_url": "https://github.com/rust-lang/rust/commit/0499923b188f35205cf49d8e306ea25ac7763d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0499923b188f35205cf49d8e306ea25ac7763d21/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f8043d44a8925e469daf5c10e2630c80c2a7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "html_url": "https://github.com/rust-lang/rust/commit/72f8043d44a8925e469daf5c10e2630c80c2a7d4"}], "stats": {"total": 298, "additions": 224, "deletions": 74}, "files": [{"sha": "bb2a5cab7d9bfbe248e4fd35fd8b87a3c8ebb94d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0499923b188f35205cf49d8e306ea25ac7763d21", "patch": "@@ -21,6 +21,8 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n+use std::fmt::Write;\n+\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty, TyCtxt, layout::VariantIdx};\n@@ -1877,41 +1879,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n         const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n \n-        /// Return `false` only if we are sure this type does *not*\n+        /// Information about why a type cannot be initialized this way.\n+        /// Contains an error message and optionally a span to point at.\n+        type InitError = (String, Option<Span>);\n+\n+        /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_maybe_allows_zero_init<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n-                Ref(..) | FnPtr(..) | Never => false,\n-                Adt(..) if ty.is_box() => false,\n+                Ref(..) => Some((format!(\"References must be non-null\"), None)),\n+                Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n+                FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n+                Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n                 // Recurse for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     match adt_def.variants.len() {\n-                        0 => false, // Uninhabited enum!\n+                        0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n                         1 => {\n                             // Struct, or enum with exactly one variant.\n                             // Proceed recursively, check all fields.\n                             let variant = &adt_def.variants[VariantIdx::from_u32(0)];\n-                            variant.fields.iter().all(|field| {\n-                                ty_maybe_allows_zero_init(\n+                            variant.fields.iter().find_map(|field| {\n+                                ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n-                                )\n+                                ).map(|(mut msg, span)| if span.is_none() {\n+                                    // Point to this field, should be helpful for figuring\n+                                    // out where the source of the error is.\n+                                    let span = tcx.def_span(field.did);\n+                                    write!(&mut msg, \" (in this {} field)\", adt_def.descr())\n+                                        .unwrap();\n+                                    (msg, Some(span))\n+                                } else {\n+                                    // Just forward.\n+                                    (msg, span)\n+                                })\n                             })\n                         }\n-                        _ => true, // Conservative fallback for multi-variant enum.\n+                        _ => None, // Conservative fallback for multi-variant enum.\n                     }\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().all(|field| ty_maybe_allows_zero_init(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n                 }\n                 // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n                 // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n                 //        `char`, and any multivariant enum.\n                 // Conservative fallback.\n-                _ => true,\n+                _ => None,\n             }\n         }\n \n@@ -1925,9 +1943,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                         // using zeroed or uninitialized memory.\n                         // We are extremely conservative with what we warn about.\n                         let conjured_ty = cx.tables.expr_ty(expr);\n-\n-                        if !ty_maybe_allows_zero_init(cx.tcx, conjured_ty) {\n-                            cx.struct_span_lint(\n+                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n+                            let mut err = cx.struct_span_lint(\n                                 INVALID_VALUE,\n                                 expr.span,\n                                 &format!(\n@@ -1939,11 +1956,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                         \"being left uninitialized\"\n                                     }\n                                 ),\n-                            )\n-                            .note(\"this means that this code causes undefined behavior \\\n-                                when executed\")\n-                            .help(\"use `MaybeUninit` instead\")\n-                            .emit();\n+                            );\n+                            err.span_label(expr.span,\n+                                \"this code causes undefined behavior when executed\");\n+                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                            if let Some(span) = span {\n+                                err.span_note(span, &msg);\n+                            } else {\n+                                err.note(&msg);\n+                            }\n+                            err.emit();\n                         }\n                     }\n                 }"}, {"sha": "d816479bbbbe33ba5ccdaa879497692f44dda69d", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=0499923b188f35205cf49d8e306ea25ac7763d21", "patch": "@@ -11,8 +11,10 @@ use std::mem::{self, MaybeUninit};\n enum Void {}\n \n struct Ref(&'static i32);\n+struct RefPair((&'static i32, i32));\n \n struct Wrap<T> { wrapped: T }\n+enum WrapEnum<T> { Wrapped(T) }\n \n #[allow(unused)]\n fn generic<T: 'static>() {\n@@ -48,6 +50,12 @@ fn main() {\n         let _val: Wrap<fn()> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: Wrap<fn()> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: WrapEnum<fn()> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: WrapEnum<fn()> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<(RefPair, i32)> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: Wrap<(RefPair, i32)> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Some types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();"}, {"sha": "1b15fc21525599e2efdda7ae40ab984323e51475", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 175, "deletions": 55, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0499923b188f35205cf49d8e306ea25ac7763d21/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=0499923b188f35205cf49d8e306ea25ac7763d21", "patch": "@@ -1,169 +1,289 @@\n error: the type `&'static T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:20:32\n+  --> $DIR/uninitialized-zeroed.rs:22:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n    |\n note: lint level defined here\n   --> $DIR/uninitialized-zeroed.rs:7:9\n    |\n LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: References must be non-null\n \n error: the type `&'static T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:21:32\n+  --> $DIR/uninitialized-zeroed.rs:23:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: References must be non-null\n \n error: the type `Wrap<&'static T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:23:38\n+  --> $DIR/uninitialized-zeroed.rs:25:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n+   |                                      |\n+   |                                      this code causes undefined behavior when executed\n+   |                                      help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:16:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n \n error: the type `Wrap<&'static T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:24:38\n+  --> $DIR/uninitialized-zeroed.rs:26:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |                                      |\n+   |                                      this code causes undefined behavior when executed\n+   |                                      help: use `MaybeUninit<T>` instead\n+   |\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:16:18\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:30:23\n+  --> $DIR/uninitialized-zeroed.rs:32:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n+   |                       |\n+   |                       this code causes undefined behavior when executed\n+   |                       help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: The never type (`!`) has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:31:23\n+  --> $DIR/uninitialized-zeroed.rs:33:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n+   |                       |\n+   |                       this code causes undefined behavior when executed\n+   |                       help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:33:30\n+  --> $DIR/uninitialized-zeroed.rs:35:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n+   |                              |\n+   |                              this code causes undefined behavior when executed\n+   |                              help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:34:30\n+  --> $DIR/uninitialized-zeroed.rs:36:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n+   |                              |\n+   |                              this code causes undefined behavior when executed\n+   |                              help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: The never type (`!`) has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:36:26\n+  --> $DIR/uninitialized-zeroed.rs:38:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: 0-variant enums have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:37:26\n+  --> $DIR/uninitialized-zeroed.rs:39:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: 0-variant enums have no valid value\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:39:34\n+  --> $DIR/uninitialized-zeroed.rs:41:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: References must be non-null\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:40:34\n+  --> $DIR/uninitialized-zeroed.rs:42:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: References must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:42:25\n+  --> $DIR/uninitialized-zeroed.rs:44:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n+   |                         |\n+   |                         this code causes undefined behavior when executed\n+   |                         help: use `MaybeUninit<T>` instead\n+   |\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:13:12\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+LL | struct Ref(&'static i32);\n+   |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:43:25\n+  --> $DIR/uninitialized-zeroed.rs:45:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n+   |                         |\n+   |                         this code causes undefined behavior when executed\n+   |                         help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:13:12\n+   |\n+LL | struct Ref(&'static i32);\n+   |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:45:26\n+  --> $DIR/uninitialized-zeroed.rs:47:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: Function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:46:26\n+  --> $DIR/uninitialized-zeroed.rs:48:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+   = note: Function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:48:32\n+  --> $DIR/uninitialized-zeroed.rs:50:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Function pointers must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:16:18\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:49:32\n+  --> $DIR/uninitialized-zeroed.rs:51:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Function pointers must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:16:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+\n+error: the type `WrapEnum<fn()>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:53:36\n+   |\n+LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n+   |                                    ^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+note: Function pointers must be non-null (in this enum field)\n+  --> $DIR/uninitialized-zeroed.rs:17:28\n+   |\n+LL | enum WrapEnum<T> { Wrapped(T) }\n+   |                            ^\n+\n+error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:54:36\n+   |\n+LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+note: Function pointers must be non-null (in this enum field)\n+  --> $DIR/uninitialized-zeroed.rs:17:28\n+   |\n+LL | enum WrapEnum<T> { Wrapped(T) }\n+   |                            ^\n+\n+error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:56:42\n+   |\n+LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n+   |                                          ^^^^^^^^^^^^^\n+   |                                          |\n+   |                                          this code causes undefined behavior when executed\n+   |                                          help: use `MaybeUninit<T>` instead\n+   |\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:14:16\n+   |\n+LL | struct RefPair((&'static i32, i32));\n+   |                ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:57:42\n+   |\n+LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n+   |                                          ^^^^^^^^^^^^^^^^^^^^\n+   |                                          |\n+   |                                          this code causes undefined behavior when executed\n+   |                                          help: use `MaybeUninit<T>` instead\n+   |\n+note: References must be non-null (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:14:16\n    |\n-   = note: this means that this code causes undefined behavior when executed\n-   = help: use `MaybeUninit` instead\n+LL | struct RefPair((&'static i32, i32));\n+   |                ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 22 previous errors\n "}]}