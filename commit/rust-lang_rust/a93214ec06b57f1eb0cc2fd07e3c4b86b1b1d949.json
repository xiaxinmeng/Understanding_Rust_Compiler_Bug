{"sha": "a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "node_id": "C_kwDOAAsO6NoAKGE5MzIxNGVjMDZiNTdmMWViMGNjMmZkMDdlM2M0Yjg2YjFiMWQ5NDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T08:46:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T08:46:40Z"}, "message": "Auto merge of #101604 - compiler-errors:issue-101465, r=lcnr\n\nFix ICE in opt_suggest_box_span\n\nWe were _totally_ mishandling substs and obligations in `opt_suggest_box_span`, so I reworked that function pretty heavily.\n\nAlso some drive-by changes, namely removing `ret_type_span`.\n\nFixes #101465", "tree": {"sha": "4e071ef137dd3d3626dca4c639b0753d9240c792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e071ef137dd3d3626dca4c639b0753d9240c792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "html_url": "https://github.com/rust-lang/rust/commit/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e7678ca97e9740f7d09206f767d5bb676917f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e7678ca97e9740f7d09206f767d5bb676917f7", "html_url": "https://github.com/rust-lang/rust/commit/56e7678ca97e9740f7d09206f767d5bb676917f7"}, {"sha": "5599a45e58402b529ef8c724c560e8cfe6e5b72b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5599a45e58402b529ef8c724c560e8cfe6e5b72b", "html_url": "https://github.com/rust-lang/rust/commit/5599a45e58402b529ef8c724c560e8cfe6e5b72b"}], "stats": {"total": 170, "additions": 120, "deletions": 50}, "files": [{"sha": "8c9ddf866320cd3036461792755406a07b6befc6", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // for opaque types, and then use that kind to fix the spans for type errors\n                     // that we see later on.\n                     let ty_var = self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n+                        kind: TypeVariableOriginKind::OpaqueTypeInference(def_id),\n                         span,\n                     });\n                     obligations.extend("}, {"sha": "7ff086452536bbfafa30d80f7a9050f9540eeed6", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -122,6 +122,7 @@ pub enum TypeVariableOriginKind {\n     MiscVariable,\n     NormalizeProjectionType,\n     TypeInference,\n+    OpaqueTypeInference(DefId),\n     TypeParameterDefinition(Symbol, Option<DefId>),\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`"}, {"sha": "20332e75c425ebef9034a2fce92696cad79613c2", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Subst, ToPredicate, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -137,9 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self.ret_type_span else {\n-                        return;\n-                    };\n+                    let Some(ret) = self\n+                        .tcx\n+                        .hir()\n+                        .find_by_def_id(self.body_id.owner)\n+                        .and_then(|owner| owner.fn_decl())\n+                        .map(|decl| decl.output.span())\n+                    else { return; };\n                     let Expectation::IsLast(stmt) = orig_expected else {\n                         return\n                     };\n@@ -468,58 +472,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n-    // we check if the different arms would work with boxed trait objects instead and\n-    // provide a structured suggestion in that case.\n+    /// When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n+    /// we check if the different arms would work with boxed trait objects instead and\n+    /// provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n         first_ty: Ty<'tcx>,\n         second_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n+        // FIXME(compiler-errors): This really shouldn't need to be done during the\n+        // \"good\" path of typeck, but here we are.\n         match orig_expected {\n-            Expectation::ExpectHasType(expected)\n-                if self.in_tail_expr\n-                    && self.return_type_has_opaque\n-                    && self.can_coerce(first_ty, expected)\n-                    && self.can_coerce(second_ty, expected) =>\n-            {\n-                let obligations = self.fulfillment_cx.borrow().pending_obligations();\n-                let mut suggest_box = !obligations.is_empty();\n-                'outer: for o in obligations {\n-                    for outer_ty in &[first_ty, second_ty] {\n-                        match o.predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(t) => {\n-                                let pred = ty::Binder::dummy(ty::PredicateKind::Trait(\n-                                    ty::TraitPredicate {\n-                                        trait_ref: ty::TraitRef {\n-                                            def_id: t.def_id(),\n-                                            substs: self.tcx.mk_substs_trait(*outer_ty, &[]),\n-                                        },\n-                                        constness: t.constness,\n-                                        polarity: t.polarity,\n-                                    },\n-                                ));\n-                                let obl = Obligation::new(\n-                                    o.cause.clone(),\n-                                    self.param_env,\n-                                    pred.to_predicate(self.tcx),\n-                                );\n-                                suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n-                                if !suggest_box {\n-                                    // We've encountered some obligation that didn't hold, so the\n-                                    // return expression can't just be boxed. We don't need to\n-                                    // evaluate the rest of the obligations.\n-                                    break 'outer;\n-                                }\n+            Expectation::ExpectHasType(expected) => {\n+                let TypeVariableOrigin {\n+                    span,\n+                    kind: TypeVariableOriginKind::OpaqueTypeInference(rpit_def_id),\n+                    ..\n+                } = self.type_var_origin(expected)? else { return None; };\n+\n+                let sig = *self\n+                    .typeck_results\n+                    .borrow()\n+                    .liberated_fn_sigs()\n+                    .get(hir::HirId::make_owner(self.body_id.owner))?;\n+\n+                let substs = sig.output().walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Opaque(def_id, substs) = *ty.kind()\n+                        && def_id == rpit_def_id\n+                    {\n+                        Some(substs)\n+                    } else {\n+                        None\n+                    }\n+                })?;\n+                let opaque_ty = self.tcx.mk_opaque(rpit_def_id, substs);\n+\n+                if !self.can_coerce(first_ty, expected) || !self.can_coerce(second_ty, expected) {\n+                    return None;\n+                }\n+\n+                for ty in [first_ty, second_ty] {\n+                    for pred in self.tcx.bound_explicit_item_bounds(rpit_def_id).transpose_iter() {\n+                        let pred = pred.map_bound(|(pred, _)| *pred).subst(self.tcx, substs);\n+                        let pred = match pred.kind().skip_binder() {\n+                            ty::PredicateKind::Trait(mut trait_pred) => {\n+                                assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n+                                trait_pred.trait_ref.substs =\n+                                    self.tcx.mk_substs_trait(ty, &trait_pred.trait_ref.substs[1..]);\n+                                pred.kind().rebind(trait_pred).to_predicate(self.tcx)\n                             }\n-                            _ => {}\n+                            ty::PredicateKind::Projection(mut proj_pred) => {\n+                                assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n+                                proj_pred.projection_ty.substs = self\n+                                    .tcx\n+                                    .mk_substs_trait(ty, &proj_pred.projection_ty.substs[1..]);\n+                                pred.kind().rebind(proj_pred).to_predicate(self.tcx)\n+                            }\n+                            _ => continue,\n+                        };\n+                        if !self.predicate_must_hold_modulo_regions(&Obligation::new(\n+                            ObligationCause::misc(span, self.body_id),\n+                            self.param_env,\n+                            pred,\n+                        )) {\n+                            return None;\n                         }\n                     }\n                 }\n-                // If all the obligations hold (or there are no obligations) the tail expression\n-                // we can suggest to return a boxed trait object instead of an opaque type.\n-                if suggest_box { self.ret_type_span } else { None }\n+\n+                Some(span)\n             }\n             _ => None,\n         }"}, {"sha": "d6fa74c87309cd92a0e0a6f59be1275fca43b25e", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -106,7 +106,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n \n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n-    fcx.ret_type_span = Some(decl.output.span());\n \n     let span = body.value.span;\n "}, {"sha": "0e22971d3aabd2982ca5231c3ebbed8caff617b2", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -68,8 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    pub(super) ret_type_span: Option<Span>,\n-\n     /// Used exclusively to reduce cost of advanced evaluation used for\n     /// more helpful diagnostics.\n     pub(super) in_tail_expr: bool,\n@@ -142,7 +140,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            ret_type_span: None,\n             in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,"}, {"sha": "8e42e2c22243464c7d4aaaff8f1e28422427f9b8", "filename": "src/test/ui/suggestions/issue-101465.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.rs?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -0,0 +1,25 @@\n+#![feature(trait_alias)]\n+\n+struct B;\n+struct C;\n+\n+trait Tr {}\n+\n+impl Tr for B {}\n+impl Tr for C {}\n+\n+trait Tr2<S> = Into<S>;\n+\n+fn foo2<T: Tr2<()>>() {}\n+\n+fn foo() -> impl Tr {\n+    let x = foo2::<_>();\n+\n+    match true {\n+        true => B,\n+        false => C,\n+        //~^ `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e2ca7771257da6e35666d06cf46c06ba55ff4dcf", "filename": "src/test/ui/suggestions/issue-101465.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101465.stderr?ref=a93214ec06b57f1eb0cc2fd07e3c4b86b1b1d949", "patch": "@@ -0,0 +1,25 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/issue-101465.rs:20:18\n+   |\n+LL | /     match true {\n+LL | |         true => B,\n+   | |                 - this is found to be of type `B`\n+LL | |         false => C,\n+   | |                  ^ expected struct `B`, found struct `C`\n+LL | |\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn foo() -> Box<dyn Tr> {\n+   |             ~~~~~~~   +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         true => Box::new(B),\n+LL ~         false => Box::new(C),\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}