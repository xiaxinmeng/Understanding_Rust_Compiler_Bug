{"sha": "cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYTU4OWIzYjUyZmY1YzRlMzU4ZGI1MmRjNmRlMTUwZWI0OGE5YTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-14T15:47:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-14T15:47:08Z"}, "message": "internal: rewrite assoc item manipulaion to use mutable trees", "tree": {"sha": "99c4c1e83bfd743ac3b30eb43c4a37b00484ea14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c4c1e83bfd743ac3b30eb43c4a37b00484ea14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "html_url": "https://github.com/rust-lang/rust/commit/cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73123a7550a667ebc42be96651a8e36be482a828", "url": "https://api.github.com/repos/rust-lang/rust/commits/73123a7550a667ebc42be96651a8e36be482a828", "html_url": "https://github.com/rust-lang/rust/commit/73123a7550a667ebc42be96651a8e36be482a828"}], "stats": {"total": 257, "additions": 89, "deletions": 168}, "files": [{"sha": "ba1be2e5eacd2a119d44eaf5b66049d406f8d817", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -9,7 +9,7 @@ incremental = false\n \n # Disabling debug info speeds up builds a bunch,\n # and we don't rely on it for debugging that much.\n-debug = 0\n+debug = 1\n \n [profile.dev.package]\n # These speed up local tests."}, {"sha": "8225ae22c6a58b6929ac738b404b958ed0a9933c", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -64,7 +64,6 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n // impl Trait for () {\n //     type X = ();\n //     fn foo(&self) {}$0\n-//\n // }\n // ```\n // ->\n@@ -195,6 +194,7 @@ impl Foo for S {\n     fn baz(&self) {\n         todo!()\n     }\n+\n }\"#,\n         );\n     }\n@@ -231,6 +231,7 @@ impl Foo for S {\n     fn foo(&self) {\n         ${0:todo!()}\n     }\n+\n }\"#,\n         );\n     }"}, {"sha": "4406406a278f917ccf6e0c589b182a40e70ae949", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -50,7 +50,6 @@ trait Trait {\n impl Trait for () {\n     type X = ();\n     fn foo(&self) {}$0\n-\n }\n \"#####,\n         r#####\""}, {"sha": "7d562d1d4ed93cec521bd3acc7b99c98058b772e", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -128,15 +128,12 @@ pub fn add_trait_assoc_items_to_impl(\n     sema: &hir::Semantics<ide_db::RootDatabase>,\n     items: Vec<ast::AssocItem>,\n     trait_: hir::Trait,\n-    impl_def: ast::Impl,\n+    impl_: ast::Impl,\n     target_scope: hir::SemanticsScope,\n ) -> (ast::Impl, ast::AssocItem) {\n-    let impl_item_list = impl_def.assoc_item_list().unwrap_or_else(make::assoc_item_list);\n-\n-    let n_existing_items = impl_item_list.assoc_items().count();\n     let source_scope = sema.scope_for_def(trait_);\n     let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def.clone()));\n+        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_.clone()));\n \n     let items = items\n         .into_iter()\n@@ -147,13 +144,18 @@ pub fn add_trait_assoc_items_to_impl(\n             ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),\n             _ => it,\n         })\n-        .map(|it| edit::remove_attrs_and_docs(&it));\n-\n-    let new_impl_item_list = impl_item_list.append_items(items);\n-    let new_impl_def = impl_def.with_assoc_item_list(new_impl_item_list);\n-    let first_new_item =\n-        new_impl_def.assoc_item_list().unwrap().assoc_items().nth(n_existing_items).unwrap();\n-    return (new_impl_def, first_new_item);\n+        .map(|it| edit::remove_attrs_and_docs(&it).clone_subtree().clone_for_update());\n+\n+    let res = impl_.clone_for_update();\n+    let assoc_item_list = res.get_or_create_assoc_item_list();\n+    let mut first_item = None;\n+    for item in items {\n+        if first_item.is_none() {\n+            first_item = Some(item.clone())\n+        }\n+        assoc_item_list.add_item(item)\n+    }\n+    return (res, first_item.unwrap());\n \n     fn add_body(fn_def: ast::Fn) -> ast::Fn {\n         match fn_def.body() {"}, {"sha": "7e4b8252efb17988317ffc12765e4929a4820772", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 6, "deletions": 145, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -80,81 +80,6 @@ where\n     }\n }\n \n-impl ast::Impl {\n-    #[must_use]\n-    pub fn with_assoc_item_list(&self, items: ast::AssocItemList) -> ast::Impl {\n-        let mut to_insert: ArrayVec<SyntaxElement, 2> = ArrayVec::new();\n-        if let Some(old_items) = self.assoc_item_list() {\n-            let to_replace: SyntaxElement = old_items.syntax().clone().into();\n-            to_insert.push(items.syntax().clone().into());\n-            self.replace_children(single_node(to_replace), to_insert)\n-        } else {\n-            to_insert.push(make::tokens::single_space().into());\n-            to_insert.push(items.syntax().clone().into());\n-            self.insert_children(InsertPosition::Last, to_insert)\n-        }\n-    }\n-}\n-\n-impl ast::AssocItemList {\n-    #[must_use]\n-    pub fn append_items(\n-        &self,\n-        items: impl IntoIterator<Item = ast::AssocItem>,\n-    ) -> ast::AssocItemList {\n-        let mut res = self.clone();\n-        if !self.syntax().text().contains_char('\\n') {\n-            res = make_multiline(res);\n-        }\n-        items.into_iter().for_each(|it| res = res.append_item(it));\n-        res.fixup_trailing_whitespace().unwrap_or(res)\n-    }\n-\n-    #[must_use]\n-    pub fn append_item(&self, item: ast::AssocItem) -> ast::AssocItemList {\n-        let (indent, position, whitespace) = match self.assoc_items().last() {\n-            Some(it) => (\n-                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n-                InsertPosition::After(it.syntax().clone().into()),\n-                \"\\n\\n\",\n-            ),\n-            None => match self.l_curly_token() {\n-                Some(it) => (\n-                    \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it.into()),\n-                    \"\\n\",\n-                ),\n-                None => return self.clone(),\n-            },\n-        };\n-        let ws = tokens::WsBuilder::new(&format!(\"{}{}\", whitespace, indent));\n-        let to_insert: ArrayVec<SyntaxElement, 2> =\n-            [ws.ws().into(), item.syntax().clone().into()].into();\n-        self.insert_children(position, to_insert)\n-    }\n-\n-    /// Remove extra whitespace between last item and closing curly brace.\n-    fn fixup_trailing_whitespace(&self) -> Option<ast::AssocItemList> {\n-        let first_token_after_items =\n-            self.assoc_items().last()?.syntax().next_sibling_or_token()?;\n-        let last_token_before_curly = self.r_curly_token()?.prev_sibling_or_token()?;\n-        if last_token_before_curly != first_token_after_items {\n-            // there is something more between last item and\n-            // right curly than just whitespace - bail out\n-            return None;\n-        }\n-        let whitespace =\n-            last_token_before_curly.clone().into_token().and_then(ast::Whitespace::cast)?;\n-        let text = whitespace.syntax().text();\n-        let newline = text.rfind('\\n')?;\n-        let keep = tokens::WsBuilder::new(&text[newline..]);\n-        Some(self.replace_children(\n-            first_token_after_items..=last_token_before_curly,\n-            std::iter::once(keep.ws().into()),\n-        ))\n-    }\n-}\n-\n impl ast::RecordExprFieldList {\n     #[must_use]\n     pub fn append_field(&self, field: &ast::RecordExprField) -> ast::RecordExprFieldList {\n@@ -246,21 +171,6 @@ impl ast::TypeAlias {\n     }\n }\n \n-impl ast::TypeParam {\n-    #[must_use]\n-    pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon_token() {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let end = match self.type_bound_list() {\n-            Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n-        };\n-        self.replace_children(colon.into()..=end, iter::empty())\n-    }\n-}\n-\n impl ast::Path {\n     #[must_use]\n     pub fn with_segment(&self, segment: ast::PathSegment) -> ast::Path {\n@@ -411,61 +321,6 @@ impl ast::MatchArmList {\n     }\n }\n \n-impl ast::GenericParamList {\n-    #[must_use]\n-    pub fn append_params(\n-        &self,\n-        params: impl IntoIterator<Item = ast::GenericParam>,\n-    ) -> ast::GenericParamList {\n-        let mut res = self.clone();\n-        params.into_iter().for_each(|it| res = res.append_param(it));\n-        res\n-    }\n-\n-    #[must_use]\n-    pub fn append_param(&self, item: ast::GenericParam) -> ast::GenericParamList {\n-        let space = tokens::single_space();\n-\n-        let mut to_insert: ArrayVec<SyntaxElement, 4> = ArrayVec::new();\n-        if self.generic_params().next().is_some() {\n-            to_insert.push(space.into());\n-        }\n-        to_insert.push(item.syntax().clone().into());\n-\n-        macro_rules! after_l_angle {\n-            () => {{\n-                let anchor = match self.l_angle_token() {\n-                    Some(it) => it.into(),\n-                    None => return self.clone(),\n-                };\n-                InsertPosition::After(anchor)\n-            }};\n-        }\n-\n-        macro_rules! after_field {\n-            ($anchor:expr) => {\n-                if let Some(comma) = $anchor\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    InsertPosition::After(comma)\n-                } else {\n-                    to_insert.insert(0, make::token(T![,]).into());\n-                    InsertPosition::After($anchor.syntax().clone().into())\n-                }\n-            };\n-        }\n-\n-        let position = match self.generic_params().last() {\n-            Some(it) => after_field!(it),\n-            None => after_l_angle!(),\n-        };\n-\n-        self.insert_children(position, to_insert)\n-    }\n-}\n-\n #[must_use]\n pub fn remove_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n     N::cast(remove_attrs_and_docs_inner(node.syntax().clone())).unwrap()\n@@ -516,6 +371,12 @@ impl ops::Add<u8> for IndentLevel {\n }\n \n impl IndentLevel {\n+    pub fn single() -> IndentLevel {\n+        IndentLevel(0)\n+    }\n+    pub fn is_zero(&self) -> bool {\n+        self.0 == 0\n+    }\n     pub fn from_element(element: &SyntaxElement) -> IndentLevel {\n         match element {\n             rowan::NodeOrToken::Node(it) => IndentLevel::from_node(it),"}, {"sha": "9812e00c9d70b47e3cc95ca9399345ce8f31c146", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -2,11 +2,16 @@\n \n use std::iter::empty;\n \n-use parser::T;\n+use parser::{SyntaxKind, T};\n+use rowan::SyntaxElement;\n \n use crate::{\n     algo::neighbor,\n-    ast::{self, edit::AstNodeEdit, make, GenericParamsOwner, WhereClause},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, GenericParamsOwner,\n+    },\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n };\n@@ -37,7 +42,7 @@ impl GenericParamsOwnerEdit for ast::Fn {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(ty) = self.ret_type() {\n                 Position::after(ty.syntax())\n@@ -67,7 +72,7 @@ impl GenericParamsOwnerEdit for ast::Impl {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n                 Position::before(items.syntax())\n@@ -97,7 +102,7 @@ impl GenericParamsOwnerEdit for ast::Trait {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n                 Position::before(items.syntax())\n@@ -127,7 +132,7 @@ impl GenericParamsOwnerEdit for ast::Struct {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let tfl = self.field_list().and_then(|fl| match fl {\n                 ast::FieldList::RecordFieldList(_) => None,\n@@ -165,7 +170,7 @@ impl GenericParamsOwnerEdit for ast::Enum {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(gpl) = self.generic_param_list() {\n                 Position::after(gpl.syntax())\n@@ -272,6 +277,59 @@ impl ast::Use {\n     }\n }\n \n+impl ast::Impl {\n+    pub fn get_or_create_assoc_item_list(&self) -> ast::AssocItemList {\n+        if self.assoc_item_list().is_none() {\n+            let assoc_item_list = make::assoc_item_list().clone_for_update();\n+            ted::append_child(self.syntax(), assoc_item_list.syntax());\n+        }\n+        self.assoc_item_list().unwrap()\n+    }\n+}\n+\n+impl ast::AssocItemList {\n+    pub fn add_item(&self, item: ast::AssocItem) {\n+        let (indent, position, whitespace) = match self.assoc_items().last() {\n+            Some(last_item) => (\n+                IndentLevel::from_node(last_item.syntax()),\n+                Position::after(last_item.syntax()),\n+                \"\\n\\n\",\n+            ),\n+            None => match self.l_curly_token() {\n+                Some(l_curly) => {\n+                    self.normalize_ws_between_braces();\n+                    (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly), \"\\n\")\n+                }\n+                None => (IndentLevel::single(), Position::last_child_of(self.syntax()), \"\\n\"),\n+            },\n+        };\n+        let elements: Vec<SyntaxElement<_>> = vec![\n+            make::tokens::whitespace(&format!(\"{}{}\", whitespace, indent)).into(),\n+            item.syntax().clone().into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+\n+    fn normalize_ws_between_braces(&self) -> Option<()> {\n+        let l = self.l_curly_token()?;\n+        let r = self.r_curly_token()?;\n+        let indent = IndentLevel::from_node(self.syntax());\n+\n+        match l.next_sibling_or_token() {\n+            Some(ws) if ws.kind() == SyntaxKind::WHITESPACE => {\n+                if ws.next_sibling_or_token()?.into_token()? == r {\n+                    ted::replace(ws, make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+                }\n+            }\n+            Some(ws) if ws.kind() == T!['}'] => {\n+                ted::insert(Position::after(l), make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+            }\n+            _ => (),\n+        }\n+        Some(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::fmt;"}, {"sha": "d13926deda891291c575773753a5cfa4bc5a9e00", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea589b3b52ff5c4e358db52dc6de150eb48a9a0/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=cea589b3b52ff5c4e358db52dc6de150eb48a9a0", "patch": "@@ -99,7 +99,7 @@ fn ty_from_text(text: &str) -> ast::Type {\n }\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n-    ast_from_text(\"impl C for D {};\")\n+    ast_from_text(\"impl C for D {}\")\n }\n \n pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {"}]}