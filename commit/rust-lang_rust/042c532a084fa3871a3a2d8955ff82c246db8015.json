{"sha": "042c532a084fa3871a3a2d8955ff82c246db8015", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MmM1MzJhMDg0ZmEzODcxYTNhMmQ4OTU1ZmY4MmMyNDZkYjgwMTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-23T03:06:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-24T04:47:28Z"}, "message": "Implement new inference algorithm.", "tree": {"sha": "9b69f961a78deae15a4f8544bec7a4f215a90a5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b69f961a78deae15a4f8544bec7a4f215a90a5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/042c532a084fa3871a3a2d8955ff82c246db8015", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/042c532a084fa3871a3a2d8955ff82c246db8015", "html_url": "https://github.com/rust-lang/rust/commit/042c532a084fa3871a3a2d8955ff82c246db8015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/042c532a084fa3871a3a2d8955ff82c246db8015/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40443768b16747cb3ef90a2fb2fd9e7f317ff383", "url": "https://api.github.com/repos/rust-lang/rust/commits/40443768b16747cb3ef90a2fb2fd9e7f317ff383", "html_url": "https://github.com/rust-lang/rust/commit/40443768b16747cb3ef90a2fb2fd9e7f317ff383"}], "stats": {"total": 1121, "additions": 1000, "deletions": 121}, "files": [{"sha": "3d4ad1cf762a9f9d4487b202e9b28ad4683d6c7c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -169,14 +169,14 @@ fn test_enumerate() {\n #[test]\n fn test_map_and_to_list() {\n     let a = bind vec::iter([0, 1, 2], _);\n-    let b = bind map(a, {|i| i*2}, _);\n+    let b = bind map(a, {|i| 2*i}, _);\n     let c = to_list(b);\n     assert c == [0, 2, 4];\n }\n \n #[test]\n fn test_map_directly_on_vec() {\n-    let b = bind map([0, 1, 2], {|i| i*2}, _);\n+    let b = bind map([0, 1, 2], {|i| 2*i}, _);\n     let c = to_list(b);\n     assert c == [0, 2, 4];\n }"}, {"sha": "37a55e97aa1a44340e0c609ee4a0ec814cca3276", "filename": "src/libcore/result.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -91,6 +91,24 @@ fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     }\n }\n \n+#[doc = \"\n+Call a function based on a previous result\n+\n+If `res` is `err` then the value is extracted and passed to `op`\n+whereupon `op`s result is returned. if `res` is `ok` then it is\n+immediately returned.  This function can be used to pass through a\n+successful result while handling an error.\n+\"]\n+fn chain_err<T: copy, U: copy, V: copy>(\n+    res: result<T, V>,\n+    op: fn(V) -> result<T, U>)\n+    -> result<T, U> {\n+    alt res {\n+      ok(t) { ok(t) }\n+      err(v) { op(v) }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Note:\n //\n@@ -171,6 +189,22 @@ fn map2<S,T,U:copy,V:copy,W>(ss: [S], ts: [T],\n     ret nxt(vs);\n }\n \n+fn iter2<S,T,U:copy>(ss: [S], ts: [T],\n+                     op: fn(S,T) -> result<(),U>)\n+    : vec::same_length(ss, ts)\n+    -> result<(),U> {\n+    let n = vec::len(ts);\n+    let mut i = 0u;\n+    while i < n {\n+        alt op(ss[i],ts[i]) {\n+          ok(()) { }\n+          err(u) { ret err(u); }\n+        }\n+        i += 1u;\n+    }\n+    ret ok(());\n+}\n+\n #[cfg(test)]\n mod tests {\n     fn op1() -> result::result<int, str> { result::ok(666) }"}, {"sha": "c760813bf7ff0d9824409c8b7047aa66709c9a72", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -27,6 +27,7 @@ export rsplit;\n export rsplitn;\n export shift;\n export pop;\n+export clear;\n export push;\n export grow;\n export grow_fn;\n@@ -164,6 +165,13 @@ fn from_mut<T>(+v: [mutable T]) -> [T] unsafe {\n     r\n }\n \n+// This function only exists to work around bugs in the type checker.\n+fn from_const<T>(+v: [const T]) -> [T] unsafe {\n+    let r = ::unsafe::reinterpret_cast(v);\n+    ::unsafe::forget(v);\n+    r\n+}\n+\n // Accessors\n \n #[doc = \"Returns the first element of a vector\"]\n@@ -336,6 +344,14 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n     val\n }\n \n+#[doc = \"\n+Removes all elements from a vector without affecting\n+how much space is reserved.\n+\"]\n+fn clear<T>(&v: [const T]) unsafe {\n+    unsafe::set_len(v, 0u);\n+}\n+\n #[doc = \"Append an element to a vector\"]\n fn push<T>(&v: [const T], +initval: T) {\n     v += [initval];\n@@ -466,8 +482,8 @@ Concatenate a vector of vectors.\n Flattens a vector of vectors of T into a single vector of T.\n \"]\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n-    let mut r: [T] = [];\n-    for inner: [T] in v { r += inner; }\n+    let mut r = [];\n+    for inner in v { r += from_const(inner); }\n     ret r;\n }\n \n@@ -477,9 +493,9 @@ Concatenate a vector of vectors, placing a given separator between each\n fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n-    for inner: [T] in v {\n+    for inner in v {\n         if first { first = false; } else { push(r, sep); }\n-        r += inner;\n+        r += from_const(inner);\n     }\n     ret r;\n }\n@@ -885,7 +901,7 @@ fn as_mut_buf<E,T>(v: [mutable E], f: fn(*mutable E) -> T) -> T unsafe {\n }\n \n #[doc = \"An extension implementation providing a `len` method\"]\n-impl vec_len<T> for [T] {\n+impl vec_len<T> for [const T] {\n     #[doc = \"Return the length of the vector\"]\n     #[inline(always)]\n     fn len() -> uint { len(self) }"}, {"sha": "91f9c499ce15df45180b231ff31c9805db26d905", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -63,6 +63,7 @@ export opt_str;\n export opt_strs;\n export opt_maybe_str;\n export opt_default;\n+export result; //NDM\n \n enum name { long(str), short(char), }\n "}, {"sha": "b5d2b18a39c709bf5f8809e529a0e0b103668a07", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -634,6 +634,7 @@ impl helpers for @e::encode_ctxt {\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n         @{ds: e::def_to_str,\n           tcx: self.ccx.tcx,\n+          reachable: self.ccx.reachable,\n           abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }"}, {"sha": "d648cc168bd6b4167ec36306152c2879e8033dd3", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -221,6 +221,7 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             params: [ty_param]) {\n     let ty_str_ctxt = @{ds: def_to_str,\n                         tcx: ecx.ccx.tcx,\n+                        reachable: ecx.ccx.reachable,\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for param in params {\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n@@ -240,6 +241,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{ds: def_to_str,\n           tcx: ecx.ccx.tcx,\n+          reachable: ecx.ccx.reachable,\n           abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n@@ -966,7 +968,10 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n // Get the encoded string for a type\n fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> str {\n-    let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n+    let cx = @{ds: def_to_str,\n+               tcx: tcx,\n+               reachable: std::map::int_hash(),\n+               abbrevs: tyencode::ac_no_abbrevs};\n     let buf = io::mem_buffer();\n     tyencode::enc_ty(io::mem_buffer_writer(buf), cx, t);\n     ret io::mem_buffer_str(buf);"}, {"sha": "6e1e8b15f564616c724399c77729cac5de68be2e", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -6,6 +6,7 @@ import syntax::ast::*;\n import driver::session::session;\n import middle::ty;\n import syntax::print::pprust::*;\n+import middle::trans::reachable;\n \n export ctxt;\n export ty_abbrev;\n@@ -18,7 +19,8 @@ export enc_mode;\n type ctxt =\n     // Def -> str Callback:\n     // The type context.\n-    {ds: fn@(def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n+    {ds: fn@(def_id) -> str, tcx: ty::ctxt,\n+     reachable: reachable::map, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n@@ -55,9 +57,14 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n             let pos = w.tell();\n             alt ty::type_def_id(t) {\n               some(def_id) {\n-                w.write_char('\"');\n-                w.write_str(cx.ds(def_id));\n-                w.write_char('|');\n+                // Do not emit node ids that map to unexported names.  Those\n+                // are not helpful.\n+                if def_id.crate != local_crate ||\n+                    cx.reachable.contains_key(def_id.node) {\n+                    w.write_char('\"');\n+                    w.write_str(cx.ds(def_id));\n+                    w.write_char('|');\n+                }\n               }\n               _ {}\n             }"}, {"sha": "694f07d41da338347bf12386ff7bdd354691b09b", "filename": "src/rustc/middle/infer.rs", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -0,0 +1,668 @@\n+import std::smallintmap;\n+import std::smallintmap::smallintmap;\n+import std::smallintmap::map;\n+import middle::ty;\n+import syntax::ast;\n+import util::ppaux::{ty_to_str, mt_to_str};\n+import result::{result, chain, chain_err, ok, iter2};\n+import ty::type_is_bot;\n+\n+export infer_ctxt;\n+export new_infer_ctxt;\n+export mk_subty;\n+export mk_eqty;\n+export resolve_type_structure;\n+export fixup_vars;\n+export resolve_var;\n+export compare_tys;\n+\n+type bound = option<ty::t>;\n+\n+type bounds = {lb: bound, ub: bound};\n+\n+enum var_value {\n+    redirect(uint),\n+    bounded(bounds)\n+}\n+\n+enum infer_ctxt = @{\n+    tcx: ty::ctxt,\n+    vals: smallintmap<var_value>,\n+    mut bindings: [(uint, var_value)]\n+};\n+\n+type ures = result::result<(), ty::type_err>;\n+type fres<T> = result::result<T,int>;\n+\n+fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n+    infer_ctxt(@{tcx: tcx,\n+                 vals: smallintmap::mk(),\n+                 mut bindings: []})\n+}\n+\n+fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    #debug[\">> mk_subty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n+    cx.commit {||\n+        cx.tys(a, b)\n+    }\n+}\n+\n+fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n+    #debug[\"> mk_eqty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n+    cx.commit {||\n+        mk_subty(cx, a, b).then {||\n+            mk_subty(cx, b, a)\n+        }\n+    }\n+}\n+\n+fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n+    let infcx = new_infer_ctxt(tcx);\n+    #debug[\"> compare_tys(%s == %s)\", infcx.ty_to_str(a), infcx.ty_to_str(b)];\n+    infcx.commit {||\n+        mk_subty(infcx, a, b).then {||\n+            mk_subty(infcx, b, a)\n+        }\n+    }\n+}\n+\n+fn resolve_type_structure(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n+    cx.resolve_ty(a)\n+}\n+\n+fn resolve_var(cx: infer_ctxt, vid: int) -> fres<ty::t> {\n+    cx.fixup_vars(ty::mk_var(cx.tcx, vid))\n+}\n+\n+fn fixup_vars(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n+    cx.fixup_vars(a)\n+}\n+\n+impl methods for ures {\n+    fn then<T:copy>(f: fn() -> result<T,ty::type_err>)\n+        -> result<T,ty::type_err> {\n+        chain(self) {|_i| f() }\n+    }\n+}\n+\n+impl unify_methods for infer_ctxt {\n+    fn uok() -> ures {\n+        #debug[\"Unification OK\"];\n+        result::ok(())\n+    }\n+\n+    fn uerr(e: ty::type_err) -> ures {\n+        #debug[\"Unification error: %?\", e];\n+        result::err(e)\n+    }\n+\n+    fn ty_to_str(t: ty::t) -> str {\n+        ty_to_str(self.tcx, t)\n+    }\n+\n+    fn bound_to_str(b: bound) -> str {\n+        alt b {\n+          none { \"none\" }\n+          some(t) { self.ty_to_str(t) }\n+        }\n+    }\n+\n+    fn bounds_to_str(v: bounds) -> str {\n+        #fmt[\"{%s <: X <: %s}\",\n+             self.bound_to_str(v.lb),\n+             self.bound_to_str(v.ub)]\n+    }\n+\n+    fn var_value_to_str(v: var_value) -> str {\n+        alt v {\n+          redirect(v) { #fmt[\"redirect(%u)\", v] }\n+          bounded(b) { self.bounds_to_str(b) }\n+        }\n+    }\n+\n+    fn set(vid: uint, +new_v: var_value) {\n+        let old_v = self.vals.get(vid);\n+        vec::push(self.bindings, (vid, old_v));\n+\n+        #debug[\"Updating variable <T%u> from %s to %s\",\n+               vid,\n+               self.var_value_to_str(old_v),\n+               self.var_value_to_str(new_v)];\n+\n+        self.vals.insert(vid, new_v);\n+    }\n+\n+    fn rollback_to(len: uint) {\n+        while self.bindings.len() != len {\n+            let (vid, old_v) = vec::pop(self.bindings);\n+            self.vals.insert(vid, old_v);\n+        }\n+    }\n+\n+    fn commit<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n+        assert self.bindings.len() == 0u;\n+        let r = self.try(f);\n+        vec::clear(self.bindings);\n+        ret r;\n+    }\n+\n+    fn try<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n+        let l = self.bindings.len();\n+        #debug[\"try(l=%u)\", l];\n+        let r = f();\n+        alt r {\n+          result::ok(_) { #debug[\"try--ok\"]; }\n+          result::err(_) { #debug[\"try--rollback\"]; }\n+        }\n+        ret r;\n+    }\n+\n+    fn get(vid: uint) -> {root: uint, bounds:bounds} {\n+        alt self.vals.find(vid) {\n+          none {\n+            let bnds = {lb: none, ub: none};\n+            self.vals.insert(vid, bounded(bnds));\n+            {root: vid, bounds: bnds}\n+          }\n+          some(redirect(vid)) {\n+            let {root, bounds} = self.get(vid);\n+            if root != vid {\n+                self.vals.insert(vid, redirect(root));\n+            }\n+            {root: root, bounds: bounds}\n+          }\n+          some(bounded(bounds)) {\n+            {root: vid, bounds: bounds}\n+          }\n+        }\n+    }\n+\n+    // Take bound a if it is set, else take bound b.\n+    fn aelseb(a: bound, b: bound) -> bound {\n+        alt (a, b) {\n+          (none, none) { none }\n+          (some(_), none) { a }\n+          (none, some(_)) { b }\n+          (some(_), some(_)) { a }\n+        }\n+    }\n+\n+    // Combines the two bounds.  Returns a bounds r where (r.lb <:\n+    // a,b) and (a,b <: r.ub).\n+    fn merge_bnds(a: bound, b: bound) -> result<bounds, ty::type_err> {\n+        alt (a, b) {\n+          (none, none) {\n+            ok({lb: none, ub: none})\n+          }\n+          (some(_), none) {\n+            ok({lb: a, ub: a})\n+          }\n+          (none, some(_)) {\n+            ok({lb: b, ub: b})\n+          }\n+          (some(t_a), some(t_b)) {\n+            let r1 = self.try {||\n+                self.tys(t_a, t_b).then {||\n+                    ok({lb: a, ub: b})\n+                }\n+            };\n+            chain_err(r1) {|_e|\n+                self.tys(t_b, t_a).then {||\n+                    ok({lb: b, ub: a})\n+                }\n+            }\n+          }\n+        }\n+    }\n+\n+    // Given a variable with bounds `a`, returns a new set of bounds\n+    // such that `a` <: `b`.  The new bounds will always be a subset\n+    // of the old bounds.  If this cannot be achieved, the result is\n+    // failure.\n+    fn merge(v_id: uint, a: bounds, b: bounds) -> ures {\n+        // Think of the two diamonds, we want to find the\n+        // intersection.  There are basically four possibilities (you\n+        // can swap A/B in these pictures):\n+        //\n+        //       A         A\n+        //      / \\       / \\\n+        //     / B \\     / B \\\n+        //    / / \\ \\   / / \\ \\\n+        //   * *   * * * /   * *\n+        //    \\ \\ / /   \\   / /\n+        //     \\ B /   / \\ / /\n+        //      \\ /   *   \\ /\n+        //       A     \\ / A\n+        //              B\n+\n+        #debug[\"merge(<T%u>,%s,%s)\",\n+               v_id,\n+               self.bounds_to_str(a),\n+               self.bounds_to_str(b)];\n+\n+        chain(self.merge_bnds(a.ub, b.ub)) {|ub|\n+            chain(self.merge_bnds(a.lb, b.lb)) {|lb|\n+                let bnds = {lb: lb.ub, ub: ub.lb};\n+\n+                // the new bounds must themselves\n+                // be relatable:\n+                self.bnds(lb.ub, ub.lb).then {||\n+                    self.set(v_id, bounded(bnds));\n+                    self.uok()\n+                }\n+            }\n+        }\n+    }\n+\n+    fn vars(a_id: uint, b_id: uint) -> ures {\n+        #debug[\"vars(<T%u> <: <T%u>)\",\n+               a_id, b_id];\n+\n+        // Need to make sub_id a subtype of sup_id.\n+        let {root: a_id, bounds: a_bounds} = self.get(a_id);\n+        let {root: b_id, bounds: b_bounds} = self.get(b_id);\n+\n+        if a_id == b_id { ret self.uok(); }\n+        self.merge(a_id, a_bounds, b_bounds).then {||\n+            // For max perf, we should consider the rank here.\n+            self.set(b_id, redirect(a_id));\n+            self.uok()\n+        }\n+    }\n+\n+    fn varty(a_id: uint, b: ty::t) -> ures {\n+        #debug[\"varty(<T%u> <: %s)\",\n+               a_id, self.ty_to_str(b)];\n+        let {root: a_id, bounds: a_bounds} = self.get(a_id);\n+        let b_bounds = {lb: none, ub: some(b)};\n+        self.merge(a_id, a_bounds, b_bounds)\n+    }\n+\n+    fn tyvar(a: ty::t, b_id: uint) -> ures {\n+        #debug[\"tyvar(%s <: <T%u>)\",\n+               self.ty_to_str(a), b_id];\n+        let a_bounds = {lb: some(a), ub: none};\n+        let {root: b_id, bounds: b_bounds} = self.get(b_id);\n+        self.merge(b_id, a_bounds, b_bounds)\n+    }\n+\n+    fn tyvecs(as: [ty::t], bs: [ty::t])\n+        : vec::same_length(as, bs) -> ures {\n+        iter2(as, bs) {|a,b| self.tys(a,b) }\n+    }\n+\n+    fn regions(a: ty::region, b: ty::region) -> ures {\n+        // FIXME: This is wrong. We should be keeping a set of region\n+        // bindings around.\n+        alt (a, b) {\n+            (ty::re_param(_), _) | (_, ty::re_param(_)) {\n+                ret if a == b {\n+                    self.uok()\n+                } else {\n+                    self.uerr(ty::terr_regions_differ(true, b, a))\n+                };\n+            }\n+            _ { /* fall through */ }\n+        }\n+\n+        let bscope = region::region_to_scope(self.tcx.region_map, b);\n+        let ascope = region::region_to_scope(self.tcx.region_map, a);\n+        if region::scope_contains(self.tcx.region_map, ascope, bscope) {\n+            self.uok()\n+        } else {\n+            self.uerr(ty::terr_regions_differ(false, a, b))\n+        }\n+    }\n+\n+    fn mts(a: ty::mt, b: ty::mt) -> ures {\n+        #debug(\"mts(%s <: %s)\",\n+               mt_to_str(self.tcx, a),\n+               mt_to_str(self.tcx, b));\n+\n+        if a.mutbl != b.mutbl && b.mutbl != ast::m_const {\n+            ret self.uerr(ty::terr_mutability);\n+        }\n+\n+        alt b.mutbl {\n+          ast::m_mutbl {\n+            // If supertype is mutable, subtype must mtach exactly\n+            // (i.e., invariant if mutable):\n+            self.tys(a.ty, b.ty).then {||\n+                self.tys(b.ty, a.ty)\n+            }\n+          }\n+          ast::m_imm | ast::m_const {\n+            // Otherwise we can be covariant:\n+            self.tys(a.ty, b.ty)\n+          }\n+        }\n+    }\n+\n+    fn flds(a: ty::field, b: ty::field) -> ures {\n+        if a.ident != b.ident {\n+            ret self.uerr(ty::terr_record_fields(a.ident, b.ident));\n+        }\n+        self.mts(a.mt, b.mt)\n+    }\n+\n+    fn tps(as: [ty::t], bs: [ty::t]) -> ures {\n+        if check vec::same_length(as, bs) {\n+            self.tyvecs(as, bs)\n+        } else {\n+            self.uerr(ty::terr_ty_param_size(as.len(), bs.len()))\n+        }\n+    }\n+\n+    fn protos(a: ast::proto, b: ast::proto) -> ures {\n+        alt (a, b) {\n+          (_, ast::proto_any) { self.uok() }\n+          (ast::proto_bare, _) { self.uok() }\n+          (_, _) if a == b { self.uok() }\n+          _ { self.uerr(ty::terr_proto_mismatch(a, b)) }\n+        }\n+    }\n+\n+    fn ret_styles(\n+        a_ret_style: ast::ret_style,\n+        b_ret_style: ast::ret_style) -> ures {\n+\n+        if b_ret_style != ast::noreturn && b_ret_style != a_ret_style {\n+            /* even though typestate checking is mostly\n+               responsible for checking control flow annotations,\n+               this check is necessary to ensure that the\n+               annotation in an object method matches the\n+               declared object type */\n+            self.uerr(ty::terr_ret_style_mismatch(a_ret_style, b_ret_style))\n+        } else {\n+            self.uok()\n+        }\n+    }\n+\n+    fn modes(a: ast::mode, b: ast::mode) -> ures {\n+        alt ty::unify_mode(self.tcx, a, b) {\n+          result::ok(_) { self.uok() }\n+          result::err(e) { self.uerr(e) }\n+        }\n+    }\n+\n+    fn args(a: ty::arg, b: ty::arg) -> ures {\n+        self.modes(a.mode, b.mode).then {||\n+            self.tys(b.ty, a.ty) // Note: contravariant\n+        }\n+    }\n+\n+    fn argvecs(\n+        a_args: [ty::arg],\n+        b_args: [ty::arg]) -> ures {\n+\n+        if check vec::same_length(a_args, b_args) {\n+            iter2(a_args, b_args) {|a, b| self.args(a, b) }\n+        } else {\n+            ret self.uerr(ty::terr_arg_count);\n+        }\n+    }\n+\n+    fn fns(a_f: ty::fn_ty, b_f: ty::fn_ty) -> ures {\n+        self.protos(a_f.proto, b_f.proto).then {||\n+            self.ret_styles(a_f.ret_style, b_f.ret_style).then {||\n+                self.argvecs(a_f.inputs, b_f.inputs).then {||\n+                    self.tys(a_f.output, b_f.output).then {||\n+                        // FIXME---constraints\n+                        self.uok()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn constrs(\n+        expected: @ty::type_constr,\n+        actual_constr: @ty::type_constr) -> ures {\n+\n+        let err_res =\n+            self.uerr(ty::terr_constr_mismatch(expected, actual_constr));\n+\n+        if expected.node.id != actual_constr.node.id { ret err_res; }\n+        let expected_arg_len = vec::len(expected.node.args);\n+        let actual_arg_len = vec::len(actual_constr.node.args);\n+        if expected_arg_len != actual_arg_len { ret err_res; }\n+        let mut i = 0u;\n+        for a in expected.node.args {\n+            let actual = actual_constr.node.args[i];\n+            alt a.node {\n+              ast::carg_base {\n+                alt actual.node {\n+                  ast::carg_base { }\n+                  _ { ret err_res; }\n+                }\n+              }\n+              ast::carg_lit(l) {\n+                alt actual.node {\n+                  ast::carg_lit(m) {\n+                    if l != m { ret err_res; }\n+                  }\n+                  _ { ret err_res; }\n+                }\n+              }\n+              ast::carg_ident(p) {\n+                alt actual.node {\n+                  ast::carg_ident(q) {\n+                    if p.node != q.node { ret err_res; }\n+                  }\n+                  _ { ret err_res; }\n+                }\n+              }\n+            }\n+            i += 1u;\n+        }\n+        ret self.uok();\n+    }\n+\n+    fn bnds(a: bound, b: bound) -> ures {\n+        #debug(\"bnds(%s <: %s)\",\n+               self.bound_to_str(a),\n+               self.bound_to_str(b));\n+\n+        alt (a, b) {\n+          (none, none) |\n+          (some(_), none) |\n+          (none, some(_)) { self.uok() }\n+          (some(t_a), some(t_b)) { self.tys(t_a, t_b) }\n+        }\n+    }\n+\n+    fn tys(a: ty::t, b: ty::t) -> ures {\n+        #debug(\"tys(%s <: %s)\",\n+               ty_to_str(self.tcx, a),\n+               ty_to_str(self.tcx, b));\n+\n+        // Fast path.\n+        if a == b { ret self.uok(); }\n+\n+        alt (ty::get(a).struct, ty::get(b).struct) {\n+          (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+            self.vars(a_id as uint, b_id as uint)\n+          }\n+          (ty::ty_var(a_id), _) {\n+            self.varty(a_id as uint, b)\n+          }\n+          (_, ty::ty_var(b_id)) {\n+            self.tyvar(a, b_id as uint)\n+          }\n+\n+          (_, ty::ty_bot) { self.uok() }\n+          (ty::ty_bot, _) { self.uok() }\n+\n+          (ty::ty_nil, _) |\n+          (ty::ty_bool, _) |\n+          (ty::ty_int(_), _) |\n+          (ty::ty_uint(_), _) |\n+          (ty::ty_float(_), _) |\n+          (ty::ty_str, _) {\n+            let cfg = self.tcx.sess.targ_cfg;\n+            if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n+                self.uok()\n+            } else {\n+                self.uerr(ty::terr_mismatch)\n+            }\n+          }\n+\n+          (ty::ty_param(a_n, _), ty::ty_param(b_n, _))\n+          if a_n == b_n {\n+            self.uok()\n+          }\n+\n+          (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps)) |\n+          (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps)) |\n+          (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n+          if a_id == b_id {\n+            self.tps(a_tps, b_tps)\n+          }\n+\n+          (ty::ty_box(a_mt), ty::ty_box(b_mt)) |\n+          (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) |\n+          (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) |\n+          (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n+            self.mts(a_mt, b_mt)\n+          }\n+\n+          (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n+            self.mts(a_mt, b_mt).then {||\n+                self.regions(a_r, b_r)\n+            }\n+          }\n+\n+          (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n+          if a_id == b_id {\n+            self.tys(a_t, b_t).then {||\n+                self.tps(a_tps, b_tps)\n+            }\n+          }\n+\n+          (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n+            if check vec::same_length(a_fields, b_fields) {\n+                iter2(a_fields, b_fields) {|a,b|\n+                    self.flds(a, b)\n+                }\n+            } else {\n+                ret self.uerr(ty::terr_record_size(a_fields.len(),\n+                                             b_fields.len()));\n+            }\n+          }\n+\n+          (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n+            if check vec::same_length(a_tys, b_tys) {\n+                self.tyvecs(a_tys, b_tys)\n+            } else {\n+                self.uerr(ty::terr_tuple_size(a_tys.len(), b_tys.len()))\n+            }\n+          }\n+\n+          (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n+            self.fns(a_fty, b_fty)\n+          }\n+\n+          (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n+            self.tys(a_t, b_t).then {||\n+                if check vec::same_length(a_constrs, b_constrs) {\n+                    iter2(a_constrs, b_constrs) {|a,b|\n+                        self.constrs(a, b)\n+                    }\n+                } else {\n+                    ret self.uerr(ty::terr_constr_len(a_constrs.len(),\n+                                                b_constrs.len()));\n+                }\n+            }\n+          }\n+\n+          _ { self.uerr(ty::terr_mismatch) }\n+        }\n+    }\n+}\n+\n+impl resolve_methods for infer_ctxt {\n+    fn rok(t: ty::t) -> fres<ty::t> {\n+        #debug[\"Resolve OK: %s\", self.ty_to_str(t)];\n+        result::ok(t)\n+    }\n+\n+    fn rerr(v: int) -> fres<ty::t> {\n+        #debug[\"Resolve error: %?\", v];\n+        result::err(v)\n+    }\n+\n+    fn resolve_var(vid: int) -> fres<ty::t> {\n+        let {root:_, bounds} = self.get(vid as uint);\n+\n+        // Nonobvious: prefer the most specific type\n+        // (i.e., the lower bound) to the more general\n+        // one.  More general types in Rust (e.g., fn())\n+        // tend to carry more restrictions or higher\n+        // perf. penalties, so it pays to know more.\n+\n+        alt bounds {\n+          { ub:_, lb:some(t) } if !type_is_bot(t) { self.rok(t) }\n+          { ub:some(t), lb:_ } { self.rok(t) }\n+          { ub:_, lb:some(t) } { self.rok(t) }\n+          { ub:none, lb:none } { self.rerr(vid) }\n+        }\n+    }\n+\n+    fn resolve_ty(typ: ty::t) -> fres<ty::t> {\n+        alt ty::get(typ).struct {\n+          ty::ty_var(vid) { self.resolve_var(vid) }\n+          _ { self.rok(typ) }\n+        }\n+    }\n+\n+    fn subst_vars(unresolved: @mutable option<int>,\n+                  vars_seen: std::list::list<int>,\n+                  vid: int) -> ty::t {\n+        // Should really return a fixup_result instead of a t, but fold_ty\n+        // doesn't allow returning anything but a t.\n+        alt self.resolve_var(vid) {\n+          result::err(vid) {\n+            *unresolved = some(vid);\n+            ret ty::mk_var(self.tcx, vid);\n+          }\n+          result::ok(rt) {\n+            let mut give_up = false;\n+            std::list::iter(vars_seen) {|v|\n+                if v == vid {\n+                    *unresolved = some(-1); // hack: communicate inf ty\n+                    give_up = true;\n+                }\n+            }\n+\n+            // Return the type unchanged, so we can error out\n+            // downstream\n+            if give_up { ret rt; }\n+            ret ty::fold_ty(self.tcx,\n+                            ty::fm_var(\n+                                self.subst_vars(\n+                                    unresolved,\n+                                    std::list::cons(vid, @vars_seen),\n+                                    _)),\n+                            rt);\n+          }\n+        }\n+    }\n+\n+    fn fixup_vars(typ: ty::t) -> fres<ty::t> {\n+        let unresolved = @mutable none::<int>;\n+        let rty =\n+            ty::fold_ty(self.tcx,\n+                        ty::fm_var(\n+                            self.subst_vars(\n+                                unresolved,\n+                                std::list::nil,\n+                                _)),\n+                        typ);\n+\n+        let ur = *unresolved;\n+        alt ur {\n+          none { ret self.rok(rty); }\n+          some(var_id) { ret self.rerr(var_id); }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "81cdb7cc4735f08a98b910efb9bbd5190c07cc14", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -37,7 +37,7 @@ export field;\n export field_idx;\n export get_field;\n export get_fields;\n-export fm_general, fm_rptr;\n+export fm_var, fm_general, fm_rptr;\n export get_element_type;\n export is_binopable;\n export is_pred_ty;\n@@ -140,6 +140,7 @@ export item_path;\n export item_path_str;\n export ast_ty_to_ty_cache_entry;\n export atttce_unresolved, atttce_resolved;\n+export mach_sty;\n \n // Data types\n \n@@ -304,6 +305,8 @@ type constr = constr_general<uint>;\n enum type_err {\n     terr_mismatch,\n     terr_ret_style_mismatch(ast::ret_style, ast::ret_style),\n+    terr_mutability,\n+    terr_proto_mismatch(ast::proto, ast::proto),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -2360,6 +2363,11 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n         ret to_str(actual) + \" function found where \" + to_str(expect) +\n             \" function was expected\";\n       }\n+      terr_proto_mismatch(e, a) {\n+        ret #fmt[\"closure protocol mismatch (%s vs %s)\",\n+                 proto_to_str(e), proto_to_str(a)];\n+      }\n+      terr_mutability { ret \"values differ in mutability\"; }\n       terr_box_mutability { ret \"boxed values differ in mutability\"; }\n       terr_vec_mutability { ret \"vectors differ in mutability\"; }\n       terr_ptr_mutability { ret \"pointers differ in mutability\"; }"}, {"sha": "8d56e3101b5b63833b38a789df17bfc78bffdb78", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 174, "deletions": 79, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -73,7 +73,7 @@ type fn_ctxt =\n     {ret_ty: ty::t,\n      purity: ast::purity,\n      proto: ast::proto,\n-     var_bindings: @ty::unify::var_bindings,\n+     infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, int>,\n      next_var_id: @mutable int,\n      ccx: @crate_ctxt};\n@@ -206,7 +206,7 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n \n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt ty::unify::resolve_type_structure(fcx.var_bindings, tp) {\n+    alt infer::resolve_type_structure(fcx.infcx, tp) {\n       result::ok(typ_s) { ret typ_s; }\n       result::err(_) {\n         fcx.ccx.tcx.sess.span_fatal\n@@ -225,7 +225,7 @@ fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n // is not known yet.\n fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n    option<ty::sty> {\n-    let r = ty::unify::resolve_type_structure(fcx.var_bindings, typ);\n+    let r = infer::resolve_type_structure(fcx.infcx, typ);\n     alt r {\n       result::ok(typ_s) { some(ty::get(typ_s).struct) }\n       result::err(_) { none }\n@@ -798,15 +798,15 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n             if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n                                              self_full(self_ty, impl_tps));\n         }\n-        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n+        alt infer::compare_tys(tcx, impl_fty, if_fty) {\n           result::err(err) {\n             tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n                               \"` has an incompatible type: \" +\n                               ty::type_err_to_str(tcx, err));\n-            impl_fty\n           }\n-          result::ok(tp) { tp }\n+          result::ok(()) { }\n         }\n+        ret impl_fty;\n     }\n }\n \n@@ -1132,16 +1132,14 @@ mod unify {\n                                   rb: @ty::unify::region_bindings,\n                                   expected: ty::t,\n                                   actual: ty::t)\n-            -> result<ty::t, ty::type_err> {\n-        let irb = ty::unify::in_region_bindings(fcx.var_bindings, rb);\n-        ret ty::unify::unify(expected, actual, irb, fcx.ccx.tcx);\n+            -> result<(), ty::type_err> {\n+        //let irb = ty::unify::in_region_bindings(fcx.var_bindings, rb);\n+        ret infer::mk_subty(fcx.infcx, actual, expected);\n     }\n \n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n-        result<ty::t, ty::type_err> {\n-        ret ty::unify::unify(expected, actual,\n-                             ty::unify::in_bindings(fcx.var_bindings),\n-                             fcx.ccx.tcx);\n+        result<(), ty::type_err> {\n+        ret infer::mk_subty(fcx.infcx, actual, expected);\n     }\n }\n \n@@ -1180,13 +1178,12 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n }\n \n fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n-    alt ty::unify::fixup_vars(fcx.ccx.tcx, none, fcx.var_bindings, typ) {\n+    alt infer::fixup_vars(fcx.infcx, typ) {\n       result::ok(new_type) { ret new_type; }\n       result::err(_) { ret typ; }\n     }\n }\n \n-\n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n@@ -1197,6 +1194,11 @@ mod demand {\n         full(fcx, sp, unify::unify, expected, actual, []).ty\n     }\n \n+    // n.b.: order of arguments is reversed.\n+    fn subty(fcx: @fn_ctxt, sp: span, actual: ty::t, expected: ty::t) {\n+        full(fcx, sp, unify::unify, expected, actual, []);\n+    }\n+\n     fn with_region_bindings(fcx: @fn_ctxt,\n                             sp: span,\n                             rb: @ty::unify::region_bindings,\n@@ -1217,7 +1219,7 @@ mod demand {\n     fn full(fcx: @fn_ctxt,\n             sp: span,\n             unifier: fn@(@fn_ctxt, ty::t, ty::t)\n-                -> result<ty::t, ty::type_err>,\n+                -> result<(), ty::type_err>,\n             expected: ty::t,\n             actual: ty::t,\n             ty_param_substs_0: [ty::t]) ->\n@@ -1247,7 +1249,9 @@ mod demand {\n \n \n         alt unifier(fcx, expected, actual) {\n-          result::ok(t) { ret mk_result(fcx, t, ty_param_subst_var_ids); }\n+          result::ok(()) {\n+            ret mk_result(fcx, expected, ty_param_subst_var_ids);\n+          }\n           result::err(err) {\n             let e_err = resolve_type_vars_if_possible(fcx, expected);\n             let a_err = resolve_type_vars_if_possible(fcx, actual);\n@@ -1311,9 +1315,14 @@ mod writeback {\n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n        option<ty::t> {\n         if !ty::type_has_vars(typ) { ret some(typ); }\n-        alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n-                                  typ) {\n+        alt infer::fixup_vars(fcx.infcx, typ) {\n           result::ok(new_type) { ret some(new_type); }\n+          result::err(-1) {\n+            fcx.ccx.tcx.sess.span_err(\n+                sp,\n+                \"can not instantiate infinite type\");\n+            ret none;\n+          }\n           result::err(vid) {\n             if !fcx.ccx.tcx.sess.has_errors() {\n                 fcx.ccx.tcx.sess.span_err(sp, \"cannot determine a type \\\n@@ -1396,16 +1405,29 @@ mod writeback {\n     fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, p.span, p.id);\n+        #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n+               pat_to_str(p), p.id,\n+               ty_to_str(wbcx.fcx.ccx.tcx,\n+                         ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n+                                             p.id))];\n         visit::visit_pat(p, wbcx, v);\n     }\n     fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-        let fix_rslt =\n-            ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx, some(l.span),\n-                                        wbcx.fcx.var_bindings, var_id);\n-        alt fix_rslt {\n-          result::ok(lty) { write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n+        alt infer::resolve_var(wbcx.fcx.infcx, var_id) {\n+          result::ok(lty) {\n+            #debug[\"Type for local %s (id %d) resolved to %s\",\n+                   pat_to_str(l.node.pat), l.node.id,\n+                   ty_to_str(wbcx.fcx.ccx.tcx, lty)];\n+            write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty);\n+          }\n+          result::err(-1) {\n+            wbcx.fcx.ccx.tcx.sess.span_err(\n+                l.span,\n+                \"this local variable has a type of infinite size\");\n+            wbcx.success = false;\n+          }\n           result::err(_) {\n             wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n                                            \"cannot determine a type \\\n@@ -1490,7 +1512,7 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n // Local variable gathering. We gather up all locals and create variable IDs\n // for them before typechecking the function.\n type gather_result =\n-    {var_bindings: @ty::unify::var_bindings,\n+    {infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, int>,\n      next_var_id: @mutable int};\n \n@@ -1500,14 +1522,14 @@ fn gather_locals(ccx: @crate_ctxt,\n                  body: ast::blk,\n                  id: ast::node_id,\n                  old_fcx: option<@fn_ctxt>) -> gather_result {\n-    let {vb: vb, locals: locals, nvi: nvi} = alt old_fcx {\n+    let {infcx, locals, nvi} = alt old_fcx {\n       none {\n-        {vb: ty::unify::mk_var_bindings(),\n+        {infcx: infer::new_infer_ctxt(ccx.tcx),\n          locals: int_hash::<int>(),\n          nvi: @mutable 0}\n       }\n       some(fcx) {\n-        {vb: fcx.var_bindings,\n+        {infcx: fcx.infcx,\n          locals: fcx.locals,\n          nvi: fcx.next_var_id}\n       }\n@@ -1522,8 +1544,7 @@ fn gather_locals(ccx: @crate_ctxt,\n         alt ty_opt {\n           none {/* nothing to do */ }\n           some(typ) {\n-            ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n-                             ty::unify::in_bindings(vb), tcx);\n+            infer::mk_eqty(infcx, ty::mk_var(tcx, var_id), typ);\n           }\n         }\n     };\n@@ -1533,6 +1554,8 @@ fn gather_locals(ccx: @crate_ctxt,\n     let mut i = 0u;\n     for arg: ty::arg in args {\n         assign(decl.inputs[i].id, some(arg.ty));\n+        #debug[\"Argument %s is assigned to <T%d>\",\n+               decl.inputs[i].ident, locals.get(decl.inputs[i].id)];\n         i += 1u;\n     }\n \n@@ -1548,15 +1571,19 @@ fn gather_locals(ccx: @crate_ctxt,\n         }\n \n         assign(local.node.id, local_ty_opt);\n+        #debug[\"Local variable %s is assigned to <T%d>\",\n+               pat_to_str(local.node.pat), locals.get(local.node.id)];\n         visit::visit_local(local, e, v);\n     };\n \n     // Add pattern bindings.\n     let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n         alt p.node {\n-          ast::pat_ident(_, _)\n+          ast::pat_ident(path, _)\n           if !pat_util::pat_is_variant(ccx.tcx.def_map, p) {\n             assign(p.id, none);\n+            #debug[\"Pattern binding %s is assigned to <T%d>\",\n+                   path.node.idents[0], locals.get(p.id)];\n           }\n           _ {}\n         }\n@@ -1577,7 +1604,7 @@ fn gather_locals(ccx: @crate_ctxt,\n               with *visit::default_visitor()};\n \n     visit::visit_block(body, (), visit::mk_vt(visit));\n-    ret {var_bindings: vb,\n+    ret {infcx: infcx,\n          locals: locals,\n          next_var_id: nvi};\n }\n@@ -2419,19 +2446,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                  element_ty: ty::t, body: ast::blk,\n                  node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n-        let element_ty = demand::simple(fcx, local.span, element_ty,\n-                                        ty::mk_var(fcx.ccx.tcx, locid));\n-        let bot = check_decl_local(fcx, local);\n-        check_block_no_value(fcx, body);\n-        // Unify type of decl with element type of the seq\n         demand::simple(fcx, local.span,\n-                       ty::node_id_to_type(fcx.ccx.tcx, local.node.id),\n+                       ty::mk_var(fcx.ccx.tcx, locid),\n                        element_ty);\n+        let bot = check_decl_local(fcx, local);\n+        check_block_no_value(fcx, body);\n         write_nil(fcx.ccx.tcx, node_id);\n         ret bot;\n     }\n \n-\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @fn_ctxt, thn: ast::blk,\n@@ -2470,49 +2493,108 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n                         opname: str, args: [option<@ast::expr>])\n-        -> option<ty::t> {\n+        -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n           some(origin) {\n             let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n-            check_call_or_bind(fcx, op_ex.span, method_ty, args);\n+            let r = check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n-            some(ty::ty_fn_ret(method_ty))\n+            some((ty::ty_fn_ret(method_ty), r.bot))\n           }\n           _ { none }\n         }\n     }\n-    fn check_binop(fcx: @fn_ctxt, ex: @ast::expr, ty: ty::t,\n-                   op: ast::binop, rhs: @ast::expr) -> ty::t {\n-        let resolved_t = structurally_resolved_type(fcx, ex.span, ty);\n+    // could be either a expr_binop or an expr_assign_binop\n+    fn check_binop(fcx: @fn_ctxt, expr: @ast::expr,\n+                   op: ast::binop,\n+                   lhs: @ast::expr,\n+                   rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n-        if ty::is_binopable(tcx, resolved_t, op) {\n-            ret alt op {\n+        let lhs_bot = check_expr(fcx, lhs);\n+        let lhs_t = expr_ty(tcx, lhs);\n+        let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n+        ret alt (op, ty::get(lhs_t).struct) {\n+          (ast::add, ty::ty_vec(lhs_mt)) {\n+            // For adding vectors with type L=[M TL] and R=[M TR], the result\n+            // is somewhat subtle.  Let L_c=[const TL] and R_c=[const TR] be\n+            // const versions of the vectors in L and R.  Next, let T be a\n+            // fresh type variable where TL <: T and TR <: T.  Then the result\n+            // type is a fresh type variable T1 where T1 <: [const T].  This\n+            // allows the result to be either a mutable or immutable vector,\n+            // depending on external demands.\n+            let const_vec_t =\n+                ty::mk_vec(tcx, {ty: next_ty_var(fcx),\n+                                 mutbl: ast::m_const});\n+            demand::simple(fcx, lhs.span, const_vec_t, lhs_t);\n+            let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n+            let result_var = next_ty_var(fcx);\n+            demand::simple(fcx, lhs.span, const_vec_t, result_var);\n+            write_ty(tcx, expr.id, result_var);\n+            lhs_bot | rhs_bot\n+          }\n+\n+          (_, _) if ty::type_is_integral(lhs_t) &&\n+          ast_util::is_shift_binop(op) {\n+            // Shift is a special case: rhs can be any integral type\n+            let rhs_bot = check_expr(fcx, rhs);\n+            let rhs_t = expr_ty(tcx, rhs);\n+            require_integral(fcx, rhs.span, rhs_t);\n+            write_ty(tcx, expr.id, lhs_t);\n+            lhs_bot | rhs_bot\n+          }\n+\n+          (_, _) if ty::is_binopable(tcx, lhs_t, op) {\n+            let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n+            let rhs_t = alt op {\n               ast::eq | ast::lt | ast::le | ast::ne | ast::ge |\n-              ast::gt { ty::mk_bool(tcx) }\n-              _ { resolved_t }\n+              ast::gt {\n+                // these comparison operators are handled in a\n+                // separate case below.\n+                tcx.sess.span_bug(\n+                    expr.span,\n+                    #fmt[\"Comparison operator in expr_binop: %s\",\n+                         ast_util::binop_to_str(op)]);\n+              }\n+              _ { lhs_t }\n             };\n-        }\n+            write_ty(tcx, expr.id, rhs_t);\n+            if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n+            else { lhs_bot }\n+          }\n \n+          (_, _) {\n+            let (result, rhs_bot) =\n+                check_user_binop(fcx, expr, lhs_t, op, rhs);\n+            write_ty(tcx, expr.id, result);\n+            lhs_bot | rhs_bot\n+          }\n+        };\n+    }\n+    fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr, lhs_resolved_t: ty::t,\n+                        op: ast::binop, rhs: @ast::expr) -> (ty::t, bool) {\n+        let tcx = fcx.ccx.tcx;\n         alt binop_method(op) {\n           some(name) {\n-            alt lookup_op_method(fcx, ex, resolved_t, name, [some(rhs)]) {\n-              some(ret_ty) { ret ret_ty; }\n+            alt lookup_op_method(fcx, ex, lhs_resolved_t, name, [some(rhs)]) {\n+              some(pair) { ret pair; }\n               _ {}\n             }\n           }\n           _ {}\n         }\n+        check_expr(fcx, rhs);\n         tcx.sess.span_err(\n             ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n-            \" cannot be applied to type `\" + ty_to_str(tcx, resolved_t) +\n+            \" cannot be applied to type `\" +\n+            ty_to_str(tcx, lhs_resolved_t) +\n             \"`\");\n-        resolved_t\n+        (lhs_resolved_t, false)\n     }\n     fn check_user_unop(fcx: @fn_ctxt, op_str: str, mname: str,\n                        ex: @ast::expr, rhs_t: ty::t) -> ty::t {\n         alt lookup_op_method(fcx, ex, rhs_t, mname, []) {\n-          some(ret_ty) { ret_ty }\n+          some((ret_ty, _)) { ret_ty }\n           _ {\n             fcx.ccx.tcx.sess.span_err(\n                 ex.span, #fmt[\"cannot apply unary operator `%s` to type `%s`\",\n@@ -2530,30 +2612,39 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let typ = check_lit(fcx.ccx, lit);\n         write_ty(tcx, id, typ);\n       }\n-      ast::expr_binary(binop, lhs, rhs) {\n-        let lhs_t = next_ty_var(fcx);\n-        bot = check_expr_with(fcx, lhs, lhs_t);\n-\n-        let rhs_bot = if !ast_util::is_shift_binop(binop) {\n-            check_expr_with(fcx, rhs, lhs_t)\n-        } else {\n-            let rhs_bot = check_expr(fcx, rhs);\n-            let rhs_t = expr_ty(tcx, rhs);\n-            require_integral(fcx, rhs.span, rhs_t);\n-            rhs_bot\n-        };\n-\n-        if !ast_util::lazy_binop(binop) { bot |= rhs_bot; }\n \n-        let result = check_binop(fcx, expr, lhs_t, binop, rhs);\n-        write_ty(tcx, id, result);\n+      // Something of a hack: special rules for comparison operators that\n+      // simply unify LHS and RHS.  This helps with inference as LHS and RHS\n+      // do not need to be \"resolvable\".  Some tests, particularly those with\n+      // complicated iface requirements, fail without this---I think this code\n+      // can be removed if we improve iface resolution to be more eager when\n+      // possible.\n+      ast::expr_binary(ast::eq, lhs, rhs) |\n+      ast::expr_binary(ast::ne, lhs, rhs) |\n+      ast::expr_binary(ast::lt, lhs, rhs) |\n+      ast::expr_binary(ast::le, lhs, rhs) |\n+      ast::expr_binary(ast::gt, lhs, rhs) |\n+      ast::expr_binary(ast::ge, lhs, rhs) {\n+        let tcx = fcx.ccx.tcx;\n+        bot |= check_expr(fcx, lhs);\n+        let lhs_t = expr_ty(tcx, lhs);\n+        bot |= check_expr_with(fcx, rhs, lhs_t);\n+        write_ty(tcx, id, ty::mk_bool(tcx));\n+      }\n+      ast::expr_binary(op, lhs, rhs) {\n+        bot |= check_binop(fcx, expr, op, lhs, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n-        bot = check_assignment(fcx, expr.span, lhs, rhs, id);\n+        bot |= check_binop(fcx, expr, op, lhs, rhs);\n         let lhs_t = ty::expr_ty(tcx, lhs);\n-        let result = check_binop(fcx, expr, lhs_t, op, rhs);\n-        demand::simple(fcx, expr.span, result, lhs_t);\n+        let result_t = ty::expr_ty(tcx, expr);\n+        demand::simple(fcx, expr.span, result_t, lhs_t);\n+\n+        // Overwrite result of check_binop...this preserves existing behavior\n+        // but seems quite dubious with regard to user-defined methods\n+        // and so forth. - Niko\n+        write_nil(tcx, expr.id);\n       }\n       ast::expr_unary(unop, oper) {\n         bot = check_expr(fcx, oper);\n@@ -3036,7 +3127,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                                       raw_base_t);\n             alt lookup_op_method(fcx, expr, resolved, \"[]\",\n                                  [some(idx)]) {\n-              some(ret_ty) { write_ty(tcx, id, ret_ty); }\n+              some((ret_ty, _)) { write_ty(tcx, id, ret_ty); }\n               _ {\n                 tcx.sess.span_fatal(\n                     expr.span, \"cannot index a value of type `\" +\n@@ -3241,7 +3332,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n-          var_bindings: ty::unify::mk_var_bindings(),\n+          infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n           next_var_id: @mutable 0,\n           ccx: ccx};\n@@ -3260,7 +3351,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n-          var_bindings: ty::unify::mk_var_bindings(),\n+          infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n           next_var_id: @mutable 0,\n           ccx: ccx};\n@@ -3438,7 +3529,7 @@ fn check_fn(ccx: @crate_ctxt,\n         @{ret_ty: ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n           proto: proto,\n-          var_bindings: gather_result.var_bindings,\n+          infcx: gather_result.infcx,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n           ccx: ccx};\n@@ -3723,8 +3814,12 @@ mod vtable {\n \n     fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n-        alt ty::unify::fixup_vars(tcx, some(sp), fcx.var_bindings, ty) {\n+        alt infer::fixup_vars(fcx.infcx, ty) {\n           result::ok(new_type) { new_type }\n+          result::err(-1) {\n+            tcx.sess.span_fatal(sp, \"bounded type parameter with \\\n+                                     cyclic type\");\n+          }\n           result::err(vid) {\n             tcx.sess.span_fatal(sp, \"could not determine a type for a \\\n                                      bounded type parameter\");"}, {"sha": "5eb6ca7853f9e11597b432fc7ac3c350c2fe6fbe", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -31,6 +31,7 @@ mod middle {\n         mod reachable;\n     }\n     mod ty;\n+    mod infer;\n     mod ast_map;\n     mod resolve;\n     mod typeck;"}, {"sha": "112308548de6575987800c9e0108754cdd5a215a", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -28,6 +28,15 @@ fn region_to_str(cx: ctxt, region: region) -> str {\n     }\n }\n \n+fn mt_to_str(cx: ctxt, m: mt) -> str {\n+    let mstr = alt m.mutbl {\n+      ast::m_mutbl { \"mut \" }\n+      ast::m_imm { \"\" }\n+      ast::m_const { \"const \" }\n+    };\n+    ret mstr + ty_to_str(cx, m.ty);\n+}\n+\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        str {\n@@ -72,14 +81,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n-    fn mt_to_str(cx: ctxt, m: mt) -> str {\n-        let mstr = alt m.mutbl {\n-          ast::m_mutbl { \"mut \" }\n-          ast::m_imm { \"\" }\n-          ast::m_const { \"const \" }\n-        };\n-        ret mstr + ty_to_str(cx, m.ty);\n-    }\n     fn parameterized(cx: ctxt, base: str, tps: [ty::t]) -> str {\n         if vec::len(tps) > 0u {\n             let strs = vec::map(tps, {|t| ty_to_str(cx, t)});"}, {"sha": "958c1fece7b288569d2aed33f4e2f44ad01323d9", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -170,7 +170,7 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n     let assoc_list = astsrv::exec(srv) {|ctxt|\n \n         let def_map = from_def_assoc_list(def_assoc_list);\n-        let path_map = map::str_hash();\n+        let path_map = map::str_hash::<[(str,doc::itemtag)]>();\n \n         ctxt.exp_map.items {|exp_id, defs|\n             let path = alt check ctxt.ast_map.get(exp_id) {"}, {"sha": "4e055be8a1a27655f6358e68759fcf0d01faada9", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -90,7 +90,7 @@ fn sectionalize(desc: option<str>) -> (option<str>, [doc::section]) {\n \n     let lines = str::lines(option::get(desc));\n \n-    let mut new_desc = none;\n+    let mut new_desc = none::<str>;\n     let mut current_section = none;\n     let mut sections = [];\n "}, {"sha": "865b283e01d2a359f41d064f9bcf96e26688faf5", "filename": "src/test/auxiliary/noexporttypelib.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -0,0 +1,3 @@\n+export foo;\n+type oint = option<int>;\n+fn foo() -> oint { some(3) }"}, {"sha": "e2669be751b21022f37721f9f5f0326066c21a8c", "filename": "src/test/compile-fail/binop-typeck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-typeck.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,4 +1,8 @@\n-// error-pattern:mismatched types\n // issue #500\n \n-fn main() { let x = true; let y = 1; let z = x + y; }\n+fn main() {\n+    let x = true;\n+    let y = 1;\n+    let z = x + y;\n+    //!^ ERROR binary operation + cannot be applied to type `bool`\n+}"}, {"sha": "c5a7cba4ea0734b0ff6f889daebc7d0fbe2630b7", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -7,5 +7,5 @@ fn apply_int(f: fn(int) -> int, a: int) -> int { f(a) }\n fn main() {\n     let f = {|i| i};\n     assert apply_int(f, 2) == 2;\n-    assert apply(f, 2) == 2; //! ERROR expected argument mode ++\n+    assert apply(f, 2) == 2; //! ERROR expected argument mode &&\n }"}, {"sha": "895322309d0f3a4e4df0b17206e9089a9d8800df", "filename": "src/test/compile-fail/mutable-huh-variance-vec1.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,11 +1,12 @@\n-// error-pattern: mismatched types\n-\n fn main() {\n-    let v = [mutable [0]];\n+    // Note: explicit type annot is required here\n+    // because otherwise the inference gets smart\n+    // and assigns a type of [mut [const int]].\n+    let v: [mut [int]] = [mutable [0]];\n \n     fn f(&&v: [mutable [const int]]) {\n         v[0] = [mutable 3]\n     }\n \n-    f(v);\n+    f(v); //! ERROR (values differ in mutability)\n }"}, {"sha": "3a0725f6643dcef583683ebd5461ce7ff2ba5d03", "filename": "src/test/compile-fail/mutable-huh-variance-vec2.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,11 +1,12 @@\n-// error-pattern: mismatched types\n-\n fn main() {\n-    let v = [mutable [mutable 0]];\n+    // Note: explicit type annot is required here\n+    // because otherwise the inference gets smart\n+    // and assigns a type of [mut [const int]].\n+    let v: [mut [mut int]] = [mutable [mutable 0]];\n \n     fn f(&&v: [mutable [const int]]) {\n         v[0] = [3]\n     }\n \n-    f(v);\n+    f(v); //! ERROR (values differ in mutability)\n }"}, {"sha": "786535dd4bcb2bfd49d5cf0951273e6b7b5d9566", "filename": "src/test/compile-fail/mutable-huh-variance-vec3.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,11 +1,12 @@\n-// error-pattern: mismatched types\n-\n fn main() {\n-    let v = [mutable [mutable [0]]];\n+    // Note: explicit type annot is required here\n+    // because otherwise the inference gets smart\n+    // and assigns a type of [mut [const int]].\n+    let v: [mut[mut[int]]] = [mutable [mutable [0]]];\n \n     fn f(&&v: [mutable [mutable [const int]]]) {\n         v[0][1] = [mutable 3]\n     }\n \n-    f(v);\n+    f(v); //! ERROR (values differ in mutability)\n }"}, {"sha": "b88f3b34c61df69b523d45df54056685e075b714", "filename": "src/test/compile-fail/noexporttypeexe.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -0,0 +1,13 @@\n+// aux-build:noexporttypelib.rs\n+\n+use noexporttypelib;\n+\n+fn main() {\n+    // Here, the type returned by foo() is not exported.\n+    // This used to cause internal errors when serializing\n+    // because the def_id associated with the type was\n+    // not convertible to a path.\n+  let x: int = noexporttypelib::foo();\n+    //!^ ERROR expected `int` but found `core::option::option<int>`\n+}\n+"}, {"sha": "4c4cacb36e7ebea0129b1a05bef07385b016a1d5", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,2 +1,4 @@\n-// error-pattern: can not instantiate infinite type\n-fn main() { let f; f = @f; }\n+fn main() {\n+    let f; //! ERROR this local variable has a type of infinite size\n+    f = @f;\n+}"}, {"sha": "08deb8a2d7c36045dd8988555c5fea6bb6de80a2", "filename": "src/test/compile-fail/type-mismatch.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -1,4 +1,8 @@\n-// error-pattern:expected `bool` but found `int`\n // issue #516\n \n-fn main() { let x = true; let y = 1; let z = x + y; }\n+fn main() {\n+    let x = true;\n+    let y = 1;\n+    let z = x + y;\n+    //!^ ERROR binary operation + cannot be applied to type `bool`\n+}"}, {"sha": "02e37aac6b882aeff6235cefce9a6588b522cbd8", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042c532a084fa3871a3a2d8955ff82c246db8015/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=042c532a084fa3871a3a2d8955ff82c246db8015", "patch": "@@ -0,0 +1,13 @@\n+fn concat<T: copy>(v: [const [const T]]) -> [T] {\n+    let mut r = [];\n+\n+    // Earlier versions of our type checker accepted this:\n+    for inner: [T] in v {\n+        //!^ ERROR found `[const 'a]` (values differ in mutability)\n+        r += inner;\n+    }\n+\n+    ret r;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}]}