{"sha": "54e97e889b97aa04d477329e26299a1bbc6fefe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZTk3ZTg4OWI5N2FhMDRkNDc3MzI5ZTI2Mjk5YTFiYmM2ZmVmZTI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T17:33:39Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T17:59:37Z"}, "message": "Factor out slice constructor struct and simplify", "tree": {"sha": "3384b38eedf2934968bf36aaf42aadbe1579b7df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3384b38eedf2934968bf36aaf42aadbe1579b7df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54e97e889b97aa04d477329e26299a1bbc6fefe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54e97e889b97aa04d477329e26299a1bbc6fefe2", "html_url": "https://github.com/rust-lang/rust/commit/54e97e889b97aa04d477329e26299a1bbc6fefe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54e97e889b97aa04d477329e26299a1bbc6fefe2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "html_url": "https://github.com/rust-lang/rust/commit/d0cfef32a8439b6936d9348e2ec17397fe2baeb2"}], "stats": {"total": 301, "additions": 160, "deletions": 141}, "files": [{"sha": "51ee1f29bf8e78a7227af327797e71ff7c0459d6", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 160, "deletions": 141, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/54e97e889b97aa04d477329e26299a1bbc6fefe2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54e97e889b97aa04d477329e26299a1bbc6fefe2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=54e97e889b97aa04d477329e26299a1bbc6fefe2", "patch": "@@ -583,21 +583,110 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n-    /// Array patterns of length `n`.\n+    /// Patterns of length `n` (`[x, y]`).\n     FixedLen(u64),\n-    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n+    /// Patterns using the `..` notation (`[x, .., y]`). Captures any array constructor of `length\n+    /// >= i + j`. In the case where `array_len` is `Some(_)`, this indicates that we only care\n+    /// about the first `i` and the last `j` values of the array, and everything in between is a\n+    /// wildcard `_`.\n     VarLen(u64, u64),\n }\n \n-impl SliceKind {\n-    fn arity(self) -> u64 {\n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct Slice {\n+    /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n+    array_len: Option<u64>,\n+    /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n+    kind: SliceKind,\n+}\n+\n+impl Slice {\n+    /// Returns what patterns this constructor covers: either fixed-length patterns or\n+    /// variable-length patterns.\n+    fn pattern_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n+                if prefix + suffix == len =>\n+            {\n+                FixedLen(len)\n+            }\n+            _ => self.kind,\n+        }\n+    }\n+\n+    /// Returns what values this constructor covers: either values of only one given length, or\n+    /// values of length above a given length.\n+    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n+    /// account a subset of the entries of the array, but still only captures values of a given\n+    /// length.\n+    fn value_kind(self) -> SliceKind {\n         match self {\n+            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n+            _ => self.kind,\n+        }\n+    }\n+\n+    fn arity(self) -> u64 {\n+        match self.pattern_kind() {\n             FixedLen(length) => length,\n             VarLen(prefix, suffix) => prefix + suffix,\n         }\n     }\n+\n+    /// Whether this pattern includes patterns of length `other_len`.\n+    fn covers_length(self, other_len: u64) -> bool {\n+        match self.value_kind() {\n+            FixedLen(len) => len == other_len,\n+            VarLen(prefix, suffix) => prefix + suffix <= other_len,\n+        }\n+    }\n+\n+    /// Returns a collection of slices that spans the values covered by `self`, subtracted by the\n+    /// values covered by `other`: i.e., `self \\ other` (in set notation).\n+    fn subtract(self, other: Self) -> SmallVec<[Self; 1]> {\n+        // Remember, `VarLen(i, j)` covers the union of `FixedLen` from `i + j` to infinity.\n+        // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+        match self.value_kind() {\n+            FixedLen(pos_len) => {\n+                if other.covers_length(pos_len) {\n+                    smallvec![]\n+                } else {\n+                    smallvec![self]\n+                }\n+            }\n+            VarLen(pos_prefix, pos_suffix) => {\n+                let pos_len = pos_prefix + pos_suffix;\n+                match other.value_kind() {\n+                    FixedLen(neg_len) => {\n+                        if neg_len < pos_len {\n+                            smallvec![self]\n+                        } else {\n+                            (pos_len..neg_len)\n+                                .map(FixedLen)\n+                                // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n+                                .chain(Some(VarLen(neg_len + 1 - pos_suffix, pos_suffix)))\n+                                .map(|kind| Slice { array_len: None, kind })\n+                                .collect()\n+                        }\n+                    }\n+                    VarLen(neg_prefix, neg_suffix) => {\n+                        let neg_len = neg_prefix + neg_suffix;\n+                        if neg_len <= pos_len {\n+                            smallvec![]\n+                        } else {\n+                            (pos_len..neg_len)\n+                                .map(FixedLen)\n+                                .map(|kind| Slice { array_len: None, kind })\n+                                .collect()\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -614,19 +703,15 @@ enum Constructor<'tcx> {\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array and slice patterns.\n-    Slice {\n-        // The length of the type of the pattern, if fixed.\n-        type_len: Option<u64>,\n-        kind: SliceKind,\n-    },\n+    Slice(Slice),\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            Slice { .. } => true,\n+            Slice(_) => true,\n             _ => false,\n         }\n     }\n@@ -655,104 +740,41 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &Slice { type_len: Some(self_len), .. } | &Slice { kind: FixedLen(self_len), .. } => {\n-                let overlaps = |c: &Constructor<'_>| match *c {\n-                    Slice { type_len: Some(len), .. } | Slice { kind: FixedLen(len), .. } => {\n-                        len == self_len\n-                    }\n-                    Slice { type_len: None, kind: VarLen(prefix, suffix) } => {\n-                        prefix + suffix <= self_len\n+            &Slice(slice) => match slice.value_kind() {\n+                FixedLen(self_len) => {\n+                    let overlaps = |c: &Constructor<'_>| match *c {\n+                        Slice(other_slice) => other_slice.covers_length(self_len),\n+                        _ => false,\n+                    };\n+                    if other_ctors.iter().any(overlaps) { vec![] } else { vec![Slice(slice)] }\n+                }\n+                VarLen(..) => {\n+                    let mut remaining_slices = vec![slice];\n+\n+                    // For each used slice, subtract from the current set of slices.\n+                    // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+                    for neg_ctor in other_ctors {\n+                        let neg_slice = match neg_ctor {\n+                            Slice(slice) => *slice,\n+                            // FIXME(#65413): If `neg_ctor` is not a slice, we assume it doesn't\n+                            // cover any value here.\n+                            _ => continue,\n+                        };\n+                        remaining_slices = remaining_slices\n+                            .into_iter()\n+                            .flat_map(|pos_slice| pos_slice.subtract(neg_slice))\n+                            .collect();\n+\n+                        // If the constructors that have been considered so far already cover\n+                        // the entire range of `self`, no need to look at more constructors.\n+                        if remaining_slices.is_empty() {\n+                            break;\n+                        }\n                     }\n-                    _ => false,\n-                };\n-                if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n-            }\n-            Slice { type_len: None, kind: VarLen(..) } => {\n-                let mut remaining_ctors = vec![self.clone()];\n-\n-                // For each used ctor, subtract from the current set of constructors.\n-                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                // Remember, `VarLen(i, j)` covers the union of `FixedLen` from\n-                // `i + j` to infinity.\n-                for neg_ctor in other_ctors {\n-                    remaining_ctors = remaining_ctors\n-                        .into_iter()\n-                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n-                            // Compute `pos_ctor \\ neg_ctor`.\n-                            match pos_ctor {\n-                                Slice { type_len: Some(pos_len), .. }\n-                                | Slice { kind: FixedLen(pos_len), .. } => match *neg_ctor {\n-                                    Slice { type_len: Some(neg_len), .. }\n-                                    | Slice { kind: FixedLen(neg_len), .. }\n-                                        if neg_len == pos_len =>\n-                                    {\n-                                        smallvec![]\n-                                    }\n-                                    Slice {\n-                                        type_len: None,\n-                                        kind: VarLen(neg_prefix, neg_suffix),\n-                                    } if neg_prefix + neg_suffix <= pos_len => smallvec![],\n-                                    _ => smallvec![pos_ctor],\n-                                },\n-                                Slice { type_len: None, kind: VarLen(pos_prefix, pos_suffix) } => {\n-                                    let pos_len = pos_prefix + pos_suffix;\n-                                    match *neg_ctor {\n-                                        Slice { type_len: Some(neg_len), .. }\n-                                        | Slice { kind: FixedLen(neg_len), .. }\n-                                            if neg_len >= pos_len =>\n-                                        {\n-                                            (pos_len..neg_len)\n-                                                .map(|l| Slice {\n-                                                    type_len: None,\n-                                                    kind: FixedLen(l),\n-                                                })\n-                                                // We know that `neg_len + 1 >= pos_len >=\n-                                                // pos_suffix`.\n-                                                .chain(Some(Slice {\n-                                                    type_len: None,\n-                                                    kind: VarLen(\n-                                                        neg_len + 1 - pos_suffix,\n-                                                        pos_suffix,\n-                                                    ),\n-                                                }))\n-                                                .collect()\n-                                        }\n-                                        Slice {\n-                                            type_len: None,\n-                                            kind: VarLen(neg_prefix, neg_suffix),\n-                                        } => {\n-                                            let neg_len = neg_prefix + neg_suffix;\n-                                            if neg_len <= pos_len {\n-                                                smallvec![]\n-                                            } else {\n-                                                (pos_len..neg_len)\n-                                                    .map(|l| Slice {\n-                                                        type_len: None,\n-                                                        kind: FixedLen(l),\n-                                                    })\n-                                                    .collect()\n-                                            }\n-                                        }\n-                                        _ => smallvec![pos_ctor],\n-                                    }\n-                                }\n-                                _ => bug!(\n-                                    \"unexpected ctor while subtracting from VarLen: {:?}\",\n-                                    pos_ctor\n-                                ),\n-                            }\n-                        })\n-                        .collect();\n \n-                    // If the constructors that have been considered so far already cover\n-                    // the entire range of `self`, no need to look at more constructors.\n-                    if remaining_ctors.is_empty() {\n-                        break;\n-                    }\n+                    remaining_slices.into_iter().map(Slice).collect()\n                 }\n-\n-                remaining_ctors\n-            }\n+            },\n             IntRange(self_range) => {\n                 let mut remaining_ranges = vec![self_range.clone()];\n                 for other_ctor in other_ctors {\n@@ -845,7 +867,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => vec![],\n             },\n-            Slice { .. } => match ty.kind {\n+            Slice(_) => match ty.kind {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = self.arity(cx, ty);\n                     (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n@@ -875,7 +897,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => 0,\n             },\n-            Slice { kind, .. } => kind.arity(),\n+            Slice(slice) => slice.arity(),\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n@@ -930,20 +952,17 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n-            Slice { kind: FixedLen(_), .. } => {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n-            Slice { type_len: Some(len), kind: VarLen(prefix, suffix) }\n-                if prefix + suffix == *len =>\n-            {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n-            Slice { kind: VarLen(prefix, _), .. } => {\n-                let prefix = subpatterns.by_ref().take(*prefix as usize).collect();\n-                let suffix = subpatterns.collect();\n-                let wild = Pat::wildcard_from_ty(ty);\n-                PatKind::Slice { prefix, slice: Some(wild), suffix }\n-            }\n+            Slice(slice) => match slice.pattern_kind() {\n+                FixedLen(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLen(prefix, _) => {\n+                    let prefix = subpatterns.by_ref().take(prefix as usize).collect();\n+                    let suffix = subpatterns.collect();\n+                    let wild = Pat::wildcard_from_ty(ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+            },\n             &ConstantValue(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n@@ -1159,16 +1178,13 @@ fn all_constructors<'a, 'tcx>(\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n-                vec![Slice { type_len: Some(len), kind: VarLen(0, 0) }]\n+                vec![Slice(Slice { array_len: Some(len), kind: VarLen(0, 0) })]\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n-            if cx.is_uninhabited(sub_ty) {\n-                vec![Slice { type_len: None, kind: FixedLen(0) }]\n-            } else {\n-                vec![Slice { type_len: None, kind: VarLen(0, 0) }]\n-            }\n+            let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+            vec![Slice(Slice { array_len: None, kind })]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             let ctors: Vec<_> = def\n@@ -1750,7 +1766,7 @@ fn pat_constructor<'tcx>(\n         }\n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let type_len = match pat.ty.kind {\n+            let array_len = match pat.ty.kind {\n                 ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n                 ty::Slice(_) => None,\n                 _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n@@ -1759,7 +1775,7 @@ fn pat_constructor<'tcx>(\n             let suffix = suffix.len() as u64;\n             let kind =\n                 if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n-            Some(Slice { type_len, kind })\n+            Some(Slice(Slice { array_len, kind }))\n         }\n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n@@ -1975,7 +1991,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         .map(IntRange),\n                 );\n             }\n-            Slice { kind: VarLen(self_prefix, self_suffix), type_len } => {\n+            Slice(Slice { array_len, kind: VarLen(self_prefix, self_suffix) }) => {\n                 // The exhaustiveness-checking paper does not include any details on\n                 // checking variable-length slice patterns. However, they are matched\n                 // by an infinite collection of fixed-length array patterns.\n@@ -2084,26 +2100,29 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n                 }\n \n-                match type_len {\n+                match array_len {\n                     Some(len) => {\n                         let kind = if max_prefix_len + max_suffix_len < len {\n                             VarLen(max_prefix_len, max_suffix_len)\n                         } else {\n                             FixedLen(len)\n                         };\n-                        split_ctors.push(Slice { type_len, kind });\n+                        split_ctors.push(Slice(Slice { array_len, kind }));\n                     }\n                     None => {\n-                        // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n-                        // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n-                        // are treated independently as fixed-lengths slices, and lengths above are\n-                        // captured by a final VarLen constructor.\n+                        // `ctor` originally covered the range `(self_prefix +\n+                        // self_suffix..infinity)`. We now split it into two: lengths smaller than\n+                        // `max_prefix_len + max_suffix_len` are treated independently as\n+                        // fixed-lengths slices, and lengths above are captured by a final VarLen\n+                        // constructor.\n                         split_ctors.extend(\n                             (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n-                                .map(|len| Slice { type_len, kind: FixedLen(len) }),\n+                                .map(|len| Slice(Slice { array_len, kind: FixedLen(len) })),\n                         );\n-                        split_ctors\n-                            .push(Slice { type_len, kind: VarLen(max_prefix_len, max_suffix_len) });\n+                        split_ctors.push(Slice(Slice {\n+                            array_len,\n+                            kind: VarLen(max_prefix_len, max_suffix_len),\n+                        }));\n                     }\n                 }\n             }\n@@ -2324,7 +2343,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            Slice { .. } => {\n+            Slice(_) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}]}