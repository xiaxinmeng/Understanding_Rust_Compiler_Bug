{"sha": "453e6b97ace822f715b6118a60ec9b33e0ae87ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1M2U2Yjk3YWNlODIyZjcxNWI2MTE4YTYwZWM5YjMzZTBhZTg3ZWM=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-09T20:26:46Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Add check_needless_collect to its own module", "tree": {"sha": "0eeecc54c596580ef3d342b4a84fac568e7d4a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eeecc54c596580ef3d342b4a84fac568e7d4a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/453e6b97ace822f715b6118a60ec9b33e0ae87ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/453e6b97ace822f715b6118a60ec9b33e0ae87ec", "html_url": "https://github.com/rust-lang/rust/commit/453e6b97ace822f715b6118a60ec9b33e0ae87ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/453e6b97ace822f715b6118a60ec9b33e0ae87ec/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9520cba554e2844c92ede32066138c38de3d327f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9520cba554e2844c92ede32066138c38de3d327f", "html_url": "https://github.com/rust-lang/rust/commit/9520cba554e2844c92ede32066138c38de3d327f"}], "stats": {"total": 564, "additions": 289, "deletions": 275}, "files": [{"sha": "043bbc9d1c589365224f946c5e3b2bb14755d8cb", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 7, "deletions": 275, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/453e6b97ace822f715b6118a60ec9b33e0ae87ec/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453e6b97ace822f715b6118a60ec9b33e0ae87ec/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=453e6b97ace822f715b6118a60ec9b33e0ae87ec", "patch": "@@ -6,15 +6,16 @@ mod for_mut_range_bound;\n mod for_single_element_loop;\n mod infinite_loop;\n mod manual_flatten;\n+mod needless_collect;\n mod utils;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, higher, implements_trait, is_in_panic_handler,\n     is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    match_type, path_to_local, path_to_local_id, paths, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n+    path_to_local, path_to_local_id, paths, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -23,16 +24,16 @@ use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand, Local,\n-    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, MatchSource,\n+    Mutability, Node, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Symbol};\n use std::iter::{once, Iterator};\n use utils::{get_span_of_entire_for_loop, make_iterator_snippet};\n \n@@ -686,7 +687,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n             infinite_loop::check_infinite_loop(cx, cond, body);\n         }\n \n-        check_needless_collect(expr, cx);\n+        needless_collect::check_needless_collect(expr, cx);\n     }\n }\n \n@@ -1894,272 +1895,3 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         NestedVisitorMap::None\n     }\n }\n-\n-const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n-\n-fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    check_needless_collect_direct_usage(expr, cx);\n-    check_needless_collect_indirect_usage(expr, cx);\n-}\n-fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n-        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n-        if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n-        if let Some(ref generic_args) = chain_method.args;\n-        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        then {\n-            let ty = cx.typeck_results().node_type(ty.hir_id);\n-            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n-                match_type(cx, ty, &paths::BTREEMAP) ||\n-                is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n-                if method.ident.name == sym!(len) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"count()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(is_empty) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"next().is_none()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(contains) {\n-                    let contains_arg = snippet(cx, args[1].span, \"??\");\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        |diag| {\n-                            let (arg, pred) = contains_arg\n-                                    .strip_prefix('&')\n-                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                            diag.span_suggestion(\n-                                span,\n-                                \"replace with\",\n-                                format!(\n-                                    \"any(|{}| x == {})\",\n-                                    arg, pred\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if let ExprKind::Block(ref block, _) = expr.kind {\n-        for ref stmt in block.stmts {\n-            if_chain! {\n-                if let StmtKind::Local(\n-                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(ref init_expr), .. }\n-                ) = stmt.kind;\n-                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n-                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n-                if let Some(ref generic_args) = method_name.args;\n-                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-                if let ty = cx.typeck_results().node_type(ty.hir_id);\n-                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n-                    match_type(cx, ty, &paths::LINKED_LIST);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n-                if iter_calls.len() == 1;\n-                then {\n-                    let mut used_count_visitor = UsedCountVisitor {\n-                        cx,\n-                        id: *pat_id,\n-                        count: 0,\n-                    };\n-                    walk_block(&mut used_count_visitor, block);\n-                    if used_count_visitor.count > 1 {\n-                        return;\n-                    }\n-\n-                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n-                    let iter_call = &iter_calls[0];\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        stmt.span.until(iter_call.span),\n-                        NEEDLESS_COLLECT_MSG,\n-                        |diag| {\n-                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n-                            diag.multipart_suggestion(\n-                                iter_call.get_suggestion_text(),\n-                                vec![\n-                                    (stmt.span, String::new()),\n-                                    (iter_call.span, iter_replacement)\n-                                ],\n-                                Applicability::MachineApplicable,// MaybeIncorrect,\n-                            ).emit();\n-                        },\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct IterFunction {\n-    func: IterFunctionKind,\n-    span: Span,\n-}\n-impl IterFunction {\n-    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n-        match &self.func {\n-            IterFunctionKind::IntoIter => String::new(),\n-            IterFunctionKind::Len => String::from(\".count()\"),\n-            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n-            IterFunctionKind::Contains(span) => {\n-                let s = snippet(cx, *span, \"..\");\n-                if let Some(stripped) = s.strip_prefix('&') {\n-                    format!(\".any(|x| x == {})\", stripped)\n-                } else {\n-                    format!(\".any(|x| x == *{})\", s)\n-                }\n-            },\n-        }\n-    }\n-    fn get_suggestion_text(&self) -> &'static str {\n-        match &self.func {\n-            IterFunctionKind::IntoIter => {\n-                \"use the original Iterator instead of collecting it and then producing a new one\"\n-            },\n-            IterFunctionKind::Len => {\n-                \"take the original Iterator's count instead of collecting it and finding the length\"\n-            },\n-            IterFunctionKind::IsEmpty => {\n-                \"check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n-            },\n-            IterFunctionKind::Contains(_) => {\n-                \"check if the original Iterator contains an element instead of collecting then checking\"\n-            },\n-        }\n-    }\n-}\n-enum IterFunctionKind {\n-    IntoIter,\n-    Len,\n-    IsEmpty,\n-    Contains(Span),\n-}\n-\n-struct IterFunctionVisitor {\n-    uses: Vec<IterFunction>,\n-    seen_other: bool,\n-    target: Ident,\n-}\n-impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        // Check function calls on our collection\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                let len = sym!(len);\n-                let is_empty = sym!(is_empty);\n-                let contains = sym!(contains);\n-                match method_name.ident.name {\n-                    sym::into_iter => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n-                    ),\n-                    name if name == len => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n-                    ),\n-                    name if name == is_empty => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n-                    ),\n-                    name if name == contains => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n-                    ),\n-                    _ => self.seen_other = true,\n-                }\n-                return\n-            }\n-        }\n-        // Check if the collection is used for anything else\n-        if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                self.seen_other = true;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n-        }\n-    }\n-\n-    type Map = Map<'tcx>;\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-struct UsedCountVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    id: HirId,\n-    count: usize,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if path_to_local_id(expr, self.id) {\n-            self.count += 1;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n-}\n-\n-/// Detect the occurrences of calls to `iter` or `into_iter` for the\n-/// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n-    let mut visitor = IterFunctionVisitor {\n-        uses: Vec::new(),\n-        target: identifier,\n-        seen_other: false,\n-    };\n-    visitor.visit_block(block);\n-    if visitor.seen_other { None } else { Some(visitor.uses) }\n-}\n-\n-fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n-    if_chain! {\n-        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n-        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n-        then {\n-            return expr.span.with_lo(span.lo());\n-        }\n-    }\n-    unreachable!();\n-}"}, {"sha": "cc2e297549276f38e85c924912f31afdc35bf1a1", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/453e6b97ace822f715b6118a60ec9b33e0ae87ec/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453e6b97ace822f715b6118a60ec9b33e0ae87ec/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=453e6b97ace822f715b6118a60ec9b33e0ae87ec", "patch": "@@ -0,0 +1,282 @@\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, match_type, path_to_local_id, paths, snippet, span_lint_and_sugg,\n+    span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Expr, ExprKind, GenericArg, HirId, Local, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::{sym, Ident};\n+\n+const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n+\n+pub(super) fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n+        if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n+        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+        then {\n+            let ty = cx.typeck_results().node_type(ty.hir_id);\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                match_type(cx, ty, &paths::BTREEMAP) ||\n+                is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n+                if method.ident.name == sym!(len) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"count()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(is_empty) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"next().is_none()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(contains) {\n+                    let contains_arg = snippet(cx, args[1].span, \"??\");\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let (arg, pred) = contains_arg\n+                                    .strip_prefix('&')\n+                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                            diag.span_suggestion(\n+                                span,\n+                                \"replace with\",\n+                                format!(\n+                                    \"any(|{}| x == {})\",\n+                                    arg, pred\n+                                ),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    let mut used_count_visitor = UsedCountVisitor {\n+                        cx,\n+                        id: *pat_id,\n+                        count: 0,\n+                    };\n+                    walk_block(&mut used_count_visitor, block);\n+                    if used_count_visitor.count > 1 {\n+                        return;\n+                    }\n+\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => {\n+                let s = snippet(cx, *span, \"..\");\n+                if let Some(stripped) = s.strip_prefix('&') {\n+                    format!(\".any(|x| x == {})\", stripped)\n+                } else {\n+                    format!(\".any(|x| x == *{})\", s)\n+                }\n+            },\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct UsedCountVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    id: HirId,\n+    count: usize,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if path_to_local_id(expr, self.id) {\n+            self.count += 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+/// Detect the occurrences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other { None } else { Some(visitor.uses) }\n+}\n+\n+fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n+    if_chain! {\n+        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n+        then {\n+            return expr.span.with_lo(span.lo());\n+        }\n+    }\n+    unreachable!();\n+}"}]}