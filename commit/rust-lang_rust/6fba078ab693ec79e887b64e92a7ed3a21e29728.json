{"sha": "6fba078ab693ec79e887b64e92a7ed3a21e29728", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYmEwNzhhYjY5M2VjNzllODg3YjY0ZTkyYTdlZDNhMjFlMjk3Mjg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-15T18:10:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-15T18:10:13Z"}, "message": "Merge #557\n\n557: remove Canceled from impl of ra_ide_api r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b97ae214a8616def416b64fb07287ac66554ed3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b97ae214a8616def416b64fb07287ac66554ed3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fba078ab693ec79e887b64e92a7ed3a21e29728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fba078ab693ec79e887b64e92a7ed3a21e29728", "html_url": "https://github.com/rust-lang/rust/commit/6fba078ab693ec79e887b64e92a7ed3a21e29728", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fba078ab693ec79e887b64e92a7ed3a21e29728/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "05ed6c548a7672e2c9472276a652c374a5d2a212", "url": "https://api.github.com/repos/rust-lang/rust/commits/05ed6c548a7672e2c9472276a652c374a5d2a212", "html_url": "https://github.com/rust-lang/rust/commit/05ed6c548a7672e2c9472276a652c374a5d2a212"}, {"sha": "0bb170a277582f5f17c21cddd27a11f19750fa36", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bb170a277582f5f17c21cddd27a11f19750fa36", "html_url": "https://github.com/rust-lang/rust/commit/0bb170a277582f5f17c21cddd27a11f19750fa36"}], "stats": {"total": 610, "additions": 254, "deletions": 356}, "files": [{"sha": "439080075593095204482bd106f959ba1e7fccb4", "filename": "crates/ra_db/src/cancellation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fcancellation.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -21,8 +21,6 @@ pub struct Canceled {\n     _private: (),\n }\n \n-pub type Cancelable<T> = Result<T, Canceled>;\n-\n impl Canceled {\n     pub(crate) fn new() -> Canceled {\n         Canceled { _private: () }"}, {"sha": "89113e7a6ff641ae16bc7cad55a4502d6c2f09c9", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -10,7 +10,7 @@ use std::panic;\n use ra_syntax::{TextUnit, TextRange, SourceFile, TreeArc};\n \n pub use crate::{\n-    cancellation::{Canceled, Cancelable},\n+    cancellation::Canceled,\n     syntax_ptr::LocalSyntaxPtr,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,"}, {"sha": "d87fe70493ae0453f2ba87141e1fcdbb035307f7", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,6 +1,5 @@\n use std::sync::Arc;\n \n-use ra_db::Cancelable;\n use ra_syntax::{\n     SyntaxNode,\n     ast::{self, NameOwner, StructFlavor, AstNode}\n@@ -18,8 +17,8 @@ impl Struct {\n         Struct { def_id }\n     }\n \n-    pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n-        Ok(db.struct_data(self.def_id).variant_data.clone())\n+    pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n+        db.struct_data(self.def_id).variant_data.clone()\n     }\n }\n "}, {"sha": "0cf7deac979207af99ea42bfd338aa327b18da4c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n-use ra_db::{CrateId, Cancelable, FileId};\n+use ra_db::{CrateId, FileId};\n use ra_syntax::{ast, TreeArc, SyntaxNode};\n \n use crate::{\n@@ -142,10 +142,7 @@ impl Module {\n         self.resolve_path_impl(db, path)\n     }\n \n-    pub fn problems(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Cancelable<Vec<(TreeArc<SyntaxNode>, Problem)>> {\n+    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         self.problems_impl(db)\n     }\n }\n@@ -160,7 +157,7 @@ impl StructField {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n-    pub fn ty(&self, db: &impl HirDatabase) -> Cancelable<Option<Ty>> {\n+    pub fn ty(&self, db: &impl HirDatabase) -> Option<Ty> {\n         db.type_for_field(self.struct_.def_id, self.name.clone())\n     }\n }\n@@ -318,7 +315,7 @@ impl Function {\n         db.fn_signature(self.def_id)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n+    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.def_id)\n     }\n }"}, {"sha": "a5c032d696179d07c27126ef38d485175ca68405", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{Cancelable, SourceRootId, FileId};\n+use ra_db::{SourceRootId, FileId};\n use ra_syntax::{ast, SyntaxNode, AstNode, TreeArc};\n \n use crate::{\n@@ -176,12 +176,9 @@ impl Module {\n         curr_per_ns\n     }\n \n-    pub fn problems_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Cancelable<Vec<(TreeArc<SyntaxNode>, Problem)>> {\n+    pub fn problems_impl(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n-        Ok(loc.module_id.problems(&module_tree, db))\n+        loc.module_id.problems(&module_tree, db)\n     }\n }"}, {"sha": "0a0994f5f7f7c70cc7e7156d9d5d00c0829c34b5", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n+use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase};\n \n use crate::{\n     DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n@@ -52,17 +52,17 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::adt::EnumVariantData::enum_variant_data_query;\n     }\n \n-    fn infer(def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+    fn infer(def_id: DefId) -> Arc<InferenceResult> {\n         type InferQuery;\n         use fn crate::ty::infer;\n     }\n \n-    fn type_for_def(def_id: DefId) -> Cancelable<Ty> {\n+    fn type_for_def(def_id: DefId) -> Ty {\n         type TypeForDefQuery;\n         use fn crate::ty::type_for_def;\n     }\n \n-    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Option<Ty>> {\n+    fn type_for_field(def_id: DefId, field: Name) -> Option<Ty> {\n         type TypeForFieldQuery;\n         use fn crate::ty::type_for_field;\n     }\n@@ -102,7 +102,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::impl_block::impls_in_module;\n     }\n \n-    fn impls_in_crate(krate: Crate) -> Cancelable<Arc<CrateImplBlocks>> {\n+    fn impls_in_crate(krate: Crate) -> Arc<CrateImplBlocks> {\n         type ImplsInCrateQuery;\n         use fn crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query;\n     }"}, {"sha": "ef7d049eeeb1812f2b554fc9d5733a248df03bfd", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -5,15 +5,6 @@\n //! to a particular crate instance. That is, it has cfg flags and features\n //! applied. So, the relation between syntax and HIR is many-to-one.\n \n-macro_rules! ctry {\n-    ($expr:expr) => {\n-        match $expr {\n-            None => return Ok(None),\n-            Some(it) => it,\n-        }\n-    };\n-}\n-\n pub mod db;\n #[cfg(test)]\n mod mock;"}, {"sha": "dbbbce795da1da1ac9f14e1b77f5fb51e711c4c0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 104, "deletions": 130, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -30,8 +30,6 @@ use ra_arena::map::ArenaMap;\n use join_to_string::join;\n use rustc_hash::FxHashMap;\n \n-use ra_db::Cancelable;\n-\n use crate::{\n     Def, DefId, Module, Function, Struct, Enum, EnumVariant, Path, Name, ImplBlock,\n     FnSignature, FnScopes,\n@@ -41,14 +39,6 @@ use crate::{\n     expr::{Body, Expr, Literal, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n-fn transpose<T>(x: Cancelable<Option<T>>) -> Option<Cancelable<T>> {\n-    match x {\n-        Ok(Some(t)) => Some(Ok(t)),\n-        Ok(None) => None,\n-        Err(e) => Some(Err(e)),\n-    }\n-}\n-\n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TypeVarId(u32);\n@@ -271,36 +261,36 @@ impl Ty {\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         type_ref: &TypeRef,\n-    ) -> Cancelable<Self> {\n-        Ok(match type_ref {\n+    ) -> Self {\n+        match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n                     .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n-                    .collect::<Cancelable<Vec<_>>>()?;\n+                    .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path)?,\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(_inner) => Ty::Unknown, // TODO\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n                     .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n-                    .collect::<Cancelable<Vec<_>>>()?;\n+                    .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n                     .expect(\"TypeRef::Fn should always have at least return type\");\n@@ -311,38 +301,36 @@ impl Ty {\n                 Ty::FnPtr(Arc::new(sig))\n             }\n             TypeRef::Error => Ty::Unknown,\n-        })\n+        }\n     }\n \n     pub(crate) fn from_hir_opt(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         type_ref: Option<&TypeRef>,\n-    ) -> Cancelable<Self> {\n-        type_ref\n-            .map(|t| Ty::from_hir(db, module, impl_block, t))\n-            .unwrap_or(Ok(Ty::Unknown))\n+    ) -> Self {\n+        type_ref.map_or(Ty::Unknown, |t| Ty::from_hir(db, module, impl_block, t))\n     }\n \n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         path: &Path,\n-    ) -> Cancelable<Self> {\n+    ) -> Self {\n         if let Some(name) = path.as_ident() {\n             if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n-                return Ok(Ty::Int(int_ty));\n+                return Ty::Int(int_ty);\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n-                return Ok(Ty::Float(float_ty));\n+                return Ty::Float(float_ty);\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n-                    KnownName::Bool => return Ok(Ty::Bool),\n-                    KnownName::Char => return Ok(Ty::Char),\n-                    KnownName::Str => return Ok(Ty::Str),\n+                    KnownName::Bool => return Ty::Bool,\n+                    KnownName::Char => return Ty::Char,\n+                    KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n             }\n@@ -352,10 +340,9 @@ impl Ty {\n         let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n             r\n         } else {\n-            return Ok(Ty::Unknown);\n+            return Ty::Unknown;\n         };\n-        let ty = db.type_for_def(resolved)?;\n-        Ok(ty)\n+        db.type_for_def(resolved)\n     }\n \n     pub fn unit() -> Self {\n@@ -445,7 +432,7 @@ impl fmt::Display for Ty {\n \n /// Compute the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n+fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     let signature = f.signature(db);\n     let module = f.module(db);\n     let impl_block = f.impl_block(db);\n@@ -454,38 +441,38 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n         .params()\n         .iter()\n         .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n-        .collect::<Cancelable<Vec<_>>>()?;\n-    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type())?;\n+        .collect::<Vec<_>>();\n+    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type());\n     let sig = FnSig { input, output };\n-    Ok(Ty::FnPtr(Arc::new(sig)))\n+    Ty::FnPtr(Arc::new(sig))\n }\n \n-fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n-    Ok(Ty::Adt {\n+fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n+    Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n-    })\n+    }\n }\n \n-pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n-    Ok(Ty::Adt {\n+pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+    Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n-    })\n+    }\n }\n \n-pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Ty {\n     let enum_parent = ev.parent_enum(db);\n \n     type_for_enum(db, enum_parent)\n }\n \n-pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n     let def = def_id.resolve(db);\n     match def {\n         Def::Module(..) => {\n             log::debug!(\"trying to get type for module {:?}\", def_id);\n-            Ok(Ty::Unknown)\n+            Ty::Unknown\n         }\n         Def::Function(f) => type_for_fn(db, f),\n         Def::Struct(s) => type_for_struct(db, s),\n@@ -497,19 +484,15 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n                 def_id,\n                 def\n             );\n-            Ok(Ty::Unknown)\n+            Ty::Unknown\n         }\n     }\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: Name,\n-) -> Cancelable<Option<Ty>> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n     let def = def_id.resolve(db);\n     let variant_data = match def {\n-        Def::Struct(s) => s.variant_data(db)?,\n+        Def::Struct(s) => s.variant_data(db),\n         Def::EnumVariant(ev) => ev.variant_data(db),\n         // TODO: unions\n         _ => panic!(\n@@ -519,13 +502,8 @@ pub(super) fn type_for_field(\n     };\n     let module = def_id.module(db);\n     let impl_block = def_id.impl_block(db);\n-    let type_ref = ctry!(variant_data.get_field_type_ref(&field));\n-    Ok(Some(Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &type_ref,\n-    )?))\n+    let type_ref = variant_data.get_field_type_ref(&field)?;\n+    Some(Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -702,7 +680,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+    fn make_ty(&self, type_ref: &TypeRef) -> Ty {\n         Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n     }\n \n@@ -848,49 +826,49 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Cancelable<Option<Ty>> {\n+    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Option<Ty> {\n         if path.is_ident() || path.is_self() {\n             // resolve locally\n             let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n             if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n-                let ty = ctry!(self.type_of_pat.get(scope_entry.pat()));\n+                let ty = self.type_of_pat.get(scope_entry.pat())?;\n                 let ty = self.resolve_ty_as_possible(ty.clone());\n-                return Ok(Some(ty));\n+                return Some(ty);\n             };\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, &path).take_values());\n-        let ty = self.db.type_for_def(resolved)?;\n+        let resolved = self.module.resolve_path(self.db, &path).take_values()?;\n+        let ty = self.db.type_for_def(resolved);\n         let ty = self.insert_type_vars(ty);\n-        Ok(Some(ty))\n+        Some(ty)\n     }\n \n-    fn resolve_variant(&self, path: Option<&Path>) -> Cancelable<(Ty, Option<DefId>)> {\n+    fn resolve_variant(&self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n         let path = if let Some(path) = path {\n             path\n         } else {\n-            return Ok((Ty::Unknown, None));\n+            return (Ty::Unknown, None);\n         };\n         let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path).take_types() {\n             def_id\n         } else {\n-            return Ok((Ty::Unknown, None));\n+            return (Ty::Unknown, None);\n         };\n-        Ok(match def_id.resolve(self.db) {\n+        match def_id.resolve(self.db) {\n             Def::Struct(s) => {\n-                let ty = type_for_struct(self.db, s)?;\n+                let ty = type_for_struct(self.db, s);\n                 (ty, Some(def_id))\n             }\n             Def::EnumVariant(ev) => {\n-                let ty = type_for_enum_variant(self.db, ev)?;\n+                let ty = type_for_enum_variant(self.db, ev);\n                 (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n-        })\n+        }\n     }\n \n-    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Cancelable<Ty> {\n+    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[expr] {\n             Expr::Missing => Ty::Unknown,\n@@ -900,11 +878,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 else_branch,\n             } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n-                let then_ty = self.infer_expr(*then_branch, expected)?;\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                let then_ty = self.infer_expr(*then_branch, expected);\n                 match else_branch {\n                     Some(else_branch) => {\n-                        self.infer_expr(*else_branch, expected)?;\n+                        self.infer_expr(*else_branch, expected);\n                     }\n                     None => {\n                         // no else branch -> unit\n@@ -913,31 +891,31 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 then_ty\n             }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected)?,\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::Loop { body } => {\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 // TODO handle break with value\n                 Ty::Never\n             }\n             Expr::While { condition, body } => {\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, .. } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n                 // TODO write type for pat\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n             Expr::Lambda { body, .. } => {\n                 // TODO write types for args, infer lambda type etc.\n-                let _body_ty = self.infer_expr(*body, &Expectation::none())?;\n+                let _body_ty = self.infer_expr(*body, &Expectation::none());\n                 Ty::Unknown\n             }\n             Expr::Call { callee, args } => {\n-                let callee_ty = self.infer_expr(*callee, &Expectation::none())?;\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n@@ -950,7 +928,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_expr(\n                         *arg,\n                         &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    )?;\n+                    );\n                 }\n                 ret_ty\n             }\n@@ -959,12 +937,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 args,\n                 method_name,\n             } => {\n-                let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n+                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n+                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n                     Some(def_id) => {\n                         self.write_method_resolution(expr, def_id);\n-                        self.db.type_for_def(def_id)?\n+                        self.db.type_for_def(def_id)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -986,32 +964,32 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_expr(\n                         *arg,\n                         &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    )?;\n+                    );\n                 }\n                 ret_ty\n             }\n             Expr::Match { expr, arms } => {\n-                let _ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _ty = self.infer_expr(*expr, &Expectation::none());\n                 for arm in arms {\n                     // TODO type the bindings in pats\n                     // TODO type the guard\n-                    let _ty = self.infer_expr(arm.expr, &Expectation::none())?;\n+                    let _ty = self.infer_expr(arm.expr, &Expectation::none());\n                 }\n                 // TODO unify all the match arm types\n                 Ty::Unknown\n             }\n-            Expr::Path(p) => self.infer_path_expr(expr, p)?.unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => self.infer_path_expr(expr, p).unwrap_or(Ty::Unknown),\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n                     // TODO handle break with value\n-                    self.infer_expr(*expr, &Expectation::none())?;\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n                 Ty::Never\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()))?;\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 }\n                 Ty::Never\n             }\n@@ -1020,60 +998,58 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 fields,\n                 spread,\n             } => {\n-                let (ty, def_id) = self.resolve_variant(path.as_ref())?;\n+                let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n-                            .type_for_field(def_id, field.name.clone())?\n+                            .type_for_field(def_id, field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n                     } else {\n                         Ty::Unknown\n                     };\n-                    self.infer_expr(field.expr, &Expectation::has_type(field_ty))?;\n+                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n-                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()))?;\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n                 }\n                 ty\n             }\n             Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = receiver_ty\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n                         // this is more complicated than necessary because type_for_field is cancelable\n                         Ty::Tuple(fields) => {\n                             let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned()).map(Ok)\n-                        }\n-                        Ty::Adt { def_id, .. } => {\n-                            transpose(self.db.type_for_field(def_id, name.clone()))\n+                            i.and_then(|i| fields.get(i).cloned())\n                         }\n+                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone()),\n                         _ => None,\n                     })\n-                    .unwrap_or(Ok(Ty::Unknown))?;\n+                    .unwrap_or(Ty::Unknown);\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 Ty::Unknown\n             }\n             Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let cast_ty =\n-                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)?;\n+                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref);\n                 let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO check the cast...\n                 cast_ty\n             }\n             Expr::Ref { expr, mutability } => {\n                 // TODO pass the expectation down\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 // TODO reference coercions etc.\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 match op {\n                     Some(UnaryOp::Deref) => {\n                         if let Some(derefed_ty) = inner_ty.builtin_deref() {\n@@ -1094,11 +1070,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                         _ => Expectation::none(),\n                     };\n-                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation)?;\n+                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n                     // TODO: find implementation of trait corresponding to operation\n                     // symbol and resolve associated `Output` type\n                     let rhs_expectation = binary_op_rhs_expectation(*op, lhs_ty);\n-                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation))?;\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n \n                     // TODO: similar as above, return ty is often associated trait type\n                     binary_op_return_ty(*op, rhs_ty)\n@@ -1108,7 +1084,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Tuple { exprs } => {\n                 let mut ty_vec = Vec::with_capacity(exprs.len());\n                 for arg in exprs.iter() {\n-                    ty_vec.push(self.infer_expr(*arg, &Expectation::none())?);\n+                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n                 }\n \n                 Ty::Tuple(Arc::from(ty_vec))\n@@ -1133,15 +1109,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(expr, ty.clone());\n-        Ok(ty)\n+        ty\n     }\n \n     fn infer_block(\n         &mut self,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n         expected: &Expectation,\n-    ) -> Cancelable<Ty> {\n+    ) -> Ty {\n         for stmt in statements {\n             match stmt {\n                 Statement::Let {\n@@ -1154,10 +1130,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         &self.module,\n                         self.impl_block.as_ref(),\n                         type_ref.as_ref(),\n-                    )?;\n+                    );\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n-                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty))?;\n+                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n                         expr_ty\n                     } else {\n                         decl_ty\n@@ -1166,43 +1142,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.write_pat_ty(*pat, ty);\n                 }\n                 Statement::Expr(expr) => {\n-                    self.infer_expr(*expr, &Expectation::none())?;\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n         let ty = if let Some(expr) = tail {\n-            self.infer_expr(expr, expected)?\n+            self.infer_expr(expr, expected)\n         } else {\n             Ty::unit()\n         };\n-        Ok(ty)\n+        ty\n     }\n \n-    fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n+    fn collect_fn_signature(&mut self, signature: &FnSignature) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n-            let ty = self.make_ty(type_ref)?;\n+            let ty = self.make_ty(type_ref);\n             let ty = self.insert_type_vars(ty);\n             self.write_pat_ty(*pat, ty);\n         }\n         self.return_ty = {\n-            let ty = self.make_ty(signature.ret_type())?;\n+            let ty = self.make_ty(signature.ret_type());\n             let ty = self.insert_type_vars(ty);\n             ty\n         };\n-        Ok(())\n     }\n \n-    fn infer_body(&mut self) -> Cancelable<()> {\n+    fn infer_body(&mut self) {\n         self.infer_expr(\n             self.body.body_expr(),\n             &Expectation::has_type(self.return_ty.clone()),\n-        )?;\n-        Ok(())\n+        );\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Arc<InferenceResult> {\n     db.check_canceled();\n     let function = Function::new(def_id); // TODO: consts also need inference\n     let body = function.body(db);\n@@ -1212,9 +1186,9 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n     let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n     let signature = function.signature(db);\n-    ctx.collect_fn_signature(&signature)?;\n+    ctx.collect_fn_signature(&signature);\n \n-    ctx.infer_body()?;\n+    ctx.infer_body();\n \n-    Ok(Arc::new(ctx.resolve_all()))\n+    Arc::new(ctx.resolve_all())\n }"}, {"sha": "b221bd14250443d5866274634c77079e6b6f6118", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n-use ra_db::{Cancelable, SourceRootId};\n+use ra_db::SourceRootId;\n \n use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n use super::Ty;\n@@ -42,19 +42,19 @@ impl CrateImplBlocks {\n         &'a self,\n         db: &'a impl HirDatabase,\n         ty: &Ty,\n-    ) -> impl Iterator<Item = Cancelable<ImplBlock>> + 'a {\n+    ) -> impl Iterator<Item = ImplBlock> + 'a {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint\n             .and_then(|f| self.impls.get(&f))\n             .into_iter()\n             .flat_map(|i| i.iter())\n             .map(move |(module_id, impl_id)| {\n                 let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id);\n-                Ok(ImplBlock::from_id(module_impl_blocks, *impl_id))\n+                ImplBlock::from_id(module_impl_blocks, *impl_id)\n             })\n     }\n \n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n         let module_id = module.def_id.loc(db).module_id;\n         let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id);\n \n@@ -65,7 +65,7 @@ impl CrateImplBlocks {\n                 // ignore for now\n             } else {\n                 let target_ty =\n-                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type())?;\n+                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type());\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)\n@@ -76,16 +76,14 @@ impl CrateImplBlocks {\n         }\n \n         for child in module.children(db) {\n-            self.collect_recursive(db, child)?;\n+            self.collect_recursive(db, child);\n         }\n-\n-        Ok(())\n     }\n \n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n         krate: Crate,\n-    ) -> Cancelable<Arc<CrateImplBlocks>> {\n+    ) -> Arc<CrateImplBlocks> {\n         let crate_graph = db.crate_graph();\n         let file_id = crate_graph.crate_root(krate.crate_id);\n         let source_root_id = db.file_source_root(file_id);\n@@ -94,9 +92,9 @@ impl CrateImplBlocks {\n             impls: FxHashMap::default(),\n         };\n         if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module)?;\n+            crate_impl_blocks.collect_recursive(db, module);\n         }\n-        Ok(Arc::new(crate_impl_blocks))\n+        Arc::new(crate_impl_blocks)\n     }\n }\n \n@@ -111,13 +109,13 @@ impl Ty {\n     // TODO: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<DefId>> {\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<DefId> {\n         self.iterate_methods(db, |f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n-                Ok(Some(f.def_id()))\n+                Some(f.def_id())\n             } else {\n-                Ok(None)\n+                None\n             }\n         })\n     }\n@@ -127,8 +125,8 @@ impl Ty {\n     pub fn iterate_methods<T>(\n         self,\n         db: &impl HirDatabase,\n-        mut callback: impl FnMut(Function) -> Cancelable<Option<T>>,\n-    ) -> Cancelable<Option<T>> {\n+        mut callback: impl FnMut(Function) -> Option<T>,\n+    ) -> Option<T> {\n         // For method calls, rust first does any number of autoderef, and then one\n         // autoref (i.e. when the method takes &self or &mut self). We just ignore\n         // the autoref currently -- when we find a method matching the given name,\n@@ -143,22 +141,21 @@ impl Ty {\n                 Some(krate) => krate,\n                 None => continue,\n             };\n-            let impls = db.impls_in_crate(krate)?;\n+            let impls = db.impls_in_crate(krate);\n \n             for impl_block in impls.lookup_impl_blocks(db, &derefed_ty) {\n-                let impl_block = impl_block?;\n                 for item in impl_block.items() {\n                     match item {\n                         ImplItem::Method(f) => {\n-                            if let Some(result) = callback(f.clone())? {\n-                                return Ok(Some(result));\n+                            if let Some(result) = callback(f.clone()) {\n+                                return Some(result);\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n             }\n         }\n-        Ok(None)\n+        None\n     }\n }"}, {"sha": "929fee04ce3f48c372c9ff2867b6c8620ac02551", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -321,7 +321,7 @@ fn infer(content: &str) -> String {\n         .filter_map(ast::FnDef::cast)\n     {\n         let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap();\n-        let inference_result = func.infer(&db).unwrap();\n+        let inference_result = func.infer(&db);\n         let body_syntax_mapping = func.body_syntax_mapping(&db);\n         let mut types = Vec::new();\n         for (pat, ty) in inference_result.type_of_pat.iter() {\n@@ -405,7 +405,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     let func = source_binder::function_from_position(&db, pos).unwrap();\n     {\n         let events = db.log_executed(|| {\n-            func.infer(&db).unwrap();\n+            func.infer(&db);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -424,7 +424,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n \n     {\n         let events = db.log_executed(|| {\n-            func.infer(&db).unwrap();\n+            func.infer(&db);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "18b9508ef3cf22f2ee71e55c6dc7f0cd3d3d5b8e", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,6 +1,6 @@\n use std::cmp::{max, min};\n \n-use ra_db::{SyntaxDatabase, Cancelable};\n+use ra_db::SyntaxDatabase;\n use ra_syntax::{\n     AstNode, SyntaxNode, TextUnit, TextRange,\n     SyntaxKind::FN_DEF,\n@@ -11,21 +11,23 @@ use ra_syntax::{\n use crate::{FilePosition, CallInfo, db::RootDatabase};\n \n /// Computes parameter information for the given call expression.\n-pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n+pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n \n     // Find the calling expression and it's NameRef\n-    let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n-    let name_ref = ctry!(calling_node.name_ref());\n+    let calling_node = FnCallNode::with_node(syntax, position.offset)?;\n+    let name_ref = calling_node.name_ref()?;\n \n     // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n     let file_symbols = db.index_resolve(name_ref);\n-    let symbol = ctry!(file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF));\n+    let symbol = file_symbols\n+        .into_iter()\n+        .find(|it| it.ptr.kind() == FN_DEF)?;\n     let fn_file = db.source_file(symbol.file_id);\n     let fn_def = symbol.ptr.resolve(&fn_file);\n     let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-    let mut call_info = ctry!(CallInfo::new(fn_def));\n+    let mut call_info = CallInfo::new(fn_def)?;\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters.len();\n     let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n@@ -61,7 +63,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable\n         }\n     }\n \n-    Ok(Some(call_info))\n+    Some(call_info)\n }\n \n enum FnCallNode<'a> {"}, {"sha": "b03ddd74c0c29fd8cdd27434d54c89579b9f7388", "filename": "crates/ra_ide_api/src/completion.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -12,7 +12,7 @@ use ra_db::SyntaxDatabase;\n \n use crate::{\n     db,\n-    Cancelable, FilePosition,\n+    FilePosition,\n     completion::{\n         completion_item::{Completions, CompletionKind},\n         completion_context::CompletionContext,\n@@ -43,12 +43,9 @@ pub use crate::completion::completion_item::{CompletionItem, InsertText, Complet\n /// `foo` *should* be present among the completion variants. Filtering by\n /// identifier prefix/fuzzy match should be done higher in the stack, together\n /// with ordering of completions (currently this is done by the client).\n-pub(crate) fn completions(\n-    db: &db::RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<Completions>> {\n+pub(crate) fn completions(db: &db::RootDatabase, position: FilePosition) -> Option<Completions> {\n     let original_file = db.source_file(position.file_id);\n-    let ctx = ctry!(CompletionContext::new(db, &original_file, position)?);\n+    let ctx = CompletionContext::new(db, &original_file, position)?;\n \n     let mut acc = Completions::default();\n \n@@ -57,11 +54,11 @@ pub(crate) fn completions(\n     complete_keyword::complete_use_tree_keyword(&mut acc, &ctx);\n     complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n     complete_snippet::complete_item_snippet(&mut acc, &ctx);\n-    complete_path::complete_path(&mut acc, &ctx)?;\n-    complete_scope::complete_scope(&mut acc, &ctx)?;\n-    complete_dot::complete_dot(&mut acc, &ctx)?;\n+    complete_path::complete_path(&mut acc, &ctx);\n+    complete_scope::complete_scope(&mut acc, &ctx);\n+    complete_dot::complete_dot(&mut acc, &ctx);\n \n-    Ok(Some(acc))\n+    Some(acc)\n }\n \n #[cfg(test)]\n@@ -72,6 +69,6 @@ fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind\n     } else {\n         single_file_with_position(code)\n     };\n-    let completions = completions(&analysis.db, position).unwrap().unwrap();\n+    let completions = completions(&analysis.db, position).unwrap();\n     completions.assert_match(expected_completions, kind);\n }"}, {"sha": "473edc50eabe2677de4c917a6827eb5802c6b0a2", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,29 +1,27 @@\n use hir::{Ty, Def};\n \n-use crate::Cancelable;\n use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem, CompletionItemKind};\n \n /// Complete dot accesses, i.e. fields or methods (currently only fields).\n-pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     let (function, receiver) = match (&ctx.function, ctx.dot_receiver) {\n         (Some(function), Some(receiver)) => (function, receiver),\n-        _ => return Ok(()),\n+        _ => return,\n     };\n-    let infer_result = function.infer(ctx.db)?;\n+    let infer_result = function.infer(ctx.db);\n     let syntax_mapping = function.body_syntax_mapping(ctx.db);\n     let expr = match syntax_mapping.node_expr(receiver) {\n         Some(expr) => expr,\n-        None => return Ok(()),\n+        None => return,\n     };\n     let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty.clone())?;\n+        complete_fields(acc, ctx, receiver_ty.clone());\n     }\n-    complete_methods(acc, ctx, receiver_ty)?;\n-    Ok(())\n+    complete_methods(acc, ctx, receiver_ty);\n }\n \n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n             Ty::Adt { def_id, .. } => {\n@@ -35,7 +33,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                                 field.name().to_string(),\n                             )\n                             .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db)?.map(|ty| ty.to_string()))\n+                            .set_detail(field.ty(ctx.db).map(|ty| ty.to_string()))\n                             .add_to(acc);\n                         }\n                     }\n@@ -53,14 +51,9 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n             _ => {}\n         };\n     }\n-    Ok(())\n }\n \n-fn complete_methods(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    receiver: Ty,\n-) -> Cancelable<()> {\n+fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     receiver.iterate_methods(ctx.db, |func| {\n         let sig = func.signature(ctx.db);\n         if sig.has_self_param() {\n@@ -69,9 +62,8 @@ fn complete_methods(\n                 .kind(CompletionItemKind::Method)\n                 .add_to(acc);\n         }\n-        Ok(None::<()>)\n-    })?;\n-    Ok(())\n+        None::<()>\n+    });\n }\n \n #[cfg(test)]"}, {"sha": "1eded7658ea9d7c45cd9482604ad211e9d2a1f76", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,16 +1,15 @@\n use crate::{\n-    Cancelable,\n     completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n };\n \n-pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n         (Some(path), Some(module)) => (path.clone(), module),\n-        _ => return Ok(()),\n+        _ => return,\n     };\n     let def_id = match module.resolve_path(ctx.db, &path).take_types() {\n         Some(it) => it,\n-        None => return Ok(()),\n+        None => return,\n     };\n     match def_id.resolve(ctx.db) {\n         hir::Def::Module(module) => {\n@@ -30,9 +29,8 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n                         .add_to(acc)\n                 });\n         }\n-        _ => return Ok(()),\n+        _ => return,\n     };\n-    Ok(())\n }\n \n #[cfg(test)]"}, {"sha": "69968074863d8e3817f09a83ec8fdfe2a84689a6", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,18 +1,15 @@\n use rustc_hash::FxHashSet;\n use ra_syntax::TextUnit;\n \n-use crate::{\n-    Cancelable,\n-    completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n-};\n+use crate::completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext};\n \n-pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n-        return Ok(());\n+        return;\n     }\n     let module = match &ctx.module {\n         Some(it) => it,\n-        None => return Ok(()),\n+        None => return,\n     };\n     if let Some(function) = &ctx.function {\n         let scopes = function.scopes(ctx.db);\n@@ -40,7 +37,6 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n                 .from_resolution(ctx, res)\n                 .add_to(acc)\n         });\n-    Ok(())\n }\n \n fn complete_fn(acc: &mut Completions, scopes: &hir::ScopesWithSyntaxMapping, offset: TextUnit) {"}, {"sha": "e537e0082d84ebfc413c70a78ad2c2959c6f7dd7", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n };\n use hir::source_binder;\n \n-use crate::{db, FilePosition, Cancelable};\n+use crate::{db, FilePosition};\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n@@ -41,10 +41,9 @@ impl<'a> CompletionContext<'a> {\n         db: &'a db::RootDatabase,\n         original_file: &'a SourceFile,\n         position: FilePosition,\n-    ) -> Cancelable<Option<CompletionContext<'a>>> {\n+    ) -> Option<CompletionContext<'a>> {\n         let module = source_binder::module_from_position(db, position);\n-        let leaf =\n-            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n+        let leaf = find_leaf_at_offset(original_file.syntax(), position.offset).left_biased()?;\n         let mut ctx = CompletionContext {\n             db,\n             leaf,\n@@ -63,7 +62,7 @@ impl<'a> CompletionContext<'a> {\n             is_call: false,\n         };\n         ctx.fill(original_file, position.offset);\n-        Ok(Some(ctx))\n+        Some(ctx)\n     }\n \n     fn fill(&mut self, original_file: &'a SourceFile, offset: TextUnit) {"}, {"sha": "b1becca03167d60c8ab142bb7d2aa5367a9a8f1f", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{FileId, Cancelable, SyntaxDatabase};\n+use ra_db::{FileId, SyntaxDatabase};\n use ra_syntax::{\n     AstNode, ast,\n     algo::find_node_at_offset,\n@@ -9,21 +9,18 @@ use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n-) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n+) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        let navs = reference_definition(db, position.file_id, name_ref)?.to_vec();\n-        return Ok(Some(RangeInfo::new(\n-            name_ref.syntax().range(),\n-            navs.to_vec(),\n-        )));\n+        let navs = reference_definition(db, position.file_id, name_ref).to_vec();\n+        return Some(RangeInfo::new(name_ref.syntax().range(), navs.to_vec()));\n     }\n     if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        let navs = ctry!(name_definition(db, position.file_id, name)?);\n-        return Ok(Some(RangeInfo::new(name.syntax().range(), navs)));\n+        let navs = name_definition(db, position.file_id, name)?;\n+        return Some(RangeInfo::new(name.syntax().range(), navs));\n     }\n-    Ok(None)\n+    None\n }\n \n pub(crate) enum ReferenceResult {\n@@ -45,7 +42,7 @@ pub(crate) fn reference_definition(\n     db: &RootDatabase,\n     file_id: FileId,\n     name_ref: &ast::NameRef,\n-) -> Cancelable<ReferenceResult> {\n+) -> ReferenceResult {\n     use self::ReferenceResult::*;\n     if let Some(function) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n@@ -54,7 +51,7 @@ pub(crate) fn reference_definition(\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n             let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n-            return Ok(Exact(nav));\n+            return Exact(nav);\n         };\n \n         // Next check if it is a method\n@@ -63,15 +60,15 @@ pub(crate) fn reference_definition(\n             .parent()\n             .and_then(ast::MethodCallExpr::cast)\n         {\n-            let infer_result = function.infer(db)?;\n+            let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n             if let Some(def_id) = syntax_mapping\n                 .node_expr(expr)\n                 .and_then(|it| infer_result.method_resolution(it))\n             {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n-                    return Ok(Exact(target));\n+                    return Exact(target);\n                 }\n             };\n         }\n@@ -88,7 +85,7 @@ pub(crate) fn reference_definition(\n             let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n-                    return Ok(Exact(target));\n+                    return Exact(target);\n                 }\n             }\n         }\n@@ -99,25 +96,25 @@ pub(crate) fn reference_definition(\n         .into_iter()\n         .map(NavigationTarget::from_symbol)\n         .collect();\n-    Ok(Approximate(navs))\n+    Approximate(navs)\n }\n \n fn name_definition(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n-) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+) -> Option<Vec<NavigationTarget>> {\n     if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n         if module.has_semi() {\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)\n             {\n                 let nav = NavigationTarget::from_module(db, child_module);\n-                return Ok(Some(vec![nav]));\n+                return Some(vec![nav]);\n             }\n         }\n     }\n-    Ok(None)\n+    None\n }\n \n #[cfg(test)]"}, {"sha": "d91151c15baf2353af6ae59fa145aa699983f733", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_db::{SyntaxDatabase};\n use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n     ast::self,\n@@ -7,27 +7,24 @@ use ra_syntax::{\n \n use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n \n-pub(crate) fn hover(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<RangeInfo<String>>> {\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<String>> {\n     let file = db.source_file(position.file_id);\n     let mut res = Vec::new();\n \n     let mut range = None;\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         use crate::goto_definition::{ReferenceResult::*, reference_definition};\n-        let ref_result = reference_definition(db, position.file_id, name_ref)?;\n+        let ref_result = reference_definition(db, position.file_id, name_ref);\n         match ref_result {\n-            Exact(nav) => res.extend(doc_text_for(db, nav)?),\n+            Exact(nav) => res.extend(doc_text_for(db, nav)),\n             Approximate(navs) => {\n                 let mut msg = String::from(\"Failed to exactly resolve the symbol. This is probably because rust_analyzer does not yet support glob imports or traits.\");\n                 if !navs.is_empty() {\n                     msg.push_str(\"  \\nThese items were found instead:\");\n                 }\n                 res.push(msg);\n                 for nav in navs {\n-                    res.extend(doc_text_for(db, nav)?)\n+                    res.extend(doc_text_for(db, nav))\n                 }\n             }\n         }\n@@ -39,25 +36,24 @@ pub(crate) fn hover(\n         let node = find_leaf_at_offset(file.syntax(), position.offset).find_map(|leaf| {\n             leaf.ancestors()\n                 .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n-        });\n-        let node = ctry!(node);\n+        })?;\n         let frange = FileRange {\n             file_id: position.file_id,\n             range: node.range(),\n         };\n-        res.extend(type_of(db, frange)?.map(Into::into));\n+        res.extend(type_of(db, frange).map(Into::into));\n         range = Some(node.range());\n     };\n \n-    let range = ctry!(range);\n+    let range = range?;\n     if res.is_empty() {\n-        return Ok(None);\n+        return None;\n     }\n     let res = RangeInfo::new(range, res.join(\"\\n\\n---\\n\"));\n-    Ok(Some(res))\n+    Some(res)\n }\n \n-pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option<String>> {\n+pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     let file = db.source_file(frange.file_id);\n     let syntax = file.syntax();\n     let leaf_node = find_covering_node(syntax, frange.range);\n@@ -67,34 +63,28 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option\n         .take_while(|it| it.range() == leaf_node.range())\n         .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())\n         .unwrap_or(leaf_node);\n-    let parent_fn = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n-    let function = ctry!(hir::source_binder::function_from_source(\n-        db,\n-        frange.file_id,\n-        parent_fn\n-    ));\n-    let infer = function.infer(db)?;\n+    let parent_fn = node.ancestors().find_map(ast::FnDef::cast)?;\n+    let function = hir::source_binder::function_from_source(db, frange.file_id, parent_fn)?;\n+    let infer = function.infer(db);\n     let syntax_mapping = function.body_syntax_mapping(db);\n     if let Some(expr) = ast::Expr::cast(node).and_then(|e| syntax_mapping.node_expr(e)) {\n-        Ok(Some(infer[expr].to_string()))\n+        Some(infer[expr].to_string())\n     } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| syntax_mapping.node_pat(p)) {\n-        Ok(Some(infer[pat].to_string()))\n+        Some(infer[pat].to_string())\n     } else {\n-        Ok(None)\n+        None\n     }\n }\n \n // FIXME: this should not really use navigation target. Rather, approximatelly\n // resovled symbol should return a `DefId`.\n-fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-    let result = match (nav.description(db), nav.docs(db)) {\n+fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Option<String> {\n+    match (nav.description(db), nav.docs(db)) {\n         (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),\n         (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n         (None, Some(docs)) => Some(docs),\n         _ => None,\n-    };\n-\n-    Ok(result)\n+    }\n }\n \n impl NavigationTarget {"}, {"sha": "a21cae62474f907235bc47b87396ee63c486eb0a", "filename": "crates/ra_ide_api/src/imp.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -110,14 +110,11 @@ impl db::RootDatabase {\n         };\n         vec![krate.crate_id()]\n     }\n-    pub(crate) fn find_all_refs(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Vec<(FileId, TextRange)>> {\n+    pub(crate) fn find_all_refs(&self, position: FilePosition) -> Vec<(FileId, TextRange)> {\n         let file = self.source_file(position.file_id);\n         // Find the binding associated with the offset\n-        let (binding, descr) = match find_binding(self, &file, position)? {\n-            None => return Ok(Vec::new()),\n+        let (binding, descr) = match find_binding(self, &file, position) {\n+            None => return Vec::new(),\n             Some(it) => it,\n         };\n \n@@ -134,36 +131,30 @@ impl db::RootDatabase {\n                 .map(|ref_desc| (position.file_id, ref_desc.range)),\n         );\n \n-        return Ok(ret);\n+        return ret;\n \n         fn find_binding<'a>(\n             db: &db::RootDatabase,\n             source_file: &'a SourceFile,\n             position: FilePosition,\n-        ) -> Cancelable<Option<(&'a ast::BindPat, hir::Function)>> {\n+        ) -> Option<(&'a ast::BindPat, hir::Function)> {\n             let syntax = source_file.syntax();\n             if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-                let descr = ctry!(source_binder::function_from_child_node(\n+                let descr = source_binder::function_from_child_node(\n                     db,\n                     position.file_id,\n                     binding.syntax(),\n-                ));\n-                return Ok(Some((binding, descr)));\n+                )?;\n+                return Some((binding, descr));\n             };\n-            let name_ref = ctry!(find_node_at_offset::<ast::NameRef>(syntax, position.offset));\n-            let descr = ctry!(source_binder::function_from_child_node(\n-                db,\n-                position.file_id,\n-                name_ref.syntax(),\n-            ));\n+            let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n+            let descr =\n+                source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n             let scope = descr.scopes(db);\n-            let resolved = ctry!(scope.resolve_local_name(name_ref));\n+            let resolved = scope.resolve_local_name(name_ref)?;\n             let resolved = resolved.ptr().resolve(source_file);\n-            let binding = ctry!(find_node_at_offset::<ast::BindPat>(\n-                syntax,\n-                resolved.range().end()\n-            ));\n-            Ok(Some((binding, descr)))\n+            let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n+            Some((binding, descr))\n         }\n     }\n \n@@ -180,7 +171,7 @@ impl db::RootDatabase {\n             })\n             .collect::<Vec<_>>();\n         if let Some(m) = source_binder::module_from_file_id(self, file_id) {\n-            for (name_node, problem) in m.problems(self)? {\n+            for (name_node, problem) in m.problems(self) {\n                 let source_root = self.file_source_root(file_id);\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n@@ -239,13 +230,8 @@ impl db::RootDatabase {\n             .collect()\n     }\n \n-    pub(crate) fn rename(\n-        &self,\n-        position: FilePosition,\n-        new_name: &str,\n-    ) -> Cancelable<Vec<SourceFileEdit>> {\n-        let res = self\n-            .find_all_refs(position)?\n+    pub(crate) fn rename(&self, position: FilePosition, new_name: &str) -> Vec<SourceFileEdit> {\n+        self.find_all_refs(position)\n             .iter()\n             .map(|(file_id, text_range)| SourceFileEdit {\n                 file_id: *file_id,\n@@ -255,8 +241,7 @@ impl db::RootDatabase {\n                     builder.finish()\n                 },\n             })\n-            .collect::<Vec<_>>();\n-        Ok(res)\n+            .collect::<Vec<_>>()\n     }\n     pub(crate) fn index_resolve(&self, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n         let name = name_ref.text();"}, {"sha": "ea5267ad9e2cc1c824965807778ec6101d0b9a8d", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -9,15 +9,6 @@\n //!\n //! The sibling `ra_ide_api_light` handles thouse bits of IDE functionality\n //! which are restricted to a single file and need only syntax.\n-macro_rules! ctry {\n-    ($expr:expr) => {\n-        match $expr {\n-            None => return Ok(None),\n-            Some(it) => it,\n-        }\n-    };\n-}\n-\n mod db;\n mod imp;\n pub mod mock_analysis;\n@@ -58,9 +49,11 @@ pub use ra_ide_api_light::{\n     LineIndex, LineCol, translate_offset_with_edit,\n };\n pub use ra_db::{\n-    Cancelable, Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n+    Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n };\n \n+pub type Cancelable<T> = Result<T, Canceled>;\n+\n #[derive(Default)]\n pub struct AnalysisChange {\n     new_roots: Vec<(SourceRootId, bool)>,\n@@ -393,28 +386,28 @@ impl Analysis {\n         position: FilePosition,\n     ) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n         self.db\n-            .catch_canceled(|db| goto_definition::goto_definition(db, position))?\n+            .catch_canceled(|db| goto_definition::goto_definition(db, position))\n     }\n \n     /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        self.with_db(|db| db.find_all_refs(position))?\n+        self.with_db(|db| db.find_all_refs(position))\n     }\n \n     /// Returns a short text descrbing element at position.\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n-        self.with_db(|db| hover::hover(db, position))?\n+        self.with_db(|db| hover::hover(db, position))\n     }\n \n     /// Computes parameter information for the given call expression.\n     pub fn call_info(&self, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n         self.db\n-            .catch_canceled(|db| call_info::call_info(db, position))?\n+            .catch_canceled(|db| call_info::call_info(db, position))\n     }\n \n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        self.with_db(|db| parent_module::parent_module(db, position))?\n+        self.with_db(|db| parent_module::parent_module(db, position))\n     }\n \n     /// Returns crates this file belongs too.\n@@ -430,7 +423,7 @@ impl Analysis {\n     /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n         self.db\n-            .catch_canceled(|db| runnables::runnables(db, file_id))?\n+            .catch_canceled(|db| runnables::runnables(db, file_id))\n     }\n \n     /// Computes syntax highlighting for the given file.\n@@ -443,7 +436,7 @@ impl Analysis {\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let completions = self\n             .db\n-            .catch_canceled(|db| completion::completions(db, position))??;\n+            .catch_canceled(|db| completion::completions(db, position))?;\n         Ok(completions.map(|it| it.into()))\n     }\n \n@@ -460,7 +453,7 @@ impl Analysis {\n \n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        self.with_db(|db| hover::type_of(db, frange))?\n+        self.with_db(|db| hover::type_of(db, frange))\n     }\n \n     /// Returns the edit required to rename reference at the position to the new\n@@ -470,7 +463,7 @@ impl Analysis {\n         position: FilePosition,\n         new_name: &str,\n     ) -> Cancelable<Vec<SourceFileEdit>> {\n-        self.with_db(|db| db.rename(position, new_name))?\n+        self.with_db(|db| db.rename(position, new_name))\n     }\n \n     fn with_db<F: FnOnce(&db::RootDatabase) -> T + std::panic::UnwindSafe, T>("}, {"sha": "e94297fe386de9ab777f4d81d755c1f27e3346f1", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -1,19 +1,16 @@\n-use ra_db::{Cancelable, FilePosition};\n+use ra_db::FilePosition;\n \n use crate::{NavigationTarget, db::RootDatabase};\n \n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n-pub(crate) fn parent_module(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Vec<NavigationTarget>> {\n+pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n     let module = match hir::source_binder::module_from_position(db, position) {\n-        None => return Ok(Vec::new()),\n+        None => return Vec::new(),\n         Some(it) => it,\n     };\n     let nav = NavigationTarget::from_module_to_decl(db, module);\n-    Ok(vec![nav])\n+    vec![nav]\n }\n \n #[cfg(test)]"}, {"sha": "0f9f8deb3231422459524c06bff5c2701664cba9", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fba078ab693ec79e887b64e92a7ed3a21e29728/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=6fba078ab693ec79e887b64e92a7ed3a21e29728", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner, ModuleItemOwner},\n };\n-use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_db::SyntaxDatabase;\n \n use crate::{db::RootDatabase, FileId};\n \n@@ -21,14 +21,13 @@ pub enum RunnableKind {\n     Bin,\n }\n \n-pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n+pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let source_file = db.source_file(file_id);\n-    let res = source_file\n+    source_file\n         .syntax()\n         .descendants()\n         .filter_map(|i| runnable(db, file_id, i))\n-        .collect();\n-    Ok(res)\n+        .collect()\n }\n \n fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {"}]}