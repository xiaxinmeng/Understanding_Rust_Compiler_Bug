{"sha": "756fbcce480c3ab93a735436f7f27bf38a0dfb10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NmZiY2NlNDgwYzNhYjkzYTczNTQzNmY3ZjI3YmYzOGEwZGZiMTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-05T08:47:10Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-05T08:47:10Z"}, "message": "add a memory limit", "tree": {"sha": "eee1ca60475d18d4bc8d3b36503cdf89c7e594d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee1ca60475d18d4bc8d3b36503cdf89c7e594d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/756fbcce480c3ab93a735436f7f27bf38a0dfb10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXe3QOAAoJEFbW7qD8Z6xGhNoQAKih5UXfiHZiOZqLqAMI7VpC\n2PeBJ6KFzqdWB4SRe6NRBpknTTSjp0WRvW6IIXg3Xqn2KXA9rhSVTtZddII/yiRx\nrYndoCAMcs/rc9BhmoEmu0TEnSVOj+rWy2xqQW6xwq3m09/Zr0e89arYknWZWAvG\ncmmue707w/d/RQXKiUyzzWXnb8RMu+OoGMsquW2NXnA3jBtEq6LBheekBrAc3O1+\n9YqOUWkS/daYhYOUveiHmx9gO3CX/JXG27g7RrXayd+3CGao5IAElDNzaxV5P0X0\n+Xq/0oVjtye8OQ+tqalauk/mjiSppjVI8gd/OIxupuDqZ5lEB3T8e2MqPpg1iTQi\nL4SVfJwImOKAEZmDNWYGX+pg9P+KRUABDO+3rPBJB8nbisDV8hdjDzwtSs+b9l/N\nTWlGjZPbWl2MsMH89izLH84tTvXFA/hfaED0bQuX6Ps1zuDQ/ll3YPkHnUE9liHh\nMOsS2aV3+xxnu8RaefA7P+keiIMbD7/60DF6jAOX+uMKEA3+kzTgRqC/OGQVVpLC\nT42Uk8Bh1rr0Xq51WUr0UNOJnb2yntC5D40Up1Suwq+55WAtuHYcXTqRfBsrR8WU\nbx1jbtb9Y5bjg6jDvgnYXOzkF/kamTzUsNVx6ybDgB2HT/oUxNCaiFUfWpN+tLKo\nzC8t6WqENaXODKRhizZN\n=cEn8\n-----END PGP SIGNATURE-----", "payload": "tree eee1ca60475d18d4bc8d3b36503cdf89c7e594d7\nparent a7cc77a010cb842c258b36130df8b9f601970fde\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467708430 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467708430 +0200\n\nadd a memory limit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/756fbcce480c3ab93a735436f7f27bf38a0dfb10", "html_url": "https://github.com/rust-lang/rust/commit/756fbcce480c3ab93a735436f7f27bf38a0dfb10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/756fbcce480c3ab93a735436f7f27bf38a0dfb10/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7cc77a010cb842c258b36130df8b9f601970fde", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7cc77a010cb842c258b36130df8b9f601970fde", "html_url": "https://github.com/rust-lang/rust/commit/a7cc77a010cb842c258b36130df8b9f601970fde"}], "stats": {"total": 144, "additions": 101, "deletions": 43}, "files": [{"sha": "4467347b49bccb60b96debdb413a3b368d7c7805", "filename": "src/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=756fbcce480c3ab93a735436f7f27bf38a0dfb10", "patch": "@@ -29,6 +29,11 @@ pub enum EvalError<'tcx> {\n     ArrayIndexOutOfBounds(Span, u64, u64),\n     Math(Span, ConstMathErr),\n     InvalidChar(u32),\n+    OutOfMemory {\n+        allocation_size: u64,\n+        memory_size: u64,\n+        memory_usage: u64,\n+    }\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -69,6 +74,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"mathematical operation failed\",\n             EvalError::InvalidChar(..) =>\n                 \"tried to interpret an invalid 32-bit value as a char\",\n+            EvalError::OutOfMemory{..} =>\n+                \"could not allocate more memory\"\n         }\n     }\n \n@@ -90,6 +97,9 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"{:?} at {:?}\", err, span),\n             EvalError::InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n+            EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>\n+                write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n+                       allocation_size, memory_size - memory_usage, memory_size),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "66d147e2d8b476c7d43ea31ce817f5bcfa02588e", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=756fbcce480c3ab93a735436f7f27bf38a0dfb10", "patch": "@@ -138,19 +138,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            memory: Memory::new(&tcx.data_layout),\n+            memory: Memory::new(&tcx.data_layout, 100*1024*1024 /* 100MB */),\n             statics: HashMap::new(),\n             stack: Vec::new(),\n         }\n     }\n \n-    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<Pointer>> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size_with_substs(ty, substs);\n-                Some(self.memory.allocate(size))\n+                self.memory.allocate(size).map(Some)\n             }\n-            ty::FnDiverging => None,\n+            ty::FnDiverging => Ok(None),\n         }\n     }\n \n@@ -172,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n         macro_rules! i2p {\n             ($i:ident, $n:expr) => {{\n-                let ptr = self.memory.allocate($n);\n+                let ptr = self.memory.allocate($n)?;\n                 self.memory.write_int(ptr, $i as i64, $n)?;\n                 Ok(ptr)\n             }}\n@@ -197,28 +197,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Integral(ConstInt::Usize(ConstUsize::Us64(i))) => i2p!(i, 8),\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(s.len());\n-                let ptr = self.memory.allocate(psize * 2);\n+                let static_ptr = self.memory.allocate(s.len())?;\n+                let ptr = self.memory.allocate(psize * 2)?;\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(bs.len());\n-                let ptr = self.memory.allocate(psize);\n+                let static_ptr = self.memory.allocate(bs.len())?;\n+                let ptr = self.memory.allocate(psize)?;\n                 self.memory.write_bytes(static_ptr, bs)?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 Ok(ptr)\n             }\n             Bool(b) => {\n-                let ptr = self.memory.allocate(1);\n+                let ptr = self.memory.allocate(1)?;\n                 self.memory.write_bool(ptr, b)?;\n                 Ok(ptr)\n             }\n             Char(c) => {\n-                let ptr = self.memory.allocate(4);\n+                let ptr = self.memory.allocate(4)?;\n                 self.memory.write_uint(ptr, c as u64, 4)?;\n                 Ok(ptr)\n             },\n@@ -282,9 +282,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    pub fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n-        return_ptr: Option<Pointer>)\n-    {\n+    pub fn push_stack_frame(\n+        &mut self,\n+        def_id: DefId,\n+        span: codemap::Span,\n+        mir: CachedMir<'a, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        return_ptr: Option<Pointer>,\n+    ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n@@ -294,7 +299,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         ::log_settings::settings().indentation += 1;\n \n-        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+        let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             self.memory.allocate(size)\n         }).collect();\n@@ -303,14 +308,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n-            locals: locals,\n+            locals: locals?,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n             stmt: 0,\n         });\n+        Ok(())\n     }\n \n     fn pop_stack_frame(&mut self) {\n@@ -538,7 +544,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let size = self.type_size(ty);\n-                let ptr = self.memory.allocate(size);\n+                let ptr = self.memory.allocate(size)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n@@ -686,7 +692,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n                             // function items are zero sized\n-                            Ok(self.memory.allocate(0))\n+                            Ok(self.memory.allocate(0)?)\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,\n@@ -927,16 +933,19 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let def_id = tcx.map.local_def_id(node_id);\n     let mut ecx = EvalContext::new(tcx, mir_map);\n     let substs = tcx.mk_substs(subst::Substs::empty());\n-    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"main function should not be diverging\");\n+    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n+                        .expect(\"should at least be able to allocate space for the main function's return value\")\n+                        .expect(\"main function should not be diverging\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr));\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr))\n+       .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {\n         // start function\n         let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size);\n+        let nargs = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for nargs\");\n         ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size);\n+        let args = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for arg pointer\");\n         ecx.memory_mut().write_usize(args, 0).unwrap();\n         ecx.frame_mut().locals[0] = nargs;\n         ecx.frame_mut().locals[1] = args;"}, {"sha": "5bfe85fff92fc9811244e99a9f9f1fd0f7e8f5f5", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=756fbcce480c3ab93a735436f7f27bf38a0dfb10", "patch": "@@ -29,15 +29,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let basic_block = &mir.basic_blocks()[block];\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n-            let current_stack = self.stack.len();\n+            let mut new = Ok(0);\n             ConstantExtractor {\n                 span: stmt.source_info.span,\n                 substs: self.substs(),\n                 def_id: self.frame().def_id,\n                 ecx: self,\n                 mir: &mir,\n+                new_constants: &mut new,\n             }.visit_statement(block, stmt);\n-            if current_stack == self.stack.len() {\n+            if new? == 0 {\n                 self.statement(stmt)?;\n             }\n             // if ConstantExtractor added new frames, we don't execute anything here\n@@ -46,15 +47,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n \n         let terminator = basic_block.terminator();\n-        let current_stack = self.stack.len();\n+        let mut new = Ok(0);\n         ConstantExtractor {\n             span: terminator.source_info.span,\n             substs: self.substs(),\n             def_id: self.frame().def_id,\n             ecx: self,\n             mir: &mir,\n+            new_constants: &mut new,\n         }.visit_terminator(block, terminator);\n-        if current_stack == self.stack.len() {\n+        if new? == 0 {\n             self.terminator(terminator)?;\n         }\n         // if ConstantExtractor added new frames, we don't execute anything here\n@@ -92,6 +94,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     mir: &'a mir::Mir<'tcx>,\n     def_id: DefId,\n     substs: &'tcx subst::Substs<'tcx>,\n+    new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n@@ -105,9 +108,22 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             return;\n         }\n         let mir = self.ecx.load_mir(def_id);\n-        let ptr = self.ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n-        self.ecx.statics.insert(cid.clone(), ptr);\n-        self.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr));\n+        self.try(|this| {\n+            let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n+            let ptr = ptr.expect(\"there's no such thing as an unreachable static\");\n+            this.ecx.statics.insert(cid.clone(), ptr);\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr))\n+        });\n+    }\n+    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n+        if let Ok(ref mut n) = *self.new_constants {\n+            *n += 1;\n+        } else {\n+            return;\n+        }\n+        if let Err(e) = f(self) {\n+            *self.new_constants = Err(e);\n+        }\n     }\n }\n \n@@ -137,10 +153,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 }\n                 let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n-                let return_ptr = self.ecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n-                let mir = CachedMir::Owned(Rc::new(mir));\n-                self.ecx.statics.insert(cid.clone(), return_ptr);\n-                self.ecx.push_stack_frame(self.def_id, constant.span, mir, self.substs, Some(return_ptr));\n+                self.try(|this| {\n+                    let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n+                    let return_ptr = return_ptr.expect(\"there's no such thing as an unreachable static\");\n+                    let mir = CachedMir::Owned(Rc::new(mir));\n+                    this.ecx.statics.insert(cid.clone(), return_ptr);\n+                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr))\n+                });\n             }\n         }\n     }"}, {"sha": "2fbc9a63ef68d236d34aaba6ea8a3cc16a315660", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=756fbcce480c3ab93a735436f7f27bf38a0dfb10", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 let mir = self.load_mir(resolved_def_id);\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr)?;\n \n                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n                 let size = self.memory.read_usize(args[0])?;\n-                let ptr = self.memory.allocate(size as usize);\n+                let ptr = self.memory.allocate(size as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n "}, {"sha": "2453b1f6e67a84f2f7f04dad687a7f674a7ce7bd", "filename": "src/memory.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756fbcce480c3ab93a735436f7f27bf38a0dfb10/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=756fbcce480c3ab93a735436f7f27bf38a0dfb10", "patch": "@@ -66,6 +66,10 @@ pub struct FunctionDefinition<'tcx> {\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n+    /// Number of virtual bytes allocated\n+    memory_usage: u64,\n+    /// Maximum number of virtual bytes that may be allocated\n+    memory_size: u64,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n@@ -78,13 +82,15 @@ pub struct Memory<'a, 'tcx> {\n const ZST_ALLOC_ID: AllocId = AllocId(0);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout) -> Self {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n         let mut mem = Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n             next_id: AllocId(1),\n             layout: layout,\n+            memory_size: max_memory,\n+            memory_usage: 0,\n         };\n         // alloc id 0 is reserved for ZSTs, this is an optimization to prevent ZST\n         // (e.g. function items, (), [], ...) from requiring memory\n@@ -95,7 +101,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0).points_to_zst());\n+        debug_assert!(mem.allocate(0).unwrap().points_to_zst());\n         debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n         mem\n     }\n@@ -127,10 +133,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn allocate(&mut self, size: usize) -> Pointer {\n+    pub fn allocate(&mut self, size: usize) -> EvalResult<'tcx, Pointer> {\n         if size == 0 {\n-            return Pointer::zst_ptr();\n+            return Ok(Pointer::zst_ptr());\n         }\n+        if self.memory_size - self.memory_usage < size as u64 {\n+            return Err(EvalError::OutOfMemory {\n+                allocation_size: size as u64,\n+                memory_size: self.memory_size,\n+                memory_usage: self.memory_usage,\n+            });\n+        }\n+        self.memory_usage += size as u64;\n         let alloc = Allocation {\n             bytes: vec![0; size],\n             relocations: BTreeMap::new(),\n@@ -139,10 +153,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n-        Pointer {\n+        Ok(Pointer {\n             alloc_id: id,\n             offset: 0,\n-        }\n+        })\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n@@ -153,17 +167,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n         if ptr.points_to_zst() {\n-            return Ok(self.allocate(new_size));\n+            return self.allocate(new_size);\n         }\n \n         let size = self.get_mut(ptr.alloc_id)?.bytes.len();\n \n         if new_size > size {\n             let amount = new_size - size;\n+            self.memory_usage += amount as u64;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n+            // it's possible to cause miri to use arbitrary amounts of memory that aren't detectable\n+            // through the memory_usage value, by allocating a lot and reallocating to zero\n+            self.memory_usage -= (size - new_size) as u64;\n             self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.truncate(new_size);\n@@ -183,7 +201,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n \n-        if self.alloc_map.remove(&ptr.alloc_id).is_none() {\n+        if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n+            self.memory_usage -= alloc.bytes.len() as u64;\n+        } else {\n             debug!(\"deallocated a pointer twice: {}\", ptr.alloc_id);\n             // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n             // already-dropped state since this if-statement is entered even in safe code without"}]}