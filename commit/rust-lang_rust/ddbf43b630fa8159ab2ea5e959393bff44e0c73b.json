{"sha": "ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYmY0M2I2MzBmYTgxNTlhYjJlYTVlOTU5MzkzYmZmNDRlMGM3M2I=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-06T21:54:33Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-09T10:15:25Z"}, "message": "Move crate graph generation to ra_project_model", "tree": {"sha": "f5ee2104b2990086a3ba7a51847be912ce293a7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ee2104b2990086a3ba7a51847be912ce293a7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "html_url": "https://github.com/rust-lang/rust/commit/ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcd615e4b76264b4fff7b5be454787bb6a4252ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd615e4b76264b4fff7b5be454787bb6a4252ea", "html_url": "https://github.com/rust-lang/rust/commit/fcd615e4b76264b4fff7b5be454787bb6a4252ea"}], "stats": {"total": 199, "additions": 116, "deletions": 83}, "files": [{"sha": "3f0334f95d1fa205925d0b4ab05c6104f0ad77c9", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "patch": "@@ -1052,7 +1052,10 @@ dependencies = [\n  \"cargo_metadata 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_db 0.1.0\",\n+ \"ra_vfs 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\","}, {"sha": "405634fe00de9d42132700004ca236016f4240b5", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "patch": "@@ -91,6 +91,7 @@ impl CrateGraph {\n         assert!(prev.is_none());\n         crate_id\n     }\n+\n     pub fn add_dep(\n         &mut self,\n         from: CrateId,\n@@ -102,22 +103,40 @@ impl CrateGraph {\n         }\n         Ok(self.arena.get_mut(&from).unwrap().add_dep(name, to))\n     }\n+\n     pub fn is_empty(&self) -> bool {\n         self.arena.is_empty()\n     }\n+\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.arena[&crate_id].file_id\n     }\n+\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;\n         Some(crate_id)\n     }\n+\n     pub fn dependencies<'a>(\n         &'a self,\n         crate_id: CrateId,\n     ) -> impl Iterator<Item = &'a Dependency> + 'a {\n         self.arena[&crate_id].dependencies.iter()\n     }\n+\n+    /// Extends this crate graph by adding a complete disjoint second crate\n+    /// graph.\n+    pub fn extend(&mut self, other: CrateGraph) {\n+        let start = self.arena.len() as u32;\n+        self.arena.extend(other.arena.into_iter().map(|(id, mut data)| {\n+            let new_id = CrateId(id.0 + start);\n+            for dep in &mut data.dependencies {\n+                dep.crate_id = CrateId(dep.crate_id.0 + start);\n+            }\n+            (new_id, data)\n+        }));\n+    }\n+\n     fn dfs_find(&self, target: CrateId, from: CrateId, visited: &mut FxHashSet<CrateId>) -> bool {\n         if !visited.insert(from) {\n             return false;"}, {"sha": "23270d0aa9d1de6c17539282f1f25b61fca76dee", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 3, "deletions": 82, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "patch": "@@ -9,13 +9,12 @@ use ra_ide_api::{\n     SourceRootId\n };\n use ra_vfs::{Vfs, VfsChange, VfsFile, VfsRoot};\n-use rustc_hash::FxHashMap;\n use relative_path::RelativePathBuf;\n use parking_lot::RwLock;\n use failure::format_err;\n \n use crate::{\n-    project_model::{ProjectWorkspace, TargetKind},\n+    project_model::ProjectWorkspace,\n     Result,\n };\n \n@@ -57,88 +56,10 @@ impl ServerWorldState {\n             change.add_root(SourceRootId(r.0.into()), is_local);\n         }\n \n+        // Create crate graph from all the workspaces\n         let mut crate_graph = CrateGraph::default();\n         for ws in workspaces.iter() {\n-            // First, load std\n-            let mut sysroot_crates = FxHashMap::default();\n-            for krate in ws.sysroot.crates() {\n-                if let Some(file_id) = vfs.load(krate.root(&ws.sysroot)) {\n-                    let file_id = FileId(file_id.0.into());\n-                    sysroot_crates.insert(krate, crate_graph.add_crate_root(file_id));\n-                }\n-            }\n-            for from in ws.sysroot.crates() {\n-                for to in from.deps(&ws.sysroot) {\n-                    let name = to.name(&ws.sysroot);\n-                    if let (Some(&from), Some(&to)) =\n-                        (sysroot_crates.get(&from), sysroot_crates.get(&to))\n-                    {\n-                        if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                            log::error!(\"cyclic dependency between sysroot crates\")\n-                        }\n-                    }\n-                }\n-            }\n-\n-            let libstd = ws.sysroot.std().and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n-\n-            let mut pkg_to_lib_crate = FxHashMap::default();\n-            let mut pkg_crates = FxHashMap::default();\n-            // Next, create crates for each package, target pair\n-            for pkg in ws.cargo.packages() {\n-                let mut lib_tgt = None;\n-                for tgt in pkg.targets(&ws.cargo) {\n-                    let root = tgt.root(&ws.cargo);\n-                    if let Some(file_id) = vfs.load(root) {\n-                        let file_id = FileId(file_id.0.into());\n-                        let crate_id = crate_graph.add_crate_root(file_id);\n-                        if tgt.kind(&ws.cargo) == TargetKind::Lib {\n-                            lib_tgt = Some(crate_id);\n-                            pkg_to_lib_crate.insert(pkg, crate_id);\n-                        }\n-                        pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                    }\n-                }\n-\n-                // Set deps to the std and to the lib target of the current package\n-                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                    if let Some(to) = lib_tgt {\n-                        if to != from {\n-                            if let Err(_) =\n-                                crate_graph.add_dep(from, pkg.name(&ws.cargo).into(), to)\n-                            {\n-                                log::error!(\n-                                    \"cyclic dependency between targets of {}\",\n-                                    pkg.name(&ws.cargo)\n-                                )\n-                            }\n-                        }\n-                    }\n-                    if let Some(std) = libstd {\n-                        if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n-                            log::error!(\"cyclic dependency on std for {}\", pkg.name(&ws.cargo))\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Now add a dep ednge from all targets of upstream to the lib\n-            // target of downstream.\n-            for pkg in ws.cargo.packages() {\n-                for dep in pkg.dependencies(&ws.cargo) {\n-                    if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                            if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n-                                log::error!(\n-                                    \"cyclic dependency {} -> {}\",\n-                                    pkg.name(&ws.cargo),\n-                                    dep.pkg.name(&ws.cargo)\n-                                )\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+            crate_graph.extend(ws.to_crate_graph(&mut vfs));\n         }\n         change.set_crate_graph(crate_graph);\n "}, {"sha": "f65aabad79c2c382a5f881f06228a51b5e423549", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "patch": "@@ -7,7 +7,7 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n [dependencies]\n # itertools = \"0.8.0\"\n # join_to_string = \"0.1.3\"\n-# log = \"0.4.5\"\n+log = \"0.4.5\"\n # relative-path = \"0.4.0\"\n # rayon = \"1.0.2\"\n # fst = \"0.3.1\"\n@@ -25,6 +25,8 @@ walkdir = \"2.2.7\"\n cargo_metadata = \"0.7.0\"\n \n ra_arena = { path = \"../ra_arena\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_vfs = { path = \"../ra_vfs\" }\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "30612ac845f9947b5569c5efb9f8089de2afdd70", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbf43b630fa8159ab2ea5e959393bff44e0c73b/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=ddbf43b630fa8159ab2ea5e959393bff44e0c73b", "patch": "@@ -4,6 +4,10 @@ mod sysroot;\n use std::path::{Path, PathBuf};\n \n use failure::bail;\n+use rustc_hash::FxHashMap;\n+\n+use ra_db::{CrateGraph, FileId};\n+use ra_vfs::Vfs;\n \n pub use crate::{\n     cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n@@ -27,6 +31,90 @@ impl ProjectWorkspace {\n         let res = ProjectWorkspace { cargo, sysroot };\n         Ok(res)\n     }\n+\n+    pub fn to_crate_graph(&self, vfs: &mut Vfs) -> CrateGraph {\n+        let mut crate_graph = CrateGraph::default();\n+        let mut sysroot_crates = FxHashMap::default();\n+        for krate in self.sysroot.crates() {\n+            if let Some(file_id) = vfs.load(krate.root(&self.sysroot)) {\n+                let file_id = FileId(file_id.0.into());\n+                sysroot_crates.insert(krate, crate_graph.add_crate_root(file_id));\n+            }\n+        }\n+        for from in self.sysroot.crates() {\n+            for to in from.deps(&self.sysroot) {\n+                let name = to.name(&self.sysroot);\n+                if let (Some(&from), Some(&to)) =\n+                    (sysroot_crates.get(&from), sysroot_crates.get(&to))\n+                {\n+                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                        log::error!(\"cyclic dependency between sysroot crates\")\n+                    }\n+                }\n+            }\n+        }\n+\n+        let libstd = self.sysroot.std().and_then(|it| sysroot_crates.get(&it).map(|&it| it));\n+\n+        let mut pkg_to_lib_crate = FxHashMap::default();\n+        let mut pkg_crates = FxHashMap::default();\n+        // Next, create crates for each package, target pair\n+        for pkg in self.cargo.packages() {\n+            let mut lib_tgt = None;\n+            for tgt in pkg.targets(&self.cargo) {\n+                let root = tgt.root(&self.cargo);\n+                if let Some(file_id) = vfs.load(root) {\n+                    let file_id = FileId(file_id.0.into());\n+                    let crate_id = crate_graph.add_crate_root(file_id);\n+                    if tgt.kind(&self.cargo) == TargetKind::Lib {\n+                        lib_tgt = Some(crate_id);\n+                        pkg_to_lib_crate.insert(pkg, crate_id);\n+                    }\n+                    pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                }\n+            }\n+\n+            // Set deps to the std and to the lib target of the current package\n+            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                if let Some(to) = lib_tgt {\n+                    if to != from {\n+                        if let Err(_) = crate_graph.add_dep(from, pkg.name(&self.cargo).into(), to)\n+                        {\n+                            log::error!(\n+                                \"cyclic dependency between targets of {}\",\n+                                pkg.name(&self.cargo)\n+                            )\n+                        }\n+                    }\n+                }\n+                if let Some(std) = libstd {\n+                    if let Err(_) = crate_graph.add_dep(from, \"std\".into(), std) {\n+                        log::error!(\"cyclic dependency on std for {}\", pkg.name(&self.cargo))\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Now add a dep ednge from all targets of upstream to the lib\n+        // target of downstream.\n+        for pkg in self.cargo.packages() {\n+            for dep in pkg.dependencies(&self.cargo) {\n+                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                        if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n+                            log::error!(\n+                                \"cyclic dependency {} -> {}\",\n+                                pkg.name(&self.cargo),\n+                                dep.pkg.name(&self.cargo)\n+                            )\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        crate_graph\n+    }\n }\n \n fn find_cargo_toml(path: &Path) -> Result<PathBuf> {"}]}