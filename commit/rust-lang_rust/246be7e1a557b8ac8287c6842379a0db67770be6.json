{"sha": "246be7e1a557b8ac8287c6842379a0db67770be6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NmJlN2UxYTU1N2I4YWM4Mjg3YzY4NDIzNzlhMGRiNjc3NzBiZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T20:41:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-25T20:41:28Z"}, "message": "Auto merge of #65826 - JohnTitor:rollup-mr6crka, r=JohnTitor\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #65705 (Add {String,Vec}::into_raw_parts)\n - #65749 (Insurance policy in case `iter.size_hint()` lies.)\n - #65799 (Fill tracking issue number for `array_value_iter`)\n - #65800 (self-profiling: Update measureme to 0.4.0 and remove non-RAII methods from profiler.)\n - #65806 (Add [T]::as_ptr_range() and [T]::as_mut_ptr_range().)\n - #65810 (SGX: Clear additional flag on enclave entry)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6359f78c7c2bbf20c7e999fa95ddab93ba1a0ea7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6359f78c7c2bbf20c7e999fa95ddab93ba1a0ea7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/246be7e1a557b8ac8287c6842379a0db67770be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/246be7e1a557b8ac8287c6842379a0db67770be6", "html_url": "https://github.com/rust-lang/rust/commit/246be7e1a557b8ac8287c6842379a0db67770be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/246be7e1a557b8ac8287c6842379a0db67770be6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f890f10202a71168c6424da0cdf94135d3c40c", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "html_url": "https://github.com/rust-lang/rust/commit/23f890f10202a71168c6424da0cdf94135d3c40c"}, {"sha": "d40c6afba04c906907cb57157c0aec7e12519c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40c6afba04c906907cb57157c0aec7e12519c94", "html_url": "https://github.com/rust-lang/rust/commit/d40c6afba04c906907cb57157c0aec7e12519c94"}], "stats": {"total": 355, "additions": 225, "deletions": 130}, "files": [{"sha": "1f78c5f3f7569d7d659e4c0f87fd471ed2b4ba16", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -1966,9 +1966,9 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d09de7dafa3aa334bc806447c7e4de69419723312f4b88b80b561dea66601ce8\"\n+checksum = \"cd21b0e6e1af976b269ce062038fe5e1b9ca2f817ab7a3af09ec4210aebf0d30\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\","}, {"sha": "d9927c642b2d8528cc012de950ace36fdbcdafa6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -196,20 +196,21 @@ use crate::vec::Vec;\n ///\n /// let story = String::from(\"Once upon a time...\");\n ///\n-/// let ptr = story.as_ptr();\n+// FIXME Update this when vec_into_raw_parts is stabilized\n+/// // Prevent automatically dropping the String's data\n+/// let mut story = mem::ManuallyDrop::new(story);\n+///\n+/// let ptr = story.as_mut_ptr();\n /// let len = story.len();\n /// let capacity = story.capacity();\n ///\n /// // story has nineteen bytes\n /// assert_eq!(19, len);\n ///\n-/// // Now that we have our parts, we throw the story away.\n-/// mem::forget(story);\n-///\n /// // We can re-build a String out of ptr, len, and capacity. This is all\n /// // unsafe because we are responsible for making sure the components are\n /// // valid:\n-/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n+/// let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n ///\n /// assert_eq!(String::from(\"Once upon a time...\"), s);\n /// ```\n@@ -647,6 +648,37 @@ impl String {\n         decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n     }\n \n+    /// Decomposes a `String` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the string (in bytes), and the allocated capacity of the data\n+    /// (in bytes). These are the same arguments in the same order as\n+    /// the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `String`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `String` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let s = String::from(\"hello\");\n+    ///\n+    /// let (ptr, len, cap) = s.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };\n+    /// assert_eq!(rebuilt, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut u8, usize, usize) {\n+        self.vec.into_raw_parts()\n+    }\n+\n     /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n     /// # Safety\n@@ -677,13 +709,16 @@ impl String {\n     ///\n     /// unsafe {\n     ///     let s = String::from(\"hello\");\n-    ///     let ptr = s.as_ptr();\n+    ///\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    ///     // Prevent automatically dropping the String's data\n+    ///     let mut s = mem::ManuallyDrop::new(s);\n+    ///\n+    ///     let ptr = s.as_mut_ptr();\n     ///     let len = s.len();\n     ///     let capacity = s.capacity();\n     ///\n-    ///     mem::forget(s);\n-    ///\n-    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n+    ///     let s = String::from_raw_parts(ptr, len, capacity);\n     ///\n     ///     assert_eq!(String::from(\"hello\"), s);\n     /// }"}, {"sha": "641f9eafa8d23fa55a047204cac29b989d544880", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -358,6 +358,44 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Decomposes a `Vec<T>` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the vector (in elements), and the allocated capacity of the\n+    /// data (in elements). These are the same arguments in the same\n+    /// order as the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Vec`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let v: Vec<i32> = vec![-1, 0, 1];\n+    ///\n+    /// let (ptr, len, cap) = v.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe {\n+    ///     // We can now make changes to the components, such as\n+    ///     // transmuting the raw pointer to a compatible type.\n+    ///     let ptr = ptr as *mut u32;\n+    ///\n+    ///     Vec::from_raw_parts(ptr, len, cap)\n+    /// };\n+    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n+        let mut me = mem::ManuallyDrop::new(self);\n+        (me.as_mut_ptr(), me.len(), me.capacity())\n+    }\n+\n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n     /// # Safety\n@@ -389,18 +427,19 @@ impl<T> Vec<T> {\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// let mut v = vec![1, 2, 3];\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    /// // Prevent running `v`'s destructor so we are in complete control\n+    /// // of the allocation.\n+    /// let mut v = mem::ManuallyDrop::new(v);\n     ///\n     /// // Pull out the various important pieces of information about `v`\n     /// let p = v.as_mut_ptr();\n     /// let len = v.len();\n     /// let cap = v.capacity();\n     ///\n     /// unsafe {\n-    ///     // Cast `v` into the void: no destructor run, so we are in\n-    ///     // complete control of the allocation to which `p` points.\n-    ///     mem::forget(v);\n-    ///\n     ///     // Overwrite memory with 4, 5, 6\n     ///     for i in 0..len as isize {\n     ///         ptr::write(p.offset(i), 4 + i);"}, {"sha": "11803238407c8d5522fc0739300cd197c2d38d67", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -13,7 +13,7 @@ use super::LengthAtMost32;\n /// A by-value [array] iterator.\n ///\n /// [array]: ../../std/primitive.array.html\n-#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n pub struct IntoIter<T, const N: usize>\n where\n     [T; N]: LengthAtMost32,\n@@ -49,7 +49,7 @@ where\n     /// *Note*: this method might never get stabilized and/or removed in the\n     /// future as there will likely be another, preferred way of obtaining this\n     /// iterator (either via `IntoIterator` for arrays or via another way).\n-    #[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+    #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n     pub fn new(array: [T; N]) -> Self {\n         // The transmute here is actually safe. The docs of `MaybeUninit`\n         // promise:\n@@ -95,7 +95,7 @@ where\n }\n \n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -141,7 +141,7 @@ where\n     }\n }\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -176,7 +176,7 @@ where\n     }\n }\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> Drop for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -189,7 +189,7 @@ where\n     }\n }\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -204,7 +204,7 @@ where\n     }\n }\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -214,13 +214,13 @@ where\n // elements (that will still be yielded) is the length of the range `alive`.\n // This range is decremented in length in either `next` or `next_back`. It is\n // always decremented by 1 in those methods, but only if `Some(_)` is returned.\n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n {}\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,\n@@ -251,7 +251,7 @@ where\n     }\n }\n \n-#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n where\n     [T; N]: LengthAtMost32,"}, {"sha": "e1ec8b795d04c6bfa467efba3549851c35919355", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -18,7 +18,7 @@ use crate::slice::{Iter, IterMut};\n mod iter;\n \n #[cfg(not(bootstrap))]\n-#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n pub use iter::IntoIter;\n \n /// Utility trait implemented only on arrays of fixed size"}, {"sha": "4655d39fb8f1fd187bf1222e7a21163014eeb53f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -874,6 +874,7 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n     ///     // Ensure the original vector is not dropped.\n     ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n     ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,"}, {"sha": "cdada1252d2bfc656e353eccc742cad5e2a2fcf1", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -28,7 +28,7 @@ use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub, is_aligned_and_not_null};\n use crate::isize;\n use crate::iter::*;\n-use crate::ops::{FnMut, self};\n+use crate::ops::{FnMut, Range, self};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::result::Result;\n@@ -407,6 +407,86 @@ impl<T> [T] {\n         self as *mut [T] as *mut T\n     }\n \n+    /// Returns the two raw pointers spanning the slice.\n+    ///\n+    /// The returned range is half-open, which means that the end pointer\n+    /// points *one past* the last element of the slice. This way, an empty\n+    /// slice is represented by two equal pointers, and the difference between\n+    /// the two pointers represents the size of the size.\n+    ///\n+    /// See [`as_ptr`] for warnings on using these pointers. The end pointer\n+    /// requires extra caution, as it does not point to a valid element in the\n+    /// slice.\n+    ///\n+    /// This function is useful for interacting with foreign interfaces which\n+    /// use two pointers to refer to a range of elements in memory, as is\n+    /// common in C++.\n+    ///\n+    /// It can also be useful to check if a pointer to an element refers to an\n+    /// element of this slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_range)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let x = &a[1] as *const _;\n+    /// let y = &5 as *const _;\n+    ///\n+    /// assert!(a.as_ptr_range().contains(&x));\n+    /// assert!(!a.as_ptr_range().contains(&y));\n+    /// ```\n+    ///\n+    /// [`as_ptr`]: #method.as_ptr\n+    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[inline]\n+    pub fn as_ptr_range(&self) -> Range<*const T> {\n+        // The `add` here is safe, because:\n+        //\n+        //   - Both pointers are part of the same object, as pointing directly\n+        //     past the object also counts.\n+        //\n+        //   - The size of the slice is never larger than isize::MAX bytes, as\n+        //     noted here:\n+        //       - https://github.com/rust-lang/unsafe-code-guidelines/issues/102#issuecomment-473340447\n+        //       - https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+        //       - https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html#safety\n+        //     (This doesn't seem normative yet, but the very same assumption is\n+        //     made in many places, including the Index implementation of slices.)\n+        //\n+        //   - There is no wrapping around involved, as slices do not wrap past\n+        //     the end of the address space.\n+        //\n+        // See the documentation of pointer::add.\n+        let start = self.as_ptr();\n+        let end = unsafe { start.add(self.len()) };\n+        start..end\n+    }\n+\n+    /// Returns the two unsafe mutable pointers spanning the slice.\n+    ///\n+    /// The returned range is half-open, which means that the end pointer\n+    /// points *one past* the last element of the slice. This way, an empty\n+    /// slice is represented by two equal pointers, and the difference between\n+    /// the two pointers represents the size of the size.\n+    ///\n+    /// See [`as_mut_ptr`] for warnings on using these pointers. The end\n+    /// pointer requires extra caution, as it does not point to a valid element\n+    /// in the slice.\n+    ///\n+    /// This function is useful for interacting with foreign interfaces which\n+    /// use two pointers to refer to a range of elements in memory, as is\n+    /// common in C++.\n+    ///\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[inline]\n+    pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n+        // See as_ptr_range() above for why `add` here is safe.\n+        let start = self.as_mut_ptr();\n+        let end = unsafe { start.add(self.len()) };\n+        start..end\n+    }\n+\n     /// Swaps two elements in the slice.\n     ///\n     /// # Arguments"}, {"sha": "38631224fd359fd1651561207f19233851a5a11b", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -37,4 +37,4 @@ byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.3\"\n+measureme = \"0.4\""}, {"sha": "0f7d5d9a25e617d8b750e9b59bd16f980139f25b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -2930,14 +2930,18 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n         // lower bounds from `size_hint` agree they are correct.\n         Ok(match iter.size_hint() {\n             (1, Some(1)) => {\n-                f(&[iter.next().unwrap()?])\n+                let t0 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n             }\n             (2, Some(2)) => {\n                 let t0 = iter.next().unwrap()?;\n                 let t1 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n                 f(&[t0, t1])\n             }\n             (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n                 f(&[])\n             }\n             _ => {"}, {"sha": "538154b035ac6567e1e2cf01574a161537445579", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -90,6 +90,10 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 }\n                 return TryGetJob::JobCompleted(result);\n             }\n+\n+            #[cfg(parallel_compiler)]\n+            let query_blocked_prof_timer;\n+\n             let job = match lock.active.entry((*key).clone()) {\n                 Entry::Occupied(entry) => {\n                     match *entry.get() {\n@@ -98,7 +102,9 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                             // in another thread has completed. Record how long we wait in the\n                             // self-profiler.\n                             #[cfg(parallel_compiler)]\n-                            tcx.prof.query_blocked_start(Q::NAME);\n+                            {\n+                                query_blocked_prof_timer = tcx.prof.query_blocked(Q::NAME);\n+                            }\n \n                             job.clone()\n                         },\n@@ -140,7 +146,11 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n-                tcx.prof.query_blocked_end(Q::NAME);\n+\n+                // This `drop()` is not strictly necessary as the binding\n+                // would go out of scope anyway. But it's good to have an\n+                // explicit marker of how far the measurement goes.\n+                drop(query_blocked_prof_timer);\n \n                 if let Err(cycle) = result {\n                     return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));"}, {"sha": "5a1b7f3aa4cb851343bee4e033c4d0d6edf91ea1", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 17, "deletions": 97, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -14,9 +14,12 @@ use measureme::{StringId, TimestampKind};\n /// MmapSerializatioSink is faster on macOS and Linux\n /// but FileSerializationSink is faster on Windows\n #[cfg(not(windows))]\n-type Profiler = measureme::Profiler<measureme::MmapSerializationSink>;\n+type SerializationSink = measureme::MmapSerializationSink;\n #[cfg(windows)]\n-type Profiler = measureme::Profiler<measureme::FileSerializationSink>;\n+type SerializationSink = measureme::FileSerializationSink;\n+\n+type Profiler = measureme::Profiler<SerializationSink>;\n+\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd)]\n pub enum ProfileCategory {\n@@ -131,32 +134,6 @@ impl SelfProfilerRef {\n         })\n     }\n \n-    /// Start profiling a generic activity. Profiling continues until\n-    /// `generic_activity_end` is called. The RAII-based `generic_activity`\n-    /// usually is the better alternative.\n-    #[inline(always)]\n-    pub fn generic_activity_start(&self, event_id: &str) {\n-        self.non_guard_generic_event(\n-            |profiler| profiler.generic_activity_event_kind,\n-            |profiler| profiler.profiler.alloc_string(event_id),\n-            EventFilter::GENERIC_ACTIVITIES,\n-            TimestampKind::Start,\n-        );\n-    }\n-\n-    /// End profiling a generic activity that was started with\n-    /// `generic_activity_start`. The RAII-based `generic_activity` usually is\n-    /// the better alternative.\n-    #[inline(always)]\n-    pub fn generic_activity_end(&self, event_id: &str) {\n-        self.non_guard_generic_event(\n-            |profiler| profiler.generic_activity_event_kind,\n-            |profiler| profiler.profiler.alloc_string(event_id),\n-            EventFilter::GENERIC_ACTIVITIES,\n-            TimestampKind::End,\n-        );\n-    }\n-\n     /// Start profiling a query provider. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]\n@@ -179,26 +156,14 @@ impl SelfProfilerRef {\n     }\n \n     /// Start profiling a query being blocked on a concurrent execution.\n-    /// Profiling continues until `query_blocked_end` is called.\n-    #[inline(always)]\n-    pub fn query_blocked_start(&self, query_name: QueryName) {\n-        self.non_guard_query_event(\n-            |profiler| profiler.query_blocked_event_kind,\n-            query_name,\n-            EventFilter::QUERY_BLOCKED,\n-            TimestampKind::Start,\n-        );\n-    }\n-\n-    /// End profiling a query being blocked on a concurrent execution.\n+    /// Profiling continues until the TimingGuard returned from this call is\n+    /// dropped.\n     #[inline(always)]\n-    pub fn query_blocked_end(&self, query_name: QueryName) {\n-        self.non_guard_query_event(\n-            |profiler| profiler.query_blocked_event_kind,\n-            query_name,\n-            EventFilter::QUERY_BLOCKED,\n-            TimestampKind::End,\n-        );\n+    pub fn query_blocked(&self, query_name: QueryName) -> TimingGuard<'_> {\n+        self.exec(EventFilter::QUERY_BLOCKED, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            TimingGuard::start(profiler, profiler.query_blocked_event_kind, event_id)\n+        })\n     }\n \n     /// Start profiling how long it takes to load a query result from the\n@@ -238,28 +203,6 @@ impl SelfProfilerRef {\n             TimingGuard::none()\n         }));\n     }\n-\n-    #[inline(always)]\n-    fn non_guard_generic_event<F: FnOnce(&SelfProfiler) -> StringId>(\n-        &self,\n-        event_kind: fn(&SelfProfiler) -> StringId,\n-        event_id: F,\n-        event_filter: EventFilter,\n-        timestamp_kind: TimestampKind\n-    ) {\n-        drop(self.exec(event_filter, |profiler| {\n-            let thread_id = thread_id_to_u64(std::thread::current().id());\n-\n-            profiler.profiler.record_event(\n-                event_kind(profiler),\n-                event_id(profiler),\n-                thread_id,\n-                timestamp_kind,\n-            );\n-\n-            TimingGuard::none()\n-        }));\n-    }\n }\n \n pub struct SelfProfiler {\n@@ -346,14 +289,7 @@ impl SelfProfiler {\n }\n \n #[must_use]\n-pub struct TimingGuard<'a>(Option<TimingGuardInternal<'a>>);\n-\n-struct TimingGuardInternal<'a> {\n-    raw_profiler: &'a Profiler,\n-    event_id: StringId,\n-    event_kind: StringId,\n-    thread_id: u64,\n-}\n+pub struct TimingGuard<'a>(Option<measureme::TimingGuard<'a, SerializationSink>>);\n \n impl<'a> TimingGuard<'a> {\n     #[inline]\n@@ -364,30 +300,14 @@ impl<'a> TimingGuard<'a> {\n     ) -> TimingGuard<'a> {\n         let thread_id = thread_id_to_u64(std::thread::current().id());\n         let raw_profiler = &profiler.profiler;\n-        raw_profiler.record_event(event_kind, event_id, thread_id, TimestampKind::Start);\n-\n-        TimingGuard(Some(TimingGuardInternal {\n-            raw_profiler,\n-            event_kind,\n-            event_id,\n-            thread_id,\n-        }))\n+        let timing_guard = raw_profiler.start_recording_interval_event(event_kind,\n+                                                                       event_id,\n+                                                                       thread_id);\n+        TimingGuard(Some(timing_guard))\n     }\n \n     #[inline]\n     pub fn none() -> TimingGuard<'a> {\n         TimingGuard(None)\n     }\n }\n-\n-impl<'a> Drop for TimingGuardInternal<'a> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        self.raw_profiler.record_event(\n-            self.event_kind,\n-            self.event_id,\n-            self.thread_id,\n-            TimestampKind::End\n-        );\n-    }\n-}"}, {"sha": "cd26c7ca200b00a767000836297a3e9ff506fcbd", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/246be7e1a557b8ac8287c6842379a0db67770be6/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=246be7e1a557b8ac8287c6842379a0db67770be6", "patch": "@@ -119,8 +119,14 @@ sgx_entry:\n     mov %rbx,%gs:tcsls_tcs_addr\n     stmxcsr %gs:tcsls_user_mxcsr\n     fnstcw %gs:tcsls_user_fcw\n+\n /*  reset user state */\n-    cld /* x86-64 ABI requires DF to be unset at function entry/exit */\n+/*    - DF flag: x86-64 ABI requires DF to be unset at function entry/exit */\n+/*    - AC flag: AEX on misaligned memory accesses leaks side channel info */\n+    pushfq\n+    andq $~0x40400, (%rsp)\n+    popfq\n+\n /*  check for debug buffer pointer */\n     testb  $0xff,DEBUG(%rip)\n     jz .Lskip_debug_init"}]}