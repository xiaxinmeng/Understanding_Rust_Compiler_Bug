{"sha": "1677946d74e411b497cf06e69749e7e1b15afa09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2Nzc5NDZkNzRlNDExYjQ5N2NmMDZlNjk3NDllN2UxYjE1YWZhMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T09:34:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-25T09:34:02Z"}, "message": "Auto merge of #1838 - atsmtat:fs-isolation, r=RalfJung\n\nFix use of deprecated `check_no_isolation` in posix fs shims\n\nUpdate posix fs shims to use new API `reject_in_isolation`, which\nallows rejection with error code instead of always forcing abort.\nError code chosen for each op is the most appropriate one from the\nlist in corresponding syscall's manual.\n\nUpdated helper APIs to not use quotes (\\`) around input name while\npreparing the message. This allows callers to pass multi-word string\nlike -- \"\\`read\\` from stdin\".\n\nCc https://github.com/rust-lang/miri/issues/1034", "tree": {"sha": "dcb8b4b353dd433ae4f104d7be6f1f90cf6538b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcb8b4b353dd433ae4f104d7be6f1f90cf6538b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1677946d74e411b497cf06e69749e7e1b15afa09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1677946d74e411b497cf06e69749e7e1b15afa09", "html_url": "https://github.com/rust-lang/rust/commit/1677946d74e411b497cf06e69749e7e1b15afa09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1677946d74e411b497cf06e69749e7e1b15afa09/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2872a3f2a26154b91a6a6085d56016509803c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2872a3f2a26154b91a6a6085d56016509803c61", "html_url": "https://github.com/rust-lang/rust/commit/e2872a3f2a26154b91a6a6085d56016509803c61"}, {"sha": "20d0f2ee2607a1eecf095223250ca07307b9dbb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/20d0f2ee2607a1eecf095223250ca07307b9dbb0", "html_url": "https://github.com/rust-lang/rust/commit/20d0f2ee2607a1eecf095223250ca07307b9dbb0"}], "stats": {"total": 326, "additions": 260, "deletions": 66}, "files": [{"sha": "f66f66e0088ffbfdf7583d24d14941e399061e1d", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -328,7 +328,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     CreatedAlloc(AllocId(id)) => format!(\"created allocation with id {}\", id),\n                     FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {}\", id),\n                     RejectedIsolatedOp(ref op) =>\n-                        format!(\"`{}` was made to return an error due to isolation\", op),\n+                        format!(\"{} was made to return an error due to isolation\", op),\n                 };\n \n                 let (title, diag_level) = match e {"}, {"sha": "e09ef2865fb2b2b1e0c57ebb9758e6cf4c9f361a", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -409,7 +409,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             RejectOpWith::WarningWithoutBacktrace => {\n                 this.tcx\n                     .sess\n-                    .warn(&format!(\"`{}` was made to return an error due to isolation\", op_name));\n+                    .warn(&format!(\"{} was made to return an error due to isolation\", op_name));\n                 Ok(())\n             }\n             RejectOpWith::Warning => {"}, {"sha": "9290ec022b57f12d78695ae07ae80386ba3ba748", "filename": "src/shims/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -322,7 +322,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"getcwd\", reject_with)?;\n+            this.reject_in_isolation(\"`getcwd`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n             return Ok(Pointer::null());\n         }\n@@ -355,7 +355,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let buf = this.read_pointer(buf_op)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"GetCurrentDirectoryW\", reject_with)?;\n+            this.reject_in_isolation(\"`GetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n             return Ok(0);\n         }\n@@ -380,7 +380,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"chdir\", reject_with)?;\n+            this.reject_in_isolation(\"`chdir`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n             return Ok(-1);\n@@ -408,7 +408,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let path = this.read_path_from_wide_str(this.read_pointer(path_op)?)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"SetCurrentDirectoryW\", reject_with)?;\n+            this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n             return Ok(0);"}, {"sha": "ac6e878da962e83e686d0efcf1b383f3a83d0186", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 180, "deletions": 60, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -4,7 +4,7 @@ use std::convert::{TryFrom, TryInto};\n use std::fs::{\n     read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n };\n-use std::io::{self, Read, Seek, SeekFrom, Write};\n+use std::io::{self, ErrorKind, Read, Seek, SeekFrom, Write};\n use std::path::Path;\n use std::time::SystemTime;\n \n@@ -304,28 +304,6 @@ impl<'tcx> FileHandler {\n \n impl<'mir, 'tcx: 'mir> EvalContextExtPrivate<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Emulate `stat` or `lstat` on `macos`. This function is not intended to be\n-    /// called directly from `emulate_foreign_item_by_name`, so it does not check if isolation is\n-    /// disabled or if the target OS is the correct one. Please use `macos_stat` or\n-    /// `macos_lstat` instead.\n-    fn macos_stat_or_lstat(\n-        &mut self,\n-        follow_symlink: bool,\n-        path_op: &OpTy<'tcx, Tag>,\n-        buf_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n-        let this = self.eval_context_mut();\n-\n-        let path_scalar = this.read_pointer(path_op)?;\n-        let path = this.read_path_from_c_str(path_scalar)?.into_owned();\n-\n-        let metadata = match FileMetadata::from_path(this, &path, follow_symlink)? {\n-            Some(metadata) => metadata,\n-            None => return Ok(-1),\n-        };\n-        this.macos_stat_write_buf(metadata, buf_op)\n-    }\n-\n     fn macos_stat_write_buf(\n         &mut self,\n         metadata: FileMetadata,\n@@ -504,8 +482,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`open`\")?;\n-\n         let flag = this.read_scalar(flag_op)?.to_i32()?;\n \n         // Get the mode.  On macOS, the argument type `mode_t` is actually `u16`, but\n@@ -583,6 +559,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`open`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         let fd = options.open(&path).map(|file| {\n             let fh = &mut this.machine.file_handler;\n             fh.insert_fd(Box::new(FileHandle { file, writable }))\n@@ -594,8 +577,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn fcntl(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`fcntl`\")?;\n-\n         if args.len() < 2 {\n             throw_ub_format!(\n                 \"incorrect number of arguments for fcntl: got {}, expected at least 2\",\n@@ -604,6 +585,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let fd = this.read_scalar(&args[0])?.to_i32()?;\n         let cmd = this.read_scalar(&args[1])?.to_i32()?;\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`fcntl`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         // We only support getting the flags for a descriptor.\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n@@ -785,10 +774,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn unlink(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`unlink`\")?;\n-\n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`unlink`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         let result = remove_file(path).map(|_| 0);\n         this.try_unwrap_io_result(result)\n     }\n@@ -810,12 +804,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         let this = self.eval_context_mut();\n-\n-        this.check_no_isolation(\"`symlink`\")?;\n-\n         let target = this.read_path_from_c_str(this.read_pointer(target_op)?)?;\n         let linkpath = this.read_path_from_c_str(this.read_pointer(linkpath_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`symlink`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         let result = create_link(&target, &linkpath).map(|_| 0);\n         this.try_unwrap_io_result(result)\n     }\n@@ -827,9 +825,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"stat\");\n-        this.check_no_isolation(\"`stat`\")?;\n+\n+        let path_scalar = this.read_pointer(path_op)?;\n+        let path = this.read_path_from_c_str(path_scalar)?.into_owned();\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`stat`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(-1);\n+        }\n+\n         // `stat` always follows symlinks.\n-        this.macos_stat_or_lstat(true, path_op, buf_op)\n+        let metadata = match FileMetadata::from_path(this, &path, true)? {\n+            Some(metadata) => metadata,\n+            None => return Ok(-1),\n+        };\n+\n+        this.macos_stat_write_buf(metadata, buf_op)\n     }\n \n     // `lstat` is used to get symlink metadata.\n@@ -840,8 +854,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"lstat\");\n-        this.check_no_isolation(\"`lstat`\")?;\n-        this.macos_stat_or_lstat(false, path_op, buf_op)\n+\n+        let path_scalar = this.read_pointer(path_op)?;\n+        let path = this.read_path_from_c_str(path_scalar)?.into_owned();\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`lstat`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(-1);\n+        }\n+\n+        let metadata = match FileMetadata::from_path(this, &path, false)? {\n+            Some(metadata) => metadata,\n+            None => return Ok(-1),\n+        };\n+\n+        this.macos_stat_write_buf(metadata, buf_op)\n     }\n \n     fn macos_fstat(\n@@ -852,10 +882,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"fstat\");\n-        this.check_no_isolation(\"`fstat`\")?;\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`fstat`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         let metadata = match FileMetadata::from_fd(this, fd)? {\n             Some(metadata) => metadata,\n             None => return Ok(-1),\n@@ -874,7 +910,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"statx\");\n-        this.check_no_isolation(\"`statx`\")?;\n \n         let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n         let pathname_ptr = this.read_pointer(pathname_op)?;\n@@ -924,6 +959,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             )\n         }\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`statx`\", reject_with)?;\n+            let ecode = if path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")? {\n+                // since `path` is provided, either absolute or\n+                // relative to CWD, `EACCES` is the most relevant.\n+                this.eval_libc(\"EACCES\")?\n+            } else {\n+                // `dirfd` is set to target file, and `path` is empty\n+                // (or we would have hit the `throw_unsup_format`\n+                // above). `EACCES` would violate the spec.\n+                assert!(empty_path_flag);\n+                this.eval_libc(\"EBADF\")?\n+            };\n+            this.set_last_error(ecode)?;\n+            return Ok(-1);\n+        }\n+\n         // the `_mask_op` paramter specifies the file information that the caller requested.\n         // However `statx` is allowed to return information that was not requested or to not\n         // return information that was requested. This `mask` represents the information we can\n@@ -1032,8 +1085,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`rename`\")?;\n-\n         let oldpath_ptr = this.read_pointer(oldpath_op)?;\n         let newpath_ptr = this.read_pointer(newpath_op)?;\n \n@@ -1046,6 +1097,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let oldpath = this.read_path_from_c_str(oldpath_ptr)?;\n         let newpath = this.read_path_from_c_str(newpath_ptr)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`rename`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         let result = rename(oldpath, newpath).map(|_| 0);\n \n         this.try_unwrap_io_result(result)\n@@ -1058,8 +1116,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`mkdir`\")?;\n-\n         #[cfg_attr(not(unix), allow(unused_variables))]\n         let mode = if this.tcx.sess.target.os == \"macos\" {\n             u32::from(this.read_scalar(mode_op)?.to_u16()?)\n@@ -1069,6 +1125,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`mkdir`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         #[cfg_attr(not(unix), allow(unused_mut))]\n         let mut builder = DirBuilder::new();\n \n@@ -1088,10 +1151,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn rmdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`rmdir`\")?;\n-\n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`rmdir`\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n+            return Ok(-1);\n+        }\n+\n         let result = remove_dir(path).map(|_| 0i32);\n \n         this.try_unwrap_io_result(result)\n@@ -1100,10 +1168,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn opendir(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`opendir`\")?;\n-\n         let name = this.read_path_from_c_str(this.read_pointer(name_op)?)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`opendir`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(Scalar::null_ptr(this));\n+        }\n+\n         let result = read_dir(name);\n \n         match result {\n@@ -1131,10 +1205,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"readdir64_r\");\n-        this.check_no_isolation(\"`readdir64_r`\")?;\n \n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`readdir64_r`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n             err_unsup_format!(\"the DIR pointer passed to readdir64_r did not come from opendir\")\n         })?;\n@@ -1224,10 +1304,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"readdir_r\");\n-        this.check_no_isolation(\"`readdir_r`\")?;\n \n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`readdir_r`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n             err_unsup_format!(\"the DIR pointer passed to readdir_r did not come from opendir\")\n         })?;\n@@ -1313,10 +1399,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn closedir(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`closedir`\")?;\n-\n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`closedir`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         if let Some(dir_iter) = this.machine.dir_handler.streams.remove(&dirp) {\n             drop(dir_iter);\n             Ok(0)\n@@ -1332,10 +1423,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`ftruncate64`\")?;\n-\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let length = this.read_scalar(length_op)?.to_i64()?;\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`ftruncate64`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             // FIXME: Support ftruncate64 for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -1367,9 +1464,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`fsync`\")?;\n-\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`fsync`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support fsync for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -1383,9 +1486,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn fdatasync(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`fdatasync`\")?;\n-\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n+\n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`fdatasync`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support fdatasync for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -1405,8 +1514,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"`sync_file_range`\")?;\n-\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let offset = this.read_scalar(offset_op)?.to_i64()?;\n         let nbytes = this.read_scalar(nbytes_op)?.to_i64()?;\n@@ -1426,6 +1533,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         }\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`sync_file_range`\", reject_with)?;\n+            // Set error code as \"EBADF\" (bad fd)\n+            return this.handle_not_found();\n+        }\n+\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support sync_data_range for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -1444,12 +1558,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"readlink\")?;\n-\n         let pathname = this.read_path_from_c_str(this.read_pointer(pathname_op)?)?;\n         let buf = this.read_pointer(buf_op)?;\n         let bufsize = this.read_scalar(bufsize_op)?.to_machine_usize(this)?;\n \n+        // Reject if isolation is enabled.\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"`readlink`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EACCES\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(-1);\n+        }\n+\n         let result = std::fs::read_link(pathname);\n         match result {\n             Ok(resolved) => {"}, {"sha": "a9e1e5094fa525a242ccb4df4eb03f6c2113053b", "filename": "tests/run-pass/fs_with_isolation.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/tests%2Frun-pass%2Ffs_with_isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/tests%2Frun-pass%2Ffs_with_isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs_with_isolation.rs?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -0,0 +1,54 @@\n+// ignore-windows: File handling is not implemented yet\n+// compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n+// normalize-stderr-test \"(stat(x)?)\" -> \"$$STAT\"\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::ffi::CString;\n+use std::os::unix;\n+use std::fs::{self, File};\n+use std::io::{Error, ErrorKind};\n+\n+fn main() {\n+    // test `open`\n+    assert_eq!(File::create(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `fcntl`\n+    unsafe {\n+        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n+    }\n+\n+    // test `unlink`\n+    assert_eq!(fs::remove_file(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `symlink`\n+    assert_eq!(unix::fs::symlink(\"foo.txt\", \"foo_link.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `readlink`\n+    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n+    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n+    unsafe {\n+        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    }\n+\n+    // test `stat`\n+    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+\n+    // test `rename`\n+    assert_eq!(fs::rename(\"a.txt\", \"b.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `mkdir`\n+    assert_eq!(fs::create_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `rmdir`\n+    assert_eq!(fs::remove_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+\n+    // test `opendir`\n+    assert_eq!(fs::read_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+}"}, {"sha": "ad75e42831b0ac7b71caaeb9e53d1f8769f276be", "filename": "tests/run-pass/fs_with_isolation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1677946d74e411b497cf06e69749e7e1b15afa09/tests%2Frun-pass%2Ffs_with_isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1677946d74e411b497cf06e69749e7e1b15afa09/tests%2Frun-pass%2Ffs_with_isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs_with_isolation.stderr?ref=1677946d74e411b497cf06e69749e7e1b15afa09", "patch": "@@ -0,0 +1,20 @@\n+warning: `open` was made to return an error due to isolation\n+\n+warning: `fcntl` was made to return an error due to isolation\n+\n+warning: `unlink` was made to return an error due to isolation\n+\n+warning: `symlink` was made to return an error due to isolation\n+\n+warning: `readlink` was made to return an error due to isolation\n+\n+warning: `$STAT` was made to return an error due to isolation\n+\n+warning: `rename` was made to return an error due to isolation\n+\n+warning: `mkdir` was made to return an error due to isolation\n+\n+warning: `rmdir` was made to return an error due to isolation\n+\n+warning: `opendir` was made to return an error due to isolation\n+"}]}