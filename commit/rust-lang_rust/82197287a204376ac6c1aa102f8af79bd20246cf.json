{"sha": "82197287a204376ac6c1aa102f8af79bd20246cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTk3Mjg3YTIwNDM3NmFjNmMxYWExMDJmOGFmNzliZDIwMjQ2Y2Y=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-29T05:55:40Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T16:21:33Z"}, "message": "rustc_metadata: combine EncodeContext and rbml::writer::Encoder.", "tree": {"sha": "3e4050a65ed8b1db07e62448e1c1648c304d8c06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e4050a65ed8b1db07e62448e1c1648c304d8c06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82197287a204376ac6c1aa102f8af79bd20246cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82197287a204376ac6c1aa102f8af79bd20246cf", "html_url": "https://github.com/rust-lang/rust/commit/82197287a204376ac6c1aa102f8af79bd20246cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82197287a204376ac6c1aa102f8af79bd20246cf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b073343db09aa51c6ff181aa721d4d022aa6d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b073343db09aa51c6ff181aa721d4d022aa6d6f", "html_url": "https://github.com/rust-lang/rust/commit/7b073343db09aa51c6ff181aa721d4d022aa6d6f"}], "stats": {"total": 1664, "additions": 800, "deletions": 864}, "files": [{"sha": "3fd4d0cf272726fc85aba89626acd9ebfbb1e765", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 92, "deletions": 117, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -46,7 +46,6 @@ use std::io::SeekFrom;\n use std::io::prelude::*;\n \n use rbml::reader;\n-use rbml::writer::Encoder;\n use rbml;\n use rustc_serialize::{Decodable, Decoder, DecoderHelpers};\n use rustc_serialize::{Encodable, EncoderHelpers};\n@@ -67,32 +66,32 @@ trait tr {\n // ______________________________________________________________________\n // Top-level methods.\n \n-pub fn encode_inlined_item(ecx: &e::EncodeContext,\n-                           rbml_w: &mut Encoder,\n-                           ii: InlinedItemRef) {\n+pub fn encode_inlined_item(ecx: &mut e::EncodeContext, ii: InlinedItemRef) {\n     let id = match ii {\n         InlinedItemRef::Item(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.node_path_str(id),\n-           rbml_w.writer.seek(SeekFrom::Current(0)));\n+           ecx.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n     let (ii, expected_id_range) = simplify_ast(ii);\n     let id_range = inlined_item_id_range(&ii);\n     assert_eq!(expected_id_range, id_range);\n \n-    rbml_w.start_tag(c::tag_ast as usize);\n-    id_range.encode(rbml_w);\n-    encode_ast(rbml_w, &ii);\n-    encode_side_tables_for_ii(ecx, rbml_w, &ii);\n-    rbml_w.end_tag();\n+    ecx.start_tag(c::tag_ast as usize);\n+    id_range.encode(ecx);\n+    ecx.start_tag(c::tag_tree as usize);\n+    ecx.emit_opaque(|this| ii.encode(this));\n+    ecx.end_tag();\n+    encode_side_tables_for_ii(ecx, &ii);\n+    ecx.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({:?})\",\n            ecx.tcx.node_path_str(id),\n-           rbml_w.writer.seek(SeekFrom::Current(0)));\n+           ecx.writer.seek(SeekFrom::Current(0)));\n }\n \n impl<'a, 'b, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'tcx> {\n@@ -235,12 +234,6 @@ impl tr for syntax_pos::Span {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n-    rbml_w.start_tag(c::tag_tree as usize);\n-    rbml_w.emit_opaque(|this| item.encode(this));\n-    rbml_w.end_tag();\n-}\n-\n struct NestedItemsDropper {\n     id_range: IdRange\n }\n@@ -385,10 +378,6 @@ impl tr for Def {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &hir::Freevar) {\n-    (*fv).encode(rbml_w).unwrap();\n-}\n-\n impl<'a> reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> hir::Freevar {\n@@ -409,26 +398,27 @@ impl tr for hir::Freevar {\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n-fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n-                                  rbml_w: &mut Encoder,\n-                                  autoderef: u32,\n-                                  method: &ty::MethodCallee<'tcx>) {\n-    use rustc_serialize::Encoder;\n+impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n+    fn encode_method_callee(&mut self,\n+                            autoderef: u32,\n+                            method: &ty::MethodCallee<'tcx>) {\n+        use rustc_serialize::Encoder;\n \n-    rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n-        rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n-            autoderef.encode(rbml_w)\n-        });\n-        rbml_w.emit_struct_field(\"def_id\", 1, |rbml_w| {\n-            method.def_id.encode(rbml_w)\n-        });\n-        rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n-            Ok(rbml_w.emit_ty(ecx, method.ty))\n-        });\n-        rbml_w.emit_struct_field(\"substs\", 3, |rbml_w| {\n-            Ok(rbml_w.emit_substs(ecx, &method.substs))\n-        })\n-    }).unwrap();\n+        self.emit_struct(\"MethodCallee\", 4, |this| {\n+            this.emit_struct_field(\"autoderef\", 0, |this| {\n+                autoderef.encode(this)\n+            });\n+            this.emit_struct_field(\"def_id\", 1, |this| {\n+                method.def_id.encode(this)\n+            });\n+            this.emit_struct_field(\"ty\", 2, |this| {\n+                Ok(this.emit_ty(method.ty))\n+            });\n+            this.emit_struct_field(\"substs\", 3, |this| {\n+                Ok(this.emit_substs(&method.substs))\n+            })\n+        }).unwrap();\n+    }\n }\n \n impl<'a, 'tcx> reader::Decoder<'a> {\n@@ -453,27 +443,25 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n     }\n }\n \n-pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n-    kind.encode(ebml_w).unwrap();\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-impl<'a, 'tcx> Encoder<'a> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region) {\n+impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n+    fn emit_region(&mut self, r: &'tcx ty::Region) {\n+        let cx = self.ty_str_ctxt();\n         self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n-                                                        &ecx.ty_str_ctxt(),\n+                                                        &cx,\n                                                         r)));\n     }\n \n-    fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n+    fn emit_ty(&mut self, ty: Ty<'tcx>) {\n+        let cx = self.ty_str_ctxt();\n         self.emit_opaque(|this| Ok(tyencode::enc_ty(&mut this.cursor,\n-                                                    &ecx.ty_str_ctxt(),\n+                                                    &cx,\n                                                     ty)));\n     }\n \n-    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n+    fn emit_upvar_capture(&mut self, capture: &ty::UpvarCapture<'tcx>) {\n         use rustc_serialize::Encoder;\n \n         self.emit_enum(\"UpvarCapture\", |this| {\n@@ -486,22 +474,21 @@ impl<'a, 'tcx> Encoder<'a> {\n                         this.emit_enum_variant_arg(0,\n                             |this| kind.encode(this));\n                         this.emit_enum_variant_arg(1,\n-                            |this| Ok(this.emit_region(ecx, region)))\n+                            |this| Ok(this.emit_region(region)))\n                     })\n                 }\n             }\n         }).unwrap()\n     }\n \n-    fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                       substs: &Substs<'tcx>) {\n+    fn emit_substs(&mut self, substs: &Substs<'tcx>) {\n+        let cx = self.ty_str_ctxt();\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n-                                                        &ecx.ty_str_ctxt(),\n+                                                        &cx,\n                                                         substs)));\n     }\n \n-    fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                                adj: &adjustment::AutoAdjustment<'tcx>) {\n+    fn emit_auto_adjustment(&mut self, adj: &adjustment::AutoAdjustment<'tcx>) {\n         use rustc_serialize::Encoder;\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n@@ -525,29 +512,28 @@ impl<'a, 'tcx> Encoder<'a> {\n                 adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AdjustDerefRef\", 4, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n+                            |this| Ok(this.emit_auto_deref_ref(auto_deref_ref)))\n                     })\n                 }\n \n                 adjustment::AdjustNeverToAny(ref ty) => {\n                     this.emit_enum_variant(\"AdjustNeverToAny\", 5, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ecx, ty)))\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ty)))\n                     })\n                 }\n             }\n         });\n     }\n \n-    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                        autoref: &adjustment::AutoRef<'tcx>) {\n+    fn emit_autoref(&mut self, autoref: &adjustment::AutoRef<'tcx>) {\n         use rustc_serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n                 &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_region(ecx, r)));\n+                            |this| Ok(this.emit_region(r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -560,8 +546,7 @@ impl<'a, 'tcx> Encoder<'a> {\n         });\n     }\n \n-    fn emit_auto_deref_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                               auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n+    fn emit_auto_deref_ref(&mut self, auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n         use rustc_serialize::Encoder;\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n@@ -571,7 +556,7 @@ impl<'a, 'tcx> Encoder<'a> {\n                 this.emit_option(|this| {\n                     match auto_deref_ref.autoref {\n                         None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(a))),\n                     }\n                 })\n             });\n@@ -581,20 +566,18 @@ impl<'a, 'tcx> Encoder<'a> {\n                     match auto_deref_ref.unsize {\n                         None => this.emit_option_none(),\n                         Some(target) => this.emit_option_some(|this| {\n-                            Ok(this.emit_ty(ecx, target))\n+                            Ok(this.emit_ty(target))\n                         })\n                     }\n                 })\n             })\n         });\n     }\n-}\n \n-impl<'a> Encoder<'a> {\n     fn tag<F>(&mut self,\n               tag_id: c::astencode_tag,\n               f: F) where\n-        F: FnOnce(&mut Encoder<'a>),\n+        F: FnOnce(&mut Self),\n     {\n         self.start_tag(tag_id as usize);\n         f(self);\n@@ -606,68 +589,61 @@ impl<'a> Encoder<'a> {\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n-    ecx: &'a e::EncodeContext<'c, 'tcx>,\n-    rbml_w: &'a mut Encoder<'b>,\n+struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n+    ecx: &'a mut e::EncodeContext<'b, 'tcx>,\n }\n \n-impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for\n-        SideTableEncodingIdVisitor<'a, 'b, 'c, 'tcx> {\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        encode_side_tables_for_id(self.ecx, self.rbml_w, id)\n+        encode_side_tables_for_id(self.ecx, id)\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             rbml_w: &mut Encoder,\n-                             ii: &InlinedItem) {\n-    rbml_w.start_tag(c::tag_table as usize);\n+fn encode_side_tables_for_ii(ecx: &mut e::EncodeContext, ii: &InlinedItem) {\n+    ecx.start_tag(c::tag_table as usize);\n     ii.visit(&mut SideTableEncodingIdVisitor {\n-        ecx: ecx,\n-        rbml_w: rbml_w\n+        ecx: ecx\n     });\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             rbml_w: &mut Encoder,\n-                             id: ast::NodeId) {\n+fn encode_side_tables_for_id(ecx: &mut e::EncodeContext, id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n     if let Some(def) = tcx.expect_def_or_none(id) {\n-        rbml_w.tag(c::tag_table_def, |rbml_w| {\n-            rbml_w.id(id);\n-            def.encode(rbml_w).unwrap();\n+        ecx.tag(c::tag_table_def, |ecx| {\n+            ecx.id(id);\n+            def.encode(ecx).unwrap();\n         })\n     }\n \n     if let Some(ty) = tcx.node_types().get(&id) {\n-        rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_ty(ecx, *ty);\n+        ecx.tag(c::tag_table_node_type, |ecx| {\n+            ecx.id(id);\n+            ecx.emit_ty(*ty);\n         })\n     }\n \n     if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n-        rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_substs(ecx, &item_substs.substs);\n+        ecx.tag(c::tag_table_item_subst, |ecx| {\n+            ecx.id(id);\n+            ecx.emit_substs(&item_substs.substs);\n         })\n     }\n \n     if let Some(fv) = tcx.freevars.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_from_vec(fv, |rbml_w, fv_entry| {\n-                Ok(encode_freevar_entry(rbml_w, fv_entry))\n+        ecx.tag(c::tag_table_freevars, |ecx| {\n+            ecx.id(id);\n+            ecx.emit_from_vec(fv, |ecx, fv_entry| {\n+                fv_entry.encode(ecx)\n             });\n         });\n \n         for freevar in fv {\n-            rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n-                rbml_w.id(id);\n+            ecx.tag(c::tag_table_upvar_capture_map, |ecx| {\n+                ecx.id(id);\n \n                 let var_id = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId {\n@@ -680,17 +656,17 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                        .get(&upvar_id)\n                                        .unwrap()\n                                        .clone();\n-                var_id.encode(rbml_w);\n-                rbml_w.emit_upvar_capture(ecx, &upvar_capture);\n+                var_id.encode(ecx);\n+                ecx.emit_upvar_capture(&upvar_capture);\n             })\n         }\n     }\n \n     let method_call = ty::MethodCall::expr(id);\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n+        ecx.tag(c::tag_table_method_map, |ecx| {\n+            ecx.id(id);\n+            ecx.encode_method_callee(method_call.autoderef, method)\n         })\n     }\n \n@@ -700,34 +676,33 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-                        rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n-                            rbml_w.id(id);\n-                            encode_method_callee(ecx, rbml_w,\n-                                                 method_call.autoderef, method)\n+                        ecx.tag(c::tag_table_method_map, |ecx| {\n+                            ecx.id(id);\n+                            ecx.encode_method_callee(method_call.autoderef, method)\n                         })\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_auto_adjustment(ecx, adjustment);\n+        ecx.tag(c::tag_table_adjustments, |ecx| {\n+            ecx.id(id);\n+            ecx.emit_auto_adjustment(adjustment);\n         })\n     }\n \n     if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_cast_kind(rbml_w, *cast_kind)\n+        ecx.tag(c::tag_table_cast_kinds, |ecx| {\n+            ecx.id(id);\n+            cast_kind.encode(ecx).unwrap()\n         })\n     }\n \n     if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n-            rbml_w.id(id);\n-            qualif.encode(rbml_w).unwrap()\n+        ecx.tag(c::tag_table_const_qualif, |ecx| {\n+            ecx.id(id);\n+            qualif.encode(ecx).unwrap()\n         })\n     }\n }"}, {"sha": "c37b2de751f9605957d799259bf56d5c9a072d71", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -13,6 +13,7 @@ use common;\n use decoder;\n use encoder;\n use loader;\n+use rbml;\n \n use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate, DefLike};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n@@ -707,15 +708,16 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                            mir_map: &MirMap<'tcx>,\n                            krate: &hir::Crate) -> Vec<u8>\n     {\n+        let type_abbrevs = RefCell::new(FnvHashMap());\n         let ecx = encoder::EncodeContext {\n-            diag: tcx.sess.diagnostic(),\n+            rbml_w: rbml::writer::Encoder::new(),\n             tcx: tcx,\n             reexports: reexports,\n             link_meta: link_meta,\n             cstore: self,\n             reachable: reachable,\n             mir_map: mir_map,\n-            type_abbrevs: RefCell::new(FnvHashMap()),\n+            type_abbrevs: &type_abbrevs,\n         };\n         encoder::encode_metadata(ecx, krate)\n "}, {"sha": "ecddab0d0609e12ec745139c4ae0e3d44a7e3bf1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -812,10 +812,8 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n         };\n         let mut decoder = reader::Decoder::new(mir_doc);\n \n-        let mut mir = decoder.read_opaque(|opaque_decoder, _| {\n-            tls::enter_decoding_context(&dcx, opaque_decoder, |_, opaque_decoder| {\n-                Decodable::decode(opaque_decoder)\n-            })\n+        let mut mir = tls::enter_decoding_context(&dcx, |_| {\n+            Decodable::decode(&mut decoder)\n         }).unwrap();\n \n         assert!(decoder.position() == mir_doc.end);"}, {"sha": "4bc8caf037ae269a463468ab710c0d4a5cf8bee2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 627, "deletions": 678, "changes": 1305, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -21,7 +21,7 @@ use def_key;\n use tyencode;\n use index::{self, IndexData};\n \n-use middle::cstore::{InlinedItemRef, LinkMeta, tls};\n+use middle::cstore::{InlinedItemRef, LinkMeta};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n@@ -38,14 +38,14 @@ use rustc_serialize::Encodable;\n use std::cell::RefCell;\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n+use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n-use errors::Handler;\n use syntax;\n use syntax_pos::BytePos;\n-use rbml::writer::Encoder;\n+use rbml;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::Visitor;\n@@ -55,61 +55,65 @@ use rustc::hir::map::DefKey;\n use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub diag: &'a Handler,\n+    pub rbml_w: rbml::writer::Encoder,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n-    pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n+    pub type_abbrevs: &'a tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n     pub mir_map: &'a MirMap<'tcx>,\n }\n \n-impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n-    fn local_id(&self, def_id: DefId) -> NodeId {\n-        self.tcx.map.as_local_node_id(def_id).unwrap()\n+impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n+    type Target = rbml::writer::Encoder;\n+    fn deref(&self) -> &Self::Target {\n+        &self.rbml_w\n     }\n }\n \n-fn encode_name(rbml_w: &mut Encoder, name: Name) {\n-    rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n+impl<'a, 'tcx> DerefMut for EncodeContext<'a, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.rbml_w\n+    }\n+}\n+\n+fn encode_name(ecx: &mut EncodeContext, name: Name) {\n+    ecx.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n \n-fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n+fn encode_def_id(ecx: &mut EncodeContext, id: DefId) {\n+    ecx.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n-fn encode_def_key(rbml_w: &mut Encoder, key: DefKey) {\n+fn encode_def_key(ecx: &mut EncodeContext, key: DefKey) {\n     let simple_key = def_key::simplify_def_key(key);\n-    rbml_w.start_tag(tag_def_key);\n-    simple_key.encode(rbml_w);\n-    rbml_w.end_tag();\n+    ecx.start_tag(tag_def_key);\n+    simple_key.encode(ecx);\n+    ecx.end_tag();\n }\n \n /// For every DefId that we create a metadata item for, we include a\n /// serialized copy of its DefKey, which allows us to recreate a path.\n-fn encode_def_id_and_key(ecx: &EncodeContext,\n-                         rbml_w: &mut Encoder,\n-                         def_id: DefId)\n-{\n-    encode_def_id(rbml_w, def_id);\n+fn encode_def_id_and_key(ecx: &mut EncodeContext, def_id: DefId) {\n+    encode_def_id(ecx, def_id);\n     let def_key = ecx.tcx.map.def_key(def_id);\n-    encode_def_key(rbml_w, def_key);\n+    encode_def_key(ecx, def_key);\n }\n \n-fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n-                              ecx: &EncodeContext<'a, 'tcx>,\n+fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n                               tag: usize) {\n-    rbml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(rbml_w.writer, &ecx.ty_str_ctxt(), trait_ref);\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n+    let cx = ecx.ty_str_ctxt();\n+    ecx.start_tag(tag);\n+    tyencode::enc_trait_ref(&mut ecx.writer, &cx, trait_ref);\n+    ecx.mark_stable_position();\n+    ecx.end_tag();\n }\n \n // Item info table encoding\n-fn encode_family(rbml_w: &mut Encoder, c: char) {\n-    rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n+fn encode_family(ecx: &mut EncodeContext, c: char) {\n+    ecx.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n pub fn def_to_u64(did: DefId) -> u64 {\n@@ -121,21 +125,18 @@ pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n-fn encode_item_variances(rbml_w: &mut Encoder,\n-                         ecx: &EncodeContext,\n-                         id: NodeId) {\n+fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n     let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n-    rbml_w.start_tag(tag_item_variances);\n-    v.encode(rbml_w);\n-    rbml_w.end_tag();\n+    ecx.start_tag(tag_item_variances);\n+    v.encode(ecx);\n+    ecx.end_tag();\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    fn encode_bounds_and_type_for_item(&mut self,\n-                                       id: NodeId) {\n-        let ecx = self.ecx();\n-        self.encode_bounds_and_type(&ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n-                                    &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+    fn encode_bounds_and_type_for_item(&mut self, def_id: DefId) {\n+        let tcx = self.tcx;\n+        self.encode_bounds_and_type(&tcx.lookup_item_type(def_id),\n+                                    &tcx.lookup_predicates(def_id));\n     }\n \n     fn encode_bounds_and_type(&mut self,\n@@ -146,61 +147,58 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n+fn encode_variant_id(ecx: &mut EncodeContext, vid: DefId) {\n     let id = def_to_u64(vid);\n-    rbml_w.wr_tagged_u64(tag_items_data_item_variant, id);\n-    rbml_w.wr_tagged_u64(tag_mod_child, id);\n+    ecx.wr_tagged_u64(tag_items_data_item_variant, id);\n+    ecx.wr_tagged_u64(tag_mod_child, id);\n }\n \n-fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                            rbml_w: &mut Encoder,\n-                            closure_type: &ty::ClosureTy<'tcx>) {\n-    tyencode::enc_closure_ty(rbml_w.writer, &ecx.ty_str_ctxt(), closure_type);\n-    rbml_w.mark_stable_position();\n+fn write_closure_type<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n+                                closure_type: &ty::ClosureTy<'tcx>) {\n+    let cx = ecx.ty_str_ctxt();\n+    tyencode::enc_closure_ty(&mut ecx.writer, &cx, closure_type);\n+    ecx.mark_stable_position();\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    fn encode_type(&mut self,\n-                   typ: Ty<'tcx>) {\n-        let ecx = self.ecx;\n-        self.rbml_w.start_tag(tag_items_data_item_type);\n-        tyencode::enc_ty(self.rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n-        self.rbml_w.mark_stable_position();\n-        self.rbml_w.end_tag();\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+    fn encode_type(&mut self, typ: Ty<'tcx>) {\n+        let cx = self.ty_str_ctxt();\n+        self.start_tag(tag_items_data_item_type);\n+        tyencode::enc_ty(&mut self.writer, &cx, typ);\n+        self.mark_stable_position();\n+        self.end_tag();\n     }\n \n     fn encode_disr_val(&mut self,\n                        disr_val: ty::Disr) {\n         // convert to u64 so just the number is printed, without any type info\n-        self.rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n+        self.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n     }\n \n     fn encode_parent_item(&mut self, id: DefId) {\n-        self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n+        self.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n     }\n \n     fn encode_struct_fields(&mut self,\n                             variant: ty::VariantDef) {\n         for f in &variant.fields {\n             if variant.kind == ty::VariantKind::Tuple {\n-                self.rbml_w.start_tag(tag_item_unnamed_field);\n+                self.start_tag(tag_item_unnamed_field);\n             } else {\n-                self.rbml_w.start_tag(tag_item_field);\n-                encode_name(self.rbml_w, f.name);\n+                self.start_tag(tag_item_field);\n+                encode_name(self, f.name);\n             }\n             self.encode_struct_field_family(f.vis);\n-            encode_def_id(self.rbml_w, f.did);\n-            self.rbml_w.end_tag();\n+            encode_def_id(self, f.did);\n+            self.end_tag();\n         }\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n-    fn encode_enum_variant_infos(&mut self,\n-                                 enum_did: DefId) {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    fn encode_enum_variant_infos(&mut self, enum_did: DefId) {\n         debug!(\"encode_enum_variant_info(enum_did={:?})\", enum_did);\n-        let ecx = self.ecx();\n-        let def = ecx.tcx.lookup_adt_def(enum_did);\n+        let def = self.tcx.lookup_adt_def(enum_did);\n         self.encode_fields(enum_did);\n         for (i, variant) in def.variants.iter().enumerate() {\n             self.record(variant.did,\n@@ -210,7 +208,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given variant of the given ADT. The\n     /// index of the variant is untracked: this is ok because we\n     /// will have to lookup the adt-def by its id, and that gives us\n@@ -219,42 +217,39 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_enum_variant_info(&mut self,\n                                 (enum_did, Untracked(index)):\n                                 (DefId, Untracked<usize>)) {\n-        let ecx = self.ecx;\n-        let def = ecx.tcx.lookup_adt_def(enum_did);\n+        let tcx = self.tcx;\n+        let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n         let vid = variant.did;\n-        let variant_node_id = ecx.local_id(vid);\n-        encode_def_id_and_key(ecx, self.rbml_w, vid);\n-        encode_family(self.rbml_w, match variant.kind {\n+        encode_def_id_and_key(self, vid);\n+        encode_family(self, match variant.kind {\n             ty::VariantKind::Struct => 'V',\n             ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Unit => 'w',\n         });\n-        encode_name(self.rbml_w, variant.name);\n+        encode_name(self, variant.name);\n         self.encode_parent_item(enum_did);\n \n-        let enum_id = ecx.tcx.map.as_local_node_id(enum_did).unwrap();\n-        let enum_vis = &ecx.tcx.map.expect_item(enum_id).vis;\n+        let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n+        let enum_vis = &tcx.map.expect_item(enum_id).vis;\n         self.encode_visibility(enum_vis);\n \n-        let attrs = ecx.tcx.get_attrs(vid);\n-        encode_attributes(self.rbml_w, &attrs);\n+        let attrs = tcx.get_attrs(vid);\n+        encode_attributes(self, &attrs);\n         self.encode_repr_attrs(&attrs);\n \n-        let stab = ecx.tcx.lookup_stability(vid);\n-        let depr = ecx.tcx.lookup_deprecation(vid);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(vid);\n+        let depr = tcx.lookup_deprecation(vid);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         self.encode_struct_fields(variant);\n         self.encode_disr_val(variant.disr_val);\n-        self.encode_bounds_and_type_for_item(variant_node_id);\n+        self.encode_bounds_and_type_for_item(vid);\n     }\n }\n \n-fn encode_reexports(ecx: &EncodeContext,\n-                    rbml_w: &mut Encoder,\n-                    id: NodeId) {\n+fn encode_reexports(ecx: &mut EncodeContext, id: NodeId) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports.get(&id) {\n         Some(exports) => {\n@@ -265,58 +260,58 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.name,\n                        exp.def_id,\n                        id);\n-                rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n-                                     def_to_u64(exp.def_id));\n-                rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n-                                     &exp.name.as_str());\n-                rbml_w.end_tag();\n+                ecx.start_tag(tag_items_data_item_reexport);\n+                ecx.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                                  def_to_u64(exp.def_id));\n+                ecx.wr_tagged_str(tag_items_data_item_reexport_name,\n+                                  &exp.name.as_str());\n+                ecx.end_tag();\n             }\n         },\n         None => debug!(\"(encoding info for module) found no reexports for {}\", id),\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_mod(&mut self,\n                            FromId(id, (md, attrs, name, vis)):\n                            FromId<(&hir::Mod, &[ast::Attribute], Name, &hir::Visibility)>) {\n-        let ecx = self.ecx();\n+        let tcx = self.tcx;\n \n-        encode_def_id_and_key(ecx, self.rbml_w, ecx.tcx.map.local_def_id(id));\n-        encode_family(self.rbml_w, 'm');\n-        encode_name(self.rbml_w, name);\n+        encode_def_id_and_key(self, tcx.map.local_def_id(id));\n+        encode_family(self, 'm');\n+        encode_name(self, name);\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n         for item_id in &md.item_ids {\n-            self.rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n+            self.wr_tagged_u64(tag_mod_child,\n+                               def_to_u64(tcx.map.local_def_id(item_id.id)));\n         }\n \n         self.encode_visibility(vis);\n \n-        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n-        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(tcx.map.local_def_id(id));\n+        let depr = tcx.lookup_deprecation(tcx.map.local_def_id(id));\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         // Encode the reexports of this module, if this module is public.\n         if *vis == hir::Public {\n             debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-            encode_reexports(ecx, self.rbml_w, id);\n+            encode_reexports(self, id);\n         }\n-        encode_attributes(self.rbml_w, attrs);\n+        encode_attributes(self, attrs);\n     }\n \n     fn encode_struct_field_family(&mut self,\n                                   visibility: ty::Visibility) {\n-        encode_family(self.rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n+        encode_family(self, if visibility.is_public() { 'g' } else { 'N' });\n     }\n \n     fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n         let ch = if visibility.is_public() { 'y' } else { 'i' };\n-        self.rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n+        self.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n     }\n }\n \n@@ -336,43 +331,43 @@ impl HasVisibility for ty::Visibility {\n     }\n }\n \n-fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n-    rbml_w.start_tag(tag_items_data_item_constness);\n+fn encode_constness(ecx: &mut EncodeContext, constness: hir::Constness) {\n+    ecx.start_tag(tag_items_data_item_constness);\n     let ch = match constness {\n         hir::Constness::Const => 'c',\n         hir::Constness::NotConst => 'n',\n     };\n-    rbml_w.wr_str(&ch.to_string());\n-    rbml_w.end_tag();\n+    ecx.wr_str(&ch.to_string());\n+    ecx.end_tag();\n }\n \n-fn encode_defaultness(rbml_w: &mut Encoder, defaultness: hir::Defaultness) {\n+fn encode_defaultness(ecx: &mut EncodeContext, defaultness: hir::Defaultness) {\n     let ch = match defaultness {\n         hir::Defaultness::Default => 'd',\n         hir::Defaultness::Final => 'f',\n     };\n-    rbml_w.wr_tagged_u8(tag_items_data_item_defaultness, ch as u8);\n+    ecx.wr_tagged_u8(tag_items_data_item_defaultness, ch as u8);\n }\n \n-fn encode_explicit_self(rbml_w: &mut Encoder,\n+fn encode_explicit_self(ecx: &mut EncodeContext,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     let tag = tag_item_trait_method_explicit_self;\n \n     // Encode the base self type.\n     match *explicit_self {\n         ty::ExplicitSelfCategory::Static => {\n-            rbml_w.wr_tagged_bytes(tag, &['s' as u8]);\n+            ecx.wr_tagged_bytes(tag, &['s' as u8]);\n         }\n         ty::ExplicitSelfCategory::ByValue => {\n-            rbml_w.wr_tagged_bytes(tag, &['v' as u8]);\n+            ecx.wr_tagged_bytes(tag, &['v' as u8]);\n         }\n         ty::ExplicitSelfCategory::ByBox => {\n-            rbml_w.wr_tagged_bytes(tag, &['~' as u8]);\n+            ecx.wr_tagged_bytes(tag, &['~' as u8]);\n         }\n         ty::ExplicitSelfCategory::ByReference(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n             let ch = encode_mutability(m);\n-            rbml_w.wr_tagged_bytes(tag, &['&' as u8, ch]);\n+            ecx.wr_tagged_bytes(tag, &['&' as u8, ch]);\n         }\n     }\n \n@@ -384,14 +379,14 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     }\n }\n \n-fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n+fn encode_item_sort(ecx: &mut EncodeContext, sort: char) {\n+    ecx.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self,\n                      adt_def_id: DefId) {\n-        let def = self.ecx().tcx.lookup_adt_def(adt_def_id);\n+        let def = self.tcx.lookup_adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n@@ -402,7 +397,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -412,131 +407,120 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_field(&mut self,\n                     (adt_def_id, Untracked((variant_index, field_index))):\n                     (DefId, Untracked<(usize, usize)>)) {\n-        let ecx = self.ecx();\n-        let def = ecx.tcx.lookup_adt_def(adt_def_id);\n+        let tcx = self.tcx;\n+        let def = tcx.lookup_adt_def(adt_def_id);\n         let variant = &def.variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let nm = field.name;\n-        let id = ecx.local_id(field.did);\n-        debug!(\"encode_field: encoding {} {}\", nm, id);\n+        debug!(\"encode_field: encoding {} {:?}\", nm, field.did);\n \n         self.encode_struct_field_family(field.vis);\n-        encode_name(self.rbml_w, nm);\n-        self.encode_bounds_and_type_for_item(id);\n-        encode_def_id_and_key(ecx, self.rbml_w, field.did);\n+        encode_name(self, nm);\n+        self.encode_bounds_and_type_for_item(field.did);\n+        encode_def_id_and_key(self, field.did);\n \n-        let stab = ecx.tcx.lookup_stability(field.did);\n-        let depr = ecx.tcx.lookup_deprecation(field.did);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(field.did);\n+        let depr = tcx.lookup_deprecation(field.did);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n     }\n-}\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_struct_ctor(&mut self,\n                           (struct_def_id, struct_node_id, ctor_node_id):\n                           (DefId, ast::NodeId, ast::NodeId)) {\n-        let ecx = self.ecx();\n-        let def = ecx.tcx.lookup_adt_def(struct_def_id);\n+        let tcx = self.tcx;\n+        let def = tcx.lookup_adt_def(struct_def_id);\n         let variant = def.struct_variant();\n-        let item = ecx.tcx.map.expect_item(struct_node_id);\n-        let ctor_def_id = ecx.tcx.map.local_def_id(ctor_node_id);\n-        encode_def_id_and_key(ecx, self.rbml_w, ctor_def_id);\n-        encode_family(self.rbml_w, match variant.kind {\n+        let item = tcx.map.expect_item(struct_node_id);\n+        let ctor_def_id = tcx.map.local_def_id(ctor_node_id);\n+        encode_def_id_and_key(self, ctor_def_id);\n+        encode_family(self, match variant.kind {\n             ty::VariantKind::Struct => 'S',\n             ty::VariantKind::Tuple => 's',\n             ty::VariantKind::Unit => 'u',\n         });\n-        self.encode_bounds_and_type_for_item(ctor_node_id);\n-        encode_name(self.rbml_w, item.name);\n+        self.encode_bounds_and_type_for_item(ctor_def_id);\n+        encode_name(self, item.name);\n         self.encode_parent_item(struct_def_id);\n \n-        let stab = ecx.tcx.lookup_stability(ctor_def_id);\n-        let depr = ecx.tcx.lookup_deprecation(ctor_def_id);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(ctor_def_id);\n+        let depr = tcx.lookup_deprecation(ctor_def_id);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         // indicate that this is a tuple struct ctor, because\n         // downstream users will normally want the tuple struct\n         // definition, but without this there is no way for them\n         // to tell that they actually have a ctor rather than a\n         // normal function\n-        self.rbml_w.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n+        self.wr_tagged_bytes(tag_items_data_item_is_tuple_struct_ctor, &[]);\n     }\n-}\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_generics(&mut self,\n                        generics: &ty::Generics<'tcx>,\n                        predicates: &ty::GenericPredicates<'tcx>)\n     {\n-        let ecx = self.ecx();\n-        self.rbml_w.start_tag(tag_item_generics);\n-        tyencode::enc_generics(self.rbml_w.writer, &ecx.ty_str_ctxt(), generics);\n-        self.rbml_w.mark_stable_position();\n-        self.rbml_w.end_tag();\n+        let cx = self.ty_str_ctxt();\n+        self.start_tag(tag_item_generics);\n+        tyencode::enc_generics(&mut self.writer, &cx, generics);\n+        self.mark_stable_position();\n+        self.end_tag();\n         self.encode_predicates(predicates, tag_item_predicates);\n     }\n \n     fn encode_predicates(&mut self,\n                          predicates: &ty::GenericPredicates<'tcx>,\n                          tag: usize) {\n-        self.rbml_w.start_tag(tag);\n+        self.start_tag(tag);\n         if let Some(def_id) = predicates.parent {\n-            self.rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+            self.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n         }\n         for predicate in &predicates.predicates {\n             let xref = self.add_xref(XRef::Predicate(predicate.clone()));\n-            self.rbml_w.wr_tagged_u32(tag_predicate, xref);\n+            self.wr_tagged_u32(tag_predicate, xref);\n         }\n-        self.rbml_w.end_tag();\n+        self.end_tag();\n     }\n \n-    fn encode_method_ty_fields(&mut self,\n-                               method_ty: &ty::Method<'tcx>) {\n-        let ecx = self.ecx();\n-        encode_def_id_and_key(ecx, self.rbml_w, method_ty.def_id);\n-        encode_name(self.rbml_w, method_ty.name);\n+    fn encode_method_ty_fields(&mut self, method_ty: &ty::Method<'tcx>) {\n+        encode_def_id_and_key(self, method_ty.def_id);\n+        encode_name(self, method_ty.name);\n         self.encode_generics(&method_ty.generics, &method_ty.predicates);\n         self.encode_visibility(method_ty.vis);\n-        encode_explicit_self(self.rbml_w, &method_ty.explicit_self);\n+        encode_explicit_self(self, &method_ty.explicit_self);\n         match method_ty.explicit_self {\n             ty::ExplicitSelfCategory::Static => {\n-                encode_family(self.rbml_w, STATIC_METHOD_FAMILY);\n+                encode_family(self, STATIC_METHOD_FAMILY);\n             }\n-            _ => encode_family(self.rbml_w, METHOD_FAMILY)\n+            _ => encode_family(self, METHOD_FAMILY)\n         }\n     }\n-}\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_trait_item(&mut self,\n                                   (trait_def_id, item_def_id, trait_item):\n                                   (DefId, DefId, &hir::TraitItem)) {\n-        let ecx = self.ecx;\n-        let tcx = ecx.tcx;\n+        let tcx = self.tcx;\n \n         self.encode_parent_item(trait_def_id);\n \n         let stab = tcx.lookup_stability(item_def_id);\n         let depr = tcx.lookup_deprecation(item_def_id);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         let trait_item_type =\n             tcx.impl_or_trait_item(item_def_id);\n         let is_nonstatic_method;\n         match trait_item_type {\n             ty::ConstTraitItem(associated_const) => {\n-                encode_name(self.rbml_w, associated_const.name);\n-                encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n+                encode_name(self, associated_const.name);\n+                encode_def_id_and_key(self, associated_const.def_id);\n                 self.encode_visibility(associated_const.vis);\n \n-                encode_family(self.rbml_w, 'C');\n+                encode_family(self, 'C');\n \n-                self.encode_bounds_and_type_for_item(\n-                    ecx.local_id(associated_const.def_id));\n+                self.encode_bounds_and_type_for_item(associated_const.def_id);\n \n                 is_nonstatic_method = false;\n             }\n@@ -547,24 +531,22 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n                 match method_ty.explicit_self {\n                     ty::ExplicitSelfCategory::Static => {\n-                        encode_family(self.rbml_w,\n-                                      STATIC_METHOD_FAMILY);\n+                        encode_family(self, STATIC_METHOD_FAMILY);\n                     }\n                     _ => {\n-                        encode_family(self.rbml_w,\n-                                      METHOD_FAMILY);\n+                        encode_family(self, METHOD_FAMILY);\n                     }\n                 }\n-                self.encode_bounds_and_type_for_item(ecx.local_id(method_def_id));\n+                self.encode_bounds_and_type_for_item(method_def_id);\n \n                 is_nonstatic_method = method_ty.explicit_self !=\n                     ty::ExplicitSelfCategory::Static;\n             }\n             ty::TypeTraitItem(associated_type) => {\n-                encode_name(self.rbml_w, associated_type.name);\n-                encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n-                encode_item_sort(self.rbml_w, 't');\n-                encode_family(self.rbml_w, 'y');\n+                encode_name(self, associated_type.name);\n+                encode_def_id_and_key(self, associated_type.def_id);\n+                encode_item_sort(self, 't');\n+                encode_family(self, 'y');\n \n                 if let Some(ty) = associated_type.ty {\n                     self.encode_type(ty);\n@@ -574,32 +556,31 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n             }\n         }\n \n-        encode_attributes(self.rbml_w, &trait_item.attrs);\n+        encode_attributes(self, &trait_item.attrs);\n         match trait_item.node {\n             hir::ConstTraitItem(_, ref default) => {\n                 if default.is_some() {\n-                    encode_item_sort(self.rbml_w, 'C');\n+                    encode_item_sort(self, 'C');\n                 } else {\n-                    encode_item_sort(self.rbml_w, 'c');\n+                    encode_item_sort(self, 'c');\n                 }\n \n-                encode_inlined_item(ecx, self.rbml_w,\n+                encode_inlined_item(self,\n                                     InlinedItemRef::TraitItem(trait_def_id, trait_item));\n-                self.encode_mir(trait_item.id);\n+                self.encode_mir(item_def_id);\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 // If this is a static method, we've already\n                 // encoded self.\n                 if is_nonstatic_method {\n-                    self.encode_bounds_and_type_for_item(\n-                        ecx.local_id(item_def_id));\n+                    self.encode_bounds_and_type_for_item(item_def_id);\n                 }\n \n                 if body.is_some() {\n-                    encode_item_sort(self.rbml_w, 'p');\n-                    self.encode_mir(trait_item.id);\n+                    encode_item_sort(self, 'p');\n+                    self.encode_mir(item_def_id);\n                 } else {\n-                    encode_item_sort(self.rbml_w, 'r');\n+                    encode_item_sort(self, 'r');\n                 }\n                 self.encode_method_argument_names(&sig.decl);\n             }\n@@ -611,7 +592,7 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_impl_item(&mut self,\n                                  (impl_id, impl_item_def_id, ast_item):\n                                  (NodeId, DefId, Option<&hir::ImplItem>)) {\n-        match self.ecx.tcx.impl_or_trait_item(impl_item_def_id) {\n+        match self.tcx.impl_or_trait_item(impl_item_def_id) {\n             ty::ConstTraitItem(ref associated_const) => {\n                 self.encode_info_for_associated_const(&associated_const,\n                                                       impl_id,\n@@ -635,34 +616,33 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                                         associated_const: &ty::AssociatedConst,\n                                         parent_id: NodeId,\n                                         impl_item_opt: Option<&hir::ImplItem>) {\n-        let ecx = self.ecx();\n+        let tcx = self.tcx;\n         debug!(\"encode_info_for_associated_const({:?},{:?})\",\n                associated_const.def_id,\n                associated_const.name);\n \n-        encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n-        encode_name(self.rbml_w, associated_const.name);\n+        encode_def_id_and_key(self, associated_const.def_id);\n+        encode_name(self, associated_const.name);\n         self.encode_visibility(associated_const.vis);\n-        encode_family(self.rbml_w, 'C');\n+        encode_family(self, 'C');\n \n-        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self.rbml_w, 'C');\n+        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self, 'C');\n \n-        self.encode_bounds_and_type_for_item(ecx.local_id(associated_const.def_id));\n+        self.encode_bounds_and_type_for_item(associated_const.def_id);\n \n-        let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(associated_const.def_id);\n+        let depr = tcx.lookup_deprecation(associated_const.def_id);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         if let Some(ii) = impl_item_opt {\n-            encode_attributes(self.rbml_w, &ii.attrs);\n-            encode_defaultness(self.rbml_w, ii.defaultness);\n-            encode_inlined_item(ecx,\n-                                self.rbml_w,\n-                                InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+            encode_attributes(self, &ii.attrs);\n+            encode_defaultness(self, ii.defaultness);\n+            encode_inlined_item(self,\n+                                InlinedItemRef::ImplItem(tcx.map.local_def_id(parent_id),\n                                                          ii));\n-            self.encode_mir(ii.id);\n+            self.encode_mir(associated_const.def_id);\n         }\n     }\n \n@@ -671,41 +651,39 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                               is_default_impl: bool,\n                               parent_id: NodeId,\n                               impl_item_opt: Option<&hir::ImplItem>) {\n-        let ecx = self.ecx();\n+        let tcx = self.tcx;\n \n         debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n                m.name);\n         self.encode_method_ty_fields(m);\n-        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self.rbml_w, 'r');\n+        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self, 'r');\n \n-        let stab = ecx.tcx.lookup_stability(m.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(m.def_id);\n+        let depr = tcx.lookup_deprecation(m.def_id);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n-        let m_node_id = ecx.local_id(m.def_id);\n-        self.encode_bounds_and_type_for_item(m_node_id);\n+        self.encode_bounds_and_type_for_item(m.def_id);\n \n         if let Some(impl_item) = impl_item_opt {\n             if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                encode_attributes(self.rbml_w, &impl_item.attrs);\n-                let generics = ecx.tcx.lookup_generics(m.def_id);\n+                encode_attributes(self, &impl_item.attrs);\n+                let generics = tcx.lookup_generics(m.def_id);\n                 let types = generics.parent_types as usize + generics.types.len();\n                 let needs_inline = types > 0 || is_default_impl ||\n                     attr::requests_inline(&impl_item.attrs);\n                 if sig.constness == hir::Constness::Const {\n                     encode_inlined_item(\n-                        ecx,\n-                        self.rbml_w,\n-                        InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                        self,\n+                        InlinedItemRef::ImplItem(tcx.map.local_def_id(parent_id),\n                                                  impl_item));\n                 }\n                 if needs_inline || sig.constness == hir::Constness::Const {\n-                    self.encode_mir(impl_item.id);\n+                    self.encode_mir(m.def_id);\n                 }\n-                encode_constness(self.rbml_w, sig.constness);\n-                encode_defaultness(self.rbml_w, impl_item.defaultness);\n+                encode_constness(self, sig.constness);\n+                encode_defaultness(self, impl_item.defaultness);\n                 self.encode_method_argument_names(&sig.decl);\n             }\n         }\n@@ -715,74 +693,65 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                                        associated_type: &ty::AssociatedType<'tcx>,\n                                        parent_id: NodeId,\n                                        impl_item_opt: Option<&hir::ImplItem>) {\n-        let ecx = self.ecx();\n+        let tcx = self.tcx;\n         debug!(\"encode_info_for_associated_type({:?},{:?})\",\n                associated_type.def_id,\n                associated_type.name);\n \n-        encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n-        encode_name(self.rbml_w, associated_type.name);\n+        encode_def_id_and_key(self, associated_type.def_id);\n+        encode_name(self, associated_type.name);\n         self.encode_visibility(associated_type.vis);\n-        encode_family(self.rbml_w, 'y');\n-        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-        encode_item_sort(self.rbml_w, 't');\n+        encode_family(self, 'y');\n+        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self, 't');\n \n-        let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n-        let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-        encode_stability(self.rbml_w, stab);\n-        encode_deprecation(self.rbml_w, depr);\n+        let stab = tcx.lookup_stability(associated_type.def_id);\n+        let depr = tcx.lookup_deprecation(associated_type.def_id);\n+        encode_stability(self, stab);\n+        encode_deprecation(self, depr);\n \n         if let Some(ii) = impl_item_opt {\n-            encode_attributes(self.rbml_w, &ii.attrs);\n-            encode_defaultness(self.rbml_w, ii.defaultness);\n+            encode_attributes(self, &ii.attrs);\n+            encode_defaultness(self, ii.defaultness);\n         }\n \n         if let Some(ty) = associated_type.ty {\n             self.encode_type(ty);\n         }\n     }\n-}\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_method_argument_names(&mut self,\n                                     decl: &hir::FnDecl) {\n-        self.rbml_w.start_tag(tag_method_argument_names);\n+        self.start_tag(tag_method_argument_names);\n         for arg in &decl.inputs {\n             let tag = tag_method_argument_name;\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 let name = path1.node.as_str();\n-                self.rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n+                self.wr_tagged_bytes(tag, name.as_bytes());\n             } else {\n-                self.rbml_w.wr_tagged_bytes(tag, &[]);\n+                self.wr_tagged_bytes(tag, &[]);\n             }\n         }\n-        self.rbml_w.end_tag();\n+        self.end_tag();\n     }\n \n     fn encode_repr_attrs(&mut self,\n                          attrs: &[ast::Attribute]) {\n-        let ecx = self.ecx();\n         let mut repr_attrs = Vec::new();\n         for attr in attrs {\n-            repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n+            repr_attrs.extend(attr::find_repr_attrs(self.tcx.sess.diagnostic(),\n                                                     attr));\n         }\n-        self.rbml_w.start_tag(tag_items_data_item_repr);\n-        repr_attrs.encode(self.rbml_w);\n-        self.rbml_w.end_tag();\n-    }\n-\n-    fn encode_mir(&mut self, node_id: NodeId) {\n-        let ecx = self.ecx();\n-        let def_id = ecx.tcx.map.local_def_id(node_id);\n-        if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n-            self.rbml_w.start_tag(tag_mir as usize);\n-            self.rbml_w.emit_opaque(|opaque_encoder| {\n-                tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n-                    Encodable::encode(mir, opaque_encoder)\n-                })\n-            }).unwrap();\n-            self.rbml_w.end_tag();\n+        self.start_tag(tag_items_data_item_repr);\n+        repr_attrs.encode(self.ecx);\n+        self.end_tag();\n+    }\n+\n+    fn encode_mir(&mut self, def_id: DefId) {\n+        if let Some(mir) = self.mir_map.map.get(&def_id) {\n+            self.start_tag(tag_mir as usize);\n+            mir.encode(self.ecx);\n+            self.end_tag();\n         }\n     }\n }\n@@ -792,198 +761,196 @@ const STATIC_METHOD_FAMILY: char = 'F';\n const METHOD_FAMILY: char = 'h';\n \n // Encodes the inherent implementations of a structure, enumeration, or trait.\n-fn encode_inherent_implementations(ecx: &EncodeContext,\n-                                   rbml_w: &mut Encoder,\n+fn encode_inherent_implementations(ecx: &mut EncodeContext,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.iter() {\n-                rbml_w.start_tag(tag_items_data_item_inherent_impl);\n-                encode_def_id(rbml_w, impl_def_id);\n-                rbml_w.end_tag();\n+                ecx.start_tag(tag_items_data_item_inherent_impl);\n+                encode_def_id(ecx, impl_def_id);\n+                ecx.end_tag();\n             }\n         }\n     }\n }\n \n-fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n+fn encode_stability(ecx: &mut EncodeContext, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n-        rbml_w.start_tag(tag_items_data_item_stability);\n-        stab.encode(rbml_w).unwrap();\n-        rbml_w.end_tag();\n+        ecx.start_tag(tag_items_data_item_stability);\n+        stab.encode(ecx).unwrap();\n+        ecx.end_tag();\n     });\n }\n \n-fn encode_deprecation(rbml_w: &mut Encoder, depr_opt: Option<attr::Deprecation>) {\n+fn encode_deprecation(ecx: &mut EncodeContext, depr_opt: Option<attr::Deprecation>) {\n     depr_opt.map(|depr| {\n-        rbml_w.start_tag(tag_items_data_item_deprecation);\n-        depr.encode(rbml_w).unwrap();\n-        rbml_w.end_tag();\n+        ecx.start_tag(tag_items_data_item_deprecation);\n+        depr.encode(ecx).unwrap();\n+        ecx.end_tag();\n     });\n }\n \n-fn encode_parent_impl(rbml_w: &mut Encoder, parent_opt: Option<DefId>) {\n+fn encode_parent_impl(ecx: &mut EncodeContext, parent_opt: Option<DefId>) {\n     parent_opt.map(|parent| {\n-        rbml_w.wr_tagged_u64(tag_items_data_parent_impl, def_to_u64(parent));\n+        ecx.wr_tagged_u64(tag_items_data_parent_impl, def_to_u64(parent));\n     });\n }\n \n-fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                          rbml_w: &mut Encoder,\n+fn encode_xrefs<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n {\n     let mut xref_positions = vec![0; xrefs.len()];\n+    let cx = ecx.ty_str_ctxt();\n \n     // Encode XRefs sorted by their ID\n     let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n     sorted_xrefs.sort_by_key(|&(_, id)| id);\n \n-    rbml_w.start_tag(tag_xref_data);\n+    ecx.start_tag(tag_xref_data);\n     for (xref, id) in sorted_xrefs.into_iter() {\n-        xref_positions[id as usize] = rbml_w.mark_stable_position() as u32;\n+        xref_positions[id as usize] = ecx.mark_stable_position() as u32;\n         match xref {\n             XRef::Predicate(p) => {\n-                tyencode::enc_predicate(rbml_w.writer, &ecx.ty_str_ctxt(), &p)\n+                tyencode::enc_predicate(&mut ecx.writer, &cx, &p)\n             }\n         }\n     }\n-    rbml_w.mark_stable_position();\n-    rbml_w.end_tag();\n+    ecx.mark_stable_position();\n+    ecx.end_tag();\n \n-    rbml_w.start_tag(tag_xref_index);\n-    index::write_dense_index(xref_positions, rbml_w.writer);\n-    rbml_w.end_tag();\n+    ecx.start_tag(tag_xref_index);\n+    index::write_dense_index(xref_positions, &mut ecx.writer);\n+    ecx.end_tag();\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_item(&mut self,\n                             (def_id, item): (DefId, &hir::Item)) {\n-        let ecx = self.ecx();\n-        let tcx = ecx.tcx;\n+        let tcx = self.tcx;\n \n         debug!(\"encoding info for item at {}\",\n                tcx.sess.codemap().span_to_string(item.span));\n \n         let vis = &item.vis;\n \n         let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n-            (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n-             tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id)))\n+            (tcx.lookup_stability(tcx.map.local_def_id(item.id)),\n+             tcx.lookup_deprecation(tcx.map.local_def_id(item.id)))\n         });\n \n         match item.node {\n             hir::ItemStatic(_, m, _) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_def_id_and_key(self, def_id);\n                 if m == hir::MutMutable {\n-                    encode_family(self.rbml_w, 'b');\n+                    encode_family(self, 'b');\n                 } else {\n-                    encode_family(self.rbml_w, 'c');\n+                    encode_family(self, 'c');\n                 }\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n-                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n+                encode_attributes(self, &item.attrs);\n             }\n             hir::ItemConst(..) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'C');\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'C');\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n+                encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(def_id);\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, FN_FAMILY);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, FN_FAMILY);\n                 let tps_len = generics.ty_params.len();\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n                 let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n                 if constness == hir::Constness::Const {\n-                    encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n                 }\n                 if needs_inline || constness == hir::Constness::Const {\n-                    self.encode_mir(item.id);\n+                    self.encode_mir(def_id);\n                 }\n-                encode_constness(self.rbml_w, constness);\n+                encode_constness(self, constness);\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n                 self.encode_method_argument_names(&decl);\n             }\n             hir::ItemMod(ref m) => {\n                 self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, item.name, &item.vis)));\n             }\n             hir::ItemForeignMod(ref fm) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'n');\n-                encode_name(self.rbml_w, item.name);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'n');\n+                encode_name(self, item.name);\n \n                 // Encode all the items in self module.\n                 for foreign_item in &fm.items {\n-                    self.rbml_w.wr_tagged_u64(\n+                    self.wr_tagged_u64(\n                         tag_mod_child,\n-                        def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n+                        def_to_u64(tcx.map.local_def_id(foreign_item.id)));\n                 }\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n             }\n             hir::ItemTy(..) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'y');\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'y');\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 't');\n-                encode_item_variances(self.rbml_w, ecx, item.id);\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 't');\n+                encode_item_variances(self, item.id);\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n                 self.encode_repr_attrs(&item.attrs);\n                 for v in &enum_definition.variants {\n-                    encode_variant_id(self.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n+                    encode_variant_id(self, tcx.map.local_def_id(v.node.data.id()));\n                 }\n \n                 // Encode inherent implementations for self enumeration.\n-                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+                encode_inherent_implementations(self, def_id);\n \n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 /* Index the class*/\n-                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let def = tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n                 /* Now, make an item for the class itself */\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, match *struct_def {\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, match *struct_def {\n                     hir::VariantData::Struct(..) => 'S',\n                     hir::VariantData::Tuple(..) => 's',\n                     hir::VariantData::Unit(..) => 'u',\n                 });\n-                self.encode_bounds_and_type_for_item(item.id);\n+                self.encode_bounds_and_type_for_item(def_id);\n \n-                encode_item_variances(self.rbml_w, ecx, item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_item_variances(self, item.id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n                 self.encode_visibility(vis);\n                 self.encode_repr_attrs(&item.attrs);\n \n@@ -993,27 +960,27 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 self.encode_struct_fields(variant);\n \n                 // Encode inherent implementations for self structure.\n-                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+                encode_inherent_implementations(self, def_id);\n \n                 if !struct_def.is_struct() {\n-                    let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-                    self.rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                              def_to_u64(ctor_did));\n+                    let ctor_did = tcx.map.local_def_id(struct_def.id());\n+                    self.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                       def_to_u64(ctor_did));\n                 }\n             }\n             hir::ItemUnion(..) => {\n-                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let def = self.tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'U');\n-                self.encode_bounds_and_type_for_item(item.id);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'U');\n+                self.encode_bounds_and_type_for_item(def_id);\n \n-                encode_item_variances(self.rbml_w, ecx, item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_item_variances(self, item.id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n                 self.encode_visibility(vis);\n                 self.encode_repr_attrs(&item.attrs);\n \n@@ -1022,70 +989,70 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 needs to know*/\n                 self.encode_struct_fields(variant);\n \n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n+                encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(def_id);\n \n                 // Encode inherent implementations for self union.\n-                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+                encode_inherent_implementations(self, def_id);\n             }\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'd');\n-                encode_name(self.rbml_w, item.name);\n-                encode_unsafety(self.rbml_w, unsafety);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'd');\n+                encode_name(self, item.name);\n+                encode_unsafety(self, unsafety);\n \n-                let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-                encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(item.id)).unwrap();\n+                encode_trait_ref(self, trait_ref, tag_item_trait_ref);\n             }\n             hir::ItemImpl(unsafety, polarity, ..) => {\n                 // We need to encode information about the default methods we\n                 // have inherited, so we drive self based on the impl structure.\n                 let impl_items = tcx.impl_items.borrow();\n                 let items = &impl_items[&def_id];\n \n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'i');\n-                self.encode_bounds_and_type_for_item(item.id);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n-                encode_unsafety(self.rbml_w, unsafety);\n-                encode_polarity(self.rbml_w, polarity);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'i');\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n+                encode_unsafety(self, unsafety);\n+                encode_polarity(self, polarity);\n \n                 match\n                     tcx.custom_coerce_unsized_kinds\n                        .borrow()\n-                       .get(&ecx.tcx.map.local_def_id(item.id))\n+                       .get(&tcx.map.local_def_id(item.id))\n                 {\n                     Some(&kind) => {\n-                        self.rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                        kind.encode(self.rbml_w);\n-                        self.rbml_w.end_tag();\n+                        self.start_tag(tag_impl_coerce_unsized_kind);\n+                        kind.encode(self.ecx);\n+                        self.end_tag();\n                     }\n                     None => {}\n                 }\n \n                 for &item_def_id in items {\n-                    self.rbml_w.start_tag(tag_item_impl_item);\n+                    self.start_tag(tag_item_impl_item);\n                     match item_def_id {\n                         ty::ConstTraitItemId(item_def_id) => {\n-                            encode_def_id(self.rbml_w, item_def_id);\n-                            encode_item_sort(self.rbml_w, 'C');\n+                            encode_def_id(self, item_def_id);\n+                            encode_item_sort(self, 'C');\n                         }\n                         ty::MethodTraitItemId(item_def_id) => {\n-                            encode_def_id(self.rbml_w, item_def_id);\n-                            encode_item_sort(self.rbml_w, 'r');\n+                            encode_def_id(self, item_def_id);\n+                            encode_item_sort(self, 'r');\n                         }\n                         ty::TypeTraitItemId(item_def_id) => {\n-                            encode_def_id(self.rbml_w, item_def_id);\n-                            encode_item_sort(self.rbml_w, 't');\n+                            encode_def_id(self, item_def_id);\n+                            encode_item_sort(self, 't');\n                         }\n                     }\n-                    self.rbml_w.end_tag();\n+                    self.end_tag();\n                 }\n \n-                let did = ecx.tcx.map.local_def_id(item.id);\n+                let did = tcx.map.local_def_id(item.id);\n                 if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                    encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+                    encode_trait_ref(self, trait_ref, tag_item_trait_ref);\n \n                     let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n                     let parent = trait_def.ancestors(did)\n@@ -1096,54 +1063,54 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                                                   Some(parent),\n                                               _ => None,\n                                           });\n-                    encode_parent_impl(self.rbml_w, parent);\n+                    encode_parent_impl(self, parent);\n                 }\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n             }\n             hir::ItemTrait(..) => {\n-                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-                encode_family(self.rbml_w, 'I');\n-                encode_item_variances(self.rbml_w, ecx, item.id);\n+                encode_def_id_and_key(self, def_id);\n+                encode_family(self, 'I');\n+                encode_item_variances(self, item.id);\n                 let trait_def = tcx.lookup_trait_def(def_id);\n                 let trait_predicates = tcx.lookup_predicates(def_id);\n-                encode_unsafety(self.rbml_w, trait_def.unsafety);\n-                encode_paren_sugar(self.rbml_w, trait_def.paren_sugar);\n-                encode_defaulted(self.rbml_w, tcx.trait_has_default_impl(def_id));\n-                encode_associated_type_names(self.rbml_w, &trait_def.associated_type_names);\n+                encode_unsafety(self, trait_def.unsafety);\n+                encode_paren_sugar(self, trait_def.paren_sugar);\n+                encode_defaulted(self, tcx.trait_has_default_impl(def_id));\n+                encode_associated_type_names(self, &trait_def.associated_type_names);\n                 self.encode_generics(&trait_def.generics, &trait_predicates);\n                 self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n                                        tag_item_super_predicates);\n-                encode_trait_ref(self.rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-                encode_name(self.rbml_w, item.name);\n-                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_trait_ref(self, trait_def.trait_ref, tag_item_trait_ref);\n+                encode_name(self, item.name);\n+                encode_attributes(self, &item.attrs);\n                 self.encode_visibility(vis);\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n                 for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-                    self.rbml_w.start_tag(tag_item_trait_item);\n+                    self.start_tag(tag_item_trait_item);\n                     match method_def_id {\n                         ty::ConstTraitItemId(const_def_id) => {\n-                            encode_def_id(self.rbml_w, const_def_id);\n-                            encode_item_sort(self.rbml_w, 'C');\n+                            encode_def_id(self, const_def_id);\n+                            encode_item_sort(self, 'C');\n                         }\n                         ty::MethodTraitItemId(method_def_id) => {\n-                            encode_def_id(self.rbml_w, method_def_id);\n-                            encode_item_sort(self.rbml_w, 'r');\n+                            encode_def_id(self, method_def_id);\n+                            encode_item_sort(self, 'r');\n                         }\n                         ty::TypeTraitItemId(type_def_id) => {\n-                            encode_def_id(self.rbml_w, type_def_id);\n-                            encode_item_sort(self.rbml_w, 't');\n+                            encode_def_id(self, type_def_id);\n+                            encode_item_sort(self, 't');\n                         }\n                     }\n-                    self.rbml_w.end_tag();\n+                    self.end_tag();\n \n-                    self.rbml_w.wr_tagged_u64(tag_mod_child,\n-                                              def_to_u64(method_def_id.def_id()));\n+                    self.wr_tagged_u64(tag_mod_child,\n+                                       def_to_u64(method_def_id.def_id()));\n                 }\n \n                 // Encode inherent implementations for self trait.\n-                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+                encode_inherent_implementations(self, def_id);\n             }\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n@@ -1152,14 +1119,14 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// In some cases, along with the item itself, we also\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self,\n                                  item: &hir::Item) {\n-        let def_id = self.ecx().tcx.map.local_def_id(item.id);\n+        let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) |\n@@ -1194,8 +1161,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                                def_id: DefId,\n                                struct_node_id: ast::NodeId,\n                                item: &hir::Item) {\n-        let ecx = self.ecx();\n-        let def = ecx.tcx.lookup_adt_def(def_id);\n+        let def = self.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n         self.encode_fields(def_id);\n@@ -1208,7 +1174,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n                 // there is a value for structs like `struct\n                 // Foo()` and `struct Foo`\n-                let ctor_def_id = ecx.tcx.map.local_def_id(struct_node_id);\n+                let ctor_def_id = self.tcx.map.local_def_id(struct_node_id);\n                 self.record(ctor_def_id,\n                             ItemContentBuilder::encode_struct_ctor,\n                             (def_id, item.id, struct_node_id));\n@@ -1224,8 +1190,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                              def_id: DefId,\n                              impl_id: ast::NodeId,\n                              ast_items: &[hir::ImplItem]) {\n-        let ecx = self.ecx();\n-        let impl_items = ecx.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_items.borrow();\n         let items = &impl_items[&def_id];\n \n         // Iterate down the trait items, emitting them. We rely on the\n@@ -1251,7 +1216,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                               def_id: DefId,\n                               trait_items: &[hir::TraitItem]) {\n         // Now output the trait item info for each trait item.\n-        let tcx = self.ecx().tcx;\n+        let tcx = self.tcx;\n         let r = tcx.trait_item_def_ids(def_id);\n         for (item_def_id, trait_item) in r.iter().zip(trait_items) {\n             let item_def_id = item_def_id.def_id();\n@@ -1263,59 +1228,59 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_foreign_item(&mut self,\n                                     (def_id, nitem): (DefId, &hir::ForeignItem)) {\n-        let ecx = self.ecx();\n+        let tcx = self.tcx;\n \n-        debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n+        debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n \n-        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-        let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_def_id_and_key(self, def_id);\n+        let parent_id = tcx.map.get_parent(nitem.id);\n+        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n         self.encode_visibility(&nitem.vis);\n         match nitem.node {\n             hir::ForeignItemFn(ref fndecl, _) => {\n-                encode_family(self.rbml_w, FN_FAMILY);\n-                self.encode_bounds_and_type_for_item(nitem.id);\n-                encode_name(self.rbml_w, nitem.name);\n-                encode_attributes(self.rbml_w, &nitem.attrs);\n-                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n+                encode_family(self, FN_FAMILY);\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_name(self, nitem.name);\n+                encode_attributes(self, &nitem.attrs);\n+                let stab = tcx.lookup_stability(tcx.map.local_def_id(nitem.id));\n+                let depr = tcx.lookup_deprecation(tcx.map.local_def_id(nitem.id));\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n                 self.encode_method_argument_names(&fndecl);\n             }\n             hir::ForeignItemStatic(_, mutbl) => {\n                 if mutbl {\n-                    encode_family(self.rbml_w, 'b');\n+                    encode_family(self, 'b');\n                 } else {\n-                    encode_family(self.rbml_w, 'c');\n+                    encode_family(self, 'c');\n                 }\n-                self.encode_bounds_and_type_for_item(nitem.id);\n-                encode_attributes(self.rbml_w, &nitem.attrs);\n-                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                encode_stability(self.rbml_w, stab);\n-                encode_deprecation(self.rbml_w, depr);\n-                encode_name(self.rbml_w, nitem.name);\n+                self.encode_bounds_and_type_for_item(def_id);\n+                encode_attributes(self, &nitem.attrs);\n+                let stab = tcx.lookup_stability(tcx.map.local_def_id(nitem.id));\n+                let depr = tcx.lookup_deprecation(tcx.map.local_def_id(nitem.id));\n+                encode_stability(self, stab);\n+                encode_deprecation(self, depr);\n+                encode_name(self, nitem.name);\n             }\n         }\n     }\n }\n \n-struct EncodeVisitor<'a, 'ecx: 'a, 'tcx: 'ecx, 'encoder: 'ecx> {\n-    index: &'a mut IndexBuilder<'ecx, 'tcx, 'encoder>,\n+struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    index: IndexBuilder<'a, 'b, 'tcx>,\n }\n \n-impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n         self.index.encode_info_for_expr(ex);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.ecx().tcx.map.local_def_id(item.id);\n+        let def_id = self.index.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n             _ => self.index.record(def_id,\n@@ -1326,7 +1291,7 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.ecx().tcx.map.local_def_id(ni.id);\n+        let def_id = self.index.tcx.map.local_def_id(ni.id);\n         self.index.record(def_id,\n                           ItemContentBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));\n@@ -1337,135 +1302,130 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        let ecx = self.ecx();\n         if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = ecx.tcx.map.local_def_id(ty.id);\n+            let def_id = self.tcx.map.local_def_id(ty.id);\n             self.record(def_id,\n                         ItemContentBuilder::encode_info_for_anon_ty,\n-                        (def_id, ty.id));\n+                        def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n-        let ecx = self.ecx();\n-\n         match expr.node {\n             hir::ExprClosure(..) => {\n-                let def_id = ecx.tcx.map.local_def_id(expr.id);\n+                let def_id = self.tcx.map.local_def_id(expr.id);\n                 self.record(def_id,\n                             ItemContentBuilder::encode_info_for_closure,\n-                            (def_id, expr.id));\n+                            def_id);\n             }\n             _ => { }\n         }\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    fn encode_info_for_anon_ty(&mut self, (def_id, ty_id): (DefId, NodeId)) {\n-        let ecx = self.ecx;\n-        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-        encode_family(self.rbml_w, 'y');\n-        self.encode_bounds_and_type_for_item(ty_id);\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n+    fn encode_info_for_anon_ty(&mut self, def_id: DefId) {\n+        encode_def_id_and_key(self, def_id);\n+        encode_family(self, 'y');\n+        self.encode_bounds_and_type_for_item(def_id);\n     }\n \n-    fn encode_info_for_closure(&mut self, (def_id, expr_id): (DefId, NodeId)) {\n-        let ecx = self.ecx;\n-        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n-        encode_name(self.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n+    fn encode_info_for_closure(&mut self, def_id: DefId) {\n+        let tcx = self.tcx;\n+        encode_def_id_and_key(self, def_id);\n+        encode_name(self, syntax::parse::token::intern(\"<closure>\"));\n \n-        self.rbml_w.start_tag(tag_items_closure_ty);\n-        write_closure_type(ecx,\n-                           self.rbml_w,\n-                           &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-        self.rbml_w.end_tag();\n+        self.start_tag(tag_items_closure_ty);\n+        write_closure_type(self,\n+                           &tcx.tables.borrow().closure_tys[&def_id]);\n+        self.end_tag();\n \n-        self.rbml_w.start_tag(tag_items_closure_kind);\n-        ecx.tcx.closure_kind(def_id).encode(self.rbml_w).unwrap();\n-        self.rbml_w.end_tag();\n+        self.start_tag(tag_items_closure_kind);\n+        tcx.closure_kind(def_id).encode(self.ecx).unwrap();\n+        self.end_tag();\n \n-        assert!(ecx.mir_map.map.contains_key(&def_id));\n-        self.encode_mir(expr_id);\n+        assert!(self.mir_map.map.contains_key(&def_id));\n+        self.encode_mir(def_id);\n     }\n }\n \n-fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                   rbml_w: &mut Encoder)\n+fn encode_info_for_items<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>)\n                                    -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n     let krate = ecx.tcx.map.krate();\n \n-    rbml_w.start_tag(tag_items_data);\n+    ecx.start_tag(tag_items_data);\n \n     let fields = {\n-        let mut index = IndexBuilder::new(ecx, rbml_w);\n+        let mut index = IndexBuilder::new(ecx);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      ItemContentBuilder::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module,\n                                             &[],\n                                             syntax::parse::token::intern(&ecx.link_meta.crate_name),\n                                             &hir::Public)));\n-        krate.visit_all_items(&mut EncodeVisitor {\n-            index: &mut index,\n-        });\n-        index.into_fields()\n+        let mut visitor = EncodeVisitor {\n+            index: index,\n+        };\n+        krate.visit_all_items(&mut visitor);\n+        visitor.index.into_fields()\n     };\n \n-    rbml_w.end_tag();\n+    ecx.end_tag();\n \n     fields\n }\n \n-fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n-    rbml_w.start_tag(tag_index);\n-    index.write_index(rbml_w.writer);\n-    rbml_w.end_tag();\n+fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n+    ecx.start_tag(tag_index);\n+    index.write_index(&mut ecx.writer);\n+    ecx.end_tag();\n }\n \n-fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n-    rbml_w.start_tag(tag_attributes);\n-    rbml_w.emit_opaque(|opaque_encoder| {\n+fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n+    ecx.start_tag(tag_attributes);\n+    ecx.emit_opaque(|opaque_encoder| {\n         attrs.encode(opaque_encoder)\n     }).unwrap();\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_unsafety(rbml_w: &mut Encoder, unsafety: hir::Unsafety) {\n+fn encode_unsafety(ecx: &mut EncodeContext, unsafety: hir::Unsafety) {\n     let byte: u8 = match unsafety {\n         hir::Unsafety::Normal => 0,\n         hir::Unsafety::Unsafe => 1,\n     };\n-    rbml_w.wr_tagged_u8(tag_unsafety, byte);\n+    ecx.wr_tagged_u8(tag_unsafety, byte);\n }\n \n-fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n+fn encode_paren_sugar(ecx: &mut EncodeContext, paren_sugar: bool) {\n     let byte: u8 = if paren_sugar {1} else {0};\n-    rbml_w.wr_tagged_u8(tag_paren_sugar, byte);\n+    ecx.wr_tagged_u8(tag_paren_sugar, byte);\n }\n \n-fn encode_defaulted(rbml_w: &mut Encoder, is_defaulted: bool) {\n+fn encode_defaulted(ecx: &mut EncodeContext, is_defaulted: bool) {\n     let byte: u8 = if is_defaulted {1} else {0};\n-    rbml_w.wr_tagged_u8(tag_defaulted_trait, byte);\n+    ecx.wr_tagged_u8(tag_defaulted_trait, byte);\n }\n \n-fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[Name]) {\n-    rbml_w.start_tag(tag_associated_type_names);\n+fn encode_associated_type_names(ecx: &mut EncodeContext, names: &[Name]) {\n+    ecx.start_tag(tag_associated_type_names);\n     for &name in names {\n-        rbml_w.wr_tagged_str(tag_associated_type_name, &name.as_str());\n+        ecx.wr_tagged_str(tag_associated_type_name, &name.as_str());\n     }\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_polarity(rbml_w: &mut Encoder, polarity: hir::ImplPolarity) {\n+fn encode_polarity(ecx: &mut EncodeContext, polarity: hir::ImplPolarity) {\n     let byte: u8 = match polarity {\n         hir::ImplPolarity::Positive => 0,\n         hir::ImplPolarity::Negative => 1,\n     };\n-    rbml_w.wr_tagged_u8(tag_polarity, byte);\n+    ecx.wr_tagged_u8(tag_polarity, byte);\n }\n \n-fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n+fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n                         -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n@@ -1491,64 +1451,64 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // the assumption that they are numbered 1 to n.\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    rbml_w.start_tag(tag_crate_deps);\n+    ecx.start_tag(tag_crate_deps);\n     for (_cnum, dep) in get_ordered_deps(cstore) {\n-        encode_crate_dep(rbml_w, &dep);\n+        encode_crate_dep(ecx, &dep);\n     }\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_lang_items);\n+fn encode_lang_items(ecx: &mut EncodeContext) {\n+    ecx.start_tag(tag_lang_items);\n \n     for (i, &opt_def_id) in ecx.tcx.lang_items.items().iter().enumerate() {\n         if let Some(def_id) = opt_def_id {\n             if def_id.is_local() {\n-                rbml_w.start_tag(tag_lang_items_item);\n-                rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n-                rbml_w.wr_tagged_u32(tag_lang_items_item_index, def_id.index.as_u32());\n-                rbml_w.end_tag();\n+                ecx.start_tag(tag_lang_items_item);\n+                ecx.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n+                ecx.wr_tagged_u32(tag_lang_items_item_index, def_id.index.as_u32());\n+                ecx.end_tag();\n             }\n         }\n     }\n \n     for i in &ecx.tcx.lang_items.missing {\n-        rbml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n+        ecx.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n     }\n \n-    rbml_w.end_tag();   // tag_lang_items\n+    ecx.end_tag();   // tag_lang_items\n }\n \n-fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_native_libraries);\n+fn encode_native_libraries(ecx: &mut EncodeContext) {\n+    ecx.start_tag(tag_native_libraries);\n \n     for &(ref lib, kind) in ecx.tcx.sess.cstore.used_libraries().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n-                rbml_w.start_tag(tag_native_libraries_lib);\n-                rbml_w.wr_tagged_u32(tag_native_libraries_kind, kind as u32);\n-                rbml_w.wr_tagged_str(tag_native_libraries_name, lib);\n-                rbml_w.end_tag();\n+                ecx.start_tag(tag_native_libraries_lib);\n+                ecx.wr_tagged_u32(tag_native_libraries_kind, kind as u32);\n+                ecx.wr_tagged_str(tag_native_libraries_name, lib);\n+                ecx.end_tag();\n             }\n         }\n     }\n \n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+fn encode_plugin_registrar_fn(ecx: &mut EncodeContext) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n         Some(id) => {\n             let def_id = ecx.tcx.map.local_def_id(id);\n-            rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, def_id.index.as_u32());\n+            ecx.wr_tagged_u32(tag_plugin_registrar_fn, def_id.index.as_u32());\n         }\n         None => {}\n     }\n }\n \n-fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_codemap);\n+fn encode_codemap(ecx: &mut EncodeContext) {\n+    ecx.start_tag(tag_codemap);\n     let codemap = ecx.tcx.sess.codemap();\n \n     for filemap in &codemap.files.borrow()[..] {\n@@ -1561,66 +1521,62 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n             continue;\n         }\n \n-        rbml_w.start_tag(tag_codemap_filemap);\n-        rbml_w.emit_opaque(|opaque_encoder| {\n+        ecx.start_tag(tag_codemap_filemap);\n+        ecx.emit_opaque(|opaque_encoder| {\n             filemap.encode(opaque_encoder)\n         }).unwrap();\n-        rbml_w.end_tag();\n+        ecx.end_tag();\n     }\n \n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n /// Serialize the text of the exported macros\n-fn encode_macro_defs(rbml_w: &mut Encoder,\n-                     krate: &hir::Crate,\n-                     tcx: TyCtxt) {\n-    rbml_w.start_tag(tag_macro_defs);\n+fn encode_macro_defs(ecx: &mut EncodeContext,\n+                     krate: &hir::Crate) {\n+    ecx.start_tag(tag_macro_defs);\n     for def in &krate.exported_macros {\n-        rbml_w.start_tag(tag_macro_def);\n+        ecx.start_tag(tag_macro_def);\n \n-        encode_name(rbml_w, def.name);\n-        encode_attributes(rbml_w, &def.attrs);\n+        encode_name(ecx, def.name);\n+        encode_attributes(ecx, &def.attrs);\n         let &BytePos(lo) = &def.span.lo;\n         let &BytePos(hi) = &def.span.hi;\n-        rbml_w.wr_tagged_u32(tag_macro_def_span_lo, lo);\n-        rbml_w.wr_tagged_u32(tag_macro_def_span_hi, hi);\n+        ecx.wr_tagged_u32(tag_macro_def_span_lo, lo);\n+        ecx.wr_tagged_u32(tag_macro_def_span_hi, hi);\n \n-        rbml_w.wr_tagged_str(tag_macro_def_body,\n-                             &::syntax::print::pprust::tts_to_string(&def.body));\n+        ecx.wr_tagged_str(tag_macro_def_body,\n+                          &::syntax::print::pprust::tts_to_string(&def.body));\n \n-        rbml_w.end_tag();\n+        ecx.end_tag();\n     }\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n \n-    if tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro) {\n-        let id = tcx.sess.derive_registrar_fn.get().unwrap();\n-        let did = tcx.map.local_def_id(id);\n-        rbml_w.wr_tagged_u32(tag_macro_derive_registrar, did.index.as_u32());\n+    if ecx.tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro) {\n+        let id = ecx.tcx.sess.derive_registrar_fn.get().unwrap();\n+        let did = ecx.tcx.map.local_def_id(id);\n+        ecx.wr_tagged_u32(tag_macro_derive_registrar, did.index.as_u32());\n     }\n }\n \n-fn encode_struct_field_attrs(ecx: &EncodeContext,\n-                             rbml_w: &mut Encoder,\n-                             krate: &hir::Crate) {\n-    struct StructFieldVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n-        ecx: &'a EncodeContext<'b, 'tcx>,\n-        rbml_w: &'a mut Encoder<'c>,\n+fn encode_struct_field_attrs(ecx: &mut EncodeContext, krate: &hir::Crate) {\n+    struct StructFieldVisitor<'a, 'b:'a, 'tcx:'b> {\n+        ecx: &'a mut EncodeContext<'b, 'tcx>\n     }\n \n-    impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b, 'c, 'tcx> {\n+    impl<'a, 'b, 'tcx, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b, 'tcx> {\n         fn visit_struct_field(&mut self, field: &hir::StructField) {\n-            self.rbml_w.start_tag(tag_struct_field);\n+            self.ecx.start_tag(tag_struct_field);\n             let def_id = self.ecx.tcx.map.local_def_id(field.id);\n-            encode_def_id(self.rbml_w, def_id);\n-            encode_attributes(self.rbml_w, &field.attrs);\n-            self.rbml_w.end_tag();\n+            encode_def_id(self.ecx, def_id);\n+            encode_attributes(self.ecx, &field.attrs);\n+            self.ecx.end_tag();\n         }\n     }\n \n-    rbml_w.start_tag(tag_struct_fields);\n-    krate.visit_all_items(&mut StructFieldVisitor { ecx: ecx, rbml_w: rbml_w });\n-    rbml_w.end_tag();\n+    ecx.start_tag(tag_struct_fields);\n+    krate.visit_all_items(&mut StructFieldVisitor { ecx: ecx });\n+    ecx.end_tag();\n }\n \n \n@@ -1644,25 +1600,23 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n }\n \n /// Encodes an index, mapping each trait to its (local) implementations.\n-fn encode_impls<'a>(ecx: &'a EncodeContext,\n-                    krate: &hir::Crate,\n-                    rbml_w: &'a mut Encoder) {\n+fn encode_impls(ecx: &mut EncodeContext, krate: &hir::Crate) {\n     let mut visitor = ImplVisitor {\n         tcx: ecx.tcx,\n         impls: FnvHashMap()\n     };\n     krate.visit_all_items(&mut visitor);\n \n-    rbml_w.start_tag(tag_impls);\n+    ecx.start_tag(tag_impls);\n     for (trait_, trait_impls) in visitor.impls {\n-        rbml_w.start_tag(tag_impls_trait);\n-        encode_def_id(rbml_w, trait_);\n+        ecx.start_tag(tag_impls_trait);\n+        encode_def_id(ecx, trait_);\n         for impl_ in trait_impls {\n-            rbml_w.wr_tagged_u64(tag_impls_trait_impl, def_to_u64(impl_));\n+            ecx.wr_tagged_u64(tag_impls_trait_impl, def_to_u64(impl_));\n         }\n-        rbml_w.end_tag();\n+        ecx.end_tag();\n     }\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n // Encodes all reachable symbols in this crate into the metadata.\n@@ -1671,47 +1625,47 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n // middle::reachable module but filters out items that either don't have a\n // symbol associated with them (they weren't translated) or if they're an FFI\n // definition (as that's not defined in this crate).\n-fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_reachable_ids);\n+fn encode_reachable(ecx: &mut EncodeContext) {\n+    ecx.start_tag(tag_reachable_ids);\n     for &id in ecx.reachable {\n         let def_id = ecx.tcx.map.local_def_id(id);\n-        rbml_w.wr_tagged_u32(tag_reachable_id, def_id.index.as_u32());\n+        ecx.wr_tagged_u32(tag_reachable_id, def_id.index.as_u32());\n     }\n-    rbml_w.end_tag();\n+    ecx.end_tag();\n }\n \n-fn encode_crate_dep(rbml_w: &mut Encoder,\n+fn encode_crate_dep(ecx: &mut EncodeContext,\n                     dep: &cstore::CrateMetadata) {\n-    rbml_w.start_tag(tag_crate_dep);\n-    rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n+    ecx.start_tag(tag_crate_dep);\n+    ecx.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n     let hash = decoder::get_crate_hash(dep.data());\n-    rbml_w.wr_tagged_u64(tag_crate_dep_hash, hash.as_u64());\n-    rbml_w.wr_tagged_u8(tag_crate_dep_explicitly_linked,\n-                        dep.explicitly_linked.get() as u8);\n-    rbml_w.end_tag();\n+    ecx.wr_tagged_u64(tag_crate_dep_hash, hash.as_u64());\n+    ecx.wr_tagged_u8(tag_crate_dep_explicitly_linked,\n+                     dep.explicitly_linked.get() as u8);\n+    ecx.end_tag();\n }\n \n-fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n-    rbml_w.wr_tagged_u64(tag_crate_hash, hash.as_u64());\n+fn encode_hash(ecx: &mut EncodeContext, hash: &Svh) {\n+    ecx.wr_tagged_u64(tag_crate_hash, hash.as_u64());\n }\n \n-fn encode_rustc_version(rbml_w: &mut Encoder) {\n-    rbml_w.wr_tagged_str(tag_rustc_version, &rustc_version());\n+fn encode_rustc_version(ecx: &mut EncodeContext) {\n+    ecx.wr_tagged_str(tag_rustc_version, &rustc_version());\n }\n \n-fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n-    rbml_w.wr_tagged_str(tag_crate_crate_name, crate_name);\n+fn encode_crate_name(ecx: &mut EncodeContext, crate_name: &str) {\n+    ecx.wr_tagged_str(tag_crate_crate_name, crate_name);\n }\n \n-fn encode_crate_disambiguator(rbml_w: &mut Encoder, crate_disambiguator: &str) {\n-    rbml_w.wr_tagged_str(tag_crate_disambiguator, crate_disambiguator);\n+fn encode_crate_disambiguator(ecx: &mut EncodeContext, crate_disambiguator: &str) {\n+    ecx.wr_tagged_str(tag_crate_disambiguator, crate_disambiguator);\n }\n \n-fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n-    rbml_w.wr_tagged_str(tag_crate_triple, triple);\n+fn encode_crate_triple(ecx: &mut EncodeContext, triple: &str) {\n+    ecx.wr_tagged_str(tag_crate_triple, triple);\n }\n \n-fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n+fn encode_dylib_dependency_formats(ecx: &mut EncodeContext) {\n     let tag = tag_dylib_dependency_formats;\n     match ecx.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n@@ -1724,37 +1678,32 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                 };\n                 Some(format!(\"{}:{}\", i + 1, kind))\n             }).collect::<Vec<String>>();\n-            rbml_w.wr_tagged_str(tag, &s.join(\",\"));\n+            ecx.wr_tagged_str(tag, &s.join(\",\"));\n         }\n         None => {\n-            rbml_w.wr_tagged_str(tag, \"\");\n+            ecx.wr_tagged_str(tag, \"\");\n         }\n     }\n }\n \n-fn encode_panic_strategy(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n+fn encode_panic_strategy(ecx: &mut EncodeContext) {\n     match ecx.tcx.sess.opts.cg.panic {\n         PanicStrategy::Unwind => {\n-            rbml_w.wr_tagged_u8(tag_panic_strategy, b'U');\n+            ecx.wr_tagged_u8(tag_panic_strategy, b'U');\n         }\n         PanicStrategy::Abort => {\n-            rbml_w.wr_tagged_u8(tag_panic_strategy, b'A');\n+            ecx.wr_tagged_u8(tag_panic_strategy, b'A');\n         }\n     }\n }\n \n-pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n-    let mut wr = Cursor::new(Vec::new());\n-\n-    {\n-        let mut rbml_w = Encoder::new(&mut wr);\n-        encode_metadata_inner(&mut rbml_w, &ecx, krate)\n-    }\n+pub fn encode_metadata(mut ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n+    encode_metadata_inner(&mut ecx, krate);\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n-    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as usize;\n-    let mut v = wr.into_inner();\n+    let metalen = ecx.rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() as usize;\n+    let mut v = ecx.rbml_w.writer.into_inner();\n     v.truncate(metalen);\n     assert_eq!(v.len(), metalen);\n \n@@ -1797,9 +1746,7 @@ pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     result\n }\n \n-fn encode_metadata_inner(rbml_w: &mut Encoder,\n-                         ecx: &EncodeContext,\n-                         krate: &hir::Crate) {\n+fn encode_metadata_inner(ecx: &mut EncodeContext, krate: &hir::Crate) {\n     struct Stats {\n         attr_bytes: u64,\n         dep_bytes: u64,\n@@ -1833,78 +1780,81 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n         total_bytes: 0,\n     };\n \n-    encode_rustc_version(rbml_w);\n-    encode_crate_name(rbml_w, &ecx.link_meta.crate_name);\n-    encode_crate_triple(rbml_w, &ecx.tcx.sess.opts.target_triple);\n-    encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n-    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.local_crate_disambiguator());\n-    encode_dylib_dependency_formats(rbml_w, &ecx);\n-    encode_panic_strategy(rbml_w, &ecx);\n+    encode_rustc_version(ecx);\n+\n+    let tcx = ecx.tcx;\n+    let link_meta = ecx.link_meta;\n+    encode_crate_name(ecx, &link_meta.crate_name);\n+    encode_crate_triple(ecx, &tcx.sess.opts.target_triple);\n+    encode_hash(ecx, &link_meta.crate_hash);\n+    encode_crate_disambiguator(ecx, &tcx.sess.local_crate_disambiguator());\n+    encode_dylib_dependency_formats(ecx);\n+    encode_panic_strategy(ecx);\n \n-    let mut i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_attributes(rbml_w, &krate.attrs);\n-    stats.attr_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    let mut i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_attributes(ecx, &krate.attrs);\n+    stats.attr_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_crate_deps(rbml_w, ecx.cstore);\n-    stats.dep_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_crate_deps(ecx, ecx.cstore);\n+    stats.dep_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the language items.\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_lang_items(&ecx, rbml_w);\n-    stats.lang_item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_lang_items(ecx);\n+    stats.lang_item_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the native libraries used\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_native_libraries(&ecx, rbml_w);\n-    stats.native_lib_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_native_libraries(ecx);\n+    stats.native_lib_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the plugin registrar function\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_plugin_registrar_fn(&ecx, rbml_w);\n-    stats.plugin_registrar_fn_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_plugin_registrar_fn(ecx);\n+    stats.plugin_registrar_fn_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode codemap\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_codemap(&ecx, rbml_w);\n-    stats.codemap_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_codemap(ecx);\n+    stats.codemap_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode macro definitions\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_macro_defs(rbml_w, krate, ecx.tcx);\n-    stats.macro_defs_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_macro_defs(ecx, krate);\n+    stats.macro_defs_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_impls(&ecx, krate, rbml_w);\n-    stats.impl_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_impls(ecx, krate);\n+    stats.impl_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode reachability info.\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_reachable(&ecx, rbml_w);\n-    stats.reachable_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_reachable(ecx);\n+    stats.reachable_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items.\n-    rbml_w.start_tag(tag_items);\n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let (items, xrefs) = encode_info_for_items(&ecx, rbml_w);\n-    stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n-    rbml_w.end_tag();\n+    ecx.start_tag(tag_items);\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    let (items, xrefs) = encode_info_for_items(ecx);\n+    stats.item_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    ecx.end_tag();\n \n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_item_index(rbml_w, items);\n-    stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_item_index(ecx, items);\n+    stats.index_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_xrefs(&ecx, rbml_w, xrefs);\n-    stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    i = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_xrefs(ecx, xrefs);\n+    stats.xref_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    encode_struct_field_attrs(&ecx, rbml_w, krate);\n+    encode_struct_field_attrs(ecx, krate);\n \n-    stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n+    stats.total_bytes = ecx.writer.seek(SeekFrom::Current(0)).unwrap();\n \n     if ecx.tcx.sess.meta_stats() {\n-        for e in rbml_w.writer.get_ref() {\n+        for e in ecx.writer.get_ref() {\n             if *e == 0 {\n                 stats.zero_bytes += 1;\n             }\n@@ -1935,7 +1885,6 @@ pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n-        diag: tcx.sess.diagnostic(),\n         ds: def_id_to_string,\n         tcx: tcx,\n         abbrevs: &RefCell::new(FnvHashMap())"}, {"sha": "de2f1c4fb0c85f45e83add281a9668f1cb170d26", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -65,51 +65,70 @@\n use common::tag_items_data_item;\n use encoder::EncodeContext;\n use index::IndexData;\n-use rbml::writer::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n use syntax::ast;\n \n+use std::ops::{Deref, DerefMut};\n+\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n-pub struct IndexBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n+pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     items: IndexData,\n-    builder: ItemContentBuilder<'a, 'tcx, 'encoder>,\n+    builder: ItemContentBuilder<'a, 'b, 'tcx>,\n }\n \n /// Builder that can encode the content of items, but can't start a\n /// new item itself. Most code is attached to here.\n-pub struct ItemContentBuilder<'a, 'tcx: 'a, 'encoder: 'a> {\n+pub struct ItemContentBuilder<'a, 'b: 'a, 'tcx: 'b> {\n     xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n-    pub ecx: &'a EncodeContext<'a, 'tcx>,\n-    pub rbml_w: &'a mut Encoder<'encoder>,\n+    pub ecx: &'a mut EncodeContext<'b, 'tcx>,\n+}\n+\n+impl<'a, 'b, 'tcx> Deref for IndexBuilder<'a, 'b, 'tcx> {\n+    type Target = EncodeContext<'b, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        self.builder.ecx\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.builder.ecx\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Deref for ItemContentBuilder<'a, 'b, 'tcx> {\n+    type Target = EncodeContext<'b, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        self.ecx\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> DerefMut for ItemContentBuilder<'a, 'b, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.ecx\n+    }\n }\n \n /// \"interned\" entries referenced by id\n #[derive(PartialEq, Eq, Hash)]\n pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n-    pub fn new(ecx: &'a EncodeContext<'a, 'tcx>,\n-               rbml_w: &'a mut Encoder<'encoder>)\n-               -> Self {\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n             items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n             builder: ItemContentBuilder {\n                 ecx: ecx,\n                 xrefs: FnvHashMap(),\n-                rbml_w: rbml_w,\n             },\n         }\n     }\n \n-    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n-        self.builder.ecx()\n-    }\n-\n     /// Emit the data for a def-id to the metadata. The function to\n     /// emit the data is `op`, and it will be given `data` as\n     /// arguments. This `record` function will start/end an RBML tag\n@@ -129,29 +148,25 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     /// content system.\n     pub fn record<DATA>(&mut self,\n                         id: DefId,\n-                        op: fn(&mut ItemContentBuilder<'a, 'tcx, 'encoder>, DATA),\n+                        op: fn(&mut ItemContentBuilder<'a, 'b, 'tcx>, DATA),\n                         data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let position = self.builder.rbml_w.mark_stable_position();\n+        let position = self.builder.ecx.mark_stable_position();\n         self.items.record(id, position);\n-        let _task = self.ecx().tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        self.builder.rbml_w.start_tag(tag_items_data_item).unwrap();\n-        data.read(self.ecx().tcx);\n+        let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n+        self.builder.ecx.start_tag(tag_items_data_item).unwrap();\n+        data.read(self.tcx);\n         op(&mut self.builder, data);\n-        self.builder.rbml_w.end_tag().unwrap();\n+        self.builder.ecx.end_tag().unwrap();\n     }\n \n     pub fn into_fields(self) -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {\n         (self.items, self.builder.xrefs)\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n-    pub fn ecx(&self) -> &'a EncodeContext<'a, 'tcx> {\n-        self.ecx\n-    }\n-\n+impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     pub fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n         let old_len = self.xrefs.len() as u32;\n         *self.xrefs.entry(xref).or_insert(old_len)"}, {"sha": "b49686e2379d693ef8ef212afec8c007deec59b2", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -21,8 +21,8 @@ use rustc_serialize as serialize;\n pub type EncodeResult = io::Result<()>;\n \n // rbml writing\n-pub struct Encoder<'a> {\n-    pub writer: &'a mut Cursor<Vec<u8>>,\n+pub struct Encoder {\n+    pub writer: Cursor<Vec<u8>>,\n     size_positions: Vec<u64>,\n     relax_limit: u64, // do not move encoded bytes before this position\n }\n@@ -65,10 +65,10 @@ pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n     Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n }\n \n-impl<'a> Encoder<'a> {\n-    pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n+impl Encoder {\n+    pub fn new() -> Encoder {\n         Encoder {\n-            writer: w,\n+            writer: Cursor::new(vec![]),\n             size_positions: vec![],\n             relax_limit: 0,\n         }\n@@ -79,7 +79,7 @@ impl<'a> Encoder<'a> {\n         assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n         // Write the enum ID:\n-        write_tag(self.writer, tag_id)?;\n+        write_tag(&mut self.writer, tag_id)?;\n \n         // Write a placeholder four-byte size.\n         let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n@@ -107,11 +107,11 @@ impl<'a> Encoder<'a> {\n             }\n \n             // overwrite the size and data and continue\n-            write_vuint(self.writer, size)?;\n+            write_vuint(&mut self.writer, size)?;\n             self.writer.write_all(&buf[..size])?;\n         } else {\n             // overwrite the size with an overlong encoding and skip past the data\n-            write_sized_vuint(self.writer, size, 4)?;\n+            write_sized_vuint(&mut self.writer, size, 4)?;\n             self.writer.seek(SeekFrom::Start(cur_pos))?;\n         }\n \n@@ -129,8 +129,8 @@ impl<'a> Encoder<'a> {\n \n     pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n         assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-        write_tag(self.writer, tag_id)?;\n-        write_vuint(self.writer, b.len())?;\n+        write_tag(&mut self.writer, tag_id)?;\n+        write_vuint(&mut self.writer, b.len())?;\n         self.writer.write_all(b)\n     }\n \n@@ -183,7 +183,7 @@ impl<'a> Encoder<'a> {\n \n     // for auto-serialization\n     fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-        write_tag(self.writer, tag_id)?;\n+        write_tag(&mut self.writer, tag_id)?;\n         self.writer.write_all(b)\n     }\n \n@@ -243,7 +243,7 @@ impl<'a> Encoder<'a> {\n     }\n }\n \n-impl<'a> Encoder<'a> {\n+impl Encoder {\n     // used internally to emit things like the vector length and so on\n     fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n         if v as u8 as usize == v {\n@@ -262,7 +262,7 @@ impl<'a> Encoder<'a> {\n         self.start_tag(EsOpaque as usize)?;\n \n         {\n-            let mut opaque_encoder = opaque::Encoder::new(self.writer);\n+            let mut opaque_encoder = opaque::Encoder::new(&mut self.writer);\n             f(&mut opaque_encoder)?;\n         }\n \n@@ -271,7 +271,7 @@ impl<'a> Encoder<'a> {\n     }\n }\n \n-impl<'a> serialize::Encoder for Encoder<'a> {\n+impl<'a, 'tcx> serialize::Encoder for ::encoder::EncodeContext<'a, 'tcx> {\n     type Error = io::Error;\n \n     fn emit_nil(&mut self) -> EncodeResult {\n@@ -355,22 +355,22 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.start_tag(EsEnum as usize)?;\n         f(self)?;\n         self.end_tag()\n     }\n \n     fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self._emit_tagged_sub(v_id)?;\n         f(self)\n     }\n \n     fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         f(self)\n     }\n@@ -381,68 +381,68 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n                                    cnt: usize,\n                                    f: F)\n                                    -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_enum_variant(v_name, v_id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n     fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         f(self)\n     }\n \n     fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         f(self)\n     }\n \n     fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.emit_enum(\"Option\", f)\n     }\n     fn emit_option_none(&mut self) -> EncodeResult {\n         self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n     }\n     fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n \n         self.emit_enum_variant(\"Some\", 1, 1, f)\n     }\n \n     fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         if len == 0 {\n             // empty vector optimization\n@@ -456,7 +456,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n \n         self.start_tag(EsVecElt as usize)?;\n@@ -465,7 +465,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         if len == 0 {\n             // empty map optimization\n@@ -479,7 +479,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n \n         self.start_tag(EsMapKey as usize)?;\n@@ -488,7 +488,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n     {\n         self.start_tag(EsMapVal as usize)?;\n         f(self)?;"}, {"sha": "73996518a15642745639eef0c3f7770f94389a0b", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82197287a204376ac6c1aa102f8af79bd20246cf/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=82197287a204376ac6c1aa102f8af79bd20246cf", "patch": "@@ -27,13 +27,11 @@ use rustc::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use errors::Handler;\n \n use rbml::leb128;\n use encoder;\n \n pub struct ctxt<'a, 'tcx: 'a> {\n-    pub diag: &'a Handler,\n     // Def -> str Callback:\n     pub ds: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String,\n     // The type context.\n@@ -42,12 +40,11 @@ pub struct ctxt<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> encoder::EncodeContext<'a, 'tcx> {\n-    pub fn ty_str_ctxt<'b>(&'b self) -> ctxt<'b, 'tcx> {\n+    pub fn ty_str_ctxt(&self) -> ctxt<'a, 'tcx> {\n         ctxt {\n-            diag: self.tcx.sess.diagnostic(),\n             ds: encoder::def_to_string,\n             tcx: self.tcx,\n-            abbrevs: &self.type_abbrevs\n+            abbrevs: self.type_abbrevs\n         }\n     }\n }"}]}