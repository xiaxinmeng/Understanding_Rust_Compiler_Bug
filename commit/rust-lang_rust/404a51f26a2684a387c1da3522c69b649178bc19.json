{"sha": "404a51f26a2684a387c1da3522c69b649178bc19", "node_id": "C_kwDOAAsO6NoAKDQwNGE1MWYyNmEyNjg0YTM4N2MxZGEzNTIyYzY5YjY0OTE3OGJjMTk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-16T08:29:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-16T08:29:55Z"}, "message": "internal: Make CompletionItem more POD-like", "tree": {"sha": "1db3916f13b3b68bfeb4035c3f4c6dc45a0eb1ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db3916f13b3b68bfeb4035c3f4c6dc45a0eb1ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/404a51f26a2684a387c1da3522c69b649178bc19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/404a51f26a2684a387c1da3522c69b649178bc19", "html_url": "https://github.com/rust-lang/rust/commit/404a51f26a2684a387c1da3522c69b649178bc19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/404a51f26a2684a387c1da3522c69b649178bc19/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f2d33fb40548178d4ced3f0f971540c910d7ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f2d33fb40548178d4ced3f0f971540c910d7ed9", "html_url": "https://github.com/rust-lang/rust/commit/1f2d33fb40548178d4ced3f0f971540c910d7ed9"}], "stats": {"total": 176, "additions": 70, "deletions": 106}, "files": [{"sha": "2f65491d85e14f920474a0bbea16baf0c2666b7c", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 25, "deletions": 65, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=404a51f26a2684a387c1da3522c69b649178bc19", "patch": "@@ -18,9 +18,10 @@ use crate::{\n /// editor pop-up. It is basically a POD with various properties. To construct a\n /// [`CompletionItem`], use [`Builder::new`] method and the [`Builder`] struct.\n #[derive(Clone)]\n+#[non_exhaustive]\n pub struct CompletionItem {\n     /// Label in the completion pop up which identifies completion.\n-    label: SmolStr,\n+    pub label: SmolStr,\n     /// Range of identifier that is being completed.\n     ///\n     /// It should be used primarily for UI, but we also use this to convert\n@@ -29,33 +30,33 @@ pub struct CompletionItem {\n     /// `source_range` must contain the completion offset. `text_edit` should\n     /// start with what `source_range` points to, or VSCode will filter out the\n     /// completion silently.\n-    source_range: TextRange,\n+    pub source_range: TextRange,\n     /// What happens when user selects this item.\n     ///\n     /// Typically, replaces `source_range` with new identifier.\n-    text_edit: TextEdit,\n-    is_snippet: bool,\n+    pub text_edit: TextEdit,\n+    pub is_snippet: bool,\n \n     /// What item (struct, function, etc) are we completing.\n-    kind: CompletionItemKind,\n+    pub kind: CompletionItemKind,\n \n     /// Lookup is used to check if completion item indeed can complete current\n     /// ident.\n     ///\n     /// That is, in `foo.bar$0` lookup of `abracadabra` will be accepted (it\n     /// contains `bar` sub sequence), and `quux` will rejected.\n-    lookup: Option<SmolStr>,\n+    pub lookup: Option<SmolStr>,\n \n     /// Additional info to show in the UI pop up.\n-    detail: Option<String>,\n-    documentation: Option<Documentation>,\n+    pub detail: Option<String>,\n+    pub documentation: Option<Documentation>,\n \n     /// Whether this item is marked as deprecated\n-    deprecated: bool,\n+    pub deprecated: bool,\n \n     /// If completing a function call, ask the editor to show parameter popup\n     /// after completion.\n-    trigger_call_info: bool,\n+    pub trigger_call_info: bool,\n \n     /// We use this to sort completion. Relevance records facts like \"do the\n     /// types align precisely?\". We can't sort by relevances directly, they are\n@@ -64,36 +65,39 @@ pub struct CompletionItem {\n     /// Note that Relevance ignores fuzzy match score. We compute Relevance for\n     /// all possible items, and then separately build an ordered completion list\n     /// based on relevance and fuzzy matching with the already typed identifier.\n-    relevance: CompletionRelevance,\n+    pub relevance: CompletionRelevance,\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n-    ref_match: Option<(Mutability, TextSize)>,\n+    // FIXME: We shouldn't expose Mutability here (that is HIR types at all), its fine for now though\n+    // until we have more splitting completions in which case we should think about\n+    // generalizing this. See https://github.com/rust-lang/rust-analyzer/issues/12571\n+    pub ref_match: Option<(Mutability, TextSize)>,\n \n     /// The import data to add to completion's edits.\n-    import_to_add: SmallVec<[LocatedImport; 1]>,\n+    pub import_to_add: SmallVec<[LocatedImport; 1]>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n impl fmt::Debug for CompletionItem {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n-        s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n-        if self.text_edit().len() == 1 {\n-            let atom = &self.text_edit().iter().next().unwrap();\n+        s.field(\"label\", &self.label).field(\"source_range\", &self.source_range);\n+        if self.text_edit.len() == 1 {\n+            let atom = &self.text_edit.iter().next().unwrap();\n             s.field(\"delete\", &atom.delete);\n             s.field(\"insert\", &atom.insert);\n         } else {\n             s.field(\"text_edit\", &self.text_edit);\n         }\n-        s.field(\"kind\", &self.kind());\n-        if self.lookup() != self.label() {\n+        s.field(\"kind\", &self.kind);\n+        if self.lookup() != self.label {\n             s.field(\"lookup\", &self.lookup());\n         }\n-        if let Some(detail) = self.detail() {\n+        if let Some(detail) = &self.detail {\n             s.field(\"detail\", &detail);\n         }\n-        if let Some(documentation) = self.documentation() {\n+        if let Some(documentation) = &self.documentation {\n             s.field(\"documentation\", &documentation);\n         }\n         if self.deprecated {\n@@ -351,51 +355,11 @@ impl CompletionItem {\n         }\n     }\n \n-    /// What user sees in pop-up in the UI.\n-    pub fn label(&self) -> &str {\n-        &self.label\n-    }\n-    pub fn source_range(&self) -> TextRange {\n-        self.source_range\n-    }\n-\n-    pub fn text_edit(&self) -> &TextEdit {\n-        &self.text_edit\n-    }\n-    /// Whether `text_edit` is a snippet (contains `$0` markers).\n-    pub fn is_snippet(&self) -> bool {\n-        self.is_snippet\n-    }\n-\n-    /// Short one-line additional information, like a type\n-    pub fn detail(&self) -> Option<&str> {\n-        self.detail.as_deref()\n-    }\n-    /// A doc-comment\n-    pub fn documentation(&self) -> Option<Documentation> {\n-        self.documentation.clone()\n-    }\n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n         self.lookup.as_deref().unwrap_or(&self.label)\n     }\n \n-    pub fn kind(&self) -> CompletionItemKind {\n-        self.kind\n-    }\n-\n-    pub fn deprecated(&self) -> bool {\n-        self.deprecated\n-    }\n-\n-    pub fn relevance(&self) -> CompletionRelevance {\n-        self.relevance\n-    }\n-\n-    pub fn trigger_call_info(&self) -> bool {\n-        self.trigger_call_info\n-    }\n-\n     pub fn ref_match(&self) -> Option<(String, text_edit::Indel, CompletionRelevance)> {\n         // Relevance of the ref match should be the same as the original\n         // match, but with exact type match set because self.ref_match\n@@ -405,16 +369,12 @@ impl CompletionItem {\n \n         self.ref_match.map(|(mutability, offset)| {\n             (\n-                format!(\"&{}{}\", mutability.as_keyword_for_ref(), self.label()),\n+                format!(\"&{}{}\", mutability.as_keyword_for_ref(), self.label),\n                 text_edit::Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n                 relevance,\n             )\n         })\n     }\n-\n-    pub fn imports_to_add(&self) -> &[LocatedImport] {\n-        &self.import_to_add\n-    }\n }\n \n /// A helper to make `CompletionItem`s."}, {"sha": "d99ad5f9f04ba14bbf942136c0a5687ad091e12d", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=404a51f26a2684a387c1da3522c69b649178bc19", "patch": "@@ -503,18 +503,18 @@ mod tests {\n     #[track_caller]\n     fn check_relevance_for_kinds(ra_fixture: &str, kinds: &[CompletionItemKind], expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| kinds.contains(&it.kind()));\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| kinds.contains(&it.kind));\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n     #[track_caller]\n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Snippet);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Keyword);\n-        actual.retain(|it| it.kind() != CompletionItemKind::BuiltinType);\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| it.kind != CompletionItemKind::Snippet);\n+        actual.retain(|it| it.kind != CompletionItemKind::Keyword);\n+        actual.retain(|it| it.kind != CompletionItemKind::BuiltinType);\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n@@ -525,9 +525,9 @@ mod tests {\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n-                let tag = it.kind().tag();\n-                let relevance = display_relevance(it.relevance());\n-                items.push(format!(\"{tag} {} {relevance}\\n\", it.label()));\n+                let tag = it.kind.tag();\n+                let relevance = display_relevance(it.relevance);\n+                items.push(format!(\"{tag} {} {relevance}\\n\", it.label));\n \n                 if let Some((label, _indel, relevance)) = it.ref_match() {\n                     let relevance = display_relevance(relevance);"}, {"sha": "1fe48b9e96f9dcaf5eb69b5dfce0bc09fb8a0987", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=404a51f26a2684a387c1da3522c69b649178bc19", "patch": "@@ -108,10 +108,10 @@ fn completion_list_with_config(\n     let items = get_all_items(config, ra_fixture, trigger_character);\n     let items = items\n         .into_iter()\n-        .filter(|it| it.kind() != CompletionItemKind::BuiltinType || it.label() == \"u32\")\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n-        .sorted_by_key(|it| (it.kind(), it.label().to_owned(), it.detail().map(ToOwned::to_owned)))\n+        .filter(|it| it.kind != CompletionItemKind::BuiltinType || it.label == \"u32\")\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Keyword)\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Snippet)\n+        .sorted_by_key(|it| (it.kind, it.label.clone(), it.detail.as_ref().map(ToOwned::to_owned)))\n         .collect();\n     render_completion_list(items)\n }\n@@ -138,8 +138,8 @@ pub(crate) fn do_completion_with_config(\n ) -> Vec<CompletionItem> {\n     get_all_items(config, code, None)\n         .into_iter()\n-        .filter(|c| c.kind() == kind)\n-        .sorted_by(|l, r| l.label().cmp(r.label()))\n+        .filter(|c| c.kind == kind)\n+        .sorted_by(|l, r| l.label.cmp(&r.label))\n         .collect()\n }\n \n@@ -148,18 +148,18 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n         s.chars().count()\n     }\n     let label_width =\n-        completions.iter().map(|it| monospace_width(it.label())).max().unwrap_or_default().min(22);\n+        completions.iter().map(|it| monospace_width(&it.label)).max().unwrap_or_default().min(22);\n     completions\n         .into_iter()\n         .map(|it| {\n-            let tag = it.kind().tag();\n-            let var_name = format!(\"{tag} {}\", it.label());\n+            let tag = it.kind.tag();\n+            let var_name = format!(\"{tag} {}\", it.label);\n             let mut buf = var_name;\n-            if let Some(detail) = it.detail() {\n-                let width = label_width.saturating_sub(monospace_width(it.label()));\n+            if let Some(detail) = it.detail {\n+                let width = label_width.saturating_sub(monospace_width(&it.label));\n                 format_to!(buf, \"{:width$} {}\", \"\", detail, width = width);\n             }\n-            if it.deprecated() {\n+            if it.deprecated {\n                 format_to!(buf, \" DEPRECATED\");\n             }\n             format_to!(buf, \"\\n\");\n@@ -191,13 +191,13 @@ pub(crate) fn check_edit_with_config(\n         .unwrap_or_else(|| panic!(\"can't find {what:?} completion in {completions:#?}\"));\n     let mut actual = db.file_text(position.file_id).to_string();\n \n-    let mut combined_edit = completion.text_edit().to_owned();\n+    let mut combined_edit = completion.text_edit.clone();\n \n     resolve_completion_edits(\n         &db,\n         &config,\n         position,\n-        completion.imports_to_add().iter().filter_map(|import_edit| {\n+        completion.import_to_add.iter().filter_map(|import_edit| {\n             let import_path = &import_edit.import_path;\n             let import_name = import_path.segments().last()?;\n             Some((import_path.to_string(), import_name.to_string()))\n@@ -225,7 +225,7 @@ pub(crate) fn get_all_items(\n         .map_or_else(Vec::default, Into::into);\n     // validate\n     res.iter().for_each(|it| {\n-        let sr = it.source_range();\n+        let sr = it.source_range;\n         assert!(\n             sr.contains_inclusive(position.offset),\n             \"source range {sr:?} does not contain the offset {:?} of the completion request: {it:?}\","}, {"sha": "92029dc1de78f01e5b9b7878f1ad839402a55040", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404a51f26a2684a387c1da3522c69b649178bc19/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=404a51f26a2684a387c1da3522c69b649178bc19", "patch": "@@ -212,7 +212,7 @@ pub(crate) fn completion_items(\n     tdpp: lsp_types::TextDocumentPositionParams,\n     items: Vec<CompletionItem>,\n ) -> Vec<lsp_types::CompletionItem> {\n-    let max_relevance = items.iter().map(|it| it.relevance().score()).max().unwrap_or_default();\n+    let max_relevance = items.iter().map(|it| it.relevance.score()).max().unwrap_or_default();\n     let mut res = Vec::with_capacity(items.len());\n     for item in items {\n         completion_item(&mut res, config, line_index, &tdpp, max_relevance, item);\n@@ -235,14 +235,17 @@ fn completion_item(\n     item: CompletionItem,\n ) {\n     let insert_replace_support = config.insert_replace_support().then_some(tdpp.position);\n+    let ref_match = item.ref_match();\n+    let lookup = item.lookup().to_string();\n+\n     let mut additional_text_edits = Vec::new();\n \n     // LSP does not allow arbitrary edits in completion, so we have to do a\n     // non-trivial mapping here.\n     let text_edit = {\n         let mut text_edit = None;\n-        let source_range = item.source_range();\n-        for indel in item.text_edit() {\n+        let source_range = item.source_range;\n+        for indel in item.text_edit {\n             if indel.delete.contains_range(source_range) {\n                 // Extract this indel as the main edit\n                 text_edit = Some(if indel.delete == source_range {\n@@ -265,23 +268,23 @@ fn completion_item(\n         text_edit.unwrap()\n     };\n \n-    let insert_text_format = item.is_snippet().then_some(lsp_types::InsertTextFormat::SNIPPET);\n-    let tags = item.deprecated().then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n-    let command = if item.trigger_call_info() && config.client_commands().trigger_parameter_hints {\n+    let insert_text_format = item.is_snippet.then_some(lsp_types::InsertTextFormat::SNIPPET);\n+    let tags = item.deprecated.then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n+    let command = if item.trigger_call_info && config.client_commands().trigger_parameter_hints {\n         Some(command::trigger_parameter_hints())\n     } else {\n         None\n     };\n \n     let mut lsp_item = lsp_types::CompletionItem {\n-        label: item.label().to_string(),\n-        detail: item.detail().map(|it| it.to_string()),\n-        filter_text: Some(item.lookup().to_string()),\n-        kind: Some(completion_item_kind(item.kind())),\n+        label: item.label.to_string(),\n+        detail: item.detail.map(|it| it.to_string()),\n+        filter_text: Some(lookup),\n+        kind: Some(completion_item_kind(item.kind)),\n         text_edit: Some(text_edit),\n         additional_text_edits: Some(additional_text_edits),\n-        documentation: item.documentation().map(documentation),\n-        deprecated: Some(item.deprecated()),\n+        documentation: item.documentation.map(documentation),\n+        deprecated: Some(item.deprecated),\n         tags,\n         command,\n         insert_text_format,\n@@ -295,12 +298,13 @@ fn completion_item(\n         });\n     }\n \n-    set_score(&mut lsp_item, max_relevance, item.relevance());\n+    set_score(&mut lsp_item, max_relevance, item.relevance);\n \n     if config.completion().enable_imports_on_the_fly {\n-        if let imports @ [_, ..] = item.imports_to_add() {\n-            let imports: Vec<_> = imports\n-                .iter()\n+        if !item.import_to_add.is_empty() {\n+            let imports: Vec<_> = item\n+                .import_to_add\n+                .into_iter()\n                 .filter_map(|import_edit| {\n                     let import_path = &import_edit.import_path;\n                     let import_name = import_path.segments().last()?;\n@@ -317,7 +321,7 @@ fn completion_item(\n         }\n     }\n \n-    if let Some((label, indel, relevance)) = item.ref_match() {\n+    if let Some((label, indel, relevance)) = ref_match {\n         let mut lsp_item_with_ref = lsp_types::CompletionItem { label, ..lsp_item.clone() };\n         lsp_item_with_ref\n             .additional_text_edits"}]}