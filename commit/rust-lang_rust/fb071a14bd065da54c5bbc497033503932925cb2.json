{"sha": "fb071a14bd065da54c5bbc497033503932925cb2", "node_id": "C_kwDOAAsO6NoAKGZiMDcxYTE0YmQwNjVkYTU0YzViYmM0OTcwMzM1MDM5MzI5MjVjYjI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-08-25T10:10:32Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-08-25T15:34:57Z"}, "message": "Use ui_test from crates.io instead of having it in-tree", "tree": {"sha": "a8981a69f8c1e88e1a82592dfde6a4ad11916a42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8981a69f8c1e88e1a82592dfde6a4ad11916a42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb071a14bd065da54c5bbc497033503932925cb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb071a14bd065da54c5bbc497033503932925cb2", "html_url": "https://github.com/rust-lang/rust/commit/fb071a14bd065da54c5bbc497033503932925cb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb071a14bd065da54c5bbc497033503932925cb2/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f99aa9d0d7b780aadbf986c95740358b31342dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f99aa9d0d7b780aadbf986c95740358b31342dd", "html_url": "https://github.com/rust-lang/rust/commit/9f99aa9d0d7b780aadbf986c95740358b31342dd"}], "stats": {"total": 2295, "additions": 5, "deletions": 2290}, "files": [{"sha": "b0601ba3d4605c1811e010ac0eb0bb613ad6e16d", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb071a14bd065da54c5bbc497033503932925cb2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb071a14bd065da54c5bbc497033503932925cb2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fb071a14bd065da54c5bbc497033503932925cb2", "patch": "@@ -756,7 +756,9 @@ dependencies = [\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"43a7bfdb147f57c498ca629c7802b57899de0bb82ae36b6f01f1540da41832f1\"\n dependencies = [\n  \"cargo_metadata\",\n  \"color-eyre\","}, {"sha": "39bc9185db3144c05c85166616125c382ca89d8a", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb071a14bd065da54c5bbc497033503932925cb2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb071a14bd065da54c5bbc497033503932925cb2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fb071a14bd065da54c5bbc497033503932925cb2", "patch": "@@ -38,7 +38,7 @@ libc = \"0.2\"\n \n [dev-dependencies]\n colored = \"2\"\n-ui_test = { path = \"ui_test\" }\n+ui_test = \"0.1\"\n # Features chosen to match those required by env_logger, to avoid rebuilds\n regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }\n lazy_static = \"1.4.0\""}, {"sha": "84bd74817090aab323b938f630f284a3f0e7b7f9", "filename": "miri", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb071a14bd065da54c5bbc497033503932925cb2/miri", "raw_url": "https://github.com/rust-lang/rust/raw/fb071a14bd065da54c5bbc497033503932925cb2/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=fb071a14bd065da54c5bbc497033503932925cb2", "patch": "@@ -186,9 +186,8 @@ test|bless)\n         export MIRI_BLESS=\"Gesundheit\"\n     fi\n     # Then test, and let caller control flags.\n-    # Only in root project and ui_test as `cargo-miri` has no tests.\n+    # Only in root project as `cargo-miri` has no tests.\n     $CARGO test $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml \"$@\"\n-    $CARGO test $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/ui_test/Cargo.toml \"$@\"\n     ;;\n run)\n     # Scan for \"--target\" to overwrite the \"MIRI_TEST_TARGET\" env var so\n@@ -219,7 +218,6 @@ fmt)\n     ;;\n clippy)\n     $CARGO clippy $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/Cargo.toml --all-targets \"$@\"\n-    $CARGO clippy $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/ui_test/Cargo.toml --all-targets \"$@\"\n     $CARGO clippy $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml \"$@\"\n     ;;\n cargo)"}, {"sha": "9addea9b19d0b8fec0d3af74bb6a2d0cb8e10d99", "filename": "ui_test/Cargo.lock", "status": "removed", "additions": 0, "deletions": 578, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FCargo.lock?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,578 +0,0 @@\n-# This file is automatically @generated by Cargo.\n-# It is not intended for manual editing.\n-version = 3\n-\n-[[package]]\n-name = \"addr2line\"\n-version = \"0.17.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n-dependencies = [\n- \"gimli\",\n-]\n-\n-[[package]]\n-name = \"adler\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n-\n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.7.18\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n-[[package]]\n-name = \"ansi_term\"\n-version = \"0.12.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n-[[package]]\n-name = \"atty\"\n-version = \"0.2.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n-dependencies = [\n- \"hermit-abi\",\n- \"libc\",\n- \"winapi\",\n-]\n-\n-[[package]]\n-name = \"autocfg\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n-\n-[[package]]\n-name = \"backtrace\"\n-version = \"0.3.65\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11a17d453482a265fd5f8479f2a3f405566e6ca627837aaddb85af8b1ab8ef61\"\n-dependencies = [\n- \"addr2line\",\n- \"cc\",\n- \"cfg-if\",\n- \"libc\",\n- \"miniz_oxide\",\n- \"object\",\n- \"rustc-demangle\",\n-]\n-\n-[[package]]\n-name = \"camino\"\n-version = \"1.0.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"869119e97797867fd90f5e22af7d0bd274bd4635ebb9eb68c04f3f513ae6c412\"\n-dependencies = [\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"cargo-platform\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cbdb825da8a5df079a43676dbe042702f1707b1109f713a01420fbb4cc71fa27\"\n-dependencies = [\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"cargo_metadata\"\n-version = \"0.15.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3abb7553d5b9b8421c6de7cb02606ff15e0c6eea7d8eadd75ef013fd636bec36\"\n-dependencies = [\n- \"camino\",\n- \"cargo-platform\",\n- \"semver\",\n- \"serde\",\n- \"serde_json\",\n-]\n-\n-[[package]]\n-name = \"cc\"\n-version = \"1.0.73\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n-\n-[[package]]\n-name = \"color-eyre\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8ebf286c900a6d5867aeff75cfee3192857bb7f24b547d4f0df2ed6baa812c90\"\n-dependencies = [\n- \"backtrace\",\n- \"color-spantrace\",\n- \"eyre\",\n- \"indenter\",\n- \"once_cell\",\n- \"owo-colors\",\n- \"tracing-error\",\n-]\n-\n-[[package]]\n-name = \"color-spantrace\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ba75b3d9449ecdccb27ecbc479fdc0b87fa2dd43d2f8298f9bf0e59aacc8dce\"\n-dependencies = [\n- \"once_cell\",\n- \"owo-colors\",\n- \"tracing-core\",\n- \"tracing-error\",\n-]\n-\n-[[package]]\n-name = \"colored\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3616f750b84d8f0de8a58bda93e08e2a81ad3f523089b05f1dffecab48c6cbd\"\n-dependencies = [\n- \"atty\",\n- \"lazy_static\",\n- \"winapi\",\n-]\n-\n-[[package]]\n-name = \"crossbeam\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-channel\"\n-version = \"0.5.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aaa7bd5fb665c6864b5f963dd9097905c54125909c7aa94c9e18507cdbe6c53\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-utils\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-deque\"\n-version = \"0.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-epoch\",\n- \"crossbeam-utils\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-epoch\"\n-version = \"0.9.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1145cf131a2c6ba0615079ab6a638f7e1973ac9c2634fcbeaaad6114246efe8c\"\n-dependencies = [\n- \"autocfg\",\n- \"cfg-if\",\n- \"crossbeam-utils\",\n- \"lazy_static\",\n- \"memoffset\",\n- \"scopeguard\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-utils\",\n-]\n-\n-[[package]]\n-name = \"crossbeam-utils\"\n-version = \"0.8.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf124c720b7686e3c2663cf54062ab0f68a88af2fb6a030e87e30bf721fcb38\"\n-dependencies = [\n- \"cfg-if\",\n- \"lazy_static\",\n-]\n-\n-[[package]]\n-name = \"ctor\"\n-version = \"0.1.22\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f877be4f7c9f246b183111634f75baa039715e3f46ce860677d3b19a69fb229c\"\n-dependencies = [\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"diff\"\n-version = \"0.1.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e25ea47919b1560c4e3b7fe0aaab9becf5b84a10325ddf7db0f0ba5e1026499\"\n-\n-[[package]]\n-name = \"eyre\"\n-version = \"0.6.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c2b6b5a29c02cdc822728b7d7b8ae1bab3e3b05d44522770ddd49722eeac7eb\"\n-dependencies = [\n- \"indenter\",\n- \"once_cell\",\n-]\n-\n-[[package]]\n-name = \"gimli\"\n-version = \"0.26.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n-\n-[[package]]\n-name = \"hermit-abi\"\n-version = \"0.1.19\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n-dependencies = [\n- \"libc\",\n-]\n-\n-[[package]]\n-name = \"indenter\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683\"\n-\n-[[package]]\n-name = \"itoa\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n-\n-[[package]]\n-name = \"lazy_static\"\n-version = \"1.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n-\n-[[package]]\n-name = \"libc\"\n-version = \"0.2.126\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n-\n-[[package]]\n-name = \"memchr\"\n-version = \"2.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n-\n-[[package]]\n-name = \"memoffset\"\n-version = \"0.6.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n-[[package]]\n-name = \"miniz_oxide\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n-dependencies = [\n- \"adler\",\n-]\n-\n-[[package]]\n-name = \"object\"\n-version = \"0.28.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n-[[package]]\n-name = \"once_cell\"\n-version = \"1.13.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n-\n-[[package]]\n-name = \"output_vt100\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"628223faebab4e3e40667ee0b2336d34a5b960ff60ea743ddfdbcf7770bcfb66\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n-[[package]]\n-name = \"owo-colors\"\n-version = \"3.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"decf7381921fea4dcb2549c5667eda59b3ec297ab7e2b5fc33eac69d2e7da87b\"\n-\n-[[package]]\n-name = \"pin-project-lite\"\n-version = \"0.2.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n-\n-[[package]]\n-name = \"pretty_assertions\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c89f989ac94207d048d92db058e4f6ec7342b0971fc58d1271ca148b799b3563\"\n-dependencies = [\n- \"ansi_term\",\n- \"ctor\",\n- \"diff\",\n- \"output_vt100\",\n-]\n-\n-[[package]]\n-name = \"proc-macro2\"\n-version = \"1.0.39\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c54b25569025b7fc9651de43004ae593a75ad88543b17178aa5e1b9c4f15f56f\"\n-dependencies = [\n- \"unicode-ident\",\n-]\n-\n-[[package]]\n-name = \"quote\"\n-version = \"1.0.18\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n-dependencies = [\n- \"proc-macro2\",\n-]\n-\n-[[package]]\n-name = \"regex\"\n-version = \"1.5.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1\"\n-dependencies = [\n- \"aho-corasick\",\n- \"memchr\",\n- \"regex-syntax\",\n-]\n-\n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.6.26\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64\"\n-\n-[[package]]\n-name = \"rustc-demangle\"\n-version = \"0.1.21\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n-\n-[[package]]\n-name = \"rustc_version\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\n-dependencies = [\n- \"semver\",\n-]\n-\n-[[package]]\n-name = \"ryu\"\n-version = \"1.0.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n-\n-[[package]]\n-name = \"scopeguard\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n-\n-[[package]]\n-name = \"semver\"\n-version = \"1.0.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cb243bdfdb5936c8dc3c45762a19d12ab4550cdc753bc247637d4ec35a040fd\"\n-dependencies = [\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"serde\"\n-version = \"1.0.137\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n-dependencies = [\n- \"serde_derive\",\n-]\n-\n-[[package]]\n-name = \"serde_derive\"\n-version = \"1.0.137\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"serde_json\"\n-version = \"1.0.81\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n-dependencies = [\n- \"itoa\",\n- \"ryu\",\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"sharded-slab\"\n-version = \"0.1.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"900fba806f70c630b0a382d0d825e17a0f19fcd059a2ade1ff237bcddf446b31\"\n-dependencies = [\n- \"lazy_static\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"1.0.95\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbaf6116ab8924f39d52792136fb74fd60a80194cf1b1c6ffa6453eef1c3f942\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"unicode-ident\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"1.1.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180\"\n-dependencies = [\n- \"once_cell\",\n-]\n-\n-[[package]]\n-name = \"tracing\"\n-version = \"0.1.35\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n-dependencies = [\n- \"cfg-if\",\n- \"pin-project-lite\",\n- \"tracing-core\",\n-]\n-\n-[[package]]\n-name = \"tracing-core\"\n-version = \"0.1.28\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7\"\n-dependencies = [\n- \"once_cell\",\n- \"valuable\",\n-]\n-\n-[[package]]\n-name = \"tracing-error\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d686ec1c0f384b1277f097b2f279a2ecc11afe8c133c1aabf036a27cb4cd206e\"\n-dependencies = [\n- \"tracing\",\n- \"tracing-subscriber\",\n-]\n-\n-[[package]]\n-name = \"tracing-subscriber\"\n-version = \"0.3.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a713421342a5a666b7577783721d3117f1b69a393df803ee17bb73b1e122a59\"\n-dependencies = [\n- \"sharded-slab\",\n- \"thread_local\",\n- \"tracing-core\",\n-]\n-\n-[[package]]\n-name = \"ui_test\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"cargo_metadata\",\n- \"color-eyre\",\n- \"colored\",\n- \"crossbeam\",\n- \"lazy_static\",\n- \"pretty_assertions\",\n- \"regex\",\n- \"rustc_version\",\n- \"serde\",\n- \"serde_json\",\n-]\n-\n-[[package]]\n-name = \"unicode-ident\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\"\n-\n-[[package]]\n-name = \"valuable\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d\"\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.3.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n-dependencies = [\n- \"winapi-i686-pc-windows-gnu\",\n- \"winapi-x86_64-pc-windows-gnu\",\n-]\n-\n-[[package]]\n-name = \"winapi-i686-pc-windows-gnu\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n-\n-[[package]]\n-name = \"winapi-x86_64-pc-windows-gnu\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "bb14eb7ecfe3091be88db83ff48f40ee28869957", "filename": "ui_test/Cargo.toml", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FCargo.toml?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,21 +0,0 @@\n-[package]\n-name = \"ui_test\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\n-[lib]\n-test = true # we have unit tests\n-doctest = false # but no doc tests\n-\n-[dependencies]\n-rustc_version = \"0.4\"\n-colored = \"2\"\n-# Features chosen to match those required by env_logger, to avoid rebuilds\n-regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }\n-pretty_assertions = \"1.2.1\"\n-crossbeam = \"0.8.1\"\n-lazy_static = \"1.4.0\"\n-serde = { version = \"1.0\", features = [\"derive\"] }\n-serde_json = \"1.0\"\n-color-eyre = { version = \"0.6.1\", default-features = false, features = [\"capture-spantrace\"] }\n-cargo_metadata = \"0.15\""}, {"sha": "3db3361faa5328c2d5ad26e9288c5b9119a7f6af", "filename": "ui_test/README.md", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FREADME.md?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,51 +0,0 @@\n-A smaller version of compiletest-rs\n-\n-## Magic behavior\n-\n-* Tests are run in order of their filenames (files first, then recursing into folders).\n-  So if you have any slow tests, prepend them with a small integral number to make them get run first, taking advantage of parallelism as much as possible (instead of waiting for the slow tests at the end).\n-\n-## Supported magic comment annotations\n-\n-If your test tests for failure, you need to add a `//~` annotation where the error is happening\n-to make sure that the test will always keep failing with a specific message at the annotated line.\n-\n-`//~ ERROR: XXX` make sure the stderr output contains `XXX` for an error in the line where this comment is written\n-\n-* Also supports `HELP`, `WARN` or `NOTE` for different kind of message\n-    * if one of those levels is specified explicitly, *all* diagnostics of this level or higher need an annotation. If you want to avoid this, just leave out the all caps level note entirely.\n-* If the all caps note is left out, a message of any level is matched. Leaving it out is not allowed for `ERROR` levels.\n-* This checks the output *before* normalization, so you can check things that get normalized away, but need to\n-    be careful not to accidentally have a pattern that differs between platforms.\n-* if `XXX` is of the form `/XXX/` it is treated as a regex instead of a substring and will succeed if the regex matches.\n-\n-In order to change how a single test is tested, you can add various `//@` comments to the test.\n-Any other comments will be ignored, and all `//@` comments must be formatted precisely as\n-their command specifies, or the test will fail without even being run.\n-\n-* `//@ignore-C` avoids running the test when condition `C` is met.\n-    * `C` can be `target-XXX`, which checks whether the target triple contains `XXX`.\n-    * `C` can also be one of `64bit`, `32bit` or `16bit`.\n-    * `C` can also be `on-host`, which will only run the test during cross compilation testing.\n-* `//@only-C` **only** runs the test when condition `C` is met. The conditions are the same as with `ignore`.\n-* `//@stderr-per-bitwidth` produces one stderr file per bitwidth, as they may differ significantly sometimes\n-* `//@error-pattern: XXX` make sure the stderr output contains `XXX`\n-* `//@revisions: XXX YYY` runs the test once for each space separated name in the list\n-    * emits one stderr file per revision\n-    * `//~` comments can be restricted to specific revisions by adding the revision name before the `~` in square brackets: `//[XXX]~`\n-* `//@compile-flags: XXX` appends `XXX` to the command line arguments passed to the rustc driver\n-    * you can specify this multiple times, and all the flags will accumulate\n-* `//@rustc-env: XXX=YYY` sets the env var `XXX` to `YYY` for the rustc driver execution.\n-    * for Miri these env vars are used during compilation via rustc and during the emulation of the program\n-    * you can specify this multiple times, accumulating all the env vars\n-* `//@normalize-stderr-test: \"REGEX\" -> \"REPLACEMENT\"` replaces all matches of `REGEX` in the stderr with `REPLACEMENT`. The replacement may specify `$1` and similar backreferences to paste captures.\n-    * you can specify multiple such commands, there is no need to create a single regex that handles multiple replacements that you want to perform.\n-* `//@require-annotations-for-level: LEVEL` can be used to change the level of diagnostics that require a corresponding annotation.\n-    * this is only useful if there are any annotations like `HELP`, `WARN` or `NOTE`, as these would automatically require annotations for all other diagnostics of the same or higher level.\n-\n-## Significant differences to compiletest-rs\n-\n-* `ignore-target-*` and `only-target-*` opereate solely on the triple, instead of supporting things like `macos`\n-* only `//~` comments can be individualized per revision\n-* only supports `ui` tests\n-* tests are run in named order, so you can prefix slow tests with `0` in order to make them get run first"}, {"sha": "582641b97ae132a6df693585e54fef10503dca93", "filename": "ui_test/src/dependencies.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fdependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fdependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fdependencies.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,137 +0,0 @@\n-use color_eyre::eyre::{bail, Result};\n-use std::{\n-    collections::{HashMap, HashSet},\n-    path::{Path, PathBuf},\n-    process::Command,\n-};\n-\n-use crate::{Config, OutputConflictHandling};\n-\n-#[derive(Default, Debug)]\n-pub struct Dependencies {\n-    /// All paths that must be imported with `-L dependency=`. This is for\n-    /// finding proc macros run on the host and dependencies for the target.\n-    pub import_paths: Vec<PathBuf>,\n-    /// The name as chosen in the `Cargo.toml` and its corresponding rmeta file.\n-    pub dependencies: Vec<(String, PathBuf)>,\n-}\n-\n-/// Compiles dependencies and returns the crate names and corresponding rmeta files.\n-pub fn build_dependencies(config: &Config) -> Result<Dependencies> {\n-    let manifest_path = match &config.dependencies_crate_manifest_path {\n-        Some(path) => path,\n-        None => return Ok(Default::default()),\n-    };\n-    let (program, args, envs): (&Path, &[_], &[_]) = match &config.dependency_builder {\n-        Some(db) => (&db.program, &db.args, &db.envs),\n-        None => (Path::new(\"cargo\"), &[], &[]),\n-    };\n-    let mut build = Command::new(program);\n-    build.args(args);\n-    // HACK: we're using `cargo run` (or `cargo miri run`), because the latter does not\n-    // support `cargo miri build` yet.\n-    build.arg(\"run\");\n-\n-    if let Some(target) = &config.target {\n-        build.arg(format!(\"--target={target}\"));\n-    }\n-\n-    // Reusable closure for setting up the environment both for artifact generation and `cargo_metadata`\n-    let setup_command = |cmd: &mut Command| {\n-        cmd.envs(envs.iter().map(|(k, v)| (k, v)));\n-        cmd.arg(\"--manifest-path\").arg(manifest_path);\n-        if matches!(config.output_conflict_handling, OutputConflictHandling::Error) {\n-            cmd.arg(\"--locked\");\n-        }\n-    };\n-\n-    setup_command(&mut build);\n-    build.arg(\"--message-format=json\");\n-\n-    let output = build.output()?;\n-\n-    if !output.status.success() {\n-        let stdout = String::from_utf8(output.stdout)?;\n-        let stderr = String::from_utf8(output.stderr)?;\n-        bail!(\"failed to compile dependencies:\\nstderr:\\n{stderr}\\n\\nstdout:{stdout}\");\n-    }\n-\n-    // Collect all artifacts generated\n-    let output = output.stdout;\n-    let output = String::from_utf8(output)?;\n-    let mut import_paths: HashSet<PathBuf> = HashSet::new();\n-    let mut artifacts: HashMap<_, _> = output\n-        .lines()\n-        .filter_map(|line| {\n-            let message = serde_json::from_str::<cargo_metadata::Message>(line).ok()?;\n-            if let cargo_metadata::Message::CompilerArtifact(artifact) = message {\n-                for filename in &artifact.filenames {\n-                    import_paths.insert(filename.parent().unwrap().into());\n-                }\n-                let filename = artifact\n-                    .filenames\n-                    .into_iter()\n-                    .find(|filename| filename.extension() == Some(\"rmeta\"))?;\n-                Some((artifact.package_id, filename.into_std_path_buf()))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect();\n-\n-    // Check which crates are mentioned in the crate itself\n-    let mut metadata = cargo_metadata::MetadataCommand::new().cargo_command();\n-    setup_command(&mut metadata);\n-    let output = metadata.output()?;\n-\n-    if !output.status.success() {\n-        let stdout = String::from_utf8(output.stdout)?;\n-        let stderr = String::from_utf8(output.stderr)?;\n-        bail!(\"failed to run cargo-metadata:\\nstderr:\\n{stderr}\\n\\nstdout:{stdout}\");\n-    }\n-\n-    let output = output.stdout;\n-    let output = String::from_utf8(output)?;\n-\n-    for line in output.lines() {\n-        if !line.starts_with('{') {\n-            continue;\n-        }\n-        let metadata: cargo_metadata::Metadata = serde_json::from_str(line)?;\n-        // Only take artifacts that are defined in the Cargo.toml\n-\n-        // First, find the root artifact\n-        let root = metadata\n-            .packages\n-            .iter()\n-            .find(|package| {\n-                package.manifest_path.as_std_path().canonicalize().unwrap()\n-                    == manifest_path.canonicalize().unwrap()\n-            })\n-            .unwrap();\n-\n-        // Then go over all of its dependencies\n-        let dependencies = root\n-            .dependencies\n-            .iter()\n-            .map(|package| {\n-                // Get the id for the package matching the version requirement of the dep\n-                let id = &metadata\n-                    .packages\n-                    .iter()\n-                    .find(|&dep| dep.name == package.name && package.req.matches(&dep.version))\n-                    .expect(\"dependency does not exist\")\n-                    .id;\n-                // Return the name chosen in `Cargo.toml` and the path to the corresponding artifact\n-                (\n-                    package.rename.clone().unwrap_or_else(|| package.name.clone()),\n-                    artifacts.remove(id).expect(\"package without artifact\"),\n-                )\n-            })\n-            .collect();\n-        let import_paths = import_paths.into_iter().collect();\n-        return Ok(Dependencies { dependencies, import_paths });\n-    }\n-\n-    bail!(\"no json found in cargo-metadata output\")\n-}"}, {"sha": "c87ac938ffd22661a17475b7b08f755650bc6bab", "filename": "ui_test/src/lib.rs", "status": "removed", "additions": 0, "deletions": 637, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Flib.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,637 +0,0 @@\n-#![allow(\n-    clippy::enum_variant_names,\n-    clippy::useless_format,\n-    clippy::too_many_arguments,\n-    rustc::internal\n-)]\n-\n-use std::collections::VecDeque;\n-use std::ffi::OsString;\n-use std::fmt::Write;\n-use std::path::{Path, PathBuf};\n-use std::process::{Command, ExitStatus};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::sync::Mutex;\n-\n-pub use color_eyre;\n-use color_eyre::eyre::Result;\n-use colored::*;\n-use parser::{ErrorMatch, Pattern};\n-use regex::Regex;\n-use rustc_stderr::{Level, Message};\n-\n-use crate::dependencies::build_dependencies;\n-use crate::parser::{Comments, Condition};\n-\n-mod dependencies;\n-mod parser;\n-mod rustc_stderr;\n-#[cfg(test)]\n-mod tests;\n-\n-#[derive(Debug)]\n-pub struct Config {\n-    /// Arguments passed to the binary that is executed.\n-    pub args: Vec<OsString>,\n-    /// `None` to run on the host, otherwise a target triple\n-    pub target: Option<String>,\n-    /// Filters applied to stderr output before processing it\n-    pub stderr_filters: Filter,\n-    /// Filters applied to stdout output before processing it\n-    pub stdout_filters: Filter,\n-    /// The folder in which to start searching for .rs files\n-    pub root_dir: PathBuf,\n-    pub mode: Mode,\n-    pub program: PathBuf,\n-    pub output_conflict_handling: OutputConflictHandling,\n-    /// Only run tests with one of these strings in their path/name\n-    pub path_filter: Vec<String>,\n-    /// Path to a `Cargo.toml` that describes which dependencies the tests can access.\n-    pub dependencies_crate_manifest_path: Option<PathBuf>,\n-    /// Can be used to override what command to run instead of `cargo` to build the\n-    /// dependencies in `manifest_path`\n-    pub dependency_builder: Option<DependencyBuilder>,\n-    /// Print one character per test instead of one line\n-    pub quiet: bool,\n-}\n-\n-#[derive(Debug)]\n-pub struct DependencyBuilder {\n-    pub program: PathBuf,\n-    pub args: Vec<String>,\n-    pub envs: Vec<(String, OsString)>,\n-}\n-\n-#[derive(Debug)]\n-pub enum OutputConflictHandling {\n-    /// The default: emit a diff of the expected/actual output.\n-    Error,\n-    /// Ignore mismatches in the stderr/stdout files.\n-    Ignore,\n-    /// Instead of erroring if the stderr/stdout differs from the expected\n-    /// automatically replace it with the found output (after applying filters).\n-    Bless,\n-}\n-\n-pub type Filter = Vec<(Regex, &'static str)>;\n-\n-pub fn run_tests(mut config: Config) -> Result<()> {\n-    eprintln!(\"   Compiler flags: {:?}\", config.args);\n-\n-    // Get the triple with which to run the tests\n-    let target = config.target.clone().unwrap_or_else(|| config.get_host());\n-\n-    eprintln!(\"   Building test dependencies...\");\n-    let dependencies = build_dependencies(&config)?;\n-    for (name, dependency) in dependencies.dependencies {\n-        config.args.push(\"--extern\".into());\n-        let mut dep = OsString::from(name);\n-        dep.push(\"=\");\n-        dep.push(dependency);\n-        config.args.push(dep);\n-    }\n-    for import_path in dependencies.import_paths {\n-        config.args.push(\"-L\".into());\n-        config.args.push(import_path.into());\n-    }\n-    let config = config;\n-\n-    // A channel for files to process\n-    let (submit, receive) = crossbeam::channel::unbounded();\n-\n-    // Some statistics and failure reports.\n-    let failures = Mutex::new(vec![]);\n-    let succeeded = AtomicUsize::default();\n-    let ignored = AtomicUsize::default();\n-    let filtered = AtomicUsize::default();\n-\n-    crossbeam::scope(|s| -> Result<()> {\n-        // Create a thread that is in charge of walking the directory and submitting jobs.\n-        // It closes the channel when it is done.\n-        s.spawn(|_| {\n-            let mut todo = VecDeque::new();\n-            todo.push_back(config.root_dir.clone());\n-            while let Some(path) = todo.pop_front() {\n-                if path.is_dir() {\n-                    // Enqueue everything inside this directory.\n-                    // We want it sorted, to have some control over scheduling of slow tests.\n-                    let mut entries =\n-                        std::fs::read_dir(path).unwrap().collect::<Result<Vec<_>, _>>().unwrap();\n-                    entries.sort_by_key(|e| e.file_name());\n-                    for entry in entries {\n-                        todo.push_back(entry.path());\n-                    }\n-                } else if path.extension().map(|ext| ext == \"rs\").unwrap_or(false) {\n-                    // Forward .rs files to the test workers.\n-                    submit.send(path).unwrap();\n-                }\n-            }\n-            // There will be no more jobs. This signals the workers to quit.\n-            // (This also ensures `submit` is moved into this closure.)\n-            drop(submit);\n-        });\n-\n-        // A channel for the messages emitted by the individual test threads.\n-        let (finished_files_sender, finished_files_recv) = crossbeam::channel::unbounded();\n-        enum TestResult {\n-            Ok,\n-            Failed,\n-            Ignored,\n-        }\n-\n-        s.spawn(|_| {\n-            if config.quiet {\n-                for (i, (_, result)) in finished_files_recv.into_iter().enumerate() {\n-                    // Humans start counting at 1\n-                    let i = i + 1;\n-                    match result {\n-                        TestResult::Ok => eprint!(\"{}\", \".\".green()),\n-                        TestResult::Failed => eprint!(\"{}\", \"F\".red().bold()),\n-                        TestResult::Ignored => eprint!(\"{}\", \"i\".yellow()),\n-                    }\n-                    if i % 100 == 0 {\n-                        eprintln!(\" {i}\");\n-                    }\n-                }\n-            } else {\n-                for (msg, result) in finished_files_recv {\n-                    eprint!(\"{msg} ... \");\n-                    eprintln!(\n-                        \"{}\",\n-                        match result {\n-                            TestResult::Ok => \"ok\".green(),\n-                            TestResult::Failed => \"FAILED\".red().bold(),\n-                            TestResult::Ignored => \"ignored (in-test comment)\".yellow(),\n-                        }\n-                    );\n-                }\n-            }\n-        });\n-\n-        let mut threads = vec![];\n-\n-        // Create N worker threads that receive files to test.\n-        for _ in 0..std::thread::available_parallelism().unwrap().get() {\n-            let finished_files_sender = finished_files_sender.clone();\n-            threads.push(s.spawn(|_| -> Result<()> {\n-                let finished_files_sender = finished_files_sender;\n-                for path in &receive {\n-                    if !config.path_filter.is_empty() {\n-                        let path_display = path.display().to_string();\n-                        if !config.path_filter.iter().any(|filter| path_display.contains(filter)) {\n-                            filtered.fetch_add(1, Ordering::Relaxed);\n-                            continue;\n-                        }\n-                    }\n-                    let comments = Comments::parse_file(&path)?;\n-                    // Ignore file if only/ignore rules do (not) apply\n-                    if !test_file_conditions(&comments, &target, &config) {\n-                        ignored.fetch_add(1, Ordering::Relaxed);\n-                        finished_files_sender\n-                            .send((path.display().to_string(), TestResult::Ignored))?;\n-                        continue;\n-                    }\n-                    // Run the test for all revisions\n-                    for revision in\n-                        comments.revisions.clone().unwrap_or_else(|| vec![String::new()])\n-                    {\n-                        let (m, errors, stderr) =\n-                            run_test(&path, &config, &target, &revision, &comments);\n-\n-                        // Using a single `eprintln!` to prevent messages from threads from getting intermingled.\n-                        let mut msg = format!(\"{}\", path.display());\n-                        if !revision.is_empty() {\n-                            write!(msg, \" (revision `{revision}`) \").unwrap();\n-                        }\n-                        if errors.is_empty() {\n-                            finished_files_sender.send((msg, TestResult::Ok))?;\n-                            succeeded.fetch_add(1, Ordering::Relaxed);\n-                        } else {\n-                            finished_files_sender.send((msg, TestResult::Failed))?;\n-                            failures.lock().unwrap().push((\n-                                path.clone(),\n-                                m,\n-                                revision,\n-                                errors,\n-                                stderr,\n-                            ));\n-                        }\n-                    }\n-                }\n-                Ok(())\n-            }));\n-        }\n-\n-        for thread in threads {\n-            thread.join().unwrap()?;\n-        }\n-        Ok(())\n-    })\n-    .unwrap()?;\n-\n-    // Print all errors in a single thread to show reliable output\n-    let failures = failures.into_inner().unwrap();\n-    let succeeded = succeeded.load(Ordering::Relaxed);\n-    let ignored = ignored.load(Ordering::Relaxed);\n-    let filtered = filtered.load(Ordering::Relaxed);\n-    if !failures.is_empty() {\n-        for (path, miri, revision, errors, stderr) in &failures {\n-            eprintln!();\n-            eprint!(\"{}\", path.display().to_string().underline().bold());\n-            if !revision.is_empty() {\n-                eprint!(\" (revision `{}`)\", revision);\n-            }\n-            eprint!(\" {}\", \"FAILED:\".red().bold());\n-            eprintln!();\n-            eprintln!(\"command: {:?}\", miri);\n-            eprintln!();\n-            for error in errors {\n-                match error {\n-                    Error::ExitStatus(mode, exit_status) => eprintln!(\"{mode:?} got {exit_status}\"),\n-                    Error::PatternNotFound { pattern, definition_line } => {\n-                        match pattern {\n-                            Pattern::SubString(s) =>\n-                                eprintln!(\"substring `{s}` {} in stderr output\", \"not found\".red()),\n-                            Pattern::Regex(r) =>\n-                                eprintln!(\"`/{r}/` does {} stderr output\", \"not match\".red()),\n-                        }\n-                        eprintln!(\n-                            \"expected because of pattern here: {}:{definition_line}\",\n-                            path.display().to_string().bold()\n-                        );\n-                    }\n-                    Error::NoPatternsFound => {\n-                        eprintln!(\"{}\", \"no error patterns found in failure test\".red());\n-                    }\n-                    Error::PatternFoundInPassTest =>\n-                        eprintln!(\"{}\", \"error pattern found in success test\".red()),\n-                    Error::OutputDiffers { path, actual, expected } => {\n-                        eprintln!(\"actual output differed from expected {}\", path.display());\n-                        eprintln!(\"{}\", pretty_assertions::StrComparison::new(expected, actual));\n-                        eprintln!()\n-                    }\n-                    Error::ErrorsWithoutPattern { path: None, msgs } => {\n-                        eprintln!(\n-                            \"There were {} unmatched diagnostics that occurred outside the testfile and had no pattern\",\n-                            msgs.len(),\n-                        );\n-                        for Message { level, message } in msgs {\n-                            eprintln!(\"    {level:?}: {message}\")\n-                        }\n-                    }\n-                    Error::ErrorsWithoutPattern { path: Some((path, line)), msgs } => {\n-                        eprintln!(\n-                            \"There were {} unmatched diagnostics at {}:{line}\",\n-                            msgs.len(),\n-                            path.display()\n-                        );\n-                        for Message { level, message } in msgs {\n-                            eprintln!(\"    {level:?}: {message}\")\n-                        }\n-                    }\n-                }\n-                eprintln!();\n-            }\n-            eprintln!(\"full stderr:\");\n-            eprintln!(\"{}\", stderr);\n-            eprintln!();\n-        }\n-        eprintln!(\"{}\", \"FAILURES:\".red().underline().bold());\n-        for (path, _miri, _revision, _errors, _stderr) in &failures {\n-            eprintln!(\"    {}\", path.display());\n-        }\n-        eprintln!();\n-        eprintln!(\n-            \"test result: {}. {} tests failed, {} tests passed, {} ignored, {} filtered out\",\n-            \"FAIL\".red(),\n-            failures.len().to_string().red().bold(),\n-            succeeded.to_string().green(),\n-            ignored.to_string().yellow(),\n-            filtered.to_string().yellow(),\n-        );\n-        std::process::exit(1);\n-    }\n-    eprintln!();\n-    eprintln!(\n-        \"test result: {}. {} tests passed, {} ignored, {} filtered out\",\n-        \"ok\".green(),\n-        succeeded.to_string().green(),\n-        ignored.to_string().yellow(),\n-        filtered.to_string().yellow(),\n-    );\n-    eprintln!();\n-    Ok(())\n-}\n-\n-#[derive(Debug)]\n-enum Error {\n-    /// Got an invalid exit status for the given mode.\n-    ExitStatus(Mode, ExitStatus),\n-    PatternNotFound {\n-        pattern: Pattern,\n-        definition_line: usize,\n-    },\n-    /// A ui test checking for failure does not have any failure patterns\n-    NoPatternsFound,\n-    /// A ui test checking for success has failure patterns\n-    PatternFoundInPassTest,\n-    /// Stderr/Stdout differed from the `.stderr`/`.stdout` file present.\n-    OutputDiffers {\n-        path: PathBuf,\n-        actual: String,\n-        expected: String,\n-    },\n-    ErrorsWithoutPattern {\n-        msgs: Vec<Message>,\n-        path: Option<(PathBuf, usize)>,\n-    },\n-}\n-\n-type Errors = Vec<Error>;\n-\n-fn run_test(\n-    path: &Path,\n-    config: &Config,\n-    target: &str,\n-    revision: &str,\n-    comments: &Comments,\n-) -> (Command, Errors, String) {\n-    // Run miri\n-    let mut miri = Command::new(&config.program);\n-    miri.args(config.args.iter());\n-    miri.arg(path);\n-    if !revision.is_empty() {\n-        miri.arg(format!(\"--cfg={revision}\"));\n-    }\n-    miri.arg(\"--error-format=json\");\n-    for arg in &comments.compile_flags {\n-        miri.arg(arg);\n-    }\n-    miri.envs(comments.env_vars.iter().map(|(k, v)| (k, v)));\n-    let output = miri.output().expect(\"could not execute miri\");\n-    let mut errors = config.mode.ok(output.status);\n-    let stderr = check_test_result(\n-        path,\n-        config,\n-        target,\n-        revision,\n-        comments,\n-        &mut errors,\n-        &output.stdout,\n-        &output.stderr,\n-    );\n-    (miri, errors, stderr)\n-}\n-\n-fn check_test_result(\n-    path: &Path,\n-    config: &Config,\n-    target: &str,\n-    revision: &str,\n-    comments: &Comments,\n-    errors: &mut Errors,\n-    stdout: &[u8],\n-    stderr: &[u8],\n-) -> String {\n-    // Always remove annotation comments from stderr.\n-    let diagnostics = rustc_stderr::process(path, stderr);\n-    let stdout = std::str::from_utf8(stdout).unwrap();\n-    // Check output files (if any)\n-    let revised = |extension: &str| {\n-        if revision.is_empty() {\n-            extension.to_string()\n-        } else {\n-            format!(\"{}.{}\", revision, extension)\n-        }\n-    };\n-    // Check output files against actual output\n-    check_output(\n-        &diagnostics.rendered,\n-        path,\n-        errors,\n-        revised(\"stderr\"),\n-        target,\n-        &config.stderr_filters,\n-        config,\n-        comments,\n-    );\n-    check_output(\n-        stdout,\n-        path,\n-        errors,\n-        revised(\"stdout\"),\n-        target,\n-        &config.stdout_filters,\n-        config,\n-        comments,\n-    );\n-    // Check error annotations in the source against output\n-    check_annotations(\n-        diagnostics.messages,\n-        diagnostics.messages_from_unknown_file_or_line,\n-        path,\n-        errors,\n-        config,\n-        revision,\n-        comments,\n-    );\n-    diagnostics.rendered\n-}\n-\n-fn check_annotations(\n-    mut messages: Vec<Vec<Message>>,\n-    mut messages_from_unknown_file_or_line: Vec<Message>,\n-    path: &Path,\n-    errors: &mut Errors,\n-    config: &Config,\n-    revision: &str,\n-    comments: &Comments,\n-) {\n-    if let Some((ref error_pattern, definition_line)) = comments.error_pattern {\n-        // first check the diagnostics messages outside of our file. We check this first, so that\n-        // you can mix in-file annotations with //@error-pattern annotations, even if there is overlap\n-        // in the messages.\n-        if let Some(i) = messages_from_unknown_file_or_line\n-            .iter()\n-            .position(|msg| error_pattern.matches(&msg.message))\n-        {\n-            messages_from_unknown_file_or_line.remove(i);\n-        } else {\n-            errors.push(Error::PatternNotFound { pattern: error_pattern.clone(), definition_line });\n-        }\n-    }\n-\n-    // The order on `Level` is such that `Error` is the highest level.\n-    // We will ensure that *all* diagnostics of level at least `lowest_annotation_level`\n-    // are matched.\n-    let mut lowest_annotation_level = Level::Error;\n-    for &ErrorMatch { ref pattern, revision: ref rev, definition_line, line, level } in\n-        &comments.error_matches\n-    {\n-        if let Some(rev) = rev {\n-            if rev != revision {\n-                continue;\n-            }\n-        }\n-\n-        // If we found a diagnostic with a level annotation, make sure that all\n-        // diagnostics of that level have annotations, even if we don't end up finding a matching diagnostic\n-        // for this pattern.\n-        lowest_annotation_level = std::cmp::min(lowest_annotation_level, level);\n-\n-        if let Some(msgs) = messages.get_mut(line) {\n-            let found =\n-                msgs.iter().position(|msg| pattern.matches(&msg.message) && msg.level == level);\n-            if let Some(found) = found {\n-                msgs.remove(found);\n-                continue;\n-            }\n-        }\n-\n-        errors.push(Error::PatternNotFound { pattern: pattern.clone(), definition_line });\n-    }\n-\n-    let filter = |msgs: Vec<Message>| -> Vec<_> {\n-        msgs.into_iter()\n-            .filter(|msg| {\n-                msg.level\n-                    >= comments.require_annotations_for_level.unwrap_or(lowest_annotation_level)\n-            })\n-            .collect()\n-    };\n-\n-    let messages_from_unknown_file_or_line = filter(messages_from_unknown_file_or_line);\n-    if !messages_from_unknown_file_or_line.is_empty() {\n-        errors.push(Error::ErrorsWithoutPattern {\n-            path: None,\n-            msgs: messages_from_unknown_file_or_line,\n-        });\n-    }\n-\n-    for (line, msgs) in messages.into_iter().enumerate() {\n-        let msgs = filter(msgs);\n-        if !msgs.is_empty() {\n-            errors\n-                .push(Error::ErrorsWithoutPattern { path: Some((path.to_path_buf(), line)), msgs });\n-        }\n-    }\n-\n-    match (config.mode, comments.error_pattern.is_some() || !comments.error_matches.is_empty()) {\n-        (Mode::Pass, true) | (Mode::Panic, true) => errors.push(Error::PatternFoundInPassTest),\n-        (Mode::Fail, false) => errors.push(Error::NoPatternsFound),\n-        _ => {}\n-    }\n-}\n-\n-fn check_output(\n-    output: &str,\n-    path: &Path,\n-    errors: &mut Errors,\n-    kind: String,\n-    target: &str,\n-    filters: &Filter,\n-    config: &Config,\n-    comments: &Comments,\n-) {\n-    let output = normalize(path, output, filters, comments);\n-    let path = output_path(path, comments, kind, target);\n-    match config.output_conflict_handling {\n-        OutputConflictHandling::Bless =>\n-            if output.is_empty() {\n-                let _ = std::fs::remove_file(path);\n-            } else {\n-                std::fs::write(path, &output).unwrap();\n-            },\n-        OutputConflictHandling::Error => {\n-            let expected_output = std::fs::read_to_string(&path).unwrap_or_default();\n-            if output != expected_output {\n-                errors.push(Error::OutputDiffers {\n-                    path,\n-                    actual: output,\n-                    expected: expected_output,\n-                });\n-            }\n-        }\n-        OutputConflictHandling::Ignore => {}\n-    }\n-}\n-\n-fn output_path(path: &Path, comments: &Comments, kind: String, target: &str) -> PathBuf {\n-    if comments.stderr_per_bitwidth {\n-        return path.with_extension(format!(\"{}bit.{kind}\", get_pointer_width(target)));\n-    }\n-    path.with_extension(kind)\n-}\n-\n-fn test_condition(condition: &Condition, target: &str, config: &Config) -> bool {\n-    match condition {\n-        Condition::Bitwidth(bits) => get_pointer_width(target) == *bits,\n-        Condition::Target(t) => target.contains(t),\n-        Condition::OnHost => config.target.is_none(),\n-    }\n-}\n-\n-/// Returns whether according to the in-file conditions, this file should be run.\n-fn test_file_conditions(comments: &Comments, target: &str, config: &Config) -> bool {\n-    if comments.ignore.iter().any(|c| test_condition(c, target, config)) {\n-        return false;\n-    }\n-    comments.only.iter().all(|c| test_condition(c, target, config))\n-}\n-\n-// Taken 1:1 from compiletest-rs\n-fn get_pointer_width(triple: &str) -> u8 {\n-    if (triple.contains(\"64\") && !triple.ends_with(\"gnux32\") && !triple.ends_with(\"gnu_ilp32\"))\n-        || triple.starts_with(\"s390x\")\n-    {\n-        64\n-    } else if triple.starts_with(\"avr\") {\n-        16\n-    } else {\n-        32\n-    }\n-}\n-\n-fn normalize(path: &Path, text: &str, filters: &Filter, comments: &Comments) -> String {\n-    // Useless paths\n-    let mut text = text.replace(&path.parent().unwrap().display().to_string(), \"$DIR\");\n-    if let Some(lib_path) = option_env!(\"RUSTC_LIB_PATH\") {\n-        text = text.replace(lib_path, \"RUSTLIB\");\n-    }\n-\n-    for (regex, replacement) in filters.iter() {\n-        text = regex.replace_all(&text, *replacement).to_string();\n-    }\n-\n-    for (from, to) in &comments.normalize_stderr {\n-        text = from.replace_all(&text, to).to_string();\n-    }\n-    text\n-}\n-\n-impl Config {\n-    fn get_host(&self) -> String {\n-        rustc_version::VersionMeta::for_command(std::process::Command::new(&self.program))\n-            .expect(\"failed to parse rustc version info\")\n-            .host\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum Mode {\n-    // The test passes a full execution of the rustc driver\n-    Pass,\n-    // The rustc driver panicked\n-    Panic,\n-    // The rustc driver emitted an error\n-    Fail,\n-}\n-\n-impl Mode {\n-    fn ok(self, status: ExitStatus) -> Errors {\n-        match (status.code(), self) {\n-            (Some(1), Mode::Fail) | (Some(101), Mode::Panic) | (Some(0), Mode::Pass) => vec![],\n-            _ => vec![Error::ExitStatus(self, status)],\n-        }\n-    }\n-}"}, {"sha": "d583e625facee2b119829a40229ff91b8ba91f79", "filename": "ui_test/src/parser.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fparser.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,327 +0,0 @@\n-use std::path::Path;\n-\n-use regex::Regex;\n-\n-use crate::rustc_stderr::Level;\n-\n-use color_eyre::eyre::{bail, ensure, eyre, Result};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// This crate supports various magic comments that get parsed as file-specific\n-/// configuration values. This struct parses them all in one go and then they\n-/// get processed by their respective use sites.\n-#[derive(Default, Debug)]\n-pub(crate) struct Comments {\n-    /// List of revision names to execute. Can only be speicified once\n-    pub revisions: Option<Vec<String>>,\n-    /// Don't run this test if any of these filters apply\n-    pub ignore: Vec<Condition>,\n-    /// Only run this test if all of these filters apply\n-    pub only: Vec<Condition>,\n-    /// Generate one .stderr file per bit width, by prepending with `.64bit` and similar\n-    pub stderr_per_bitwidth: bool,\n-    /// Additional flags to pass to the executable\n-    pub compile_flags: Vec<String>,\n-    /// Additional env vars to set for the executable\n-    pub env_vars: Vec<(String, String)>,\n-    /// Normalizations to apply to the stderr output before emitting it to disk\n-    pub normalize_stderr: Vec<(Regex, String)>,\n-    /// An arbitrary pattern to look for in the stderr.\n-    pub error_pattern: Option<(Pattern, usize)>,\n-    pub error_matches: Vec<ErrorMatch>,\n-    /// Ignore diagnostics below this level.\n-    /// `None` means pick the lowest level from the `error_pattern`s.\n-    pub require_annotations_for_level: Option<Level>,\n-}\n-\n-/// The conditions used for \"ignore\" and \"only\" filters.\n-#[derive(Debug)]\n-pub(crate) enum Condition {\n-    /// The given string must appear in the target.\n-    Target(String),\n-    /// Tests that the bitwidth is the given one.\n-    Bitwidth(u8),\n-    /// Tests that the target is the host.\n-    OnHost,\n-}\n-\n-#[derive(Debug, Clone)]\n-pub(crate) enum Pattern {\n-    SubString(String),\n-    Regex(Regex),\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct ErrorMatch {\n-    pub pattern: Pattern,\n-    pub revision: Option<String>,\n-    pub level: Level,\n-    /// The line where the message was defined, for reporting issues with it (e.g. in case it wasn't found).\n-    pub definition_line: usize,\n-    /// The line this pattern is expecting to find a message in.\n-    pub line: usize,\n-}\n-\n-impl Condition {\n-    fn parse(c: &str) -> Result<Self> {\n-        if c == \"on-host\" {\n-            Ok(Condition::OnHost)\n-        } else if let Some(bits) = c.strip_suffix(\"bit\") {\n-            let bits: u8 = bits.parse().map_err(|_err| {\n-                eyre!(\"invalid ignore/only filter ending in 'bit': {c:?} is not a valid bitwdith\")\n-            })?;\n-            Ok(Condition::Bitwidth(bits))\n-        } else if let Some(target) = c.strip_prefix(\"target-\") {\n-            Ok(Condition::Target(target.to_owned()))\n-        } else {\n-            Err(eyre!(\"invalid ignore/only condition {c:?}\"))\n-        }\n-    }\n-}\n-\n-impl Comments {\n-    pub(crate) fn parse_file(path: &Path) -> Result<Self> {\n-        let content = std::fs::read_to_string(path)?;\n-        Self::parse(path, &content)\n-    }\n-\n-    /// Parse comments in `content`.\n-    /// `path` is only used to emit diagnostics if parsing fails.\n-    pub(crate) fn parse(path: &Path, content: &str) -> Result<Self> {\n-        let mut this = Self::default();\n-\n-        let mut fallthrough_to = None; // The line that a `|` will refer to.\n-        for (l, line) in content.lines().enumerate() {\n-            let l = l + 1; // enumerate starts at 0, but line numbers start at 1\n-            this.parse_checked_line(l, &mut fallthrough_to, line).map_err(|err| {\n-                err.wrap_err(format!(\"{}:{l}: failed to parse annotation\", path.display()))\n-            })?;\n-        }\n-        Ok(this)\n-    }\n-\n-    fn parse_checked_line(\n-        &mut self,\n-        l: usize,\n-        fallthrough_to: &mut Option<usize>,\n-        line: &str,\n-    ) -> Result<()> {\n-        if let Some((_, command)) = line.split_once(\"//@\") {\n-            self.parse_command(command.trim(), l)\n-        } else if let Some((_, pattern)) = line.split_once(\"//~\") {\n-            self.parse_pattern(pattern, fallthrough_to, l)\n-        } else if let Some((_, pattern)) = line.split_once(\"//[\") {\n-            self.parse_revisioned_pattern(pattern, fallthrough_to, l)\n-        } else {\n-            *fallthrough_to = None;\n-            Ok(())\n-        }\n-    }\n-\n-    fn parse_command(&mut self, command: &str, l: usize) -> Result<()> {\n-        // Commands are letters or dashes, grab everything until the first character that is neither of those.\n-        let (command, args) =\n-            match command.chars().position(|c: char| !c.is_alphanumeric() && c != '-') {\n-                None => (command, \"\"),\n-                Some(i) => {\n-                    let (command, args) = command.split_at(i);\n-                    let mut args = args.chars();\n-                    // Commands are separated from their arguments by ':' or ' '\n-                    let next = args\n-                        .next()\n-                        .expect(\"the `position` above guarantees that there is at least one char\");\n-                    ensure!(next == ':', \"test command must be followed by : (or end the line)\");\n-                    (command, args.as_str().trim())\n-                }\n-            };\n-\n-        match command {\n-            \"revisions\" => {\n-                ensure!(self.revisions.is_none(), \"cannot specifiy revisions twice\");\n-                self.revisions = Some(args.split_whitespace().map(|s| s.to_string()).collect());\n-            }\n-            \"compile-flags\" => {\n-                self.compile_flags.extend(args.split_whitespace().map(|s| s.to_string()));\n-            }\n-            \"rustc-env\" =>\n-                for env in args.split_whitespace() {\n-                    let (k, v) = env.split_once('=').ok_or_else(|| {\n-                        eyre!(\"environment variables must be key/value pairs separated by a `=`\")\n-                    })?;\n-                    self.env_vars.push((k.to_string(), v.to_string()));\n-                },\n-            \"normalize-stderr-test\" => {\n-                /// Parses a string literal. `s` has to start with `\"`; everything until the next `\"` is\n-                /// returned in the first component. `\\` can be used to escape arbitrary character.\n-                /// Second return component is the rest of the string with leading whitespace removed.\n-                fn parse_str(s: &str) -> Result<(&str, &str)> {\n-                    let mut chars = s.char_indices();\n-                    match chars.next().ok_or_else(|| eyre!(\"missing arguments\"))?.1 {\n-                        '\"' => {\n-                            let s = chars.as_str();\n-                            let mut escaped = false;\n-                            for (i, c) in chars {\n-                                if escaped {\n-                                    // Accept any character as literal after a `\\`.\n-                                    escaped = false;\n-                                } else if c == '\"' {\n-                                    return Ok((&s[..(i - 1)], s[i..].trim_start()));\n-                                } else {\n-                                    escaped = c == '\\\\';\n-                                }\n-                            }\n-                            bail!(\"no closing quotes found for {s}\")\n-                        }\n-                        c => bail!(\"expected '\\\"', got {c}\"),\n-                    }\n-                }\n-\n-                let (from, rest) = parse_str(args)?;\n-\n-                let to = rest.strip_prefix(\"->\").ok_or_else(|| {\n-                    eyre!(\"normalize-stderr-test needs a pattern and replacement separated by `->`\")\n-                })?.trim_start();\n-                let (to, rest) = parse_str(to)?;\n-\n-                ensure!(rest.is_empty(), \"trailing text after pattern replacement: {rest}\");\n-\n-                let from = Regex::new(from)?;\n-                self.normalize_stderr.push((from, to.to_string()));\n-            }\n-            \"error-pattern\" => {\n-                ensure!(\n-                    self.error_pattern.is_none(),\n-                    \"cannot specifiy error_pattern twice, previous: {:?}\",\n-                    self.error_pattern\n-                );\n-                self.error_pattern = Some((Pattern::parse(args.trim())?, l));\n-            }\n-            \"stderr-per-bitwidth\" => {\n-                // args are ignored (can be used as comment)\n-                ensure!(!self.stderr_per_bitwidth, \"cannot specifiy stderr-per-bitwidth twice\");\n-                self.stderr_per_bitwidth = true;\n-            }\n-            \"require-annotations-for-level\" => {\n-                ensure!(\n-                    self.require_annotations_for_level.is_none(),\n-                    \"cannot specify `require-annotations-for-level` twice\"\n-                );\n-                self.require_annotations_for_level = Some(args.trim().parse()?);\n-            }\n-            command => {\n-                if let Some(s) = command.strip_prefix(\"ignore-\") {\n-                    // args are ignored (can be sue as comment)\n-                    self.ignore.push(Condition::parse(s)?);\n-                    return Ok(());\n-                }\n-\n-                if let Some(s) = command.strip_prefix(\"only-\") {\n-                    // args are ignored (can be sue as comment)\n-                    self.only.push(Condition::parse(s)?);\n-                    return Ok(());\n-                }\n-                bail!(\"unknown command {command}\");\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn parse_pattern(\n-        &mut self,\n-        pattern: &str,\n-        fallthrough_to: &mut Option<usize>,\n-        l: usize,\n-    ) -> Result<()> {\n-        self.parse_pattern_inner(pattern, fallthrough_to, None, l)\n-    }\n-\n-    fn parse_revisioned_pattern(\n-        &mut self,\n-        pattern: &str,\n-        fallthrough_to: &mut Option<usize>,\n-        l: usize,\n-    ) -> Result<()> {\n-        let (revision, pattern) =\n-            pattern.split_once(']').ok_or_else(|| eyre!(\"`//[` without corresponding `]`\"))?;\n-        if let Some(pattern) = pattern.strip_prefix('~') {\n-            self.parse_pattern_inner(pattern, fallthrough_to, Some(revision.to_owned()), l)\n-        } else {\n-            bail!(\"revisioned pattern must have `~` following the `]`\");\n-        }\n-    }\n-\n-    // parse something like (?P<offset>\\||[\\^]+)? *(?P<level>ERROR|HELP|WARN|NOTE): (?P<text>.*)\n-    fn parse_pattern_inner(\n-        &mut self,\n-        pattern: &str,\n-        fallthrough_to: &mut Option<usize>,\n-        revision: Option<String>,\n-        l: usize,\n-    ) -> Result<()> {\n-        let (match_line, pattern) =\n-            match pattern.chars().next().ok_or_else(|| eyre!(\"no pattern specified\"))? {\n-                '|' =>\n-                    (\n-                        *fallthrough_to\n-                            .as_mut()\n-                            .ok_or_else(|| eyre!(\"`//~|` pattern without preceding line\"))?,\n-                        &pattern[1..],\n-                    ),\n-                '^' => {\n-                    let offset = pattern.chars().take_while(|&c| c == '^').count();\n-                    (l - offset, &pattern[offset..])\n-                }\n-                _ => (l, pattern),\n-            };\n-\n-        let pattern = pattern.trim_start();\n-        let offset = pattern\n-            .chars()\n-            .position(|c| !matches!(c, 'A'..='Z' | 'a'..='z'))\n-            .ok_or_else(|| eyre!(\"pattern without level\"))?;\n-\n-        let level = pattern[..offset].parse()?;\n-        let pattern = &pattern[offset..];\n-        let pattern = pattern.strip_prefix(':').ok_or_else(|| eyre!(\"no `:` after level found\"))?;\n-\n-        let pattern = pattern.trim();\n-\n-        ensure!(!pattern.is_empty(), \"no pattern specified\");\n-\n-        let pattern = Pattern::parse(pattern)?;\n-\n-        *fallthrough_to = Some(match_line);\n-\n-        self.error_matches.push(ErrorMatch {\n-            pattern,\n-            revision,\n-            level,\n-            definition_line: l,\n-            line: match_line,\n-        });\n-\n-        Ok(())\n-    }\n-}\n-\n-impl Pattern {\n-    pub(crate) fn matches(&self, message: &str) -> bool {\n-        match self {\n-            Pattern::SubString(s) => message.contains(s),\n-            Pattern::Regex(r) => r.is_match(message),\n-        }\n-    }\n-\n-    pub(crate) fn parse(pattern: &str) -> Result<Self> {\n-        if let Some(pattern) = pattern.strip_prefix('/') {\n-            let regex =\n-                pattern.strip_suffix('/').ok_or_else(|| eyre!(\"regex must end with `/`\"))?;\n-            Ok(Pattern::Regex(Regex::new(regex)?))\n-        } else {\n-            Ok(Pattern::SubString(pattern.to_string()))\n-        }\n-    }\n-}"}, {"sha": "343857d44bd35d5b87fd95354777c65af8731146", "filename": "ui_test/src/parser/tests.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fparser%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Fparser%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fparser%2Ftests.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,85 +0,0 @@\n-use std::path::Path;\n-\n-use crate::parser::Pattern;\n-\n-use super::Comments;\n-\n-#[test]\n-fn parse_simple_comment() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address $HEX is unallocated)\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    println!(\"parsed comments: {:#?}\", comments);\n-    assert_eq!(comments.error_matches[0].definition_line, 5);\n-    assert_eq!(comments.error_matches[0].revision, None);\n-    match &comments.error_matches[0].pattern {\n-        Pattern::SubString(s) =>\n-            assert_eq!(s, \"encountered a dangling reference (address $HEX is unallocated)\"),\n-        other => panic!(\"expected substring, got {other:?}\"),\n-    }\n-}\n-\n-#[test]\n-fn parse_missing_level() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ encountered a dangling reference (address $HEX is unallocated)\n-}\n-    \";\n-    assert!(Comments::parse(Path::new(\"<dummy>\"), s).is_err(), \"expected parsing to fail\");\n-}\n-\n-#[test]\n-fn parse_slash_slash_at() {\n-    let s = r\"\n-//@  error-pattern:  foomp\n-use std::mem;\n-\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    println!(\"parsed comments: {:#?}\", comments);\n-    let pat = comments.error_pattern.unwrap();\n-    assert_eq!(format!(\"{:?}\", pat.0), r#\"SubString(\"foomp\")\"#);\n-    assert_eq!(pat.1, 2);\n-}\n-\n-#[test]\n-fn parse_regex_error_pattern() {\n-    let s = r\"\n-//@  error-pattern:  /foomp/\n-use std::mem;\n-\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    println!(\"parsed comments: {:#?}\", comments);\n-    let pat = comments.error_pattern.unwrap();\n-    assert_eq!(format!(\"{:?}\", pat.0), r#\"Regex(foomp)\"#);\n-    assert_eq!(pat.1, 2);\n-}\n-\n-#[test]\n-fn parse_slash_slash_at_fail() {\n-    let s = r\"\n-//@  error-patttern  foomp\n-use std::mem;\n-\n-    \";\n-    assert!(Comments::parse(Path::new(\"<dummy>\"), s).is_err(), \"expected parsing to fail\");\n-}\n-\n-#[test]\n-fn missing_colon_fail() {\n-    let s = r\"\n-//@stderr-per-bitwidth hello\n-use std::mem;\n-\n-    \";\n-    assert!(Comments::parse(Path::new(\"<dummy>\"), s).is_err(), \"expected parsing to fail\");\n-}"}, {"sha": "8e031947581b38230fb4aa5f5f58ac9d7a5eb35c", "filename": "ui_test/src/rustc_stderr.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Frustc_stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Frustc_stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Frustc_stderr.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,155 +0,0 @@\n-use std::{\n-    fmt::Write,\n-    path::{Path, PathBuf},\n-};\n-\n-use color_eyre::eyre::{eyre, Error};\n-use regex::Regex;\n-\n-#[derive(serde::Deserialize, Debug)]\n-struct RustcMessage {\n-    rendered: Option<String>,\n-    spans: Vec<Span>,\n-    level: String,\n-    message: String,\n-    children: Vec<RustcMessage>,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n-pub(crate) enum Level {\n-    Ice = 5,\n-    Error = 4,\n-    Warn = 3,\n-    Help = 2,\n-    Note = 1,\n-    /// Only used for \"For more information about this error, try `rustc --explain EXXXX`\".\n-    FailureNote = 0,\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct Message {\n-    pub(crate) level: Level,\n-    pub(crate) message: String,\n-}\n-\n-/// Information about macro expansion.\n-#[derive(serde::Deserialize, Debug)]\n-struct Expansion {\n-    span: Span,\n-}\n-\n-#[derive(serde::Deserialize, Debug)]\n-struct Span {\n-    line_start: usize,\n-    file_name: PathBuf,\n-    expansion: Option<Box<Expansion>>,\n-}\n-\n-impl std::str::FromStr for Level {\n-    type Err = Error;\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"ERROR\" | \"error\" => Ok(Self::Error),\n-            \"WARN\" | \"warning\" => Ok(Self::Warn),\n-            \"HELP\" | \"help\" => Ok(Self::Help),\n-            \"NOTE\" | \"note\" => Ok(Self::Note),\n-            \"failure-note\" => Ok(Self::FailureNote),\n-            \"error: internal compiler error\" => Ok(Self::Ice),\n-            _ => Err(eyre!(\"unknown level `{s}`\")),\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct Diagnostics {\n-    /// Rendered and concatenated version of all diagnostics.\n-    /// This is equivalent to non-json diagnostics.\n-    pub rendered: String,\n-    /// Per line, a list of messages for that line.\n-    pub messages: Vec<Vec<Message>>,\n-    /// Messages not on any line (usually because they are from libstd)\n-    pub messages_from_unknown_file_or_line: Vec<Message>,\n-}\n-\n-impl RustcMessage {\n-    fn line(&self, file: &Path) -> Option<usize> {\n-        self.spans.iter().find_map(|span| span.line(file))\n-    }\n-\n-    /// Put the message and its children into the line-indexed list.\n-    fn insert_recursive(\n-        self,\n-        file: &Path,\n-        messages: &mut Vec<Vec<Message>>,\n-        messages_from_unknown_file_or_line: &mut Vec<Message>,\n-        line: Option<usize>,\n-    ) {\n-        let line = self.line(file).or(line);\n-        let msg = Message { level: self.level.parse().unwrap(), message: self.message };\n-        if let Some(line) = line {\n-            if messages.len() <= line {\n-                messages.resize_with(line + 1, Vec::new);\n-            }\n-            messages[line].push(msg);\n-        // All other messages go into the general bin, unless they are specifically of the\n-        // \"aborting due to X previous errors\" variety, as we never want to match those. They\n-        // only count the number of errors and provide no useful information about the tests.\n-        } else if !(msg.message.starts_with(\"aborting due to\")\n-            && msg.message.contains(\"previous error\"))\n-        {\n-            messages_from_unknown_file_or_line.push(msg);\n-        }\n-        for child in self.children {\n-            child.insert_recursive(file, messages, messages_from_unknown_file_or_line, line)\n-        }\n-    }\n-}\n-\n-impl Span {\n-    /// Returns a line number *in the given file*, if possible.\n-    fn line(&self, file: &Path) -> Option<usize> {\n-        if self.file_name == file {\n-            Some(self.line_start)\n-        } else {\n-            self.expansion.as_ref()?.span.line(file)\n-        }\n-    }\n-}\n-\n-pub(crate) fn filter_annotations_from_rendered(rendered: &str) -> std::borrow::Cow<'_, str> {\n-    let annotations = Regex::new(r\" *//(\\[[a-z,]+\\])?~.*\").unwrap();\n-    annotations.replace_all(rendered, \"\")\n-}\n-\n-pub(crate) fn process(file: &Path, stderr: &[u8]) -> Diagnostics {\n-    let stderr = std::str::from_utf8(stderr).unwrap();\n-    let mut rendered = String::new();\n-    let mut messages = vec![];\n-    let mut messages_from_unknown_file_or_line = vec![];\n-    for line in stderr.lines() {\n-        if line.starts_with('{') {\n-            match serde_json::from_str::<RustcMessage>(line) {\n-                Ok(msg) => {\n-                    write!(\n-                        rendered,\n-                        \"{}\",\n-                        filter_annotations_from_rendered(msg.rendered.as_ref().unwrap())\n-                    )\n-                    .unwrap();\n-                    msg.insert_recursive(\n-                        file,\n-                        &mut messages,\n-                        &mut messages_from_unknown_file_or_line,\n-                        None,\n-                    );\n-                }\n-                Err(err) =>\n-                    panic!(\"failed to parse rustc JSON output at line: {}\\nerr:{}\", line, err),\n-            }\n-        } else {\n-            // FIXME: do we want to throw interpreter stderr into a separate file?\n-            writeln!(rendered, \"{}\", line).unwrap();\n-        }\n-    }\n-    Diagnostics { rendered, messages, messages_from_unknown_file_or_line }\n-}"}, {"sha": "2032988ed384dcd8daee4b2ddf12dd1b04346dba", "filename": "ui_test/src/tests.rs", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99aa9d0d7b780aadbf986c95740358b31342dd/ui_test%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Ftests.rs?ref=9f99aa9d0d7b780aadbf986c95740358b31342dd", "patch": "@@ -1,294 +0,0 @@\n-use std::path::{Path, PathBuf};\n-\n-use crate::rustc_stderr::Level;\n-use crate::rustc_stderr::Message;\n-\n-use super::*;\n-\n-fn config() -> Config {\n-    Config {\n-        args: vec![],\n-        target: None,\n-        stderr_filters: vec![],\n-        stdout_filters: vec![],\n-        root_dir: PathBuf::from(\"$RUSTROOT\"),\n-        mode: Mode::Fail,\n-        path_filter: vec![],\n-        program: PathBuf::from(\"cake\"),\n-        output_conflict_handling: OutputConflictHandling::Error,\n-        dependencies_crate_manifest_path: None,\n-        dependency_builder: None,\n-        quiet: false,\n-    }\n-}\n-\n-#[test]\n-fn issue_2156() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address $HEX is unallocated)\n-}\n-    \";\n-    let path = Path::new(\"$DIR/<dummy>\");\n-    let comments = Comments::parse(path, s).unwrap();\n-    let mut errors = vec![];\n-    let config = config();\n-    let messages = vec![\n-        vec![], vec![], vec![], vec![], vec![],\n-        vec![\n-            Message {\n-                message:\"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            }\n-        ]\n-    ];\n-    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n-    match &errors[..] {\n-        [\n-            Error::PatternNotFound { definition_line: 5, .. },\n-            Error::ErrorsWithoutPattern { path: Some((_, 5)), .. },\n-        ] => {}\n-        _ => panic!(\"{:#?}\", errors),\n-    }\n-}\n-\n-#[test]\n-fn find_pattern() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    let config = config();\n-    {\n-        let messages = vec![vec![], vec![], vec![], vec![], vec![], vec![\n-                Message {\n-                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                    level: Level::Error,\n-                }\n-            ]\n-        ];\n-        let mut errors = vec![];\n-        check_annotations(\n-            messages,\n-            vec![],\n-            Path::new(\"moobar\"),\n-            &mut errors,\n-            &config,\n-            \"\",\n-            &comments,\n-        );\n-        match &errors[..] {\n-            [] => {}\n-            _ => panic!(\"{:#?}\", errors),\n-        }\n-    }\n-\n-    // only difference to above is a wrong line number\n-    {\n-        let messages = vec![vec![], vec![], vec![], vec![], vec![\n-                Message {\n-                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                    level: Level::Error,\n-                }\n-            ]\n-        ];\n-        let mut errors = vec![];\n-        check_annotations(\n-            messages,\n-            vec![],\n-            Path::new(\"moobar\"),\n-            &mut errors,\n-            &config,\n-            \"\",\n-            &comments,\n-        );\n-        match &errors[..] {\n-            [\n-                Error::PatternNotFound { definition_line: 5, .. },\n-                Error::ErrorsWithoutPattern { path: Some((_, 4)), .. },\n-            ] => {}\n-            _ => panic!(\"not the expected error: {:#?}\", errors),\n-        }\n-    }\n-\n-    // only difference to first is a wrong level\n-    {\n-        let messages = vec![\n-            vec![], vec![], vec![], vec![], vec![],\n-            vec![\n-                Message {\n-                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                    level: Level::Note,\n-                }\n-            ]\n-        ];\n-        let mut errors = vec![];\n-        check_annotations(\n-            messages,\n-            vec![],\n-            Path::new(\"moobar\"),\n-            &mut errors,\n-            &config,\n-            \"\",\n-            &comments,\n-        );\n-        match &errors[..] {\n-            // Note no `ErrorsWithoutPattern`, because there are no `//~NOTE` in the test file, so we ignore them\n-            [Error::PatternNotFound { definition_line: 5, .. }] => {}\n-            _ => panic!(\"not the expected error: {:#?}\", errors),\n-        }\n-    }\n-}\n-\n-#[test]\n-fn duplicate_pattern() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-    //~^ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    let config = config();\n-    let messages = vec![\n-        vec![], vec![], vec![], vec![], vec![],\n-        vec![\n-            Message {\n-                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            }\n-        ]\n-    ];\n-    let mut errors = vec![];\n-    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n-    match &errors[..] {\n-        [Error::PatternNotFound { definition_line: 6, .. }] => {}\n-        _ => panic!(\"{:#?}\", errors),\n-    }\n-}\n-\n-#[test]\n-fn missing_pattern() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    let config = config();\n-    let messages = vec![\n-        vec![], vec![], vec![], vec![], vec![],\n-        vec![\n-            Message {\n-                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            },\n-            Message {\n-                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            }\n-        ]\n-    ];\n-    let mut errors = vec![];\n-    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n-    match &errors[..] {\n-        [Error::ErrorsWithoutPattern { path: Some((_, 5)), .. }] => {}\n-        _ => panic!(\"{:#?}\", errors),\n-    }\n-}\n-\n-#[test]\n-fn missing_warn_pattern() {\n-    let s = r\"\n-use std::mem;\n-\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-    //~^ WARN: cake\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    let config = config();\n-    let messages= vec![\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![\n-            Message {\n-                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            },\n-            Message {\n-                message: \"kaboom\".to_string(),\n-                level: Level::Warn,\n-            },\n-            Message {\n-                message: \"cake\".to_string(),\n-                level: Level::Warn,\n-            },\n-        ],\n-    ];\n-    let mut errors = vec![];\n-    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n-    match &errors[..] {\n-        [Error::ErrorsWithoutPattern { path: Some((_, 5)), msgs, .. }] =>\n-            match &msgs[..] {\n-                [Message { message, level: Level::Warn }] if message == \"kaboom\" => {}\n-                _ => panic!(\"{:#?}\", msgs),\n-            },\n-        _ => panic!(\"{:#?}\", errors),\n-    }\n-}\n-\n-#[test]\n-fn missing_implicit_warn_pattern() {\n-    let s = r\"\n-use std::mem;\n-//@require-annotations-for-level: ERROR\n-fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n-    //~^ WARN: cake\n-}\n-    \";\n-    let comments = Comments::parse(Path::new(\"<dummy>\"), s).unwrap();\n-    let config = config();\n-    let messages = vec![\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![],\n-        vec![\n-            Message {\n-                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n-                level: Level::Error,\n-            },\n-            Message {\n-                message: \"kaboom\".to_string(),\n-                level: Level::Warn,\n-            },\n-            Message {\n-                message: \"cake\".to_string(),\n-                level: Level::Warn,\n-            },\n-        ],\n-    ];\n-    let mut errors = vec![];\n-    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n-    match &errors[..] {\n-        [] => {}\n-        _ => panic!(\"{:#?}\", errors),\n-    }\n-}"}]}