{"sha": "00dc20ab26591b9641bb822d85fc353272b6307b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZGMyMGFiMjY1OTFiOTY0MWJiODIyZDg1ZmMzNTMyNzJiNjMwN2I=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T12:12:28Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-13T12:12:28Z"}, "message": "report: Numerous fixes. :heart: @DanielKeep, @programble, @ubsan, @eddyb", "tree": {"sha": "6c6f7f53cf25998159cf3b3abd828664f246e0de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6f7f53cf25998159cf3b3abd828664f246e0de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00dc20ab26591b9641bb822d85fc353272b6307b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00dc20ab26591b9641bb822d85fc353272b6307b", "html_url": "https://github.com/rust-lang/rust/commit/00dc20ab26591b9641bb822d85fc353272b6307b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00dc20ab26591b9641bb822d85fc353272b6307b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d9df5b442929fe33fb941ac302496845a08a7ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9df5b442929fe33fb941ac302496845a08a7ab", "html_url": "https://github.com/rust-lang/rust/commit/8d9df5b442929fe33fb941ac302496845a08a7ab"}], "stats": {"total": 439, "additions": 231, "deletions": 208}, "files": [{"sha": "a1894505fb9696fe4c4b2652fb5e49b7c1788bb5", "filename": "test/vecs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00dc20ab26591b9641bb822d85fc353272b6307b/test%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dc20ab26591b9641bb822d85fc353272b6307b/test%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fvecs.rs?ref=00dc20ab26591b9641bb822d85fc353272b6307b", "patch": "@@ -20,8 +20,11 @@ fn make_vec_macro_repeat() -> Vec<u8> {\n }\n \n #[miri_run]\n-fn vec_into_iter() -> i32 {\n-    vec![1, 2, 3, 4].into_iter().fold(0, |x, y| x + y)\n+fn vec_into_iter() -> u8 {\n+    vec![1, 2, 3, 4]\n+        .into_iter()\n+        .map(|x| x * x)\n+        .fold(0, |x, y| x + y)\n }\n \n #[miri_run]"}, {"sha": "82efc73605caa17d743ca8ff2d0f8a237ee68d74", "filename": "tex/report/miri-report.tex", "status": "modified", "additions": 226, "deletions": 206, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/00dc20ab26591b9641bb822d85fc353272b6307b/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/00dc20ab26591b9641bb822d85fc353272b6307b/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=00dc20ab26591b9641bb822d85fc353272b6307b", "patch": "@@ -31,18 +31,19 @@ \\section{Abstract}\n \n The increasing need for safe low-level code in contexts like operating systems and browsers is\n driving the development of Rust\\footnote{\\url{https://www.rust-lang.org}}, a programming language\n-backed by Mozilla promising blazing speed without the segfaults. To make programming more\n-convenient, it's often desirable to be able to generate code or perform some computation at\n-compile-time. The former is mostly covered by Rust's existing macro feature, but the latter is\n-currently restricted to a limited form of constant evaluation capable of little beyond simple math.\n-\n-When the existing constant evaluator was built, it would have been difficult to make it more\n-powerful than it is. However, a new intermediate representation was recently\n-added\\footnote{\\href{https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md}{The MIR RFC}}\n+promising high performance without the risk of memory unsafety. To make programming more convenient,\n+it's often desirable to be able to generate code or perform some computation at compile-time. The\n+former is mostly covered by Rust's existing macro feature or build-time code generation, but the\n+latter is currently restricted to a limited form of constant evaluation capable of little beyond\n+simple math.\n+\n+The architecture of the compiler at the time the existing constant evaluator was built limited its\n+potential for future extension. However, a new intermediate representation was recently\n+added\\footnote{\\href{https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md}{Rust RFC \\#1211: Mid-level IR (MIR)}}\n to the Rust compiler between the abstract syntax tree and the back-end LLVM IR, called mid-level\n-intermediate representation, or MIR for short. As it turns out, writing an interpreter for MIR is a\n-surprisingly effective approach for supporting a large proportion of Rust's features in compile-time\n-execution.\n+intermediate representation, or MIR for short. This report will demonstrate that writing an\n+interpreter for MIR is a surprisingly effective approach for supporting a large proportion of Rust's\n+features in compile-time execution.\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n@@ -54,9 +55,9 @@ \\section{Background}\n statement is of the form \\rust{lvalue = rvalue}. An \\rust{Lvalue} is used for referencing variables\n and calculating addresses such as when dereferencing pointers, accessing fields, or indexing arrays.\n An \\rust{Rvalue} represents the core set of operations possible in MIR, including reading a value\n-from an lvalue, performing math operations, creating new pointers, structs, and arrays, and so on.\n-Finally, a terminator decides where control will flow next, optionally based on a boolean or some\n-other condition.\n+from an lvalue, performing math operations, creating new pointers, structures, and arrays, and so\n+on. Finally, a terminator decides where control will flow next, optionally based on the value of a\n+boolean or integer.\n \n \\begin{figure}[ht]\n   \\begin{minted}[autogobble]{rust}\n@@ -95,81 +96,83 @@ \\section{First implementation}\n \n \\subsection{Basic operation}\n \n-Initially, I wrote a simple version of Miri\\footnote{\\url{https://github.com/tsion/miri}} that was\n-quite capable despite its flaws. The structure of the interpreter closely mirrors the structure of\n-MIR itself. It starts executing a function by iterating the statement list in the starting basic\n-block, matching over the lvalue to produce a pointer and matching over the rvalue to decide what to\n-write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides of a\n-binary operation) or construction of new values. Upon reaching the terminator, a similar matching is\n-done and a new basic block is selected. Finally, Miri returns to the top of the main interpreter\n-loop and this entire process repeats, reading statements from the new block.\n+To investigate the possibility of executing Rust at compile-time I wrote an interpreter for MIR\n+called Miri\\footnote{\\url{https://github.com/tsion/miri}}. The structure of the interpreter closely\n+mirrors the structure of MIR itself. It starts executing a function by iterating the statement list\n+in the starting basic block, translating the lvalue into a pointer and using the rvalue to decide\n+what to write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides\n+of a binary operation) or construction of new values. When the terminator is reached, it is used to\n+decide which basic block to jump to next. Finally, Miri repeats this entire process, reading\n+statements from the new block.\n \n \\subsection{Function calls}\n \n To handle function call terminators\\footnote{Calls occur only as terminators, never as rvalues.},\n Miri is required to store some information in a virtual call stack so that it may pick up where it\n left off when the callee returns. Each stack frame stores a reference to the \\rust{Mir} for the\n function being executed, its local variables, its return value location\\footnote{Return value\n-pointers are passed in by callers.}, and the basic block where execution should resume. To\n-facilitate returning, there is a \\rust{Return} terminator which causes Miri to pop a stack frame and\n-resume the previous function. The entire execution of a program completes when the first function\n-that Miri called returns, rendering the call stack empty.\n+pointers are passed in by callers.}, and the basic block where execution should resume. When Miri\n+encounters a \\rust{Return} terminator in the MIR, it pops one frame off the stack and resumes the\n+previous function. Miri's execution ends when the function it was initially invoked with returns,\n+leaving the call stack empty.\n \n It should be noted that Miri does not itself recurse when a function is called; it merely pushes a\n virtual stack frame and jumps to the top of the interpreter loop. Consequently, Miri can interpret\n-deeply recursive programs without crashing. It could also set a stack depth limit and report an\n-error when a program exceeds it.\n+deeply recursive programs without overflowing its native call stack. This approach would allow Miri\n+to set a virtual stack depth limit and report an error when a program exceeds it.\n \n \\subsection{Flaws}\n \n-This version of Miri was surprisingly easy to write and already supported quite a bit of the Rust\n-language, including booleans, integers, if-conditions, while-loops, structs, enums, arrays, tuples,\n-pointers, and function calls, all in about 400 lines of Rust code. However, it had a particularly\n-naive value representation with a number of downsides. It resembled the data layout of a dynamic\n-language like Ruby or Python, where every value has the same size\\footnote{A Rust \\rust{enum} is a\n-discriminated union with a tag and data the size of the largest variant, regardless of which variant\n-it contains.} in the interpreter:\n+This version of Miri supported quite a bit of the Rust language, including booleans, integers,\n+if-conditions, while-loops, structures, enums, arrays, tuples, pointers, and function calls,\n+requiring approximately 400 lines of Rust code. However, it had a particularly naive value\n+representation with a number of downsides. It resembled the data layout of a dynamic language like\n+Ruby or Python, where every value has the same size\\footnote{An \\rust{enum} is a discriminated union\n+with a tag and space to fit the largest variant, regardless of which variant it contains.} in the\n+interpreter:\n \n \\begin{minted}[autogobble]{rust}\n   enum Value {\n       Uninitialized,\n       Bool(bool),\n       Int(i64),\n       Pointer(Pointer), // index into stack\n-      Adt { variant: usize, data: Pointer },\n-      // ...\n+      Aggregate {\n+        variant: usize,\n+        data: Pointer,\n+      },\n   }\n \\end{minted}\n \n-This representation did not work well for \\rust{Adt}s\\footnote{Algebraic data types: structs, enums,\n-arrays, and tuples.} and required strange hacks to support them. Their contained values were\n-allocated elsewhere on the stack and pointed to by the \\rust{Adt} value. When it came to copying\n-\\rust{Adt} values from place to place, this made it more complicated.\n+This representation did not work well for aggregate types\\footnote{That is, structures, enums,\n+arrays, tuples, and closures.} and required strange hacks to support them. Their contained values\n+were allocated elsewhere on the stack and pointed to by the aggregate value, which made it more\n+complicated to implement copying aggregate values from place to place.\n \n-Moreover, while the \\rust{Adt} issues could be worked around, this value representation made common\n-\\rust{unsafe} programming tricks (which make assumptions about the low-level value layout)\n-fundamentally impossible.\n+Moreover, while the aggregate issues could be worked around, this value representation made common\n+unsafe programming tricks (which make assumptions about the low-level value layout) fundamentally\n+impossible.\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Current implementation}\n \n Roughly halfway through my time working on Miri, Eduard\n-Burtescu\\footnote{\\href{https://github.com/eddyb}{Eduard Burtescu on GitHub}} from the Rust compiler\n-team\\footnote{\\href{https://www.rust-lang.org/team.html\\#Compiler}{The Rust compiler team}} made a\n-post on Rust's internal forums about a ``Rust Abstract Machine''\n+Burtescu\\footnote{\\href{https://github.com/eddyb}{eddyb on GitHub}} from the Rust compiler\n+team\\footnote{\\url{https://www.rust-lang.org/team.html\\#Compiler}} made a post on Rust's internal\n+forums about a ``Rust Abstract Machine''\n specification\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n-``Rust Abstract Machine'' forum post}} which could be used to implement more powerful compile-time\n+reply on ``MIR constant evaluation''}} which could be used to implement more powerful compile-time\n function execution, similar to what is supported by C++14's \\mintinline{cpp}{constexpr} feature.\n-After clarifying some of the details of the abstract machine's data layout with Burtescu via IRC, I\n-started implementing it in Miri.\n+After clarifying some of the details of the data layout with Burtescu via IRC, I started\n+implementing it in Miri.\n \n \\subsection{Raw value representation}\n \n The main difference in the new value representation was to represent values by ``abstract\n-allocations'' containing arrays of raw bytes with different sizes depending on the types of the\n-values. This closely mimics how Rust values are represented when compiled for traditional machines.\n-In addition to the raw bytes, allocations carry information about pointers and undefined bytes.\n+allocations'' containing arrays of raw bytes with different sizes depending on their types. This\n+mimics how Rust values are represented when compiled for physical machines. In addition to the raw\n+bytes, allocations carry information about pointers and undefined bytes.\n \n \\begin{minted}[autogobble]{rust}\n   struct Memory {\n@@ -189,64 +192,63 @@ \\subsubsection{Relocations}\n The abstract machine represents pointers through ``relocations'', which are analogous to relocations\n in linkers\\footnote{\\href{https://en.wikipedia.org/wiki/Relocation_(computing)}{Relocation\n (computing) - Wikipedia}}. Instead of storing a global memory address in the raw byte representation\n-like a traditional machine, we store an offset from the start of the target allocation and add an\n-entry to the relocation table. The entry maps the index of the start of the offset bytes to the\n-\\rust{AllocId} of the target allocation.\n+like on a physical machine, we store an offset from the start of the target allocation and add an\n+entry to the relocation table which maps the index of the offset bytes to the target allocation.\n \n-\\begin{figure}[ht]\n+In \\autoref{fig:reloc}, the relocation stored at offset 0 in \\rust{y} points to offset 2 in \\rust{x}\n+(the 2nd 16-bit integer). Thus, the relocation table for \\rust{y} is \\texttt{\\{0 =>\n+x\\}}, meaning the next $N$ bytes after offset 0 denote an offset into allocation \\rust{x} where $N$\n+is the size of a pointer (4 in this example). The example shows this as a labelled line beneath the\n+offset bytes.\n+\n+In effect, the abstract machine represents pointers as \\rust{(allocation_id, offset)} pairs. This\n+makes it easy to detect when pointer accesses go out of bounds.\n+\n+\\begin{figure}[hb]\n   \\begin{minted}[autogobble]{rust}\n-    let a: [i16; 3] = [2, 4, 6];\n-    let b = &a[1];\n-    // A: 02 00 04 00 06 00 (6 bytes)\n-    // B: 02 00 00 00 (4 bytes)\n-    //    \u2514\u2500\u2500\u2500(A)\u2500\u2500\u2500\u2518\n+    let x: [i16; 3] = [0xAABB, 0xCCDD, 0xEEFF];\n+    let y = &x[1];\n+    // x: BB AA DD CC FF EE (6 bytes)\n+    // y: 02 00 00 00 (4 bytes)\n+    //    \u2514\u2500\u2500\u2500(x)\u2500\u2500\u2500\u2518\n   \\end{minted}\n   \\caption{Example relocation on 32-bit little-endian}\n   \\label{fig:reloc}\n \\end{figure}\n \n-In effect, the abstract machine treats each allocation as a separate address space and represents\n-pointers as \\rust{(address_space, offset)} pairs. This makes it easy to detect when pointer accesses\n-go out of bounds.\n-\n-See \\autoref{fig:reloc} for an example of a relocation. Variable \\rust{b} points to the second\n-16-bit integer in \\rust{a}, so it contains a relocation with offset 2 and target allocation\n-\\rust{A}.\n-\n \\subsubsection{Undefined byte mask}\n \n The final piece of an abstract allocation is the undefined byte mask. Logically, we store a boolean\n for the definedness of every byte in the allocation, but there are multiple ways to make the storage\n more compact. I tried two implementations: one based on the endpoints of alternating ranges of\n-defined and undefined bytes and the other based on a simple bitmask. The former is more compact but\n-I found it surprisingly difficult to update cleanly. I currently use the bitmask system, which is\n-comparatively trivial.\n+defined and undefined bytes and the other based on a bitmask. The former is more compact but I found\n+it surprisingly difficult to update cleanly. I currently use the much simpler bitmask system.\n \n-See \\autoref{fig:undef} for an example undefined byte, represented by underscores. Note that there\n-would still be a value for the second byte in the byte array, but we don't care what it is. The\n-bitmask would be $10_2$, i.e.\\ \\rust{[true, false]}.\n+See \\autoref{fig:undef} for an example of an undefined byte in a value, represented by underscores.\n+Note that there is a value for the second byte in the byte array, but it doesn't matter what it is.\n+The bitmask would be $10_2$, i.e.\\ \\rust{[true, false]}.\n \n \\begin{figure}[hb]\n   \\begin{minted}[autogobble]{rust}\n-    let a: [u8; 2] = unsafe {\n+    let x: [u8; 2] = unsafe {\n         [1, std::mem::uninitialized()]\n     };\n-    // A: 01 __ (2 bytes)\n+    // x: 01 __ (2 bytes)\n   \\end{minted}\n   \\caption{Example undefined byte}\n   \\label{fig:undef}\n \\end{figure}\n \n \\subsection{Computing data layout}\n \n-Currently, the Rust compiler's data layout computations used in translation from MIR to LLVM IR are\n-hidden from Miri, so I do my own basic data layout computation which doesn't generally match what\n-translation does. In the future, the Rust compiler may be modified so that Miri can use the exact\n-same data layout.\n+Currently, the Rust compiler's data layouts for types are hidden from Miri, so it does its own data\n+layout computation which will not always match what the compiler does, since Miri doesn't take\n+target type alignments into account. In the future, the Rust compiler may be modified so that Miri\n+can use the exact same data layout.\n \n-Miri's data layout calculation is a relatively simple transformation from Rust types to a basic\n-structure with constant size values for primitives and sets of fields with offsets for aggregate\n-types. These layouts are cached for performance.\n+Miri's data layout calculation is a relatively simple transformation from Rust types to a structure\n+with constant size values for primitives and sets of fields with offsets for aggregate types. These\n+layouts are cached for performance.\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n@@ -268,7 +270,8 @@ \\section{Deterministic execution}\n doesn't exist at the MIR level.}, it is specifically designed to remain safe while interpreting\n potentially unsafe code. When Miri encounters an unrecoverable error, it reports it via the Rust\n compiler's usual error reporting mechanism, pointing to the part of the original code where the\n-error occurred. For example:\n+error occurred. Below is an example from Miri's\n+repository.\\footnote{\\href{https://github.com/tsion/miri/blob/master/test/errors.rs}{miri/test/errors.rs}}\n \n \\begin{minted}[autogobble]{rust}\n   let b = Box::new(42);\n@@ -280,50 +283,47 @@ \\section{Deterministic execution}\n \\end{minted}\n \\label{dangling-pointer}\n \n-There are more examples in Miri's\n-repository.\\footnote{\\href{https://github.com/tsion/miri/blob/master/test/errors.rs}{Miri's error\n-tests}}\n-\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Language support}\n \n-In its current state, Miri supports a large proportion of the Rust language, with a few major\n-exceptions such as the lack of support for FFI\\footnote{Foreign Function Interface, e.g.\\ calling\n+In its current state, Miri supports a large proportion of the Rust language, detailed below. The\n+major exception is a lack of support for  FFI\\footnote{Foreign Function Interface, e.g.\\ calling\n functions defined in Assembly, C, or C++.}, which eliminates possibilities like reading and writing\n-files, user input, graphics, and more. The following is a tour of what is currently supported.\n+files, user input, graphics, and more. However, for compile-time evaluation in Rust, this limitation\n+is desired.\n \n \\subsection{Primitives}\n \n-Miri supports booleans and integers of various sizes and signed-ness (i.e.\\ \\rust{i8}, \\rust{i16},\n+Miri supports booleans, integers of various sizes and signed-ness (i.e.\\ \\rust{i8}, \\rust{i16},\n \\rust{i32}, \\rust{i64}, \\rust{isize}, \\rust{u8}, \\rust{u16}, \\rust{u32}, \\rust{u64}, \\rust{usize}),\n-as well as unary and boolean operations over these types. The \\rust{isize} and \\rust{usize} types\n-will be sized according to the target machine's pointer size just like in compiled Rust. The\n-\\rust{char} and float types (\\rust{f32}, \\rust{f64}) are not supported yet, but there are no known\n-barriers to doing so.\n+and unary and binary operations over these types. The \\rust{isize} and \\rust{usize} types will be\n+sized according to the target machine's pointer size just like in compiled Rust. The \\rust{char} and\n+float types (\\rust{f32}, \\rust{f64}) are not supported yet, but there are no known barriers to doing\n+so.\n \n-When examining a boolean in an \\rust{if} condition, Miri will report an error if it is not precisely\n-0 or 1, since this is undefined behaviour in Rust. The \\rust{char} type has similar restrictions to\n-check for once it is implemented.\n+When examining a boolean in an \\rust{if} condition, Miri will report an error if its byte\n+representation is not precisely 0 or 1, since having any other value for a boolean is undefined\n+behaviour in Rust. The \\rust{char} type will have similar restrictions once it is implemented.\n \n \\subsection{Pointers}\n \n Both references and raw pointers are supported, with essentially no difference between them in Miri.\n-It is also possible to do basic pointer comparisons and math. However, a few operations are\n-considered errors and a few require special support.\n+It is also possible to do pointer comparisons and math. However, a few operations are considered\n+errors and a few require special support.\n \n Firstly, pointers into the same allocations may be compared for ordering, but pointers into\n different allocations are considered unordered and Miri will complain if you attempt this. The\n reasoning is that different allocations may have different orderings in the global address space at\n runtime, making this non-deterministic. However, pointers into different allocations \\emph{may} be\n-compared for direct equality (they are always, automatically unequal).\n+compared for direct equality (they are always unequal).\n \n-Finally, for things like null pointer checks, abstract pointers (the kind represented using\n-relocations) may be compared against pointers casted from integers (e.g.\\ \\rust{0 as *const i32}).\n-To handle these cases, Miri has a concept of ``integer pointers'' which are always unequal to\n-abstract pointers. Integer pointers can be compared and operated upon freely. However, note that it\n-is impossible to go from an integer pointer to an abstract pointer backed by a relocation. It is not\n-valid to dereference an integer pointer.\n+Secondly, pointers represented using relocations may be compared against pointers casted from\n+integers (e.g.\\ \\rust{0 as *const i32}) for things like null pointer checks. To handle these cases,\n+Miri has a concept of ``integer pointers'' which are always unequal to abstract pointers. Integer\n+pointers can be compared and operated upon freely. However, note that it is impossible to go from an\n+integer pointer to an abstract pointer backed by a relocation. It is not valid to dereference an\n+integer pointer.\n \n \\subsubsection{Slice pointers}\n \n@@ -335,49 +335,48 @@ \\subsubsection{Trait objects}\n \n Rust also supports pointers to ``trait objects'' which represent some type that implements a trait,\n with the specific type unknown at compile-time. These are implemented using virtual dispatch with a\n-vtable, similar to virtual methods in C++. Miri does not currently support this at all.\n+vtable, similar to virtual methods in C++. Miri does not currently support these at all.\n \n \\subsection{Aggregates}\n \n-Aggregates include types declared as \\rust{struct} or \\rust{enum} as well as tuples, arrays, and\n-closures\\footnote{Closures are essentially structs with a field for each variable captured by the\n-closure.}. Miri supports all common usage of all of these types. The main missing piece is to handle\n+Aggregates include types declared with \\rust{struct} or \\rust{enum} as well as tuples, arrays, and\n+closures. Miri supports all common usage of all of these types. The main missing piece is to handle\n \\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n \n \\subsection{Lvalue projections}\n \n-This category includes field accesses like \\rust{foo.bar}, dereferencing, accessing data in an\n-\\rust{enum} variant, and indexing arrays. Miri supports all of these, including nested projections\n-such as \\rust{*foo.bar[2]}.\n+This category includes field accesses, dereferencing, accessing data in an \\rust{enum} variant, and\n+indexing arrays. Miri supports all of these, including nested projections such as\n+\\rust{*foo.bar[2]}.\n \n \\subsection{Control flow}\n \n All of Rust's standard control flow features, including \\rust{loop}, \\rust{while}, \\rust{for},\n \\rust{if}, \\rust{if let}, \\rust{while let}, \\rust{match}, \\rust{break}, \\rust{continue}, and\n-\\rust{return} are supported. In fact, supporting these were quite easy since the Rust compiler\n-reduces them all down to a comparatively smaller set of control-flow graph primitives in MIR.\n+\\rust{return} are supported. In fact, supporting these was quite easy since the Rust compiler\n+reduces them all down to a small set of control-flow graph primitives in MIR.\n \n \\subsection{Function calls}\n \n-As previously described, Miri supports arbitrary function calls without growing its own stack (only\n-its virtual call stack). It is somewhat limited by the fact that cross-crate\\footnote{A crate is a\n-single Rust library (or executable).} calls only work for functions whose MIR is stored in crate\n-metadata. This is currently true for \\rust{const}, generic, and \\texttt{\\#[inline]} functions. A\n-branch of the compiler could be made that stores MIR for all functions. This would be a non-issue\n+As previously described, Miri supports arbitrary function calls without growing the native stack\n+(only its virtual call stack). It is somewhat limited by the fact that cross-crate\\footnote{A crate\n+is a single Rust library (or executable).} calls only work for functions whose MIR is stored in\n+crate metadata. This is currently true for \\rust{const}, generic, and inline functions.\n+A branch of the compiler could be made that stores MIR for all functions. This would be a non-issue\n for a compile-time evaluator based on Miri, since it would only call \\rust{const fn}s.\n \n \\subsubsection{Method calls}\n \n-Trait method calls require a bit more machinery dealing with compiler internals than normal function\n-calls, but Miri supports them.\n+Miri supports trait method calls, including invoking all the compiler-internal lookup needed to find\n+the correct implementation of the method.\n \n \\subsubsection{Closures}\n \n-Closures are like structs containing a field for each captured variable, but closures also have an\n-associated function. Supporting closure function calls required some extra machinery to get the\n-necessary information from the compiler, but it is all supported except for one edge case on my todo\n-list\\footnote{The edge case is calling a closure that takes a reference to its captures via a\n-closure interface that passes the captures by value.}.\n+Calls to closures are also supported with the exception of one edge case\\footnote{Calling a closure\n+that takes a reference to its captures via a closure interface that passes the captures by value is\n+not yet supported.}. The value part of a closure that holds the captured variables is handled as an\n+aggregate and the function call part is mostly the same as a trait method call, but with the added\n+complication that closures use a separate calling convention within the compiler.\n \n \\subsubsection{Function pointers}\n \n@@ -388,19 +387,19 @@ \\subsubsection{Function pointers}\n \n \\subsubsection{Intrinsics}\n \n-To support unsafe code, and in particular the unsafe code used to implement Rust's standard library,\n-it became clear that Miri would have to support calls to compiler\n-intrinsics\\footnote{\\href{https://doc.rust-lang.org/stable/std/intrinsics/index.html}{Rust\n-intrinsics documentation}}. Intrinsics are function calls which cause the Rust compiler to produce\n-special-purpose code instead of a regular function call. Miri simply recognizes intrinsic calls by\n-their unique ABI\\footnote{Application Binary Interface, which defines calling conventions. Includes\n-``C'', ``Rust'', and ``rust-intrinsic''.} and name and runs special purpose code to handle them.\n+To support unsafe code, and in particular to support Rust's standard library, it became clear that\n+Miri would have to support calls to compiler\n+intrinsics\\footnote{\\url{https://doc.rust-lang.org/stable/std/intrinsics/index.html}}. Intrinsics\n+are function calls which cause the Rust compiler to produce special-purpose code instead of a\n+regular function call. Miri simply recognizes intrinsic calls by their unique\n+ABI\\footnote{Application Binary Interface, which defines calling conventions. Includes ``C'',\n+``Rust'', and ``rust-intrinsic''.} and name and runs special-purpose code to handle them.\n \n An example of an important intrinsic is \\rust{size_of} which will cause Miri to write the size of\n the type in question to the return value location. The Rust standard library uses intrinsics heavily\n-to implement various data structures, so this was a major step toward supporting them. So far, I've\n-been implementing intrinsics on a case-by-case basis as I write test cases which require missing\n-ones, so I haven't yet exhaustively implemented them all.\n+to implement various data structures, so this was a major step toward supporting them. Intrinsics\n+have been implemented on a case-by-case basis as tests which required them were written, and not all\n+intrinsics are supported yet.\n \n \\subsubsection{Generic function calls}\n \n@@ -414,17 +413,17 @@ \\subsubsection{Generic function calls}\n   fn some<T>(t: T) -> Option<T> { Some(t) }\n \\end{minted}\n \n-\\ldots{} Miri needs to know how many bytes to copy from the argument to the return value, based on\n-the size of \\rust{T}. If we call \\rust{some(10i32)} Miri will execute \\rust{some} knowing that\n+\\ldots{}Miri needs to know the size of \\rust{T} to copy the right amount of bytes from the argument\n+to the return value. If we call \\rust{some(10i32)} Miri will execute \\rust{some} knowing that\n \\rust{T = i32} and generate a representation for \\rust{Option<i32>}.\n \n-Miri currently does this monomorphization on-demand, or lazily, unlike the Rust back-end which does\n-it all ahead of time.\n+Miri currently does this monomorphization lazily on-demand unlike the Rust back-end which does it\n+all ahead of time.\n \n \\subsection{Heap allocations}\n \n The next piece of the puzzle for supporting interesting programs (and the standard library) was heap\n-allocations. There are two main interfaces for heap allocation in Rust, the built-in \\rust{Box}\n+allocations. There are two main interfaces for heap allocation in Rust: the built-in \\rust{Box}\n rvalue in MIR and a set of C ABI foreign functions including \\rust{__rust_allocate},\n \\rust{__rust_reallocate}, and \\rust{__rust_deallocate}. These correspond approximately to\n \\mintinline{c}{malloc}, \\mintinline{c}{realloc}, and \\mintinline{c}{free} in C.\n@@ -435,8 +434,8 @@ \\subsection{Heap allocations}\n \n The allocator functions, which are used to implement things like Rust's standard \\rust{Vec<T>} type,\n were a bit trickier. Rust declares them as \\rust{extern \"C\" fn} so that different allocator\n-libraries can be linked in at the user's option. Since Miri doesn't actually support FFI and we want\n-full control of allocations for safety, Miri ``cheats'' and recognizes these allocator function in\n+libraries can be linked in at the user's option. Since Miri doesn't actually support FFI and wants\n+full control of allocations for safety, it ``cheats'' and recognizes these allocator functions in\n essentially the same way it recognizes compiler intrinsics. Then, a call to \\rust{__rust_allocate}\n simply creates another abstract allocation with the requested size and \\rust{__rust_reallocate}\n grows one.\n@@ -446,28 +445,28 @@ \\subsection{Heap allocations}\n \n \\subsection{Destructors}\n \n-When values go out of scope that ``own'' some resource, like a heap allocation or file handle, Rust\n-inserts \\emph{drop glue} that calls the user-defined destructor for the type if it exists, and then\n-drops all of the subfields. Destructors for types like \\rust{Box<T>} and \\rust{Vec<T>} deallocate\n-heap memory.\n+When a value which ``owns'' some resource (like a heap allocation or file handle) goes out of scope,\n+Rust inserts \\emph{drop glue} that calls the user-defined destructor for the type if it has one, and\n+then drops all of the subfields. Destructors for types like \\rust{Box<T>} and \\rust{Vec<T>}\n+deallocate heap memory.\n \n Miri doesn't yet support calling user-defined destructors, but it has most of the machinery in place\n-to do so already and it's next on my to-do list. There \\emph{is} support for dropping \\rust{Box<T>}\n-types, including deallocating their associated allocations. This is enough to properly execute the\n-dangling pointer example in \\autoref{sec:deterministic}.\n+to do so already. There \\emph{is} support for dropping \\rust{Box<T>} types, including deallocating\n+their associated allocations. This is enough to properly execute the dangling pointer example in\n+\\autoref{sec:deterministic}.\n \n \\subsection{Constants}\n \n Only basic integer, boolean, string, and byte-string literals are currently supported. Evaluating\n more complicated constant expressions in their current form would be a somewhat pointless exercise\n-for Miri. Instead, we should lower constant expressions to MIR so Miri can run them directly. (This\n-is precisely what would be done to use Miri as the actual constant evaluator.)\n+for Miri. Instead, we should lower constant expressions to MIR so Miri can run them directly, which\n+is precisely what would need be done to use Miri as the compiler's constant evaluator.\n \n \\subsection{Static variables}\n \n-While it would be invalid to write to static (i.e.\\ global) variables in Miri executions, it would\n-probably be fine to allow reads. However, Miri doesn't currently support them and they would need\n-support similar to constants.\n+Miri doesn't currently support statics, but they would need support similar to constants. Also note\n+that while it would be invalid to write to static (i.e.\\ global) variables in Miri executions, it\n+would probably be fine to allow reads.\n \n \\subsection{Standard library}\n \n@@ -486,7 +485,7 @@ \\subsection{Standard library}\n pointer} all seem to work. I've also tested using the shared smart pointer types with \\rust{Cell}\n and \\rust{RefCell}\\footnote{\\href{https://doc.rust-lang.org/stable/std/cell/index.html}{Rust\n documentation for cell types}} for internal mutability, and that works as well, although\n-\\rust{RefCell} can't ever be borrowed twice until I implement destructor calls, since its destructor\n+\\rust{RefCell} can't ever be borrowed twice until I implement destructor calls, since a destructor\n is what releases the borrow.\n \n But the standard library collection I spent the most time on was \\rust{Vec}, the standard\n@@ -509,35 +508,40 @@ \\subsection{Standard library}\n \n     let mut v: Vec<u8> =\n         Vec::with_capacity(2);\n-    // A: 00 00 00 00 02 00 00 00 00 00 00 00\n-    //    \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    // B: __ __\n+    // v: 00 00 00 00 02 00 00 00 00 00 00 00\n+    //    \u2514\u2500(data)\u2500\u2500\u2518\n+    // data: __ __\n \n     v.push(1);\n-    // A: 00 00 00 00 02 00 00 00 01 00 00 00\n-    //    \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    // B: 01 __\n+    // v: 00 00 00 00 02 00 00 00 01 00 00 00\n+    //    \u2514\u2500(data)\u2500\u2500\u2518\n+    // data: 01 __\n \n     v.push(2);\n-    // A: 00 00 00 00 02 00 00 00 02 00 00 00\n-    //    \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    // B: 01 02\n+    // v: 00 00 00 00 02 00 00 00 02 00 00 00\n+    //    \u2514\u2500(data)\u2500\u2500\u2518\n+    // data: 01 02\n \n     v.push(3);\n-    // A: 00 00 00 00 04 00 00 00 03 00 00 00\n-    //    \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    // B: 01 02 03 __\n+    // v: 00 00 00 00 04 00 00 00 03 00 00 00\n+    //    \u2514\u2500(data)\u2500\u2500\u2518\n+    // data: 01 02 03 __\n   \\end{minted}\n   \\caption{\\rust{Vec} example on 32-bit little-endian}\n   \\label{fig:vec}\n \\end{figure}\n \n-You can even do unsafe things with \\rust{Vec} like \\rust{v.set_len(10)} or\n-\\rust{v.get_unchecked(2)}, but if you do these things carefully in a way that doesn't cause any\n-undefined behaviour (just like when you write unsafe code for regular Rust), then Miri can handle it\n-all. But if you do slip up, Miri will error out with an appropriate message (see\n+Miri supports unsafe operations on \\rust{Vec} like \\rust{v.set_len(10)} or\n+\\rust{v.get_unchecked(2)}, provided that such calls do no invoke undefined behaviour. If a call\n+\\emph{does} invoke undefined behaviour, Miri will abort with an appropriate error message (see\n \\autoref{fig:vec-error}).\n \n+% You can even do unsafe things with \\rust{Vec} like \\rust{v.set_len(10)} or\n+% \\rust{v.get_unchecked(2)}, but if you do these things carefully in a way that doesn't cause any\n+% undefined behaviour (just like when you write unsafe code for regular Rust), then Miri can handle it\n+% all. But if you do slip up, Miri will error out with an appropriate message (see\n+% \\autoref{fig:vec-error}).\n+\n \\begin{figure}[t]\n   \\begin{minted}[autogobble]{rust}\n     fn out_of_bounds() -> u8 {\n@@ -560,6 +564,20 @@ \\subsection{Standard library}\n   \\label{fig:vec-error}\n \\end{figure}\n \n+\\newpage\n+\n+Here is one final code sample Miri can execute that demonstrates many features at once, including\n+vectors, heap allocation, iterators, closures, raw pointers, and math:\n+\n+\\begin{minted}[autogobble]{rust}\n+  let x: u8 = vec![1, 2, 3, 4]\n+      .into_iter()\n+      .map(|x| x * x)\n+      .fold(0, |x, y| x + y);\n+    // x: 1e (that is, the hex value\n+    //        0x1e = 30 = 1 + 4 + 9 + 16)\n+\\end{minted}\n+\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Future directions}\n@@ -569,72 +587,74 @@ \\subsection{Finishing the implementation}\n There are a number of pressing items on my to-do list for Miri, including:\n \n \\begin{itemize}\n-  \\item Destructors and \\rust{__rust_deallocate}.\n+  \\item A much more comprehensive and automated test suite.\n+  \\item User-defined destructor calls.\n   \\item Non-trivial casts between primitive types like integers and pointers.\n   \\item Handling statics and global memory.\n   \\item Reporting errors for all undefined behaviour.\\footnote{\\href{https://doc.rust-lang.org/reference.html\\#behavior-considered-undefined}{The Rust reference on what is considered undefined behaviour}}\n   \\item Function pointers.\n   \\item Accounting for target machine primitive type alignment and endianness.\n-  \\item Optimizing stuff (undefined byte masks, tail-calls).\n+  \\item Optimizations (undefined byte masks, tail-calls).\n   \\item Benchmarking Miri vs. unoptimized Rust.\n   \\item Various \\texttt{TODO}s and \\texttt{FIXME}s left in the code.\n-  \\item Getting a version of Miri into rustc for real.\n+  \\item Integrating into the compiler proper.\n \\end{itemize}\n \n-\\subsection{Alternative applications}\n+\\subsection{Future projects}\n \n-Other possible uses for Miri include:\n+Other possible Miri-related projects include:\n \n \\begin{itemize}\n+  \\item A read-eval-print-loop (REPL) for Rust, which may be easier to implement on top of Miri than\n+    the usual LLVM back-end.\n   \\item A graphical or text-mode debugger that steps through MIR execution one statement at a time,\n     for figuring out why some compile-time execution is raising an error or simply learning how Rust\n     works at a low level.\n-  \\item A read-eval-print-loop (REPL) for Rust, which may be easier to implement on top of Miri than\n-    the usual LLVM back-end.\n-  \\item An extended version of Miri developed apart from the purpose of compile-time execution that\n-    is able to run foreign functions from C/C++ and generally have full access to the operating\n-    system. Such a version of Miri could be used to more quickly prototype changes to the Rust\n-    language that would otherwise require changes to the LLVM back-end.\n+  \\item A less restricted version of Miri that is able to run foreign functions from C/C++ and\n+    generally has full access to the operating system. Such an interpreter could be used to more\n+    quickly prototype changes to the Rust language that would otherwise require changes to the LLVM\n+    back-end.\n   \\item Unit-testing the compiler by comparing the results of Miri's execution against the results\n     of LLVM-compiled machine code's execution. This would help to guarantee that compile-time\n     execution works the same as runtime execution.\n-  \\item Some kind of symbolic evaluator that examines multiple possible code paths at once to\n-    determine if undefined behaviour could be observed on any of them.\n+  \\item Some kind of Miri-based symbolic evaluator that examines multiple possible code paths at\n+    once to determine if undefined behaviour could be observed on any of them.\n \\end{itemize}\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n \n \\section{Final thoughts}\n \n Writing an interpreter which models values of varying sizes, stack and heap allocation, unsafe\n-memory operations, and more requires some unconventional techniques compared to typical\n-interpreters. However, aside from the somewhat complicated abstract memory model, making Miri work\n-was primarily a software engineering problem, and not a particularly tricky one. This is a testament\n-to MIR's suitability as an intermediate representation for Rust---removing enough unnecessary\n-abstraction to keep it simple. For example, Miri doesn't even need to know that there are different\n-kind of loops, or how to match patterns in a \\rust{match} expression.\n+memory operations, and more requires some unconventional techniques compared to conventional\n+interpreters targeting dynamically-typed languages. However, aside from the somewhat complicated\n+abstract memory model, making Miri work was primarily a software engineering problem, and not a\n+particularly tricky one. This is a testament to MIR's suitability as an intermediate representation\n+for Rust---removing enough unnecessary abstraction to keep it simple. For example, Miri doesn't even\n+need to know that there are different kinds of loops, or how to match patterns in a \\rust{match}\n+expression.\n \n Another advantage to targeting MIR is that any new features at the syntax-level or type-level\n generally require little to no change in Miri. For example, when the new ``question mark'' syntax\n for error handling\\footnote{\n   \\href{https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md}\n     {Question mark syntax RFC}}\n-was added to rustc, Miri also supported it the same day with no change. When specialization\\footnote{\n+was added to rustc, Miri required no change to support it.\n+When specialization\\footnote{\n   \\href{https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md}\n     {Specialization RFC}}\n was added, Miri supported it with just minor changes to trait method lookup.\n \n Of course, Miri also has limitations. The inability to execute FFI and inline assembly reduces the\n amount of Rust programs Miri could ever execute. The good news is that in the constant evaluator,\n-FFI can be stubbed out in cases where it makes sense, like I did with \\rust{__rust_allocate}, and\n-for Miri outside of the compiler it may be possible to use libffi to call C functions from the\n-interpreter.\n-\n-In conclusion, Miri was a surprisingly effective project, and a lot of fun to implement. There were\n-times where I ended up supporting Rust features I didn't even intend to while I was adding support\n-for some other feature, due to the design of MIR collapsing features at the source level into fewer\n-features at the MIR level. I am excited to work with the compiler team going forward to try to make\n-Miri useful for constant evaluation in Rust.\n+FFI can be stubbed out in cases where it makes sense, like I did with \\rust{__rust_allocate}. For a\n+version of Miri not intended for constant evaluation, it may be possible to use libffi to call C\n+functions from the interpreter.\n+\n+In conclusion, Miri is a surprisingly effective project, and a lot of fun to implement. Due to MIR's\n+tendency to collapse multiple source-level features into one, I often ended up supporting features I\n+hadn't explicitly intended to. I am excited to work with the compiler team going forward to try to\n+make Miri useful for constant evaluation in Rust.\n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n "}]}