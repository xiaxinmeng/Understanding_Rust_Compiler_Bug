{"sha": "fd465f91a89450b7daebecdde9c280a923bbe394", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNDY1ZjkxYTg5NDUwYjdkYWViZWNkZGU5YzI4MGE5MjNiYmUzOTQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-07T11:21:08Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T20:17:32Z"}, "message": "Drop collect_items pass, create decls on demand\n\nThis solves a problem with inlined functions that have inner functions.", "tree": {"sha": "58d345ca820a4248419a99421367a2e01257a415", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58d345ca820a4248419a99421367a2e01257a415"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd465f91a89450b7daebecdde9c280a923bbe394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd465f91a89450b7daebecdde9c280a923bbe394", "html_url": "https://github.com/rust-lang/rust/commit/fd465f91a89450b7daebecdde9c280a923bbe394", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd465f91a89450b7daebecdde9c280a923bbe394/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8fe781200e985d4d12d1b0ea4a7b338e6220a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8fe781200e985d4d12d1b0ea4a7b338e6220a5", "html_url": "https://github.com/rust-lang/rust/commit/6f8fe781200e985d4d12d1b0ea4a7b338e6220a5"}], "stats": {"total": 626, "additions": 295, "deletions": 331}, "files": [{"sha": "4f037511418f5b01a869c765151c0fc7cf7b5a1f", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -131,7 +131,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let ast_map =\n         time(time_passes, \"ast indexing\",\n-             bind middle::ast_map::map_crate(*crate));\n+             bind middle::ast_map::map_crate(sess, *crate));\n     time(time_passes, \"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n     let {def_map, exp_map, impl_map} ="}, {"sha": "8e6d7a0a5262b081668b8147a5ffe4cfa872bda2", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -89,7 +89,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                     to_id_range: to_id_range};\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        ast_map::map_decoded_item(dcx.tcx.items, path, ii);\n+        ast_map::map_decoded_item(tcx.sess, dcx.tcx.items, path, ii);\n         #debug[\"Fn named: %s\", ii.ident()];\n         decode_side_tables(xcx, ast_doc);\n         #debug[\"< Decoded inlined fn: %s::%s\","}, {"sha": "0b24b3325d998ef3eef67252f074494123b9bc28", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -328,7 +328,7 @@ fn purity_fn_family(p: purity) -> char {\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        &index: [entry<int>], path: ast_map::path) {\n+                        &index: [entry<int>], path: ast_map::path) -> bool {\n \n     fn should_inline(attrs: [attribute]) -> bool {\n         alt attr::find_inline_attr(attrs) {\n@@ -342,7 +342,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_enum(_, _) | item_res(_, _, _, _, _) { true }\n       _ { false }\n     };\n-    if !must_write && !ecx.reachable.contains_key(item.id) { ret; }\n+    if !must_write && !ecx.reachable.contains_key(item.id) { ret false; }\n \n     alt item.node {\n       item_const(_, _) {\n@@ -494,11 +494,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n     }\n+    ret true;\n }\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                               nitem: @native_item, path: ast_map::path) {\n-    if !ecx.reachable.contains_key(nitem.id) { ret; }\n+                               nitem: @native_item, path: ast_map::path)\n+    -> bool {\n+    if !ecx.reachable.contains_key(nitem.id) { ret false; }\n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n@@ -511,6 +513,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n       }\n     }\n     ebml_w.end_tag();\n+    ret true;\n }\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n@@ -520,17 +523,17 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n     encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, [], \"\");\n     ecx.ccx.tcx.items.items {|key, val|\n-        alt val {\n+        let where = ebml_w.writer.tell();\n+        let written = alt val {\n           middle::ast_map::node_item(i, path) {\n-            index += [{val: key, pos: ebml_w.writer.tell()}];\n-            encode_info_for_item(ecx, ebml_w, i, index, *path);\n+            encode_info_for_item(ecx, ebml_w, i, index, *path)\n           }\n-          middle::ast_map::node_native_item(i, path) {\n-            index += [{val: key, pos: ebml_w.writer.tell()}];\n-            encode_info_for_native_item(ecx, ebml_w, i, *path);\n+          middle::ast_map::node_native_item(i, _, path) {\n+            encode_info_for_native_item(ecx, ebml_w, i, *path)\n           }\n-          _ { }\n-        }\n+          _ { false }\n+        };\n+        if written { index += [{val: key, pos: where}]; }\n     };\n     ebml_w.end_tag();\n     ret index;"}, {"sha": "b66ac037bdeab3415c6242c0619e28ec668d8647", "filename": "src/rustc/metadata/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmetadata%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Freachable.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -58,7 +58,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     alt cx.ccx.tcx.items.get(did.node) {\n       ast_map::node_item(item, _) { traverse_public_item(cx, item); }\n       ast_map::node_method(_, impl_id, _) { traverse_def_id(cx, impl_id); }\n-      ast_map::node_native_item(item, _) { cx.rmap.insert(item.id, ()); }\n+      ast_map::node_native_item(item, _, _) { cx.rmap.insert(item.id, ()); }\n       ast_map::node_variant(v, _, _) { cx.rmap.insert(v.node.id, ()); }\n       _ {}\n     }"}, {"sha": "4240c0e509256de02ad81e9f18cc432869857c1b", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -4,6 +4,8 @@ import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::inlined_item_methods;\n import syntax::{visit, codemap};\n+import driver::session::session;\n+import front::attr;\n \n enum path_elt { path_mod(str), path_name(str) }\n type path = [path_elt];\n@@ -24,20 +26,21 @@ fn path_to_str(p: path) -> str {\n \n enum ast_node {\n     node_item(@item, @path),\n-    node_native_item(@native_item, @path),\n+    node_native_item(@native_item, native_abi, @path),\n     node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n-    node_variant(variant, def_id, @path),\n+    node_variant(variant, @item, @path),\n     node_expr(@expr),\n     node_export(@view_path, @path),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    node_res_ctor(@item),\n+    node_ctor(@item),\n }\n \n type map = std::map::hashmap<node_id, ast_node>;\n-type ctx = {map: map, mutable path: path, mutable local_id: uint};\n+type ctx = {map: map, mutable path: path,\n+            mutable local_id: uint, sess: session};\n type vt = visit::vt<ctx>;\n \n fn extend(cx: ctx, elt: str) -> @path {\n@@ -47,7 +50,6 @@ fn extend(cx: ctx, elt: str) -> @path {\n fn mk_ast_map_visitor() -> vt {\n     ret visit::mk_vt(@{\n         visit_item: map_item,\n-        visit_native_item: map_native_item,\n         visit_expr: map_expr,\n         visit_fn: map_fn,\n         visit_local: map_local,\n@@ -57,18 +59,19 @@ fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-fn map_crate(c: crate) -> map {\n+fn map_crate(sess: session, c: crate) -> map {\n     let cx = {map: std::map::new_int_hash(),\n               mutable path: [],\n-              mutable local_id: 0u};\n+              mutable local_id: 0u,\n+              sess: sess};\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n     ret cx.map;\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n+fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -77,7 +80,8 @@ fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n               mutable path: path,\n-              mutable local_id: 0u};\n+              mutable local_id: 0u,\n+              sess: sess};\n     let v = mk_ast_map_visitor();\n \n     // methods get added to the AST map when their impl is visited.  Since we\n@@ -86,7 +90,7 @@ fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n     alt ii {\n       ii_item(i) { /* fallthrough */ }\n       ii_method(impl_did, m) {\n-        map_method(impl_did, @vec::init(path), m, cx);\n+        map_method(impl_did, @path, m, cx);\n       }\n     }\n \n@@ -137,19 +141,31 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       item_impl(_, _, _, ms) {\n         let impl_did = ast_util::local_def(i.id);\n         for m in ms {\n-            map_method(impl_did, item_path, m, cx);\n+            map_method(impl_did, extend(cx, i.ident), m, cx);\n         }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n-        cx.map.insert(ctor_id, node_res_ctor(i));\n+        cx.map.insert(ctor_id, node_ctor(i));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _) {\n         for v in vs {\n             cx.map.insert(v.node.id, node_variant(\n-                v, ast_util::local_def(i.id), extend(cx, i.ident)));\n+                v, i, extend(cx, i.ident)));\n         }\n       }\n+      item_native_mod(nm) {\n+        let abi = alt attr::native_abi(i.attrs) {\n+          either::left(msg) { cx.sess.span_fatal(i.span, msg); }\n+          either::right(abi) { abi }\n+        };\n+        for nitem in nm.items {\n+            cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n+        }\n+      }\n+      item_class(_, _, ctor) {\n+        cx.map.insert(ctor.node.id, node_ctor(i));\n+      }\n       _ { }\n     }\n     alt i.node {\n@@ -179,11 +195,6 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     }\n }\n \n-fn map_native_item(i: @native_item, cx: ctx, v: vt) {\n-    cx.map.insert(i.id, node_native_item(i, @cx.path));\n-    visit::visit_native_item(i, cx, v);\n-}\n-\n fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);"}, {"sha": "6f53c56e32cb10b575001ae280f7242d7cf506f7", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 167, "deletions": 252, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -2111,7 +2111,7 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       ast_map::node_variant(v, _, pt) { (pt, v.node.name) }\n       ast_map::node_method(m, _, pt) { (pt, m.ident) }\n       // We can't monomorphize native functions\n-      ast_map::node_native_item(_, _) { ret none; }\n+      ast_map::node_native_item(_, _, _) { ret none; }\n       _ { fail \"unexpected node type\"; }\n     };\n     let pt = *pt + [path_name(ccx.names(name))];\n@@ -2128,11 +2128,11 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n       ast_map::node_item(@{node: ast::item_res(decl, _, _, _, _), _}, _) {\n         trans_res_ctor(ccx, pt, decl, fn_id.node, [], psubsts, lldecl);\n       }\n-      ast_map::node_variant(v, enum_id, _) {\n-        let tvs = ty::enum_variants(ccx.tcx, enum_id);\n+      ast_map::node_variant(v, enum_item, _) {\n+        let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n-        trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n+        trans_enum_variant(ccx, enum_item.id, v, this_tv.disr_val,\n                            (*tvs).len() == 1u, [], psubsts, lldecl);\n       }\n       ast_map::node_method(mth, impl_def_id, _) {\n@@ -2164,7 +2164,6 @@ fn maybe_instantiate_inline(ccx: crate_ctxt, fn_id: ast::def_id)\n                    ty::item_path_str(ccx.tcx, fn_id),\n                    item.id];\n             ccx.external.insert(fn_id, some(item.id));\n-            collect_item(ccx, @mutable none, item);\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n@@ -2176,11 +2175,7 @@ fn maybe_instantiate_inline(ccx: crate_ctxt, fn_id: ast::def_id)\n                    mth.id];\n             ccx.external.insert(fn_id, some(mth.id));\n             compute_ii_method_info(ccx, impl_did, mth) {|ty, bounds, path|\n-                let mth_ty = ty::node_id_to_type(ccx.tcx, mth.id);\n-                let llfn = register_fn_full(ccx, mth.span, path,\n-                                            \"impl_method\", bounds,\n-                                            mth.id, mth_ty);\n-                set_inline_hint_if_appr(mth.attrs, llfn);\n+                let llfn = get_item_val(ccx, mth.id);\n                 trans_fn(ccx, path, mth.decl, mth.body,\n                          llfn, impl_self(ty), bounds,\n                          none, mth.id, none);\n@@ -2243,8 +2238,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n-        assert (ccx.item_ids.contains_key(fn_id.node));\n-        ccx.item_ids.get(fn_id.node)\n+        get_item_val(ccx, fn_id.node)\n     } else {\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n@@ -2375,8 +2369,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id, path: @ast::path)\n       }\n       ast::def_const(did) {\n         if did.crate == ast::local_crate {\n-            assert (ccx.consts.contains_key(did.node));\n-            ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n+            ret lval_no_env(cx, get_item_val(ccx, did.node), owned);\n         } else {\n             let tp = node_id_type(cx, id);\n             let val = trans_external_path(cx, did, {bounds: @[], ty: tp});\n@@ -4323,19 +4316,14 @@ fn trans_const_expr(cx: crate_ctxt, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-fn trans_const(cx: crate_ctxt, e: @ast::expr, id: ast::node_id) {\n-    let v = trans_const_expr(cx, e);\n+fn trans_const(ccx: crate_ctxt, e: @ast::expr, id: ast::node_id) {\n+    let v = trans_const_expr(ccx, e);\n \n     // The scalars come back as 1st class LLVM vals\n     // which we have to stick into global constants.\n-\n-    alt cx.consts.find(id) {\n-      some(g) {\n-        llvm::LLVMSetInitializer(g, v);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-      }\n-      _ { cx.sess.span_bug(e.span, \"unbound const in trans_const\"); }\n-    }\n+    let g = get_item_val(ccx, id);\n+    llvm::LLVMSetInitializer(g, v);\n+    llvm::LLVMSetGlobalConstant(g, True);\n }\n \n fn trans_item(ccx: crate_ctxt, item: ast::item) {\n@@ -4344,15 +4332,7 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n     };\n     alt item.node {\n       ast::item_fn(decl, tps, body) {\n-        let llfndecl = alt ccx.item_ids.find(item.id) {\n-          some(llfndecl) { llfndecl }\n-          _ {\n-            ccx.sess.span_bug(\n-                item.span,\n-                #fmt[\"unbound function item %s in trans_item\",\n-                     ast_map::path_to_str(*path)]);\n-          }\n-        };\n+        let llfndecl = get_item_val(ccx, item.id);\n         if decl.purity != ast::crust_fn  {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n                      llfndecl, no_self, param_bounds(ccx, tps),\n@@ -4366,21 +4346,15 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n         impl::trans_impl(ccx, *path, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n-        let llctor_decl = ccx.item_ids.get(ctor_id);\n+        let llctor_decl = get_item_val(ccx, ctor_id);\n         trans_res_ctor(ccx, *path, decl, ctor_id,\n                        param_bounds(ccx, tps), none, llctor_decl);\n \n         // Create a function for the destructor\n-        alt ccx.item_ids.find(item.id) {\n-          some(lldtor_decl) {\n-            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     lldtor_decl, no_self, param_bounds(ccx, tps),\n-                     none, dtor_id, none);\n-          }\n-          _ {\n-            ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n-          }\n-        }\n+        let lldtor_decl = get_item_val(ccx, item.id);\n+        trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+                 lldtor_decl, no_self, param_bounds(ccx, tps),\n+                 none, dtor_id, none);\n       }\n       ast::item_mod(m) {\n         trans_mod(ccx, m);\n@@ -4393,7 +4367,7 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n             if variant.node.args.len() > 0u {\n                 trans_enum_variant(ccx, item.id, variant,\n                                    vi[i].disr_val, degen, tps,\n-                                   none, ccx.item_ids.get(variant.node.id));\n+                                   none, get_item_val(ccx, variant.node.id));\n             }\n             i += 1;\n         }\n@@ -4407,81 +4381,74 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n         native::trans_native_mod(ccx, native_mod, abi);\n       }\n       ast::item_class(tps, items, ctor) {\n-          alt ccx.item_ids.find(ctor.node.id) {\n-             some(llctor_decl) {\n-             // Translate the ctor\n-             // First, add a preamble that\n-             // generates a new name, obj:\n-             // let obj = { ... } (uninit record fields)\n-                 let sess = ccx.sess;\n-                 let rslt_path_ = {global: false,\n-                                   idents: [\"obj\"],\n-                                   types: []}; // ??\n-                 let rslt_path = @{node: rslt_path_,\n-                                  span: ctor.node.body.span};\n-                 let rslt_id : ast::node_id = sess.next_node_id();\n-                 let rslt_pat : @ast::pat =\n-                     @{id: sess.next_node_id(),\n-                       node: ast::pat_ident(rslt_path, none),\n-                       span: ctor.node.body.span};\n-                 // Set up obj's type\n-                 let rslt_ast_ty : @ast::ty = @{node: ast::ty_infer,\n-                                    span: ctor.node.body.span};\n-                 // kludgy\n-                 let ty_args = [], i = 0u;\n-                 for tp in tps {\n-                   ty_args += [ty::mk_param(ccx.tcx, i,\n-                                            local_def(tps[i].id))];\n-                 }\n-                 let rslt_ty =  ty::mk_class(ccx.tcx,\n-                                                  local_def(item.id),\n-                                             ty_args);\n-                 // Set up a local for obj\n-                 let rslt_loc_ : ast::local_ = {is_mutbl: true,\n-                                  ty: rslt_ast_ty, // ???\n-                                  pat: rslt_pat,\n-                                  init: none::<ast::initializer>,\n-                                  id: rslt_id};\n-                 // Register a type for obj\n-                 smallintmap::insert(*ccx.tcx.node_types,\n-                                     rslt_loc_.id as uint, rslt_ty);\n-                 // Create the decl statement that initializers obj\n-                 let rslt_loc : @ast::local =\n-                     @{node: rslt_loc_, span: ctor.node.body.span};\n-                 let rslt_decl_ : ast::decl_ = ast::decl_local([rslt_loc]);\n-                 let rslt_decl : @ast::decl\n-                     = @{node: rslt_decl_, span: ctor.node.body.span};\n-                 let prologue : @ast::stmt = @{node: ast::stmt_decl(rslt_decl,\n-                                                     sess.next_node_id()),\n-                                              span: ctor.node.body.span};\n-                 let rslt_node_id = sess.next_node_id();\n-                 ccx.tcx.def_map.insert(rslt_node_id,\n-                          ast::def_local(rslt_loc_.id, true));\n-                 // And give the statement a type\n-                 smallintmap::insert(*ccx.tcx.node_types,\n-                                     rslt_node_id as uint, rslt_ty);\n-                 // The result expression of the constructor is now a\n-                 // reference to obj\n-                 let rslt_expr : @ast::expr =\n-                     @{id: rslt_node_id,\n-                       node: ast::expr_path(rslt_path),\n-                       span: ctor.node.body.span};\n-                 let ctor_body_new : ast::blk_ = {stmts: [prologue]\n-                                      + ctor.node.body.node.stmts,\n-                                       expr: some(rslt_expr)\n-                                     with ctor.node.body.node};\n-                 let ctor_body__ : ast::blk = {node: ctor_body_new\n-                                                with ctor.node.body};\n-             trans_fn(ccx, *path + [path_name(item.ident)], ctor.node.dec,\n-                      ctor_body__, llctor_decl, no_self,\n-                      param_bounds(ccx, tps), none, ctor.node.id,\n-                      some(rslt_expr));\n-             // TODO: translate methods!\n-             }\n-             _ {\n-               ccx.sess.span_bug(item.span, \"unbound ctor in trans_item\");\n-             }\n-          }\n+        let llctor_decl = get_item_val(ccx, ctor.node.id);\n+        // Translate the ctor\n+        // First, add a preamble that\n+        // generates a new name, obj:\n+        // let obj = { ... } (uninit record fields)\n+        let rslt_path_ = {global: false,\n+                          idents: [\"obj\"],\n+                          types: []}; // ??\n+        let rslt_path = @{node: rslt_path_,\n+                          span: ctor.node.body.span};\n+        let rslt_id : ast::node_id = ccx.sess.next_node_id();\n+        let rslt_pat : @ast::pat =\n+            @{id: ccx.sess.next_node_id(),\n+              node: ast::pat_ident(rslt_path, none),\n+              span: ctor.node.body.span};\n+        // Set up obj's type\n+        let rslt_ast_ty : @ast::ty = @{node: ast::ty_infer,\n+                                       span: ctor.node.body.span};\n+        // kludgy\n+        let ty_args = [], i = 0u;\n+        for tp in tps {\n+            ty_args += [ty::mk_param(ccx.tcx, i,\n+                                     local_def(tps[i].id))];\n+        }\n+        let rslt_ty =  ty::mk_class(ccx.tcx,\n+                                    local_def(item.id),\n+                                    ty_args);\n+        // Set up a local for obj\n+        let rslt_loc_ : ast::local_ = {is_mutbl: true,\n+                                       ty: rslt_ast_ty, // ???\n+                                       pat: rslt_pat,\n+                                       init: none::<ast::initializer>,\n+                                       id: rslt_id};\n+        // Register a type for obj\n+        smallintmap::insert(*ccx.tcx.node_types,\n+                            rslt_loc_.id as uint, rslt_ty);\n+        // Create the decl statement that initializers obj\n+        let rslt_loc : @ast::local =\n+            @{node: rslt_loc_, span: ctor.node.body.span};\n+        let rslt_decl_ : ast::decl_ = ast::decl_local([rslt_loc]);\n+        let rslt_decl : @ast::decl\n+            = @{node: rslt_decl_, span: ctor.node.body.span};\n+        let prologue = @{node: ast::stmt_decl(rslt_decl,\n+                                              ccx.sess.next_node_id()),\n+                         span: ctor.node.body.span};\n+        let rslt_node_id = ccx.sess.next_node_id();\n+        ccx.tcx.def_map.insert(rslt_node_id,\n+                               ast::def_local(rslt_loc_.id, true));\n+        // And give the statement a type\n+        smallintmap::insert(*ccx.tcx.node_types,\n+                            rslt_node_id as uint, rslt_ty);\n+        // The result expression of the constructor is now a\n+        // reference to obj\n+        let rslt_expr : @ast::expr =\n+            @{id: rslt_node_id,\n+              node: ast::expr_path(rslt_path),\n+              span: ctor.node.body.span};\n+        let ctor_body_new : ast::blk_ = {stmts: [prologue]\n+                                             + ctor.node.body.node.stmts,\n+                                         expr: some(rslt_expr)\n+                                         with ctor.node.body.node};\n+        let ctor_body__ : ast::blk = {node: ctor_body_new\n+                                      with ctor.node.body};\n+        trans_fn(ccx, *path + [path_name(item.ident)], ctor.node.dec,\n+                 ctor_body__, llctor_decl, no_self,\n+                 param_bounds(ccx, tps), none, ctor.node.id,\n+                 some(rslt_expr));\n+        // TODO: translate methods!\n       }\n       _ {/* fall through */ }\n     }\n@@ -4538,7 +4505,6 @@ fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n                       cc: lib::llvm::CallConv, llfty: TypeRef) -> ValueRef {\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n-    ccx.item_ids.insert(node_id, llfn);\n     ccx.item_symbols.insert(node_id, ps);\n \n     #debug[\"register_fn_fuller created fn %s for item %d with path %s\",\n@@ -4649,145 +4615,96 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-fn collect_native_item(ccx: crate_ctxt,\n-                       abi: @mutable option<ast::native_abi>,\n-                       i: @ast::native_item) {\n-    alt i.node {\n-      ast::native_item_fn(_, tps) {\n-        let id = i.id;\n-        let node_type = ty::node_id_to_type(ccx.tcx, id);\n-        let fn_abi =\n-            alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n-            option::none {\n-                // if abi isn't specified for this function, inherit from\n-                  // its enclosing native module\n-                  option::get(*abi)\n-              }\n-                _ {\n-                    alt attr::native_abi(i.attrs) {\n-                      either::right(abi_) { abi_ }\n-                      either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n-                    }\n-                }\n-            };\n-        alt fn_abi {\n-          ast::native_abi_rust_intrinsic {\n-            // For intrinsics: link the function directly to the intrinsic\n-            // function itself.\n-            let fn_type = type_of_fn_from_ty(\n-                ccx, node_type, param_bounds(ccx, tps));\n-            let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n-            let llnativefn = get_extern_fn(\n-                ccx.externs, ccx.llmod, ri_name,\n-                lib::llvm::CCallConv, fn_type);\n-            ccx.item_ids.insert(id, llnativefn);\n-            ccx.item_symbols.insert(id, ri_name);\n-          }\n-\n-          ast::native_abi_cdecl | ast::native_abi_stdcall {\n-            // For true external functions: create a rust wrapper\n-            // and link to that.  The rust wrapper will handle\n-            // switching to the C stack.\n-            let path = *alt check ccx.tcx.items.get(i.id) {\n-              ast_map::node_native_item(_, p) { p }\n-            } + [path_name(i.ident)];\n-            register_fn(ccx, i.span, path, \"native fn\", tps, i.id);\n-          }\n-        }\n-      }\n-      _ { }\n-    }\n-}\n-\n fn item_path(ccx: crate_ctxt, i: @ast::item) -> path {\n     *alt check ccx.tcx.items.get(i.id) {\n       ast_map::node_item(_, p) { p }\n     } + [path_name(i.ident)]\n }\n \n-fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n-                i: @ast::item) {\n-    let my_path = item_path(ccx, i);\n-    alt i.node {\n-      ast::item_const(_, _) {\n-        let typ = ty::node_id_to_type(ccx.tcx, i.id);\n-        let s = mangle_exported_name(ccx, my_path, typ);\n-        let g = str::as_buf(s, {|buf|\n-            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n-        });\n-        ccx.item_symbols.insert(i.id, s);\n-        ccx.consts.insert(i.id, g);\n-      }\n-      ast::item_native_mod(native_mod) {\n-        // Propagate the native ABI down to collect_native_item(),\n-        alt attr::native_abi(i.attrs) {\n-          either::left(msg) { ccx.sess.span_fatal(i.span, msg); }\n-          either::right(abi_) { *abi = option::some(abi_); }\n-        }\n-      }\n-      ast::item_fn(decl, tps, _) {\n-        let llfn = if decl.purity != ast::crust_fn {\n-            register_fn(ccx, i.span, my_path, \"fn\", tps, i.id)\n-        } else {\n-            native::register_crust_fn(ccx, i.span, my_path, i.id)\n-        };\n-\n-        set_inline_hint_if_appr(i.attrs, llfn);\n-      }\n-      ast::item_impl(tps, _, _, methods) {\n-        let path = my_path + [path_name(int::str(i.id))];\n-        for m in methods {\n-            let llm  = register_fn(ccx, i.span,\n-                                   path + [path_name(m.ident)],\n-                                   \"impl_method\", tps + m.tps, m.id);\n-            set_inline_hint_if_appr(m.attrs, llm);\n-        }\n-      }\n-      ast::item_res(_, tps, _, dtor_id, ctor_id) {\n-        let llctor = register_fn(ccx, i.span, my_path, \"res_ctor\", tps,\n-                                 ctor_id);\n-\n-        // Note that the destructor is associated with the item's id, not\n-        // the dtor_id. This is a bit counter-intuitive, but simplifies\n-        // ty_res, which would have to carry around two def_ids otherwise\n-        // -- one to identify the type, and one to find the dtor symbol.\n-        let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n-        let lldtor = register_fn_full(ccx, i.span, my_path +\n-                                      [path_name(\"dtor\")], \"res_dtor\",\n-                                      param_bounds(ccx, tps), i.id, t);\n-\n-        // give hints that resource ctors/dtors ought to be inlined\n-        set_inline_hint(llctor);\n-        set_inline_hint(lldtor);\n-      }\n-      ast::item_enum(variants, tps) {\n-        for variant in variants {\n-            if variant.node.args.len() != 0u {\n-                register_fn(ccx, i.span,\n-                            my_path + [path_name(variant.node.name)],\n-                            \"enum\", tps, variant.node.id);\n+fn get_item_val(ccx: crate_ctxt, id: ast::node_id) -> ValueRef {\n+    alt ccx.item_vals.find(id) {\n+      some(v) { v }\n+      none {\n+        let val = alt check ccx.tcx.items.get(id) {\n+          ast_map::node_item(i, pth) {\n+            let my_path = *pth + [path_name(i.ident)];\n+            alt check i.node {\n+              ast::item_const(_, _) {\n+                let typ = ty::node_id_to_type(ccx.tcx, i.id);\n+                let s = mangle_exported_name(ccx, my_path, typ);\n+                let g = str::as_buf(s, {|buf|\n+                    llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n+                });\n+                ccx.item_symbols.insert(i.id, s);\n+                g\n+              }\n+              ast::item_fn(decl, tps, _) {\n+                let llfn = if decl.purity != ast::crust_fn {\n+                    register_fn(ccx, i.span, my_path, \"fn\", tps, i.id)\n+                } else {\n+                    native::register_crust_fn(ccx, i.span, my_path, i.id)\n+                };\n+                set_inline_hint_if_appr(i.attrs, llfn);\n+                llfn\n+              }\n+              ast::item_res(_, tps, _, dtor_id, _) {\n+                // Note that the destructor is associated with the item's id,\n+                // not the dtor_id. This is a bit counter-intuitive, but\n+                // simplifies ty_res, which would have to carry around two\n+                // def_ids otherwise -- one to identify the type, and one to\n+                // find the dtor symbol.\n+                let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n+                register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n+                                 \"res_dtor\", param_bounds(ccx, tps), i.id, t)\n+              }\n             }\n-        }\n-      }\n-      ast::item_class(tps,_,ctor) {\n-          // Register the ctor\n-          let t = ty::node_id_to_type(ccx.tcx, ctor.node.id);\n-          register_fn_full(ccx, i.span, my_path, \"ctor\",\n-                           param_bounds(ccx, tps), ctor.node.id, t);\n+          }\n+          ast_map::node_method(m, impl_id, pth) {\n+            let mty = ty::node_id_to_type(ccx.tcx, id);\n+            let impl_tps = *ty::lookup_item_type(ccx.tcx, impl_id).bounds;\n+            let pth = *pth + [path_name(int::str(impl_id.node)),\n+                              path_name(m.ident)];\n+            let llfn = register_fn_full(ccx, m.span, pth, \"impl_method\",\n+                                        impl_tps + param_bounds(ccx, m.tps),\n+                                        id, mty);\n+            set_inline_hint_if_appr(m.attrs, llfn);\n+            llfn\n+          }\n+          ast_map::node_native_item(ni, _, pth) {\n+            native::decl_native_fn(ccx, ni, *pth + [path_name(ni.ident)])\n+          }\n+          ast_map::node_ctor(i) {\n+            alt check i.node {\n+              ast::item_res(_, tps, _, _, _) {\n+                let my_path = item_path(ccx, i);\n+                let llctor = register_fn(ccx, i.span, my_path, \"res_ctor\",\n+                                         tps, id);\n+                set_inline_hint(llctor);\n+                llctor\n+              }\n+              ast::item_class(tps, _, ctor) {\n+                register_fn(ccx, i.span, item_path(ccx, i), \"ctor\", tps, id)\n+              }\n+            }\n+          }\n+          ast_map::node_variant(v, enm, pth) {\n+            assert v.node.args.len() != 0u;\n+            let pth = *pth + [path_name(enm.ident), path_name(v.node.name)];\n+            let llfn = alt check enm.node {\n+              ast::item_enum(_, tps) {\n+                register_fn(ccx, v.span, pth, \"enum\", tps, id)\n+              }\n+            };\n+            set_inline_hint(llfn);\n+            llfn\n+          }\n+        };\n+        ccx.item_vals.insert(id, val);\n+        val\n       }\n-      _ { }\n     }\n }\n \n-fn collect_items(ccx: crate_ctxt, crate: @ast::crate) {\n-    let abi = @mutable none;\n-    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_native_item: bind collect_native_item(ccx, abi, _),\n-        visit_item: bind collect_item(ccx, abi, _)\n-        with *visit::default_simple_visitor()\n-    }));\n-}\n-\n // The constant translation pass.\n fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n     alt it.node {\n@@ -5043,15 +4960,14 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           tn: tn,\n           externs: new_str_hash::<ValueRef>(),\n           intrinsics: intrinsics,\n-          item_ids: new_int_hash::<ValueRef>(),\n+          item_vals: new_int_hash::<ValueRef>(),\n           exp_map: emap,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n           link_meta: link_meta,\n           enum_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n-          consts: new_int_hash::<ValueRef>(),\n           tydescs: ty::new_ty_hash(),\n           dicts: map::mk_hashmap(hash_dict_id, {|a, b| a == b}),\n           external: util::common::new_def_hash(),\n@@ -5084,7 +5000,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n-    collect_items(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(ccx, crate.node.module);\n     fill_crate_map(ccx, crate_map);"}, {"sha": "82f826d9ee8da2d224a2f810465e6b33662ad8ac", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -81,15 +81,14 @@ type crate_ctxt = @{\n      tn: type_names,\n      externs: hashmap<str, ValueRef>,\n      intrinsics: hashmap<str, ValueRef>,\n-     item_ids: hashmap<ast::node_id, ValueRef>,\n+     item_vals: hashmap<ast::node_id, ValueRef>,\n      exp_map: resolve::exp_map,\n      item_symbols: hashmap<ast::node_id, str>,\n      mutable main_fn: option<ValueRef>,\n      link_meta: link::link_meta,\n      enum_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::def_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n-     consts: hashmap<ast::node_id, ValueRef>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      dicts: hashmap<dict_id, ValueRef>,\n      // Track mapping of external ids to local items imported for inlining\n@@ -300,10 +299,7 @@ fn revoke_clean(cx: block, val: ValueRef) {\n fn get_res_dtor(ccx: crate_ctxt, did: ast::def_id, inner_t: ty::t)\n    -> ValueRef {\n     if did.crate == ast::local_crate {\n-        alt ccx.item_ids.find(did.node) {\n-          some(x) { ret x; }\n-          _ { ccx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n-        }\n+        ret base::get_item_val(ccx, did.node);\n     }\n \n     let param_bounds = ty::lookup_item_type(ccx.tcx, did).bounds;"}, {"sha": "fd3f94625d1f121db595a8ec7b1236c1df385279", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -793,7 +793,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n-      ast_map::node_res_ctor(item) {\n+      ast_map::node_ctor(item) {\n         alt item.node {\n             ast::item_res(decl, _, _, _, ctor_id) {\n               (item.ident, decl.output, ctor_id)"}, {"sha": "16cc55a6f944daadfae4fa84f3a8242e08869798", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -48,17 +48,11 @@ fn trans_impl(ccx: crate_ctxt, path: path, name: ast::ident,\n               tps: [ast::ty_param]) {\n     let sub_path = path + [path_name(name)];\n     for m in methods {\n-        alt ccx.item_ids.find(m.id) {\n-          some(llfn) {\n-            let m_bounds = param_bounds(ccx, tps + m.tps);\n-            trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n-                     llfn, impl_self(ty::node_id_to_type(ccx.tcx, id)),\n-                     m_bounds, none, m.id, none);\n-          }\n-          _ {\n-            ccx.sess.bug(\"unbound id in trans_impl\");\n-          }\n-        }\n+        let llfn = get_item_val(ccx, m.id);\n+        let m_bounds = param_bounds(ccx, tps + m.tps);\n+        trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n+                 llfn, impl_self(ty::node_id_to_type(ccx.tcx, id)),\n+                 m_bounds, none, m.id, none);\n     }\n }\n \n@@ -222,7 +216,7 @@ fn trans_vtable(ccx: crate_ctxt, id: ast::node_id, name: str,\n     });\n     llvm::LLVMSetInitializer(vt_gvar, tbl);\n     llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n-    ccx.item_ids.insert(id, vt_gvar);\n+    ccx.item_vals.insert(id, vt_gvar);\n     ccx.item_symbols.insert(id, name);\n }\n \n@@ -343,13 +337,12 @@ fn trans_impl_vtable(ccx: crate_ctxt, pt: path,\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, iface_id), {|im|\n         alt vec::find(ms, {|m| m.ident == im.ident}) {\n           some(m) {\n-            let target = ccx.item_ids.get(m.id);\n             trans_impl_wrapper(ccx, new_pt + [path_name(m.ident)],\n-                               extra_tps, target)\n+                               extra_tps, get_item_val(ccx, m.id))\n           }\n           _ {\n             ccx.sess.span_bug(it.span, \"no matching method \\\n-               in trans_impl_vtable\");\n+                                        in trans_impl_vtable\");\n           }\n         }\n     });\n@@ -491,7 +484,7 @@ fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n     let ccx = bcx.ccx();\n     fn get_vtable(ccx: crate_ctxt, did: ast::def_id) -> ValueRef {\n         if did.crate == ast::local_crate {\n-            ccx.item_ids.get(did.node)\n+            get_item_val(ccx, did.node)\n         } else {\n             let name = csearch::get_symbol(ccx.sess.cstore, did);\n             get_extern_const(ccx.externs, ccx.llmod, name, T_ptr(T_i8()))"}, {"sha": "ba2c60a6bc9b5c1cc7f5b3f2048215e2e728af40", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -11,7 +11,8 @@ import base::*;\n import type_of::*;\n import std::map::hashmap;\n \n-export link_name, trans_native_mod, register_crust_fn, trans_crust_fn;\n+export link_name, trans_native_mod, register_crust_fn, trans_crust_fn,\n+       decl_native_fn;\n \n fn link_name(i: @ast::native_item) -> str {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n@@ -238,7 +239,10 @@ fn trans_native_mod(ccx: crate_ctxt,\n \n     let cc = lib::llvm::CCallConv;\n     alt abi {\n-      ast::native_abi_rust_intrinsic { ret; }\n+      ast::native_abi_rust_intrinsic {\n+        for item in native_mod.items { get_item_val(ccx, item.id); }\n+        ret;\n+      }\n       ast::native_abi_cdecl { cc = lib::llvm::CCallConv; }\n       ast::native_abi_stdcall { cc = lib::llvm::X86StdcallCallConv; }\n     }\n@@ -248,17 +252,9 @@ fn trans_native_mod(ccx: crate_ctxt,\n         ast::native_item_fn(fn_decl, tps) {\n           let id = native_item.id;\n           let tys = c_stack_tys(ccx, id);\n-          alt ccx.item_ids.find(id) {\n-            some(llwrapfn) {\n-              let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n-              build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n-            }\n-            none {\n-              ccx.sess.span_bug(\n-                  native_item.span,\n-                  \"unbound function item in trans_native_mod\");\n-            }\n-          }\n+          let llwrapfn = get_item_val(ccx, id);\n+          let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n+          build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n         }\n       }\n     }\n@@ -360,3 +356,48 @@ fn register_crust_fn(ccx: crate_ctxt, sp: span,\n     register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n                        t, lib::llvm::CCallConv, llfty)\n }\n+\n+fn abi_of_native_fn(ccx: crate_ctxt, i: @ast::native_item)\n+    -> ast::native_abi {\n+    alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n+      none {\n+        alt check ccx.tcx.items.get(i.id) {\n+          ast_map::node_native_item(_, abi, _) { abi }\n+        }\n+      }\n+      some(_) {\n+        alt attr::native_abi(i.attrs) {\n+          either::right(abi) { abi }\n+          either::left(msg) { ccx.sess.span_fatal(i.span, msg); }\n+        }\n+      }\n+    }\n+}\n+\n+fn decl_native_fn(ccx: crate_ctxt, i: @ast::native_item,\n+                  pth: ast_map::path) -> ValueRef {\n+    alt i.node {\n+      ast::native_item_fn(_, tps) {\n+        let node_type = ty::node_id_to_type(ccx.tcx, i.id);\n+        alt abi_of_native_fn(ccx, i) {\n+          ast::native_abi_rust_intrinsic {\n+            // For intrinsics: link the function directly to the intrinsic\n+            // function itself.\n+            let fn_type = type_of_fn_from_ty(\n+                ccx, node_type, param_bounds(ccx, tps));\n+            let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n+            ccx.item_symbols.insert(i.id, ri_name);\n+            get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n+                          lib::llvm::CCallConv, fn_type)\n+          }\n+\n+          ast::native_abi_cdecl | ast::native_abi_stdcall {\n+            // For true external functions: create a rust wrapper\n+            // and link to that.  The rust wrapper will handle\n+            // switching to the C stack.\n+            register_fn(ccx, i.span, pth, \"native fn\", tps, i.id)\n+          }\n+        }\n+      }\n+    }\n+}"}, {"sha": "fa4e254d9341d7a1670f80304143ff939b0009bc", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -2157,7 +2157,8 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n \n fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n-        option::map(cx.tcache.find(id), {|it| it.ty})\n+        let t = cx.tcache.get(id).ty;\n+        if get(t).struct == ty_nil { none } else { some(t) }\n     } else {\n         csearch::get_impl_iface(cx, id)\n     }\n@@ -2203,7 +2204,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             *path + [item_elt]\n           }\n \n-          ast_map::node_native_item(nitem, path) {\n+          ast_map::node_native_item(nitem, _, path) {\n             *path + [ast_map::path_name(nitem.ident)]\n           }\n \n@@ -2216,7 +2217,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n-          ast_map::node_local(_) | ast_map::node_res_ctor(_) |\n+          ast_map::node_local(_) | ast_map::node_ctor(_) |\n           ast_map::node_export(_, _) {\n             cx.sess.bug(#fmt[\"cannot find item_path for node %?\", node]);\n           }"}, {"sha": "998ffa654d470fa0c089e3bdb380a8e96442a094", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -258,7 +258,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                   some(ast_map::node_item(item, _)) {\n                     ty_of_item(tcx, mode, item)\n                   }\n-                  some(ast_map::node_native_item(native_item, _)) {\n+                  some(ast_map::node_native_item(native_item, _, _)) {\n                     ty_of_native_item(tcx, mode, native_item)\n                   }\n                   _ {\n@@ -906,7 +906,11 @@ mod collect {\n                   }\n                 }\n               }\n-              _ {}\n+              _ {\n+                // Store the bounds with a nil type.\n+                tcx.tcache.insert(local_def(it.id), {bounds: i_bounds,\n+                                                     ty: ty::mk_nil(tcx)});\n+              }\n             }\n           }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {"}, {"sha": "7bbc8fc3b43643a6ff9e2f8936b362bbc06c58fa", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -109,7 +109,7 @@ fn build_ctxt(sess: session::session, ast: @ast::crate,\n \n     let ast = config::strip_unconfigured_items(ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n-    let ast_map = ast_map::map_crate(*ast);\n+    let ast_map = ast_map::map_crate(sess, *ast);\n     *ignore_errors = true;\n     let exp_map = resolve::resolve_crate_reexports(sess, ast_map, ast);\n     *ignore_errors = false;"}, {"sha": "20c7591417e8c3cc47a6bb688834b39eacbf279f", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -97,7 +97,7 @@ fn parse_item_attrs<T:send>(\n     astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) { item.attrs }\n-          ast_map::node_native_item(item, _) { item.attrs }\n+          ast_map::node_native_item(item, _, _) { item.attrs }\n           _ {\n             fail \"parse_item_attrs: not an item\";\n           }"}, {"sha": "5ad366115ea26cac87a0879b2721f2022e22b304", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd465f91a89450b7daebecdde9c280a923bbe394/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=fd465f91a89450b7daebecdde9c280a923bbe394", "patch": "@@ -57,7 +57,7 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           ast_map::node_native_item(@{\n             ident: ident,\n             node: ast::native_item_fn(decl, _), _\n-          }, _) {\n+          }, _, _) {\n             some(pprust::fun_to_str(decl, ident, []))\n           }\n         }\n@@ -100,7 +100,7 @@ fn get_ret_ty(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           }, _) |\n           ast_map::node_native_item(@{\n             node: ast::native_item_fn(decl, _), _\n-          }, _) {\n+          }, _, _) {\n             ret_ty_to_str(decl)\n           }\n         }\n@@ -161,7 +161,7 @@ fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n           }, _) |\n           ast_map::node_native_item(@{\n             node: ast::native_item_fn(decl, _), _\n-          }, _) {\n+          }, _, _) {\n             decl_arg_tys(decl)\n           }\n         }"}]}