{"sha": "857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "node_id": "C_kwDOAAsO6NoAKDg1N2FmYzc1ZTZjYTY5Y2M3ZGNhZTM2YTZmYWM4YzA5M2VlNmZhMzE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-20T16:58:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-20T16:58:14Z"}, "message": "Rollup merge of #99212 - davidtwco:partial-stability-implies, r=michaelwoerister\n\nintroduce `implied_by` in `#[unstable]` attribute\n\nRequested by the library team [on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/better.20support.20for.20partial.20stabilizations/near/285581519).\n\nIf part of a feature is stabilized and a new feature is added for the remaining parts, then the `implied_by` meta-item can be added to `#[unstable]` to indicate which now-stable feature was used previously.\n\n```diagnostic\nerror: the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n  --> $DIR/stability-attribute-implies-using-unstable.rs:3:12\n   |\nLL | #![feature(foo)]\n   |            ^^^\n   |\nnote: the lint level is defined here\n  --> $DIR/stability-attribute-implies-using-stable.rs:2:9\n   |\nLL | #![deny(stable_features)]\n   |         ^^^^^^^^^^^^^^^\nhelp: if you are using features which are still unstable, change to using `foobar`\n   |\nLL | #![feature(foobar)]\n   |            ~~~~~~\nhelp: if you are using features which are now stable, remove this line\n   |\nLL - #![feature(foo)]\n   |\n```\n\nWhen a `#![feature(..)]` attribute still exists for the now-stable attribute, then there this has two effects:\n\n- There will not be an stability error for uses of items from the implied feature which are still unstable (until the `#![feature(..)]` is removed or updated to the new feature).\n- There will be an improved diagnostic for the remaining use of the feature attribute for the now-stable feature.\n\n```rust\n        /// If part of a feature is stabilized and a new feature is added for the remaining parts,\n        /// then the `implied_by` attribute is used to indicate which now-stable feature previously\n        /// contained a item.\n        ///\n        /// ```pseudo-Rust\n        /// #[unstable(feature = \"foo\", issue = \"...\")]\n        /// fn foo() {}\n        /// #[unstable(feature = \"foo\", issue = \"...\")]\n        /// fn foobar() {}\n        /// ```\n        ///\n        /// ...becomes...\n        ///\n        /// ```pseudo-Rust\n        /// #[stable(feature = \"foo\", since = \"1.XX.X\")]\n        /// fn foo() {}\n        /// #[unstable(feature = \"foobar\", issue = \"...\", implied_by = \"foo\")]\n        /// fn foobar() {}\n        /// ```\n```\n\nIn the Zulip discussion, this was envisioned as `implies` on `#[stable]` but I went with `implied_by` on `#[unstable]` because it means that only the unstable attribute needs to be changed in future, not the new stable attribute, which seems less error-prone. It also isn't particularly feasible for me to detect whether items from the implied feature are used and then only suggest updating _or_ removing the `#![feature(..)]` as appropriate, so I always do both.\n\nThere's some new information in the cross-crate metadata as a result of this change, that's a little unfortunate, but without requiring that the `#[unstable]` and `#[stable]` attributes both contain the implication information, it's necessary:\n\n```rust\n    /// This mapping is necessary unless both the `#[stable]` and `#[unstable]` attributes should\n    /// specify their implications (both `implies` and `implied_by`). If only one of the two\n    /// attributes do (as in the current implementation, `implied_by` in `#[unstable]`), then this\n    /// mapping is necessary for diagnostics. When a \"unnecessary feature attribute\" error is\n    /// reported, only the `#[stable]` attribute information is available, so the map is necessary\n    /// to know that the feature implies another feature. If it were reversed, and the `#[stable]`\n    /// attribute had an `implies` meta item, then a map would be necessary when avoiding a \"use of\n    /// unstable feature\" error for a feature that was implied.\n```\n\nI also change some comments to documentation comments in the compiler, add a helper for going from a `Span` to a `Span` for the entire line, and fix a incorrect part of the pre-existing stability attribute diagnostics.\n\ncc `@yaahc`", "tree": {"sha": "de307833a7c06a03bbcfa7da7bfb7ae54bf26f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de307833a7c06a03bbcfa7da7bfb7ae54bf26f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi2DQnCRBK7hj4Ov3rIwAAGZwIAD02ciN31POJ9VXrcWqIalHU\nA2Y4HApEC27QOH0oCf11j/WJtqo+OfZZtdDl1R2hHZcgpH5hqVFsaB43OAjytcHo\n2+ac3lfX/HZ9ATMK0dyLzPWZ0fuxdpbupB/kqJiWwZpP+Cd8me8FQZ/GEtQbb5TN\n4JhJosfk5vxHAeFTN5j7qFxokR4APPUA8OBsO4tyjbHVlGK4dH9ChKdNWcIr/z72\nFIYwGEiq0h13g5P/MKNOMZCC9TQ0we5vMgpwBZpV3VUo6vx/L3w1saE5wZhRUQEH\nRZPIyg2jpswrPNLqtJeahCwUHpCnAv1IUN6rJQdLWWgm+WncER1Xku5gN6ttBJU=\n=iTTe\n-----END PGP SIGNATURE-----\n", "payload": "tree de307833a7c06a03bbcfa7da7bfb7ae54bf26f5f\nparent 14dbfebfa25a0e626ad827526934381b2545cbb4\nparent e5872990d13abb088397e23b226439b1b4926b91\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1658336294 +0200\ncommitter GitHub <noreply@github.com> 1658336294 +0200\n\nRollup merge of #99212 - davidtwco:partial-stability-implies, r=michaelwoerister\n\nintroduce `implied_by` in `#[unstable]` attribute\n\nRequested by the library team [on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/better.20support.20for.20partial.20stabilizations/near/285581519).\n\nIf part of a feature is stabilized and a new feature is added for the remaining parts, then the `implied_by` meta-item can be added to `#[unstable]` to indicate which now-stable feature was used previously.\n\n```diagnostic\nerror: the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n  --> $DIR/stability-attribute-implies-using-unstable.rs:3:12\n   |\nLL | #![feature(foo)]\n   |            ^^^\n   |\nnote: the lint level is defined here\n  --> $DIR/stability-attribute-implies-using-stable.rs:2:9\n   |\nLL | #![deny(stable_features)]\n   |         ^^^^^^^^^^^^^^^\nhelp: if you are using features which are still unstable, change to using `foobar`\n   |\nLL | #![feature(foobar)]\n   |            ~~~~~~\nhelp: if you are using features which are now stable, remove this line\n   |\nLL - #![feature(foo)]\n   |\n```\n\nWhen a `#![feature(..)]` attribute still exists for the now-stable attribute, then there this has two effects:\n\n- There will not be an stability error for uses of items from the implied feature which are still unstable (until the `#![feature(..)]` is removed or updated to the new feature).\n- There will be an improved diagnostic for the remaining use of the feature attribute for the now-stable feature.\n\n```rust\n        /// If part of a feature is stabilized and a new feature is added for the remaining parts,\n        /// then the `implied_by` attribute is used to indicate which now-stable feature previously\n        /// contained a item.\n        ///\n        /// ```pseudo-Rust\n        /// #[unstable(feature = \"foo\", issue = \"...\")]\n        /// fn foo() {}\n        /// #[unstable(feature = \"foo\", issue = \"...\")]\n        /// fn foobar() {}\n        /// ```\n        ///\n        /// ...becomes...\n        ///\n        /// ```pseudo-Rust\n        /// #[stable(feature = \"foo\", since = \"1.XX.X\")]\n        /// fn foo() {}\n        /// #[unstable(feature = \"foobar\", issue = \"...\", implied_by = \"foo\")]\n        /// fn foobar() {}\n        /// ```\n```\n\nIn the Zulip discussion, this was envisioned as `implies` on `#[stable]` but I went with `implied_by` on `#[unstable]` because it means that only the unstable attribute needs to be changed in future, not the new stable attribute, which seems less error-prone. It also isn't particularly feasible for me to detect whether items from the implied feature are used and then only suggest updating _or_ removing the `#![feature(..)]` as appropriate, so I always do both.\n\nThere's some new information in the cross-crate metadata as a result of this change, that's a little unfortunate, but without requiring that the `#[unstable]` and `#[stable]` attributes both contain the implication information, it's necessary:\n\n```rust\n    /// This mapping is necessary unless both the `#[stable]` and `#[unstable]` attributes should\n    /// specify their implications (both `implies` and `implied_by`). If only one of the two\n    /// attributes do (as in the current implementation, `implied_by` in `#[unstable]`), then this\n    /// mapping is necessary for diagnostics. When a \"unnecessary feature attribute\" error is\n    /// reported, only the `#[stable]` attribute information is available, so the map is necessary\n    /// to know that the feature implies another feature. If it were reversed, and the `#[stable]`\n    /// attribute had an `implies` meta item, then a map would be necessary when avoiding a \"use of\n    /// unstable feature\" error for a feature that was implied.\n```\n\nI also change some comments to documentation comments in the compiler, add a helper for going from a `Span` to a `Span` for the entire line, and fix a incorrect part of the pre-existing stability attribute diagnostics.\n\ncc `@yaahc`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "html_url": "https://github.com/rust-lang/rust/commit/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14dbfebfa25a0e626ad827526934381b2545cbb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dbfebfa25a0e626ad827526934381b2545cbb4", "html_url": "https://github.com/rust-lang/rust/commit/14dbfebfa25a0e626ad827526934381b2545cbb4"}, {"sha": "e5872990d13abb088397e23b226439b1b4926b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5872990d13abb088397e23b226439b1b4926b91", "html_url": "https://github.com/rust-lang/rust/commit/e5872990d13abb088397e23b226439b1b4926b91"}], "stats": {"total": 419, "additions": 357, "deletions": 62}, "files": [{"sha": "64a6f91f02206f6472f00a6ada3ef730d94c5045", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -135,9 +135,42 @@ impl ConstStability {\n #[derive(Encodable, Decodable, PartialEq, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub enum StabilityLevel {\n-    // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<Symbol>, issue: Option<NonZeroU32>, is_soft: bool },\n-    Stable { since: Symbol, allowed_through_unstable_modules: bool },\n+    /// `#[unstable]`\n+    Unstable {\n+        /// Reason for the current stability level.\n+        reason: Option<Symbol>,\n+        /// Relevant `rust-lang/rust` issue.\n+        issue: Option<NonZeroU32>,\n+        is_soft: bool,\n+        /// If part of a feature is stabilized and a new feature is added for the remaining parts,\n+        /// then the `implied_by` attribute is used to indicate which now-stable feature previously\n+        /// contained a item.\n+        ///\n+        /// ```pseudo-Rust\n+        /// #[unstable(feature = \"foo\", issue = \"...\")]\n+        /// fn foo() {}\n+        /// #[unstable(feature = \"foo\", issue = \"...\")]\n+        /// fn foobar() {}\n+        /// ```\n+        ///\n+        /// ...becomes...\n+        ///\n+        /// ```pseudo-Rust\n+        /// #[stable(feature = \"foo\", since = \"1.XX.X\")]\n+        /// fn foo() {}\n+        /// #[unstable(feature = \"foobar\", issue = \"...\", implied_by = \"foo\")]\n+        /// fn foobar() {}\n+        /// ```\n+        implied_by: Option<Symbol>,\n+    },\n+    /// `#[stable]`\n+    Stable {\n+        /// Rust release which stabilized this feature.\n+        since: Symbol,\n+        /// Is this item allowed to be referred to on stable, despite being contained in unstable\n+        /// modules?\n+        allowed_through_unstable_modules: bool,\n+    },\n }\n \n impl StabilityLevel {\n@@ -243,6 +276,7 @@ where\n                     let mut issue = None;\n                     let mut issue_num = None;\n                     let mut is_soft = false;\n+                    let mut implied_by = None;\n                     for meta in metas {\n                         let Some(mi) = meta.meta_item() else {\n                             handle_errors(\n@@ -308,6 +342,11 @@ where\n                                 }\n                                 is_soft = true;\n                             }\n+                            sym::implied_by => {\n+                                if !get(mi, &mut implied_by) {\n+                                    continue 'outer;\n+                                }\n+                            }\n                             _ => {\n                                 handle_errors(\n                                     &sess.parse_sess,\n@@ -332,7 +371,7 @@ where\n                                 );\n                                 continue;\n                             }\n-                            let level = Unstable { reason, issue: issue_num, is_soft };\n+                            let level = Unstable { reason, issue: issue_num, is_soft, implied_by };\n                             if sym::unstable == meta_name {\n                                 stab = Some((Stability { level, feature }, attr.span));\n                             } else {\n@@ -391,7 +430,7 @@ where\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             pprust::path_to_string(&mi.path),\n-                                            &[\"since\", \"note\"],\n+                                            &[\"feature\", \"since\"],\n                                         ),\n                                     );\n                                     continue 'outer;"}, {"sha": "aa5705d3fcdc3c368820455749c6d6906e893ee5", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -951,6 +951,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n     }\n \n+    /// Iterates over the stability implications in the given crate (when a `#[unstable]` attribute\n+    /// has an `implied_by` meta item, then the mapping from the implied feature to the actual\n+    /// feature is a stability implication).\n+    fn get_stability_implications(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Symbol)] {\n+        tcx.arena.alloc_from_iter(self.root.stability_implications.decode(self))\n+    }\n+\n     /// Iterates over the language items in the given crate.\n     fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n         tcx.arena.alloc_from_iter("}, {"sha": "65cae29c58dcbdd21accf3086843208d21f3f1de", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -291,6 +291,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         tcx.arena.alloc_slice(&result)\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n+    stability_implications => {\n+        cdata.get_stability_implications(tcx).iter().copied().collect()\n+    }\n     is_intrinsic => { cdata.get_is_intrinsic(def_id.index) }\n     defined_lang_items => { cdata.get_lang_items(tcx) }\n     diagnostic_items => { cdata.get_diagnostic_items() }"}, {"sha": "50d983754e89c6204e1dbdc3905da4bda237b821", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -538,6 +538,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let lib_features = self.encode_lib_features();\n         let lib_feature_bytes = self.position() - i;\n \n+        // Encode the stability implications.\n+        i = self.position();\n+        let stability_implications = self.encode_stability_implications();\n+        let stability_implications_bytes = self.position() - i;\n+\n         // Encode the language items.\n         i = self.position();\n         let lang_items = self.encode_lang_items();\n@@ -686,6 +691,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             crate_deps,\n             dylib_dependency_formats,\n             lib_features,\n+            stability_implications,\n             lang_items,\n             diagnostic_items,\n             lang_items_missing,\n@@ -710,6 +716,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let computed_total_bytes = preamble_bytes\n             + dep_bytes\n             + lib_feature_bytes\n+            + stability_implications_bytes\n             + lang_item_bytes\n             + diagnostic_item_bytes\n             + native_lib_bytes\n@@ -761,6 +768,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             p(\"preamble\", preamble_bytes);\n             p(\"dep\", dep_bytes);\n             p(\"lib feature\", lib_feature_bytes);\n+            p(\"stability_implications\", stability_implications_bytes);\n             p(\"lang item\", lang_item_bytes);\n             p(\"diagnostic item\", diagnostic_item_bytes);\n             p(\"native lib\", native_lib_bytes);\n@@ -1777,6 +1785,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_array(lib_features.to_vec())\n     }\n \n+    fn encode_stability_implications(&mut self) -> LazyArray<(Symbol, Symbol)> {\n+        empty_proc_macro!(self);\n+        let tcx = self.tcx;\n+        let implications = tcx.stability_implications(LOCAL_CRATE);\n+        self.lazy_array(implications.iter().map(|(k, v)| (*k, *v)))\n+    }\n+\n     fn encode_diagnostic_items(&mut self) -> LazyArray<(Symbol, DefIndex)> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;"}, {"sha": "0f291f926477702c9924e57f7dff06361f085aa2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -226,6 +226,7 @@ pub(crate) struct CrateRoot {\n     crate_deps: LazyArray<CrateDep>,\n     dylib_dependency_formats: LazyArray<Option<LinkagePreference>>,\n     lib_features: LazyArray<(Symbol, Option<Symbol>)>,\n+    stability_implications: LazyArray<(Symbol, Symbol)>,\n     lang_items: LazyArray<(DefIndex, usize)>,\n     lang_items_missing: LazyArray<lang_items::LangItem>,\n     diagnostic_items: LazyArray<(Symbol, DefIndex)>,"}, {"sha": "8dc68b1f5a820d415d0e21d696eeaedf3c780000", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -3,23 +3,23 @@ pub mod dependency_format;\n pub mod exported_symbols;\n pub mod lang_items;\n pub mod lib_features {\n-    use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-    use rustc_span::symbol::Symbol;\n+    use rustc_data_structures::fx::FxHashMap;\n+    use rustc_span::{symbol::Symbol, Span};\n \n     #[derive(HashStable, Debug)]\n     pub struct LibFeatures {\n-        // A map from feature to stabilisation version.\n-        pub stable: FxHashMap<Symbol, Symbol>,\n-        pub unstable: FxHashSet<Symbol>,\n+        /// A map from feature to stabilisation version.\n+        pub stable: FxHashMap<Symbol, (Symbol, Span)>,\n+        pub unstable: FxHashMap<Symbol, Span>,\n     }\n \n     impl LibFeatures {\n         pub fn to_vec(&self) -> Vec<(Symbol, Option<Symbol>)> {\n             let mut all_features: Vec<_> = self\n                 .stable\n                 .iter()\n-                .map(|(f, s)| (*f, Some(*s)))\n-                .chain(self.unstable.iter().map(|f| (*f, None)))\n+                .map(|(f, (s, _))| (*f, Some(*s)))\n+                .chain(self.unstable.iter().map(|(f, _)| (*f, None)))\n                 .collect();\n             all_features.sort_unstable_by(|a, b| a.0.as_str().partial_cmp(b.0.as_str()).unwrap());\n             all_features"}, {"sha": "0fbad3f0f0f06761c56b77ce6740cfdc936eb1ba", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -62,6 +62,19 @@ pub struct Index {\n     pub stab_map: FxHashMap<LocalDefId, Stability>,\n     pub const_stab_map: FxHashMap<LocalDefId, ConstStability>,\n     pub depr_map: FxHashMap<LocalDefId, DeprecationEntry>,\n+    /// Mapping from feature name to feature name based on the `implied_by` field of `#[unstable]`\n+    /// attributes. If a `#[unstable(feature = \"implier\", implied_by = \"impliee\")]` attribute\n+    /// exists, then this map will have a `impliee -> implier` entry.\n+    ///\n+    /// This mapping is necessary unless both the `#[stable]` and `#[unstable]` attributes should\n+    /// specify their implications (both `implies` and `implied_by`). If only one of the two\n+    /// attributes do (as in the current implementation, `implied_by` in `#[unstable]`), then this\n+    /// mapping is necessary for diagnostics. When a \"unnecessary feature attribute\" error is\n+    /// reported, only the `#[stable]` attribute information is available, so the map is necessary\n+    /// to know that the feature implies another feature. If it were reversed, and the `#[stable]`\n+    /// attribute had an `implies` meta item, then a map would be necessary when avoiding a \"use of\n+    /// unstable feature\" error for a feature that was implied.\n+    pub implications: FxHashMap<Symbol, Symbol>,\n }\n \n impl Index {\n@@ -423,7 +436,9 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         match stability {\n             Some(Stability {\n-                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n+                level: attr::Unstable { reason, issue, is_soft, implied_by },\n+                feature,\n+                ..\n             }) => {\n                 if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n@@ -433,6 +448,13 @@ impl<'tcx> TyCtxt<'tcx> {\n                     return EvalResult::Allow;\n                 }\n \n+                // If this item was previously part of a now-stabilized feature which is still\n+                // active (i.e. the user hasn't removed the attribute for the stabilized feature\n+                // yet) then allow use of this item.\n+                if let Some(implied_by) = implied_by && self.features().active(implied_by) {\n+                    return EvalResult::Allow;\n+                }\n+\n                 // When we're compiling the compiler itself we may pull in\n                 // crates from crates.io, but those crates may depend on other\n                 // crates also pulled in from crates.io. We want to ideally be"}, {"sha": "466a0fc25f7d11ca3563cdd7a377aa4f55586d02", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -1634,11 +1634,15 @@ rustc_queries! {\n         storage(ArenaCacheSelector<'tcx>)\n         desc { \"calculating the lib features map\" }\n     }\n-    query defined_lib_features(_: CrateNum)\n-        -> &'tcx [(Symbol, Option<Symbol>)] {\n+    query defined_lib_features(_: CrateNum) -> &'tcx [(Symbol, Option<Symbol>)] {\n         desc { \"calculating the lib features defined in a crate\" }\n         separate_provide_extern\n     }\n+    query stability_implications(_: CrateNum) -> FxHashMap<Symbol, Symbol> {\n+        storage(ArenaCacheSelector<'tcx>)\n+        desc { \"calculating the implications between `#[unstable]` features defined in a crate\" }\n+        separate_provide_extern\n+    }\n     /// Whether the function is an intrinsic\n     query is_intrinsic(def_id: DefId) -> bool {\n         desc { |tcx| \"is_intrinsic({})\", tcx.def_path_str(def_id) }"}, {"sha": "e05994f13e4d9b8ef73bc5c8b50ca878cb599636", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -1,8 +1,8 @@\n-// Detecting lib features (i.e., features that are not lang features).\n-//\n-// These are declared using stability attributes (e.g., `#[stable (..)]`\n-// and `#[unstable (..)]`), but are not declared in one single location\n-// (unlike lang features), which means we need to collect them instead.\n+//! Detecting lib features (i.e., features that are not lang features).\n+//!\n+//! These are declared using stability attributes (e.g., `#[stable (..)]` and `#[unstable (..)]`),\n+//! but are not declared in one single location (unlike lang features), which means we need to\n+//! collect them instead.\n \n use rustc_ast::{Attribute, MetaItemKind};\n use rustc_errors::struct_span_err;\n@@ -71,11 +71,11 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n \n     fn collect_feature(&mut self, feature: Symbol, since: Option<Symbol>, span: Span) {\n         let already_in_stable = self.lib_features.stable.contains_key(&feature);\n-        let already_in_unstable = self.lib_features.unstable.contains(&feature);\n+        let already_in_unstable = self.lib_features.unstable.contains_key(&feature);\n \n         match (since, already_in_stable, already_in_unstable) {\n             (Some(since), _, false) => {\n-                if let Some(prev_since) = self.lib_features.stable.get(&feature) {\n+                if let Some((prev_since, _)) = self.lib_features.stable.get(&feature) {\n                     if *prev_since != since {\n                         self.span_feature_error(\n                             span,\n@@ -89,10 +89,10 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                     }\n                 }\n \n-                self.lib_features.stable.insert(feature, since);\n+                self.lib_features.stable.insert(feature, (since, span));\n             }\n             (None, false, _) => {\n-                self.lib_features.unstable.insert(feature);\n+                self.lib_features.unstable.insert(feature, span);\n             }\n             (Some(_), _, true) | (None, true, _) => {\n                 self.span_feature_error("}, {"sha": "81b04c414ed9b6c11ba48e8f078310476b359407", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 89, "deletions": 34, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -2,9 +2,9 @@\n //! propagating default levels lexically from parent to children ast nodes.\n \n use attr::StabilityLevel;\n-use rustc_attr::{self as attr, ConstStability, Stability};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n-use rustc_errors::struct_span_err;\n+use rustc_attr::{self as attr, ConstStability, Stability, Unstable};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -29,13 +29,13 @@ use std::num::NonZeroU32;\n \n #[derive(PartialEq)]\n enum AnnotationKind {\n-    // Annotation is required if not inherited from unstable parents\n+    /// Annotation is required if not inherited from unstable parents.\n     Required,\n-    // Annotation is useless, reject it\n+    /// Annotation is useless, reject it.\n     Prohibited,\n-    // Deprecation annotation is useless, reject it. (Stability attribute is still required.)\n+    /// Deprecation annotation is useless, reject it. (Stability attribute is still required.)\n     DeprecationProhibited,\n-    // Annotation itself is useless, but it can be propagated to children\n+    /// Annotation itself is useless, but it can be propagated to children.\n     Container,\n }\n \n@@ -83,7 +83,7 @@ impl InheritStability {\n     }\n }\n \n-// A private tree-walker for producing an Index.\n+/// A private tree-walker for producing an `Index`.\n struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     index: &'a mut Index,\n@@ -94,9 +94,9 @@ struct Annotator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Annotator<'a, 'tcx> {\n-    // Determine the stability for a node based on its attributes and inherited\n-    // stability. The stability is recorded in the index and used as the parent.\n-    // If the node is a function, `fn_sig` is its signature\n+    /// Determine the stability for a node based on its attributes and inherited stability. The\n+    /// stability is recorded in the index and used as the parent. If the node is a function,\n+    /// `fn_sig` is its signature.\n     fn annotate<F>(\n         &mut self,\n         def_id: LocalDefId,\n@@ -265,6 +265,10 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 }\n             }\n \n+            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } = stab {\n+                self.index.implications.insert(implied_by, feature);\n+            }\n+\n             self.index.stab_map.insert(def_id, stab);\n             stab\n         });\n@@ -610,6 +614,7 @@ fn stability_index(tcx: TyCtxt<'_>, (): ()) -> Index {\n         stab_map: Default::default(),\n         const_stab_map: Default::default(),\n         depr_map: Default::default(),\n+        implications: Default::default(),\n     };\n \n     {\n@@ -637,6 +642,7 @@ fn stability_index(tcx: TyCtxt<'_>, (): ()) -> Index {\n                     reason: Some(Symbol::intern(reason)),\n                     issue: NonZeroU32::new(27812),\n                     is_soft: false,\n+                    implied_by: None,\n                 },\n                 feature: sym::rustc_private,\n             };\n@@ -667,6 +673,7 @@ pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         check_mod_unstable_api_usage,\n         stability_index,\n+        stability_implications: |tcx, _| tcx.stability().implications.clone(),\n         lookup_stability: |tcx, id| tcx.stability().local_stability(id.expect_local()),\n         lookup_const_stability: |tcx, id| tcx.stability().local_const_stability(id.expect_local()),\n         lookup_deprecation_entry: |tcx, id| {\n@@ -945,32 +952,51 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     remaining_lib_features.remove(&sym::libc);\n     remaining_lib_features.remove(&sym::test);\n \n-    let check_features = |remaining_lib_features: &mut FxIndexMap<_, _>, defined_features: &[_]| {\n-        for &(feature, since) in defined_features {\n-            if let Some(since) = since {\n-                if let Some(span) = remaining_lib_features.get(&feature) {\n-                    // Warn if the user has enabled an already-stable lib feature.\n-                    unnecessary_stable_feature_lint(tcx, *span, feature, since);\n-                }\n-            }\n-            remaining_lib_features.remove(&feature);\n-            if remaining_lib_features.is_empty() {\n-                break;\n-            }\n-        }\n-    };\n-\n     // We always collect the lib features declared in the current crate, even if there are\n     // no unknown features, because the collection also does feature attribute validation.\n-    let local_defined_features = tcx.lib_features(()).to_vec();\n-    if !remaining_lib_features.is_empty() {\n-        check_features(&mut remaining_lib_features, &local_defined_features);\n+    let local_defined_features = tcx.lib_features(());\n+    let mut all_lib_features: FxHashMap<_, _> =\n+        local_defined_features.to_vec().iter().map(|el| *el).collect();\n+    let mut implications = tcx.stability_implications(rustc_hir::def_id::LOCAL_CRATE).clone();\n+    for &cnum in tcx.crates(()) {\n+        implications.extend(tcx.stability_implications(cnum));\n+        all_lib_features.extend(tcx.defined_lib_features(cnum).iter().map(|el| *el));\n+    }\n \n-        for &cnum in tcx.crates(()) {\n+    // Check that every feature referenced by an `implied_by` exists (for features defined in the\n+    // local crate).\n+    for (implied_by, feature) in tcx.stability_implications(rustc_hir::def_id::LOCAL_CRATE) {\n+        // Only `implied_by` needs to be checked, `feature` is guaranteed to exist.\n+        if !all_lib_features.contains_key(implied_by) {\n+            let span = local_defined_features\n+                .stable\n+                .get(feature)\n+                .map(|(_, span)| span)\n+                .or_else(|| local_defined_features.unstable.get(feature))\n+                .expect(\"feature that implied another does not exist\");\n+            tcx.sess\n+                .struct_span_err(\n+                    *span,\n+                    format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    if !remaining_lib_features.is_empty() {\n+        for (feature, since) in all_lib_features.iter() {\n+            if let Some(since) = since && let Some(span) = remaining_lib_features.get(&feature) {\n+                // Warn if the user has enabled an already-stable lib feature.\n+                if let Some(implies) = implications.get(&feature) {\n+                    unnecessary_partially_stable_feature_lint(tcx, *span, *feature, *implies, *since);\n+                } else {\n+                    unnecessary_stable_feature_lint(tcx, *span, *feature, *since);\n+                }\n+            }\n+            remaining_lib_features.remove(&feature);\n             if remaining_lib_features.is_empty() {\n                 break;\n             }\n-            check_features(&mut remaining_lib_features, tcx.defined_lib_features(cnum));\n         }\n     }\n \n@@ -982,12 +1008,41 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     // don't lint about unused features. We should re-enable this one day!\n }\n \n+fn unnecessary_partially_stable_feature_lint(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    feature: Symbol,\n+    implies: Symbol,\n+    since: Symbol,\n+) {\n+    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n+        lint.build(&format!(\n+            \"the feature `{feature}` has been partially stabilized since {since} and is succeeded \\\n+             by the feature `{implies}`\"\n+        ))\n+        .span_suggestion(\n+            span,\n+            &format!(\n+                \"if you are using features which are still unstable, change to using `{implies}`\"\n+            ),\n+            implies,\n+            Applicability::MaybeIncorrect,\n+        )\n+        .span_suggestion(\n+            tcx.sess.source_map().span_extend_to_line(span),\n+            \"if you are using features which are now stable, remove this line\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        )\n+        .emit();\n+    });\n+}\n+\n fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n     tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n         lint.build(&format!(\n-            \"the feature `{}` has been stable since {} and no longer requires \\\n-                      an attribute to enable\",\n-            feature, since\n+            \"the feature `{feature}` has been stable since {since} and no longer requires an \\\n+             attribute to enable\",\n         ))\n         .emit();\n     });"}, {"sha": "2b5eb12a8a890e39a26b902b8fa790856cdeaa45", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -796,9 +796,16 @@ impl<'a> Resolver<'a> {\n     ) {\n         let span = path.span;\n         if let Some(stability) = &ext.stability {\n-            if let StabilityLevel::Unstable { reason, issue, is_soft } = stability.level {\n+            if let StabilityLevel::Unstable { reason, issue, is_soft, implied_by } = stability.level\n+            {\n                 let feature = stability.feature;\n-                if !self.active_features.contains(&feature) && !span.allows_unstable(feature) {\n+\n+                let is_allowed = |feature| {\n+                    self.active_features.contains(&feature) || span.allows_unstable(feature)\n+                };\n+                let allowed_by_implication =\n+                    implied_by.map(|feature| is_allowed(feature)).unwrap_or(false);\n+                if !is_allowed(feature) && !allowed_by_implication {\n                     let lint_buffer = &mut self.lint_buffer;\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);"}, {"sha": "b4a4424e876cdeb6e5178df20f6bb19d3831be88", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -718,6 +718,11 @@ impl SourceMap {\n         sp\n     }\n \n+    /// Extends the given `Span` to contain the entire line it is on.\n+    pub fn span_extend_to_line(&self, sp: Span) -> Span {\n+        self.span_extend_to_prev_char(self.span_extend_to_next_char(sp, '\\n', true), '\\n', true)\n+    }\n+\n     /// Given a `Span`, tries to get a shorter span ending before the first occurrence of `char`\n     /// `c`.\n     pub fn span_until_char(&self, sp: Span, c: char) -> Span {"}, {"sha": "2ac1ecfe87eb5f11820b3456149ecd5fab79f9dc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -800,6 +800,7 @@ symbols! {\n         impl_lint_pass,\n         impl_macros,\n         impl_trait_in_bindings,\n+        implied_by,\n         import,\n         import_shadowing,\n         imported_main,"}, {"sha": "468be1bc144508b1e094ce66eb3d6872de7dba21", "filename": "src/test/ui/stability-attribute/auxiliary/stability-attribute-implies.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fstability-attribute-implies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fstability-attribute-implies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fstability-attribute-implies.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,8 @@\n+#![feature(staged_api)]\n+#![stable(feature = \"stability_attribute_implies\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"foo\", since = \"1.62.0\")]\n+pub fn foo() {}\n+\n+#[unstable(feature = \"foobar\", issue = \"1\", implied_by = \"foo\")]\n+pub fn foobar() {}"}, {"sha": "613878536721b3eeda65d59930abcd2c714811b4", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-missing.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,10 @@\n+#![feature(staged_api)]\n+#![stable(feature = \"stability_attribute_implies\", since = \"1.0.0\")]\n+\n+// Tests that `implied_by = \"bar\"` results in an error being emitted if `bar` does not exist.\n+\n+#[unstable(feature = \"foobar\", issue = \"1\", implied_by = \"bar\")]\n+//~^ ERROR feature `bar` implying `foobar` does not exist\n+pub fn foobar() {}\n+\n+fn main() {}"}, {"sha": "ff1856f1763f94573db427224a9fed0c9a000814", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-missing.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-missing.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,8 @@\n+error: feature `bar` implying `foobar` does not exist\n+  --> $DIR/stability-attribute-implies-missing.rs:6:1\n+   |\n+LL | #[unstable(feature = \"foobar\", issue = \"1\", implied_by = \"bar\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "947f9f73eff11a663ac21dd597d3a57c285169b3", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-no-feature.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,13 @@\n+// aux-build:stability-attribute-implies.rs\n+\n+// Tests that despite the `foobar` feature being implied by now-stable feature `foo`, if `foobar`\n+// isn't allowed in this crate then an error will be emitted.\n+\n+extern crate stability_attribute_implies;\n+use stability_attribute_implies::{foo, foobar};\n+//~^ ERROR use of unstable library feature 'foobar'\n+\n+fn main() {\n+    foo(); // no error - stable\n+    foobar(); //~ ERROR use of unstable library feature 'foobar'\n+}"}, {"sha": "c2331f6766c4fc0d0ac5bccc2d17701b93b0fab4", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-no-feature.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-no-feature.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: use of unstable library feature 'foobar'\n+  --> $DIR/stability-attribute-implies-no-feature.rs:7:40\n+   |\n+LL | use stability_attribute_implies::{foo, foobar};\n+   |                                        ^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(foobar)]` to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'foobar'\n+  --> $DIR/stability-attribute-implies-no-feature.rs:12:5\n+   |\n+LL |     foobar();\n+   |     ^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(foobar)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1a2d8e271de043bd20b8c8170cd37148a659469a", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-using-stable.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:stability-attribute-implies.rs\n+#![deny(stable_features)]\n+#![feature(foo)]\n+//~^ ERROR the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n+\n+// Tests that the use of `implied_by` in the `#[unstable]` attribute results in a diagnostic\n+// mentioning partial stabilization, and that given the implied unstable feature is unused (there\n+// is no `foobar` call), that the compiler suggests removing the flag.\n+\n+extern crate stability_attribute_implies;\n+use stability_attribute_implies::foo;\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "c9b3f07cc70b15eab8092a85a745e1e53615bba0", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-using-stable.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-stable.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,22 @@\n+error: the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n+  --> $DIR/stability-attribute-implies-using-stable.rs:3:12\n+   |\n+LL | #![feature(foo)]\n+   |            ^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/stability-attribute-implies-using-stable.rs:2:9\n+   |\n+LL | #![deny(stable_features)]\n+   |         ^^^^^^^^^^^^^^^\n+help: if you are using features which are still unstable, change to using `foobar`\n+   |\n+LL | #![feature(foobar)]\n+   |            ~~~~~~\n+help: if you are using features which are now stable, remove this line\n+   |\n+LL - #![feature(foo)]\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "3c73c5abf3b54dec533b85c5a3e0ee372182f9d6", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-using-unstable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.rs?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:stability-attribute-implies.rs\n+#![deny(stable_features)]\n+#![feature(foo)]\n+//~^ ERROR the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n+\n+// Tests that the use of `implied_by` in the `#[unstable]` attribute results in a diagnostic\n+// mentioning partial stabilization and that given the implied unstable feature is used (there is a\n+// `foobar` call), that the compiler suggests changing to that feature and doesn't error about its\n+// use.\n+\n+extern crate stability_attribute_implies;\n+use stability_attribute_implies::{foo, foobar};\n+\n+fn main() {\n+    foo();\n+    foobar(); // no error!\n+}"}, {"sha": "9a5c7ef5a476221c5c6432befccaaa0ce29f9b49", "filename": "src/test/ui/stability-attribute/stability-attribute-implies-using-unstable.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-implies-using-unstable.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -0,0 +1,22 @@\n+error: the feature `foo` has been partially stabilized since 1.62.0 and is succeeded by the feature `foobar`\n+  --> $DIR/stability-attribute-implies-using-unstable.rs:3:12\n+   |\n+LL | #![feature(foo)]\n+   |            ^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/stability-attribute-implies-using-unstable.rs:2:9\n+   |\n+LL | #![deny(stable_features)]\n+   |         ^^^^^^^^^^^^^^^\n+help: if you are using features which are still unstable, change to using `foobar`\n+   |\n+LL | #![feature(foobar)]\n+   |            ~~~~~~\n+help: if you are using features which are now stable, remove this line\n+   |\n+LL - #![feature(foo)]\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "8dbcc6c97efd5fea50b7fe63657218a5f00c07c2", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity-2.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -8,7 +8,7 @@ error[E0541]: unknown meta item 'sinse'\n   --> $DIR/stability-attribute-sanity-2.rs:10:25\n    |\n LL | #[stable(feature = \"a\", sinse = \"1.0.0\")]\n-   |                         ^^^^^^^^^^^^^^^ expected one of `since`, `note`\n+   |                         ^^^^^^^^^^^^^^^ expected one of `feature`, `since`\n \n error[E0545]: `issue` must be a non-zero numeric string or \"none\"\n   --> $DIR/stability-attribute-sanity-2.rs:13:27"}, {"sha": "079230b2a3160e5462cb70d72b0655235be734a2", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/857afc75e6ca69cc7dcae36a6fac8c093ee6fa31/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=857afc75e6ca69cc7dcae36a6fac8c093ee6fa31", "patch": "@@ -14,7 +14,7 @@ error[E0541]: unknown meta item 'reason'\n   --> $DIR/stability-attribute-sanity.rs:8:42\n    |\n LL |     #[stable(feature = \"a\", since = \"b\", reason)]\n-   |                                          ^^^^^^ expected one of `since`, `note`\n+   |                                          ^^^^^^ expected one of `feature`, `since`\n \n error[E0539]: incorrect meta item\n   --> $DIR/stability-attribute-sanity.rs:11:29"}]}