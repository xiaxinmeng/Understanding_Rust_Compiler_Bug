{"sha": "b20f427391e9ca6c9a0439df77dfc938c0ba59da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMGY0MjczOTFlOWNhNmM5YTA0MzlkZjc3ZGZjOTM4YzBiYTU5ZGE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-16T12:16:29Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-16T12:16:29Z"}, "message": "Rollup merge of #30368 - arielb1:region-unification-2, r=nikomatsakis\n\nTurns out that calling `resolve_type_variables_if_possible` in a O(n^2)\nloop is a bad idea. Now we just resolve each copy of the region variable\nto its lowest name each time (we resolve the region variable to its lowest\nname, rather than to its unify-table name to avoid the risk of\nthe unify-table name changing infinitely many times. That may be\nnot a problem in practice, but I am not sure of it).", "tree": {"sha": "a44b8b4398c712fad6dbdd6c2581029c3548c074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a44b8b4398c712fad6dbdd6c2581029c3548c074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20f427391e9ca6c9a0439df77dfc938c0ba59da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20f427391e9ca6c9a0439df77dfc938c0ba59da", "html_url": "https://github.com/rust-lang/rust/commit/b20f427391e9ca6c9a0439df77dfc938c0ba59da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20f427391e9ca6c9a0439df77dfc938c0ba59da/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee24bddfc51df686c72d3a3ed52611209c655850", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee24bddfc51df686c72d3a3ed52611209c655850", "html_url": "https://github.com/rust-lang/rust/commit/ee24bddfc51df686c72d3a3ed52611209c655850"}, {"sha": "08bffdd5c0c0916d9caed05f42419076e1e89359", "url": "https://api.github.com/repos/rust-lang/rust/commits/08bffdd5c0c0916d9caed05f42419076e1e89359", "html_url": "https://github.com/rust-lang/rust/commit/08bffdd5c0c0916d9caed05f42419076e1e89359"}], "stats": {"total": 86, "additions": 61, "deletions": 25}, "files": [{"sha": "e148aecd241f2797c5ca3f5017adaffc69e63c59", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=b20f427391e9ca6c9a0439df77dfc938c0ba59da", "patch": "@@ -18,6 +18,7 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n+use super::unify_key;\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -345,10 +346,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n-        let id = self.num_vars();\n+        let vid = RegionVid { index: self.num_vars() };\n         self.var_origins.borrow_mut().push(origin.clone());\n-        let vid = self.unification_table.borrow_mut().new_key(());\n-        assert_eq!(vid.index, id);\n+\n+        let u_vid = self.unification_table.borrow_mut().new_key(\n+            unify_key::RegionVidKey { min_vid: vid }\n+            );\n+        assert_eq!(vid, u_vid);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n@@ -581,7 +585,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        ty::ReVar(self.unification_table.borrow_mut().find(rid))\n+        ty::ReVar(self.unification_table.borrow_mut().find_value(rid).min_vid)\n     }\n \n     fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {"}, {"sha": "c83231930f502e0302d0c29327c8a05b43e3241d", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=b20f427391e9ca6c9a0439df77dfc938c0ba59da", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast;\n use middle::ty::{self, IntVarValue, Ty};\n-use rustc_data_structures::unify::UnifyKey;\n+use rustc_data_structures::unify::{Combine, UnifyKey};\n \n pub trait ToType<'tcx> {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n@@ -23,8 +23,28 @@ impl UnifyKey for ty::IntVid {\n     fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub struct RegionVidKey {\n+    /// The minimum region vid in the unification set. This is needed\n+    /// to have a canonical name for a type to prevent infinite\n+    /// recursion.\n+    pub min_vid: ty::RegionVid\n+}\n+\n+impl Combine for RegionVidKey {\n+    fn combine(&self, other: &RegionVidKey) -> RegionVidKey {\n+        let min_vid = if self.min_vid.index < other.min_vid.index {\n+            self.min_vid\n+        } else {\n+            other.min_vid\n+        };\n+\n+        RegionVidKey { min_vid: min_vid }\n+    }\n+}\n+\n impl UnifyKey for ty::RegionVid {\n-    type Value = ();\n+    type Value = RegionVidKey;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid { index: i } }\n     fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }"}, {"sha": "c6da70eef750a89f0947b0388bb2ba650f396ee4", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=b20f427391e9ca6c9a0439df77dfc938c0ba59da", "patch": "@@ -37,6 +37,16 @@ pub trait UnifyKey : Copy + Clone + Debug + PartialEq {\n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n+/// This trait is implemented for unify values that can be\n+/// combined. This relation should be a monoid.\n+pub trait Combine {\n+    fn combine(&self, other: &Self) -> Self;\n+}\n+\n+impl Combine for () {\n+    fn combine(&self, _other: &()) {}\n+}\n+\n /// Value of a unification key. We implement Tarjan's union-find\n /// algorithm: when two keys are unified, one of them is converted\n /// into a \"redirect\" pointing at the other. These redirects form a\n@@ -243,23 +253,28 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n ///////////////////////////////////////////////////////////////////////////\n // Base union-find algorithm, where we are just making sets\n \n-impl<'tcx,K> UnificationTable<K>\n-    where K : UnifyKey<Value=()>,\n+impl<'tcx,K:UnifyKey> UnificationTable<K>\n+    where K::Value: Combine\n {\n     pub fn union(&mut self, a_id: K, b_id: K) {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n         let a_id = node_a.key();\n         let b_id = node_b.key();\n         if a_id != b_id {\n-            self.unify(node_a, node_b, ());\n+            let new_value = node_a.value.combine(&node_b.value);\n+            self.unify(node_a, node_b, new_value);\n         }\n     }\n \n     pub fn find(&mut self, id: K) -> K {\n         self.get(id).key()\n     }\n \n+    pub fn find_value(&mut self, id: K) -> K::Value {\n+        self.get(id).value\n+    }\n+\n     pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n         self.find(a_id) == self.find(b_id)\n     }"}, {"sha": "59025346ce3bd029b3cce2d000a306cf1bd4712c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f427391e9ca6c9a0439df77dfc938c0ba59da/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b20f427391e9ca6c9a0439df77dfc938c0ba59da", "patch": "@@ -17,6 +17,7 @@ use middle::region;\n use middle::subst::{self, Subst};\n use middle::traits;\n use middle::ty::{self, Ty};\n+use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -279,7 +280,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n             rcx: rcx,\n             span: span,\n             parent_scope: parent_scope,\n-            breadcrumbs: Vec::new(),\n+            breadcrumbs: FnvHashSet()\n         },\n         TypeContext::Root,\n         typ,\n@@ -340,7 +341,7 @@ enum TypeContext {\n struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n     rcx: &'a mut Rcx<'b, 'tcx>,\n     /// types that have already been traversed\n-    breadcrumbs: Vec<Ty<'tcx>>,\n+    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n     /// span for error reporting\n     span: Span,\n     /// the scope reachable dtorck types must outlive\n@@ -355,8 +356,6 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     depth: usize) -> Result<(), Error<'tcx>>\n {\n     let tcx = cx.rcx.tcx();\n-    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n-\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n     let recursion_limit = tcx.sess.recursion_limit.get();\n@@ -367,19 +366,17 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    for breadcrumb in &mut cx.breadcrumbs {\n-        *breadcrumb =\n-            cx.rcx.infcx().resolve_type_and_region_vars_if_possible(breadcrumb);\n-        if *breadcrumb == ty {\n-            debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                   {}ty: {} scope: {:?} - cached\",\n-                   (0..depth).map(|_| ' ').collect::<String>(),\n-                   ty, cx.parent_scope);\n-            return Ok(()); // we already visited this type\n-        }\n-    }\n-    cx.breadcrumbs.push(ty);\n+    // canoncialize the regions in `ty` before inserting - infinitely many\n+    // region variables can refer to the same region.\n+    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n \n+    if !cx.breadcrumbs.insert(ty) {\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+               {}ty: {} scope: {:?} - cached\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               ty, cx.parent_scope);\n+        return Ok(()); // we already visited this type\n+    }\n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n            {}ty: {} scope: {:?}\",\n            (0..depth).map(|_| ' ').collect::<String>(),"}]}