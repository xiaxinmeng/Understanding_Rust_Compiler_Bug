{"sha": "131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMWVmOTdjNGIxNjAwMTdjNjFmMGIzYmVmNmUwMWFjZTZjMDRlY2Y=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-05T21:12:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-06T13:25:19Z"}, "message": "Reduce the amount of unsafe code and mark handle_deadlock as unsafe", "tree": {"sha": "3afac1fdd4779d87f8a0634c631c4f4ba8de5f98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3afac1fdd4779d87f8a0634c631c4f4ba8de5f98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "html_url": "https://github.com/rust-lang/rust/commit/131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/131ef97c4b160017c61f0b3bef6e01ace6c04ecf/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e832484414e4b0b28682f9ae6c3607fd5db53f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e832484414e4b0b28682f9ae6c3607fd5db53f4", "html_url": "https://github.com/rust-lang/rust/commit/3e832484414e4b0b28682f9ae6c3607fd5db53f4"}], "stats": {"total": 105, "additions": 53, "deletions": 52}, "files": [{"sha": "3da73d47a0bf5d9a7cd4d6d7b3513d653d4c5f98", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/131ef97c4b160017c61f0b3bef6e01ace6c04ecf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131ef97c4b160017c61f0b3bef6e01ace6c04ecf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "patch": "@@ -151,6 +151,10 @@ impl<'tcx> QueryJob<'tcx> {\n         #[cfg(parallel_queries)]\n         self.latch.set();\n     }\n+\n+    fn as_ptr(&self) -> *const QueryJob<'tcx> {\n+        self as *const _\n+    }\n }\n \n #[cfg(parallel_queries)]\n@@ -233,13 +237,9 @@ impl<'tcx> QueryLatch<'tcx> {\n     }\n }\n \n-/// A pointer to an active query job. This is used to give query jobs an identity.\n-#[cfg(parallel_queries)]\n-type Ref<'tcx> = *const QueryJob<'tcx>;\n-\n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_queries)]\n-type Waiter<'tcx> = (Ref<'tcx>, usize);\n+type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -251,25 +251,23 @@ type Waiter<'tcx> = (Ref<'tcx>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_queries)]\n-fn visit_waiters<'tcx, F>(query_ref: Ref<'tcx>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n+fn visit_waiters<'tcx, F>(query: Lrc<QueryJob<'tcx>>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n where\n-    F: FnMut(Span, Ref<'tcx>) -> Option<Option<Waiter<'tcx>>>\n+    F: FnMut(Span, Lrc<QueryJob<'tcx>>) -> Option<Option<Waiter<'tcx>>>\n {\n-    let query = unsafe { &*query_ref };\n-\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(ref parent) = query.parent {\n-        if let Some(cycle) = visit(query.info.span, &**parent as Ref) {\n+        if let Some(cycle) = visit(query.info.span, parent.clone()) {\n             return Some(cycle);\n         }\n     }\n \n     // Visit the explict waiters which use condvars and are resumable\n     for (i, waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n         if let Some(ref waiter_query) = waiter.query {\n-            if visit(waiter.span, &**waiter_query).is_some() {\n+            if visit(waiter.span, waiter_query.clone()).is_some() {\n                 // Return a value which indicates that this waiter can be resumed\n-                return Some(Some((query_ref, i)));\n+                return Some(Some((query.clone(), i)));\n             }\n         }\n     }\n@@ -281,12 +279,13 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_queries)]\n-fn cycle_check<'tcx>(query: Ref<'tcx>,\n+fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n                      span: Span,\n-                     stack: &mut Vec<(Span, Ref<'tcx>)>,\n-                     visited: &mut HashSet<Ref<'tcx>>) -> Option<Option<Waiter<'tcx>>> {\n-    if visited.contains(&query) {\n-        return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n+                     stack: &mut Vec<(Span, Lrc<QueryJob<'tcx>>)>,\n+                     visited: &mut HashSet<*const QueryJob<'tcx>>\n+) -> Option<Option<Waiter<'tcx>>> {\n+    if visited.contains(&query.as_ptr()) {\n+        return if let Some(p) = stack.iter().position(|q| q.1.as_ptr() == query.as_ptr()) {\n             // We detected a query cycle, fix up the initial span and return Some\n \n             // Remove previous stack entries\n@@ -300,8 +299,8 @@ fn cycle_check<'tcx>(query: Ref<'tcx>,\n     }\n \n     // Mark this query is visited and add it to the stack\n-    visited.insert(query);\n-    stack.push((span, query));\n+    visited.insert(query.as_ptr());\n+    stack.push((span, query.clone()));\n \n     // Visit all the waiters\n     let r = visit_waiters(query, |span, successor| {\n@@ -320,18 +319,21 @@ fn cycle_check<'tcx>(query: Ref<'tcx>,\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_queries)]\n-fn connected_to_root<'tcx>(query: Ref<'tcx>, visited: &mut HashSet<Ref<'tcx>>) -> bool {\n+fn connected_to_root<'tcx>(\n+    query: Lrc<QueryJob<'tcx>>,\n+    visited: &mut HashSet<*const QueryJob<'tcx>>\n+) -> bool {\n     // We already visited this or we're deliberately ignoring it\n-    if visited.contains(&query) {\n+    if visited.contains(&query.as_ptr()) {\n         return false;\n     }\n \n     // This query is connected to the root (it has no query parent), return true\n-    if unsafe { (*query).parent.is_none() } {\n+    if query.parent.is_none() {\n         return true;\n     }\n \n-    visited.insert(query);\n+    visited.insert(query.as_ptr());\n \n     let mut connected = false;\n \n@@ -351,7 +353,7 @@ fn connected_to_root<'tcx>(query: Ref<'tcx>, visited: &mut HashSet<Ref<'tcx>>) -\n /// the function returns false.\n #[cfg(parallel_queries)]\n fn remove_cycle<'tcx>(\n-    jobs: &mut Vec<Ref<'tcx>>,\n+    jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n     tcx: TyCtxt<'_, 'tcx, '_>\n ) -> bool {\n@@ -367,7 +369,7 @@ fn remove_cycle<'tcx>(\n \n         // Extract the spans and queries into separate arrays\n         let mut spans: Vec<_> = stack.iter().map(|e| e.0).collect();\n-        let queries = stack.iter().map(|e| e.1);\n+        let queries = stack.into_iter().map(|e| e.1);\n \n         // Shift the spans so that queries are matched with the span for their waitee\n         let last = spans.pop().unwrap();\n@@ -378,23 +380,25 @@ fn remove_cycle<'tcx>(\n \n         // Remove the queries in our cycle from the list of jobs to look at\n         for r in &stack {\n-            jobs.remove_item(&r.1);\n+            if let Some(pos) = jobs.iter().position(|j| j.as_ptr() == r.1.as_ptr()) {\n+                jobs.remove(pos);\n+            }\n         }\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points: Vec<Ref<'_>> = stack.iter().filter_map(|query| {\n+        let entry_points: Vec<Lrc<QueryJob<'tcx>>> = stack.iter().filter_map(|query| {\n             // Mark all the other queries in the cycle as already visited\n             let mut visited = HashSet::from_iter(stack.iter().filter_map(|q| {\n-                if q.1 != query.1 {\n-                    Some(q.1)\n+                if q.1.as_ptr() != query.1.as_ptr() {\n+                    Some(q.1.as_ptr())\n                 } else {\n                     None\n                 }\n             }));\n \n-            if connected_to_root(query.1, &mut visited) {\n-                Some(query.1)\n+            if connected_to_root(query.1.clone(), &mut visited) {\n+                Some(query.1.clone())\n             } else {\n                 None\n             }\n@@ -403,39 +407,36 @@ fn remove_cycle<'tcx>(\n         // Deterministically pick an entry point\n         // FIXME: Sort this instead\n         let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = *entry_points.iter().min_by_key(|&&q| {\n+        let entry_point = entry_points.iter().min_by_key(|q| {\n             let mut stable_hasher = StableHasher::<u64>::new();\n-            unsafe { (*q).info.query.hash_stable(&mut hcx, &mut stable_hasher); }\n+            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n             stable_hasher.finish()\n-        }).unwrap();\n+        }).unwrap().as_ptr();\n \n         // Shift the stack until our entry point is first\n-        while stack[0].1 != entry_point {\n+        while stack[0].1.as_ptr() != entry_point {\n             let last = stack.pop().unwrap();\n             stack.insert(0, last);\n         }\n \n         // Create the cycle error\n         let mut error = CycleError {\n             usage: None,\n-            cycle: stack.iter().map(|&(s, q)| QueryInfo {\n+            cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n                 span: s,\n-                query: unsafe { (*q).info.query.clone() },\n+                query: q.info.query.clone(),\n             } ).collect(),\n         };\n \n         // We unwrap `waiter` here since there must always be one\n         // edge which is resumeable / waited using a query latch\n         let (waitee_query, waiter_idx) = waiter.unwrap();\n-        let waitee_query = unsafe { &*waitee_query };\n \n         // Extract the waiter we want to resume\n         let waiter = waitee_query.latch.extract_waiter(waiter_idx);\n \n         // Set the cycle error so it will be picked up when resumed\n-        unsafe {\n-            *waiter.cycle.lock() = Some(error);\n-        }\n+        *waiter.cycle.lock() = Some(error);\n \n         // Put the waiter on the list of things to resume\n         wakelist.push(waiter);\n@@ -448,8 +449,9 @@ fn remove_cycle<'tcx>(\n \n /// Creates a new thread and forwards information in thread locals to it.\n /// The new thread runs the deadlock handler.\n+/// Must only be called when a deadlock is about to happen.\n #[cfg(parallel_queries)]\n-pub fn handle_deadlock() {\n+pub unsafe fn handle_deadlock() {\n     use syntax;\n     use syntax_pos;\n \n@@ -458,25 +460,23 @@ pub fn handle_deadlock() {\n     let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| {\n         gcx_ptr as *const _\n     });\n-    let gcx_ptr = unsafe { &*gcx_ptr };\n+    let gcx_ptr = &*gcx_ptr;\n \n     let syntax_globals = syntax::GLOBALS.with(|syntax_globals| {\n         syntax_globals as *const _\n     });\n-    let syntax_globals = unsafe { &*syntax_globals };\n+    let syntax_globals = &*syntax_globals;\n \n     let syntax_pos_globals = syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n         syntax_pos_globals as *const _\n     });\n-    let syntax_pos_globals = unsafe { &*syntax_pos_globals };\n+    let syntax_pos_globals = &*syntax_pos_globals;\n     thread::spawn(move || {\n         tls::GCX_PTR.set(gcx_ptr, || {\n             syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n                 syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n                     tls::with_thread_locals(|| {\n-                        unsafe {\n-                            tls::with_global(|tcx| deadlock(tcx, &registry))\n-                        }\n+                        tls::with_global(|tcx| deadlock(tcx, &registry))\n                     })\n                 })\n             })\n@@ -497,7 +497,7 @@ fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n     });\n \n     let mut wakelist = Vec::new();\n-    let mut jobs: Vec<_> = tcx.maps.collect_active_jobs().iter().map(|j| &**j as Ref).collect();\n+    let mut jobs: Vec<_> = tcx.maps.collect_active_jobs();\n \n     let mut found_cycle = false;\n "}, {"sha": "37f8bff964f5b1e880ae08684b17e67c133f9453", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/131ef97c4b160017c61f0b3bef6e01ace6c04ecf/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131ef97c4b160017c61f0b3bef6e01ace6c04ecf/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=131ef97c4b160017c61f0b3bef6e01ace6c04ecf", "patch": "@@ -85,9 +85,10 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n \n     let gcx_ptr = &Lock::new(0);\n \n-    let config = ThreadPoolBuilder::new().num_threads(Session::query_threads_from_opts(&opts))\n-                                         .deadlock_handler(ty::maps::handle_deadlock)\n-                                         .stack_size(16 * 1024 * 1024);\n+    let config = ThreadPoolBuilder::new()\n+        .num_threads(Session::query_threads_from_opts(&opts))\n+        .deadlock_handler(|| unsafe { ty::maps::handle_deadlock() })\n+        .stack_size(16 * 1024 * 1024);\n \n     let with_pool = move |pool: &ThreadPool| {\n         pool.install(move || f(opts))"}]}