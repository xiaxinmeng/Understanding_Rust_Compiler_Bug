{"sha": "ab74346b965e890f3395dc43a7abc9cc0f828a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNzQzNDZiOTY1ZTg5MGYzMzk1ZGM0M2E3YWJjOWNjMGY4MjhhM2I=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-02-01T13:29:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-01T13:29:31Z"}, "message": "Rollup merge of #81364 - camelid:improve-build-matches-docs, r=varkor\n\nImprove `rustc_mir_build::matches` docs\n\n- Fix typos\n- Add more information\n- General cleanup", "tree": {"sha": "4af2b5c904c377cb39d4be1cc73ba7a8a0e4d56b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4af2b5c904c377cb39d4be1cc73ba7a8a0e4d56b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab74346b965e890f3395dc43a7abc9cc0f828a3b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGAI8CRBK7hj4Ov3rIwAAdHIIAKm+R6Dp4aqOv+OYPud8qpwy\nq/lOblP/2AYCCY0geFMIOYfLIxgYCDX/z/SYeNTsH+Rb4BxYN8gAM/hZ7W5d7p/6\n+HoZiEDCUypRZxPpxdeSC0ynXBFlw7lFjNOrn9JCBoA4b3c8l145LqEMXkbosnOs\nZD6Jytn+qy4g3VeJgcyoAXsgunzA5orQ9gDa1qoQ/fsBRY5MREzmTE1i9eqyKVMD\nNvSV9nDKT6lSZaVXu6NbSSztQnIk/4vAVfGpKLjvO29OZ06Pd/Z1oZy6dNMjPZEN\nNZKKwCJfjLzTTlDFCf9l9UortqNTa15OwOUiG94k0LVjSO9LBhu+XG5CaGcEGfA=\n=7lBI\n-----END PGP SIGNATURE-----\n", "payload": "tree 4af2b5c904c377cb39d4be1cc73ba7a8a0e4d56b\nparent 21d0e9b8dc297cd78f51b397c55c033673f8be6e\nparent 8b52cdc942ef590fd4576a5d9b2934c764f25c7b\nauthor Jonas Schievink <jonasschievink@gmail.com> 1612186171 +0100\ncommitter GitHub <noreply@github.com> 1612186171 +0100\n\nRollup merge of #81364 - camelid:improve-build-matches-docs, r=varkor\n\nImprove `rustc_mir_build::matches` docs\n\n- Fix typos\n- Add more information\n- General cleanup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab74346b965e890f3395dc43a7abc9cc0f828a3b", "html_url": "https://github.com/rust-lang/rust/commit/ab74346b965e890f3395dc43a7abc9cc0f828a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab74346b965e890f3395dc43a7abc9cc0f828a3b/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21d0e9b8dc297cd78f51b397c55c033673f8be6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d0e9b8dc297cd78f51b397c55c033673f8be6e", "html_url": "https://github.com/rust-lang/rust/commit/21d0e9b8dc297cd78f51b397c55c033673f8be6e"}, {"sha": "8b52cdc942ef590fd4576a5d9b2934c764f25c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b52cdc942ef590fd4576a5d9b2934c764f25c7b", "html_url": "https://github.com/rust-lang/rust/commit/8b52cdc942ef590fd4576a5d9b2934c764f25c7b"}], "stats": {"total": 129, "additions": 74, "deletions": 55}, "files": [{"sha": "90fcee075b5ac47e06b25209d5ef59c1c8f7c326", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ab74346b965e890f3395dc43a7abc9cc0f828a3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab74346b965e890f3395dc43a7abc9cc0f828a3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=ab74346b965e890f3395dc43a7abc9cc0f828a3b", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// visible through borrow checking. False edges ensure that the CFG as\n     /// seen by borrow checking doesn't encode this. False edges are added:\n     ///\n-    /// * From each prebinding block to the next prebinding block.\n-    /// * From each otherwise block to the next prebinding block.\n+    /// * From each pre-binding block to the next pre-binding block.\n+    /// * From each otherwise block to the next pre-binding block.\n     crate fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n@@ -630,10 +630,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n #[derive(Debug)]\n pub(super) struct Candidate<'pat, 'tcx> {\n-    /// `Span` of the original pattern that gave rise to this candidate\n+    /// [`Span`] of the original pattern that gave rise to this candidate.\n     span: Span,\n \n-    /// This `Candidate` has a guard.\n+    /// Whether this `Candidate` has a guard.\n     has_guard: bool,\n \n     /// All of these must be satisfied...\n@@ -645,14 +645,15 @@ pub(super) struct Candidate<'pat, 'tcx> {\n     /// ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    /// ... and if this is non-empty, one of these subcandidates also has to match ...\n+    /// ...and if this is non-empty, one of these subcandidates also has to match...\n     subcandidates: Vec<Candidate<'pat, 'tcx>>,\n \n-    /// ...and the guard must be evaluated, if false branch to Block...\n+    /// ...and the guard must be evaluated; if it's `false` then branch to `otherwise_block`.\n     otherwise_block: Option<BasicBlock>,\n \n-    /// ...and the blocks for add false edges between candidates\n+    /// The block before the `bindings` have been established.\n     pre_binding_block: Option<BasicBlock>,\n+    /// The pre-binding block of the next candidate.\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n@@ -737,26 +738,27 @@ crate struct MatchPair<'pat, 'tcx> {\n     pattern: &'pat Pat<'tcx>,\n }\n \n+/// See [`Test`] for more.\n #[derive(Clone, Debug, PartialEq)]\n enum TestKind<'tcx> {\n-    /// Test the branches of enum.\n+    /// Test what enum variant a value is.\n     Switch {\n-        /// The enum being tested\n+        /// The enum type being tested.\n         adt_def: &'tcx ty::AdtDef,\n         /// The set of variants that we should create a branch for. We also\n         /// create an additional \"otherwise\" case.\n         variants: BitSet<VariantIdx>,\n     },\n \n-    /// Test what value an `integer`, `bool` or `char` has.\n+    /// Test what value an integer, `bool`, or `char` has.\n     SwitchInt {\n         /// The type of the value that we're testing.\n         switch_ty: Ty<'tcx>,\n         /// The (ordered) set of values that we test for.\n         ///\n         /// For integers and `char`s we create a branch to each of the values in\n         /// `options`, as well as an \"otherwise\" branch for all other values, even\n-        /// in the (rare) case that options is exhaustive.\n+        /// in the (rare) case that `options` is exhaustive.\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n@@ -776,17 +778,21 @@ enum TestKind<'tcx> {\n     /// Test whether the value falls within an inclusive or exclusive range\n     Range(PatRange<'tcx>),\n \n-    /// Test length of the slice is equal to len\n+    /// Test that the length of the slice is equal to `len`.\n     Len { len: u64, op: BinOp },\n }\n \n+/// A test to perform to determine which [`Candidate`] matches a value.\n+///\n+/// [`Test`] is just the test to perform; it does not include the value\n+/// to be tested.\n #[derive(Debug)]\n crate struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n-/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// `ArmHasGuard` is a wrapper around a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n crate struct ArmHasGuard(crate bool);\n@@ -801,27 +807,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n     /// the value, we will set and generate a branch to the appropriate\n-    /// prebinding block.\n+    /// pre-binding block.\n     ///\n     /// If we find that *NONE* of the candidates apply, we branch to the\n     /// `otherwise_block`, setting it to `Some` if required. In principle, this\n     /// means that the input list was not exhaustive, though at present we\n     /// sometimes are not smart enough to recognize all exhaustive inputs.\n     ///\n-    /// It might be surprising that the input can be inexhaustive.\n+    /// It might be surprising that the input can be non-exhaustive.\n     /// Indeed, initially, it is not, because all matches are\n     /// exhaustive in Rust. But during processing we sometimes divide\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n-    /// under control. See `test_candidates` for more details.\n+    /// under control. See [`Builder::test_candidates`] for more details.\n     ///\n-    /// If `fake_borrows` is Some, then places which need fake borrows\n+    /// If `fake_borrows` is `Some`, then places which need fake borrows\n     /// will be added to it.\n     ///\n     /// For an example of a case where we set `otherwise_block`, even for an\n-    /// exhaustive match consider:\n+    /// exhaustive match, consider:\n     ///\n-    /// ```rust\n+    /// ```\n     /// match x {\n     ///     (true, true) => (),\n     ///     (_, false) => (),\n@@ -830,8 +836,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// ```\n     ///\n     /// For this match, we check if `x.0` matches `true` (for the first\n-    /// arm). If that's false, we check `x.1`. If it's `true` we check if\n-    /// `x.0` matches `false` (for the third arm). In the (impossible at\n+    /// arm). If it doesn't match, we check `x.1`. If `x.1` is `true` we check\n+    /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n     fn match_candidates<'pat>(\n@@ -938,26 +944,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n     }\n \n-    /// Link up matched candidates. For example, if we have something like\n-    /// this:\n+    /// Link up matched candidates.\n+    ///\n+    /// For example, if we have something like this:\n     ///\n     /// ```rust\n     /// ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond1 => ...\n     /// Some(x) => ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond2 => ...\n     /// ...\n     /// ```\n     ///\n     /// We generate real edges from:\n-    /// * `start_block` to the `prebinding_block` of the first pattern,\n-    /// * the otherwise block of the first pattern to the second pattern,\n-    /// * the otherwise block of the third pattern to the a block with an\n-    ///   Unreachable terminator.\n     ///\n-    /// As well as that we add fake edges from the otherwise blocks to the\n-    /// prebinding block of the next candidate in the original set of\n+    /// * `start_block` to the [pre-binding block] of the first pattern,\n+    /// * the [otherwise block] of the first pattern to the second pattern,\n+    /// * the [otherwise block] of the third pattern to a block with an\n+    ///   [`Unreachable` terminator](TerminatorKind::Unreachable).\n+    ///\n+    /// In addition, we add fake edges from the otherwise blocks to the\n+    /// pre-binding block of the next candidate in the original set of\n     /// candidates.\n+    ///\n+    /// [pre-binding block]: Candidate::pre_binding_block\n+    /// [otherwise block]: Candidate::otherwise_block\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n@@ -1044,7 +1055,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// forwards to [Builder::test_candidates].\n     ///\n     /// Given a pattern `(P | Q, R | S)` we (in principle) generate a CFG like\n-    /// so\n+    /// so:\n     ///\n     /// ```text\n     /// [ start ]\n@@ -1214,31 +1225,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n-    /// sort of test. To decide what test to do, we take the highest\n-    /// priority candidate (last one in the list) and extract the\n-    /// first match-pair from the list. From this we decide what kind\n-    /// of test is needed using `test`, defined in the `test` module.\n+    /// sort of test. To decide what test to perform, we take the highest\n+    /// priority candidate (the first one in the list, as of January 2021)\n+    /// and extract the first match-pair from the list. From this we decide\n+    /// what kind of test is needed using [`Builder::test`], defined in the\n+    /// [`test` module](mod@test).\n     ///\n     /// *Note:* taking the first match pair is somewhat arbitrary, and\n     /// we might do better here by choosing more carefully what to\n     /// test.\n     ///\n     /// For example, consider the following possible match-pairs:\n     ///\n-    /// 1. `x @ Some(P)` -- we will do a `Switch` to decide what variant `x` has\n-    /// 2. `x @ 22` -- we will do a `SwitchInt`\n-    /// 3. `x @ 3..5` -- we will do a range test\n+    /// 1. `x @ Some(P)` -- we will do a [`Switch`] to decide what variant `x` has\n+    /// 2. `x @ 22` -- we will do a [`SwitchInt`] to decide what value `x` has\n+    /// 3. `x @ 3..5` -- we will do a [`Range`] test to decide what range `x` falls in\n     /// 4. etc.\n     ///\n+    /// [`Switch`]: TestKind::Switch\n+    /// [`SwitchInt`]: TestKind::SwitchInt\n+    /// [`Range`]: TestKind::Range\n+    ///\n     /// Once we know what sort of test we are going to perform, this\n-    /// Tests may also help us with other candidates. So we walk over\n+    /// test may also help us winnow down our candidates. So we walk over\n     /// the candidates (from high to low priority) and check. This\n     /// gives us, for each outcome of the test, a transformed list of\n-    /// candidates. For example, if we are testing the current\n-    /// variant of `x.0`, and we have a candidate `{x.0 @ Some(v), x.1\n-    /// @ 22}`, then we would have a resulting candidate of `{(x.0 as\n-    /// Some).0 @ v, x.1 @ 22}`. Note that the first match-pair is now\n-    /// simpler (and, in fact, irrefutable).\n+    /// candidates. For example, if we are testing `x.0`'s variant,\n+    /// and we have a candidate `(x.0 @ Some(v), x.1 @ 22)`,\n+    /// then we would have a resulting candidate of `((x.0 as Some).0 @ v, x.1 @ 22)`.\n+    /// Note that the first match-pair is now simpler (and, in fact, irrefutable).\n     ///\n     /// But there may also be candidates that the test just doesn't\n     /// apply to. The classical example involves wildcards:\n@@ -1268,7 +1283,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// is trivially NP-complete:\n     ///\n     /// ```rust\n-    ///     match (var0, var1, var2, var3, ..) {\n+    ///     match (var0, var1, var2, var3, ...) {\n     ///         (true, _, _, false, true, ...) => false,\n     ///         (_, true, true, false, _, ...) => false,\n     ///         (false, _, false, false, _, ...) => false,\n@@ -1283,7 +1298,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// That kind of exponential worst-case might not occur in practice, but\n     /// our simplistic treatment of constants and guards would make it occur\n-    /// in very common situations - for example #29740:\n+    /// in very common situations - for example [#29740]:\n     ///\n     /// ```rust\n     /// match x {\n@@ -1294,13 +1309,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Here we first test the match-pair `x @ \"foo\"`, which is an `Eq` test.\n+    /// [#29740]: https://github.com/rust-lang/rust/issues/29740\n+    ///\n+    /// Here we first test the match-pair `x @ \"foo\"`, which is an [`Eq` test].\n+    ///\n+    /// [`Eq` test]: TestKind::Eq\n     ///\n     /// It might seem that we would end up with 2 disjoint candidate\n-    /// sets, consisting of the first candidate or the other 3, but our\n-    /// algorithm doesn't reason about \"foo\" being distinct from the other\n+    /// sets, consisting of the first candidate or the other two, but our\n+    /// algorithm doesn't reason about `\"foo\"` being distinct from the other\n     /// constants; it considers the latter arms to potentially match after\n-    /// both outcomes, which obviously leads to an exponential amount\n+    /// both outcomes, which obviously leads to an exponential number\n     /// of tests.\n     ///\n     /// To avoid these kinds of problems, our algorithm tries to ensure\n@@ -1312,16 +1331,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// After we perform our test, we branch into the appropriate candidate\n     /// set and recurse with `match_candidates`. These sub-matches are\n-    /// obviously inexhaustive - as we discarded our otherwise set - so\n+    /// obviously non-exhaustive - as we discarded our otherwise set - so\n     /// we set their continuation to do `match_candidates` on the\n-    /// \"unmatched\" set (which is again inexhaustive).\n+    /// \"unmatched\" set (which is again non-exhaustive).\n     ///\n     /// If you apply this to the above test, you basically wind up\n     /// with an if-else-if chain, testing each candidate in turn,\n     /// which is precisely what we want.\n     ///\n     /// In addition to avoiding exponential-time blowups, this algorithm\n-    /// also has nice property that each guard and arm is only generated\n+    /// also has the nice property that each guard and arm is only generated\n     /// once.\n     fn test_candidates<'pat, 'b, 'c>(\n         &mut self,"}, {"sha": "126fb957a6a9945e2c5ff0c00b7e5cf005fa32cf", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab74346b965e890f3395dc43a7abc9cc0f828a3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab74346b965e890f3395dc43a7abc9cc0f828a3b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=ab74346b965e890f3395dc43a7abc9cc0f828a3b", "patch": "@@ -23,7 +23,7 @@ use std::cmp::Ordering;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n-    /// It is a bug to call this with a simplifiable pattern.\n+    /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {"}]}