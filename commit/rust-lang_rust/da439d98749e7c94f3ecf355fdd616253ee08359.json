{"sha": "da439d98749e7c94f3ecf355fdd616253ee08359", "node_id": "C_kwDOAAsO6NoAKGRhNDM5ZDk4NzQ5ZTdjOTRmM2VjZjM1NWZkZDYxNjI1M2VlMDgzNTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-22T21:24:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-22T21:24:29Z"}, "message": "Auto merge of #108357 - matthiaskrgr:rollup-ceo3q2s, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #107736 ( Rename atomic 'as_mut_ptr' to 'as_ptr' to match Cell (ref #66893) )\n - #108176 (Don't delay `ReError` bug during lexical region resolve)\n - #108315 (Lint dead code in closures and generators)\n - #108342 (apply query response: actually define opaque types)\n - #108344 (Fix test filename for #105700)\n - #108353 (resolve: Remove `ImportResolver`)\n\nFailed merges:\n\n - #107911 (Add check for invalid #[macro_export] arguments)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "447f24e380c71df5422e366c51c2c871f8c320ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447f24e380c71df5422e366c51c2c871f8c320ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da439d98749e7c94f3ecf355fdd616253ee08359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da439d98749e7c94f3ecf355fdd616253ee08359", "html_url": "https://github.com/rust-lang/rust/commit/da439d98749e7c94f3ecf355fdd616253ee08359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da439d98749e7c94f3ecf355fdd616253ee08359/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20", "html_url": "https://github.com/rust-lang/rust/commit/fdbc4329cb781c7768ffa6d76c8fa2d032d3fe20"}, {"sha": "9f5c401f670190737f93b6e440fea4d733ab7560", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5c401f670190737f93b6e440fea4d733ab7560", "html_url": "https://github.com/rust-lang/rust/commit/9f5c401f670190737f93b6e440fea4d733ab7560"}], "stats": {"total": 300, "additions": 179, "deletions": 121}, "files": [{"sha": "07e7589fee43a19a44f1e60566c5e46b258167af", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -393,6 +393,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// will instantiate fresh inference variables for each canonical\n     /// variable instead. Therefore, the result of this method must be\n     /// properly unified\n+    #[instrument(level = \"debug\", skip(self, cause, param_env))]\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -403,11 +404,6 @@ impl<'tcx> InferCtxt<'tcx> {\n     where\n         R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n     {\n-        debug!(\n-            \"query_response_substitution_guess(original_values={:#?}, query_response={:#?})\",\n-            original_values, query_response,\n-        );\n-\n         // For each new universe created in the query result that did\n         // not appear in the original query, create a local\n         // superuniverse.\n@@ -502,7 +498,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         for &(a, b) in &query_response.value.opaque_types {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n-            obligations.extend(self.at(cause, param_env).eq(a, b)?.obligations);\n+            debug!(?a, ?b, \"constrain opaque type\");\n+            obligations\n+                .extend(self.at(cause, param_env).define_opaque_types(true).eq(a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })"}, {"sha": "335eb4c54062f45983d9b1daabaef700ec290c1e", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -1046,7 +1046,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n             ty::ReVar(rid) => match self.values[rid] {\n                 VarValue::Empty(_) => r,\n                 VarValue::Value(r) => r,\n-                VarValue::ErrorValue => tcx.mk_re_error_misc(),\n+                VarValue::ErrorValue => tcx.lifetimes.re_static,\n             },\n             _ => r,\n         };"}, {"sha": "cfc91d636a7d7bd6e0c3f4ad26de8b2a9b328914", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -395,6 +395,9 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n                     self.mark_as_used_if_union(*adt, fields);\n                 }\n             }\n+            hir::ExprKind::Closure(cls) => {\n+                self.insert_def_id(cls.def_id.to_def_id());\n+            }\n             _ => (),\n         }\n "}, {"sha": "760a81b9a590db29b22c258ad8281006383f3bc8", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -29,7 +29,7 @@ use rustc_span::{BytePos, Span, SyntaxContext};\n use thin_vec::ThinVec;\n \n use crate::errors as errs;\n-use crate::imports::{Import, ImportKind, ImportResolver};\n+use crate::imports::{Import, ImportKind};\n use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n@@ -1888,15 +1888,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n         }\n     }\n-}\n \n-impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// Adds suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n@@ -1931,11 +1929,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n@@ -1950,11 +1948,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1981,11 +1979,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n@@ -2003,7 +2001,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         if path[1].ident.span.is_rust_2015() {\n             return None;\n@@ -2013,13 +2011,13 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // 1) some consistent ordering for emitted diagnostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n-            self.r.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+            self.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n         extern_crate_names.sort_by(|a, b| b.as_str().partial_cmp(a.as_str()).unwrap());\n \n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+            let result = self.maybe_resolve_path(&path, None, parent_scope);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result\n@@ -2046,8 +2044,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        import: &'b Import<'b>,\n-        module: ModuleOrUniformRoot<'b>,\n+        import: &'a Import<'a>,\n+        module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Option<String>)> {\n         let ModuleOrUniformRoot::Module(mut crate_module) = module else {\n@@ -2064,8 +2062,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             return None;\n         }\n \n-        let resolutions = self.r.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&self.r.new_key(ident, MacroNS))?;\n+        let resolutions = self.resolutions(crate_module).borrow();\n+        let resolution = resolutions.get(&self.new_key(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n@@ -2086,7 +2084,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.r.tcx.sess,\n+                    self.tcx.sess,\n                     import.span,\n                     import.use_span,\n                 );\n@@ -2105,7 +2103,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) =\n-                        extend_span_to_previous_binding(self.r.tcx.sess, binding_span)\n+                        extend_span_to_previous_binding(self.tcx.sess, binding_span)\n                     {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -2123,7 +2121,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.r.tcx.sess,\n+                    self.tcx.sess,\n                     module_name,\n                     import.use_span,\n                 );\n@@ -2132,7 +2130,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     has_nested, after_crate_name\n                 );\n \n-                let source_map = self.r.tcx.sess.source_map();\n+                let source_map = self.tcx.sess.source_map();\n \n                 // Make sure this is actually crate-relative.\n                 let is_definitely_crate = import"}, {"sha": "4dab0836d28b14f2a5c720c7622f91113c24fb15", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 65, "deletions": 76, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -210,6 +210,17 @@ impl<'a> NameResolution<'a> {\n     }\n }\n \n+/// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved\n+/// import errors within the same use tree into a single diagnostic.\n+#[derive(Debug, Clone)]\n+struct UnresolvedImportError {\n+    span: Span,\n+    label: Option<String>,\n+    note: Option<String>,\n+    suggestion: Option<Suggestion>,\n+    candidates: Option<Vec<ImportSuggestion>>,\n+}\n+\n // Reexports of the form `pub use foo as bar;` where `foo` is `extern crate foo;`\n // are permitted for backward-compatibility under a deprecation lint.\n fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBinding<'_>) -> bool {\n@@ -392,24 +403,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n-}\n-\n-/// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved\n-/// import errors within the same use tree into a single diagnostic.\n-#[derive(Debug, Clone)]\n-struct UnresolvedImportError {\n-    span: Span,\n-    label: Option<String>,\n-    note: Option<String>,\n-    suggestion: Option<Suggestion>,\n-    candidates: Option<Vec<ImportSuggestion>>,\n-}\n-\n-pub(crate) struct ImportResolver<'a, 'b, 'tcx> {\n-    pub r: &'a mut Resolver<'b, 'tcx>,\n-}\n \n-impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -421,28 +415,28 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub(crate) fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.r.indeterminate_imports.len() + 1;\n-        while self.r.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.r.indeterminate_imports.len();\n-            for import in mem::take(&mut self.r.indeterminate_imports) {\n+        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n+        while self.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.indeterminate_imports.len();\n+            for import in mem::take(&mut self.indeterminate_imports) {\n                 match self.resolve_import(&import) {\n-                    true => self.r.determined_imports.push(import),\n-                    false => self.r.indeterminate_imports.push(import),\n+                    true => self.determined_imports.push(import),\n+                    false => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n     }\n \n     pub(crate) fn finalize_imports(&mut self) {\n-        for module in self.r.arenas.local_modules().iter() {\n+        for module in self.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n \n         let mut seen_spans = FxHashSet::default();\n         let mut errors = vec![];\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n-        let determined_imports = mem::take(&mut self.r.determined_imports);\n-        let indeterminate_imports = mem::take(&mut self.r.indeterminate_imports);\n+        let determined_imports = mem::take(&mut self.determined_imports);\n+        let indeterminate_imports = mem::take(&mut self.indeterminate_imports);\n \n         for (is_indeterminate, import) in determined_imports\n             .into_iter()\n@@ -453,7 +447,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n             // If this import is unresolved then create a dummy import\n             // resolution for it so that later resolve stages won't complain.\n-            self.r.import_dummy_binding(import);\n+            self.import_dummy_binding(import);\n \n             if let Some(err) = unresolved_import_error {\n                 if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n@@ -526,7 +520,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n-        let mut diag = struct_span_err!(self.r.tcx.sess, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n             diag.note(note);\n@@ -548,7 +542,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if let Some(candidates) = &err.candidates {\n                 match &import.kind {\n                     ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n-                        self.r.tcx,\n+                        self.tcx,\n                         &mut diag,\n                         Some(err.span),\n                         &candidates,\n@@ -560,7 +554,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     ),\n                     ImportKind::Single { nested: true, source, target, .. } => {\n                         import_candidates(\n-                            self.r.tcx,\n+                            self.tcx,\n                             &mut diag,\n                             None,\n                             &candidates,\n@@ -581,7 +575,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, import: &'b Import<'b>) -> bool {\n+    fn resolve_import(&mut self, import: &'a Import<'a>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n             Segment::names_to_string(&import.module_path),\n@@ -594,8 +588,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.take();\n-            let path_res =\n-                self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n+            let path_res = self.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -623,7 +616,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         let mut indeterminate = false;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n@@ -676,23 +669,23 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n+    fn finalize_import(&mut self, import: &'a Import<'a>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.take();\n         let ignore_binding = match &import.kind {\n             ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n-        let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n+        let prev_ambiguity_errors_len = self.ambiguity_errors.len();\n         let finalize = Finalize::with_root_span(import.root_id, import.span, import.root_span);\n-        let path_res = self.r.resolve_path(\n+        let path_res = self.resolve_path(\n             &import.module_path,\n             None,\n             &import.parent_scope,\n             Some(finalize),\n             ignore_binding,\n         );\n \n-        let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n+        let no_ambiguity = self.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         import.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n@@ -701,19 +694,18 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n                         span_bug!(import.span, \"inconsistent resolution for an import\");\n                     }\n-                } else if self.r.privacy_errors.is_empty() {\n+                } else if self.privacy_errors.is_empty() {\n                     let msg = \"cannot determine resolution for the import\";\n                     let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                    self.r.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n+                    self.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(import.imported_module.get().is_none());\n-                    self.r\n-                        .report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n+                    self.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 }\n                 return None;\n             }\n@@ -775,7 +767,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         // 2 segments, so the `resolve_path` above won't trigger it.\n                         let mut full_path = import.module_path.clone();\n                         full_path.push(Segment::from_ident(Ident::empty()));\n-                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                        self.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n                     }\n \n                     if let ModuleOrUniformRoot::Module(module) = module {\n@@ -794,18 +786,18 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n-                    && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n+                    && !max_vis.is_at_least(import.expect_vis(), &*self)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n                     return None;\n                 }\n                 _ => unreachable!(),\n             };\n \n         let mut all_ns_err = true;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 let orig_vis = import.vis.take();\n                 let binding = this.resolve_ident_in_module(\n@@ -874,7 +866,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n         if all_ns_err {\n             let mut all_ns_failed = true;\n-            self.r.per_ns(|this, ns| {\n+            self.per_ns(|this, ns| {\n                 if !type_ns_only || ns == TypeNS {\n                     let binding = this.resolve_ident_in_module(\n                         module,\n@@ -892,9 +884,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => {\n-                        Some(self.r.resolutions(module).borrow())\n-                    }\n+                    ModuleOrUniformRoot::Module(module) => Some(self.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -963,7 +953,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 let parent_suggestion =\n-                    self.r.lookup_import_candidates(ident, TypeNS, &import.parent_scope, |_| true);\n+                    self.lookup_import_candidates(ident, TypeNS, &import.parent_scope, |_| true);\n \n                 Some(UnresolvedImportError {\n                     span: import.span,\n@@ -985,7 +975,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         let mut reexport_error = None;\n         let mut any_successful_reexport = false;\n         let mut crate_private_reexport = false;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 if !binding.vis.is_at_least(import.expect_vis(), &*this) {\n                     reexport_error = Some((ns, binding));\n@@ -1010,7 +1000,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                                    `pub`\",\n                     ident\n                 );\n-                self.r.lint_buffer.buffer_lint(\n+                self.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                     import_id,\n                     import.span,\n@@ -1033,17 +1023,17 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         format!(\"re-export of private `{}`\", ident)\n                     };\n \n-                    struct_span_err!(self.r.tcx.sess, import.span, E0365, \"{}\", error_msg)\n+                    struct_span_err!(self.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n                         .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n-                        struct_span_err!(self.r.tcx.sess, import.span, E0364, \"{error_msg}\");\n+                        struct_span_err!(self.tcx.sess, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n                         NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n-                            if self.r.get_macro_by_def_id(def_id).macro_rules =>\n+                            if self.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n                             err.span_help(\n                                 binding.span,\n@@ -1069,7 +1059,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = import.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n-            self.r.per_ns(|this, ns| {\n+            self.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(Some(finalize), &full_path, Some(binding));\n                 }\n@@ -1079,7 +1069,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n@@ -1094,9 +1084,9 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        import: &'b Import<'b>,\n-        source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n-        target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n+        import: &'a Import<'a>,\n+        source_bindings: &PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n+        target_bindings: &PerNS<Cell<Option<&'a NameBinding<'a>>>>,\n         target: Ident,\n     ) {\n         // This function is only called for single imports.\n@@ -1117,7 +1107,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n         let mut redundant_span = PerNS { value_ns: None, type_ns: None, macro_ns: None };\n \n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 if binding.res() == Res::Err {\n                     return;\n@@ -1147,7 +1137,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             let mut redundant_spans: Vec<_> = redundant_span.present_items().collect();\n             redundant_spans.sort();\n             redundant_spans.dedup();\n-            self.r.lint_buffer.buffer_lint_with_diagnostic(\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 id,\n                 import.span,\n@@ -1157,22 +1147,22 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+    fn resolve_glob_import(&mut self, import: &'a Import<'a>) {\n         // This function is only called for glob imports.\n         let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n \n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n-            self.r.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n+            self.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n         };\n \n         if module.is_trait() {\n-            self.r.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n+            self.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n         } else if is_prelude {\n-            self.r.prelude = Some(module);\n+            self.prelude = Some(module);\n             return;\n         }\n \n@@ -1182,7 +1172,6 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n         let bindings = self\n-            .r\n             .resolutions(module)\n             .borrow()\n             .iter()\n@@ -1192,30 +1181,30 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n             let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n-                Some(Some(def)) => self.r.expn_def_scope(def),\n+                Some(Some(def)) => self.expn_def_scope(def),\n                 Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n-            if self.r.is_accessible_from(binding.vis, scope) {\n-                let imported_binding = self.r.import(binding, import);\n-                let _ = self.r.try_define(import.parent_scope.module, key, imported_binding);\n+            if self.is_accessible_from(binding.vis, scope) {\n+                let imported_binding = self.import(binding, import);\n+                let _ = self.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n+        self.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n     // reporting conflicts, and reporting unresolved imports.\n-    fn finalize_resolutions_in(&mut self, module: Module<'b>) {\n+    fn finalize_resolutions_in(&mut self, module: Module<'a>) {\n         // Since import resolution is finished, globs will not define any more names.\n         *module.globs.borrow_mut() = Vec::new();\n \n         if let Some(def_id) = module.opt_def_id() {\n             let mut reexports = Vec::new();\n \n-            module.for_each_child(self.r, |this, ident, _, binding| {\n+            module.for_each_child(self, |this, ident, _, binding| {\n                 if let Some(res) = this.is_reexport(binding) {\n                     reexports.push(ModChild {\n                         ident,\n@@ -1230,7 +1219,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if !reexports.is_empty() {\n                 // Call to `expect_local` should be fine because current\n                 // code is only called for local modules.\n-                self.r.reexport_map.insert(def_id.expect_local(), reexports);\n+                self.reexport_map.insert(def_id.expect_local(), reexports);\n             }\n         }\n     }"}, {"sha": "7a1f14f71f2153a60daf7aa91b8ecd264358f63c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -60,7 +60,7 @@ use std::collections::BTreeSet;\n use std::{fmt, ptr};\n \n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n-use imports::{Import, ImportKind, ImportResolver, NameResolution};\n+use imports::{Import, ImportKind, NameResolution};\n use late::{HasGenericParams, PathSource, PatternSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n@@ -1491,9 +1491,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.tcx.sess.time(\"resolve_crate\", || {\n-            self.tcx\n-                .sess\n-                .time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.tcx.sess.time(\"finalize_imports\", || self.finalize_imports());\n             self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });"}, {"sha": "b38c11e8bb8d4b6e4627cd630afebfdbc971dfe9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -1,7 +1,6 @@\n //! A bunch of methods and structures more or less related to resolving macros and\n //! interface provided by `Resolver` to macro expander.\n \n-use crate::imports::ImportResolver;\n use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n@@ -233,7 +232,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_imports(&mut self) {\n-        ImportResolver { r: self }.resolve_imports()\n+        self.resolve_imports()\n     }\n \n     fn resolve_macro_invocation("}, {"sha": "00bcaf3e18c3d8fe8eeb47c7ca731b0ad77264a9", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -922,13 +922,13 @@ impl AtomicBool {\n     ///\n     /// let mut atomic = AtomicBool::new(true);\n     /// unsafe {\n-    ///     my_atomic_op(atomic.as_mut_ptr());\n+    ///     my_atomic_op(atomic.as_ptr());\n     /// }\n     /// # }\n     /// ```\n     #[inline]\n     #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n-    pub const fn as_mut_ptr(&self) -> *mut bool {\n+    pub const fn as_ptr(&self) -> *mut bool {\n         self.v.get().cast()\n     }\n \n@@ -1814,12 +1814,12 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// // SAFETY: Safe as long as `my_atomic_op` is atomic.\n     /// unsafe {\n-    ///     my_atomic_op(atomic.as_mut_ptr());\n+    ///     my_atomic_op(atomic.as_ptr());\n     /// }\n     /// ```\n     #[inline]\n     #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n-    pub const fn as_mut_ptr(&self) -> *mut *mut T {\n+    pub const fn as_ptr(&self) -> *mut *mut T {\n         self.p.get()\n     }\n }\n@@ -2719,15 +2719,15 @@ macro_rules! atomic_int {\n             ///\n             /// // SAFETY: Safe as long as `my_atomic_op` is atomic.\n             /// unsafe {\n-            ///     my_atomic_op(atomic.as_mut_ptr());\n+            ///     my_atomic_op(atomic.as_ptr());\n             /// }\n             /// # }\n             /// ```\n             #[inline]\n             #[unstable(feature = \"atomic_mut_ptr\",\n                    reason = \"recently added\",\n                    issue = \"66893\")]\n-            pub const fn as_mut_ptr(&self) -> *mut $int_type {\n+            pub const fn as_ptr(&self) -> *mut $int_type {\n                 self.v.get()\n             }\n         }"}, {"sha": "575988ec760c7a84cd5109b3e7754d51b756816a", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -60,7 +60,7 @@ impl Parker {\n         if state == PARKED {\n             // Loop to guard against spurious wakeups.\n             while state == PARKED {\n-                park(self.state.as_mut_ptr().addr());\n+                park(self.state.as_ptr().addr());\n                 state = self.state.load(Acquire);\n             }\n \n@@ -76,7 +76,7 @@ impl Parker {\n \n         let state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n         if state == PARKED {\n-            park_timeout(dur, self.state.as_mut_ptr().addr());\n+            park_timeout(dur, self.state.as_ptr().addr());\n             // Swap to ensure that we observe all state changes with acquire\n             // ordering, even if the state has been changed after the timeout\n             // occured.\n@@ -99,7 +99,7 @@ impl Parker {\n             // and terminated before this call is made. This call then returns an\n             // error or wakes up an unrelated thread. The platform API and\n             // environment does allow this, however.\n-            unpark(tid, self.state.as_mut_ptr().addr());\n+            unpark(tid, self.state.as_ptr().addr());\n         }\n     }\n }"}, {"sha": "c55634405ed7ba5adcb5bbd63f9bf422ed9e5c7f", "filename": "tests/ui/lint/dead-code/in-closure.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -0,0 +1,16 @@\n+// edition: 2021\n+\n+#![deny(dead_code)]\n+\n+pub fn foo() {\n+    let closure = || {\n+        fn a() {}   //~ ERROR function `a` is never used\n+    };\n+    closure()\n+}\n+\n+pub async fn async_foo() {\n+    const A: usize = 1; //~ ERROR constant `A` is never used\n+}\n+\n+fn main() {}"}, {"sha": "deb276be7027c32c6b78fa173141fd075cc7a3fe", "filename": "tests/ui/lint/dead-code/in-closure.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Fin-closure.stderr?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -0,0 +1,20 @@\n+error: function `a` is never used\n+  --> $DIR/in-closure.rs:7:12\n+   |\n+LL |         fn a() {}\n+   |            ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/in-closure.rs:3:9\n+   |\n+LL | #![deny(dead_code)]\n+   |         ^^^^^^^^^\n+\n+error: constant `A` is never used\n+  --> $DIR/in-closure.rs:13:11\n+   |\n+LL |     const A: usize = 1;\n+   |           ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e1fee46313d50cfc560f9b6febd69ff5ca0174b0", "filename": "tests/ui/recursion_limit/issue-105700.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Frecursion_limit%2Fissue-105700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Frecursion_limit%2Fissue-105700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion_limit%2Fissue-105700.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "previous_filename": "tests/ui/recursion_limit/issue_21102.rs"}, {"sha": "9b1114e9ce62bd8df10b20ee618ce985c035cf95", "filename": "tests/ui/recursion_limit/issue-105700.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Frecursion_limit%2Fissue-105700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Frecursion_limit%2Fissue-105700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion_limit%2Fissue-105700.stderr?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -1,10 +1,10 @@\n error: recursion limit reached while expanding `#[invalid_attribute]`\n-  --> $DIR/issue_21102.rs:6:1\n+  --> $DIR/issue-105700.rs:6:1\n    |\n LL | #![invalid_attribute]\n    | ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"8\"]` attribute to your crate (`issue_21102`)\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"8\"]` attribute to your crate (`issue_105700`)\n \n error: aborting due to previous error\n ", "previous_filename": "tests/ui/recursion_limit/issue_21102.stderr"}, {"sha": "f37b27a82b3637685649dcf00419e05aae654049", "filename": "tests/ui/regions/resolve-re-error-ice.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Fregions%2Fresolve-re-error-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Fregions%2Fresolve-re-error-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fresolve-re-error-ice.rs?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+// Allow this for now, can remove this UI test when this becomes a hard error.\n+#![allow(implied_bounds_entailment)]\n+\n+use std::collections::hash_map::{Keys, HashMap};\n+use std::marker::PhantomData;\n+\n+trait MapAssertion<'a, K, V, R> {\n+    fn key_set(&self) -> Subject<Keys<K, V>, (), R>;\n+}\n+\n+struct Subject<'a, T, V, R>(PhantomData<(&'a T, V, R)>);\n+\n+impl<'a, K, V, R> MapAssertion<'a, K, V, R> for Subject<'a, HashMap<K, V>, (), R>\n+{\n+    fn key_set(&self) -> Subject<'a, Keys<K, V>, (), R> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e7003e1c32f6477b0314db23f7ca8105bd43560d", "filename": "tests/ui/regions/resolve-re-error-ice.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Fregions%2Fresolve-re-error-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da439d98749e7c94f3ecf355fdd616253ee08359/tests%2Fui%2Fregions%2Fresolve-re-error-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fresolve-re-error-ice.stderr?ref=da439d98749e7c94f3ecf355fdd616253ee08359", "patch": "@@ -0,0 +1,15 @@\n+Future incompatibility report: Future breakage diagnostic:\n+warning: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/resolve-re-error-ice.rs:17:16\n+   |\n+LL |     fn key_set(&self) -> Subject<'a, Keys<K, V>, (), R> {\n+   |                ^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `Subject<'_, std::collections::hash_map::Keys<'_, K, V>, (), R>`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/resolve-re-error-ice.rs:4:10\n+   |\n+LL | #![allow(implied_bounds_entailment)]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}]}