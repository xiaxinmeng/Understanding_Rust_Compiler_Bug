{"sha": "fa56cf537ffbb5a1614692422c4f0c728eea037f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNTZjZjUzN2ZmYmI1YTE2MTQ2OTI0MjJjNGYwYzcyOGVlYTAzN2Y=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-09-10T04:02:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-10T04:02:27Z"}, "message": "Rollup merge of #76458 - mbrubeck:hash_drain_filter, r=Amanieu\n\nAdd drain_filter method to HashMap and HashSet\n\nAdd `HashMap::drain_filter` and `HashSet::drain_filter`, implementing part of rust-lang/rfcs#2140.  These new methods are unstable.  The tracking issue is #59618.\n\nThe added iterators behave the same as `BTreeMap::drain_filter` and `BTreeSet::drain_filter`, except their iteration order is arbitrary.  The unit tests are adapted from `alloc::collections::btree`.\n\nThis branch rewrites `HashSet` to be a wrapper around `hashbrown::HashSet` rather than `std::collections::HashMap`.\n (Both are themselves wrappers around `hashbrown::HashMap`, so the in-memory representation is the same either way.)  This lets `std` re-use more iterator code from `hashbrown`.  Without this change, we would need to duplicate much more code to implement `HashSet::drain_filter`.\n\nThis branch also updates the `hashbrown` crate to version 0.9.0.  Aside from changes related to the `DrainFilter` iterators, this version only changes features that are not used in libstd or rustc.  And it updates `indexmap` to version 1.6.0, whose only change is compatibility with `hashbrown` 0.9.0.", "tree": {"sha": "0723fdde8c9727ca0312bdb397d8d502f131b18b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0723fdde8c9727ca0312bdb397d8d502f131b18b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa56cf537ffbb5a1614692422c4f0c728eea037f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfWaVUCRBK7hj4Ov3rIwAAdHIIAFxQT+IqFXV8yW+Oitp2/a3r\nSP5njRCeaVyd/eH9ZwxYPOfAsKkLdwr5qrzZlQuEZsmXir6VGuDZluCDiBzHkoW7\n7+acEQT4590tbkrEBqTkCib3VUOZk9wau9a1ye7F9yoyWIMPVgyCNLFO8kqeCHog\nRAdySAm589j8N0e+LHMVAhPdxJmtJclPnoMXJ4TrRUX5cy+PDWg4r8E7aAmN7B4S\ndTlu2ck7p9SJYOY9pQtor8eIATFj3uv8OgFFUrBlOhwvZPDxIsbgTLfNt2VOEFMd\nc0HxEJuTfzJbHLXAotUFg/AhNV8hlLVpuI5UIhfG8r89G1fqc/Z7c5WThl/0OIU=\n=v+Kr\n-----END PGP SIGNATURE-----\n", "payload": "tree 0723fdde8c9727ca0312bdb397d8d502f131b18b\nparent f09372ab609236510187bd61ab1c6b30cfa69014\nparent fb1fab5a67955240330038414c23d912766ddeaf\nauthor Tyler Mandry <tmandry@gmail.com> 1599710547 -0700\ncommitter GitHub <noreply@github.com> 1599710547 -0700\n\nRollup merge of #76458 - mbrubeck:hash_drain_filter, r=Amanieu\n\nAdd drain_filter method to HashMap and HashSet\n\nAdd `HashMap::drain_filter` and `HashSet::drain_filter`, implementing part of rust-lang/rfcs#2140.  These new methods are unstable.  The tracking issue is #59618.\n\nThe added iterators behave the same as `BTreeMap::drain_filter` and `BTreeSet::drain_filter`, except their iteration order is arbitrary.  The unit tests are adapted from `alloc::collections::btree`.\n\nThis branch rewrites `HashSet` to be a wrapper around `hashbrown::HashSet` rather than `std::collections::HashMap`.\n (Both are themselves wrappers around `hashbrown::HashMap`, so the in-memory representation is the same either way.)  This lets `std` re-use more iterator code from `hashbrown`.  Without this change, we would need to duplicate much more code to implement `HashSet::drain_filter`.\n\nThis branch also updates the `hashbrown` crate to version 0.9.0.  Aside from changes related to the `DrainFilter` iterators, this version only changes features that are not used in libstd or rustc.  And it updates `indexmap` to version 1.6.0, whose only change is compatibility with `hashbrown` 0.9.0.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa56cf537ffbb5a1614692422c4f0c728eea037f", "html_url": "https://github.com/rust-lang/rust/commit/fa56cf537ffbb5a1614692422c4f0c728eea037f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa56cf537ffbb5a1614692422c4f0c728eea037f/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f09372ab609236510187bd61ab1c6b30cfa69014", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09372ab609236510187bd61ab1c6b30cfa69014", "html_url": "https://github.com/rust-lang/rust/commit/f09372ab609236510187bd61ab1c6b30cfa69014"}, {"sha": "fb1fab5a67955240330038414c23d912766ddeaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1fab5a67955240330038414c23d912766ddeaf", "html_url": "https://github.com/rust-lang/rust/commit/fb1fab5a67955240330038414c23d912766ddeaf"}], "stats": {"total": 586, "additions": 503, "deletions": 83}, "files": [{"sha": "b687e714d4fa29609ae2d878530c9beb5ae55b80", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -1259,11 +1259,10 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e91b62f79061a0bc2e046024cb7ba44b08419ed238ecbd9adbd787434b9e8c25\"\n+checksum = \"00d63df3d41950fb462ed38308eea019113ad1508da725bbedcd0fa5a85ef5f7\"\n dependencies = [\n- \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1401,9 +1400,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.5.1\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n+checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\","}, {"sha": "bfd05db6b1bbee628c1554fdd33db18d7296d81d", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -20,7 +20,7 @@ libc = { version = \"0.2.74\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.35\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.8.1\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.9.0\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate\n addr2line = { version = \"0.13.0\", optional = true, default-features = false }"}, {"sha": "1a3a493fbb8f68dcff12a948f828669847bf99fb", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 93, "deletions": 6, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -497,6 +497,50 @@ impl<K, V, S> HashMap<K, V, S> {\n         Drain { base: self.base.drain() }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n+    /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n+    }\n+\n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n     /// for reuse.\n     ///\n@@ -1190,6 +1234,19 @@ impl<'a, K, V> Drain<'a, K, V> {\n     }\n }\n \n+/// A draining, filtering iterator over the entries of a `HashMap`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n+///\n+/// [`drain_filter`]: HashMap::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, V, F>,\n+}\n+\n /// A mutable iterator over the values of a `HashMap`.\n ///\n /// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n@@ -1247,16 +1304,16 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n-    Occupied(RawOccupiedEntryMut<'a, K, V>),\n+    Occupied(RawOccupiedEntryMut<'a, K, V, S>),\n     /// A vacant entry.\n     Vacant(RawVacantEntryMut<'a, K, V, S>),\n }\n \n /// A view into an occupied entry in a `HashMap`.\n /// It is part of the [`RawEntryMut`] enum.\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n-    base: base::RawOccupiedEntryMut<'a, K, V>,\n+pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n+    base: base::RawOccupiedEntryMut<'a, K, V, S>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n@@ -1457,7 +1514,7 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     }\n }\n \n-impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n+impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n     /// Gets a reference to the key in the entry.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n@@ -1597,7 +1654,7 @@ impl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n-impl<K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'_, K, V> {\n+impl<K: Debug, V: Debug, S> Debug for RawOccupiedEntryMut<'_, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"RawOccupiedEntryMut\")\n             .field(\"key\", self.key())\n@@ -1990,6 +2047,36 @@ where\n     }\n }\n \n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2698,7 +2785,7 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n+pub(super) fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n         hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n         hashbrown::TryReserveError::AllocError { layout } => {"}, {"sha": "467968354e25d984d1b47f885da660a1ae238a9d", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -924,3 +924,164 @@ fn test_raw_entry() {\n         }\n     }\n }\n+\n+mod test_drain_filter {\n+    use super::*;\n+\n+    use crate::panic::{catch_unwind, AssertUnwindSafe};\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+    trait EqSorted: Iterator {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool;\n+    }\n+\n+    impl<T: Iterator> EqSorted for T\n+    where\n+        T::Item: Eq + Ord,\n+    {\n+        fn eq_sorted<I: IntoIterator<Item = Self::Item>>(self, other: I) -> bool {\n+            let mut v: Vec<_> = self.collect();\n+            v.sort_unstable();\n+            v.into_iter().eq(other)\n+        }\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: HashMap<i32, i32> = HashMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq_sorted(crate::iter::empty()));\n+        assert_eq!(map.len(), 3);\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq_sorted(pairs));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq_sorted(crate::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq_sorted(0..3));\n+        assert!(map.values().copied().eq_sorted(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: HashMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq_sorted((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|_, _| {\n+                PREDS.fetch_add(1, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            }))\n+        }))\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 2);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+\n+    // Same as above, but attempt to use the iterator again after the panic in the predicate\n+    #[test]\n+    fn pred_panic_reuse() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = (0..3).map(|i| (i, D)).collect::<HashMap<_, _>>();\n+\n+        {\n+            let mut it = map.drain_filter(|_, _| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+                0 => true,\n+                _ => panic!(),\n+            });\n+            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+            // Iterator behaviour after a panic is explicitly unspecified,\n+            // so this is just the current implementation:\n+            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+            assert!(result.is_err());\n+        }\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+    }\n+}"}, {"sha": "72f4798b65d66d665f27c1bb9af67636e09bb6b0", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 136, "deletions": 57, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -1,14 +1,16 @@\n #[cfg(test)]\n mod tests;\n \n+use hashbrown::hash_set as base;\n+\n use crate::borrow::Borrow;\n use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{BuildHasher, Hash};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n use crate::ops::{BitAnd, BitOr, BitXor, Sub};\n \n-use super::map::{self, HashMap, Keys, RandomState};\n+use super::map::{map_try_reserve_error, RandomState};\n \n // Future Optimization (FIXME!)\n // ============================\n@@ -101,13 +103,14 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// // use the values stored in the set\n /// ```\n ///\n+/// [`HashMap`]: crate::collections::HashMap\n /// [`RefCell`]: crate::cell::RefCell\n /// [`Cell`]: crate::cell::Cell\n #[derive(Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"hashset_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>,\n+    base: base::HashSet<T, S>,\n }\n \n impl<T> HashSet<T, RandomState> {\n@@ -125,7 +128,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::new() }\n+        Default::default()\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity.\n@@ -143,7 +146,7 @@ impl<T> HashSet<T, RandomState> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, Default::default()) }\n     }\n }\n \n@@ -160,7 +163,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n+        self.base.capacity()\n     }\n \n     /// An iterator visiting all elements in arbitrary order.\n@@ -182,7 +185,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.map.keys() }\n+        Iter { base: self.base.iter() }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -200,7 +203,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.map.len()\n+        self.base.len()\n     }\n \n     /// Returns `true` if the set contains no elements.\n@@ -218,7 +221,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.map.is_empty()\n+        self.base.is_empty()\n     }\n \n     /// Clears the set, returning all elements in an iterator.\n@@ -241,7 +244,48 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<'_, T> {\n-        Drain { iter: self.map.drain() }\n+        Drain { base: self.base.drain() }\n+    }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<i32> = (0..8).collect();\n+    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n+    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n     }\n \n     /// Clears the set, removing all values.\n@@ -259,7 +303,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.map.clear()\n+        self.base.clear()\n     }\n \n     /// Creates a new empty hash set which will use the given hasher to hash\n@@ -288,7 +332,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_hasher(hasher) }\n+        HashSet { base: base::HashSet::with_hasher(hasher) }\n     }\n \n     /// Creates an empty `HashSet` with the specified capacity, using\n@@ -318,7 +362,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n-        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+        HashSet { base: base::HashSet::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n     /// Returns a reference to the set's [`BuildHasher`].\n@@ -336,7 +380,7 @@ impl<T, S> HashSet<T, S> {\n     #[inline]\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n-        self.map.hasher()\n+        self.base.hasher()\n     }\n }\n \n@@ -364,7 +408,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        self.map.reserve(additional)\n+        self.base.reserve(additional)\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -387,7 +431,7 @@ where\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.map.try_reserve(additional)\n+        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n     }\n \n     /// Shrinks the capacity of the set as much as possible. It will drop\n@@ -409,7 +453,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        self.map.shrink_to_fit()\n+        self.base.shrink_to_fit()\n     }\n \n     /// Shrinks the capacity of the set with a lower limit. It will drop\n@@ -437,7 +481,7 @@ where\n     #[inline]\n     #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.map.shrink_to(min_capacity)\n+        self.base.shrink_to(min_capacity)\n     }\n \n     /// Visits the values representing the difference,\n@@ -577,7 +621,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.contains_key(value)\n+        self.base.contains(value)\n     }\n \n     /// Returns a reference to the value in the set, if any, that is equal to the given value.\n@@ -602,7 +646,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.get_key_value(value).map(|(k, _)| k)\n+        self.base.get(value)\n     }\n \n     /// Inserts the given `value` into the set if it is not present, then\n@@ -626,7 +670,7 @@ where\n     pub fn get_or_insert(&mut self, value: T) -> &T {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(&value).or_insert(value, ()).0\n+        self.base.get_or_insert(value)\n     }\n \n     /// Inserts an owned copy of the given `value` into the set if it is not\n@@ -658,7 +702,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (value.to_owned(), ())).0\n+        self.base.get_or_insert_owned(value)\n     }\n \n     /// Inserts a value computed from `f` into the set if the given `value` is\n@@ -691,7 +735,7 @@ where\n     {\n         // Although the raw entry gives us `&mut T`, we only return `&T` to be consistent with\n         // `get`. Key mutation is \"raw\" because you're not supposed to affect `Eq` or `Hash`.\n-        self.map.raw_entry_mut().from_key(value).or_insert_with(|| (f(value), ())).0\n+        self.base.get_or_insert_with(value, f)\n     }\n \n     /// Returns `true` if `self` has no elements in common with `other`.\n@@ -788,7 +832,7 @@ where\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool {\n-        self.map.insert(value, ()).is_none()\n+        self.base.insert(value)\n     }\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n@@ -809,13 +853,7 @@ where\n     #[inline]\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn replace(&mut self, value: T) -> Option<T> {\n-        match self.map.entry(value) {\n-            map::Entry::Occupied(occupied) => Some(occupied.replace_key()),\n-            map::Entry::Vacant(vacant) => {\n-                vacant.insert(());\n-                None\n-            }\n-        }\n+        self.base.replace(value)\n     }\n \n     /// Removes a value from the set. Returns whether the value was\n@@ -843,7 +881,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove(value).is_some()\n+        self.base.remove(value)\n     }\n \n     /// Removes and returns the value in the set, if any, that is equal to the given one.\n@@ -868,7 +906,7 @@ where\n         T: Borrow<Q>,\n         Q: Hash + Eq,\n     {\n-        self.map.remove_entry(value).map(|(k, _)| k)\n+        self.base.take(value)\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -886,11 +924,11 @@ where\n     /// assert_eq!(set.len(), 3);\n     /// ```\n     #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n-    pub fn retain<F>(&mut self, mut f: F)\n+    pub fn retain<F>(&mut self, f: F)\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        self.map.retain(|k, _| f(k));\n+        self.base.retain(f)\n     }\n }\n \n@@ -949,17 +987,17 @@ where\n {\n     #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        self.map.extend(iter.into_iter().map(|k| (k, ())));\n+        self.base.extend(iter);\n     }\n \n     #[inline]\n     fn extend_one(&mut self, item: T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n     fn extend_reserve(&mut self, additional: usize) {\n-        self.map.extend_reserve(additional);\n+        self.base.extend_reserve(additional);\n     }\n }\n \n@@ -976,7 +1014,7 @@ where\n \n     #[inline]\n     fn extend_one(&mut self, &item: &'a T) {\n-        self.map.insert(item, ());\n+        self.base.insert(item);\n     }\n \n     #[inline]\n@@ -993,7 +1031,7 @@ where\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     #[inline]\n     fn default() -> HashSet<T, S> {\n-        HashSet { map: HashMap::default() }\n+        HashSet { base: Default::default() }\n     }\n }\n \n@@ -1137,7 +1175,7 @@ where\n /// [`iter`]: HashSet::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>,\n+    base: base::Iter<'a, K>,\n }\n \n /// An owning iterator over the items of a `HashSet`.\n@@ -1148,7 +1186,7 @@ pub struct Iter<'a, K: 'a> {\n /// [`into_iter`]: IntoIterator::into_iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: map::IntoIter<K, ()>,\n+    base: base::IntoIter<K>,\n }\n \n /// A draining iterator over the items of a `HashSet`.\n@@ -1159,7 +1197,20 @@ pub struct IntoIter<K> {\n /// [`drain`]: HashSet::drain\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: map::Drain<'a, K, ()>,\n+    base: base::Drain<'a, K>,\n+}\n+\n+/// A draining, filtering iterator over the items of a `HashSet`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n+///\n+/// [`drain_filter`]: HashSet::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, F>,\n }\n \n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n@@ -1250,15 +1301,15 @@ impl<T, S> IntoIterator for HashSet<T, S> {\n     /// ```\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { iter: self.map.into_iter() }\n+        IntoIter { base: self.base.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Clone for Iter<'_, K> {\n     #[inline]\n     fn clone(&self) -> Self {\n-        Iter { iter: self.iter.clone() }\n+        Iter { base: self.base.clone() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1267,18 +1318,18 @@ impl<'a, K> Iterator for Iter<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a K> {\n-        self.iter.next()\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Iter<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1297,18 +1348,18 @@ impl<K> Iterator for IntoIter<K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1317,8 +1368,7 @@ impl<K> FusedIterator for IntoIter<K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n     }\n }\n \n@@ -1328,18 +1378,18 @@ impl<'a, K> Iterator for Drain<'a, K> {\n \n     #[inline]\n     fn next(&mut self) -> Option<K> {\n-        self.iter.next().map(|(k, _)| k)\n+        self.base.next()\n     }\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+        self.base.size_hint()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for Drain<'_, K> {\n     #[inline]\n     fn len(&self) -> usize {\n-        self.iter.len()\n+        self.base.len()\n     }\n }\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1348,8 +1398,37 @@ impl<K> FusedIterator for Drain<'_, K> {}\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let entries_iter = self.iter.iter().map(|(k, _)| k);\n-        f.debug_list().entries(entries_iter).finish()\n+        fmt::Debug::fmt(&self.base, f)\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> Iterator for DrainFilter<'_, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    type Item = K;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n     }\n }\n "}, {"sha": "40f8467fd93fddf18907d1a9d55440164a9a522f", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -1,6 +1,9 @@\n use super::super::map::RandomState;\n use super::HashSet;\n \n+use crate::panic::{catch_unwind, AssertUnwindSafe};\n+use crate::sync::atomic::{AtomicU32, Ordering};\n+\n #[test]\n fn test_zero_capacities() {\n     type HS = HashSet<i32>;\n@@ -413,3 +416,71 @@ fn test_retain() {\n     assert!(set.contains(&4));\n     assert!(set.contains(&6));\n }\n+\n+#[test]\n+fn test_drain_filter() {\n+    let mut x: HashSet<_> = [1].iter().copied().collect();\n+    let mut y: HashSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = (0..3).map(|i| D(i)).collect::<HashSet<_>>();\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|_| {\n+            PREDS.fetch_add(1, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 3);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Hash)]\n+    struct D;\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set: HashSet<_> = (0..3).map(|_| D).collect();\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|_| match PREDS.fetch_add(1, Ordering::SeqCst) {\n+            0 => true,\n+            _ => panic!(),\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 1);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    assert_eq!(set.len(), 0);\n+}"}, {"sha": "a5a1824c84e78be919f81ea5f4119d70686b7121", "filename": "src/etc/gdb_lookup.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -69,9 +69,9 @@ def lookup(valobj):\n         else:\n             return StdOldHashMapProvider(valobj)\n     if rust_type == RustType.STD_HASH_SET:\n-        hash_map = valobj[\"map\"]\n+        hash_map = valobj[valobj.type.fields()[0]]\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapProvider(hash_map, show_values=False)\n+            return StdHashMapProvider(valobj, show_values=False)\n         else:\n             return StdOldHashMapProvider(hash_map, show_values=False)\n "}, {"sha": "bae51e6f9ee93a394ba51718ebfe5b81a9f1c5a5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -347,7 +347,7 @@ def __init__(self, valobj, show_values=True):\n         self.valobj = valobj\n         self.show_values = show_values\n \n-        table = self.valobj[\"base\"][\"table\"]\n+        table = self.table()\n         capacity = int(table[\"bucket_mask\"]) + 1\n         ctrl = table[\"ctrl\"][\"pointer\"]\n \n@@ -368,6 +368,18 @@ def __init__(self, valobj, show_values=True):\n             if is_presented:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj[\"base\"]\n+        elif self.valobj.type.fields()[0].name == \"map\":\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps std::collections::HashMap, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"map\"][\"base\"]\n+        else:\n+            # HashSet wraps hashbrown::HashSet, which wraps hashbrown::HashMap\n+            hashbrown_hashmap = self.valobj[\"base\"][\"map\"]\n+        return hashbrown_hashmap[\"table\"]\n+\n     def to_string(self):\n         if self.show_values:\n             return \"HashMap(size={})\".format(self.size)"}, {"sha": "3cee51982ba9f921eac8be4e9eeed216df09680b", "filename": "src/etc/lldb_lookup.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -94,7 +94,7 @@ def synthetic_lookup(valobj, dict):\n     if rust_type == RustType.STD_HASH_SET:\n         hash_map = valobj.GetChildAtIndex(0)\n         if is_hashbrown_hashmap(hash_map):\n-            return StdHashMapSyntheticProvider(hash_map, dict, show_values=False)\n+            return StdHashMapSyntheticProvider(valobj, dict, show_values=False)\n         else:\n             return StdOldHashMapSyntheticProvider(hash_map, dict, show_values=False)\n "}, {"sha": "64cb9837943b902b0b8fcdf9749859848c25e884", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -526,7 +526,7 @@ def get_child_at_index(self, index):\n \n     def update(self):\n         # type: () -> None\n-        table = self.valobj.GetChildMemberWithName(\"base\").GetChildMemberWithName(\"table\")\n+        table = self.table()\n         capacity = table.GetChildMemberWithName(\"bucket_mask\").GetValueAsUnsigned() + 1\n         ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n \n@@ -552,6 +552,17 @@ def update(self):\n             if is_present:\n                 self.valid_indices.append(idx)\n \n+    def table(self):\n+        # type: () -> SBValue\n+        if self.show_values:\n+            hashbrown_hashmap = self.valobj.GetChildMemberWithName(\"base\")\n+        else:\n+            # BACKCOMPAT: rust 1.47\n+            # HashSet wraps either std HashMap or hashbrown::HashSet, which both\n+            # wrap hashbrown::HashMap, so either way we \"unwrap\" twice.\n+            hashbrown_hashmap = self.valobj.GetChildAtIndex(0).GetChildAtIndex(0)\n+        return hashbrown_hashmap.GetChildMemberWithName(\"table\")\n+\n     def has_children(self):\n         # type: () -> bool\n         return True"}, {"sha": "9550c25f2fcfe5da1b78cc5b2ab743f3f1ab105f", "filename": "src/etc/natvis/libstd.natvis", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/fa56cf537ffbb5a1614692422c4f0c728eea037f/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=fa56cf537ffbb5a1614692422c4f0c728eea037f", "patch": "@@ -5,7 +5,7 @@\n \n     Current std impls:\n       std::collections::hash::set::HashSet<K, S>      is implemented in terms of...\n-      std::collections::hash::map::HashMap<K, V, S>   is implemented in terms of...\n+      hashbrown::set::HashSet<K, S>                   is implemented in terms of...\n       hashbrown::map::HashMap<K, V, S>                is implemented in terms of...\n       hashbrown::raw::RawTable<(K, V)>\n \n@@ -50,22 +50,22 @@\n   </Type>\n \n   <Type Name=\"std::collections::hash::set::HashSet&lt;*,*&gt;\">\n-    <DisplayString>{{ size={map.base.table.items} }}</DisplayString>\n+    <DisplayString>{{ size={base.map.table.items} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[size]\">map.base.table.items</Item>\n-      <Item Name=\"[capacity]\">map.base.table.items + map.base.table.growth_left</Item>\n-      <Item Name=\"[state]\">map.base.hash_builder</Item>\n+      <Item Name=\"[size]\">base.map.table.items</Item>\n+      <Item Name=\"[capacity]\">base.map.table.items + base.map.table.growth_left</Item>\n+      <Item Name=\"[state]\">base.map.hash_builder</Item>\n \n       <CustomListItems>\n         <Variable Name=\"i\" InitialValue=\"0\" />\n-        <Variable Name=\"n\" InitialValue=\"map.base.table.items\" />\n-        <Size>map.base.table.items</Size>\n+        <Variable Name=\"n\" InitialValue=\"base.map.table.items\" />\n+        <Size>base.map.table.items</Size>\n         <Loop>\n           <Break Condition=\"n == 0\" />\n-          <If Condition=\"(map.base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n+          <If Condition=\"(base.map.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n             <!-- Bucket is populated -->\n             <Exec>n--</Exec>\n-            <Item>(($T1*)map.base.table.ctrl.pointer)[-(i + 1)]</Item>\n+            <Item>(($T1*)base.map.table.ctrl.pointer)[-(i + 1)]</Item>\n           </If>\n           <Exec>i++</Exec>\n         </Loop>"}]}