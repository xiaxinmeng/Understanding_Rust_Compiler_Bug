{"sha": "ec443886ea0eaef05979e1c83a41beaa714297c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDQzODg2ZWEwZWFlZjA1OTc5ZTFjODNhNDFiZWFhNzE0Mjk3YzQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-11T11:39:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-11T11:52:57Z"}, "message": "Show type actions on ranged type hover", "tree": {"sha": "6bb72b82268e6e30f99794e9bc90747653a65c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bb72b82268e6e30f99794e9bc90747653a65c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec443886ea0eaef05979e1c83a41beaa714297c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec443886ea0eaef05979e1c83a41beaa714297c4", "html_url": "https://github.com/rust-lang/rust/commit/ec443886ea0eaef05979e1c83a41beaa714297c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec443886ea0eaef05979e1c83a41beaa714297c4/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2246fecef40fb86806fbe440df3b1eeb19a0f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2246fecef40fb86806fbe440df3b1eeb19a0f34", "html_url": "https://github.com/rust-lang/rust/commit/f2246fecef40fb86806fbe440df3b1eeb19a0f34"}], "stats": {"total": 201, "additions": 143, "deletions": 58}, "files": [{"sha": "35c219cadd94f4437be3bd9cf1f7740dbea73269", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=ec443886ea0eaef05979e1c83a41beaa714297c4", "patch": "@@ -1,6 +1,6 @@\n //! Utilities for creating `Analysis` instances for tests.\n use ide_db::base_db::fixture::ChangeFixture;\n-use test_utils::extract_annotations;\n+use test_utils::{extract_annotations, RangeOrOffset};\n \n use crate::{Analysis, AnalysisHost, FileId, FilePosition, FileRange};\n \n@@ -32,6 +32,15 @@ pub(crate) fn range(ra_fixture: &str) -> (Analysis, FileRange) {\n     (host.analysis(), FileRange { file_id, range })\n }\n \n+/// Creates analysis for a single file, returns range marked with a pair of $0 or a position marked with $0.\n+pub(crate) fn range_or_position(ra_fixture: &str) -> (Analysis, FileId, RangeOrOffset) {\n+    let mut host = AnalysisHost::default();\n+    let change_fixture = ChangeFixture::parse(ra_fixture);\n+    host.db.apply_change(change_fixture.change);\n+    let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n+    (host.analysis(), file_id, range_or_offset)\n+}\n+\n /// Creates analysis from a multi-file fixture, returns positions marked with $0.\n pub(crate) fn annotations(ra_fixture: &str) -> (Analysis, FilePosition, Vec<(FileRange, String)>) {\n     let mut host = AnalysisHost::default();"}, {"sha": "da023419ccfef3d9a6e35f741415cb115ee8da0b", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 127, "deletions": 57, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=ec443886ea0eaef05979e1c83a41beaa714297c4", "patch": "@@ -13,7 +13,7 @@ use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n     algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, AstToken, Direction,\n-    SyntaxKind::*, SyntaxToken, T,\n+    SyntaxKind::*, SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -54,6 +54,25 @@ pub enum HoverAction {\n     GoToType(Vec<HoverGotoTypeData>),\n }\n \n+impl HoverAction {\n+    fn goto_type_from_targets(db: &RootDatabase, targets: Vec<hir::ModuleDef>) -> Self {\n+        let targets = targets\n+            .into_iter()\n+            .filter_map(|it| {\n+                Some(HoverGotoTypeData {\n+                    mod_path: render_path(\n+                        db,\n+                        it.module(db)?,\n+                        it.name(db).map(|name| name.to_string()),\n+                    ),\n+                    nav: it.try_to_nav(db)?,\n+                })\n+            })\n+            .collect();\n+        HoverAction::GoToType(targets)\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct HoverGotoTypeData {\n     pub mod_path: String,\n@@ -81,28 +100,10 @@ pub(crate) fn hover(\n     let sema = hir::Semantics::new(db);\n     let file = sema.parse(file_id).syntax().clone();\n \n-    let offset = if range.is_empty() {\n-        range.start()\n-    } else {\n-        let expr = file.covering_element(range).ancestors().find_map(|it| {\n-            match_ast! {\n-                match it {\n-                    ast::Expr(expr) => Some(Either::Left(expr)),\n-                    ast::Pat(pat) => Some(Either::Right(pat)),\n-                    _ => None,\n-                }\n-            }\n-        })?;\n-        return hover_type_info(&sema, config, &expr).map(|it| {\n-            RangeInfo::new(\n-                match expr {\n-                    Either::Left(it) => it.syntax().text_range(),\n-                    Either::Right(it) => it.syntax().text_range(),\n-                },\n-                it,\n-            )\n-        });\n-    };\n+    if !range.is_empty() {\n+        return hover_ranged(&file, range, &sema, config);\n+    }\n+    let offset = range.start();\n \n     let token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,\n@@ -112,8 +113,8 @@ pub(crate) fn hover(\n     })?;\n     let token = sema.descend_into_macros(token);\n \n+    let mut range_override = None;\n     let node = token.parent()?;\n-    let mut range = None;\n     let definition = match_ast! {\n         match node {\n             // We don't use NameClass::referenced_or_defined here as we do not want to resolve\n@@ -129,11 +130,13 @@ pub(crate) fn hover(\n                 }\n             }),\n             ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n-                || NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                    NameRefClass::Definition(it) => Some(it),\n-                    _ => None,\n-                }),\n-                |d| d.defined(),\n+                || {\n+                    NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                        NameRefClass::Definition(it) => Some(it),\n+                        _ => None,\n+                    })\n+                },\n+                NameClass::defined,\n             ),\n             _ => {\n                 if ast::Comment::cast(token.clone()).is_some() {\n@@ -145,7 +148,7 @@ pub(crate) fn hover(\n                             let mapped = doc_mapping.map(range)?;\n                             (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n                         })?;\n-                    range = Some(idl_range);\n+                    range_override = Some(idl_range);\n                     Some(match resolve_doc_path_for_def(db,def, &link,ns)? {\n                         Either::Left(it) => Definition::ModuleDef(it),\n                         Either::Right(it) => Definition::Macro(it),\n@@ -154,7 +157,7 @@ pub(crate) fn hover(\n                     if let res@Some(_) = try_hover_for_lint(&attr, &token) {\n                         return res;\n                     } else {\n-                        range = Some(token.text_range());\n+                        range_override = Some(token.text_range());\n                         try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro)\n                     }\n                 } else {\n@@ -186,11 +189,11 @@ pub(crate) fn hover(\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = goto_type_action(db, definition) {\n+            if let Some(action) = goto_type_action_for_def(db, definition) {\n                 res.actions.push(action);\n             }\n \n-            let range = range.unwrap_or_else(|| sema.original_range(&node).range);\n+            let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n@@ -199,6 +202,8 @@ pub(crate) fn hover(\n         return res;\n     }\n \n+    // No definition below cursor, fall back to showing type hovers.\n+\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -220,6 +225,30 @@ pub(crate) fn hover(\n     Some(RangeInfo::new(range, res))\n }\n \n+fn hover_ranged(\n+    file: &SyntaxNode,\n+    range: syntax::TextRange,\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+) -> Option<RangeInfo<HoverResult>> {\n+    let expr = file.covering_element(range).ancestors().find_map(|it| {\n+        match_ast! {\n+            match it {\n+                ast::Expr(expr) => Some(Either::Left(expr)),\n+                ast::Pat(pat) => Some(Either::Right(pat)),\n+                _ => None,\n+            }\n+        }\n+    })?;\n+    hover_type_info(sema, config, &expr).map(|it| {\n+        let range = match expr {\n+            Either::Left(it) => it.syntax().text_range(),\n+            Either::Right(it) => it.syntax().text_range(),\n+        };\n+        RangeInfo::new(range, it)\n+    })\n+}\n+\n fn hover_type_info(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n@@ -231,7 +260,16 @@ fn hover_type_info(\n     };\n \n     let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n     res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n         let original = original.display(sema.db).to_string();\n         let adjusted = adjusted_ty.display(sema.db).to_string();\n         format!(\n@@ -250,6 +288,7 @@ fn hover_type_info(\n             original.display(sema.db).to_string().into()\n         }\n     };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n     Some(res)\n }\n \n@@ -354,7 +393,7 @@ fn runnable_action(\n     }\n }\n \n-fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n+fn goto_type_action_for_def(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n     let mut targets: Vec<hir::ModuleDef> = Vec::new();\n     let mut push_new_def = |item: hir::ModuleDef| {\n         if !targets.contains(&item) {\n@@ -372,30 +411,28 @@ fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n             _ => return None,\n         };\n \n-        ty.walk(db, |t| {\n-            if let Some(adt) = t.as_adt() {\n-                push_new_def(adt.into());\n-            } else if let Some(trait_) = t.as_dyn_trait() {\n-                push_new_def(trait_.into());\n-            } else if let Some(traits) = t.as_impl_traits(db) {\n-                traits.into_iter().for_each(|it| push_new_def(it.into()));\n-            } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n-                push_new_def(trait_.into());\n-            }\n-        });\n+        walk_and_push_ty(db, &ty, &mut push_new_def);\n     }\n \n-    let targets = targets\n-        .into_iter()\n-        .filter_map(|it| {\n-            Some(HoverGotoTypeData {\n-                mod_path: render_path(db, it.module(db)?, it.name(db).map(|name| name.to_string())),\n-                nav: it.try_to_nav(db)?,\n-            })\n-        })\n-        .collect();\n+    Some(HoverAction::goto_type_from_targets(db, targets))\n+}\n \n-    Some(HoverAction::GoToType(targets))\n+fn walk_and_push_ty(\n+    db: &RootDatabase,\n+    ty: &hir::Type,\n+    push_new_def: &mut dyn FnMut(hir::ModuleDef),\n+) {\n+    ty.walk(db, |t| {\n+        if let Some(adt) = t.as_adt() {\n+            push_new_def(adt.into());\n+        } else if let Some(trait_) = t.as_dyn_trait() {\n+            push_new_def(trait_.into());\n+        } else if let Some(traits) = t.as_impl_traits(db) {\n+            traits.into_iter().for_each(|it| push_new_def(it.into()));\n+        } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n+            push_new_def(trait_.into());\n+        }\n+    });\n }\n \n fn hover_markup(docs: Option<String>, desc: String, mod_path: Option<String>) -> Option<Markup> {\n@@ -666,14 +703,14 @@ mod tests {\n     }\n \n     fn check_actions(ra_fixture: &str, expect: Expect) {\n-        let (analysis, position) = fixture::position(ra_fixture);\n+        let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);\n         let hover = analysis\n             .hover(\n                 &HoverConfig {\n                     links_in_hover: true,\n                     documentation: Some(HoverDocFormat::Markdown),\n                 },\n-                FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n+                FileRange { file_id, range: position.range_or_empty() },\n             )\n             .unwrap()\n             .unwrap();\n@@ -4163,4 +4200,37 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_range_shows_type_actions() {\n+        check_actions(\n+            r#\"\n+struct Foo;\n+fn foo() {\n+    let x: &Foo = $0&&&&&Foo$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    GoToType(\n+                        [\n+                            HoverGotoTypeData {\n+                                mod_path: \"test::Foo\",\n+                                nav: NavigationTarget {\n+                                    file_id: FileId(\n+                                        0,\n+                                    ),\n+                                    full_range: 0..11,\n+                                    focus_range: 7..10,\n+                                    name: \"Foo\",\n+                                    kind: Struct,\n+                                    description: \"struct Foo\",\n+                                },\n+                            },\n+                        ],\n+                    ),\n+                ]\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "7b43fb9de54ee259da49bd2f6aeb2009240f7e20", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec443886ea0eaef05979e1c83a41beaa714297c4/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=ec443886ea0eaef05979e1c83a41beaa714297c4", "patch": "@@ -113,6 +113,12 @@ impl RangeOrOffset {\n             RangeOrOffset::Offset(_) => panic!(\"expected a range but got an offset\"),\n         }\n     }\n+    pub fn range_or_empty(self) -> TextRange {\n+        match self {\n+            RangeOrOffset::Range(range) => range,\n+            RangeOrOffset::Offset(offset) => TextRange::empty(offset),\n+        }\n+    }\n }\n \n impl From<RangeOrOffset> for TextRange {"}]}