{"sha": "f6c5d8d599070bacad800ac7014fa3a6f140eadc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YzVkOGQ1OTkwNzBiYWNhZDgwMGFjNzAxNGZhM2E2ZjE0MGVhZGM=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-07T20:19:25Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T23:27:25Z"}, "message": "Remove all usages of `match_path`, `match_qpath` and `match_path_ast` except the `author` lint.\nAdd note to fix `MATCH_TYPE_ON_DIAG_ITEM`\nAdd false negative test for `uninit_assumed_init`", "tree": {"sha": "012bf8d18f3e1d02ce4ed8fbf6c77f4f2c560030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/012bf8d18f3e1d02ce4ed8fbf6c77f4f2c560030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6c5d8d599070bacad800ac7014fa3a6f140eadc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmB4zAQACgkQ2lnoZDo37Qb88QEA9s9Bu8qj4U/zKe8SuBDaoDbD\nSwoERmrfD15xXkoG5XEA/0MvXMA1SX0w6tfFoI+lSXUEBUKYpth+3iFW+g16VQwA\n=R9R0\n-----END PGP SIGNATURE-----", "payload": "tree 012bf8d18f3e1d02ce4ed8fbf6c77f4f2c560030\nparent b1c675f3fc682201cdb28719133285b878e2d157\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617826765 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1618529245 -0400\n\nRemove all usages of `match_path`, `match_qpath` and `match_path_ast` except the `author` lint.\nAdd note to fix `MATCH_TYPE_ON_DIAG_ITEM`\nAdd false negative test for `uninit_assumed_init`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6c5d8d599070bacad800ac7014fa3a6f140eadc", "html_url": "https://github.com/rust-lang/rust/commit/f6c5d8d599070bacad800ac7014fa3a6f140eadc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6c5d8d599070bacad800ac7014fa3a6f140eadc/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1c675f3fc682201cdb28719133285b878e2d157", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c675f3fc682201cdb28719133285b878e2d157", "html_url": "https://github.com/rust-lang/rust/commit/b1c675f3fc682201cdb28719133285b878e2d157"}], "stats": {"total": 604, "additions": 269, "deletions": 335}, "files": [{"sha": "c565e29d07801d3a449aeabe40276f4c8315cff3", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -127,10 +127,9 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n             _ => &block.expr,\n         };\n         // function call\n-        if let Some(args) = match_panic_call(cx, begin_panic_call);\n-        if args.len() == 1;\n+        if let Some(arg) = match_panic_call(cx, begin_panic_call);\n         // bind the second argument of the `assert!` macro if it exists\n-        if let panic_message = snippet_opt(cx, args[0].span);\n+        if let panic_message = snippet_opt(cx, arg.span);\n         // second argument of begin_panic is irrelevant\n         // as is the second match arm\n         then {"}, {"sha": "4e2dbf005d51c7cd9f2f5ffb9fde6563d73c9def", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{in_macro, match_path_ast};\n+use clippy_utils::in_macro;\n use rustc_ast::ast::{AssocItemKind, Extern, FnKind, FnSig, ImplKind, Item, ItemKind, TraitKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -126,7 +126,9 @@ impl_lint_pass!(ExcessiveBools => [STRUCT_EXCESSIVE_BOOLS, FN_PARAMS_EXCESSIVE_B\n \n fn is_bool_ty(ty: &Ty) -> bool {\n     if let TyKind::Path(None, path) = &ty.kind {\n-        return match_path_ast(path, &[\"bool\"]);\n+        if let [name] = path.segments.as_slice() {\n+            return name.ident.name == sym::bool;\n+        }\n     }\n     false\n }"}, {"sha": "03fe0d16d480f792f8138a3480812604ab183cb4", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -22,7 +22,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, match_path};\n+use clippy_utils::{differing_macro_contexts, match_def_path};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for public `impl` or `fn` missing generalization\n@@ -333,12 +333,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Call(fun, args) = e.kind;\n             if let ExprKind::Path(QPath::TypeRelative(ty, method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n+            if let Some(ty_did) = ty_path.res.opt_def_id();\n             then {\n                 if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n                     return;\n                 }\n \n-                if match_path(ty_path, &paths::HASHMAP) {\n+                if match_def_path(self.cx, ty_did, &paths::HASHMAP) {\n                     if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n@@ -351,7 +352,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                             ),\n                         );\n                     }\n-                } else if match_path(ty_path, &paths::HASHSET) {\n+                } else if match_def_path(self.cx, ty_did, &paths::HASHSET) {\n                     if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());"}, {"sha": "4069a685ea0a44e9eff0d141fa0c67feba6b769c", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{in_macro, match_qpath, SpanlessEq};\n+use clippy_utils::{in_macro, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -87,7 +87,13 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n-                const INT_TYPES: [&str; 5] = [\"i8\", \"i16\", \"i32\", \"i64\", \"i128\"];\n+                const INT_TYPES: [LangItem; 5] = [\n+                    LangItem::I8,\n+                    LangItem::I16,\n+                    LangItem::I32,\n+                    LangItem::I64,\n+                    LangItem::Isize\n+                ];\n \n                 match cond_num_val.kind {\n                     ExprKind::Lit(ref cond_lit) => {\n@@ -99,17 +105,30 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             };\n                         }\n                     },\n-                    ExprKind::Path(ref cond_num_path) => {\n-                        if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"MIN\"])) {\n-                            print_lint_and_sugg(cx, &var_name, expr);\n-                        };\n+                    ExprKind::Path(QPath::TypeRelative(_, name)) => {\n+                        if_chain! {\n+                            if name.ident.as_str() == \"MIN\";\n+                            if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n+                            if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n+                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n+                            if int_ids.any(|int_id| int_id == impl_id);\n+                            then {\n+                                print_lint_and_sugg(cx, &var_name, expr)\n+                            }\n+                        }\n                     },\n-                    ExprKind::Call(func, _) => {\n-                        if let ExprKind::Path(ref cond_num_path) = func.kind {\n-                            if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n-                                print_lint_and_sugg(cx, &var_name, expr);\n+                    ExprKind::Call(func, []) => {\n+                        if_chain! {\n+                            if let ExprKind::Path(QPath::TypeRelative(_, name)) = func.kind;\n+                            if name.ident.as_str() == \"min_value\";\n+                            if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n+                            if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n+                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n+                            if int_ids.any(|int_id| int_id == impl_id);\n+                            then {\n+                                print_lint_and_sugg(cx, &var_name, expr)\n                             }\n-                        };\n+                        }\n                     },\n                     _ => (),\n                 }"}, {"sha": "afee20ce43e48088b46e2cf3d9cb4c39a272057e", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, match_type};\n-use clippy_utils::{get_trait_def_id, higher, match_qpath, paths};\n+use clippy_utils::{get_trait_def_id, higher, is_qpath_def_path, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -163,7 +163,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n         ExprKind::Call(path, _) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n-                match_qpath(qpath, &paths::REPEAT).into()\n+                is_qpath_def_path(cx, qpath, path.hir_id, &paths::ITER_REPEAT).into()\n             } else {\n                 Finite\n             }"}, {"sha": "41cda23510ea2f9e19e694e534ebf0f98d5e8834", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_adjusted, is_trait_method, match_path, match_var, paths, remove_blocks};\n+use clippy_utils::{is_adjusted, is_qpath_def_path, is_trait_method, match_var, paths, remove_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n@@ -80,7 +80,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(QPath::Resolved(_, path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n         _ => false,\n     }\n }"}, {"sha": "8f1112cff7b184116d81da453c79e56c9771404e", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1701,7 +1701,7 @@ mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n     use clippy_utils::source::snippet;\n-    use clippy_utils::{is_lang_ctor, is_trait_method, match_qpath, paths};\n+    use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n     use rustc_errors::Applicability;\n@@ -1735,8 +1735,8 @@ mod redundant_pattern_match {\n             kind = &inner.kind;\n         }\n         let good_method = match kind {\n-            PatKind::TupleStruct(ref path, patterns, _) if patterns.len() == 1 => {\n-                if let PatKind::Wild = patterns[0].kind {\n+            PatKind::TupleStruct(ref path, [sub_pat], _) => {\n+                if let PatKind::Wild = sub_pat.kind {\n                     if is_lang_ctor(cx, path, ResultOk) {\n                         \"is_ok()\"\n                     } else if is_lang_ctor(cx, path, ResultErr) {\n@@ -1745,9 +1745,9 @@ mod redundant_pattern_match {\n                         \"is_some()\"\n                     } else if is_lang_ctor(cx, path, PollReady) {\n                         \"is_ready()\"\n-                    } else if match_qpath(path, &paths::IPADDR_V4) {\n+                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n                         \"is_ipv4()\"\n-                    } else if match_qpath(path, &paths::IPADDR_V6) {\n+                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n                         \"is_ipv6()\"\n                     } else {\n                         return;\n@@ -1821,6 +1821,7 @@ mod redundant_pattern_match {\n                 ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n                     if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n                         find_good_method_for_match(\n+                            cx,\n                             arms,\n                             path_left,\n                             path_right,\n@@ -1831,6 +1832,7 @@ mod redundant_pattern_match {\n                         )\n                         .or_else(|| {\n                             find_good_method_for_match(\n+                                cx,\n                                 arms,\n                                 path_left,\n                                 path_right,\n@@ -1850,6 +1852,7 @@ mod redundant_pattern_match {\n                 {\n                     if let PatKind::Wild = patterns[0].kind {\n                         find_good_method_for_match(\n+                            cx,\n                             arms,\n                             path_left,\n                             path_right,\n@@ -1860,6 +1863,7 @@ mod redundant_pattern_match {\n                         )\n                         .or_else(|| {\n                             find_good_method_for_match(\n+                                cx,\n                                 arms,\n                                 path_left,\n                                 path_right,\n@@ -1900,7 +1904,9 @@ mod redundant_pattern_match {\n         }\n     }\n \n+    #[allow(clippy::too_many_arguments)]\n     fn find_good_method_for_match<'a>(\n+        cx: &LateContext<'_>,\n         arms: &[Arm<'_>],\n         path_left: &QPath<'_>,\n         path_right: &QPath<'_>,\n@@ -1909,9 +1915,13 @@ mod redundant_pattern_match {\n         should_be_left: &'a str,\n         should_be_right: &'a str,\n     ) -> Option<&'a str> {\n-        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+        let body_node_pair = if is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_left)\n+            && is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_right)\n+        {\n             (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+        } else if is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_left)\n+            && is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_right)\n+        {\n             (&(*arms[1].body).kind, &(*arms[0].body).kind)\n         } else {\n             return None;"}, {"sha": "403fe8d35468468db91a9c46a13dd2755b5c9fd7", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n+use clippy_utils::{is_expr_path_def_path, is_trait_method, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -33,14 +33,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg:\n             }\n         }\n \n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = filter_map_arg.kind;\n-\n-            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n-\n-            then {\n-                apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n-            }\n+        if is_expr_path_def_path(cx, filter_map_arg, &paths::CONVERT_IDENTITY) {\n+            apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n         }\n     }\n }"}, {"sha": "25f8434cb94428f458f36fd442fcf8260e542828", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_trait_method, match_qpath, paths};\n+use clippy_utils::{is_expr_path_def_path, is_trait_method, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -16,8 +16,6 @@ pub(super) fn check<'tcx>(\n     flat_map_span: Span,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &flat_map_arg.kind;\n-\n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n                 cx,\n@@ -31,8 +29,8 @@ pub(super) fn check<'tcx>(\n         };\n \n         if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n-            let body = cx.tcx.hir().body(*body_id);\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = flat_map_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n \n             if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n             if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n@@ -45,14 +43,8 @@ pub(super) fn check<'tcx>(\n             }\n         }\n \n-        if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = arg_node;\n-\n-            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n-\n-            then {\n-                apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n-            }\n+        if is_expr_path_def_path(cx, flat_map_arg, &paths::CONVERT_IDENTITY) {\n+            apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n         }\n     }\n }"}, {"sha": "28d0e8cd4ae9e33039c01e7b0c21c34d55166bb4", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,26 +1,23 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, match_qpath, paths, sugg};\n+use clippy_utils::{is_expr_path_def_path, paths, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::ExprKind;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty::Ty;\n use rustc_span::sym;\n \n use super::FROM_ITER_INSTEAD_OF_COLLECT;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>], func_kind: &ExprKind<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>], func: &hir::Expr<'_>) {\n     if_chain! {\n-        if let hir::ExprKind::Path(path) = func_kind;\n-        if match_qpath(path, &[\"from_iter\"]);\n+        if is_expr_path_def_path(cx, func, &paths::FROM_ITERATOR_METHOD);\n         let ty = cx.typeck_results().expr_ty(expr);\n         let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n-        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n         if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n \n-        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        if implements_trait(cx, arg_ty, iter_id, &[]);\n         then {\n             // `expr` implements `FromIterator` trait\n             let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();"}, {"sha": "2fddea7068d961f45d14a81bb3961c1377cce7f0", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::match_qpath;\n+use clippy_utils::is_qpath_def_path;\n use clippy_utils::source::snippet_with_applicability;\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -94,11 +94,11 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n \n     // `std::T::MAX` `std::T::MIN` constants\n     if let hir::ExprKind::Path(path) = &expr.kind {\n-        if match_qpath(path, &[\"core\", &ty_str, \"MAX\"][..]) {\n+        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MAX\"][..]) {\n             return Some(MinMax::Max);\n         }\n \n-        if match_qpath(path, &[\"core\", &ty_str, \"MIN\"][..]) {\n+        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MIN\"][..]) {\n             return Some(MinMax::Min);\n         }\n     }"}, {"sha": "6c21ff0f6c22c6f3c195ba12578cbe60f928bdc9", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1708,7 +1708,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n         match expr.kind {\n             hir::ExprKind::Call(func, args) => {\n-                from_iter_instead_of_collect::check(cx, expr, args, &func.kind);\n+                from_iter_instead_of_collect::check(cx, expr, args, func);\n             },\n             hir::ExprKind::MethodCall(method_call, ref method_span, args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);"}, {"sha": "1a5894e48d14c5ac1c935dae2231e086f248c78c", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_def_path, match_qpath, paths};\n+use clippy_utils::{is_expr_path_def_path, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -12,8 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n     if_chain! {\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n-        if let hir::ExprKind::Path(ref path) = callee.kind;\n-        if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n+        if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n         if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint("}, {"sha": "b61c4ffe9b3aebb5abd0a4d39ec94abf1d75e830", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -61,8 +61,6 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n                     }\n                     return (true, false);\n                 }\n-                // We don't know. It might do anything.\n-                return (true, true);\n             }\n             (true, true)\n         },"}, {"sha": "0b0cd9be46cf41f02614a99d6a4839aac9c235e3", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use crate::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n-    last_path_segment, match_qpath, unsext, SpanlessEq,\n+    expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n+    iter_input_pats, last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -564,13 +564,13 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n                 }\n             )\n         },\n-        ExprKind::Call(path, v) if v.len() == 1 => {\n-            if let ExprKind::Path(ref path) = path.kind {\n-                if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n-                } else {\n-                    return;\n-                }\n+        ExprKind::Call(path, [arg]) => {\n+            if expr_path_res(cx, path)\n+                .opt_def_id()\n+                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n+                .is_some()\n+            {\n+                (cx.typeck_results().expr_ty(arg), snippet(cx, arg.span, \"..\"))\n             } else {\n                 return;\n             }"}, {"sha": "b0674f90678362d0248ac4def6f5fa738e50a83d", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_the\n use clippy_utils::ptr::get_spans;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{is_type_diagnostic_item, match_type, walk_ptrs_hir_ty};\n-use clippy_utils::{is_allowed, match_def_path, paths};\n+use clippy_utils::{expr_path_res, is_allowed, match_any_def_paths, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -417,14 +417,11 @@ fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability,\n }\n \n fn is_null_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let ExprKind::Call(path, []) = expr.kind;\n-        if let ExprKind::Path(ref qpath) = path.kind;\n-        if let Some(fn_def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-        then {\n-            match_def_path(cx, fn_def_id, &paths::PTR_NULL) || match_def_path(cx, fn_def_id, &paths::PTR_NULL_MUT)\n-        } else {\n-            false\n-        }\n+    if let ExprKind::Call(pathexp, []) = expr.kind {\n+        expr_path_res(cx, pathexp).opt_def_id().map_or(false, |id| {\n+            match_any_def_paths(cx, id, &[&paths::PTR_NULL, &paths::PTR_NULL_MUT]).is_some()\n+        })\n+    } else {\n+        false\n     }\n }"}, {"sha": "30bee21390068eadf73ac702b08a9565beafcb36", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -3,10 +3,10 @@ use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, match_qpath};\n+use clippy_utils::{eq_expr_value, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -101,15 +101,14 @@ impl QuestionMark {\n             if Self::is_option(cx, subject);\n \n             if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n-            if match_qpath(path1, &[\"Some\"]);\n-            if let PatKind::Binding(annot, _, bind, _) = &fields[0].kind;\n+            if is_lang_ctor(cx, path1, OptionSome);\n+            if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n             if let ExprKind::Block(block, None) = &arms[0].body.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n-            if let ExprKind::Path(path) = &trailing_expr.kind;\n-            if match_qpath(path, &[&bind.as_str()]);\n+            if path_to_local_id(trailing_expr, bind_id);\n \n             if let PatKind::Wild = arms[1].pat.kind;\n             if Self::expression_returns_none(cx, arms[1].body);"}, {"sha": "b565c77aaecff808131af09b3c81dd23ca69197c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{fn_def_id, in_macro, match_qpath};\n+use clippy_utils::{fn_def_id, in_macro, path_to_local_id};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n@@ -84,9 +84,8 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n             if local.ty.is_none();\n             if cx.tcx.hir().attrs(local.hir_id).is_empty();\n             if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if let PatKind::Binding(_, local_id, _, _) = local.pat.kind;\n+            if path_to_local_id(retexpr, local_id);\n             if !last_statement_borrows(cx, initexpr);\n             if !in_external_macro(cx.sess(), initexpr.span);\n             if !in_external_macro(cx.sess(), retexpr.span);"}, {"sha": "191781be000cf8177919236a38389dafac24c3df", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_enclosing_block, match_qpath, SpanlessEq};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_enclosing_block, is_expr_path_def_path, path_to_local, path_to_local_id, paths, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -9,7 +10,7 @@ use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath,\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks slow zero-filled vector initialization\n@@ -46,8 +47,8 @@ declare_lint_pass!(SlowVectorInit => [SLOW_VECTOR_INITIALIZATION]);\n /// assigned to a variable. For example, `let mut vec = Vec::with_capacity(0)` or\n /// `vec = Vec::with_capacity(0)`\n struct VecAllocation<'tcx> {\n-    /// Symbol of the local variable name\n-    variable_name: Symbol,\n+    /// HirId of the variable\n+    local_id: HirId,\n \n     /// Reference to the expression which allocates the vector\n     allocation_expr: &'tcx Expr<'tcx>,\n@@ -72,16 +73,15 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         if_chain! {\n             if let ExprKind::Assign(left, right, _) = expr.kind;\n \n-            // Extract variable name\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n-            if let Some(variable_name) = path.segments.get(0);\n+            // Extract variable\n+            if let Some(local_id) = path_to_local(left);\n \n             // Extract len argument\n-            if let Some(len_arg) = Self::is_vec_with_capacity(right);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(cx, right);\n \n             then {\n                 let vi = VecAllocation {\n-                    variable_name: variable_name.ident.name,\n+                    local_id,\n                     allocation_expr: right,\n                     len_expr: len_arg,\n                 };\n@@ -95,13 +95,13 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(local) = stmt.kind;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.kind;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, local_id, _, None) = local.pat.kind;\n             if let Some(init) = local.init;\n-            if let Some(len_arg) = Self::is_vec_with_capacity(init);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(cx, init);\n \n             then {\n                 let vi = VecAllocation {\n-                    variable_name: variable_name.name,\n+                    local_id,\n                     allocation_expr: init,\n                     len_expr: len_arg,\n                 };\n@@ -115,19 +115,18 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n impl SlowVectorInit {\n     /// Checks if the given expression is `Vec::with_capacity(..)`. It will return the expression\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n-    fn is_vec_with_capacity<'tcx>(expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_vec_with_capacity<'tcx>(cx: &LateContext<'_>, expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         if_chain! {\n-            if let ExprKind::Call(func, args) = expr.kind;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n-            if args.len() == 1;\n-\n+            if let ExprKind::Call(func, [arg]) = expr.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, name)) = func.kind;\n+            if name.ident.as_str() == \"with_capacity\";\n+            if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::vec_type);\n             then {\n-                return Some(&args[0]);\n+                Some(arg)\n+            } else {\n+                None\n             }\n         }\n-\n-        None\n     }\n \n     /// Search initialization for the given vector\n@@ -208,11 +207,9 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if let ExprKind::MethodCall(path, _, [self_arg, extend_arg], _) = expr.kind;\n+            if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(extend);\n-            if let Some(extend_arg) = args.get(1);\n             if self.is_repeat_take(extend_arg);\n \n             then {\n@@ -225,11 +222,9 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n-            if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if let ExprKind::MethodCall(path, _, [self_arg, len_arg, fill_arg], _) = expr.kind;\n+            if path_to_local_id(self_arg, self.vec_alloc.local_id);\n             if path.ident.name == sym!(resize);\n-            if let (Some(len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n             if let ExprKind::Lit(ref lit) = fill_arg.kind;\n@@ -252,7 +247,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n \n             // Check that take is applied to `repeat(0)`\n             if let Some(repeat_expr) = take_args.get(0);\n-            if Self::is_repeat_zero(repeat_expr);\n+            if self.is_repeat_zero(repeat_expr);\n \n             // Check that len expression is equals to `with_capacity` expression\n             if let Some(len_arg) = take_args.get(1);\n@@ -267,21 +262,19 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Returns `true` if given expression is `repeat(0)`\n-    fn is_repeat_zero(expr: &Expr<'_>) -> bool {\n+    fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::Call(fn_expr, repeat_args) = expr.kind;\n-            if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n-            if match_qpath(qpath_repeat, &[\"repeat\"]);\n-            if let Some(repeat_arg) = repeat_args.get(0);\n+            if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n+            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n             if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n             then {\n-                return true\n+                true\n+            } else {\n+                false\n             }\n         }\n-\n-        false\n     }\n }\n "}, {"sha": "888ecab10461ac936317191e6fa41927e655c504", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n use crate::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_def_path, paths};\n+use clippy_utils::{is_expr_path_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_hir::{Expr, ExprKind};\n@@ -37,18 +37,15 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(func, args) = expr.kind;\n-            if args.len() == 1;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if let Some(func_def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n-            if match_def_path(cx, func_def_id, &paths::TRANSMUTE);\n-            then {\n+            if let ExprKind::Call(func, [arg]) = expr.kind;\n+            if is_expr_path_def_path(cx, func, &paths::TRANSMUTE);\n \n+            then {\n                 // Catching transmute over constants that resolve to `null`.\n                 let mut const_eval_context = constant_context(cx, cx.typeck_results());\n                 if_chain! {\n-                    if let ExprKind::Path(ref _qpath) = args[0].kind;\n-                    let x = const_eval_context.expr(&args[0]);\n+                    if let ExprKind::Path(ref _qpath) = arg.kind;\n+                    let x = const_eval_context.expr(arg);\n                     if let Some(Constant::RawPtr(0)) = x;\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n@@ -58,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(0 as *const i32)`\n                 if_chain! {\n-                    if let ExprKind::Cast(inner_expr, _cast_ty) = args[0].kind;\n+                    if let ExprKind::Cast(inner_expr, _cast_ty) = arg.kind;\n                     if let ExprKind::Lit(ref lit) = inner_expr.kind;\n                     if let LitKind::Int(0, _) = lit.node;\n                     then {\n@@ -69,10 +66,8 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(std::ptr::null::<i32>())`\n                 if_chain! {\n-                    if let ExprKind::Call(func1, []) = args[0].kind;\n-                    if let ExprKind::Path(ref path1) = func1.kind;\n-                    if let Some(func1_def_id) = cx.qpath_res(path1, func1.hir_id).opt_def_id();\n-                    if match_def_path(cx, func1_def_id, &paths::PTR_NULL);\n+                    if let ExprKind::Call(func1, []) = arg.kind;\n+                    if is_expr_path_def_path(cx, func1, &paths::PTR_NULL);\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n                     }"}, {"sha": "bdeff035e5ec99ab30dd2e68a90c06a2eb4033a7", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{match_path, paths};\n+use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n                     _ => None,\n                 });\n                 then {\n-                    if is_any_trait(inner) {\n+                    if is_any_trait(cx, inner) {\n                         // Ignore `Box<Any>` types; see issue #1884 for details.\n                         return false;\n                     }\n@@ -84,13 +84,14 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n }\n \n // Returns true if given type is `Any` trait.\n-fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n+fn is_any_trait(cx: &LateContext<'_>, t: &hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let TyKind::TraitObject(traits, ..) = t.kind;\n         if !traits.is_empty();\n+        if let Some(trait_did) = traits[0].trait_ref.trait_def_id();\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_path(traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        if match_def_path(cx, trait_did, &paths::ANY_TRAIT);\n         then {\n             return true;\n         }"}, {"sha": "f2f1410aed7421343bd812172c02f40d25167ca4", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -104,22 +104,20 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 // Check if a function call.\n-                if let ExprKind::Call(func, args) = ret_expr.kind;\n-                // Get the Path of the function call.\n-                if let ExprKind::Path(ref qpath) = func.kind;\n+                if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type.\n+                if let ExprKind::Path(qpath) = &func.kind;\n                 if is_lang_ctor(cx, qpath, lang_item);\n-                if args.len() == 1;\n                 // Make sure the function argument does not contain a return expression.\n-                if !contains_return(&args[0]);\n+                if !contains_return(arg);\n                 then {\n                     suggs.push(\n                         (\n                             ret_expr.span,\n                             if inner_type.is_unit() {\n                                 \"\".to_string()\n                             } else {\n-                                snippet(cx, args[0].span.source_callsite(), \"..\").to_string()\n+                                snippet(cx, arg.span.source_callsite(), \"..\").to_string()\n                             }\n                         )\n                     );"}, {"sha": "3d3d0e19d26224190bdd8e0546ae7e31599fb9bf", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -3,7 +3,8 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sug\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq,\n+    is_else_clause, is_expn_of, is_expr_path_def_path, match_def_path, method_calls, path_to_res, paths, run_lints,\n+    SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n@@ -578,8 +579,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n \n         if_chain! {\n             if let ExprKind::Call(func, and_then_args) = expr.kind;\n-            if let ExprKind::Path(ref path) = func.kind;\n-            if match_qpath(path, &[\"span_lint_and_then\"]);\n+            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n@@ -761,8 +761,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n         if_chain! {\n             // Check if this is a call to utils::match_type()\n             if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n-            if match_qpath(fn_qpath, &[\"utils\", \"match_type\"]);\n+            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n@@ -771,16 +770,17 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n             if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n             then {\n+                // TODO: check paths constants from external crates.\n                 let cx_snippet = snippet(cx, context.span, \"_\");\n                 let ty_snippet = snippet(cx, ty.span, \"_\");\n \n                 span_lint_and_sugg(\n                     cx,\n                     MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n                     expr.span,\n-                    \"usage of `utils::match_type()` on a type diagnostic item\",\n+                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n                     \"try\",\n-                    format!(\"utils::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n+                    format!(\"clippy_utils::ty::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "4a523520a4350fda3411b6ea807950ab07904e75", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -397,6 +397,29 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     }\n }\n \n+/// If the expression is a path, resolve it. Otherwise, return `Res::Err`.\n+pub fn expr_path_res(cx: &LateContext<'_>, expr: &Expr<'_>) -> Res {\n+    if let ExprKind::Path(p) = &expr.kind {\n+        cx.qpath_res(p, expr.hir_id)\n+    } else {\n+        Res::Err\n+    }\n+}\n+\n+/// Resolves the path to a `DefId` and checks if it matches the given path.\n+pub fn is_qpath_def_path(cx: &LateContext<'_>, path: &QPath<'_>, hir_id: HirId, segments: &[&str]) -> bool {\n+    cx.qpath_res(path, hir_id)\n+        .opt_def_id()\n+        .map_or(false, |id| match_def_path(cx, id, segments))\n+}\n+\n+/// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n+pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n+    expr_path_res(cx, expr)\n+        .opt_def_id()\n+        .map_or(false, |id| match_def_path(cx, id, segments))\n+}\n+\n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n /// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n /// `QPath::Resolved.1.res.opt_def_id()`.\n@@ -425,20 +448,6 @@ pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name.as_str() == *b)\n }\n \n-/// Matches a `Path` against a slice of segment string literals, e.g.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n /// If the expression is a path to a local, returns the canonical `HirId` of the local.\n pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n@@ -1148,29 +1157,47 @@ pub fn match_function_call<'tcx>(\n     None\n }\n \n+/// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n+/// any.\n+pub fn match_any_def_paths(cx: &LateContext<'_>, did: DefId, paths: &[&[&str]]) -> Option<usize> {\n+    let search_path = cx.get_def_path(did);\n+    paths\n+        .iter()\n+        .position(|p| p.iter().map(|x| Symbol::intern(x)).eq(search_path.iter().cloned()))\n+}\n+\n+/// Checks if the given `DefId` matches the path.\n pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n-    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n-    // accepts only that. We should probably move to Symbols in Clippy as well.\n-    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n-    cx.match_def_path(did, &syms)\n+    // We should probably move to Symbols in Clippy as well rather than interning every time.\n+    let path = cx.get_def_path(did);\n+    syms.iter().map(|x| Symbol::intern(x)).eq(path.iter().cloned())\n }\n \n-pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n-    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n-        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n+pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Call(func, [arg]) = expr.kind {\n+        expr_path_res(cx, func)\n+            .opt_def_id()\n+            .map_or(false, |id| match_panic_def_id(cx, id))\n+            .then(|| arg)\n+    } else {\n+        None\n+    }\n }\n \n pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_def_path(cx, did, &paths::BEGIN_PANIC)\n-        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANIC_ANY)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n+    match_any_def_paths(\n+        cx,\n+        did,\n+        &[\n+            &paths::BEGIN_PANIC,\n+            &paths::BEGIN_PANIC_FMT,\n+            &paths::PANIC_ANY,\n+            &paths::PANICKING_PANIC,\n+            &paths::PANICKING_PANIC_FMT,\n+            &paths::PANICKING_PANIC_STR,\n+        ],\n+    )\n+    .is_some()\n }\n \n /// Returns the list of condition expressions and the list of blocks in a"}, {"sha": "21011dbded6a2fd5ad23b6a319b1e6a16d391710", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -4,7 +4,7 @@\n //! Whenever possible, please consider diagnostic items over hardcoded paths.\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n-pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n+pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n@@ -42,6 +42,8 @@ pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n+pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n+pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n@@ -58,8 +60,9 @@ pub const INTO: [&str; 3] = [\"core\", \"convert\", \"Into\"];\n pub const INTO_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\"];\n pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n-pub const IPADDR_V4: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V4\"];\n-pub const IPADDR_V6: [&str; 4] = [\"std\", \"net\", \"IpAddr\", \"V6\"];\n+pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n+pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n+pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n@@ -126,7 +129,6 @@ pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n-pub const REPEAT: [&str; 3] = [\"core\", \"iter\", \"repeat\"];\n pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n@@ -140,7 +142,7 @@ pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n-pub const STD_CONVERT_IDENTITY: [&str; 3] = [\"std\", \"convert\", \"identity\"];\n+pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];"}, {"sha": "50f0d724016ff1b33039de9ae471d68b04fc0ced", "filename": "doc/adding_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -625,7 +625,7 @@ in the following steps:\n Here are some pointers to things you are likely going to need for every lint:\n \n * [Clippy utils][utils] - Various helper functions. Maybe the function you need\n-  is already in here (`implements_trait`, `match_path`, `snippet`, etc)\n+  is already in here (`implements_trait`, `match_def_path`, `snippet`, etc)\n * [Clippy diagnostics][diagnostics]\n * [The `if_chain` macro][if_chain]\n * [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]"}, {"sha": "7764cc8da786115eb69d7de82ea2216decd6a1d1", "filename": "tests/ui-internal/collapsible_span_lint_calls.fixed", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -2,58 +2,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_ast;\n extern crate rustc_errors;\n extern crate rustc_lint;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use rustc_ast::ast::Expr;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-#[allow(unused_variables)]\n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n-{\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_help<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    option_span: Option<Span>,\n-    help: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_note<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    note_span: Option<Span>,\n-    note: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_sugg<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    help: &str,\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-}\n \n declare_tool_lint! {\n     pub clippy::TEST_LINT,"}, {"sha": "bdd296db8320bac83ebab1971a9c0363c194dac5", "filename": "tests/ui-internal/collapsible_span_lint_calls.rs", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -2,58 +2,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_ast;\n extern crate rustc_errors;\n extern crate rustc_lint;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use rustc_ast::ast::Expr;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint, LintContext};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-#[allow(unused_variables)]\n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n-{\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_help<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    option_span: Option<Span>,\n-    help: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_note<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    span: Span,\n-    msg: &str,\n-    note_span: Option<Span>,\n-    note: &str,\n-) {\n-}\n-\n-#[allow(unused_variables)]\n-fn span_lint_and_sugg<'a, T: LintContext>(\n-    cx: &'a T,\n-    lint: &'static Lint,\n-    sp: Span,\n-    msg: &str,\n-    help: &str,\n-    sugg: String,\n-    applicability: Applicability,\n-) {\n-}\n \n declare_tool_lint! {\n     pub clippy::TEST_LINT,"}, {"sha": "0632b038577375f3a1c2ada471554bd5cb7303b8", "filename": "tests/ui-internal/collapsible_span_lint_calls.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:75:9\n+  --> $DIR/collapsible_span_lint_calls.rs:35:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_suggestion(expr.span, help_msg, sugg.to_string(), Applicability::MachineApplicable);\n@@ -14,31 +14,31 @@ LL | #![deny(clippy::internal)]\n    = note: `#[deny(clippy::collapsible_span_lint_calls)]` implied by `#[deny(clippy::internal)]`\n \n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:78:9\n+  --> $DIR/collapsible_span_lint_calls.rs:38:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_help(expr.span, help_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg)`\n \n error: this call is collapsible\n-  --> $DIR/collapsible_span_lint_calls.rs:81:9\n+  --> $DIR/collapsible_span_lint_calls.rs:41:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.help(help_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg)`\n \n error: this call is collspible\n-  --> $DIR/collapsible_span_lint_calls.rs:84:9\n+  --> $DIR/collapsible_span_lint_calls.rs:44:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_note(expr.span, note_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg)`\n \n error: this call is collspible\n-  --> $DIR/collapsible_span_lint_calls.rs:87:9\n+  --> $DIR/collapsible_span_lint_calls.rs:47:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.note(note_msg);"}, {"sha": "063f0c6460c5ee92053ba824d69e06b67d62bc23", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,29 +1,18 @@\n #![deny(clippy::internal)]\n #![feature(rustc_private)]\n \n+extern crate clippy_utils;\n extern crate rustc_hir;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+\n #[macro_use]\n extern crate rustc_session;\n+use clippy_utils::{paths, ty::match_type};\n use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Ty;\n \n-mod paths {\n-    pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n-}\n-\n-mod utils {\n-    use super::*;\n-\n-    pub fn match_type(_cx: &LateContext<'_>, _ty: Ty<'_>, _path: &[&str]) -> bool {\n-        false\n-    }\n-}\n-\n-use utils::match_type;\n-\n declare_lint! {\n     pub TEST_LINT,\n     Warn,\n@@ -38,12 +27,12 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n         let ty = cx.typeck_results().expr_ty(expr);\n \n-        let _ = match_type(cx, ty, &paths::VEC);\n+        let _ = match_type(cx, ty, &paths::VEC); // FIXME: Doesn't lint external paths\n         let _ = match_type(cx, ty, &OPTION);\n         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n \n         let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n-        let _ = utils::match_type(cx, ty, rc_path);\n+        let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n     }\n }\n "}, {"sha": "714729605658cca3aa0110c9ee311b7beb637861", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,8 +1,8 @@\n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:41:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:31:17\n    |\n-LL |         let _ = match_type(cx, ty, &paths::VEC);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::vec_type)`\n+LL |         let _ = match_type(cx, ty, &OPTION);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::option_type)`\n    |\n note: the lint level is defined here\n   --> $DIR/match_type_on_diag_item.rs:1:9\n@@ -11,23 +11,17 @@ LL | #![deny(clippy::internal)]\n    |         ^^^^^^^^^^^^^^^^\n    = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n \n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:42:17\n-   |\n-LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::option_type)`\n-\n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:43:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:32:17\n    |\n LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::result_type)`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::result_type)`\n \n-error: usage of `utils::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:46:17\n+error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:35:17\n    |\n-LL |         let _ = utils::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::Rc)`\n+LL |         let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Rc)`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "6c7e2b854dc14b3379cc8b6448662861d4a88d02", "filename": "tests/ui/repl_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Frepl_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Frepl_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,5 +1,5 @@\n-#![allow(deprecated, invalid_value)]\n-#![warn(clippy::all)]\n+#![allow(deprecated, invalid_value, clippy::uninit_assumed_init)]\n+#![warn(clippy::mem_replace_with_uninit)]\n \n use std::mem;\n "}, {"sha": "1ed3883c1f06059285c858c40323eec9b069de77", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -1,6 +1,6 @@\n #![feature(stmt_expr_attributes)]\n \n-use std::mem::MaybeUninit;\n+use std::mem::{self, MaybeUninit};\n \n fn main() {\n     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n@@ -19,4 +19,7 @@ fn main() {\n \n     // This is OK, because all constitutent types are uninit-compatible.\n     let _: (MaybeUninit<usize>, [MaybeUninit<bool>; 2]) = unsafe { MaybeUninit::uninit().assume_init() };\n+\n+    // Was a false negative.\n+    let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n }"}, {"sha": "85b64a8419ab021bd36585ebde6e9431e84301e6", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6c5d8d599070bacad800ac7014fa3a6f140eadc/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=f6c5d8d599070bacad800ac7014fa3a6f140eadc", "patch": "@@ -12,5 +12,11 @@ error: this call for this type may be undefined behavior\n LL |     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: this call for this type may be undefined behavior\n+  --> $DIR/uninit.rs:24:29\n+   |\n+LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}]}