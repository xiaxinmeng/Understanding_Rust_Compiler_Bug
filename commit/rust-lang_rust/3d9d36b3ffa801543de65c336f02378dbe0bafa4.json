{"sha": "3d9d36b3ffa801543de65c336f02378dbe0bafa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOWQzNmIzZmZhODAxNTQzZGU2NWMzMzZmMDIzNzhkYmUwYmFmYTQ=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-17T23:02:26Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-08-05T14:16:27Z"}, "message": "Got rid of concept of 'principal trait' in more places in codebase.", "tree": {"sha": "6b9ecdcf42497983d3348daeb3630419d995e01a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b9ecdcf42497983d3348daeb3630419d995e01a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9d36b3ffa801543de65c336f02378dbe0bafa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9d36b3ffa801543de65c336f02378dbe0bafa4", "html_url": "https://github.com/rust-lang/rust/commit/3d9d36b3ffa801543de65c336f02378dbe0bafa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9d36b3ffa801543de65c336f02378dbe0bafa4/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f9ca24f55cc74159d00c4691c464ced5d51a669", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9ca24f55cc74159d00c4691c464ced5d51a669", "html_url": "https://github.com/rust-lang/rust/commit/8f9ca24f55cc74159d00c4691c464ced5d51a669"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "4040c0166d85900f52be61adcd30f6e5a23b4d75", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3d9d36b3ffa801543de65c336f02378dbe0bafa4", "patch": "@@ -1050,10 +1050,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n-            let (principal, bounds) = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n-            if self.visit_trait(*principal.skip_binder()) {\n-                return;\n+            let bounds = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n+\n+            for (trait_predicate, _) in bounds.trait_bounds {\n+                if self.visit_trait(*trait_predicate.skip_binder()) {\n+                    return;\n+                }\n             }\n+\n             for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty)"}, {"sha": "64c0011a7b39c9ec7d2d29cddc640f4e8daa8345", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3d9d36b3ffa801543de65c336f02378dbe0bafa4", "patch": "@@ -775,11 +775,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// The given trait-ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n+        span: Span,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n-    {\n+    ) -> Option<Vec<Span>> {\n         let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -794,6 +794,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n+        bounds.trait_bounds.push((poly_trait_ref, span));\n+\n         let mut dup_bindings = FxHashMap::default();\n         for binding in &assoc_bindings {\n             // Specify type to assert that error was already reported in `Err` case.\n@@ -811,7 +813,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n                trait_ref, bounds, poly_trait_ref);\n-        (poly_trait_ref, potential_assoc_types)\n+        potential_assoc_types\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -836,10 +838,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        bounds: &mut Bounds<'tcx>\n-    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n-    {\n-        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty, bounds, false)\n+        bounds: &mut Bounds<'tcx>,\n+    ) -> Option<Vec<Span>> {\n+        self.instantiate_poly_trait_ref_inner(\n+            &poly_trait_ref.trait_ref,\n+            poly_trait_ref.span,\n+            self_ty,\n+            bounds,\n+            false,\n+        )\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n@@ -983,12 +990,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         for bound in trait_bounds {\n-            let (poly_trait_ref, _) = self.instantiate_poly_trait_ref(\n+            let _ = self.instantiate_poly_trait_ref(\n                 bound,\n                 param_ty,\n                 bounds,\n             );\n-            bounds.trait_bounds.push((poly_trait_ref, bound.span))\n         }\n \n         bounds.region_bounds.extend(region_bounds\n@@ -1172,11 +1178,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n-                self.add_bounds(\n-                    param_ty,\n-                    ast_bounds,\n-                    bounds,\n-                );\n+                self.add_bounds(param_ty, ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1216,25 +1218,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n-        // FIXME: we want to avoid collecting into a `Vec` here, but simply cloning the iterator is\n-        // not straightforward due to the borrow checker.\n-        let bound_trait_refs: Vec<_> = trait_bounds\n-            .iter()\n-            .rev()\n-            .map(|trait_bound| {\n-                let (trait_ref, cur_potential_assoc_types) = self.instantiate_poly_trait_ref(\n-                    trait_bound,\n-                    dummy_self,\n-                    &mut bounds,\n-                );\n-                potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n-                (trait_ref, trait_bound.span)\n-            })\n-            .collect();\n+        for trait_bound in trait_bounds.iter().rev() {\n+            let cur_potential_assoc_types = self.instantiate_poly_trait_ref(\n+                trait_bound,\n+                dummy_self,\n+                &mut bounds,\n+            );\n+            potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n+        }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n         // is used and no 'maybe' bounds are used.\n-        let expanded_traits = traits::expand_trait_aliases(tcx, bound_trait_refs.iter().cloned());\n+        let expanded_traits =\n+            traits::expand_trait_aliases(tcx, bounds.trait_bounds.iter().cloned());\n         let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n             expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n         if regular_traits.len() > 1 {\n@@ -1276,7 +1272,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        let regular_traits_refs = bound_trait_refs\n+        let regular_traits_refs = bounds.trait_bounds\n             .into_iter()\n             .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()))\n             .map(|(trait_ref, _)| trait_ref);"}, {"sha": "4056d6f974c5d9b509a0aa5776f9e0a124743bec", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3d9d36b3ffa801543de65c336f02378dbe0bafa4", "patch": "@@ -49,8 +49,6 @@ use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n use errors::{Applicability, DiagnosticId};\n \n-use std::iter;\n-\n struct OnlySelfBounds(bool);\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -2191,15 +2189,12 @@ fn explicit_predicates_of(\n                     match bound {\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut bounds = Bounds::default();\n-\n-                            let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n+                            let _ = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n                                 &mut bounds,\n                             );\n-\n-                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n@@ -2301,10 +2296,13 @@ fn predicates_from_bound<'tcx>(\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut bounds = Bounds::default();\n-            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut bounds);\n-            iter::once((pred.to_predicate(), tr.span))\n-                .chain(bounds.predicates(astconv.tcx(), param_ty))\n-                .collect()\n+            let _ = astconv.instantiate_poly_trait_ref(\n+                tr,\n+                param_ty,\n+                &mut bounds,\n+                false,\n+            );\n+            bounds.predicates(astconv.tcx(), param_ty)\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);"}, {"sha": "9d9a9d9b559e47bcdbac5321819f7edd5cacec0a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9d36b3ffa801543de65c336f02378dbe0bafa4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3d9d36b3ffa801543de65c336f02378dbe0bafa4", "patch": "@@ -108,7 +108,7 @@ use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::util;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use util::common::time;\n \n use std::iter;\n@@ -375,19 +375,19 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n pub fn hir_trait_to_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     hir_trait: &hir::TraitRef,\n-) -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n+) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut bounds = Bounds::default();\n-    let (principal, _) = AstConv::instantiate_poly_trait_ref_inner(\n-        &item_cx, hir_trait, tcx.types.err, &mut bounds, true\n+    let _ = AstConv::instantiate_poly_trait_ref_inner(\n+        &item_cx, hir_trait, DUMMY_SP, tcx.types.err, &mut bounds, true\n     );\n \n-    (principal, bounds)\n+    bounds\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}]}