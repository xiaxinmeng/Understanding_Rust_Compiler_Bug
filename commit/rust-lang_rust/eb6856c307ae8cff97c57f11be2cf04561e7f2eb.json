{"sha": "eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNjg1NmMzMDdhZThjZmY5N2M1N2YxMWJlMmNmMDQ1NjFlN2YyZWI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-15T17:28:46Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-18T20:56:19Z"}, "message": "Fixing rustdoc stage1.\n\nSee #13983 and #14000.\n\nFix was originally authored by alexcrichton and then rebased a couple\ntimes by pnkfelix, most recently atop PR 13954.\n\n----\n\nRegarding the change to librustdoc/lib.rs, to do `map_err` before\nunwrapping a `TqskResult`: I do not understand how master is passing\nwithout this change or something like it, since `Box<Any:Send>` does\nnot implement `Show`.  (Is this something that is only a problem for\nthe snapshot stage0 compiler?)  Still, the change I have put in here\n(which was added as part of a rebase after alex's review) seems\nharmless to me to apply to rustdoc at all stages, since a call to\n`unwrap` is just going to `fail!` on the err case anyway.", "tree": {"sha": "9c54337e46e8de105349df1db874a3ed5370198f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c54337e46e8de105349df1db874a3ed5370198f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "html_url": "https://github.com/rust-lang/rust/commit/eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11", "html_url": "https://github.com/rust-lang/rust/commit/63287eef27b1a23a1fc24a7b4453eb7bd8ec1f11"}], "stats": {"total": 161, "additions": 99, "deletions": 62}, "files": [{"sha": "6b273c2d4634593845753be052c9e03a06b09e07", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "patch": "@@ -11,54 +11,31 @@\n use std::os;\n use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n+use std::unstable::dynamic_lib::DynamicLibrary;\n \n-#[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n-    let env = os::env();\n+    let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};\n+    let aux_path = prog + \".libaux\";\n \n-    // Make sure we include the aux directory in the path\n-    assert!(prog.ends_with(\".exe\"));\n-    let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n+    // Need to be sure to put both the lib_path and the aux path in the dylib\n+    // search path for the child.\n+    let mut path = DynamicLibrary::search_path();\n+    path.insert(0, Path::new(aux_path));\n+    path.insert(0, Path::new(lib_path));\n \n-    let mut new_env: Vec<_> = env.move_iter().map(|(k, v)| {\n-        let new_v = if \"PATH\" == k {\n-            format_strbuf!(\"{};{};{}\", v, lib_path, aux_path)\n-        } else {\n-            v.to_strbuf()\n-        };\n-        (k.to_strbuf(), new_v)\n-    }).collect();\n-    if prog.ends_with(\"rustc.exe\") {\n-        new_env.push((\"RUST_THREADS\".to_strbuf(), \"1\".to_strbuf()));\n+    // Remove the previous dylib search path var\n+    let var = DynamicLibrary::envvar();\n+    let mut env: Vec<(StrBuf,StrBuf)> =\n+        os::env().move_iter().map(|(a,b)|(a.to_strbuf(), b.to_strbuf())).collect();\n+    match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n+        Some(i) => { env.remove(i); }\n+        None => {}\n     }\n-    return new_env;\n-}\n \n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf,StrBuf)> {\n-    // Make sure we include the aux directory in the path\n-    let aux_path = prog + \".libaux\";\n-\n-    let mut env: Vec<(StrBuf,StrBuf)> =\n-        os::env().move_iter()\n-                 .map(|(ref k, ref v)| (k.to_strbuf(), v.to_strbuf()))\n-                 .collect();\n-    let var = if cfg!(target_os = \"macos\") {\n-        \"DYLD_LIBRARY_PATH\"\n-    } else {\n-        \"LD_LIBRARY_PATH\"\n-    };\n-    let prev = match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n-        Some(i) => env.remove(i).unwrap().val1(),\n-        None => \"\".to_strbuf(),\n-    };\n-    env.push((var.to_strbuf(), if prev.is_empty() {\n-        format_strbuf!(\"{}:{}\", lib_path, aux_path)\n-    } else {\n-        format_strbuf!(\"{}:{}:{}\", lib_path, aux_path, prev)\n-    }));\n+    // Add the new dylib search path var\n+    let newpath = DynamicLibrary::create_path(path.as_slice());\n+    env.push((var.to_strbuf(),\n+              str::from_utf8(newpath.as_slice()).unwrap().to_strbuf()));\n     return env;\n }\n "}, {"sha": "238b23d6c5a13cff8a9b4e33d0c40cdecd68dab3", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "patch": "@@ -136,7 +136,7 @@ impl<'a> FileSearch<'a> {\n \n     pub fn add_dylib_search_paths(&self) {\n         self.for_each_lib_search_path(|lib_search_path| {\n-            DynamicLibrary::add_search_path(lib_search_path);\n+            DynamicLibrary::prepend_search_path(lib_search_path);\n             FileDoesntMatch\n         })\n     }"}, {"sha": "48db910fc3908eddf5121f6870c6fff9aa8708ef", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "patch": "@@ -284,7 +284,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n         core::run_core(libs.move_iter().map(|x| x.clone()).collect(),\n                        cfgs.move_iter().map(|x| x.to_strbuf()).collect(),\n                        &cr)\n-    }).unwrap();\n+    }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n     info!(\"finished with rustc\");\n     analysiskey.replace(Some(analysis));\n "}, {"sha": "6a07b7a906e3dd483f7fef8bde7234f4b386dd4f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "patch": "@@ -15,6 +15,7 @@ use std::io::{Command, TempDir};\n use std::os;\n use std::str;\n use std::strbuf::StrBuf;\n+use std::unstable::dynamic_lib::DynamicLibrary;\n \n use collections::{HashSet, HashMap};\n use testing;\n@@ -150,12 +151,37 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());\n     let cfg = config::build_configuration(&sess);\n+    let libdir = sess.target_filesearch().get_lib_path();\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n     if no_run { return }\n \n     // Run the code!\n-    match Command::new(outdir.path().join(\"rust_out\")).output() {\n+    //\n+    // We're careful to prepend the *target* dylib search path to the child's\n+    // environment to ensure that the target loads the right libraries at\n+    // runtime. It would be a sad day if the *host* libraries were loaded as a\n+    // mistake.\n+    let exe = outdir.path().join(\"rust_out\");\n+    let env = {\n+        let mut path = DynamicLibrary::search_path();\n+        path.insert(0, libdir.clone());\n+\n+        // Remove the previous dylib search path var\n+        let var = DynamicLibrary::envvar();\n+        let mut env: Vec<(~str,~str)> = os::env().move_iter().collect();\n+        match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n+            Some(i) => { env.remove(i); }\n+            None => {}\n+        };\n+\n+        // Add the new dylib search path var\n+        let newpath = DynamicLibrary::create_path(path.as_slice());\n+        env.push((var.to_owned(),\n+                  str::from_utf8(newpath.as_slice()).unwrap().to_owned()));\n+        env\n+    };\n+    match Command::new(exe).env(env.as_slice()).output() {\n         Err(e) => fail!(\"couldn't run the test: {}{}\", e,\n                         if e.kind == io::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\""}, {"sha": "d50c63c583247f1d82ae2523d7a37ab8778ad356", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb6856c307ae8cff97c57f11be2cf04561e7f2eb/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=eb6856c307ae8cff97c57f11be2cf04561e7f2eb", "patch": "@@ -16,16 +16,16 @@ A simple wrapper over the platform's dynamic library facilities\n \n */\n \n-\n+use clone::Clone;\n use c_str::ToCStr;\n+use iter::Iterator;\n use mem;\n use ops::*;\n use option::*;\n use os;\n-use path::GenericPath;\n-use path;\n+use path::{Path,GenericPath};\n use result::*;\n-use slice::Vector;\n+use slice::{Vector,ImmutableVector};\n use str;\n use vec::Vec;\n \n@@ -76,22 +76,55 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Appends a path to the system search path for dynamic libraries\n-    pub fn add_search_path(path: &path::Path) {\n-        let (envvar, sep) = if cfg!(windows) {\n-            (\"PATH\", ';' as u8)\n+    /// Prepends a path to this process's search path for dynamic libraries\n+    pub fn prepend_search_path(path: &Path) {\n+        let mut search_path = DynamicLibrary::search_path();\n+        search_path.insert(0, path.clone());\n+        let newval = DynamicLibrary::create_path(search_path.as_slice());\n+        os::setenv(DynamicLibrary::envvar(),\n+                   str::from_utf8(newval.as_slice()).unwrap());\n+    }\n+\n+    /// From a slice of paths, create a new vector which is suitable to be an\n+    /// environment variable for this platforms dylib search path.\n+    pub fn create_path(path: &[Path]) -> Vec<u8> {\n+        let mut newvar = Vec::new();\n+        for (i, path) in path.iter().enumerate() {\n+            if i > 0 { newvar.push(DynamicLibrary::separator()); }\n+            newvar.push_all(path.as_vec());\n+        }\n+        return newvar;\n+    }\n+\n+    /// Returns the environment variable for this process's dynamic library\n+    /// search path\n+    pub fn envvar() -> &'static str {\n+        if cfg!(windows) {\n+            \"PATH\"\n         } else if cfg!(target_os = \"macos\") {\n-            (\"DYLD_LIBRARY_PATH\", ':' as u8)\n+            \"DYLD_LIBRARY_PATH\"\n         } else {\n-            (\"LD_LIBRARY_PATH\", ':' as u8)\n-        };\n-        let mut newenv = Vec::from_slice(path.as_vec());\n-        newenv.push(sep);\n-        match os::getenv_as_bytes(envvar) {\n-            Some(bytes) => newenv.push_all(bytes),\n+            \"LD_LIBRARY_PATH\"\n+        }\n+    }\n+\n+    fn separator() -> u8 {\n+        if cfg!(windows) {';' as u8} else {':' as u8}\n+    }\n+\n+    /// Returns the current search path for dynamic libraries being used by this\n+    /// process\n+    pub fn search_path() -> Vec<Path> {\n+        let mut ret = Vec::new();\n+        match os::getenv_as_bytes(DynamicLibrary::envvar()) {\n+            Some(env) => {\n+                for portion in env.split(|a| *a == DynamicLibrary::separator()) {\n+                    ret.push(Path::new(portion));\n+                }\n+            }\n             None => {}\n         }\n-        os::setenv(envvar, str::from_utf8(newenv.as_slice()).unwrap());\n+        return ret;\n     }\n \n     /// Access the value at the symbol of the dynamic library\n@@ -168,11 +201,12 @@ mod test {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n pub mod dl {\n+    use prelude::*;\n+\n     use c_str::ToCStr;\n     use libc;\n     use ptr;\n     use str;\n-    use result::*;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         filename.with_c_str(|raw_name| {"}]}