{"sha": "b01da7282dc5b71cfe78d4cd54c664bcbb13b393", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWRhNzI4MmRjNWI3MWNmZTc4ZDRjZDU0YzY2NGJjYmIxM2IzOTM=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-28T12:31:57Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-28T14:00:34Z"}, "message": "Don't check(=cache) redirect pages\n\nChecking a redirect page during tree traversal before trying to actually\nfollow the redirect leads to retrieval of the redirect pages source\ninstead.", "tree": {"sha": "c169aa0cbdb2400be87780b616dfbe07978215c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c169aa0cbdb2400be87780b616dfbe07978215c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01da7282dc5b71cfe78d4cd54c664bcbb13b393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01da7282dc5b71cfe78d4cd54c664bcbb13b393", "html_url": "https://github.com/rust-lang/rust/commit/b01da7282dc5b71cfe78d4cd54c664bcbb13b393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01da7282dc5b71cfe78d4cd54c664bcbb13b393/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41916d860179f4715fd0f588c1b2342a223a4186", "url": "https://api.github.com/repos/rust-lang/rust/commits/41916d860179f4715fd0f588c1b2342a223a4186", "html_url": "https://github.com/rust-lang/rust/commit/41916d860179f4715fd0f588c1b2342a223a4186"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "7116cb01d6bb442a89f0c0a201bcf1072cb1147e", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b01da7282dc5b71cfe78d4cd54c664bcbb13b393/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01da7282dc5b71cfe78d4cd54c664bcbb13b393/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=b01da7282dc5b71cfe78d4cd54c664bcbb13b393", "patch": "@@ -35,6 +35,8 @@ use std::collections::hash_map::Entry;\n \n use url::{Url, UrlParser};\n \n+use Redirect::*;\n+\n macro_rules! t {\n     ($e:expr) => (match $e {\n         Ok(e) => e,\n@@ -57,6 +59,12 @@ fn main() {\n pub enum LoadError {\n     IOError(std::io::Error),\n     BrokenRedirect(PathBuf, std::io::Error),\n+    IsRedirect,\n+}\n+\n+enum Redirect {\n+    SkipRedirect,\n+    FromRedirect(bool),\n }\n \n struct FileEntry {\n@@ -156,7 +164,7 @@ fn check(cache: &mut Cache,\n     let mut parser = UrlParser::new();\n     parser.base_url(base);\n \n-    let res = load_file(cache, root, PathBuf::from(file), false, false);\n+    let res = load_file(cache, root, PathBuf::from(file), SkipRedirect);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n         Err(_) => return None,\n@@ -182,7 +190,7 @@ fn check(cache: &mut Cache,\n             if path.is_dir() {\n                 return;\n             }\n-            let res = load_file(cache, root, path.clone(), true, false);\n+            let res = load_file(cache, root, path.clone(), FromRedirect(false));\n             let (pretty_path, contents) = match res {\n                 Ok(res) => res,\n                 Err(LoadError::IOError(err)) => panic!(format!(\"{}\", err)),\n@@ -191,6 +199,7 @@ fn check(cache: &mut Cache,\n                            pretty_file.display(), i + 1, target.display());\n                     return;\n                 }\n+                Err(LoadError::IsRedirect) => unreachable!(),\n             };\n \n             if let Some(ref fragment) = parsed_url.fragment {\n@@ -225,8 +234,7 @@ fn check(cache: &mut Cache,\n fn load_file(cache: &mut Cache,\n              root: &Path,\n              file: PathBuf,\n-             follow_redirects: bool,\n-             is_redirect: bool) -> Result<(PathBuf, String), LoadError> {\n+             redirect: Redirect) -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n     let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n \n@@ -237,7 +245,7 @@ fn load_file(cache: &mut Cache,\n         },\n         Entry::Vacant(entry) => {\n             let mut fp = try!(File::open(file.clone()).map_err(|err| {\n-                if is_redirect {\n+                if let FromRedirect(true) = redirect {\n                     LoadError::BrokenRedirect(file.clone(), err)\n                 } else {\n                     LoadError::IOError(err)\n@@ -246,12 +254,12 @@ fn load_file(cache: &mut Cache,\n             try!(fp.read_to_string(&mut contents)\n                    .map_err(|err| LoadError::IOError(err)));\n \n-            let maybe = if follow_redirects {\n-                maybe_redirect(&contents)\n+            let maybe = maybe_redirect(&contents);\n+            if maybe.is_some() {\n+                if let SkipRedirect = redirect {\n+                    return Err(LoadError::IsRedirect);\n+                }\n             } else {\n-                None\n-            };\n-            if maybe.is_none() {\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n@@ -266,9 +274,8 @@ fn load_file(cache: &mut Cache,\n \n     match maybe_redirect.and_then(|url| url_to_file_path(&parser, &url)) {\n         Some((_, redirect_file)) => {\n-            assert!(follow_redirects);\n             let path = PathBuf::from(redirect_file);\n-            load_file(cache, root, path, follow_redirects, true)\n+            load_file(cache, root, path, FromRedirect(true))\n         }\n         None => Ok((pretty_file, contents))\n     }"}]}