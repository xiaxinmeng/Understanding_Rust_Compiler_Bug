{"sha": "16e18395ce33ca1ebfe60a591fb2f9317a75d822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTE4Mzk1Y2UzM2NhMWViZmU2MGE1OTFmYjJmOTMxN2E3NWQ4MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-10T20:32:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-10T20:32:43Z"}, "message": "Auto merge of #80080 - rylev:qpath-on-struct, r=petrochenkov\n\nAllow qualified paths in struct construction (both expressions and patterns)\n\nFixes #79658", "tree": {"sha": "166a43159b96252a1054b698186e2c55b21d541e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166a43159b96252a1054b698186e2c55b21d541e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e18395ce33ca1ebfe60a591fb2f9317a75d822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e18395ce33ca1ebfe60a591fb2f9317a75d822", "html_url": "https://github.com/rust-lang/rust/commit/16e18395ce33ca1ebfe60a591fb2f9317a75d822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e18395ce33ca1ebfe60a591fb2f9317a75d822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c622840b909428bc77ab67f4f4fb61d03abb65eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c622840b909428bc77ab67f4f4fb61d03abb65eb", "html_url": "https://github.com/rust-lang/rust/commit/c622840b909428bc77ab67f4f4fb61d03abb65eb"}, {"sha": "69363492337fa5280d8242f8b68de9a4b60a8b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/69363492337fa5280d8242f8b68de9a4b60a8b55", "html_url": "https://github.com/rust-lang/rust/commit/69363492337fa5280d8242f8b68de9a4b60a8b55"}], "stats": {"total": 561, "additions": 374, "deletions": 187}, "files": [{"sha": "93d7a597681339e3cfddea236667e67f4a371667", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -623,12 +623,13 @@ impl Pat {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n \n             // Walk into each field of struct.\n-            PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n+            PatKind::Struct(_, _, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n \n             // Sequence of patterns.\n-            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) | PatKind::Or(s) => {\n-                s.iter().for_each(|p| p.walk(it))\n-            }\n+            PatKind::TupleStruct(_, _, s)\n+            | PatKind::Tuple(s)\n+            | PatKind::Slice(s)\n+            | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n \n             // Trivial wrappers over inner patterns.\n             PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n@@ -701,10 +702,10 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, Vec<PatField>, /* recovered */ bool),\n+    Struct(Option<QSelf>, Path, Vec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Path, Vec<P<Pat>>),\n+    TupleStruct(Option<QSelf>, Path, Vec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n@@ -1247,6 +1248,7 @@ pub enum StructRest {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructExpr {\n+    pub qself: Option<QSelf>,\n     pub path: Path,\n     pub fields: Vec<ExprField>,\n     pub rest: StructRest,"}, {"sha": "0b6099fd330dad615198553db46362b523bfe637", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -1139,15 +1139,17 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             visit_opt(sub, |sub| vis.visit_pat(sub));\n         }\n         PatKind::Lit(e) => vis.visit_expr(e),\n-        PatKind::TupleStruct(path, elems) => {\n+        PatKind::TupleStruct(qself, path, elems) => {\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             visit_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n         }\n-        PatKind::Struct(path, fields, _etc) => {\n+        PatKind::Struct(qself, path, fields, _etc) => {\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_pat_field(field));\n         }\n@@ -1333,7 +1335,8 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n-            let StructExpr { path, fields, rest } = se.deref_mut();\n+            let StructExpr { qself, path, fields, rest } = se.deref_mut();\n+            vis.visit_qself(qself);\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_expr_field(field));\n             match rest {"}, {"sha": "1ebfcf367110fb5bde6563c03a3afb1f57026bce", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -497,7 +497,10 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n     match pattern.kind {\n-        PatKind::TupleStruct(ref path, ref elems) => {\n+        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n@@ -507,7 +510,10 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref path, ref fields, _) => {\n+        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n@@ -740,6 +746,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_anon_const(count)\n         }\n         ExprKind::Struct(ref se) => {\n+            if let Some(ref qself) = se.qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(&se.path, expression.id);\n             walk_list!(visitor, visit_expr_field, &se.fields);\n             match &se.rest {"}, {"sha": "b9dcd083c0b8c9b176883851952e7cbdd3007cd9", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -237,7 +237,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::Struct(\n                         self.arena.alloc(self.lower_qpath(\n                             e.id,\n-                            &None,\n+                            &se.qself,\n                             &se.path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),\n@@ -1041,18 +1041,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// It is not a complete check, but just tries to reject most paths early\n     /// if they are not tuple structs.\n     /// Type checking will take care of the full validation later.\n-    fn extract_tuple_struct_path<'a>(&mut self, expr: &'a Expr) -> Option<&'a Path> {\n-        // For tuple struct destructuring, it must be a non-qualified path (like in patterns).\n-        if let ExprKind::Path(None, path) = &expr.kind {\n-            // Does the path resolves to something disallowed in a tuple struct/variant pattern?\n+    fn extract_tuple_struct_path<'a>(\n+        &mut self,\n+        expr: &'a Expr,\n+    ) -> Option<(&'a Option<QSelf>, &'a Path)> {\n+        if let ExprKind::Path(qself, path) = &expr.kind {\n+            // Does the path resolve to something disallowed in a tuple struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n                 if partial_res.unresolved_segments() == 0\n                     && !partial_res.base_res().expected_in_tuple_struct_pat()\n                 {\n                     return None;\n                 }\n             }\n-            return Some(path);\n+            return Some((qself, path));\n         }\n         None\n     }\n@@ -1088,7 +1090,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             // Tuple structs.\n             ExprKind::Call(callee, args) => {\n-                if let Some(path) = self.extract_tuple_struct_path(callee) {\n+                if let Some((qself, path)) = self.extract_tuple_struct_path(callee) {\n                     let (pats, rest) = self.destructure_sequence(\n                         args,\n                         \"tuple struct or variant\",\n@@ -1097,7 +1099,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let qpath = self.lower_qpath(\n                         callee.id,\n-                        &None,\n+                        qself,\n                         path,\n                         ParamMode::Optional,\n                         ImplTraitContext::disallowed(),\n@@ -1122,7 +1124,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }));\n                 let qpath = self.lower_qpath(\n                     lhs.id,\n-                    &None,\n+                    &se.qself,\n                     &se.path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),"}, {"sha": "66e623528f3bd179a189e75414ae59fc0b063f6e", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -21,10 +21,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n                     }\n                     PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n-                    PatKind::TupleStruct(ref path, ref pats) => {\n+                    PatKind::TupleStruct(ref qself, ref path, ref pats) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n-                            &None,\n+                            qself,\n                             path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),\n@@ -47,10 +47,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n-                    PatKind::Struct(ref path, ref fields, etc) => {\n+                    PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n-                            &None,\n+                            qself,\n                             path,\n                             ParamMode::Optional,\n                             ImplTraitContext::disallowed(),"}, {"sha": "3f98944d850e7991f01393e0062da1984dcb0441", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -705,6 +705,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         \"async closures are unstable\",\n         \"to use an async block, remove the `||`: `async {`\"\n     );\n+    gate_all!(more_qualified_paths, \"usage of qualified paths in this context is experimental\");\n     gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n     gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");"}, {"sha": "93facd255df5e3427bfe373755466ed4850dfa95", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -1713,11 +1713,16 @@ impl<'a> State<'a> {\n \n     fn print_expr_struct(\n         &mut self,\n+        qself: &Option<ast::QSelf>,\n         path: &ast::Path,\n         fields: &[ast::ExprField],\n         rest: &ast::StructRest,\n     ) {\n-        self.print_path(path, true, 0);\n+        if let Some(qself) = qself {\n+            self.print_qpath(path, qself, true);\n+        } else {\n+            self.print_path(path, true, 0);\n+        }\n         self.s.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n@@ -1874,7 +1879,7 @@ impl<'a> State<'a> {\n                 self.print_expr_repeat(element, count);\n             }\n             ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.path, &se.fields, &se.rest);\n+                self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(exprs);\n@@ -2340,8 +2345,12 @@ impl<'a> State<'a> {\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts) => {\n-                self.print_path(path, true, 0);\n+            PatKind::TupleStruct(ref qself, ref path, ref elts) => {\n+                if let Some(qself) = qself {\n+                    self.print_qpath(path, qself, true);\n+                } else {\n+                    self.print_path(path, true, 0);\n+                }\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.pclose();\n@@ -2355,8 +2364,12 @@ impl<'a> State<'a> {\n             PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false);\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0);\n+            PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+                if let Some(qself) = qself {\n+                    self.print_qpath(path, qself, true);\n+                } else {\n+                    self.print_path(path, true, 0);\n+                }\n                 self.nbsp();\n                 self.word_space(\"{\");\n                 self.commasep_cmnt("}, {"sha": "ef5b97a946909707e20767b6be5921525451e85a", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -275,7 +275,12 @@ impl<'a> ExtCtxt<'a> {\n     ) -> P<ast::Expr> {\n         self.expr(\n             span,\n-            ast::ExprKind::Struct(P(ast::StructExpr { path, fields, rest: ast::StructRest::None })),\n+            ast::ExprKind::Struct(P(ast::StructExpr {\n+                qself: None,\n+                path,\n+                fields,\n+                rest: ast::StructRest::None,\n+            })),\n         )\n     }\n     pub fn expr_struct_ident(\n@@ -405,15 +410,15 @@ impl<'a> ExtCtxt<'a> {\n         path: ast::Path,\n         subpats: Vec<P<ast::Pat>>,\n     ) -> P<ast::Pat> {\n-        self.pat(span, PatKind::TupleStruct(path, subpats))\n+        self.pat(span, PatKind::TupleStruct(None, path, subpats))\n     }\n     pub fn pat_struct(\n         &self,\n         span: Span,\n         path: ast::Path,\n         field_pats: Vec<ast::PatField>,\n     ) -> P<ast::Pat> {\n-        self.pat(span, PatKind::Struct(path, field_pats, false))\n+        self.pat(span, PatKind::Struct(None, path, field_pats, false))\n     }\n     pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))"}, {"sha": "56a320c8d3bce0f786d07557e9164398335ba18d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -663,6 +663,9 @@ declare_features! (\n     /// Allows unnamed fields of struct and union type\n     (active, unnamed_fields, \"1.53.0\", Some(49804), None),\n \n+    /// Allows qualified paths in struct expressions, struct patterns and tuple struct patterns.\n+    (active, more_qualified_paths, \"1.54.0\", Some(80080), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "44c2a550c30e2d40af462a89bd4afda3f30c49d2", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -858,10 +858,10 @@ impl EarlyLintPass for UnusedParens {\n             // The other cases do not contain sub-patterns.\n             | Wild | Rest | Lit(..) | MacCall(..) | Range(..) | Ident(.., None) | Path(..) => {},\n             // These are list-like patterns; parens can always be removed.\n-            TupleStruct(_, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n+            TupleStruct(_, _, ps) | Tuple(ps) | Slice(ps) | Or(ps) => for p in ps {\n                 self.check_unused_parens_pat(cx, p, false, false);\n             },\n-            Struct(_, fps, _) => for f in fps {\n+            Struct(_, _, fps, _) => for f in fps {\n                 self.check_unused_parens_pat(cx, &f.pat, false, false);\n             },\n             // Avoid linting on `i @ (p0 | .. | pn)` and `box (p0 | .. | pn)`, #64106."}, {"sha": "8b050389078a648311b408e4415fd19a42541707", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -32,7 +32,6 @@ impl<'a> Parser<'a> {\n         let mut just_parsed_doc_comment = false;\n         let start_pos = self.token_cursor.num_next_calls;\n         loop {\n-            debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n             let attr = if self.check(&token::Pound) {\n                 let inner_error_reason = if just_parsed_doc_comment {\n                     \"an inner attribute is not permitted following an outer doc comment\""}, {"sha": "b37caaebfb6895b4e098bfdb6f0ad430dd140490", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -366,7 +366,7 @@ impl<'a> Parser<'a> {\n             let mut snapshot = self.clone();\n             let path =\n                 Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n-            let struct_expr = snapshot.parse_struct_expr(path, AttrVec::new(), false);\n+            let struct_expr = snapshot.parse_struct_expr(None, path, AttrVec::new(), false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {"}, {"sha": "c8789abc142d6cf1179a8f0bf712398656e58620", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -1108,9 +1108,6 @@ impl<'a> Parser<'a> {\n             self.parse_closure_expr(attrs)\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             self.parse_array_or_repeat_expr(attrs)\n-        } else if self.eat_lt() {\n-            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-            Ok(self.mk_expr(lo.to(path.span), ExprKind::Path(Some(qself), path), attrs))\n         } else if self.check_path() {\n             self.parse_path_start_expr(attrs)\n         } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n@@ -1262,26 +1259,37 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n-        let path = self.parse_path(PathStyle::Expr)?;\n+        let (qself, path) = if self.eat_lt() {\n+            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+            (Some(qself), path)\n+        } else {\n+            (None, self.parse_path(PathStyle::Expr)?)\n+        };\n         let lo = path.span;\n \n         // `!`, as an operator, is prefix, so we know this isn't that.\n         let (hi, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n+            if qself.is_some() {\n+                self.struct_span_err(path.span, \"macros cannot use qualified paths\").emit();\n+            }\n             let mac = MacCall {\n                 path,\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n             (self.prev_token.span, ExprKind::MacCall(mac))\n         } else if self.check(&token::OpenDelim(token::Brace)) {\n-            if let Some(expr) = self.maybe_parse_struct_expr(&path, &attrs) {\n+            if let Some(expr) = self.maybe_parse_struct_expr(qself.as_ref(), &path, &attrs) {\n+                if qself.is_some() {\n+                    self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n+                }\n                 return expr;\n             } else {\n-                (path.span, ExprKind::Path(None, path))\n+                (path.span, ExprKind::Path(qself, path))\n             }\n         } else {\n-            (path.span, ExprKind::Path(None, path))\n+            (path.span, ExprKind::Path(qself, path))\n         };\n \n         let expr = self.mk_expr(lo.to(hi), kind, attrs);\n@@ -2247,6 +2255,7 @@ impl<'a> Parser<'a> {\n \n     fn maybe_parse_struct_expr(\n         &mut self,\n+        qself: Option<&ast::QSelf>,\n         path: &ast::Path,\n         attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n@@ -2255,7 +2264,7 @@ impl<'a> Parser<'a> {\n             if let Err(err) = self.expect(&token::OpenDelim(token::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(path.clone(), attrs.clone(), true);\n+            let expr = self.parse_struct_expr(qself.cloned(), path.clone(), attrs.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n@@ -2278,6 +2287,7 @@ impl<'a> Parser<'a> {\n     /// Precondition: already parsed the '{'.\n     pub(super) fn parse_struct_expr(\n         &mut self,\n+        qself: Option<ast::QSelf>,\n         pth: ast::Path,\n         attrs: AttrVec,\n         recover: bool,\n@@ -2375,7 +2385,7 @@ impl<'a> Parser<'a> {\n         let expr = if recover_async {\n             ExprKind::Err\n         } else {\n-            ExprKind::Struct(P(ast::StructExpr { path: pth, fields, rest: base }))\n+            ExprKind::Struct(P(ast::StructExpr { qself, path: pth, fields, rest: base }))\n         };\n         Ok(self.mk_expr(span, expr, attrs))\n     }"}, {"sha": "418122202be1b187e9e356ee0f96005ae7d7f328", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -859,7 +859,8 @@ impl<'a> Parser<'a> {\n     /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n     fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n         if qself.is_some() {\n-            return self.error_qpath_before_pat(&path, \"{\");\n+            // Feature gate the use of qualified paths in patterns\n+            self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n         }\n         self.bump();\n         let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n@@ -869,27 +870,17 @@ impl<'a> Parser<'a> {\n             (vec![], true)\n         });\n         self.bump();\n-        Ok(PatKind::Struct(path, fields, etc))\n+        Ok(PatKind::Struct(qself, path, fields, etc))\n     }\n \n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n-        if qself.is_some() {\n-            return self.error_qpath_before_pat(&path, \"(\");\n-        }\n         let (fields, _) =\n             self.parse_paren_comma_seq(|p| p.parse_pat_allow_top_alt(None, RecoverComma::No))?;\n-        Ok(PatKind::TupleStruct(path, fields))\n-    }\n-\n-    /// Error when there's a qualified path, e.g. `<Foo as Bar>::Baz`\n-    /// as the path of e.g., a tuple or record struct pattern.\n-    fn error_qpath_before_pat(&mut self, path: &Path, token: &str) -> PResult<'a, PatKind> {\n-        let msg = &format!(\"unexpected `{}` after qualified path\", token);\n-        let mut err = self.struct_span_err(self.token.span, msg);\n-        err.span_label(self.token.span, msg);\n-        err.span_label(path.span, \"the qualified path\");\n-        Err(err)\n+        if qself.is_some() {\n+            self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n+        }\n+        Ok(PatKind::TupleStruct(qself, path, fields))\n     }\n \n     /// Parses the fields of a struct-like pattern."}, {"sha": "9ef3f61ec346b11b2933dcc5f0cd075b8b0863c5", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -117,7 +117,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(token::Brace)) {\n-                this.parse_struct_expr(path, AttrVec::new(), true)?\n+                this.parse_struct_expr(None, path, AttrVec::new(), true)?\n             } else {\n                 let hi = this.prev_token.span;\n                 this.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())"}, {"sha": "a21d8197bdbb3cb70e3271b9a7e6cfff2f765abe", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -1613,10 +1613,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                     self.r.record_pat_span(pat.id, pat.span);\n                 }\n-                PatKind::TupleStruct(ref path, ref sub_patterns) => {\n+                PatKind::TupleStruct(ref qself, ref path, ref sub_patterns) => {\n                     self.smart_resolve_path(\n                         pat.id,\n-                        None,\n+                        qself.as_ref(),\n                         path,\n                         PathSource::TupleStruct(\n                             pat.span,\n@@ -1627,8 +1627,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 PatKind::Path(ref qself, ref path) => {\n                     self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n-                PatKind::Struct(ref path, ..) => {\n-                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n+                PatKind::Struct(ref qself, ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Struct);\n                 }\n                 PatKind::Or(ref ps) => {\n                     // Add a new set of bindings to the stack. `Or` here records that when a\n@@ -2288,7 +2288,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ExprKind::Struct(ref se) => {\n-                self.smart_resolve_path(expr.id, None, &se.path, PathSource::Struct);\n+                self.smart_resolve_path(expr.id, se.qself.as_ref(), &se.path, PathSource::Struct);\n                 visit::walk_expr(self, expr);\n             }\n "}, {"sha": "fb37c5e9c1eff58f3a6bd5b1f565751fd917d801", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -756,6 +756,7 @@ symbols! {\n         modifiers,\n         module,\n         module_path,\n+        more_qualified_paths,\n         more_struct_aliases,\n         movbe_target_feature,\n         move_ref_pattern,"}, {"sha": "857af577a6cfeb3e5d29462189cb47cf85c29fb3", "filename": "src/doc/unstable-book/src/language-features/more-qualified-paths.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmore-qualified-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmore-qualified-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmore-qualified-paths.md?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,29 @@\n+# `more_qualified_paths`\n+\n+The `more_qualified_paths` feature can be used in order to enable the\n+use of qualified paths in patterns.\n+\n+## Example\n+\n+```rust\n+#![feature(more_qualified_paths)]\n+\n+fn main() {\n+    // destructure through a qualified path\n+    let <Foo as A>::Assoc { br } = StructStruct { br: 2 };\n+}\n+\n+struct StructStruct {\n+    br: i8,\n+}\n+\n+struct Foo;\n+\n+trait A {\n+    type Assoc;\n+}\n+\n+impl A for Foo {\n+    type Assoc = StructStruct;\n+}\n+```"}, {"sha": "091c834eccf5f848826f26a4aa59e6e17db776a0", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -19,45 +19,35 @@\n \n #![feature(rustc_private)]\n \n+extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_data_structures;\n-extern crate rustc_ast;\n extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n \n+use rustc_ast::mut_visit::{self, visit_clobber, MutVisitor};\n+use rustc_ast::ptr::P;\n+use rustc_ast::*;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_parse::new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n-use rustc_span::source_map::{Spanned, DUMMY_SP, FileName};\n use rustc_span::source_map::FilePathMapping;\n+use rustc_span::source_map::{FileName, Spanned, DUMMY_SP};\n use rustc_span::symbol::Ident;\n-use rustc_ast::*;\n-use rustc_ast::mut_visit::{self, MutVisitor, visit_clobber};\n-use rustc_ast::ptr::P;\n \n fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n     let src_as_string = src.to_string();\n \n-    let mut p = new_parser_from_source_str(\n-        ps,\n-        FileName::Custom(src_as_string.clone()),\n-        src_as_string,\n-    );\n+    let mut p =\n+        new_parser_from_source_str(ps, FileName::Custom(src_as_string.clone()), src_as_string);\n     p.parse_expr().map_err(|mut e| e.cancel()).ok()\n }\n \n-\n // Helper functions for building exprs\n fn expr(kind: ExprKind) -> P<Expr> {\n-    P(Expr {\n-        id: DUMMY_NODE_ID,\n-        kind,\n-        span: DUMMY_SP,\n-        attrs: ThinVec::new(),\n-        tokens: None\n-    })\n+    P(Expr { id: DUMMY_NODE_ID, kind, span: DUMMY_SP, attrs: ThinVec::new(), tokens: None })\n }\n \n fn make_x() -> P<Expr> {\n@@ -83,11 +73,13 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n             2 => {\n                 let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n-                            seg.clone(), vec![e, make_x()], DUMMY_SP)));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n-                            seg.clone(), vec![make_x(), e], DUMMY_SP)));\n-            },\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::MethodCall(seg.clone(), vec![e, make_x()], DUMMY_SP))\n+                });\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::MethodCall(seg.clone(), vec![make_x(), e], DUMMY_SP))\n+                });\n+            }\n             3..=8 => {\n                 let op = Spanned {\n                     span: DUMMY_SP,\n@@ -99,14 +91,14 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                         7 => BinOpKind::Or,\n                         8 => BinOpKind::Lt,\n                         _ => unreachable!(),\n-                    }\n+                    },\n                 };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n-            },\n+            }\n             9 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Unary(UnOp::Deref, e)));\n-            },\n+            }\n             10 => {\n                 let block = P(Block {\n                     stmts: Vec::new(),\n@@ -116,67 +108,66 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                     tokens: None,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n-            },\n+            }\n             11 => {\n-                let decl = P(FnDecl {\n-                    inputs: vec![],\n-                    output: FnRetTy::Default(DUMMY_SP),\n+                let decl = P(FnDecl { inputs: vec![], output: FnRetTy::Default(DUMMY_SP) });\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::Closure(\n+                        CaptureBy::Value,\n+                        Async::No,\n+                        Movability::Movable,\n+                        decl.clone(),\n+                        e,\n+                        DUMMY_SP,\n+                    ))\n                 });\n-                iter_exprs(depth - 1, &mut |e| g(\n-                        ExprKind::Closure(CaptureBy::Value,\n-                                          Async::No,\n-                                          Movability::Movable,\n-                                          decl.clone(),\n-                                          e,\n-                                          DUMMY_SP)));\n-            },\n+            }\n             12 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x(), DUMMY_SP)));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e, DUMMY_SP)));\n-            },\n+            }\n             13 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, Ident::from_str(\"f\"))));\n-            },\n+            }\n             14 => {\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n-                            Some(e), Some(make_x()), RangeLimits::HalfOpen)));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n-                            Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n-            },\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::Range(Some(e), Some(make_x()), RangeLimits::HalfOpen))\n+                });\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::Range(Some(make_x()), Some(e), RangeLimits::HalfOpen))\n+                });\n+            }\n             15 => {\n-                iter_exprs(\n-                    depth - 1,\n-                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, e)),\n-                );\n-            },\n+                iter_exprs(depth - 1, &mut |e| {\n+                    g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, e))\n+                });\n+            }\n             16 => {\n                 g(ExprKind::Ret(None));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n-            },\n+            }\n             17 => {\n                 let path = Path::from_ident(Ident::from_str(\"S\"));\n                 g(ExprKind::Struct(P(StructExpr {\n-                    path, fields: vec![], rest: StructRest::Base(make_x())\n+                    qself: None,\n+                    path,\n+                    fields: vec![],\n+                    rest: StructRest::Base(make_x()),\n                 })));\n-            },\n+            }\n             18 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n-            },\n+            }\n             19 => {\n-                let pat = P(Pat {\n-                    id: DUMMY_NODE_ID,\n-                    kind: PatKind::Wild,\n-                    span: DUMMY_SP,\n-                    tokens: None,\n-                });\n+                let pat =\n+                    P(Pat { id: DUMMY_NODE_ID, kind: PatKind::Wild, span: DUMMY_SP, tokens: None });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))\n-            },\n+            }\n             _ => panic!(\"bad counter value in iter_exprs\"),\n         }\n     }\n }\n \n-\n // Folders for manipulating the placement of `Paren` nodes. See below for why this is needed.\n \n /// `MutVisitor` that removes all `ExprKind::Paren` nodes.\n@@ -192,7 +183,6 @@ impl MutVisitor for RemoveParens {\n     }\n }\n \n-\n /// `MutVisitor` that inserts `ExprKind::Paren` nodes around every `Expr`.\n struct AddParens;\n \n@@ -205,7 +195,7 @@ impl MutVisitor for AddParens {\n                 kind: ExprKind::Paren(e),\n                 span: DUMMY_SP,\n                 attrs: ThinVec::new(),\n-                tokens: None\n+                tokens: None,\n             })\n         });\n     }\n@@ -238,9 +228,12 @@ fn run() {\n             RemoveParens.visit_expr(&mut parsed);\n             AddParens.visit_expr(&mut parsed);\n             let text2 = pprust::expr_to_string(&parsed);\n-            assert!(text1 == text2,\n-                    \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n-                    text1, text2);\n+            assert!(\n+                text1 == text2,\n+                \"exprs are not equal:\\n  e =      {:?}\\n  parsed = {:?}\",\n+                text1,\n+                text2\n+            );\n         }\n     });\n }"}, {"sha": "fea7c7a383fbe44987bc7cda900e143ce4d8d24d", "filename": "src/test/ui/associated-types/associated-type-destructuring-assignment.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-destructuring-assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-destructuring-assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-destructuring-assignment.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(destructuring_assignment)]\n+#![feature(more_qualified_paths)]\n+\n+enum E { V() }\n+\n+fn main() {\n+    <E>::V() = E::V(); // OK, destructuring assignment\n+    <E>::V {} = E::V(); // OK, destructuring assignment\n+}"}, {"sha": "22b5bca40103df5e52a2553a2fefd3e646e47924", "filename": "src/test/ui/associated-types/associated-type-macro.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    #[cfg(FALSE)]\n+    <() as module>::mac!(); //~ ERROR macros cannot use qualified paths\n+}"}, {"sha": "6a4cf99c474e2d27d5a5e499dbee3c9b7dafa5ef", "filename": "src/test/ui/associated-types/associated-type-macro.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-macro.stderr?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,8 @@\n+error: macros cannot use qualified paths\n+  --> $DIR/associated-type-macro.rs:3:5\n+   |\n+LL |     <() as module>::mac!();\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "f8f8048fb717f3a07eed548cdd5c4487bebff7b5", "filename": "src/test/ui/associated-types/associated-type-struct-construction.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-struct-construction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-struct-construction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-struct-construction.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,24 @@\n+// Make sure that users can construct structs through associated types\n+// in both expressions and patterns\n+\n+#![feature(more_qualified_paths)]\n+\n+// check-pass\n+fn main() {\n+    let <Foo as A>::Assoc { br } = <Foo as A>::Assoc { br: 2 };\n+    assert!(br == 2);\n+}\n+\n+struct StructStruct {\n+    br: i8,\n+}\n+\n+struct Foo;\n+\n+trait A {\n+    type Assoc;\n+}\n+\n+impl A for Foo {\n+    type Assoc = StructStruct;\n+}"}, {"sha": "d5809ecd55d853b18dd8e6e8b9e074ae642b4240", "filename": "src/test/ui/associated-types/associated-type-tuple-struct-construction.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,24 @@\n+// Users cannot yet construct structs through associated types\n+// in both expressions and patterns\n+\n+#![feature(more_qualified_paths)]\n+\n+fn main() {\n+    let <Foo as A>::Assoc(n) = <Foo as A>::Assoc(2);\n+    //~^ ERROR expected method or associated constant, found associated type\n+    //~| ERROR expected method or associated constant, found associated type\n+    assert!(n == 2);\n+}\n+\n+struct TupleStruct(i8);\n+\n+struct Foo;\n+\n+\n+trait A {\n+    type Assoc;\n+}\n+\n+impl A for Foo {\n+    type Assoc = TupleStruct;\n+}"}, {"sha": "bca7deeb5128c8870bb246c059ac6e10fd2bbef0", "filename": "src/test/ui/associated-types/associated-type-tuple-struct-construction.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-type-tuple-struct-construction.stderr?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,19 @@\n+error[E0575]: expected method or associated constant, found associated type `A::Assoc`\n+  --> $DIR/associated-type-tuple-struct-construction.rs:7:32\n+   |\n+LL |     let <Foo as A>::Assoc(n) = <Foo as A>::Assoc(2);\n+   |                                ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: can't use a type alias as a constructor\n+\n+error[E0575]: expected method or associated constant, found associated type `A::Assoc`\n+  --> $DIR/associated-type-tuple-struct-construction.rs:7:9\n+   |\n+LL |     let <Foo as A>::Assoc(n) = <Foo as A>::Assoc(2);\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: can't use a type alias as a constructor\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0575`."}, {"sha": "2e05acbfa1758432e6794936f140380a1392a675", "filename": "src/test/ui/feature-gates/feature-gate-more-qualified-paths.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,27 @@\n+fn main() {\n+    // destructure through a qualified path\n+    let <Foo as A>::Assoc { br } = StructStruct { br: 2 };\n+    //~^ ERROR usage of qualified paths in this context is experimental\n+    let _ = <Foo as A>::Assoc { br: 2 };\n+    //~^ ERROR usage of qualified paths in this context is experimental\n+    let <E>::V(..) = E::V(0);\n+    //~^ ERROR usage of qualified paths in this context is experimental\n+}\n+\n+struct StructStruct {\n+    br: i8,\n+}\n+\n+struct Foo;\n+\n+trait A {\n+    type Assoc;\n+}\n+\n+impl A for Foo {\n+    type Assoc = StructStruct;\n+}\n+\n+enum E {\n+    V(u8)\n+}"}, {"sha": "b49cc40800f03660cd5ca2e0ff2d1636ac0a53af", "filename": "src/test/ui/feature-gates/feature-gate-more-qualified-paths.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-more-qualified-paths.stderr?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -0,0 +1,30 @@\n+error[E0658]: usage of qualified paths in this context is experimental\n+  --> $DIR/feature-gate-more-qualified-paths.rs:3:9\n+   |\n+LL |     let <Foo as A>::Assoc { br } = StructStruct { br: 2 };\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #80080 <https://github.com/rust-lang/rust/issues/80080> for more information\n+   = help: add `#![feature(more_qualified_paths)]` to the crate attributes to enable\n+\n+error[E0658]: usage of qualified paths in this context is experimental\n+  --> $DIR/feature-gate-more-qualified-paths.rs:5:13\n+   |\n+LL |     let _ = <Foo as A>::Assoc { br: 2 };\n+   |             ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #80080 <https://github.com/rust-lang/rust/issues/80080> for more information\n+   = help: add `#![feature(more_qualified_paths)]` to the crate attributes to enable\n+\n+error[E0658]: usage of qualified paths in this context is experimental\n+  --> $DIR/feature-gate-more-qualified-paths.rs:7:9\n+   |\n+LL |     let <E>::V(..) = E::V(0);\n+   |         ^^^^^^\n+   |\n+   = note: see issue #80080 <https://github.com/rust-lang/rust/issues/80080> for more information\n+   = help: add `#![feature(more_qualified_paths)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f41520861627ab84c9558e001c53b0cbc64ec768", "filename": "src/test/ui/parser/brace-after-qualified-path-in-match.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.rs?ref=c622840b909428bc77ab67f4f4fb61d03abb65eb", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    match 10 {\n-        <T as Trait>::Type{key: value} => (),\n-        //~^ ERROR unexpected `{` after qualified path\n-        _ => (),\n-    }\n-}"}, {"sha": "d6fdf353f07af3f9e5c790d31b61aabcfd3b9eac", "filename": "src/test/ui/parser/brace-after-qualified-path-in-match.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbrace-after-qualified-path-in-match.stderr?ref=c622840b909428bc77ab67f4f4fb61d03abb65eb", "patch": "@@ -1,10 +0,0 @@\n-error: unexpected `{` after qualified path\n-  --> $DIR/brace-after-qualified-path-in-match.rs:3:27\n-   |\n-LL |         <T as Trait>::Type{key: value} => (),\n-   |         ------------------^ unexpected `{` after qualified path\n-   |         |\n-   |         the qualified path\n-\n-error: aborting due to previous error\n-"}, {"sha": "68b1c2baf100163bc2d632ad3b970ccac196f78d", "filename": "src/test/ui/parser/paren-after-qualified-path-in-match.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.rs?ref=c622840b909428bc77ab67f4f4fb61d03abb65eb", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    match 10 {\n-        <T as Trait>::Type(2) => (),\n-        //~^ ERROR unexpected `(` after qualified path\n-        _ => (),\n-    }\n-}"}, {"sha": "af21f9195467ae0511287ecd646031ae0f95a982", "filename": "src/test/ui/parser/paren-after-qualified-path-in-match.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c622840b909428bc77ab67f4f4fb61d03abb65eb/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fparen-after-qualified-path-in-match.stderr?ref=c622840b909428bc77ab67f4f4fb61d03abb65eb", "patch": "@@ -1,10 +0,0 @@\n-error: unexpected `(` after qualified path\n-  --> $DIR/paren-after-qualified-path-in-match.rs:3:27\n-   |\n-LL |         <T as Trait>::Type(2) => (),\n-   |         ------------------^ unexpected `(` after qualified path\n-   |         |\n-   |         the qualified path\n-\n-error: aborting due to previous error\n-"}, {"sha": "2201cf56d52ab357c287633b45c8e3d0b8dbcc7e", "filename": "src/tools/clippy/clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::{EarlyContext, LintContext};\n use super::UNNEEDED_FIELD_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n+    if let PatKind::Struct(_, ref npat, ref pfields, _) = pat.kind {\n         let mut wilds = 0;\n         let type_name = npat\n             .segments"}, {"sha": "df044538fe19d36b825bcd5d858c9833a6308961", "filename": "src/tools/clippy/clippy_lints/src/misc_early/unneeded_wildcard_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n use super::UNNEEDED_WILDCARD_PATTERN;\n \n pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n+    if let PatKind::TupleStruct(_, _, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n         if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n             if let Some((left_index, left_pat)) = patterns[..rest_index]\n                 .iter()"}, {"sha": "1a23e6afe283d52c642406bd97f547440914ca68", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                     self.check_ident(ident);\n                 }\n             },\n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(_, _, ref fields, _) => {\n                 for field in fields {\n                     if !field.is_shorthand {\n                         self.visit_pat(&field.pat);"}, {"sha": "1b3c457b01adb64650f9965d352eabedee6d54d9", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n+use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path, eq_maybe_qself};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{meets_msrv, msrvs, over};\n use rustc_ast::mut_visit::*;\n@@ -273,16 +273,16 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n             |k| always_pat!(k, Tuple(ps) => ps),\n         ),\n         // Transform `S(pre, x, post) | ... | S(pre, y, post)` into `S(pre, x | y, post)`.\n-        TupleStruct(path1, ps1) => extend_with_matching_product(\n+        TupleStruct(qself1, path1, ps1) => extend_with_matching_product(\n             ps1, start, alternatives,\n             |k, ps1, idx| matches!(\n                 k,\n-                TupleStruct(path2, ps2) if eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+                TupleStruct(qself2, path2, ps2) if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n             ),\n-            |k| always_pat!(k, TupleStruct(_, ps) => ps),\n+            |k| always_pat!(k, TupleStruct(_, _, ps) => ps),\n         ),\n         // Transform a record pattern `S { fp_0, ..., fp_n }`.\n-        Struct(path1, fps1, rest1) => extend_with_struct_pat(path1, fps1, *rest1, start, alternatives),\n+        Struct(qself1, path1, fps1, rest1) => extend_with_struct_pat(qself1, path1, fps1, *rest1, start, alternatives),\n     };\n \n     alternatives[focus_idx].kind = focus_kind;\n@@ -294,6 +294,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n /// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n /// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n fn extend_with_struct_pat(\n+    qself1: &Option<ast::QSelf>,\n     path1: &ast::Path,\n     fps1: &mut Vec<ast::PatField>,\n     rest1: bool,\n@@ -306,8 +307,9 @@ fn extend_with_struct_pat(\n             start,\n             alternatives,\n             |k| {\n-                matches!(k, Struct(path2, fps2, rest2)\n+                matches!(k, Struct(qself2, path2, fps2, rest2)\n                 if rest1 == *rest2 // If one struct pattern has `..` so must the other.\n+                && eq_maybe_qself(qself1, qself2)\n                 && eq_path(path1, path2)\n                 && fps1.len() == fps2.len()\n                 && fps1.iter().enumerate().all(|(idx_1, fp1)| {\n@@ -323,7 +325,7 @@ fn extend_with_struct_pat(\n                 }))\n             },\n             // Extract `p2_k`.\n-            |k| always_pat!(k, Struct(_, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n+            |k| always_pat!(k, Struct(_, _, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n         );\n         extend_with_tail_or(&mut fps1[idx].pat, tail_or)\n     })"}, {"sha": "e6d84bc7560ba9cc9ae8d2d76c633d938d896a77", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -47,9 +47,9 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TupleStruct(lp, lfs), TupleStruct(rp, rfs)) => eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n-        (Struct(lp, lfs, lr), Struct(rp, rfs, rr)) => {\n-            lr == rr && eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n+            lr == rr && eq_maybe_qself(lqself, rqself) &&eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -78,6 +78,14 @@ pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n     l.position == r.position && eq_ty(&l.ty, &r.ty)\n }\n \n+pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n+    match (l, r) {\n+        (Some(l), Some(r)) => eq_qself(l, r),\n+        (None, None) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn eq_path(l: &Path, r: &Path) -> bool {\n     over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n }\n@@ -170,7 +178,8 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lse), Struct(rse)) => {\n-            eq_path(&lse.path, &rse.path)\n+            eq_maybe_qself(&lse.qself, &rse.qself) \n+                && eq_path(&lse.path, &rse.path)\n                 && eq_struct_rest(&lse.rest, &rse.rest)\n                 && unordered_over(&lse.fields, &rse.fields, |l, r| eq_field(l, r))\n         },"}, {"sha": "bca9f77f959e3aa5c118552babd65338b99325c0", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -107,7 +107,9 @@ pub(crate) fn format_expr(\n         }\n         ast::ExprKind::Unary(op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n         ast::ExprKind::Struct(ref struct_expr) => {\n-            let ast::StructExpr { fields, path, rest } = &**struct_expr;\n+            let ast::StructExpr {\n+                fields, path, rest, ..\n+            } = &**struct_expr;\n             rewrite_struct_lit(context, path, fields, rest, &expr.attrs, expr.span, shape)\n         }\n         ast::ExprKind::Tup(ref items) => {"}, {"sha": "fa0ef260991d7355af6d0bcc30b098381bad8233", "filename": "src/tools/rustfmt/src/patterns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e18395ce33ca1ebfe60a591fb2f9317a75d822/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs?ref=16e18395ce33ca1ebfe60a591fb2f9317a75d822", "patch": "@@ -45,7 +45,7 @@ fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n         | ast::PatKind::Path(..)\n         | ast::PatKind::Range(..) => false,\n         ast::PatKind::Tuple(ref subpats) => subpats.len() <= 1,\n-        ast::PatKind::TupleStruct(ref path, ref subpats) => {\n+        ast::PatKind::TupleStruct(_, ref path, ref subpats) => {\n             path.segments.len() <= 1 && subpats.len() <= 1\n         }\n         ast::PatKind::Box(ref p) | ast::PatKind::Ref(ref p, _) | ast::PatKind::Paren(ref p) => {\n@@ -226,7 +226,7 @@ impl Rewrite for Pat {\n             PatKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n             }\n-            PatKind::TupleStruct(ref path, ref pat_vec) => {\n+            PatKind::TupleStruct(_, ref path, ref pat_vec) => {\n                 let path_str = rewrite_path(context, PathContext::Expr, None, path, shape)?;\n                 rewrite_tuple_pat(pat_vec, Some(path_str), self.span, context, shape)\n             }\n@@ -244,7 +244,7 @@ impl Rewrite for Pat {\n                     .collect();\n                 Some(format!(\"[{}]\", rw.join(\", \")))\n             }\n-            PatKind::Struct(ref path, ref fields, ellipsis) => {\n+            PatKind::Struct(_, ref path, ref fields, ellipsis) => {\n                 rewrite_struct_pat(path, fields, ellipsis, self.span, context, shape)\n             }\n             PatKind::MacCall(ref mac) => {"}]}