{"sha": "5d63910f90afcb601a765bba6bd4bb8d52ebef81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNjM5MTBmOTBhZmNiNjAxYTc2NWJiYTZiZDRiYjhkNTJlYmVmODE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-05T21:50:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-08T02:53:21Z"}, "message": "syntax: split out the parsing and the formatting part of format_args!().", "tree": {"sha": "ae122ee4d9d84e58698104f2f41778ede07cb98a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae122ee4d9d84e58698104f2f41778ede07cb98a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d63910f90afcb601a765bba6bd4bb8d52ebef81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d63910f90afcb601a765bba6bd4bb8d52ebef81", "html_url": "https://github.com/rust-lang/rust/commit/5d63910f90afcb601a765bba6bd4bb8d52ebef81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d63910f90afcb601a765bba6bd4bb8d52ebef81/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa191a559171094d89a598884ea18aba6cbda858", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa191a559171094d89a598884ea18aba6cbda858", "html_url": "https://github.com/rust-lang/rust/commit/fa191a559171094d89a598884ea18aba6cbda858"}], "stats": {"total": 166, "additions": 92, "deletions": 74}, "files": [{"sha": "4bc3b804c7ff7a5fb3cd503370b446e7adf659c9", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 92, "deletions": 74, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/5d63910f90afcb601a765bba6bd4bb8d52ebef81/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d63910f90afcb601a765bba6bd4bb8d52ebef81/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5d63910f90afcb601a765bba6bd4bb8d52ebef81", "patch": "@@ -56,78 +56,83 @@ struct Context<'a> {\n     next_arg: uint,\n }\n \n-impl<'a> Context<'a> {\n-    /// Parses the arguments from the given list of tokens, returning None if\n-    /// there's a parse error so we can continue parsing other format! expressions.\n-    fn parse_args(&mut self, sp: Span, tts: &[ast::TokenTree])\n-                  -> (@ast::Expr, Option<@ast::Expr>) {\n-        let mut p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n-                                                 self.ecx.cfg(),\n-                                                 tts.to_owned());\n-        // Parse the leading function expression (maybe a block, maybe a path)\n-        let extra = p.parse_expr();\n-        if !p.eat(&token::COMMA) {\n-            self.ecx.span_err(sp, \"expected token: `,`\");\n-            return (extra, None);\n-        }\n+/// Parses the arguments from the given list of tokens, returning None\n+/// if there's a parse error so we can continue parsing other format!\n+/// expressions.\n+///\n+/// If parsing succeeds, the second return value is:\n+///\n+///     Some((fmtstr, unnamed arguments, named arguments))\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span,\n+              tts: &[ast::TokenTree]) -> (@ast::Expr, Option<(@ast::Expr, ~[@ast::Expr],\n+                                                              HashMap<~str, @ast::Expr>)>) {\n+    let mut args = ~[];\n+    let mut names = HashMap::<~str, @ast::Expr>::new();\n+\n+    let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n+                                             ecx.cfg(),\n+                                             tts.to_owned());\n+    // Parse the leading function expression (maybe a block, maybe a path)\n+    let extra = p.parse_expr();\n+    if !p.eat(&token::COMMA) {\n+        ecx.span_err(sp, \"expected token: `,`\");\n+        return (extra, None);\n+    }\n \n-        if p.token == token::EOF {\n-            self.ecx.span_err(sp, \"requires at least a format string argument\");\n+    if p.token == token::EOF {\n+        ecx.span_err(sp, \"requires at least a format string argument\");\n+        return (extra, None);\n+    }\n+    let fmtstr = p.parse_expr();\n+    let mut named = false;\n+    while p.token != token::EOF {\n+        if !p.eat(&token::COMMA) {\n+            ecx.span_err(sp, \"expected token: `,`\");\n             return (extra, None);\n         }\n-        let fmtstr = p.parse_expr();\n-        let mut named = false;\n-        while p.token != token::EOF {\n-            if !p.eat(&token::COMMA) {\n-                self.ecx.span_err(sp, \"expected token: `,`\");\n-                return (extra, None);\n-            }\n-            if p.token == token::EOF { break } // accept trailing commas\n-            if named || (token::is_ident(&p.token) &&\n-                         p.look_ahead(1, |t| *t == token::EQ)) {\n-                named = true;\n-                let ident = match p.token {\n-                    token::IDENT(i, _) => {\n-                        p.bump();\n-                        i\n-                    }\n-                    _ if named => {\n-                        self.ecx.span_err(p.span,\n-                                          \"expected ident, positional arguments \\\n-                                           cannot follow named arguments\");\n-                        return (extra, None);\n-                    }\n-                    _ => {\n-                        self.ecx.span_err(p.span,\n-                                          format!(\"expected ident for named \\\n-                                                argument, but found `{}`\",\n-                                               p.this_token_to_str()));\n-                        return (extra, None);\n-                    }\n-                };\n-                let interned_name = token::get_ident(ident.name);\n-                let name = interned_name.get();\n-                p.expect(&token::EQ);\n-                let e = p.parse_expr();\n-                match self.names.find_equiv(&name) {\n-                    None => {}\n-                    Some(prev) => {\n-                        self.ecx.span_err(e.span, format!(\"duplicate argument \\\n-                                                        named `{}`\", name));\n-                        self.ecx.parse_sess.span_diagnostic.span_note(\n-                            prev.span, \"previously here\");\n-                        continue\n-                    }\n+        if p.token == token::EOF { break } // accept trailing commas\n+        if named || (token::is_ident(&p.token) &&\n+                     p.look_ahead(1, |t| *t == token::EQ)) {\n+            named = true;\n+            let ident = match p.token {\n+                token::IDENT(i, _) => {\n+                    p.bump();\n+                    i\n+                }\n+                _ if named => {\n+                    ecx.span_err(p.span,\n+                                 \"expected ident, positional arguments \\\n+                                 cannot follow named arguments\");\n+                    return (extra, None);\n+                }\n+                _ => {\n+                    ecx.span_err(p.span,\n+                                 format!(\"expected ident for named argument, but found `{}`\",\n+                                         p.this_token_to_str()));\n+                    return (extra, None);\n+                }\n+            };\n+            let interned_name = token::get_ident(ident.name);\n+            let name = interned_name.get();\n+            p.expect(&token::EQ);\n+            let e = p.parse_expr();\n+            match names.find_equiv(&name) {\n+                None => {}\n+                Some(prev) => {\n+                    ecx.span_err(e.span, format!(\"duplicate argument named `{}`\", name));\n+                    ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n+                    continue\n                 }\n-                self.names.insert(name.to_str(), e);\n-            } else {\n-                self.args.push(p.parse_expr());\n-                self.arg_types.push(None);\n             }\n+            names.insert(name.to_str(), e);\n+        } else {\n+            args.push(p.parse_expr());\n         }\n-        return (extra, Some(fmtstr));\n     }\n+    return (extra, Some((fmtstr, args, names)));\n+}\n \n+impl<'a> Context<'a> {\n     /// Verifies one piece of a parse string. All errors are not emitted as\n     /// fatal so we can continue giving errors about this and possibly other\n     /// format strings.\n@@ -758,11 +763,28 @@ impl<'a> Context<'a> {\n \n pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                    tts: &[ast::TokenTree]) -> base::MacResult {\n+\n+    match parse_args(ecx, sp, tts) {\n+        (extra, Some((efmt, args, names))) => {\n+            MRExpr(expand_preparsed_format_args(ecx, sp, extra, efmt, args, names))\n+        }\n+        (_, None) => MRExpr(ecx.expr_uint(sp, 2))\n+    }\n+}\n+\n+/// Take the various parts of `format_args!(extra, efmt, args...,\n+/// name=names...)` and construct the appropriate formatting\n+/// expression.\n+pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n+                                    extra: @ast::Expr,\n+                                    efmt: @ast::Expr, args: ~[@ast::Expr],\n+                                    names: HashMap<~str, @ast::Expr>) -> @ast::Expr {\n+    let arg_types = vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n         ecx: ecx,\n-        args: ~[],\n-        arg_types: ~[],\n-        names: HashMap::new(),\n+        args: args,\n+        arg_types: arg_types,\n+        names: names,\n         name_positions: HashMap::new(),\n         name_types: HashMap::new(),\n         nest_level: 0,\n@@ -771,10 +793,6 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let (extra, efmt) = match cx.parse_args(sp, tts) {\n-        (extra, Some(e)) => (extra, e),\n-        (_, None) => { return MRExpr(cx.ecx.expr_uint(sp, 2)); }\n-    };\n     cx.fmtsp = efmt.span;\n     // Be sure to recursively expand macros just in case the format string uses\n     // a macro to build the format expression.\n@@ -783,7 +801,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n                                 expr,\n                                 \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n-        None => return MacResult::dummy_expr()\n+        None => return efmt\n     };\n \n     let mut parser = parse::Parser::new(fmt.get());\n@@ -801,7 +819,7 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n     match parser.errors.shift() {\n         Some(error) => {\n             cx.ecx.span_err(efmt.span, \"invalid format string: \" + error);\n-            return MRExpr(efmt);\n+            return efmt;\n         }\n         None => {}\n     }\n@@ -818,5 +836,5 @@ pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    MRExpr(cx.to_expr(extra))\n+    cx.to_expr(extra)\n }"}]}