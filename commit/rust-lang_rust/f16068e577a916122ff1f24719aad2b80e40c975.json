{"sha": "f16068e577a916122ff1f24719aad2b80e40c975", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjA2OGU1NzdhOTE2MTIyZmYxZjI0NzE5YWFkMmI4MGU0MGM5NzU=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-08-29T00:44:19Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-09-24T22:21:10Z"}, "message": "Completely kill `represent_type` and the `adt::Repr` type that goes with it.", "tree": {"sha": "c02b780450bcb28c48b379e6ee005a56e43ae737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02b780450bcb28c48b379e6ee005a56e43ae737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f16068e577a916122ff1f24719aad2b80e40c975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f16068e577a916122ff1f24719aad2b80e40c975", "html_url": "https://github.com/rust-lang/rust/commit/f16068e577a916122ff1f24719aad2b80e40c975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f16068e577a916122ff1f24719aad2b80e40c975/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdad70213b32454837c0ed16dbbac3954325feea", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad70213b32454837c0ed16dbbac3954325feea", "html_url": "https://github.com/rust-lang/rust/commit/bdad70213b32454837c0ed16dbbac3954325feea"}], "stats": {"total": 1435, "additions": 520, "deletions": 915}, "files": [{"sha": "c24dd4aaed60bee199d302889d64a7a26cc83037", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -489,6 +489,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Cache for layouts computed from types.\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n \n+    //Used to prevent layout from recursing too deeply.\n+    pub layout_depth: Cell<usize>,\n+\n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `rustc-macro` crates.\n     pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n@@ -760,6 +763,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FnvHashMap()),\n+            layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n        }, f)\n     }"}, {"sha": "c8bcda8c530e7ebf4fd23ae2a59e0ec27f65f1f6", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -328,6 +328,33 @@ pub enum Integer {\n }\n \n impl Integer {\n+\n+    pub fn size(&self) -> Size {\n+        match *self {\n+            I1 => Size::from_bits(1),\n+            I8 => Size::from_bytes(1),\n+            I16 => Size::from_bytes(2),\n+            I32 => Size::from_bytes(4),\n+            I64  => Size::from_bytes(8),\n+        }\n+    }\n+\n+    pub fn to_ty<'a, 'tcx>(&self, tcx: &ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                       signed: bool) -> Ty<'tcx> {\n+        match (*self, signed) {\n+            (I1, false) => tcx.types.u8,\n+            (I8, false) => tcx.types.u8,\n+            (I16, false) => tcx.types.u16,\n+            (I32, false) => tcx.types.u32,\n+            (I64, false) => tcx.types.u64,\n+            (I1, true) => tcx.types.i8,\n+            (I8, true) => tcx.types.i8,\n+            (I16, true) => tcx.types.i16,\n+            (I32, true) => tcx.types.i32,\n+            (I64, true) => tcx.types.i64,\n+        }\n+    }\n+\n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i64) -> Integer {\n         match x {\n@@ -912,7 +939,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 Univariant { variant: unit, non_zero: false }\n             }\n \n-            // Tuples.\n+            // Tuples and closures.\n             ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n             ty::TyTuple(tys) => {\n                 let mut st = Struct::new(dl, false);\n@@ -975,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 if def.variants.len() == 1 {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert!(!def.is_enum() || hint == attr::ReprAny);\n+\n                     let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n                     });\n@@ -1003,6 +1030,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                 }\n \n+                if def.variants.len() == 1 && hint == attr::ReprAny{\n+                    // Equivalent to a struct/tuple/newtype.\n+                    let fields = def.variants[0].fields.iter().map(|field| {\n+                        field.ty(tcx, substs).layout(infcx)\n+                    });\n+                    let mut st = Struct::new(dl, false);\n+                    st.extend(dl, fields, ty)?;\n+                    return success(Univariant { variant: st, non_zero: false });\n+                }\n+\n                 // Cache the substituted and normalized variant field types.\n                 let variants = def.variants.iter().map(|v| {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()"}, {"sha": "c8fd27f066cac328280d380d6778d3eec46aa3cf", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -608,10 +608,19 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n \n+        let rec_limit = tcx.sess.recursion_limit.get();\n+        let depth = tcx.layout_depth.get();\n+        if depth > rec_limit {\n+            tcx.sess.fatal(\n+                &format!(\"overflow representing the type `{}`\", self));\n+        }\n+\n+        tcx.layout_depth.set(depth+1);\n         let layout = Layout::compute_uncached(self, infcx)?;\n         if can_cache {\n             tcx.layout_cache.borrow_mut().insert(self, layout);\n         }\n+        tcx.layout_depth.set(depth);\n         Ok(layout)\n     }\n "}, {"sha": "683ad76952a7e5a338e66e84e7438248c55146de", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -24,7 +24,7 @@ use cabi_s390x;\n use cabi_mips;\n use cabi_mips64;\n use cabi_asmjs;\n-use machine::{llalign_of_min, llsize_of, llsize_of_real, llsize_of_store};\n+use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n \n@@ -102,7 +102,7 @@ impl ArgType {\n         // Wipe old attributes, likely not valid through indirection.\n         self.attrs = llvm::Attributes::default();\n \n-        let llarg_sz = llsize_of_real(ccx, self.ty);\n+        let llarg_sz = llsize_of_alloc(ccx, self.ty);\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n@@ -200,7 +200,7 @@ impl ArgType {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, llsize_of_store(ccx, self.ty)),\n+                                  C_uint(ccx, llsize_of_alloc(ccx, self.ty)),\n                                   cmp::min(llalign_of_min(ccx, self.ty),\n                                            llalign_of_min(ccx, ty)) as u32);\n \n@@ -327,7 +327,7 @@ impl FnType {\n                 if let Layout::CEnum { signed, .. } = *ccx.layout_of(ty) {\n                     arg.signedness = Some(signed);\n                 }\n-                if llsize_of_real(ccx, arg.ty) == 0 {\n+                if llsize_of_alloc(ccx, arg.ty) == 0 {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments.\n                     // The same is true for s390x-unknown-linux-gnu.\n@@ -358,7 +358,7 @@ impl FnType {\n                 ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n                 ty::TyBox(ty) => {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n-                    let llsz = llsize_of_real(ccx, llty);\n+                    let llsz = llsize_of_alloc(ccx, llty);\n                     ret.attrs.set_dereferenceable(llsz);\n                 }\n                 _ => {}\n@@ -427,7 +427,7 @@ impl FnType {\n             } else {\n                 if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n                     let llty = type_of::sizing_type_of(ccx, inner);\n-                    let llsz = llsize_of_real(ccx, llty);\n+                    let llsz = llsize_of_alloc(ccx, llty);\n                     arg.attrs.set_dereferenceable(llsz);\n                 }\n                 args.push(arg);\n@@ -469,8 +469,8 @@ impl FnType {\n                     return;\n                 }\n \n-                let size = llsize_of_real(ccx, llty);\n-                if size > llsize_of_real(ccx, ccx.int_type()) {\n+                let size = llsize_of_alloc(ccx, llty);\n+                if size > llsize_of_alloc(ccx, ccx.int_type()) {\n                     arg.make_indirect(ccx);\n                 } else if size > 0 {\n                     // We want to pass small aggregates as immediates, but using"}, {"sha": "e3b15c8e2b9dc0898315cb50a0bc1e815a6d7dd9", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 318, "deletions": 740, "changes": 1058, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -45,20 +45,17 @@ pub use self::Repr::*;\n use super::Disr;\n \n use std;\n-use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use syntax::ast;\n+use rustc::ty::layout;\n+use rustc::ty::{self, Ty, AdtKind};\n use syntax::attr;\n use syntax::attr::IntType;\n-use abi::FAT_PTR_ADDR;\n-use base;\n use build::*;\n use common::*;\n use debuginfo::DebugLoc;\n use glue;\n+use base;\n use machine;\n use monomorphize;\n use type_::Type;\n@@ -159,506 +156,33 @@ impl MaybeSizedValue {\n     }\n }\n \n-/// Decides how to represent a given type.\n-pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>)\n-                                -> Rc<Repr<'tcx>> {\n-    debug!(\"Representing: {}\", t);\n-    if let Some(repr) = cx.adt_reprs().borrow().get(&t) {\n-        return repr.clone();\n-    }\n-\n-    let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {:?}\", repr);\n-    cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n-    repr\n-}\n-\n-fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                     t: Ty<'tcx>) -> Repr<'tcx> {\n+//Given an enum, struct, closure, or tuple, extracts fields.\n+//treats closures as a struct with one variant.\n+//`empty_if_no_variants` is a switch to deal with empty enums.\n+//if true, `variant_index` is disregarded and an empty Vec returned in this case.\n+fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                            variant_index: usize,\n+                            empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n     match t.sty {\n-        ty::TyTuple(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t))\n-        }\n-        ty::TyClosure(_, ref substs) => {\n-            Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n-        }\n-        ty::TyAdt(def, substs) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                let ftys = def.struct_variant().fields.iter().map(|field| {\n-                    monomorphize::field_ty(cx.tcx(), substs, field)\n-                }).collect::<Vec<_>>();\n-                let packed = cx.tcx().lookup_packed(def.did);\n-\n-                Univariant(mk_struct(cx, &ftys[..], packed, t))\n-            }\n-            AdtKind::Union => {\n-                let ftys = def.struct_variant().fields.iter().map(|field| {\n-                    monomorphize::field_ty(cx.tcx(), substs, field)\n-                }).collect::<Vec<_>>();\n-                let packed = cx.tcx().lookup_packed(def.did);\n-                UntaggedUnion(mk_union(cx, &ftys[..], packed, t))\n-            }\n-            AdtKind::Enum => {\n-                let cases = get_cases(cx.tcx(), def, substs);\n-                let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n-                    .unwrap_or(&attr::ReprAny);\n-\n-                if cases.is_empty() {\n-                    // Uninhabitable; represent as unit\n-                    // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n-                    return Univariant(mk_struct(cx, &[], false, t));\n-                }\n-\n-                if cases.iter().all(|c| c.tys.is_empty()) {\n-                    // All bodies empty -> intlike\n-                    let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n-                    let bounds = IntBounds {\n-                        ulo: discrs.iter().min().unwrap().0,\n-                        uhi: discrs.iter().max().unwrap().0,\n-                        slo: discrs.iter().map(|n| n.0 as i64).min().unwrap(),\n-                        shi: discrs.iter().map(|n| n.0 as i64).max().unwrap()\n-                    };\n-                    return mk_cenum(cx, hint, &bounds);\n-                }\n-\n-                // Since there's at least one\n-                // non-empty body, explicit discriminants should have\n-                // been rejected by a checker before this point.\n-                if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n-                    bug!(\"non-C-like enum {} with specified discriminants\",\n-                        cx.tcx().item_path_str(def.did));\n-                }\n-\n-                if cases.len() == 1 && hint == attr::ReprAny {\n-                    // Equivalent to a struct or tuple.\n-                    return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n-                }\n-\n-                if cases.len() == 2 && hint == attr::ReprAny {\n-                    // Nullable pointer optimization\n-                    let mut discr = 0;\n-                    while discr < 2 {\n-                        if cases[1 - discr].is_zerolen(cx, t) {\n-                            let st = mk_struct(cx, &cases[discr].tys,\n-                                            false, t);\n-                            match cases[discr].find_ptr(cx) {\n-                                Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n-                                    return RawNullablePointer {\n-                                        nndiscr: Disr::from(discr),\n-                                        nnty: st.fields[0],\n-                                        nullfields: cases[1 - discr].tys.clone()\n-                                    };\n-                                }\n-                                Some(mut discrfield) => {\n-                                    discrfield.push(0);\n-                                    discrfield.reverse();\n-                                    return StructWrappedNullablePointer {\n-                                        nndiscr: Disr::from(discr),\n-                                        nonnull: st,\n-                                        discrfield: discrfield,\n-                                        nullfields: cases[1 - discr].tys.clone()\n-                                    };\n-                                }\n-                                None => {}\n-                            }\n-                        }\n-                        discr += 1;\n-                    }\n-                }\n-\n-                // The general case.\n-                assert!((cases.len() - 1) as i64 >= 0);\n-                let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n-                                        slo: 0, shi: (cases.len() - 1) as i64 };\n-                let min_ity = range_to_inttype(cx, hint, &bounds);\n-\n-                // Create the set of structs that represent each variant\n-                // Use the minimum integer type we figured out above\n-                let fields : Vec<_> = cases.iter().map(|c| {\n-                    let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n-                    ftys.extend_from_slice(&c.tys);\n-                    mk_struct(cx, &ftys, false, t)\n-                }).collect();\n-\n-\n-                // Check to see if we should use a different type for the\n-                // discriminant. If the overall alignment of the type is\n-                // the same as the first field in each variant, we can safely use\n-                // an alignment-sized type.\n-                // We increase the size of the discriminant to avoid LLVM copying\n-                // padding when it doesn't need to. This normally causes unaligned\n-                // load/stores and excessive memcpy/memset operations. By using a\n-                // bigger integer size, LLVM can be sure about it's contents and\n-                // won't be so conservative.\n-                // This check is needed to avoid increasing the size of types when\n-                // the alignment of the first field is smaller than the overall\n-                // alignment of the type.\n-                let (_, align) = union_size_and_align(&fields);\n-                let mut use_align = true;\n-                for st in &fields {\n-                    // Get the first non-zero-sized field\n-                    let field = st.fields.iter().skip(1).filter(|ty| {\n-                        let t = type_of::sizing_type_of(cx, **ty);\n-                        machine::llsize_of_real(cx, t) != 0 ||\n-                        // This case is only relevant for zero-sized types with large alignment\n-                        machine::llalign_of_min(cx, t) != 1\n-                    }).next();\n-\n-                    if let Some(field) = field {\n-                        let field_align = type_of::align_of(cx, *field);\n-                        if field_align != align {\n-                            use_align = false;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                // If the alignment is smaller than the chosen discriminant size, don't use the\n-                // alignment as the final size.\n-                let min_ty = ll_inttype(&cx, min_ity);\n-                let min_size = machine::llsize_of_real(cx, min_ty);\n-                if (align as u64) < min_size {\n-                    use_align = false;\n-                }\n-\n-                let ity = if use_align {\n-                    // Use the overall alignment\n-                    match align {\n-                        1 => attr::UnsignedInt(ast::UintTy::U8),\n-                        2 => attr::UnsignedInt(ast::UintTy::U16),\n-                        4 => attr::UnsignedInt(ast::UintTy::U32),\n-                        8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                            attr::UnsignedInt(ast::UintTy::U64),\n-                        _ => min_ity // use min_ity as a fallback\n-                    }\n-                } else {\n-                    min_ity\n-                };\n-\n-                let fields : Vec<_> = cases.iter().map(|c| {\n-                    let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                    ftys.extend_from_slice(&c.tys);\n-                    mk_struct(cx, &ftys[..], false, t)\n-                }).collect();\n-\n-                ensure_enum_fits_in_address_space(cx, &fields[..], t);\n-\n-                General(ity, fields)\n-            }\n-        },\n-        _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n-    }\n-}\n-\n-// this should probably all be in ty\n-struct Case<'tcx> {\n-    discr: Disr,\n-    tys: Vec<Ty<'tcx>>\n-}\n-\n-/// This represents the (GEP) indices to follow to get to the discriminant field\n-pub type DiscrField = Vec<usize>;\n-\n-fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        ty: Ty<'tcx>,\n-                                        mut path: DiscrField)\n-                                        -> Option<DiscrField> {\n-    match ty.sty {\n-        // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) | ty::TyBox(ty) if !type_is_sized(tcx, ty) => {\n-            path.push(FAT_PTR_ADDR);\n-            Some(path)\n-        },\n-\n-        // Regular thin pointer: &T/&mut T/Box<T>\n-        ty::TyRef(..) | ty::TyBox(..) => Some(path),\n-\n-        // Function pointer: `fn() -> i32`\n-        ty::TyFnPtr(_) => Some(path),\n-\n-        // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::TyAdt(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = &def.struct_variant().fields;\n-            assert_eq!(nonzero_fields.len(), 1);\n-            let field_ty = monomorphize::field_ty(tcx, substs, &nonzero_fields[0]);\n-            match field_ty.sty {\n-                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if !type_is_sized(tcx, ty) => {\n-                    path.extend_from_slice(&[0, FAT_PTR_ADDR]);\n-                    Some(path)\n-                },\n-                ty::TyRawPtr(..) | ty::TyInt(..) | ty::TyUint(..) => {\n-                    path.push(0);\n-                    Some(path)\n-                },\n-                _ => None\n-            }\n-        },\n-\n-        // Perhaps one of the fields of this struct is non-zero\n-        // let's recurse and find out\n-        ty::TyAdt(def, substs) if def.is_struct() => {\n-            for (j, field) in def.struct_variant().fields.iter().enumerate() {\n-                let field_ty = monomorphize::field_ty(tcx, substs, field);\n-                if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n-                    fpath.push(j);\n-                    return Some(fpath);\n-                }\n-            }\n-            None\n+        ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n+            Vec::default()\n         },\n-\n-        // Perhaps one of the upvars of this struct is non-zero\n-        // Let's recurse and find out!\n-        ty::TyClosure(_, ref substs) => {\n-            for (j, &ty) in substs.upvar_tys.iter().enumerate() {\n-                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n-                    fpath.push(j);\n-                    return Some(fpath);\n-                }\n-            }\n-            None\n+        ty::TyAdt(ref def, ref substs) => {\n+            def.variants[variant_index].fields.iter().map(|f| {\n+                monomorphize::field_ty(cx.tcx(), substs, f)\n+            }).collect::<Vec<_>>()\n         },\n-\n-        // Can we use one of the fields in this tuple?\n-        ty::TyTuple(ref tys) => {\n-            for (j, &ty) in tys.iter().enumerate() {\n-                if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n-                    fpath.push(j);\n-                    return Some(fpath);\n-                }\n-            }\n-            None\n-        },\n-\n-        // Is this a fixed-size array of something non-zero\n-        // with at least one element?\n-        ty::TyArray(ety, d) if d > 0 => {\n-            if let Some(mut vpath) = find_discr_field_candidate(tcx, ety, path) {\n-                vpath.push(0);\n-                Some(vpath)\n-            } else {\n-                None\n-            }\n+        ty::TyTuple(fields) => fields.to_vec(),\n+        ty::TyClosure(_, substs) => {\n+            if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n+            substs.upvar_tys.to_vec()\n         },\n-\n-        // Anything else is not a pointer\n-        _ => None\n-    }\n-}\n-\n-impl<'tcx> Case<'tcx> {\n-    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, &self.tys, false, scapegoat).size == 0\n-    }\n-\n-    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n-        for (i, &ty) in self.tys.iter().enumerate() {\n-            if let Some(mut path) = find_discr_field_candidate(cx.tcx(), ty, vec![]) {\n-                path.push(i);\n-                return Some(path);\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       adt: ty::AdtDef<'tcx>,\n-                       substs: &Substs<'tcx>)\n-                       -> Vec<Case<'tcx>> {\n-    adt.variants.iter().map(|vi| {\n-        let field_tys = vi.fields.iter().map(|field| {\n-            monomorphize::field_ty(tcx, substs, field)\n-        }).collect();\n-        Case { discr: Disr::from(vi.disr_val), tys: field_tys }\n-    }).collect()\n-}\n-\n-fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                       tys: &[Ty<'tcx>], packed: bool,\n-                       scapegoat: Ty<'tcx>)\n-                       -> Struct<'tcx> {\n-    let sized = tys.iter().all(|&ty| type_is_sized(cx.tcx(), ty));\n-    let lltys : Vec<Type> = if sized {\n-        tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n-    } else {\n-        tys.iter().filter(|&ty| type_is_sized(cx.tcx(), *ty))\n-           .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n-    };\n-\n-    ensure_struct_fits_in_address_space(cx, &lltys[..], packed, scapegoat);\n-\n-    let llty_rec = Type::struct_(cx, &lltys[..], packed);\n-    Struct {\n-        size: machine::llsize_of_alloc(cx, llty_rec),\n-        align: machine::llalign_of_min(cx, llty_rec),\n-        sized: sized,\n-        packed: packed,\n-        fields: tys.to_vec(),\n-    }\n-}\n-\n-fn mk_union<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                      tys: &[Ty<'tcx>], packed: bool,\n-                      _scapegoat: Ty<'tcx>)\n-                      -> Union<'tcx> {\n-    let mut min_size = 0;\n-    let mut align = 0;\n-    for llty in tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)) {\n-        let field_size = machine::llsize_of_alloc(cx, llty);\n-        if min_size < field_size {\n-            min_size = field_size;\n-        }\n-        let field_align = machine::llalign_of_min(cx, llty);\n-        if align < field_align {\n-            align = field_align;\n-        }\n-    }\n-\n-    Union {\n-        min_size: min_size,\n-        align: if packed { 1 } else { align },\n-        packed: packed,\n-        fields: tys.to_vec(),\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct IntBounds {\n-    slo: i64,\n-    shi: i64,\n-    ulo: u64,\n-    uhi: u64\n-}\n-\n-fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                      hint: Hint, bounds: &IntBounds)\n-                      -> Repr<'tcx> {\n-    let it = range_to_inttype(cx, hint, bounds);\n-    match it {\n-        attr::SignedInt(_) => CEnum(it, Disr(bounds.slo as u64), Disr(bounds.shi as u64)),\n-        attr::UnsignedInt(_) => CEnum(it, Disr(bounds.ulo), Disr(bounds.uhi))\n-    }\n-}\n-\n-fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n-    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n-    // Lists of sizes to try.  u64 is always allowed as a fallback.\n-    #[allow(non_upper_case_globals)]\n-    const choose_shortest: &'static [IntType] = &[\n-        attr::UnsignedInt(ast::UintTy::U8), attr::SignedInt(ast::IntTy::I8),\n-        attr::UnsignedInt(ast::UintTy::U16), attr::SignedInt(ast::IntTy::I16),\n-        attr::UnsignedInt(ast::UintTy::U32), attr::SignedInt(ast::IntTy::I32)];\n-    #[allow(non_upper_case_globals)]\n-    const at_least_32: &'static [IntType] = &[\n-        attr::UnsignedInt(ast::UintTy::U32), attr::SignedInt(ast::IntTy::I32)];\n-\n-    let attempts;\n-    match hint {\n-        attr::ReprInt(ity) => {\n-            if !bounds_usable(cx, ity, bounds) {\n-                bug!(\"representation hint insufficient for discriminant range\")\n-            }\n-            return ity;\n-        }\n-        attr::ReprExtern => {\n-            attempts = match &cx.sess().target.target.arch[..] {\n-                // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n-                // appears to be used on Linux and NetBSD, but some systems may use the variant\n-                // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n-                \"arm\" => at_least_32,\n-                _ => at_least_32,\n-            }\n-        }\n-        attr::ReprAny => {\n-            attempts = choose_shortest;\n-        },\n-        attr::ReprPacked => {\n-            bug!(\"range_to_inttype: found ReprPacked on an enum\");\n-        }\n-        attr::ReprSimd => {\n-            bug!(\"range_to_inttype: found ReprSimd on an enum\");\n-        }\n-    }\n-    for &ity in attempts {\n-        if bounds_usable(cx, ity, bounds) {\n-            return ity;\n-        }\n-    }\n-    return attr::UnsignedInt(ast::UintTy::U64);\n-}\n-\n-pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n-    match ity {\n-        attr::SignedInt(t) => Type::int_from_ty(cx, t),\n-        attr::UnsignedInt(t) => Type::uint_from_ty(cx, t)\n-    }\n-}\n-\n-fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n-    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n-    match ity {\n-        attr::SignedInt(_) => {\n-            let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n-            let llhi = C_integral(ll_inttype(cx, ity), bounds.shi as u64, true);\n-            bounds.slo == const_to_int(lllo) as i64 && bounds.shi == const_to_int(llhi) as i64\n-        }\n-        attr::UnsignedInt(_) => {\n-            let lllo = C_integral(ll_inttype(cx, ity), bounds.ulo, false);\n-            let llhi = C_integral(ll_inttype(cx, ity), bounds.uhi, false);\n-            bounds.ulo == const_to_uint(lllo) as u64 && bounds.uhi == const_to_uint(llhi) as u64\n-        }\n-    }\n-}\n-\n-pub fn ty_of_inttype<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ity: IntType) -> Ty<'tcx> {\n-    match ity {\n-        attr::SignedInt(t) => tcx.mk_mach_int(t),\n-        attr::UnsignedInt(t) => tcx.mk_mach_uint(t)\n-    }\n-}\n-\n-// LLVM doesn't like types that don't fit in the address space\n-fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                 fields: &[Type],\n-                                                 packed: bool,\n-                                                 scapegoat: Ty<'tcx>) {\n-    let mut offset = 0;\n-    for &llty in fields {\n-        // Invariant: offset < ccx.obj_size_bound() <= 1<<61\n-        if !packed {\n-            let type_align = machine::llalign_of_min(ccx, llty);\n-            offset = roundup(offset, type_align);\n-        }\n-        // type_align is a power-of-2, so still offset < ccx.obj_size_bound()\n-        // llsize_of_alloc(ccx, llty) is also less than ccx.obj_size_bound()\n-        // so the sum is less than 1<<62 (and therefore can't overflow).\n-        offset += machine::llsize_of_alloc(ccx, llty);\n-\n-        if offset >= ccx.obj_size_bound() {\n-            ccx.report_overbig_object(scapegoat);\n-        }\n-    }\n-}\n-\n-fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n-    let size = sts.iter().map(|st| st.size).max().unwrap();\n-    let align = sts.iter().map(|st| st.align).max().unwrap();\n-    (roundup(size, align), align)\n-}\n-\n-fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               fields: &[Struct],\n-                                               scapegoat: Ty<'tcx>) {\n-    let (total_size, _) = union_size_and_align(fields);\n-\n-    if total_size >= ccx.obj_size_bound() {\n-        ccx.report_overbig_object(scapegoat);\n+        _ => bug!(\"{} is not a type that can have fields.\", t)\n     }\n }\n \n+/// This represents the (GEP) indices to follow to get to the discriminant field\n+pub type DiscrField = Vec<usize>;\n \n /// LLVM-level types are a little complicated.\n ///\n@@ -668,62 +192,89 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// For nominal types, in some cases, we need to use LLVM named structs\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n-    generic_type_of(cx, r, None, false, false)\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+    generic_type_of(cx, t, None, false, false)\n }\n \n \n // Pass dst=true if the type you are passing is a DST. Yes, we could figure\n // this out, but if you call this on an unsized type without realising it, you\n // are going to get the wrong type (it will not include the unsized parts of it).\n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                r: &Repr<'tcx>, dst: bool) -> Type {\n-    generic_type_of(cx, r, None, true, dst)\n+                                t: Ty<'tcx>, dst: bool) -> Type {\n+    generic_type_of(cx, t, None, true, dst)\n }\n \n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                    r: &Repr<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, r, Some(name), false, false)\n+                                    t: Ty<'tcx>, name: &str) -> Type {\n+    generic_type_of(cx, t, Some(name), false, false)\n }\n \n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                r: &Repr<'tcx>, llty: &mut Type) {\n-    match *r {\n-        CEnum(..) | General(..) | UntaggedUnion(..) | RawNullablePointer { .. } => { }\n-        Univariant(ref st) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(&struct_llfields(cx, st, false, false),\n-                                 st.packed)\n+                                t: Ty<'tcx>, llty: &mut Type) {\n+    let l = cx.layout_of(t);\n+    debug!(\"finish_type_of: {} with layout {:#?}\", t, l);\n+    match *l {\n+        layout::CEnum { .. } | layout::General { .. }\n+        | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n+        layout::Univariant { ..}\n+        | layout::StructWrappedNullablePointer { .. }\n+        | layout::Vector { .. } => {\n+            let (nonnull_variant, packed) = match *l {\n+                layout::Univariant { ref variant, .. } => (0, variant.packed),\n+                layout::Vector { .. } => (0, true),\n+                layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n+                    (nndiscr, nonnull.packed),\n+                _ => unreachable!()\n+            };\n+            let fields = compute_fields(cx, t, nonnull_variant as usize, true);\n+            llty.set_struct_body(&struct_llfields(cx, &fields, false, false),\n+                                 packed)\n+        },\n+        _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n     }\n }\n \n fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                             r: &Repr<'tcx>,\n+                             t: Ty<'tcx>,\n                              name: Option<&str>,\n                              sizing: bool,\n                              dst: bool) -> Type {\n-    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {}\",\n-           r, name, sizing, dst);\n-    match *r {\n-        CEnum(ity, ..) => ll_inttype(cx, ity),\n-        RawNullablePointer { nnty, .. } =>\n-            type_of::sizing_type_of(cx, nnty),\n-        StructWrappedNullablePointer { nonnull: ref st, .. } => {\n+    let l = cx.layout_of(t);\n+    debug!(\"adt::generic_type_of t: {:?} name: {:?} sizing: {} dst: {}\",\n+           t, name, sizing, dst);\n+    match *l {\n+        layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let (def, substs) = match t.sty {\n+                ty::TyAdt(d, s) => (d, s),\n+                _ => bug!(\"{} is not an ADT\", t)\n+            };\n+            let nnty = monomorphize::field_ty(cx.tcx(), substs,\n+                &def.variants[nndiscr as usize].fields[0]);\n+            type_of::sizing_type_of(cx, nnty)\n+        }\n+        layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+            let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n-                                  st.packed)\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, sizing, dst),\n+                                  nonnull.packed)\n                 }\n                 Some(name) => {\n                     assert_eq!(sizing, false);\n                     Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        Univariant(ref st) => {\n+        layout::Univariant { ref variant, .. } => {\n+            //note that this case also handles empty enums.\n+            //Thus the true as the final parameter here.\n+            let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, st, sizing, dst);\n-                    Type::struct_(cx, &fields, st.packed)\n+                    let fields = struct_llfields(cx, &fields, sizing, dst);\n+                    Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n@@ -733,35 +284,27 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        UntaggedUnion(ref un) => {\n+        layout::Vector { element, count } => {\n+            let elem_ty = Type::from_primitive(cx, element);\n+            Type::vector(&elem_ty, count)\n+        }\n+        layout::UntaggedUnion { ref variants, .. }=> {\n             // Use alignment-sized ints to fill all the union storage.\n-            let (size, align) = (roundup(un.min_size, un.align), un.align);\n-\n-            let align_s = align as u64;\n-            assert_eq!(size % align_s, 0); // Ensure division in align_units comes out evenly\n-            let align_units = size / align_s;\n-            let fill_ty = match align_s {\n-                1 => Type::array(&Type::i8(cx), align_units),\n-                2 => Type::array(&Type::i16(cx), align_units),\n-                4 => Type::array(&Type::i32(cx), align_units),\n-                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                                 Type::array(&Type::i64(cx), align_units),\n-                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n-                                                              align_units),\n-                _ => bug!(\"unsupported union alignment: {}\", align)\n-            };\n+            let size = variants.stride().bytes();\n+            let align = variants.align.abi();\n+            let fill = union_fill(cx, size, align);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill_ty], un.packed)\n+                    Type::struct_(cx, &[fill], variants.packed)\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill_ty], un.packed);\n+                    llty.set_struct_body(&[fill], variants.packed);\n                     llty\n                 }\n             }\n         }\n-        General(ity, ref sts) => {\n+        layout::General { discr, size, align, .. } => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -774,29 +317,20 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(&sts[..]);\n-            let align_s = align as u64;\n-            let discr_ty = ll_inttype(cx, ity);\n-            let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n-            let padded_discr_size = roundup(discr_size, align);\n-            assert_eq!(size % align_s, 0); // Ensure division in align_units comes out evenly\n-            let align_units = (size - padded_discr_size) / align_s;\n-            let fill_ty = match align_s {\n-                1 => Type::array(&Type::i8(cx), align_units),\n-                2 => Type::array(&Type::i16(cx), align_units),\n-                4 => Type::array(&Type::i32(cx), align_units),\n-                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                                 Type::array(&Type::i64(cx), align_units),\n-                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n-                                                              align_units),\n-                _ => bug!(\"unsupported enum alignment: {}\", align)\n-            };\n-            assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n+            let size = size.bytes();\n+            let align = align.abi();\n+            let discr_ty = Type::from_integer(cx, discr);\n+            let discr_size = discr.size().bytes();\n+            let padded_discr_size = roundup(discr_size, align as u32);\n+            let variant_part_size = size-padded_discr_size;\n+            let variant_fill = union_fill(cx, variant_part_size, align);\n+\n+            assert_eq!(machine::llalign_of_min(cx, variant_fill), align as u32);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n             let fields: Vec<Type> =\n                 [discr_ty,\n                  Type::array(&discr_ty, (padded_discr_size - discr_size)/discr_size),\n-                 fill_ty].iter().cloned().collect();\n+                 variant_fill].iter().cloned().collect();\n             match name {\n                 None => {\n                     Type::struct_(cx, &fields[..], false)\n@@ -808,100 +342,127 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n+        _ => bug!(\"Unsupported type {} represented as {:#?}\", t, l)\n+    }\n+}\n+\n+fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n+    assert_eq!(size%align, 0);\n+    let align_units = size/align;\n+    match align {\n+        1 => Type::array(&Type::i8(cx), align_units),\n+        2 => Type::array(&Type::i16(cx), align_units),\n+        4 => Type::array(&Type::i32(cx), align_units),\n+        8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                         Type::array(&Type::i64(cx), align_units),\n+        a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n+                                                      align_units),\n+        _ => bug!(\"unsupported union alignment: {}\", align)\n     }\n }\n \n-fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n+\n+fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n                              sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n+        fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        st.fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n }\n \n /// Obtain a representation of the discriminant sufficient to translate\n /// destructuring; this may or may not involve the actual discriminant.\n pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                r: &Repr<'tcx>,\n+                                t: Ty<'tcx>,\n                                 scrutinee: ValueRef,\n                                 range_assert: bool)\n                                 -> (BranchKind, Option<ValueRef>) {\n-    match *r {\n-        CEnum(..) | General(..) |\n-        RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            (BranchKind::Switch, Some(trans_get_discr(bcx, r, scrutinee, None, range_assert)))\n+    let l = bcx.ccx().layout_of(t);\n+    match *l {\n+        layout::CEnum { .. } | layout::General { .. } |\n+        layout::RawNullablePointer { .. } | layout::StructWrappedNullablePointer { .. } => {\n+            (BranchKind::Switch, Some(trans_get_discr(bcx, t, scrutinee, None, range_assert)))\n         }\n-        Univariant(..) | UntaggedUnion(..) => {\n+        layout::Univariant { .. } | layout::UntaggedUnion { .. } => {\n             // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n             (BranchKind::Single, None)\n-        }\n+        },\n+        _ => bug!(\"{} is not an enum.\", t)\n     }\n }\n \n-pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n-    match *r {\n-        CEnum(ity, ..) => ity.is_signed(),\n-        General(ity, _) => ity.is_signed(),\n-        Univariant(..) | UntaggedUnion(..) => false,\n-        RawNullablePointer { .. } => false,\n-        StructWrappedNullablePointer { .. } => false,\n+pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n+    match *l {\n+        layout::CEnum { signed, .. }=> signed,\n+        _ => false,\n     }\n }\n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n                                    scrutinee: ValueRef, cast_to: Option<Type>,\n                                    range_assert: bool)\n     -> ValueRef {\n-    debug!(\"trans_get_discr r: {:?}\", r);\n-    let val = match *r {\n-        CEnum(ity, min, max) => {\n-            load_discr(bcx, ity, scrutinee, min, max, range_assert)\n+    let (def, substs) = match t.sty {\n+        ty::TyAdt(ref def, substs) if def.adt_kind() == AdtKind::Enum => (def, substs),\n+        _ => bug!(\"{} is not an enum\", t)\n+    };\n+\n+    debug!(\"trans_get_discr t: {:?}\", t);\n+    let l = bcx.ccx().layout_of(t);\n+\n+    let val = match *l {\n+        layout::CEnum { discr, min, max, .. } => {\n+            load_discr(bcx, discr, scrutinee, min, max, range_assert)\n         }\n-        General(ity, ref cases) => {\n+        layout::General { discr, .. } => {\n             let ptr = StructGEP(bcx, scrutinee, 0);\n-            load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n+            load_discr(bcx, discr, ptr, 0, def.variants.len() as u64 - 1,\n                        range_assert)\n         }\n-        Univariant(..) | UntaggedUnion(..) => C_u8(bcx.ccx(), 0),\n-        RawNullablePointer { nndiscr, nnty, .. } =>  {\n-            let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n-            let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n+        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx(), 0),\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+            let llptrty = type_of::sizing_type_of(bcx.ccx(),\n+                monomorphize::field_ty(bcx.ccx().tcx(), substs,\n+                &def.variants[nndiscr as usize].fields[0]));\n             ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None)\n         }\n-        StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee)\n-        }\n+        },\n+        _ => bug!(\"{} is not an enum\", t)\n     };\n     match cast_to {\n         None => val,\n-        Some(llty) => if is_discr_signed(r) { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n+        Some(llty) => if is_discr_signed(&l) { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n+fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: u64, discrfield: &layout::FieldPath,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, &discrfield[..]);\n+    let llptrptr = GEPi(bcx, scrutinee,\n+        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>()[..]);\n     let llptr = Load(bcx, llptrptr);\n-    let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n+    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr,\n+fn load_discr(bcx: Block, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n-    let llty = ll_inttype(bcx.ccx(), ity);\n+    let llty = Type::from_integer(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n-    let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n+    let bits = ity.size().bits();\n     assert!(bits <= 64);\n     let bits = bits as usize;\n-    let mask = Disr(!0u64 >> (64 - bits));\n+    let mask = !0u64 >> (64 - bits);\n     // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n     // However, that is fine here (it would still represent the full range),\n-    if max.wrapping_add(Disr(1)) & mask == min & mask || !range_assert {\n+    if max.wrapping_add(1) & mask == min & mask || !range_assert {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -910,132 +471,141 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr,\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min.0, max.0.wrapping_add(1), /* signed: */ True)\n+        LoadRangeAssert(bcx, ptr, min, max.wrapping_add(1), /* signed: */ True)\n     }\n }\n \n /// Yield information about how to dispatch a case of the\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n+pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, value: Disr)\n                               -> ValueRef {\n-    match *r {\n-        CEnum(ity, ..) => {\n-            C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n-        }\n-        General(ity, _) => {\n-            C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n+    let l = bcx.ccx().layout_of(t);\n+    match *l {\n+        layout::CEnum { discr, .. }\n+        | layout::General { discr, .. }=> {\n+            C_integral(Type::from_integer(bcx.ccx(), discr), value.0, true)\n         }\n-        Univariant(..) | UntaggedUnion(..) => {\n-            bug!(\"no cases for univariants, structs or unions\")\n+        layout::RawNullablePointer { .. } |\n+layout::StructWrappedNullablePointer { .. } => {\n+            assert!(value == Disr(0) || value == Disr(1));\n+            C_bool(bcx.ccx(), value != Disr(0))\n         }\n-        RawNullablePointer { .. } |\n-        StructWrappedNullablePointer { .. } => {\n-            assert!(discr == Disr(0) || discr == Disr(1));\n-            C_bool(bcx.ccx(), discr != Disr(0))\n+        _ => {\n+            bug!(\"{} does not have a discriminant. Represented as {:#?}\", t, l);\n         }\n     }\n }\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n-                                   val: ValueRef, discr: Disr) {\n-    match *r {\n-        CEnum(ity, min, max) => {\n-            assert_discr_in_range(ity, min, max, discr);\n-            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n+pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n+                                   val: ValueRef, to: Disr) {\n+    let l = bcx.ccx().layout_of(t);\n+    match *l {\n+        layout::CEnum{ discr, min, max, .. } => {\n+            assert_discr_in_range(Disr(min), Disr(max), to);\n+            Store(bcx, C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n                   val);\n         }\n-        General(ity, _) => {\n-            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n+        layout::General{ discr, .. } => {\n+            Store(bcx, C_integral(Type::from_integer(bcx.ccx(), discr), to.0, true),\n                   StructGEP(bcx, val, 0));\n         }\n-        Univariant(_) => {\n-            assert_eq!(discr, Disr(0));\n-        }\n-        UntaggedUnion(..) => {\n-            assert_eq!(discr, Disr(0));\n+        layout::Univariant { .. }\n+        | layout::UntaggedUnion { .. }\n+        | layout::Vector { .. } => {\n+            assert_eq!(to, Disr(0));\n         }\n-        RawNullablePointer { nndiscr, nnty, ..} => {\n-            if discr != nndiscr {\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n+            if to.0 != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n                 Store(bcx, C_null(llptrty), val);\n             }\n         }\n-        StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-            if discr != nndiscr {\n+        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n+            if to.0 != nndiscr {\n                 if target_sets_discr_via_memset(bcx) {\n                     // Issue #34427: As workaround for LLVM bug on\n                     // ARM, use memset of 0 on whole struct rather\n                     // than storing null to single target field.\n                     let b = B(bcx);\n                     let llptr = b.pointercast(val, Type::i8(b.ccx).ptr_to());\n                     let fill_byte = C_u8(b.ccx, 0);\n-                    let size = C_uint(b.ccx, nonnull.size);\n-                    let align = C_i32(b.ccx, nonnull.align as i32);\n+                    let size = C_uint(b.ccx, nonnull.stride().bytes());\n+                    let align = C_i32(b.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(&b, llptr, fill_byte, size, align, false);\n                 } else {\n-                    let llptrptr = GEPi(bcx, val, &discrfield[..]);\n+                    let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n+                    let llptrptr = GEPi(bcx, val, &path[..]);\n                     let llptrty = val_ty(llptrptr).element_type();\n                     Store(bcx, C_null(llptrty), llptrptr);\n                 }\n             }\n         }\n+        _ => bug!(\"Cannot handle {} represented as {:#?}\", t, l)\n     }\n }\n \n fn target_sets_discr_via_memset<'blk, 'tcx>(bcx: Block<'blk, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n-    match ity {\n-        attr::UnsignedInt(_) => {\n-            assert!(min <= discr);\n-            assert!(discr <= max);\n-        },\n-        attr::SignedInt(_) => {\n-            assert!(min.0 as i64 <= discr.0 as i64);\n-            assert!(discr.0 as i64 <= max.0 as i64);\n-        },\n+fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+    if min <= max {\n+        assert!(min <= discr && discr <= max)\n+    } else {\n+        assert!(min <= discr || discr <= max)\n     }\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>,\n                                    val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n-    trans_field_ptr_builder(&bcx.build(), r, val, discr, ix)\n+    trans_field_ptr_builder(&bcx.build(), t, val, discr, ix)\n }\n \n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                           r: &Repr<'tcx>,\n+                                           t: Ty<'tcx>,\n                                            val: MaybeSizedValue,\n                                            discr: Disr, ix: usize)\n                                            -> ValueRef {\n+    let l = bcx.ccx().layout_of(t);\n+    debug!(\"trans_field_ptr_builder on {} represented as {:#?}\", t, l);\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n-    match *r {\n-        CEnum(..) => {\n-            bug!(\"element access in C-like enum\")\n-        }\n-        Univariant(ref st) => {\n+    match *l {\n+        layout::Univariant { ref variant, .. } => {\n             assert_eq!(discr, Disr(0));\n-            struct_field_ptr(bcx, st, val, ix, false)\n-        }\n-        General(_, ref cases) => {\n-            struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n-        }\n-        UntaggedUnion(ref un) => {\n-            let ty = type_of::in_memory_type_of(bcx.ccx(), un.fields[ix]);\n+            struct_field_ptr(bcx, &variant,\n+             &compute_fields(bcx.ccx(), t, 0, false),\n+             val, ix, false)\n+        }\n+        layout::Vector { count, .. } => {\n+            assert_eq!(discr.0, 0);\n+            assert!((ix as u64) < count);\n+            bcx.struct_gep(val.value, ix)\n+        }\n+        layout::General { discr: d, ref variants, .. } => {\n+            let mut fields = compute_fields(bcx.ccx(), t, discr.0 as usize, false);\n+            fields.insert(0, d.to_ty(&bcx.ccx().tcx(), false));\n+            struct_field_ptr(bcx, &variants[discr.0 as usize],\n+             &fields,\n+             val, ix + 1, true)\n+        }\n+        layout::UntaggedUnion { .. } => {\n+            let fields = compute_fields(bcx.ccx(), t, 0, false);\n+            let ty = type_of::in_memory_type_of(bcx.ccx(), fields[ix]);\n             if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n-        RawNullablePointer { nndiscr, ref nullfields, .. } |\n-        StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n+        layout::RawNullablePointer { nndiscr, .. } |\n+        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n+            let nullfields = compute_fields(bcx.ccx(), t, (1-nndiscr) as usize, false);\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n             let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n@@ -1045,32 +615,36 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n-        RawNullablePointer { nndiscr, nnty, .. } => {\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = compute_fields(bcx.ccx(), t, nndiscr as usize, false)[0];\n             assert_eq!(ix, 0);\n-            assert_eq!(discr, nndiscr);\n+            assert_eq!(discr.0, nndiscr);\n             let ty = type_of::type_of(bcx.ccx(), nnty);\n             if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n             bcx.pointercast(val.value, ty.ptr_to())\n         }\n-        StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            assert_eq!(discr, nndiscr);\n-            struct_field_ptr(bcx, nonnull, val, ix, false)\n+        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            assert_eq!(discr.0, nndiscr);\n+            struct_field_ptr(bcx, &nonnull,\n+             &compute_fields(bcx.ccx(), t, discr.0 as usize, false),\n+             val, ix, false)\n         }\n+        _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n     }\n }\n \n fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                st: &Struct<'tcx>, val: MaybeSizedValue,\n+                                st: &layout::Struct, fields: &Vec<Ty<'tcx>>, val: MaybeSizedValue,\n                                 ix: usize, needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n-    let fty = st.fields[ix];\n+    let fty = fields[ix];\n     let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n     if bcx.is_unreachable() {\n         return C_undef(ll_fty.ptr_to());\n     }\n \n     let ptr_val = if needs_cast {\n-        let fields = st.fields.iter().map(|&ty| {\n+        let fields = fields.iter().map(|&ty| {\n             type_of::in_memory_type_of(ccx, ty)\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n@@ -1124,7 +698,7 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n     // Calculate the unaligned offset of the unsized field.\n     let mut offset = 0;\n-    for &ty in &st.fields[0..ix] {\n+    for &ty in &fields[0..ix] {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = type_of::align_of(ccx, ty);\n         offset = roundup(offset, type_align);\n@@ -1177,82 +751,76 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n /// Currently the returned value has the same size as the type, but\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n-pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr: Disr,\n+pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: Disr,\n                              vals: &[ValueRef]) -> ValueRef {\n-    match *r {\n-        CEnum(ity, min, max) => {\n+    let l = ccx.layout_of(t);\n+    let dl = &ccx.tcx().data_layout;\n+    match *l {\n+        layout::CEnum { discr: d, min, max, .. } => {\n             assert_eq!(vals.len(), 0);\n-            assert_discr_in_range(ity, min, max, discr);\n-            C_integral(ll_inttype(ccx, ity), discr.0, true)\n-        }\n-        General(ity, ref cases) => {\n-            let case = &cases[discr.0 as usize];\n-            let (max_sz, _) = union_size_and_align(&cases[..]);\n-            let lldiscr = C_integral(ll_inttype(ccx, ity), discr.0 as u64, true);\n-            let mut f = vec![lldiscr];\n-            f.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, case, &f[..]);\n-            contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n+            assert_discr_in_range(Disr(min), Disr(max), discr);\n+            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+        }\n+        layout::General { discr: d, ref variants, .. } => {\n+            let variant = &variants[discr.0 as usize];\n+            let lldiscr = C_integral(Type::from_integer(ccx, d), discr.0 as u64, true);\n+            let mut vals_with_discr = vec![lldiscr];\n+            vals_with_discr.extend_from_slice(vals);\n+            let mut contents = build_const_struct(ccx, &variant.offset_after_field[..],\n+                &vals_with_discr[..], variant.packed);\n+            let needed_padding = l.size(dl).bytes() - variant.min_size().bytes();\n+            if needed_padding > 0 {\n+                contents.push(padding(ccx, needed_padding));\n+            }\n             C_struct(ccx, &contents[..], false)\n         }\n-        UntaggedUnion(ref un) => {\n+        layout::UntaggedUnion { ref variants, .. }=> {\n             assert_eq!(discr, Disr(0));\n-            let contents = build_const_union(ccx, un, vals[0]);\n-            C_struct(ccx, &contents, un.packed)\n+            let contents = build_const_union(ccx, variants, vals[0]);\n+            C_struct(ccx, &contents, variants.packed)\n         }\n-        Univariant(ref st) => {\n+        layout::Univariant { ref variant, .. } => {\n             assert_eq!(discr, Disr(0));\n-            let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, &contents[..], st.packed)\n+            let contents = build_const_struct(ccx,\n+                &variant.offset_after_field[..], vals, variant.packed);\n+            C_struct(ccx, &contents[..], variant.packed)\n+        }\n+        layout::Vector { .. } => {\n+            C_vector(vals)\n         }\n-        RawNullablePointer { nndiscr, nnty, .. } => {\n-            if discr == nndiscr {\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = compute_fields(ccx, t, nndiscr as usize, false)[0];\n+            if discr.0 == nndiscr {\n                 assert_eq!(vals.len(), 1);\n                 vals[0]\n             } else {\n                 C_null(type_of::sizing_type_of(ccx, nnty))\n             }\n         }\n-        StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            if discr == nndiscr {\n+        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            if discr.0 == nndiscr {\n                 C_struct(ccx, &build_const_struct(ccx,\n-                                                 nonnull,\n-                                                 vals),\n+                                                 &nonnull.offset_after_field[..],\n+                                                 vals, nonnull.packed),\n                          false)\n             } else {\n-                let vals = nonnull.fields.iter().map(|&ty| {\n+                let fields = compute_fields(ccx, t, nndiscr as usize, false);\n+                let vals = fields.iter().map(|&ty| {\n                     // Always use null even if it's not the `discrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, &build_const_struct(ccx,\n-                                                 nonnull,\n-                                                 &vals[..]),\n+                                                 &nonnull.offset_after_field[..],\n+                                                 &vals[..],\n+                                                 false),\n                          false)\n             }\n         }\n+        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n     }\n }\n \n-/// Compute struct field offsets relative to struct begin.\n-fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                          st: &Struct<'tcx>) -> Vec<u64> {\n-    let mut offsets = vec!();\n-\n-    let mut offset = 0;\n-    for &ty in &st.fields {\n-        let llty = type_of::sizing_type_of(ccx, ty);\n-        if !st.packed {\n-            let type_align = type_of::align_of(ccx, ty);\n-            offset = roundup(offset, type_align);\n-        }\n-        offsets.push(offset);\n-        offset += machine::llsize_of_alloc(ccx, llty);\n-    }\n-    assert_eq!(st.fields.len(), offsets.len());\n-    offsets\n-}\n-\n /// Building structs is a little complicated, because we might need to\n /// insert padding if a field's value is less aligned than its type.\n ///\n@@ -1262,45 +830,52 @@ fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                st: &Struct<'tcx>, vals: &[ValueRef])\n+                                offset_after_field: &[layout::Size],\n+                                vals: &[ValueRef],\n+                                packed: bool)\n                                 -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), st.fields.len());\n+    assert_eq!(vals.len(), offset_after_field.len());\n \n-    let target_offsets = compute_struct_field_offsets(ccx, st);\n+    if vals.len() == 0 {\n+        return Vec::new();\n+    }\n \n     // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    for (&val, target_offset) in vals.iter().zip(target_offsets) {\n-        if !st.packed {\n+    for (&val, target_offset) in\n+        vals.iter().zip(\n+        offset_after_field.iter().map(|i| i.bytes())\n+    ) {\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n+        if !packed {\n             let val_align = machine::llalign_of_min(ccx, val_ty(val));\n             offset = roundup(offset, val_align);\n         }\n         if offset != target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n         }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n     }\n \n-    assert!(st.sized && offset <= st.size);\n-    if offset != st.size {\n-        cfields.push(padding(ccx, st.size - offset));\n+    let size = offset_after_field.last().unwrap();\n+    if offset < size.bytes() {\n+        cfields.push(padding(ccx, size.bytes() - offset));\n     }\n \n     cfields\n }\n \n fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &Union<'tcx>,\n+                               un: &layout::Union,\n                                field_val: ValueRef)\n                                -> Vec<ValueRef> {\n     let mut cfields = vec![field_val];\n \n     let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = roundup(un.min_size, un.align);\n+    let size = un.stride().bytes();\n     if offset != size {\n         cfields.push(padding(ccx, size - offset));\n     }\n@@ -1321,18 +896,21 @@ fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n ///\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n-pub fn const_get_field(r: &Repr, val: ValueRef, _discr: Disr,\n+pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                       val: ValueRef, _discr: Disr,\n                        ix: usize) -> ValueRef {\n-    match *r {\n-        CEnum(..) => bug!(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(val, ix),\n-        UntaggedUnion(..) => const_struct_field(val, 0),\n-        General(..) => const_struct_field(val, ix + 1),\n-        RawNullablePointer { .. } => {\n+    let l = ccx.layout_of(t);\n+    match *l {\n+        layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n+        layout::Univariant { .. } | layout::Vector { .. } => const_struct_field(val, ix),\n+        layout::UntaggedUnion { .. } => const_struct_field(val, 0),\n+        layout::General { .. } => const_struct_field(val, ix + 1),\n+        layout::RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         },\n-        StructWrappedNullablePointer{ .. } => const_struct_field(val, ix)\n+        layout::StructWrappedNullablePointer{ .. } => const_struct_field(val, ix),\n+        _ => bug!(\"{} does not have fields.\", t)\n     }\n }\n "}, {"sha": "446042b839ad398a20084f28a054790e54f55532", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -466,32 +466,27 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             store_fat_ptr(bcx, base, info, dst, dst_ty);\n         }\n \n-        // This can be extended to enums and tuples in the future.\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+        (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n-            let src_fields = match &*src_repr {\n-                &adt::Repr::Univariant(ref s) => &s.fields,\n-                _ => bug!(\"struct has non-univariant repr\"),\n-            };\n-            let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n-            let dst_fields = match &*dst_repr {\n-                &adt::Repr::Univariant(ref s) => &s.fields,\n-                _ => bug!(\"struct has non-univariant repr\"),\n-            };\n+            let src_fields = def_a.variants[0].fields.iter().map(|f| {\n+                monomorphize::field_ty(bcx.tcx(), substs_a, f)\n+            });\n+            let dst_fields = def_b.variants[0].fields.iter().map(|f| {\n+                monomorphize::field_ty(bcx.tcx(), substs_b, f)\n+            });\n \n             let src = adt::MaybeSizedValue::sized(src);\n             let dst = adt::MaybeSizedValue::sized(dst);\n \n-            let iter = src_fields.iter().zip(dst_fields).enumerate();\n+            let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx(), dst_fty) {\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, &src_repr, src, Disr(0), i);\n-                let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, Disr(0), i);\n+                let src_f = adt::trans_field_ptr(bcx, src_ty, src, Disr(0), i);\n+                let dst_f = adt::trans_field_ptr(bcx, dst_ty, dst, Disr(0), i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty);\n                 } else {\n@@ -1164,11 +1159,10 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !fcx.fn_ty.ret.is_ignore() {\n         let dest = fcx.llretslotptr.get().unwrap();\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let repr = adt::represent_type(ccx, sig.output);\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n+            let lldestptr = adt::trans_field_ptr(bcx, sig.output, dest_val, Disr::from(disr), i);\n             let arg = &fcx.fn_ty.args[arg_idx];\n             arg_idx += 1;\n             let b = &bcx.build();\n@@ -1181,7 +1175,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n             }\n         }\n-        adt::trans_set_discr(bcx, &repr, dest, disr);\n+        adt::trans_set_discr(bcx, sig.output, dest, disr);\n     }\n \n     fcx.finish(bcx, DebugLoc::None);"}, {"sha": "5b1f691af8df74b244da2c7d0f68af0db3a4c6eb", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -875,12 +875,6 @@ pub fn const_get_elt(v: ValueRef, us: &[c_uint])\n     }\n }\n \n-pub fn const_to_int(v: ValueRef) -> i64 {\n-    unsafe {\n-        llvm::LLVMConstIntGetSExtValue(v)\n-    }\n-}\n-\n pub fn const_to_uint(v: ValueRef) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)"}, {"sha": "f7b89f6f1bb822168b650d0cbc25ff7278b5075d", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -994,7 +994,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n         self.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n             ty.layout(&infcx).unwrap_or_else(|e| {\n-                bug!(\"failed to get layout for `{}`: {}\", ty, e);\n+                match e {\n+                    ty::layout::LayoutError::SizeOverflow(_) =>\n+                        self.sess().fatal(&e.to_string()),\n+                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n             })\n         })\n     }"}, {"sha": "458127c7ada0501e3dfed17a73a0734892bcb7b3", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -27,10 +27,10 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DI\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n-use {type_of, adt, machine, monomorphize};\n+use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n-use rustc::ty::{self, AdtKind, Ty};\n+use rustc::ty::{self, AdtKind, Ty, layout};\n use session::config;\n use util::nodemap::FnvHashMap;\n use util::common::path2cstr;\n@@ -40,7 +40,6 @@ use std::ffi::CString;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n-use syntax;\n use syntax::util::interner::Interner;\n use syntax::ast;\n use syntax::parse::token;\n@@ -1281,7 +1280,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n-    type_rep: Rc<adt::Repr<'tcx>>,\n+    type_rep: &'tcx layout::Layout,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1292,11 +1291,15 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n+        let substs = match self.enum_type.sty {\n+            ty::TyAdt(def, ref s) if def.adt_kind() == AdtKind::Enum => s,\n+            ref t @ _ => bug!(\"{} is not an enum\", t)\n+        };\n         match *self.type_rep {\n-            adt::General(_, ref struct_defs) => {\n+            layout::General { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n-                struct_defs\n+                variants\n                     .iter()\n                     .enumerate()\n                     .map(|(i, struct_def)| {\n@@ -1327,7 +1330,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                     }).collect()\n             },\n-            adt::Univariant(ref struct_def) => {\n+            layout::Univariant{ ref variant, .. } => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n@@ -1338,7 +1341,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                          member_description_factory) =\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n-                                              struct_def,\n+                                              variant,\n                                               &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n@@ -1362,16 +1365,17 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     ]\n                 }\n             }\n-            adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n+            layout::RawNullablePointer { nndiscr: non_null_variant_index, .. } => {\n                 // As far as debuginfo is concerned, the pointer this enum\n                 // represents is still wrapped in a struct. This is to make the\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &adt.variants[non_null_variant_index.0 as usize];\n+                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n+                let nnty = monomorphize::field_ty(cx.tcx(), &substs, &non_null_variant.fields[0] );\n                 let non_null_llvm_type = type_of::type_of(cx, nnty);\n                 let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n \n@@ -1416,7 +1420,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - non_null_variant_index.0) as usize;\n+                let null_variant_index = (1 - non_null_variant_index) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n@@ -1434,15 +1438,15 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n+            layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n                                                 ref discrfield, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &adt.variants[nndiscr.0 as usize],\n+                                          &adt.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1457,7 +1461,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr.0) as usize;\n+                let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n@@ -1478,9 +1482,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            adt::CEnum(..) | adt::UntaggedUnion(..) => {\n-                span_bug!(self.span, \"This should be unreachable.\")\n-            }\n+            layout::CEnum { .. } => span_bug!(self.span, \"This should be unreachable.\"),\n+            ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n         }\n     }\n }\n@@ -1523,16 +1526,39 @@ enum EnumDiscriminantInfo {\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n-                                   struct_def: &adt::Struct<'tcx>,\n+                                   struct_def: &layout::Struct,\n                                    variant: ty::VariantDef<'tcx>,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n                                    -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n+    let substs = match enum_type.sty {\n+        ty::TyAdt(def, s) if def.adt_kind() == AdtKind::Enum => s,\n+        ref t @ _ => bug!(\"{:#?} is not an enum\", t)\n+    };\n+\n+    let maybe_discr_and_signed: Option<(layout::Integer, bool)> = match *cx.layout_of(enum_type) {\n+        layout::CEnum {discr, ..} => Some((discr, true)),\n+        layout::General{discr, ..} => Some((discr, false)),\n+        layout::Univariant { .. }\n+        | layout::RawNullablePointer { .. }\n+        | layout::StructWrappedNullablePointer { .. } => None,\n+        ref l @ _ => bug!(\"This should be unreachable. Type is {:#?} layout is {:#?}\", enum_type, l)\n+    };\n+\n+    let mut field_tys = variant.fields.iter().map(|f: ty::FieldDef<'tcx>| {\n+        monomorphize::field_ty(cx.tcx(), &substs, f)\n+    }).collect::<Vec<_>>();\n+\n+    if let Some((discr, signed)) = maybe_discr_and_signed {\n+        field_tys.insert(0, discr.to_ty(&cx.tcx(), signed));\n+    }\n+\n+\n     let variant_llvm_type =\n-        Type::struct_(cx, &struct_def.fields\n+        Type::struct_(cx, &field_tys\n                                     .iter()\n-                                    .map(|&t| type_of::type_of(cx, t))\n+                                    .map(|t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n                                     ,\n                       struct_def.packed);\n@@ -1578,7 +1604,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n     let args: Vec<(String, Ty)> = arg_names.iter()\n-        .zip(&struct_def.fields)\n+        .zip(field_tys.iter())\n         .map(|(s, &t)| (s.to_string(), t))\n         .collect();\n \n@@ -1615,7 +1641,6 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = unknown_file_metadata(cx);\n \n     let variants = &enum_type.ty_adt_def().unwrap().variants;\n-\n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n@@ -1630,20 +1655,20 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |inttype: syntax::attr::IntType| {\n+    let discriminant_type_metadata = |inttype: layout::Integer, signed: bool| {\n         let disr_type_key = (enum_def_id, inttype);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n                                                                  .get(&disr_type_key).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n-                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+                let discriminant_llvm_type = Type::from_integer(cx, inttype);\n                 let (discriminant_size, discriminant_align) =\n                     size_and_align_of(cx, discriminant_llvm_type);\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx,\n-                                  adt::ty_of_inttype(cx.tcx(), inttype),\n+                                  inttype.to_ty(&cx.tcx(), signed),\n                                   syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n@@ -1670,16 +1695,17 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let type_rep = adt::represent_type(cx, enum_type);\n+    let type_rep = cx.layout_of(enum_type);\n \n     let discriminant_type_metadata = match *type_rep {\n-        adt::CEnum(inttype, ..) => {\n-            return FinalMetadata(discriminant_type_metadata(inttype))\n+        layout::CEnum { discr, signed, .. } => {\n+            return FinalMetadata(discriminant_type_metadata(discr, signed))\n         },\n-        adt::RawNullablePointer { .. }           |\n-        adt::StructWrappedNullablePointer { .. } |\n-        adt::Univariant(..) | adt::UntaggedUnion(..) => None,\n-        adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n+        layout::RawNullablePointer { .. }           |\n+        layout::StructWrappedNullablePointer { .. } |\n+        layout::Univariant { .. }                      => None,\n+        layout::General { discr, .. } => Some(discriminant_type_metadata(discr, false)),\n+        ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n@@ -1715,7 +1741,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_llvm_type,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n-            type_rep: type_rep.clone(),\n+            type_rep: type_rep,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,"}, {"sha": "a23fd3ab8b395a60d99d409bca47e44e09f4781b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -43,7 +43,7 @@ use std::ptr;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n-use syntax::attr::IntType;\n+use rustc::ty::layout;\n \n pub mod gdb;\n mod utils;\n@@ -69,7 +69,7 @@ pub struct CrateDebugContext<'tcx> {\n     builder: DIBuilderRef,\n     current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<FnvHashMap<(DefId, IntType), DIType>>,\n+    created_enum_disr_types: RefCell<FnvHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,"}, {"sha": "fe76ec05f6eadda4a945c3e7d0bdb6357ce3e6fb", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -513,7 +513,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"drop_structural_ty\");\n \n     fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                repr: &adt::Repr<'tcx>,\n+                                t: Ty<'tcx>,\n                                 av: adt::MaybeSizedValue,\n                                 variant: ty::VariantDef<'tcx>,\n                                 substs: &Substs<'tcx>)\n@@ -525,7 +525,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             cx = drop_ty(cx,\n-                         adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n+                         adt::trans_field_ptr(cx, t, av, Disr::from(variant.disr_val), i),\n                          arg, DebugLoc::None);\n         }\n         return cx;\n@@ -543,9 +543,8 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let mut cx = cx;\n     match t.sty {\n         ty::TyClosure(_, ref substs) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                let llupvar = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n                 cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n             }\n         }\n@@ -562,18 +561,16 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n         }\n         ty::TyTuple(ref args) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                let llfld_a = adt::trans_field_ptr(cx, t, value, Disr(0), i);\n                 cx = drop_ty(cx, llfld_a, *arg, DebugLoc::None);\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n-                let repr = adt::represent_type(cx.ccx(), t);\n                 let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n+                    let llfld_a = adt::trans_field_ptr(cx, t, value, Disr::from(discr), i);\n \n                     let val = if type_is_sized(cx.tcx(), field_ty) {\n                         llfld_a\n@@ -593,18 +590,16 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             AdtKind::Enum => {\n                 let fcx = cx.fcx;\n                 let ccx = fcx.ccx;\n-\n-                let repr = adt::represent_type(ccx, t);\n                 let n_variants = adt.variants.len();\n \n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(cx, &repr, av, false) {\n+                match adt::trans_switch(cx, t, av, false) {\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n+                            cx = iter_variant(cx, t, adt::MaybeSizedValue::sized(av),\n                                             &adt.variants[0], substs);\n                         }\n                     }\n@@ -633,10 +628,10 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                             let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n                                                                         &variant.disr_val\n                                                                                 .to_string()));\n-                            let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n+                            let case_val = adt::trans_case(cx, t, Disr::from(variant.disr_val));\n                             AddCase(llswitch, case_val, variant_cx.llbb);\n                             let variant_cx = iter_variant(variant_cx,\n-                                                        &repr,\n+                                                        t,\n                                                         value,\n                                                         variant,\n                                                         substs);"}, {"sha": "4cacbc0f35effbedfd9f704f9be1487b1f259556", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -418,8 +418,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let val_ty = substs.type_at(0);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    let repr = adt::represent_type(ccx, val_ty);\n-                    adt::trans_get_discr(bcx, &repr, llargs[0],\n+                    adt::trans_get_discr(bcx, val_ty, llargs[0],\n                                          Some(llret_ty), true)\n                 }\n                 _ => C_null(llret_ty)\n@@ -629,13 +628,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.fcx.type_needs_drop(arg_type));\n-\n-                        let repr = adt::represent_type(bcx.ccx(), arg_type);\n-                        let repr_ptr = &repr;\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {\n-                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, arg, Disr(0), i))\n+                                Load(bcx, adt::trans_field_ptr(bcx, arg_type, arg, Disr(0), i))\n                             })\n                             .collect()\n                     }"}, {"sha": "cd31f02842addfef6b40fe6c00e67e0ec1b9b9c6", "filename": "src/librustc_trans/machine.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -24,13 +24,6 @@ pub type llalign = u32;\n // ______________________________________________________________________\n // compute sizeof / alignof\n \n-// Returns the number of bytes clobbered by a Store to this type.\n-pub fn llsize_of_store(cx: &CrateContext, ty: Type) -> llsize {\n-    unsafe {\n-        return llvm::LLVMStoreSizeOfType(cx.td(), ty.to_ref());\n-    }\n-}\n-\n // Returns the number of bytes between successive elements of type T in an\n // array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n@@ -39,28 +32,6 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n     }\n }\n \n-// Returns, as near as we can figure, the \"real\" size of a type. As in, the\n-// bits in this number of bytes actually carry data related to the datum\n-// with the type. Not junk, accidentally-damaged words, or whatever.\n-// Note that padding of the type will be included for structs, but not for the\n-// other types (i.e. SIMD types).\n-// Rounds up to the nearest byte though, so if you have a 1-bit\n-// value, we return 1 here, not 0. Most of rustc works in bytes. Be warned\n-// that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n-// at the codegen level! In general you should prefer `llbitsize_of_real`\n-// below.\n-pub fn llsize_of_real(cx: &CrateContext, ty: Type) -> llsize {\n-    unsafe {\n-        let nbits = llvm::LLVMSizeOfTypeInBits(cx.td(), ty.to_ref());\n-        if nbits & 7 != 0 {\n-            // Not an even number of bytes, spills into \"next\" byte.\n-            1 + (nbits >> 3)\n-        } else {\n-            nbits >> 3\n-        }\n-    }\n-}\n-\n /// Returns the \"real\" size of the type in bits.\n pub fn llbitsize_of_real(cx: &CrateContext, ty: Type) -> llbits {\n     unsafe {"}, {"sha": "003830123ff3b9c7f136ea0c854025bc3bce6350", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -139,9 +139,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, discr);\n                 let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let repr = adt::represent_type(bcx.ccx(), ty);\n                 let discr = bcx.with_block(|bcx|\n-                    adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None, true)\n+                    adt::trans_get_discr(bcx, ty, discr_lvalue.llval, None, true)\n                 );\n \n                 let mut bb_hist = FnvHashMap();\n@@ -167,7 +166,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if default_bb != Some(target) {\n                         let llbb = llblock(self, target);\n                         let llval = bcx.with_block(|bcx| adt::trans_case(\n-                                bcx, &repr, Disr::from(adt_variant.disr_val)));\n+                                bcx, ty, Disr::from(adt_variant.disr_val)));\n                         build::AddCase(switch, llval, llbb)\n                     }\n                 }\n@@ -701,10 +700,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval) => {\n-                let base_repr = adt::represent_type(bcx.ccx(), tuple.ty);\n                 let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n+                    let ptr = adt::trans_field_ptr_builder(bcx, tuple.ty, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n                         let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n                         Pair(lldata, llextra)"}, {"sha": "aba50053b09b307c0da1dc9e1764a0661c720831", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -23,9 +23,9 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {abi, adt, base, Disr};\n+use {abi, adt, base, Disr, machine};\n use callee::Callee;\n-use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty, type_is_sized};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n use common::{const_to_opt_int, const_to_opt_uint};\n@@ -441,8 +441,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let base_repr = adt::represent_type(self.ccx, tr_base.ty);\n-                        let llprojected = adt::const_get_field(&base_repr, base.llval,\n+                        let llprojected = adt::const_get_field(self.ccx, tr_base.ty, base.llval,\n                                                                Disr(0), field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n@@ -585,9 +584,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             }\n                             _ => Disr(0)\n                         };\n-                        let repr = adt::represent_type(self.ccx, dest_ty);\n                         Const::new(\n-                            adt::trans_const(self.ccx, &repr, disr, &fields),\n+                            adt::trans_const(self.ccx, dest_ty, disr, &fields),\n                             dest_ty\n                         )\n                     }\n@@ -658,8 +656,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let ll_t_out = type_of::immediate_type_of(self.ccx, cast_ty);\n                         let llval = operand.llval;\n                         let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let repr = adt::represent_type(self.ccx, operand.ty);\n-                            adt::is_discr_signed(&repr)\n+                            let l = self.ccx.layout_of(operand.ty);\n+                            adt::is_discr_signed(&l)\n                         } else {\n                             operand.ty.is_signed()\n                         };\n@@ -735,7 +733,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 let base = match tr_lvalue.base {\n                     Base::Value(llval) => {\n-                        let align = type_of::align_of(self.ccx, ty);\n+                        //Fixme: may be wrong for &*(&simd_vec as &fmt::Debug)\n+                        let align = if type_is_sized(self.ccx.tcx(), ty) {\n+                            type_of::align_of(self.ccx, ty)\n+                        } else {\n+                            self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n+                        };\n                         if bk == mir::BorrowKind::Mut {\n                             consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n                         } else {"}, {"sha": "0ce5544c3bfc5b50bb650226e1f7601e32d23edb", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -152,7 +152,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        let base_repr = adt::represent_type(ccx, base_ty);\n                         let discr = match tr_base.ty {\n                             LvalueTy::Ty { .. } => 0,\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n@@ -164,7 +163,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        let llprojected = adt::trans_field_ptr_builder(bcx, &base_repr, base,\n+                        let llprojected = adt::trans_field_ptr_builder(bcx, base_ty, base,\n                                                                        Disr(discr), field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()"}, {"sha": "b643dcd9871b0bd798536bfe98f2401f757c134c", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -111,19 +111,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n-                        let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n                         bcx.with_block(|bcx| {\n-                            adt::trans_set_discr(bcx, &repr, dest.llval, Disr::from(disr));\n+                            adt::trans_set_discr(bcx,\n+                                dest.ty.to_ty(bcx.tcx()), dest.llval, Disr::from(disr));\n                         });\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr_builder(&bcx, &repr, val,\n-                                                                            disr, field_index);\n+                                let lldest_i = adt::trans_field_ptr_builder(&bcx,\n+                                    dest.ty.to_ty(bcx.tcx()),\n+                                    val, disr, field_index);\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n                         }\n@@ -270,17 +271,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n                         let (llval, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let repr = adt::represent_type(bcx.ccx(), operand.ty);\n+                            let l = bcx.ccx().layout_of(operand.ty);\n                             let discr = match operand.val {\n                                 OperandValue::Immediate(llval) => llval,\n                                 OperandValue::Ref(llptr) => {\n                                     bcx.with_block(|bcx| {\n-                                        adt::trans_get_discr(bcx, &repr, llptr, None, true)\n+                                        adt::trans_get_discr(bcx, operand.ty, llptr, None, true)\n                                     })\n                                 }\n                                 OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n                             };\n-                            (discr, adt::is_discr_signed(&repr))\n+                            (discr, adt::is_discr_signed(&l))\n                         } else {\n                             (operand.immediate(), operand.ty.is_signed())\n                         };"}, {"sha": "9943acbc88e6d2365857e89ac7300483816ebb28", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -62,11 +62,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             mir::StatementKind::SetDiscriminant{ref lvalue, variant_index} => {\n                 let ty = self.monomorphized_lvalue_ty(lvalue);\n-                let repr = adt::represent_type(bcx.ccx(), ty);\n                 let lvalue_transed = self.trans_lvalue(&bcx, lvalue);\n                 bcx.with_block(|bcx|\n                     adt::trans_set_discr(bcx,\n-                                         &repr,\n+                                         ty,\n                                         lvalue_transed.llval,\n                                         Disr::from(variant_index))\n                 );"}, {"sha": "f0f3dd0bc11ffa76480f5639f8d1a733d6c6921d", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -18,6 +18,7 @@ use context::CrateContext;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n+use rustc::ty::layout;\n \n use std::ffi::CString;\n use std::fmt;\n@@ -299,6 +300,26 @@ impl Type {\n             llvm::LLVMGetIntTypeWidth(self.to_ref()) as u64\n         }\n     }\n+\n+    pub fn from_integer(cx: &CrateContext, i: layout::Integer)->Type {\n+        use rustc::ty::layout::Integer::*;\n+        match i {\n+            I1 => Type::i1(cx),\n+            I8 => Type::i8(cx),\n+            I16 => Type::i16(cx),\n+            I32 => Type::i32(cx),\n+            I64 => Type::i64(cx),\n+        }\n+    }\n+\n+    pub fn from_primitive(ccx: &CrateContext, p: layout::Primitive)->Type {\n+        match p {\n+            layout::Int(i) => Type::from_integer(ccx, i),\n+            layout::F32 => Type::f32(ccx),\n+            layout::F64 => Type::f64(ccx),\n+            layout::Pointer => bug!(\"It is not possible to convert Pointer directly to Type.\")\n+        }\n+    }\n }\n \n /* Memory-managed object interface to type handles. */"}, {"sha": "8183639ae22102232f8feac8d98fc67abeef58f1", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16068e577a916122ff1f24719aad2b80e40c975/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f16068e577a916122ff1f24719aad2b80e40c975", "patch": "@@ -22,17 +22,6 @@ use type_::Type;\n \n use syntax::ast;\n \n-// LLVM doesn't like objects that are too big. Issue #17913\n-fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                llet: Type,\n-                                                size: machine::llsize,\n-                                                scapegoat: Ty<'tcx>) {\n-    let esz = machine::llsize_of_alloc(ccx, llet);\n-    match esz.checked_mul(size) {\n-        Some(n) if n < ccx.obj_size_bound() => {}\n-        _ => { ccx.report_overbig_object(scapegoat) }\n-    }\n-}\n \n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n@@ -81,7 +70,6 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyArray(ty, size) => {\n             let llty = sizing_type_of(cx, ty);\n             let size = size as u64;\n-            ensure_array_fits_in_address_space(cx, llty, size, t);\n             Type::array(&llty, size)\n         }\n \n@@ -98,13 +86,11 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n             let llet = type_of(cx, e);\n             let n = t.simd_size(cx.tcx()) as u64;\n-            ensure_array_fits_in_address_space(cx, llet, n, t);\n             Type::vector(&llet, n)\n         }\n \n         ty::TyTuple(..) | ty::TyAdt(..) | ty::TyClosure(..) => {\n-            let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &repr, false)\n+            adt::sizing_type_of(cx, t, false)\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n@@ -242,8 +228,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n-          let repr = adt::represent_type(cx, t);\n-          adt::incomplete_type_of(cx, &repr, \"closure\")\n+          adt::incomplete_type_of(cx, t, \"closure\")\n       }\n \n       ty::TyBox(ty) |\n@@ -266,11 +251,6 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n       ty::TyArray(ty, size) => {\n           let size = size as u64;\n-          // we must use `sizing_type_of` here as the type may\n-          // not be fully initialized.\n-          let szty = sizing_type_of(cx, ty);\n-          ensure_array_fits_in_address_space(cx, szty, size, t);\n-\n           let llty = in_memory_type_of(cx, ty);\n           Type::array(&llty, size)\n       }\n@@ -290,8 +270,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {\n-          let repr = adt::represent_type(cx, t);\n-          adt::type_of(cx, &repr)\n+          adt::type_of(cx, t)\n       }\n       ty::TyAdt(..) if t.is_simd() => {\n           let e = t.simd_type(cx.tcx());\n@@ -302,17 +281,15 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n           let llet = in_memory_type_of(cx, e);\n           let n = t.simd_size(cx.tcx()) as u64;\n-          ensure_array_fits_in_address_space(cx, llet, n, t);\n           Type::vector(&llet, n)\n       }\n       ty::TyAdt(def, substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n-          let repr = adt::represent_type(cx, t);\n           let name = llvm_type_name(cx, def.did, substs);\n-          adt::incomplete_type_of(cx, &repr, &name[..])\n+          adt::incomplete_type_of(cx, t, &name[..])\n       }\n \n       ty::TyInfer(..) |\n@@ -329,8 +306,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n         ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() => {\n-            let repr = adt::represent_type(cx, t);\n-            adt::finish_type_of(cx, &repr, &mut llty);\n+            adt::finish_type_of(cx, t, &mut llty);\n         }\n         _ => ()\n     }\n@@ -340,8 +316,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n                           -> machine::llalign {\n-    let llty = sizing_type_of(cx, t);\n-    machine::llalign_of_min(cx, llty)\n+    let layout = cx.layout_of(t);\n+    layout.align(&cx.tcx().data_layout).abi() as machine::llalign\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,"}]}