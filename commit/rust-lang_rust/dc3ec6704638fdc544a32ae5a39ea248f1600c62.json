{"sha": "dc3ec6704638fdc544a32ae5a39ea248f1600c62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjM2VjNjcwNDYzOGZkYzU0NGEzMmFlNWEzOWVhMjQ4ZjE2MDBjNjI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T13:58:46Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T13:58:46Z"}, "message": "Implement intrinsics copy and copy_nonoverlapping", "tree": {"sha": "33f1aeacfd05c88a57ea8df59238dca702859c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33f1aeacfd05c88a57ea8df59238dca702859c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc3ec6704638fdc544a32ae5a39ea248f1600c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc3ec6704638fdc544a32ae5a39ea248f1600c62", "html_url": "https://github.com/rust-lang/rust/commit/dc3ec6704638fdc544a32ae5a39ea248f1600c62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc3ec6704638fdc544a32ae5a39ea248f1600c62/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a45965bb2181ba97c9a3f786f36580f4986b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a45965bb2181ba97c9a3f786f36580f4986b90", "html_url": "https://github.com/rust-lang/rust/commit/75a45965bb2181ba97c9a3f786f36580f4986b90"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "f2e6007e5f8d58a78ef85c209277fa261c9a6eab", "filename": "src/abi.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dc3ec6704638fdc544a32ae5a39ea248f1600c62/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3ec6704638fdc544a32ae5a39ea248f1600c62/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=dc3ec6704638fdc544a32ae5a39ea248f1600c62", "patch": "@@ -104,32 +104,46 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n         module.declare_func_in_func(func_id, &mut self.bcx.func)\n     }\n \n-    pub fn lib_call(\n+    fn lib_call(\n         &mut self,\n         name: &str,\n         input_tys: Vec<types::Type>,\n-        output_ty: types::Type,\n+        output_ty: Option<types::Type>,\n         args: &[Value],\n-    ) -> Value {\n+    ) -> Option<Value> {\n         let sig = Signature {\n             params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: vec![AbiParam::new(output_ty)],\n+            returns: vec![AbiParam::new(output_ty.unwrap_or(types::VOID))],\n             call_conv: CallConv::SystemV,\n             argument_bytes: None,\n         };\n         let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n+        if output_ty.is_none() {\n+            return None;\n+        }\n         let results = self.bcx.inst_results(call_inst);\n         assert_eq!(results.len(), 1);\n-        results[0]\n+        Some(results[0])\n     }\n \n     pub fn easy_call(&mut self, name: &str, args: &[CValue<'tcx>], return_ty: Ty<'tcx>) -> CValue<'tcx> {\n         let (input_tys, args): (Vec<_>, Vec<_>) = args.into_iter().map(|arg| (self.cton_type(arg.layout().ty).unwrap(), arg.load_value(self))).unzip();\n         let return_layout = self.layout_of(return_ty);\n-        let return_ty = self.cton_type(return_ty).unwrap();\n-        CValue::ByVal(self.lib_call(name, input_tys, return_ty, &args), return_layout)\n+        let return_ty = if let TypeVariants::TyTuple(tup) = return_ty.sty {\n+            if !tup.is_empty() {\n+                bug!(\"easy_call( (...) -> <non empty tuple> ) is not allowed\");\n+            }\n+            None\n+        } else {\n+            Some(self.cton_type(return_ty).unwrap())\n+        };\n+        if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n+            CValue::ByVal(val, return_layout)\n+        } else {\n+            CValue::ByRef(self.bcx.ins().iconst(types::I64, 0), return_layout)\n+        }\n     }\n \n     fn self_sig(&self) -> FnSig<'tcx> {\n@@ -277,18 +291,23 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n             let intrinsic = fx.tcx.item_name(def_id).as_str();\n             let intrinsic = &intrinsic[..];\n \n+            let nil_ty = fx.tcx.mk_nil();\n             let usize_layout = fx.layout_of(fx.tcx.types.usize);\n             let ret = return_place.unwrap();\n             match intrinsic {\n                 \"abort\" => {\n                     fx.bcx.ins().trap(TrapCode::User(!0 - 1));\n                 }\n                 \"copy\" | \"copy_nonoverlapping\" => {\n-                    /*let elem_ty = substs.type_at(0);\n+                    let elem_ty = substs.type_at(0);\n+                    let elem_size: u64 = fx.layout_of(elem_ty).size.bytes();\n+                    let elem_size = fx.bcx.ins().iconst(types::I64, elem_size as i64);\n                     assert_eq!(args.len(), 3);\n                     let src = args[0];\n                     let dst = args[1];\n-                    let count = args[2];*/\n+                    let count = args[2].load_value(fx);\n+                    let byte_amount = fx.bcx.ins().imul(count, elem_size);\n+                    fx.easy_call(\"memmove\", &[dst, src, CValue::ByVal(byte_amount, usize_layout)], nil_ty);\n                     unimplemented!(\"copy\");\n                 }\n                 \"discriminant_value\" => {"}]}