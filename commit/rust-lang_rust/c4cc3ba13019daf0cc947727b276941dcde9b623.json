{"sha": "c4cc3ba13019daf0cc947727b276941dcde9b623", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0Y2MzYmExMzAxOWRhZjBjYzk0NzcyN2IyNzY5NDFkY2RlOWI2MjM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T05:33:30Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T17:10:38Z"}, "message": "update fold_method to return a smallvector\n\nThis is nice for macros, to allow them to expand into multiple methods", "tree": {"sha": "cd9c5ec36e4c6e8b7587a20d6440831840a6e1d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd9c5ec36e4c6e8b7587a20d6440831840a6e1d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4cc3ba13019daf0cc947727b276941dcde9b623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4cc3ba13019daf0cc947727b276941dcde9b623", "html_url": "https://github.com/rust-lang/rust/commit/c4cc3ba13019daf0cc947727b276941dcde9b623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4cc3ba13019daf0cc947727b276941dcde9b623/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b293a6604bdbca136e46a68e358be5dde1faa7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b293a6604bdbca136e46a68e358be5dde1faa7a9", "html_url": "https://github.com/rust-lang/rust/commit/b293a6604bdbca136e46a68e358be5dde1faa7a9"}], "stats": {"total": 53, "additions": 38, "deletions": 15}, "files": [{"sha": "d58023a48756f00ebc3f8facec0c9e2536003dd7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c4cc3ba13019daf0cc947727b276941dcde9b623", "patch": "@@ -345,7 +345,9 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n         // HACK we're not dropping items.\n         e::IIItemRef(i) => ast::IIItem(fold::noop_fold_item(i, &mut fld)\n                                        .expect_one(\"expected one item\")),\n-        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)),\n+        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)\n+                                                 .expect_one(\n+                \"noop_fold_method must produce exactly one method\")),\n         e::IIForeignRef(i) => ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n     }\n }\n@@ -387,7 +389,8 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n                 ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n             }\n             ast::IIMethod(d, is_provided, m) => {\n-                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m))\n+                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m)\n+                              .expect_one(\"expected one method\"))\n             }\n             ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n         }"}, {"sha": "b8a0a31f9c3b64690356098b0ddb6d10074e9aa5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=c4cc3ba13019daf0cc947727b276941dcde9b623", "patch": "@@ -571,13 +571,14 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         m\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method> {\n+    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>> {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n-        let m = fold::noop_fold_method(&*m, self);\n+        let m = fold::noop_fold_method(&*m, self).expect_one(\n+            \"noop_fold_method must produce exactly one method\");\n         assert_eq!(self.parent, m.id);\n         self.parent = parent;\n-        m\n+        SmallVector::one(m)\n     }\n \n     fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {"}, {"sha": "fd786192cb48c181745bf1ed0a7b7022ec9b2440", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4cc3ba13019daf0cc947727b276941dcde9b623/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c4cc3ba13019daf0cc947727b276941dcde9b623", "patch": "@@ -114,7 +114,7 @@ pub trait Folder {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> Gc<Method>  {\n+    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>>  {\n         noop_fold_method(&*m, self)\n     }\n \n@@ -465,10 +465,16 @@ fn fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T) -> token:\n     match *nt {\n         token::NtItem(item) =>\n             token::NtItem(fld.fold_item(item)\n+                          // this is probably okay, because the only folds likely\n+                          // to peek inside interpolated nodes will be renamings/markings,\n+                          // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n             token::NtStmt(fld.fold_stmt(stmt)\n+                          // this is probably okay, because the only folds likely\n+                          // to peek inside interpolated nodes will be renamings/markings,\n+                          // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one statement\")),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n@@ -683,15 +689,26 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n             ItemImpl(fold_generics(generics, folder),\n                      ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n                      folder.fold_ty(ty),\n-                     methods.iter().map(|x| folder.fold_method(*x)).collect()\n+                     methods.iter().flat_map(|x| folder.fold_method(*x).move_iter()).collect()\n             )\n         }\n         ItemTrait(ref generics, ref unbound, ref traits, ref methods) => {\n-            let methods = methods.iter().map(|method| {\n-                match *method {\n-                    Required(ref m) => Required(folder.fold_type_method(m)),\n-                    Provided(method) => Provided(folder.fold_method(method))\n-                }\n+            let methods = methods.iter().flat_map(|method| {\n+                let r = match *method {\n+                    Required(ref m) =>\n+                            SmallVector::one(Required(folder.fold_type_method(m))).move_iter(),\n+                    Provided(method) => {\n+                            // the awkward collect/iter idiom here is because\n+                            // even though an iter and a map satisfy the same trait bound,\n+                            // they're not actually the same type, so the method arms\n+                            // don't unify.\n+                            let methods : SmallVector<ast::TraitMethod> =\n+                                folder.fold_method(method).move_iter()\n+                                .map(|m| Provided(m)).collect();\n+                            methods.move_iter()\n+                        }\n+                };\n+                r\n             }).collect();\n             ItemTrait(fold_generics(generics, folder),\n                       unbound.clone(),\n@@ -791,9 +808,11 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n     }\n }\n \n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n+// Default fold over a method.\n+// Invariant: produces exactly one method.\n+pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {\n     let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    box(GC) Method {\n+    SmallVector::one(box(GC) Method {\n         attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n         id: id,\n         span: folder.new_span(m.span),\n@@ -809,7 +828,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n             },\n             MethMac(ref mac) => MethMac(folder.fold_mac(mac)),\n         }\n-    }\n+    })\n }\n \n pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {"}]}