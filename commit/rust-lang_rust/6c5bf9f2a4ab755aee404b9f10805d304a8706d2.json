{"sha": "6c5bf9f2a4ab755aee404b9f10805d304a8706d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNWJmOWYyYTRhYjc1NWFlZTQwNGI5ZjEwODA1ZDMwNGE4NzA2ZDI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-20T18:42:17Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-10-03T15:22:44Z"}, "message": "Re-do the 30 minute intro\n\nThis was originally on my blog, so it's incredibly informal. Let's make\nit better.", "tree": {"sha": "839d9b2939f7bed10d18c17283182fe407047531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/839d9b2939f7bed10d18c17283182fe407047531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c5bf9f2a4ab755aee404b9f10805d304a8706d2", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5bf9f2a4ab755aee404b9f10805d304a8706d2", "html_url": "https://github.com/rust-lang/rust/commit/6c5bf9f2a4ab755aee404b9f10805d304a8706d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c5bf9f2a4ab755aee404b9f10805d304a8706d2/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cad720879a09ec996cf688caaeba8f0b5aad2ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cad720879a09ec996cf688caaeba8f0b5aad2ff", "html_url": "https://github.com/rust-lang/rust/commit/8cad720879a09ec996cf688caaeba8f0b5aad2ff"}], "stats": {"total": 857, "additions": 499, "deletions": 358}, "files": [{"sha": "b45610faebc41a0bf8102585f8dc9a1a233974a6", "filename": "src/doc/intro.md", "status": "modified", "additions": 499, "deletions": 358, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/6c5bf9f2a4ab755aee404b9f10805d304a8706d2/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c5bf9f2a4ab755aee404b9f10805d304a8706d2/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=6c5bf9f2a4ab755aee404b9f10805d304a8706d2", "patch": "@@ -1,435 +1,576 @@\n % A 30-minute Introduction to Rust\n \n-Rust is a systems programming language that combines strong compile-time correctness guarantees with fast performance.\n-It improves upon the ideas of other systems languages like C++\n-by providing guaranteed memory safety (no crashes, no data races) and complete control over the lifecycle of memory.\n-Strong memory guarantees make writing correct concurrent Rust code easier than in other languages.\n-This introduction will give you an idea of what Rust is like in about thirty minutes.\n-It expects that you're at least vaguely familiar with a previous 'curly brace' language,\n-but does not require prior experience with systems programming.\n-The concepts are more important than the syntax,\n-so don't worry if you don't get every last detail:\n-the [guide](guide.html) can help you out with that later.\n-\n-Let's talk about the most important concept in Rust, \"ownership,\"\n-and its implications on a task that programmers usually find very difficult: concurrency.\n-\n-# The power of ownership\n-\n-Ownership is central to Rust,\n-and is the feature from which many of Rust's powerful capabilities are derived.\n-\"Ownership\" refers to which parts of your code are allowed to read,\n-write, and ultimately release, memory.\n-Let's start by looking at some C++ code:\n-\n-```cpp\n-int* dangling(void)\n-{\n-    int i = 1234;\n-    return &i;\n-}\n+Rust is a modern systems programming language focusing on safety and speed. It\n+accomplishes these goals by being memory safe without using garbage collection.\n \n-int add_one(void)\n-{\n-    int* num = dangling();\n-    return *num + 1;\n-}\n+This introduction will give you a rough idea of what Rust is like, eliding many\n+details. It does not require prior experience with systems programming, but you\n+may find the syntax easier if you've used a 'curly brace' programming language\n+before, like C or JavaScript. The concepts are more important than the syntax,\n+so don't worry if you don't get every last detail: you can read [the\n+Guide](guide.html) to get a more complete explanation.\n+\n+Because this is about high-level concepts, you don't need to actually install\n+Rust to follow along. If you'd like to anyway, check out [the\n+homepage](http://rust-lang.org) for explanation.\n+\n+To show off Rust, let's talk about how easy it is to get started with Rust.\n+Then, we'll talk about Rust's most interesting feature, **ownership**, and\n+then discuss how it makes concurrency easier to reason about. Finally,\n+we'll talk about how Rust breaks down the perceived dichotomy between speed\n+and safety.\n+\n+# Tools\n+\n+Getting started on a new Rust project is incredibly easy, thanks to Rust's\n+package manager, [Cargo](http://crates.io).\n+\n+To start a new project with Cargo, use `cargo new`:\n+\n+```{bash}\n+$ cargo new hello_world --bin\n ```\n \n-**Note: The above C++ code is deliberately simple and non-idiomatic for the purpose\n-of demonstration. It is not representative of production-quality C++ code.**\n-\n-This function allocates an integer on the stack,\n-and stores it in a variable, `i`.\n-It then returns a reference to the variable `i`.\n-There's just one problem:\n-stack memory becomes invalid when the function returns.\n-This means that in the second line of `add_one`,\n-`num` points to some garbage values,\n-and we won't get the effect that we want.\n-While this is a trivial example,\n-it can happen quite often in C++ code.\n-There's a similar problem when memory on the heap is allocated with `malloc` (or `new`),\n-then freed with `free` (or `delete`),\n-yet your code attempts to do something with the pointer to that memory.\n-This problem is called a 'dangling pointer,'\n-and it's not possible to write Rust code that has it.\n-Let's try writing it in Rust:\n-\n-```ignore\n-fn dangling() -> &int {\n-    let i = 1234;\n-    return &i;\n-}\n+We're passing `--bin` because we're making a binary program: if we\n+were making a library, we'd leave it off.\n \n-fn add_one() -> int {\n-    let num = dangling();\n-    return *num + 1;\n-}\n+Let's check out what Cargo has generated for us:\n+\n+```{bash}\n+$ cd hello_world\n+$ tree .\n+.\n+\u251c\u2500\u2500 Cargo.toml\n+\u2514\u2500\u2500 src\n+    \u2514\u2500\u2500 main.rs\n+\n+1 directory, 2 files\n+```\n+\n+This is all we need to get started. First, let's check out `Cargo.toml`:\n \n+```{toml}\n+[package]\n+\n+name = \"hello_world\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+This is called a **manifest**, and it contains all of the metadata that Cargo\n+needs to compile your project. \n+\n+Here's what's in `src/main.rs`:\n+\n+```{rust}\n fn main() {\n-    add_one();\n+    println!(\"Hello, world!\")\n }\n ```\n \n-Save this program as `dangling.rs`. When you try to compile this program with `rustc dangling.rs`, you'll get an interesting (and long) error message:\n-\n-```text\n-dangling.rs:3:12: 3:14 error: `i` does not live long enough\n-dangling.rs:3     return &i;\n-                         ^~\n-dangling.rs:1:23: 4:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 1:22...\n-dangling.rs:1 fn dangling() -> &int {\n-dangling.rs:2     let i = 1234;\n-dangling.rs:3     return &i;\n-dangling.rs:4 }\n-dangling.rs:1:23: 4:2 note: ...but borrowed value is only valid for the block at 1:22\n-dangling.rs:1 fn dangling() -> &int {\n-dangling.rs:2     let i = 1234;\n-dangling.rs:3     return &i;\n-dangling.rs:4 }\n-error: aborting due to previous error\n+Cargo generated a 'hello world' for us. We'll talk more about the syntax here\n+later, but that's what Rust code looks like! Let's compile and run it:\n+\n+```{bash}\n+$ cargo run\n+   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n+     Running `target/hello_world`\n+Hello, world!\n ```\n \n-In order to fully understand this error message,\n-we need to talk about what it means to \"own\" something.\n-So for now,\n-let's just accept that Rust will not allow us to write code with a dangling pointer,\n-and we'll come back to this code once we understand ownership.\n-\n-Let's forget about programming for a second and talk about books.\n-I like to read physical books,\n-and sometimes I really like one and tell my friends they should read it.\n-While I'm reading my book, I own it: the book is in my possession.\n-When I loan the book out to someone else for a while, they \"borrow\" it from me.\n-And when you borrow a book, it's yours for a certain period of time,\n-and then you give it back to me, and I own it again. Right?\n-\n-This concept applies directly to Rust code as well:\n-some code \"owns\" a particular pointer to memory.\n-It's the sole owner of that pointer.\n-It can also lend that memory out to some other code for a while:\n-that code \"borrows\" the memory,\n-and it borrows it for a precise period of time,\n-called a \"lifetime.\"\n-\n-That's all there is to it.\n-That doesn't seem so hard, right?\n-Let's go back to that error message:\n-`error: 'i' does not live long enough`.\n-We tried to loan out a particular variable, `i`,\n-using a reference (the `&` operator) but Rust knew that the variable would be invalid after the function returns,\n-and so it tells us that:\n-`reference must be valid for the anonymous lifetime #1...`.\n-Neat!\n-\n-That's a great example for stack memory,\n-but what about heap memory?\n-Rust has a second kind of pointer,\n-an 'owned box',\n-that you can create with the `box` operator.\n-Check it out:\n+Using an external dependency in Rust is incredibly easy. You add a line to\n+your `Cargo.toml`:\n \n+```{toml}\n+[package]\n+\n+name = \"hello_world\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <someone@example.com>\"]\n+\n+[dependencies.semver]\n+\n+git = \"https://github.com/rust-lang/semver.git\"\n ```\n \n-fn dangling() -> Box<int> {\n-    let i = box 1234i;\n-    return i;\n-}\n+You added the `semver` library, which parses version numbers and compares them\n+according to the [SemVer specification](http://semver.org/).\n+\n+Now, you can pull in that library using `extern crate` in\n+`main.rs`.\n+\n+```{rust,ignore}\n+extern crate semver;\n \n-fn add_one() -> int {\n-    let num = dangling();\n-    return *num + 1;\n+use semver::Version;\n+\n+fn main() {\n+    assert!(Version::parse(\"1.2.3\") == Ok(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: vec!(),\n+        build: vec!(),\n+    }));\n+\n+    println!(\"Versions compared successfully!\");\n }\n ```\n \n-Now instead of a stack allocated `1234i`,\n-we have a heap allocated `box 1234i`.\n-Whereas `&` borrows a pointer to existing memory,\n-creating an owned box allocates memory on the heap and places a value in it,\n-giving you the sole pointer to that memory.\n-You can roughly compare these two lines:\n+Again, we'll discuss the exact details of all of this syntax soon. For now,\n+let's compile and run it:\n \n+```{bash}\n+$ cargo run\n+    Updating git repository `https://github.com/rust-lang/semver.git`\n+   Compiling semver v0.0.1 (https://github.com/rust-lang/semver.git#bf739419)\n+   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n+     Running `target/hello_world`\n+Versions compared successfully!\n ```\n-// Rust\n-let i = box 1234i;\n+\n+Because we only specified a repository without a version, if someone else were\n+to try out our project at a later date, when `semver` was updated, they would\n+get a different, possibly incompatible version. To solve this problem, Cargo\n+produces a file, `Cargo.lock`, which records the versions of any dependencies.\n+This gives us repeatable builds.\n+\n+There is a lot more here, and this is a whirlwind tour, but you should feel\n+right at home if you've used tools like [Bundler](http://bundler.io/),\n+[npm](https://www.npmjs.org/), or [pip](https://pip.pypa.io/en/latest/).\n+There's no `Makefile`s or endless `autotools` output here. (Rust's tooling does\n+[play nice with external libraries written in those\n+tools](http://crates.io/native-build.html), if you need to.)\n+\n+Enough about tools, let's talk code!\n+\n+# Ownership\n+\n+Rust's defining feature is 'memory safety without garbage collection.' Let's\n+take a moment to talk about what that means. **Memory safety** means that the\n+programming language eliminates certain kinds of bugs, such as [buffer\n+overflows](http://en.wikipedia.org/wiki/Buffer_overflow) and [dangling\n+pointers](http://en.wikipedia.org/wiki/Dangling_pointer). These problems occur\n+when you have unrestricted access to memory. As an example, here's some Ruby\n+code:\n+\n+```{ruby}\n+v = [];\n+\n+v.push(\"Hello\");\n+\n+x = v[0];\n+\n+v.push(\"world\");\n+\n+puts x\n ```\n \n-```cpp\n-// C++\n-int *i = new int;\n-*i = 1234;\n+We make an array, `v`, and then call `push` on it. `push` is a method which\n+adds an element to the end of an array.\n+\n+Next, we make a new variable, `x`, that's equal to the first element of\n+the array. Simple, but this is where the 'bug' will appear.\n+\n+Let's keep going. We then call `push` again, pushing \"world\" onto the\n+end of the array. `v` now is `[\"Hello\", \"world\"]`.\n+\n+Finally, we print `x` with the `puts` method. This prints \"Hello.\"\n+\n+All good? Let's go over a similar, but subtly different example, in C++:\n+\n+```{cpp}\n+#include<iostream>\n+#include<vector>\n+#include<string>\n+\n+int main() {\n+    std::vector<std::string> v;\n+\n+    v.push_back(\"Hello\");\n+\n+    std::string& x = v[0];\n+\n+    v.push_back(\"world\");\n+\n+    std::cout << x;\n+}\n ```\n \n-Rust infers the correct type,\n-allocates the correct amount of memory and sets it to the value you asked for.\n-This means that it's impossible to allocate uninitialized memory:\n-*Rust does not have the concept of null*.\n-Hooray!\n-There's one other difference between this line of Rust and the C++:\n-The Rust compiler also figures out the lifetime of `i`,\n-and then inserts a corresponding `free` call after it's invalid,\n-like a destructor in C++.\n-You get all of the benefits of manually allocated heap memory without having to do all the bookkeeping yourself.\n-Furthermore, all of this checking is done at compile time,\n-so there's no runtime overhead.\n-You'll get (basically) the exact same code that you'd get if you wrote the correct C++,\n-but it's impossible to write the incorrect version, thanks to the compiler.\n-\n-You've seen one way that ownership and borrowing are useful to prevent code that would normally be dangerous in a less-strict language,\n-but let's talk about another: concurrency.\n-\n-# Owning concurrency\n-\n-Concurrency is an incredibly hot topic in the software world right now.\n-It's always been an interesting area of study for computer scientists,\n-but as usage of the Internet explodes,\n-people are looking to improve the number of users a given service can handle.\n-Concurrency is one way of achieving this goal.\n-There is a pretty big drawback to concurrent code, though:\n-it can be hard to reason about, because it is non-deterministic.\n-There are a few different approaches to writing good concurrent code,\n-but let's talk about how Rust's notions of ownership and lifetimes contribute to correct but concurrent code.\n-\n-First, let's go over a simple concurrency example.\n-Rust makes it easy to create \"tasks\",\n-otherwise known as \"threads\".\n-Typically, tasks do not share memory but instead communicate amongst each other with 'channels', like this:\n+It's a little more verbose due to the static typing, but it's almost the same\n+thing. We make a `std::vector` of `std::string`s, we call `push_back` (same as\n+`push`) on it, take a reference to the first element of the vector, call\n+`push_back` again, and then print out the reference.\n \n+There's two big differences here: one, they're not _exactly_ the same thing,\n+and two...\n+\n+```{bash}\n+$ g++ hello.cpp -Wall -Werror\n+$ ./a.out \n+Segmentation fault (core dumped)\n ```\n+\n+A crash! (Note that this is actually system-dependent. Because referring to an\n+invalid reference is undefined behavior, the compiler can do anything,\n+including the right thing!) Even though we compiled with flags to give us as\n+many warnings as possible, and to treat those warnings as errors, we got no\n+errors. When we ran the program, it crashed.\n+\n+Why does this happen? When we prepend to an array, its length changes. Since\n+its length changes, we may need to allocate more memory. In Ruby, this happens\n+as well, we just don't think about it very often. So why does the C++ version\n+segfault when we allocate more memory?\n+\n+The answer is that in the C++ version, `x` is a **reference** to the memory\n+location where the first element of the array is stored. But in Ruby, `x` is a\n+standalone value, not connected to the underyling array at all. Let's dig into\n+the details for a moment. Your program has access to memory, provided to it by\n+the operating system. Each location in memory has an address.  So when we make\n+our vector, `v`, it's stored in a memory location somewhere:\n+\n+| location | name | value |\n+|----------|------|-------|\n+| 0x30     | v    |       |\n+\n+(Address numbers made up, and in hexadecimal. Those of you with deep C++\n+knowledge, there are some simplifications going on here, like the lack of an\n+allocated length for the vector. This is an introduction.)\n+\n+When we push our first string onto the array, we allocate some memory,\n+and `v` refers to it:\n+\n+| location | name | value    |\n+|----------|------|----------|\n+| 0x30     | v    | 0x18     |\n+| 0x18     |      | \"Hello\"  |\n+\n+We then make a reference to that first element. A reference is a variable\n+that points to a memory location, so its value is the memory location of\n+the `\"Hello\"` string:\n+\n+| location | name | value    |\n+|----------|------|----------|\n+| 0x30     | v    | 0x18     |\n+| 0x18     |      | \"Hello\"  |\n+| 0x14     | x    | 0x18     |\n+\n+When we push `\"world\"` onto the vector with `push_back`, there's no room:\n+we only allocated one element. So, we need to allocate two elements,\n+copy the `\"Hello\"` string over, and update the reference. Like this:\n+\n+| location | name | value    |\n+|----------|------|----------|\n+| 0x30     | v    | 0x08     |\n+| 0x18     |      | GARBAGE  |\n+| 0x14     | x    | 0x18     |\n+| 0x08     |      | \"Hello\"  |\n+| 0x04     |      | \"world\"  |\n+\n+Note that `v` now refers to the new list, which has two elements. It's all\n+good. But our `x` didn't get updated! It still points at the old location,\n+which isn't valid anymore. In fact, [the documentation for `push_back` mentions\n+this](http://en.cppreference.com/w/cpp/container/vector/push_back):\n+\n+> If the new `size()` is greater than `capacity()` then all iterators and\n+> references (including the past-the-end iterator) are invalidated.\n+\n+Finding where these iterators and references are is a difficult problem, and\n+even in this simple case, `g++` can't help us here. While the bug is obvious in\n+this case, in real code, it can be difficult to track down the source of the\n+error.\n+\n+Before we talk about this solution, why didn't our Ruby code have this problem?\n+The semantics are a little more complicated, and explaining Ruby's internals is\n+out of the scope of a guide to Rust. But in a nutshell, Ruby's garbage\n+collector keeps track of references, and makes sure that everything works as\n+you might expect. This comes at an efficiency cost, and the internals are more\n+complex.  If you'd really like to dig into the details, [this\n+article](http://patshaughnessy.net/2012/1/18/seeing-double-how-ruby-shares-string-values)\n+can give you more information.\n+\n+Garbage collection is a valid approach to memory safety, but Rust chooses a\n+different path.  Let's examine what the Rust version of this looks like:\n+\n+```{rust,ignore}\n fn main() {\n-    let numbers = vec![1i, 2i, 3i];\n+    let mut v = vec![];\n \n-    let (tx, rx)  = channel();\n-    tx.send(numbers);\n+    v.push(\"Hello\");\n \n-    spawn(proc() {\n-        let numbers = rx.recv();\n-        println!(\"{}\", numbers[0]);\n-    })\n+    let x = &v[0];\n+\n+    v.push(\"world\");\n+\n+    println!(\"{}\", x);\n }\n ```\n \n-In this example, we create a boxed array of numbers.\n-We then make a 'channel',\n-Rust's primary means of passing messages between tasks.\n-The `channel` function returns two different ends of the channel:\n-a `Sender` and `Receiver` (commonly abbreviated `tx` and `rx`).\n-The `spawn` function spins up a new task,\n-given a *heap allocated closure* to run.\n-As you can see in the code,\n-we call `tx.send()` from the original task,\n-passing in our boxed array,\n-and we call `rx.recv()` (short for 'receive') inside of the new task:\n-values given to the `Sender` via the `send` method come out the other end via the `recv` method on the `Receiver`.\n-\n-Now here's the exciting part:\n-because `numbers` is an owned type,\n-when it is sent across the channel,\n-it is actually *moved*,\n-transferring ownership of `numbers` between tasks.\n-This ownership transfer is *very fast* -\n-in this case simply copying a pointer -\n-while also ensuring that the original owning task cannot create data races by continuing to read or write to `numbers` in parallel with the new owner.\n-\n-To prove that Rust performs the ownership transfer,\n-try to modify the previous example to continue using the variable `numbers`:\n-\n-```ignore\n+This looks like a bit of both: fewer type annotations, but we do create new\n+variables with `let`. The method name is `push`, some other stuff is different,\n+but it's pretty close. So what happens when we compile this code?  Does Rust\n+print `\"Hello\"`, or does Rust crash?\n+\n+Neither. It refuses to compile:\n+\n+```{notrust,ignore}\n+$ cargo run\n+   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n+main.rs:8:5: 8:6 error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+main.rs:8     v.push(\"world\");\n+              ^\n+main.rs:6:14: 6:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends\n+main.rs:6     let x = &v[0];\n+                       ^\n+main.rs:11:2: 11:2 note: previous borrow ends here\n+main.rs:1 fn main() {\n+...\n+main.rs:11 }\n+           ^\n+error: aborting due to previous error\n+```\n+\n+When we try to mutate the array by `push`ing it the second time, Rust throws\n+an error. It says that we \"cannot borrow v as mutable because it is also\n+borrowed as immutable.\" What's up with \"borrowed\"?\n+\n+In Rust, the type system encodes the notion of **ownership**. The variable `v`\n+is an \"owner\" of the vector. When we make a reference to `v`, we let that\n+variable (in this case, `x`) 'borrow' it for a while. Just like if you own a\n+book, and you lend it to me, I'm borrowing the book.\n+\n+So, when I try to modify the vector with the second call to `push`, I need\n+to be owning it. But `x` is borrowing it. You can't modify something that\n+you've lent to someone. And so Rust throws an error.\n+\n+So how do we fix this problem? Well, we can make a copy of the element:\n+\n+\n+```{rust}\n fn main() {\n-    let numbers = vec![1i, 2i, 3i];\n+    let mut v = vec![];\n \n-    let (tx, rx)  = channel();\n-    tx.send(numbers);\n+    v.push(\"Hello\");\n \n-    spawn(proc() {\n-        let numbers = rx.recv();\n-        println!(\"{}\", numbers[0]);\n-    });\n+    let x = v[0].clone();\n+\n+    v.push(\"world\");\n \n-    // Try to print a number from the original task\n-    println!(\"{}\", numbers[0]);\n+    println!(\"{}\", x);\n }\n ```\n \n-The compiler will produce an error indicating that the value is no longer in scope:\n+Note the addition of `clone()`. This creates a copy of the element, leaving\n+the original untouched. Now, we no longer have two references to the same\n+memory, and so the compiler is happy. Let's give that a try:\n \n-```text\n-concurrency.rs:12:20: 12:27 error: use of moved value: 'numbers'\n-concurrency.rs:12     println!(\"{}\", numbers[0]);\n-                                     ^~~~~~~\n+```{bash}\n+$ cargo run\n+   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n+     Running `target/hello_world`\n+Hello\n ```\n \n-Since only one task can own a boxed array at a time,\n-if instead of distributing our `numbers` array to a single task we wanted to distribute it to many tasks,\n-we would need to copy the array for each.\n-Let's see an example that uses the `clone` method to create copies of the data:\n+Same result. Now, making a copy can be inefficient, so this solution may not be\n+acceptable. There are other ways to get around this problem, but this is a toy\n+example, and because we're in an introduction, we'll leave that for later.\n \n-```\n-fn main() {\n-    let numbers = vec![1i, 2i, 3i];\n+The point is, the Rust compiler and its notion of ownership has saved us from a\n+bug that would crash the program. We've achieved safety, at compile time,\n+without needing to rely on a garbage collector to handle our memory.\n+\n+# Concurrency\n+\n+Rust's ownership model can help in other ways, as well. For example, take\n+concurrency. Concurrency is a big topic, and an important one for any modern\n+programming language. Let's take a look at how ownership can help you write\n+safe concurrent programs.\n \n-    for num in range(0u, 3) {\n-        let (tx, rx)  = channel();\n-        // Use `clone` to send a *copy* of the array\n-        tx.send(numbers.clone());\n+Here's an example of a concurrent Rust program:\n \n+```{rust}\n+fn main() {\n+    for _ in range(0u, 10u) {\n         spawn(proc() {\n-            let numbers = rx.recv();\n-            println!(\"{:d}\", numbers[num]);\n-        })\n+            println!(\"Hello, world!\");\n+        });\n     }\n }\n ```\n \n-This is similar to the code we had before,\n-except now we loop three times,\n-making three tasks,\n-and *cloning* `numbers` before sending it.\n+This program creates ten threads, who all print `Hello, world!`. The `spawn`\n+function takes one argument, a `proc`. 'proc' is short for 'procedure,' and is\n+a form of closure. This closure is executed in a new thread, created by `spawn`\n+itself.\n \n-However, if we're making a lot of tasks,\n-or if our data is very large,\n-creating a copy for each task requires a lot of work and a lot of extra memory for little benefit.\n-In practice, we might not want to do this because of the cost.\n-Enter `Arc`,\n-an atomically reference counted box (\"A.R.C.\" == \"atomically reference counted\").\n-`Arc` is the most common way to *share* data between tasks.\n-Here's some code:\n+One common form of problem in concurrent programs is a 'data race.' This occurs\n+when two different threads attempt to access the same location in memory in a\n+non-synchronized way, where at least one of them is a write. If one thread is\n+attempting to read, and one thread is attempting to write, you cannot be sure\n+that your data will not be corrupted. Note the first half of that requirement:\n+two threads that attempt to access the same location in memory. Rust's\n+ownership model can track which pointers own which memory locations, which\n+solves this problem.\n \n-```\n-use std::sync::Arc;\n+Let's see an example. This Rust code will not compile:\n \n+```{rust,ignore}\n fn main() {\n-    let numbers = Arc::new(vec![1i, 2i, 3i]);\n-\n-    for num in range(0u, 3) {\n-        let (tx, rx)  = channel();\n-        tx.send(numbers.clone());\n+    let mut numbers = vec![1i, 2i, 3i];\n \n+    for i in range(0u, 3u) {\n         spawn(proc() {\n-            let numbers = rx.recv();\n-            println!(\"{:d}\", (*numbers)[num as uint]);\n-        })\n+            for j in range(0, 3) { numbers[j] += 1 }\n+        });\n     }\n }\n ```\n \n-This is almost exactly the same,\n-except that this time `numbers` is first put into an `Arc`.\n-`Arc::new` creates the `Arc`,\n-`.clone()` makes another `Arc` that refers to the same contents.\n-So we clone the `Arc` for each task,\n-send that clone down the channel,\n-and then use it to print out a number.\n-Now instead of copying an entire array to send it to our multiple tasks we are just copying a pointer (the `Arc`) and *sharing* the array.\n-\n-How can this work though?\n-Surely if we're sharing data then can't we cause data races if one task writes to the array while others read?\n-\n-Well, Rust is super-smart and will only let you put data into an `Arc` that is provably safe to share.\n-In this case, it's safe to share the array *as long as it's immutable*,\n-i.e. many tasks may read the data in parallel as long as none can write.\n-So for this type and many others `Arc` will only give you an immutable view of the data.\n-\n-Arcs are great for immutable data,\n-but what about mutable data?\n-Shared mutable state is the bane of the concurrent programmer:\n-you can use a mutex to protect shared mutable state,\n-but if you forget to acquire the mutex, bad things can happen, including crashes.\n-Rust provides mutexes but makes it impossible to use them in a way that subverts memory safety.\n-\n-Let's take the same example yet again,\n-and modify it to mutate the shared state:\n+It gives us this error:\n \n+```{notrust,ignore}\n+6:71 error: capture of moved value: `numbers`\n+    for j in range(0, 3) { numbers[j] += 1 }\n+               ^~~~~~~\n+7:50 note: `numbers` moved into closure environment here because it has type `proc():Send`, which is non-copyable (perhaps you meant to use clone()?)\n+    spawn(proc() {\n+        for j in range(0, 3) { numbers[j] += 1 }\n+    });\n+6:79 error: cannot assign to immutable dereference (dereference is implicit, due to indexing)\n+        for j in range(0, 3) { numbers[j] += 1 }\n+                           ^~~~~~~~~~~~~~~\n ```\n-use std::sync::{Arc, Mutex};\n \n-fn main() {\n-    let numbers_lock = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n+It mentions that \"numbers moved into closure environment\". Because we referred\n+to `numbers` inside of our `proc`, and we create ten `proc`s, we would have ten\n+references. Rust detects this and gives us the error: we claim that `numbers`\n+has ownership, but our code tries to make ten owners. This may cause a safety\n+problem, so Rust disallows it.\n+\n+What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n+\"Arc\" stands for \"atomically reference counted.\" In other words, an Arc will\n+keep track of the number of references to something, and not free the\n+associated resource until the count is zero. The 'atomic' portion refers to an\n+Arc's usage of concurrency primitives to atomically update the count, making it\n+safe across threads. If we use an Arc, we can have our ten references. But, an\n+Arc does not allow mutable borrows of the data it holds, and we want to modify\n+what we're sharing. In this case, we can use a `Mutex<T>` inside of our Arc. A\n+Mutex will synchronize our accesses, so that we can ensure that our mutation\n+doesn't cause a data race.\n+\n+Here's what using an Arc with a Mutex looks like:\n+\n+```{rust}\n+use std::sync::{Arc,Mutex};\n \n-    for num in range(0u, 3) {\n-        let (tx, rx)  = channel();\n-        tx.send(numbers_lock.clone());\n+fn main() {\n+    let numbers = Arc::new(Mutex::new(vec![1i, 2i, 3i]));\n \n+    for i in range(0u, 3u) {\n+        let number = numbers.clone();\n         spawn(proc() {\n-            let numbers_lock = rx.recv();\n+            let mut array = number.lock();\n+\n+            (*(*array).get_mut(i)) += 1;\n \n-            // Take the lock, along with exclusive access to the underlying array\n-            let mut numbers = numbers_lock.lock();\n+            println!(\"numbers[{}] is {}\", i, (*array)[i]);\n+        });\n+    }\n+}\n+```\n+\n+We first have to `use` the appropriate library, and then we wrap our vector in\n+an Arc with the call to `Arc::new()`. Inside of the loop, we make a new\n+reference to the Arc with the `clone()` method. This will increment the\n+reference count. When each new `numbers` variable binding goes out of scope, it\n+will decrement the count. The `lock()` call will return us a reference to the\n+value inside the Mutex, and block any other calls to `lock()` until said\n+reference goes out of scope.\n+\n+We can compile and run this program without error, and in fact, see the\n+non-deterministic aspect:\n+\n+```{shell}\n+$ cargo run\n+   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n+     Running `target/hello_world`\n+numbers[1] is 2\n+numbers[0] is 1\n+numbers[2] is 3\n+$ cargo run\n+     Running `target/hello_world`\n+numbers[2] is 3\n+numbers[1] is 2\n+numbers[0] is 1\n+```\n \n-            // This is ugly for now because of the need for `get_mut`, but\n-            // will be replaced by `numbers[num as uint] += 1`\n-            // in the near future.\n-            // See: https://github.com/rust-lang/rust/issues/6515\n-            *numbers.get_mut(num as uint) += 1;\n+Each time, we get a slightly different output, because each thread works in a\n+different order. You may not get the same output as this sample, even.\n \n-            println!(\"{}\", (*numbers)[num as uint]);\n+The important part here is that the Rust compiler was able to use ownership to\n+give us assurance _at compile time_ that we weren't doing something incorrect\n+with regards to concurrency. In order to share ownership, we were forced to be\n+explicit and use a mechanism to ensure that it would be properly handled.\n \n-            // When `numbers` goes out of scope the lock is dropped\n-        })\n+# Safety _and_ speed\n+\n+Safety and speed are always presented as a continuum. On one hand, you have\n+maximum speed, but no safety. On the other, you have absolute safety, with no\n+speed. Rust seeks to break out of this mode by introducing safety at compile\n+time, ensuring that you haven't done anything wrong, while compiling to the\n+same low-level code you'd expect without the safety.\n+\n+As an example, Rust's ownership system is _entirely_ at compile time. The\n+safety check that makes this an error about moved values:\n+\n+```{rust,ignore}\n+fn main() {\n+    let vec = vec![1i, 2, 3];\n+\n+    for i in range(1u, 3) {\n+        spawn(proc() {\n+            println!(\"{}\", vec[i]);\n+        });\n     }\n }\n ```\n \n-This example is starting to get more subtle,\n-but it hints at the powerful composability of Rust's concurrent types.\n-This time we've put our array of numbers inside a `Mutex` and then put *that* inside the `Arc`.\n-Like immutable data,\n-`Mutex`es are sharable,\n-but unlike immutable data,\n-data inside a `Mutex` may be mutated as long as the mutex is locked.\n-\n-The `lock` method here returns not your original array or a pointer thereof,\n-but a `MutexGuard`,\n-a type that is responsible for releasing the lock when it goes out of scope.\n-This same `MutexGuard` can transparently be treated as if it were the value the `Mutex` contains,\n-as you can see in the subsequent indexing operation that performs the mutation.\n-\n-OK, let's stop there before we get too deep.\n-\n-# A footnote: unsafe\n-\n-The Rust compiler and libraries are entirely written in Rust;\n-we say that Rust is \"self-hosting\".\n-If Rust makes it impossible to unsafely share data between threads,\n-and Rust is written in Rust,\n-then how does it implement concurrent types like `Arc` and `Mutex`?\n-The answer: `unsafe`.\n-\n-You see, while the Rust compiler is very smart,\n-and saves you from making mistakes you might normally make,\n-it's not an artificial intelligence.\n-Because we're smarter than the compiler -\n-sometimes - we need to over-ride this safe behavior.\n-For this purpose, Rust has an `unsafe` keyword.\n-Within an `unsafe` block,\n-Rust turns off many of its safety checks.\n-If something bad happens to your program,\n-you only have to audit what you've done inside `unsafe`,\n-and not the entire program itself.\n-\n-If one of the major goals of Rust was safety,\n-why allow that safety to be turned off?\n-Well, there are really only three main reasons to do it:\n-interfacing with external code,\n-such as doing FFI into a C library;\n-performance (in certain cases);\n-and to provide a safe abstraction around operations that normally would not be safe.\n-Our `Arc`s are an example of this last purpose.\n-We can safely hand out multiple pointers to the contents of the `Arc`,\n-because we are sure the data is safe to share.\n-But the Rust compiler can't know that we've made these choices,\n-so _inside_ the implementation of the Arcs,\n-we use `unsafe` blocks to do (normally) dangerous things.\n-But we expose a safe interface,\n-which means that the `Arc`s are impossible to use incorrectly.\n-\n-This is how Rust's type system prevents you from making some of the mistakes that make concurrent programming difficult,\n-yet get the efficiency of languages such as C++.\n-\n-# That's all, folks\n-\n-I hope that this taste of Rust has given you an idea if Rust is the right language for you.\n-If that's true,\n-I encourage you to check out [the guide](guide.html) for a full,\n+carries no runtime penalty. And while some of Rust's safety features do have\n+a run-time cost, there's often a way to write your code in such a way that\n+you can remove it. As an example, this is a poor way to iterate through\n+a vector:\n+\n+```{rust}\n+let vec = vec![1i, 2, 3];\n+\n+for i in range(1u, vec.len()) {\n+     println!(\"{}\", vec[i]);\n+}\n+```\n+\n+The reason is that the access of `vec[i]` does bounds checking, to ensure\n+that we don't try to access an invalid index. However, we can remove this\n+while retaining safety. The answer is iterators:\n+\n+```{rust}\n+let vec = vec![1i, 2, 3];\n+\n+for x in vec.iter() {\n+    println!(\"{}\", x);\n+}\n+```\n+\n+This version uses an iterator that yields each element of the vector in turn.\n+Because we have a reference to the element, rather than the whole vector itself,\n+there's no array access bounds to check.\n+\n+# Learning More\n+\n+I hope that this taste of Rust has given you an idea if Rust is the right\n+language for you. We talked about Rust's tooling, how encoding ownership into\n+the type system helps you find bugs, how Rust can help you write correct\n+concurrent code, and how you don't have to pay a speed cost for much of this\n+safety.\n+\n+To continue your Rustic education, read [the guide](guide.html) for a more\n in-depth exploration of Rust's syntax and concepts."}]}