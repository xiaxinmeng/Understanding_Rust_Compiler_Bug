{"sha": "3d34e177dd19bfbc6885b03eac0632adc9c621b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMzRlMTc3ZGQxOWJmYmM2ODg1YjAzZWFjMDYzMmFkYzljNjIxYjI=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T12:11:14Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T12:11:14Z"}, "message": "core: use banker's rounding for the exact mode in flt2dec.\n\nFor the shortest mode the IEEE 754 decoder already provides\nan exact rounding range accounting for banker's rounding,\nbut it was not the case for the exact mode. This commit alters\nthe exact mode algorithm for Dragon so that any number ending at\n`...x5000...` with even `x` and infinite zeroes will round to\n`...x` instead of `...(x+1)` as it was. Grisu is not affected\nby this change because this halfway case always results in\nthe failure for Grisu.", "tree": {"sha": "7552928ee99af9f398ac719a2ce016e5e352835d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7552928ee99af9f398ac719a2ce016e5e352835d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d34e177dd19bfbc6885b03eac0632adc9c621b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d34e177dd19bfbc6885b03eac0632adc9c621b2", "html_url": "https://github.com/rust-lang/rust/commit/3d34e177dd19bfbc6885b03eac0632adc9c621b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d34e177dd19bfbc6885b03eac0632adc9c621b2/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a641b05fda448d3388347838076e3c583a5f8fa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a641b05fda448d3388347838076e3c583a5f8fa4", "html_url": "https://github.com/rust-lang/rust/commit/a641b05fda448d3388347838076e3c583a5f8fa4"}], "stats": {"total": 29, "additions": 23, "deletions": 6}, "files": [{"sha": "a819932525bd14259559a5c8fb407fbfa9d1bb42", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d34e177dd19bfbc6885b03eac0632adc9c621b2/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d34e177dd19bfbc6885b03eac0632adc9c621b2/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=3d34e177dd19bfbc6885b03eac0632adc9c621b2", "patch": "@@ -307,7 +307,11 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     }\n \n     // rounding up if we stop in the middle of digits\n-    if mant >= *scale.mul_small(5) {\n+    // if the following digits are exactly 5000..., check the prior digit and try to\n+    // round to even (i.e. avoid rounding up when the prior digit is even).\n+    let order = mant.cmp(scale.mul_small(5));\n+    if order == Ordering::Greater || (order == Ordering::Equal &&\n+                                      (len == 0 || buf[len-1] & 1 == 1)) {\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n         if let Some(c) = round_up(buf, len) {"}, {"sha": "488cd3a779ca30e30f94d5f8f7bbf6d3bb1eaa1c", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d34e177dd19bfbc6885b03eac0632adc9c621b2/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d34e177dd19bfbc6885b03eac0632adc9c621b2/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=3d34e177dd19bfbc6885b03eac0632adc9c621b2", "patch": "@@ -105,11 +105,17 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n         bytes::copy_memory(&expected[..i], &mut expected_);\n         let mut expectedk_ = expectedk;\n         if expected[i] >= b'5' {\n-            // if this returns true, expected_[..i] is all `9`s and being rounded up.\n-            // we should always return `100..00` (`i` digits) instead, since that's\n-            // what we can came up with `i` digits anyway. `round_up` assumes that\n-            // the adjustment to the length is done by caller, which we simply ignore.\n-            if let Some(_) = round_up(&mut expected_, i) { expectedk_ += 1; }\n+            // check if this is a rounding-to-even case.\n+            // we avoid rounding ...x5000... (with infinite zeroes) to ...(x+1) when x is even.\n+            if !(i+1 < expected.len() && expected[i-1] & 1 == 0 &&\n+                                         expected[i] == b'5' &&\n+                                         expected[i+1] == b' ') {\n+                // if this returns true, expected_[..i] is all `9`s and being rounded up.\n+                // we should always return `100..00` (`i` digits) instead, since that's\n+                // what we can came up with `i` digits anyway. `round_up` assumes that\n+                // the adjustment to the length is done by caller, which we simply ignore.\n+                if let Some(_) = round_up(&mut expected_, i) { expectedk_ += 1; }\n+            }\n         }\n \n         try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk_;\n@@ -243,6 +249,7 @@ pub fn f32_exact_sanity_test<F>(mut f: F)\n     let minf32 = f32::ldexp(1.0, -149);\n \n     check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n+    check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n     check_exact!(f(1.0f32/3.0)        => b\"3333333432674407958984375               \", 0);\n     check_exact!(f(3.141592f32)       => b\"31415920257568359375                    \", 1);\n     check_exact!(f(3.141592e17f32)    => b\"314159196796878848                      \", 18);\n@@ -348,6 +355,7 @@ pub fn f64_exact_sanity_test<F>(mut f: F)\n \n     check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n     check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n+    check_exact!(f(0.5f64)            => b\"5                                       \", 0);\n     check_exact!(f(0.95f64)           => b\"9499999999999999555910790149937383830547\", 0);\n     check_exact!(f(100.0f64)          => b\"1                                       \", 3);\n     check_exact!(f(999.5f64)          => b\"9995000000000000000000000000000000000000\", 3);\n@@ -1032,6 +1040,11 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, 999.5, Minus,  3, false), \"999.500\");\n     assert_eq!(to_string(f, 999.5, Minus, 30, false), \"999.500000000000000000000000000000\");\n \n+    assert_eq!(to_string(f, 0.5, Minus, 0, false), \"1\");\n+    assert_eq!(to_string(f, 0.5, Minus, 1, false), \"0.5\");\n+    assert_eq!(to_string(f, 0.5, Minus, 2, false), \"0.50\");\n+    assert_eq!(to_string(f, 0.5, Minus, 3, false), \"0.500\");\n+\n     assert_eq!(to_string(f, 0.95, Minus,  0, false), \"1\");\n     assert_eq!(to_string(f, 0.95, Minus,  1, false), \"0.9\"); // because it really is less than 0.95\n     assert_eq!(to_string(f, 0.95, Minus,  2, false), \"0.95\");"}]}