{"sha": "45043374ff4d4eb48bed52ff8f8251f9cddf239a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MDQzMzc0ZmY0ZDRlYjQ4YmVkNTJmZjhmODI1MWY5Y2RkZjIzOWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-01T00:31:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-01T00:32:00Z"}, "message": "Tidy up structural types for rec, tup AST and typeck nodes.", "tree": {"sha": "7a6e5d2114776a896f5d1f7c70f89f1d68ff1781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a6e5d2114776a896f5d1f7c70f89f1d68ff1781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45043374ff4d4eb48bed52ff8f8251f9cddf239a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45043374ff4d4eb48bed52ff8f8251f9cddf239a", "html_url": "https://github.com/rust-lang/rust/commit/45043374ff4d4eb48bed52ff8f8251f9cddf239a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45043374ff4d4eb48bed52ff8f8251f9cddf239a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "567a45cc70424b77cac489940a36ff8a6ea97b84", "url": "https://api.github.com/repos/rust-lang/rust/commits/567a45cc70424b77cac489940a36ff8a6ea97b84", "html_url": "https://github.com/rust-lang/rust/commit/567a45cc70424b77cac489940a36ff8a6ea97b84"}], "stats": {"total": 234, "additions": 117, "deletions": 117}, "files": [{"sha": "9b503c71b2f4829916d636c5d447913294ef6e21", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=45043374ff4d4eb48bed52ff8f8251f9cddf239a", "patch": "@@ -109,11 +109,14 @@ tag decl_ {\n \n type arm = rec(@pat pat, block block);\n \n+type elt = rec(mutability mut, @expr expr);\n+type field = rec(mutability mut, ident ident, @expr expr);\n+\n type expr = spanned[expr_];\n tag expr_ {\n     expr_vec(vec[@expr], ann);\n-    expr_tup(vec[tup(mutability, @expr)], ann);\n-    expr_rec(vec[tup(ident,@expr)], ann);\n+    expr_tup(vec[elt], ann);\n+    expr_rec(vec[field], ann);\n     expr_call(@expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);\n     expr_unary(unop, @expr, ann);\n@@ -143,6 +146,7 @@ tag lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/typeck.rs as well.\n+type ty_field = rec(ident ident, @ty ty);\n type ty = spanned[ty_];\n tag ty_ {\n     ty_nil;\n@@ -155,7 +159,7 @@ tag ty_ {\n     ty_box(@ty);\n     ty_vec(@ty);\n     ty_tup(vec[@ty]);\n-    ty_rec(vec[tup(ident,@ty)]);\n+    ty_rec(vec[ty_field]);\n     ty_fn(vec[rec(mode mode, @ty ty)], @ty);        // TODO: effect\n     ty_path(path, option.t[def]);\n     ty_mutable(@ty);"}, {"sha": "709dbc056c4742afa70e9b083aabcfe35bb103e3", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=45043374ff4d4eb48bed52ff8f8251f9cddf239a", "patch": "@@ -189,17 +189,17 @@ impure fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.REC) {\n             p.bump();\n-            impure fn parse_field(parser p) -> tup(ast.ident, @ast.ty) {\n+            impure fn parse_field(parser p) -> ast.ty_field {\n                 auto ty = parse_ty(p);\n                 auto id = parse_ident(p);\n-                ret tup(id,ty);\n+                ret rec(ident=id, ty=ty);\n             }\n             auto f = parse_field; // FIXME: trans_const_lval bug\n             auto elems =\n-                parse_seq[tup(ast.ident, @ast.ty)](token.LPAREN,\n-                                                   token.RPAREN,\n-                                                   some(token.COMMA),\n-                                                   f, p);\n+                parse_seq[ast.ty_field](token.LPAREN,\n+                                        token.RPAREN,\n+                                        some(token.COMMA),\n+                                        f, p);\n             hi = p.get_span();\n             t = ast.ty_rec(elems.node);\n         }\n@@ -352,17 +352,12 @@ impure fn parse_name(parser p, ast.ident id) -> ast.name {\n     ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n }\n \n-impure fn parse_possibly_mutable_expr(parser p)\n-    -> tup(ast.mutability, @ast.expr) {\n-    auto mut;\n+impure fn parse_mutabliity(parser p) -> ast.mutability {\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n-        mut = ast.mut;\n-    } else {\n-        mut = ast.imm;\n+        ret ast.mut;\n     }\n-\n-    ret tup(mut, parse_expr(p));\n+    ret ast.imm;\n }\n \n impure fn parse_bottom_expr(parser p) -> @ast.expr {\n@@ -415,13 +410,17 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.TUP) {\n             p.bump();\n-            auto pf = parse_possibly_mutable_expr;\n+            impure fn parse_elt(parser p) -> ast.elt {\n+                auto m = parse_mutabliity(p);\n+                auto e = parse_expr(p);\n+                ret rec(mut=m, expr=e);\n+            }\n+            auto pf = parse_elt;\n             auto es =\n-                parse_seq[tup(ast.mutability, @ast.expr)]\n-                (token.LPAREN,\n-                 token.RPAREN,\n-                 some(token.COMMA),\n-                 pf, p);\n+                parse_seq[ast.elt](token.LPAREN,\n+                                   token.RPAREN,\n+                                   some(token.COMMA),\n+                                   pf, p);\n             hi = es.span;\n             ex = ast.expr_tup(es.node, ast.ann_none);\n         }\n@@ -439,21 +438,21 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.REC) {\n             p.bump();\n-            impure fn parse_entry(parser p) ->\n-                tup(ast.ident, @ast.expr) {\n+            impure fn parse_field(parser p) -> ast.field {\n+                auto m = parse_mutabliity(p);\n                 auto i = parse_ident(p);\n                 expect(p, token.EQ);\n                 auto e = parse_expr(p);\n-                ret tup(i, e);\n+                ret rec(mut=m, ident=i, expr=e);\n             }\n-            auto pf = parse_entry;\n-            auto es =\n-                parse_seq[tup(ast.ident, @ast.expr)](token.LPAREN,\n-                                                     token.RPAREN,\n-                                                     some(token.COMMA),\n-                                                     pf, p);\n-            hi = es.span;\n-            ex = ast.expr_rec(es.node, ast.ann_none);\n+            auto pf = parse_field;\n+            auto fs =\n+                parse_seq[ast.field](token.LPAREN,\n+                                     token.RPAREN,\n+                                     some(token.COMMA),\n+                                     pf, p);\n+            hi = fs.span;\n+            ex = ast.expr_rec(fs.node, ast.ann_none);\n         }\n \n         case (_) {"}, {"sha": "458f9e95f50de11a5ccb9353e5b19a394c8e4bbf", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=45043374ff4d4eb48bed52ff8f8251f9cddf239a", "patch": "@@ -49,7 +49,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, vec[@ty] elts) -> @ty) fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(ident,@ty)] elts) -> @ty)        fold_ty_rec,\n+         vec[ast.ty_field] elts) -> @ty)          fold_ty_rec,\n \n      (fn(&ENV e, &span sp,\n          vec[rec(ast.mode mode, @ty ty)] inputs,\n@@ -65,12 +65,10 @@ type ast_fold[ENV] =\n          vec[@expr] es, ann a) -> @expr)          fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(mutability,@expr)] es,\n-         ann a) -> @expr)                         fold_expr_tup,\n+         vec[ast.elt] es, ann a) -> @expr)        fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(ident,@expr)] fields,\n-         ann a) -> @expr)                         fold_expr_rec,\n+         vec[ast.field] fields, ann a) -> @expr)  fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n          @expr f, vec[@expr] args,\n@@ -252,16 +250,16 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             for (@ty elt in elts) {\n                 append[@ty](elts_,fold_ty(env, fld, elt));\n             }\n-            ret fld.fold_ty_tup(env_, t.span, elts);\n+            ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n \n-        case (ast.ty_rec(?elts)) {\n-            let vec[tup(ident,@ty)] elts_ = vec();\n-            for (tup(ident, @ty) elt in elts) {\n-                append[tup(ident, @ty)]\n-                    (elts_, tup(elt._0, fold_ty(env, fld, elt._1)));\n+        case (ast.ty_rec(?flds)) {\n+            let vec[ast.ty_field] flds_ = vec();\n+            for (ast.ty_field f in flds) {\n+                append[ast.ty_field]\n+                    (flds_, rec(ty=fold_ty(env, fld, f.ty) with f));\n             }\n-            ret fld.fold_ty_rec(env_, t.span, elts);\n+            ret fld.fold_ty_rec(env_, t.span, flds_);\n         }\n \n         case (ast.ty_path(?pth, ?ref_opt)) {\n@@ -347,14 +345,13 @@ fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     ret exprs;\n }\n \n-fn fold_tup_entry[ENV](&ENV env, ast_fold[ENV] fld,\n-                       &tup(mutability,@expr) e) -> tup(mutability,@expr) {\n-    ret tup(e._0, fold_expr(env, fld, e._1));\n+fn fold_tup_elt[ENV](&ENV env, ast_fold[ENV] fld, &ast.elt e) -> ast.elt {\n+    ret rec(expr=fold_expr(env, fld, e.expr) with e);\n }\n \n-fn fold_rec_entry[ENV](&ENV env, ast_fold[ENV] fld, &tup(ident,@expr) e)\n-    -> tup(ident,@expr) {\n-    ret tup(e._0, fold_expr(env, fld, e._1));\n+fn fold_rec_field[ENV](&ENV env, ast_fold[ENV] fld, &ast.field f)\n+    -> ast.field {\n+    ret rec(expr=fold_expr(env, fld, f.expr) with f);\n }\n \n fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n@@ -372,19 +369,19 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n         }\n \n         case (ast.expr_tup(?es, ?t)) {\n-            let vec[tup(mutability,@expr)] entries = vec();\n-            for (tup(mutability,@expr) entry in es) {\n-                entries += fold_tup_entry[ENV](env, fld, entry);\n+            let vec[ast.elt] elts = vec();\n+            for (ast.elt e in es) {\n+                elts += fold_tup_elt[ENV](env, fld, e);\n             }\n-            ret fld.fold_expr_tup(env_, e.span, entries, t);\n+            ret fld.fold_expr_tup(env_, e.span, elts, t);\n         }\n \n-        case (ast.expr_rec(?es, ?t)) {\n-            let vec[tup(ident,@expr)] entries = vec();\n-            for (tup(ident,@expr) entry in es) {\n-                entries += fold_rec_entry(env, fld, entry);\n+        case (ast.expr_rec(?fs, ?t)) {\n+            let vec[ast.field] fields = vec();\n+            for (ast.field f in fs) {\n+                fields += fold_rec_field(env, fld, f);\n             }\n-            ret fld.fold_expr_rec(env_, e.span, entries, t);\n+            ret fld.fold_expr_rec(env_, e.span, fields, t);\n         }\n \n         case (ast.expr_call(?f, ?args, ?t)) {\n@@ -680,7 +677,7 @@ fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_ty_rec[ENV](&ENV env, &span sp,\n-                             vec[tup(ident,@ty)] elts) -> @ty {\n+                             vec[ast.ty_field] elts) -> @ty {\n     ret @respan(sp, ast.ty_rec(elts));\n }\n \n@@ -708,13 +705,12 @@ fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n-                               vec[tup(mutability, @expr)] es,\n-                               ann a) -> @expr {\n+                               vec[ast.elt] es, ann a) -> @expr {\n     ret @respan(sp, ast.expr_tup(es, a));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               vec[tup(ident,@expr)] fields, ann a) -> @expr {\n+                               vec[ast.field] fields, ann a) -> @expr {\n     ret @respan(sp, ast.expr_rec(fields, a));\n }\n "}, {"sha": "bc5801661c5bdbc3e53cdf9be613d38dcdcfac42", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=45043374ff4d4eb48bed52ff8f8251f9cddf239a", "patch": "@@ -1197,15 +1197,15 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n             args_res._0.build.FastCall(f_res._0.val, args_res._1));\n }\n \n-impure fn trans_tup(@block_ctxt cx, vec[tup(ast.mutability, @ast.expr)] args,\n+impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n                     &ast.ann ann) -> result {\n     auto ty = node_type(cx.fcx.ccx, ann);\n     auto tup_val = cx.build.Alloca(ty);\n     let int i = 0;\n     auto r = res(cx, C_nil());\n-    for (tup(ast.mutability, @ast.expr) arg in args) {\n-        auto t = typeck.expr_ty(arg._1);\n-        auto src_res = trans_expr(r.bcx, arg._1);\n+    for (ast.elt e in elts) {\n+        auto t = typeck.expr_ty(e.expr);\n+        auto src_res = trans_expr(r.bcx, e.expr);\n         auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n         // FIXME: calculate copy init-ness in typestate.\n         r = copy_ty(src_res.bcx, true, dst_elt, src_res.val, t);\n@@ -1214,21 +1214,21 @@ impure fn trans_tup(@block_ctxt cx, vec[tup(ast.mutability, @ast.expr)] args,\n     ret res(r.bcx, tup_val);\n }\n \n-impure fn trans_rec(@block_ctxt cx, vec[tup(ast.ident, @ast.expr)] args,\n+impure fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n                     &ast.ann ann) -> result {\n     auto ty = node_type(cx.fcx.ccx, ann);\n-    auto tup_val = cx.build.Alloca(ty);\n+    auto rec_val = cx.build.Alloca(ty);\n     let int i = 0;\n     auto r = res(cx, C_nil());\n-    for (tup(ast.ident, @ast.expr) arg in args) {\n-        auto t = typeck.expr_ty(arg._1);\n-        auto src_res = trans_expr(r.bcx, arg._1);\n-        auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n+    for (ast.field f in fields) {\n+        auto t = typeck.expr_ty(f.expr);\n+        auto src_res = trans_expr(r.bcx, f.expr);\n+        auto dst_elt = r.bcx.build.GEP(rec_val, vec(C_int(0), C_int(i)));\n         // FIXME: calculate copy init-ness in typestate.\n         r = copy_ty(src_res.bcx, true, dst_elt, src_res.val, t);\n         i += 1;\n     }\n-    ret res(r.bcx, tup_val);\n+    ret res(r.bcx, rec_val);\n }\n \n "}, {"sha": "b34b8b58bd804ebc66702f8255e7980279387bfc", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45043374ff4d4eb48bed52ff8f8251f9cddf239a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=45043374ff4d4eb48bed52ff8f8251f9cddf239a", "patch": "@@ -26,7 +26,7 @@ type fn_ctxt = rec(@ty ret_ty,\n                    @crate_ctxt ccx);\n \n type arg = rec(ast.mode mode, @ty ty);\n-type field = rec(ast.ident label, @ty ty);\n+type field = rec(ast.ident ident, @ty ty);\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -83,8 +83,8 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n         ret s + ast_ty_to_str(input.ty);\n     }\n \n-    fn ast_field_to_str(&tup(ast.ident, @ast.ty) f) -> str {\n-        ret ast_ty_to_str(f._1) + \" \" + f._0;\n+    fn ast_ty_field_to_str(&ast.ty_field f) -> str {\n+        ret ast_ty_to_str(f.ty) + \" \" + f.ident;\n     }\n \n     auto s;\n@@ -99,18 +99,17 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n         case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n         case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n \n-        case (ast.ty_tup(?elems)) {\n+        case (ast.ty_tup(?elts)) {\n             auto f = ast_ty_to_str;\n             s = \"tup(\";\n-            s += _str.connect(_vec.map[@ast.ty,str](f, elems), \",\");\n+            s += _str.connect(_vec.map[@ast.ty,str](f, elts), \",\");\n             s += \")\";\n         }\n \n-        case (ast.ty_rec(?elems)) {\n-            auto f = ast_field_to_str;\n+        case (ast.ty_rec(?fields)) {\n+            auto f = ast_ty_field_to_str;\n             s = \"rec(\";\n-            s += _str.connect(_vec.map[tup(ast.ident, @ast.ty),str]\n-                              (f, elems), \",\");\n+            s += _str.connect(_vec.map[ast.ty_field,str](f, fields), \",\");\n             s += \")\";\n         }\n \n@@ -172,7 +171,7 @@ fn ty_to_str(&@ty typ) -> str {\n     }\n \n     fn field_to_str(&field f) -> str {\n-        ret ty_to_str(f.ty) + \" \" + f.label;\n+        ret ty_to_str(f.ty) + \" \" + f.ident;\n     }\n \n     auto s = \"\";\n@@ -251,9 +250,9 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n-            for (tup(ast.ident, @ast.ty) f in fields) {\n-                append[field](flds, rec(label=f._0,\n-                                        ty=ast_ty_to_ty(getter, f._1)));\n+            for (ast.ty_field f in fields) {\n+                append[field](flds, rec(ident=f.ident,\n+                                        ty=ast_ty_to_ty(getter, f.ty)));\n             }\n             sty = ty_rec(flds);\n         }\n@@ -478,7 +477,7 @@ fn field_idx(session.session sess, &span sp,\n              &ast.ident id, vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) {\n-        if (_str.eq(f.label, id)) {\n+        if (_str.eq(f.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -812,11 +811,11 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                                 ret ures_err(err, expected, actual);\n                             }\n \n-                            if (!_str.eq(expected_field.label,\n-                                        actual_field.label)) {\n+                            if (!_str.eq(expected_field.ident,\n+                                        actual_field.ident)) {\n                                 auto err =\n-                                    terr_record_fields(expected_field.label,\n-                                                       actual_field.label);\n+                                    terr_record_fields(expected_field.ident,\n+                                                       actual_field.ident);\n                                 ret ures_err(err, expected, actual);\n                             }\n \n@@ -1339,40 +1338,42 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                       ast.ann_type(t_1)));\n         }\n \n-        case (ast.expr_tup(?args, _)) {\n-            let vec[tup(mutability, @ast.expr)] args_1 = vec();\n-            let vec[@ty] args_t = vec();\n+        case (ast.expr_tup(?elts, _)) {\n+            let vec[ast.elt] elts_1 = vec();\n+            let vec[@ty] elts_t = vec();\n \n-            for (tup(mutability, @ast.expr) arg in args) {\n-                auto expr_1 = check_expr(fcx, arg._1);\n-                args_1 += tup(arg._0, expr_1);\n-                if (arg._0 == ast.mut) {\n-                    append[@ty](args_t,@rec(mut=ast.mut\n-                                            with *expr_ty(expr_1)));\n-                } else {\n-                    append[@ty](args_t,expr_ty(expr_1));\n+            for (ast.elt e in elts) {\n+                auto expr_1 = check_expr(fcx, e.expr);\n+                auto expr_t = expr_ty(expr_1);\n+                if (e.mut == ast.mut) {\n+                    expr_t = @rec(mut=ast.mut with *expr_t);\n                 }\n+                append[ast.elt](elts_1, rec(expr=expr_1 with e));\n+                append[@ty](elts_t, expr_t);\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty_tup(args_t)));\n+            auto ann = ast.ann_type(plain_ty(ty_tup(elts_t)));\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_tup(args_1, ann));\n+                                        ast.expr_tup(elts_1, ann));\n         }\n \n-        case (ast.expr_rec(?args, _)) {\n-            let vec[tup(ast.ident, @ast.expr)] args_1 = vec();\n-            let vec[field] args_t = vec();\n+        case (ast.expr_rec(?fields, _)) {\n+            let vec[ast.field] fields_1 = vec();\n+            let vec[field] fields_t = vec();\n \n-            for (tup(ast.ident, @ast.expr) arg in args) {\n-                auto expr_1 = check_expr(fcx, arg._1);\n-                args_1 += tup(arg._0, expr_1);\n-                append[field](args_t,rec(label=arg._0,\n-                                         ty=expr_ty(expr_1)));\n+            for (ast.field f in fields) {\n+                auto expr_1 = check_expr(fcx, f.expr);\n+                auto expr_t = expr_ty(expr_1);\n+                if (f.mut == ast.mut) {\n+                    expr_t = @rec(mut=ast.mut with *expr_t);\n+                }\n+                append[ast.field](fields_1, rec(expr=expr_1 with f));\n+                append[field](fields_t, rec(ident=f.ident, ty=expr_t));\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty_rec(args_t)));\n+            auto ann = ast.ann_type(plain_ty(ty_rec(fields_t)));\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_rec(args_1, ann));\n+                                        ast.expr_rec(fields_1, ann));\n         }\n \n         case (ast.expr_field(?base, ?field, _)) {"}]}