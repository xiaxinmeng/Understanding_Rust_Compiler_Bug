{"sha": "0120571e90a68befb03892c63c470d0923d425c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMjA1NzFlOTBhNjhiZWZiMDM4OTJjNjNjNDcwZDA5MjNkNDI1YzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-26T03:42:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-26T03:42:26Z"}, "message": "rustc: Make the tag info table keyed by both tag ID and type parameter. Also fix a bug that was causing all tags to compare equal.", "tree": {"sha": "d9308c96868da071396d08028412dd3d72b5ed89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9308c96868da071396d08028412dd3d72b5ed89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0120571e90a68befb03892c63c470d0923d425c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0120571e90a68befb03892c63c470d0923d425c4", "html_url": "https://github.com/rust-lang/rust/commit/0120571e90a68befb03892c63c470d0923d425c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0120571e90a68befb03892c63c470d0923d425c4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37db13b02557b887de295a63b4b96021042ccde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37db13b02557b887de295a63b4b96021042ccde", "html_url": "https://github.com/rust-lang/rust/commit/e37db13b02557b887de295a63b4b96021042ccde"}], "stats": {"total": 38, "additions": 24, "deletions": 14}, "files": [{"sha": "fb916f00848cbf34aa8c88b11a800c1bd95586b3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0120571e90a68befb03892c63c470d0923d425c4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0120571e90a68befb03892c63c470d0923d425c4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0120571e90a68befb03892c63c470d0923d425c4", "patch": "@@ -74,7 +74,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n                                     @ast.native_item] native_items,\n-                            hashmap[ast.def_id, @tag_info] tags,\n+                            hashmap[@ty.t, @tag_info] tags,\n                             hashmap[ast.def_id, ValueRef] fn_pairs,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n@@ -543,7 +543,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         case (ty.ty_char) { llty = T_char(); }\n         case (ty.ty_str) { llty = T_ptr(T_str()); }\n         case (ty.ty_tag(?tag_id, _)) {\n-            llty = llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n+            llty = llvm.LLVMResolveTypeHandle(cx.tags.get(t).th.llth);\n         }\n         case (ty.ty_box(?t)) {\n             llty = T_ptr(T_box(type_of_inner(cx, t)));\n@@ -1472,6 +1472,14 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[ast.variant] {\n     fail;   // not reached\n }\n \n+// Returns a new plain tag type of the given ID with no type parameters. Don't\n+// use this function in new code; it's a hack to keep things working for now.\n+fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n+    let vec[@ty.t] tps = vec();\n+    ret ty.plain_ty(ty.ty_tag(tid, tps));\n+}\n+\n+\n type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n // Iterates through the elements of a structural type.\n@@ -1521,8 +1529,7 @@ fn iter_structural_ty(@block_ctxt cx,\n             }\n         }\n         case (ty.ty_tag(?tid, ?tps)) {\n-            check (cx.fcx.ccx.tags.contains_key(tid));\n-            auto info = cx.fcx.ccx.tags.get(tid);\n+            auto info = cx.fcx.ccx.tags.get(mk_plain_tag(tid));\n \n             auto variants = tag_variants(cx.fcx.ccx, tid);\n             auto n_variants = _vec.len[ast.variant](variants);\n@@ -2591,7 +2598,6 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_generic_fn(cx, ty.item_ty(fn_item), did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n-                    check (cx.fcx.ccx.tags.contains_key(tid));\n                     if (cx.fcx.ccx.fn_pairs.contains_key(vid)) {\n                         check (cx.fcx.ccx.items.contains_key(tid));\n                         auto tag_item = cx.fcx.ccx.items.get(tid);\n@@ -4247,7 +4253,9 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     auto arg_tys = arg_tys_of_fn(variant.ann);\n     copy_args_to_allocas(bcx, none[TypeRef], fn_args, arg_tys);\n \n-    auto info = cx.tags.get(tag_id);\n+    // FIXME: This is wrong for generic tags. We should be dynamically\n+    // computing \"size\" below based on the tydescs passed in.\n+    auto info = cx.tags.get(mk_plain_tag(tag_id));\n \n     auto lltagty = T_struct(vec(T_int(), T_array(T_i8(), info.size)));\n \n@@ -4445,8 +4453,8 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         case (ast.item_tag(_, ?variants, ?tps, ?tag_id)) {\n             auto vi = new_def_hash[uint]();\n             auto navi = new_def_hash[uint]();\n-            cx.tags.insert(tag_id, @rec(th=mk_type_handle(),\n-                                        mutable size=0u));\n+            cx.tags.insert(mk_plain_tag(tag_id), @rec(th=mk_type_handle(),\n+                                                      mutable size=0u));\n             cx.items.insert(tag_id, i);\n         }\n \n@@ -4507,7 +4515,7 @@ fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             auto max_align = 0u;\n             auto max_size = 0u;\n \n-            auto info = cx.tags.get(tag_id);\n+            auto info = cx.tags.get(mk_plain_tag(tag_id));\n \n             for (ast.variant variant in variants) {\n                 if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n@@ -4528,7 +4536,7 @@ fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             // FIXME: alignment is wrong here, manually insert padding I\n             // guess :(\n             auto tag_ty = T_struct(vec(T_int(), T_array(T_i8(), max_size)));\n-            auto th = cx.tags.get(tag_id).th.llth;\n+            auto th = info.th.llth;\n             llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n         }\n         case (_) {\n@@ -4554,7 +4562,7 @@ fn resolve_tag_types(@crate_ctxt cx, @ast.crate crate) {\n fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n     alt (it.node) {\n         case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n-            auto info = cx.tags.get(tag_id);\n+            auto info = cx.tags.get(mk_plain_tag(tag_id));\n \n             auto tag_ty = llvm.LLVMResolveTypeHandle(info.th.llth);\n             check (llvm.LLVMCountStructElementTypes(tag_ty) == 2u);\n@@ -4924,6 +4932,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     auto glues = make_glues(llmod, tn);\n     auto hasher = ty.hash_ty;\n     auto eqer = ty.eq_ty;\n+    auto tags = map.mk_hashmap[@ty.t,@tag_info](hasher, eqer);\n     auto tydescs = map.mk_hashmap[@ty.t,ValueRef](hasher, eqer);\n     let vec[ast.ty_param] obj_typarams = vec();\n     let vec[ast.obj_field] obj_fields = vec();\n@@ -4939,7 +4948,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),\n-                   tags = new_def_hash[@tag_info](),\n+                   tags = tags,\n                    fn_pairs = new_def_hash[ValueRef](),\n                    consts = new_def_hash[ValueRef](),\n                    obj_methods = new_def_hash[()](),"}, {"sha": "25ef8709ecceaab550cc6b2d57e040938bfb6768", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0120571e90a68befb03892c63c470d0923d425c4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0120571e90a68befb03892c63c470d0923d425c4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0120571e90a68befb03892c63c470d0923d425c4", "patch": "@@ -247,9 +247,10 @@ fn ty_to_str(&@t typ) -> str {\n             s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n-        case (ty_tag(_, ?tps)) {\n+        case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-            s = \"<tag>\";\n+            s = \"<tag#\" + util.common.istr(id._0) + \":\" +\n+                util.common.istr(id._1) + \">\";\n             if (_vec.len[@t](tps) > 0u) {\n                 auto f = ty_to_str;\n                 auto strs = _vec.map[@t,str](f, tps);"}]}