{"sha": "d8e4780b0b59636cd979a60434a407142e407ac9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZTQ3ODBiMGI1OTYzNmNkOTc5YTYwNDM0YTQwNzE0MmU0MDdhYzk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-01T16:49:32Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:51Z"}, "message": "Remove rt::{mutex, exclusive}", "tree": {"sha": "8b13d1e484c9b461ca1b5f0c80ef5ac35da1c44b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b13d1e484c9b461ca1b5f0c80ef5ac35da1c44b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8e4780b0b59636cd979a60434a407142e407ac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e4780b0b59636cd979a60434a407142e407ac9", "html_url": "https://github.com/rust-lang/rust/commit/d8e4780b0b59636cd979a60434a407142e407ac9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8e4780b0b59636cd979a60434a407142e407ac9/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd7ce682dd6f98d456d817a297b15bdc9841190", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd7ce682dd6f98d456d817a297b15bdc9841190", "html_url": "https://github.com/rust-lang/rust/commit/7fd7ce682dd6f98d456d817a297b15bdc9841190"}], "stats": {"total": 143, "additions": 74, "deletions": 69}, "files": [{"sha": "f875147ed820ebfa932ed8734e6f174208e009af", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -1627,9 +1627,7 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![rt::exclusive::Exclusive::new(()),\n-                         rt::exclusive::Exclusive::new(()),\n-                         rt::exclusive::Exclusive::new(())];\n+        let mut v = vec![Box::new(()), Box::new(()), Box::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);"}, {"sha": "9e4bdb15b0037bdcf049fe5307d8a15dc3708d41", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -52,9 +52,7 @@ pub struct Packet<T> {\n     /// the other shared channel already had the code implemented\n     channels: atomic::AtomicUint,\n \n-    /// The state field is protected by this mutex\n-    lock: NativeMutex,\n-    state: UnsafeCell<State<T>>,\n+    lock: Mutex<State<T>>,\n }\n \n struct State<T> {\n@@ -107,9 +105,25 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n+fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n+                   guard: MutexGuard<'b, State<T>>,\n+                   f: fn(BlockedTask) -> Blocker)\n+                   -> MutexGuard<'a, State<T>>\n+{\n+    let me: Box<Task> = Local::take();\n+    me.deschedule(1, |task| {\n+        match mem::replace(&mut guard.blocker, f(task)) {\n+            NoneBlocked => {}\n+            _ => unreachable!(),\n+        }\n+        mem::drop(guard);\n+        Ok(())\n+    });\n+    lock.lock()\n+}\n \n-/// Wakes up a thread, dropping the lock at the correct time\n-fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n+/// Wakes up a task, dropping the lock at the correct time\n+fn wakeup<T>(task: BlockedTask, guard: MutexGuard<State<T>>) {\n     // We need to be careful to wake up the waiting task *outside* of the mutex\n     // in case it incurs a context switch.\n     drop(guard);\n@@ -120,8 +134,7 @@ impl<T: Send> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n             channels: atomic::AtomicUint::new(1),\n-            lock: unsafe { NativeMutex::new() },\n-            state: UnsafeCell::new(State {\n+            lock: Mutex::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,\n                 cap: cap,\n@@ -161,17 +174,17 @@ impl<T: Send> Packet<T> {\n         if guard.disconnected { return Err(t) }\n         guard.buf.enqueue(t);\n \n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             // if our capacity is 0, then we need to wait for a receiver to be\n             // available to take our data. After waiting, we check again to make\n             // sure the port didn't go away in the meantime. If it did, we need\n             // to hand back our data.\n-            NoneBlocked if state.cap == 0 => {\n+            NoneBlocked if guard.cap == 0 => {\n                 let mut canceled = false;\n-                assert!(state.canceled.is_none());\n-                state.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n-                wait(&mut state.blocker, BlockedSender, &self.lock);\n-                if canceled {Err(state.buf.dequeue())} else {Ok(())}\n+                assert!(guard.canceled.is_none());\n+                guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n+                let guard = wait(&self.lock, guard, BlockedSender);\n+                if canceled {Err(guard.buf.dequeue())} else {Ok(())}\n             }\n \n             // success, we buffered some data\n@@ -185,15 +198,15 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let (guard, state) = self.lock();\n-        if state.disconnected {\n+        let guard = self.lock.lock();\n+        if guard.disconnected {\n             Err(super::RecvDisconnected(t))\n-        } else if state.buf.size() == state.buf.cap() {\n+        } else if guard.buf.size() == guard.buf.cap() {\n             Err(super::Full(t))\n-        } else if state.cap == 0 {\n+        } else if guard.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n             // transfer the data unless there's a receiver waiting.\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n                 NoneBlocked => Err(super::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(token) => {\n@@ -227,28 +240,28 @@ impl<T: Send> Packet<T> {\n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n         let mut waited = false;\n-        if !state.disconnected && state.buf.size() == 0 {\n-            wait(&mut state.blocker, BlockedReceiver, &self.lock);\n+        if !guard.disconnected && guard.buf.size() == 0 {\n+            wait(&mut guard.blocker, BlockedReceiver, &self.lock);\n             waited = true;\n         }\n-        if state.disconnected && state.buf.size() == 0 { return Err(()) }\n+        if guard.disconnected && guard.buf.size() == 0 { return Err(()) }\n \n         // Pick up the data, wake up our neighbors, and carry on\n-        assert!(state.buf.size() > 0);\n-        let ret = state.buf.dequeue();\n+        assert!(guard.buf.size() > 0);\n+        let ret = guard.buf.dequeue();\n         self.wakeup_senders(waited, guard, state);\n         return Ok(ret);\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n-        let (guard, state) = self.lock();\n+        let guard = self.lock();\n \n         // Easy cases first\n-        if state.disconnected { return Err(Disconnected) }\n-        if state.buf.size() == 0 { return Err(Empty) }\n+        if guard.disconnected { return Err(Disconnected) }\n+        if guard.buf.size() == 0 { return Err(Empty) }\n \n         // Be sure to wake up neighbors\n-        let ret = Ok(state.buf.dequeue());\n+        let ret = Ok(guard.buf.dequeue());\n         self.wakeup_senders(false, guard, state);\n \n         return ret;\n@@ -265,8 +278,8 @@ impl<T: Send> Packet<T> {\n         // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n         // need to ACK the sender. If we waited, then the sender waking us up\n         // was already the ACK.\n-        let pending_sender2 = if state.cap == 0 && !waited {\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let pending_sender2 = if guard.cap == 0 && !waited {\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n                 NoneBlocked => None,\n                 BlockedReceiver(..) => unreachable!(),\n                 BlockedSender(token) => {\n@@ -277,7 +290,7 @@ impl<T: Send> Packet<T> {\n         } else {\n             None\n         };\n-        mem::drop((state, guard));\n+        mem::drop(guard);\n \n         // only outside of the lock do we wake up the pending tasks\n         pending_sender1.map(|t| t.signal());\n@@ -298,46 +311,46 @@ impl<T: Send> Packet<T> {\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n-        let (guard, state) = self.lock();\n-        if state.disconnected { return }\n-        state.disconnected = true;\n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let guard = self.lock();\n+        if guard.disconnected { return }\n+        guard.disconnected = true;\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => {}\n             BlockedSender(..) => unreachable!(),\n             BlockedReceiver(token) => wakeup(token, guard),\n         }\n     }\n \n     pub fn drop_port(&self) {\n-        let (guard, state) = self.lock();\n+        let guard = self.lock();\n \n-        if state.disconnected { return }\n-        state.disconnected = true;\n+        if guard.disconnected { return }\n+        guard.disconnected = true;\n \n         // If the capacity is 0, then the sender may want its data back after\n         // we're disconnected. Otherwise it's now our responsibility to destroy\n         // the buffered data. As with many other portions of this code, this\n         // needs to be careful to destroy the data *outside* of the lock to\n         // prevent deadlock.\n-        let _data = if state.cap != 0 {\n-            mem::replace(&mut state.buf.buf, Vec::new())\n+        let _data = if guard.cap != 0 {\n+            mem::replace(&mut guard.buf.buf, Vec::new())\n         } else {\n             Vec::new()\n         };\n-        let mut queue = mem::replace(&mut state.queue, Queue {\n+        let mut queue = mem::replace(&mut guard.queue, Queue {\n             head: 0 as *mut Node,\n             tail: 0 as *mut Node,\n         });\n \n-        let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => None,\n             BlockedSender(token) => {\n                 *guard.canceled.take().unwrap() = true;\n                 Some(token)\n             }\n             BlockedReceiver(..) => unreachable!(),\n         };\n-        mem::drop((state, guard));\n+        mem::drop(guard);\n \n         loop {\n             match queue.dequeue() {\n@@ -355,8 +368,8 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&self) -> bool {\n-        let (_g, state) = self.lock();\n-        state.disconnected || state.buf.size() > 0\n+        let guard = self.lock();\n+        guard.disconnected || guard.buf.size() > 0\n     }\n \n     // Attempts to start selection on this port. This can either succeed or fail\n@@ -380,8 +393,8 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n-        let (_g, state) = self.lock();\n-        match mem::replace(&mut state.blocker, NoneBlocked) {\n+        let guard = self.lock();\n+        match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => true,\n             BlockedSender(token) => {\n                 guard.blocker = BlockedSender(token);\n@@ -396,9 +409,9 @@ impl<T: Send> Packet<T> {\n impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(atomic::SeqCst), 0);\n-        let (_g, state) = self.lock();\n-        assert!(state.queue.dequeue().is_none());\n-        assert!(state.canceled.is_none());\n+        let guard = self.lock();\n+        assert!(guard.queue.dequeue().is_none());\n+        assert!(guard.canceled.is_none());\n     }\n }\n "}, {"sha": "fed0554863c6afcfdfa6d230f93449065f3aeedf", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -51,10 +51,10 @@ mod imp {\n     use string::String;\n     use mem;\n \n-    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::mutex::{StaticMutex, MUTEX_INIT};\n \n     static mut GLOBAL_ARGS_PTR: uint = 0;\n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: NativeMutex = MUTEX_INIT;\n \n     pub unsafe fn init(argc: int, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);"}, {"sha": "b8012134c9ec1598d98527ba2b59b1efdf23af71", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -17,20 +17,18 @@ use core::prelude::*;\n use libc;\n use boxed::Box;\n use vec::Vec;\n-use sync::{atomic, Once, ONCE_INIT};\n+use sync::{Mutex, atomic, Once, ONCE_INIT};\n use mem;\n use thunk::Thunk;\n \n-use rt::exclusive::Exclusive;\n-\n-type Queue = Exclusive<Vec<Thunk>>;\n+type Queue = Mutex<Vec<Thunk>>;\n \n static INIT: Once = ONCE_INIT;\n static QUEUE: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n static RUNNING: atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n \n fn init() {\n-    let state: Box<Queue> = box Exclusive::new(Vec::new());\n+    let state: Box<Queue> = box Mutex::new(Vec::new());\n     unsafe {\n         QUEUE.store(mem::transmute(state), atomic::SeqCst);\n         libc::atexit(run);"}, {"sha": "a3b1d831a385e5b87602411578f0c0c4e0396c0c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -71,9 +71,6 @@ pub mod backtrace;\n mod macros;\n \n // These should be refactored/moved/made private over time\n-pub mod mutex;\n-pub mod thread;\n-pub mod exclusive;\n pub mod util;\n <<<<<<< HEAD\n ======="}, {"sha": "c3bf5cfc301c65306b7a4fc1a6bf9af195000729", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -58,10 +58,9 @@\n \n use prelude::*;\n \n-use rt::exclusive::Exclusive;\n use rt;\n use sync::atomic::{mod, AtomicUint};\n-use sync::{Once, ONCE_INIT};\n+use sync::{Mutex, Once, ONCE_INIT};\n \n use sys::thread_local as imp;\n \n@@ -143,7 +142,7 @@ pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n };\n \n static INIT_KEYS: Once = ONCE_INIT;\n-static mut KEYS: *mut Exclusive<Vec<imp::Key>> = 0 as *mut _;\n+static mut KEYS: *mut Mutex<Vec<imp::Key>> = 0 as *mut _;\n \n impl StaticKey {\n     /// Gets the value associated with this TLS key"}, {"sha": "2b36ece0e4b4867ccd0e833527def6a19e6b8ea4", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -89,7 +89,7 @@ use libc;\n use mem;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n-use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use sync::{StaticMutex, MUTEX_INIT};\n \n use sys_common::backtrace::*;\n \n@@ -150,7 +150,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // is semi-reasonable in terms of printing anyway, and we know that all\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n     let _g = unsafe { LOCK.lock() };\n \n     try!(writeln!(w, \"stack backtrace:\"));"}, {"sha": "9903d2f1ae281a550107709ccc17720ba2897a4f", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e4780b0b59636cd979a60434a407142e407ac9/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=d8e4780b0b59636cd979a60434a407142e407ac9", "patch": "@@ -30,7 +30,7 @@ use ops::Drop;\n use option::{Some, None};\n use path::Path;\n use result::{Ok, Err};\n-use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+use sync::{StaticMutex, MUTEX_INIT};\n use slice::SliceExt;\n use str::StrPrelude;\n use dynamic_lib::DynamicLibrary;\n@@ -293,7 +293,7 @@ impl Drop for Cleanup {\n pub fn write(w: &mut Writer) -> IoResult<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n     let _g = unsafe { LOCK.lock() };\n \n     // Open up dbghelp.dll, we don't link to it explicitly because it can't"}]}