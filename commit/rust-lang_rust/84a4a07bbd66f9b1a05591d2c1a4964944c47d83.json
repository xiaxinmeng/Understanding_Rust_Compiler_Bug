{"sha": "84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YTRhMDdiYmQ2NmY5YjFhMDU1OTFkMmMxYTQ5NjQ5NDRjNDdkODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T11:32:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T11:32:25Z"}, "message": "auto merge of #17434 : P1start/rust/borrowck-messages, r=nikomatsakis\n\nThis was originally part of #17215.\r\n\r\nCloses #15506.\r\nCloses #15630.\r\nCloses #17263.\r\n\r\nThis also partially implements #15838.", "tree": {"sha": "a3c7f6ddc470fc1584817587618bf7e6c31ba5b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3c7f6ddc470fc1584817587618bf7e6c31ba5b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "html_url": "https://github.com/rust-lang/rust/commit/84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd7f00de801e4ca24c9c1235227ace4f998d4b1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd7f00de801e4ca24c9c1235227ace4f998d4b1c", "html_url": "https://github.com/rust-lang/rust/commit/dd7f00de801e4ca24c9c1235227ace4f998d4b1c"}, {"sha": "02c6ebde7e9bca72baa0623d9c5f6a86a30ec486", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c6ebde7e9bca72baa0623d9c5f6a86a30ec486", "html_url": "https://github.com/rust-lang/rust/commit/02c6ebde7e9bca72baa0623d9c5f6a86a30ec486"}], "stats": {"total": 371, "additions": 299, "deletions": 72}, "files": [{"sha": "a5111cdf7c8f52acc464b0087d753a0559c5a025", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -400,50 +400,82 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         for restr_path in loan1.restricted_paths.iter() {\n             if *restr_path != loan2_base_path { continue; }\n \n-            let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n+            // If new_loan is something like `x.a`, and old_loan is something like `x.b`, we would\n+            // normally generate a rather confusing message (in this case, for multiple mutable\n+            // borrows):\n+            //\n+            //     error: cannot borrow `x.b` as mutable more than once at a time\n+            //     note: previous borrow of `x.a` occurs here; the mutable borrow prevents\n+            //     subsequent moves, borrows, or modification of `x.a` until the borrow ends\n+            //\n+            // What we want to do instead is get the 'common ancestor' of the two borrow paths and\n+            // use that for most of the message instead, giving is something like this:\n+            //\n+            //     error: cannot borrow `x` as mutable more than once at a time\n+            //     note: previous borrow of `x` occurs here (through borrowing `x.a`); the mutable\n+            //     borrow prevents subsequent moves, borrows, or modification of `x` until the\n+            //     borrow ends\n+\n+            let common = new_loan.loan_path.common(&*old_loan.loan_path);\n+            let (nl, ol, new_loan_msg, old_loan_msg) =\n+                if new_loan.loan_path.has_fork(&*old_loan.loan_path) && common.is_some() {\n+                    let nl = self.bccx.loan_path_to_string(&common.unwrap());\n+                    let ol = nl.clone();\n+                    let new_loan_msg = format!(\" (here through borrowing `{}`)\",\n+                                               self.bccx.loan_path_to_string(\n+                                                   &*new_loan.loan_path));\n+                    let old_loan_msg = format!(\" (through borrowing `{}`)\",\n+                                               self.bccx.loan_path_to_string(\n+                                                   &*old_loan.loan_path));\n+                    (nl, ol, new_loan_msg, old_loan_msg)\n+                } else {\n+                    (self.bccx.loan_path_to_string(&*new_loan.loan_path),\n+                     self.bccx.loan_path_to_string(&*old_loan.loan_path),\n+                     String::new(), String::new())\n+                };\n+\n+            let ol_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n             } else {\n-                format!(\"`{}`\",\n-                        self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                format!(\"`{}`\", ol)\n             };\n \n             match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as mutable \\\n+                        format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_string(\n-                                    &*new_loan.loan_path)).as_slice());\n+                                nl, new_loan_msg).as_slice())\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n-                                but {} is already borrowed\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n-                                old_pronoun).as_slice());\n+                                but {} is already borrowed{}\",\n+                                nl, ol_pronoun, old_loan_msg).as_slice());\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as {} because \\\n+                        format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n-                                new_loan.kind.to_user_str()).as_slice());\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()).as_slice());\n                 }\n \n                 (_, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as {} because \\\n-                                {} is also borrowed as {}\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n+                        format!(\"cannot borrow `{}`{} as {} because \\\n+                                {} is also borrowed as {}{}\",\n+                                nl,\n+                                new_loan_msg,\n                                 new_loan.kind.to_user_str(),\n-                                old_pronoun,\n-                                old_loan.kind.to_user_str()).as_slice());\n+                                ol_pronoun,\n+                                old_loan.kind.to_user_str(),\n+                                old_loan_msg).as_slice());\n                 }\n             }\n \n@@ -452,8 +484,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_string(\n-                                    &*new_loan.loan_path)).as_slice());\n+                                nl).as_slice());\n                 }\n                 _ => { }\n             }\n@@ -463,30 +494,29 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(\n-                                &*old_loan.loan_path))\n+                            ol)\n                 }\n \n                 ty::ImmBorrow => {\n                     format!(\"the immutable borrow prevents subsequent \\\n                             moves or mutable borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol)\n                 }\n \n                 ty::UniqueImmBorrow => {\n                     format!(\"the unique capture prevents subsequent \\\n                             moves or borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol)\n                 }\n             };\n \n             let borrow_summary = match old_loan.cause {\n                 euv::ClosureCapture(_) => {\n-                    format!(\"previous borrow of `{}` occurs here due to \\\n+                    format!(\"previous borrow of `{}` occurs here{} due to \\\n                             use in closure\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol, old_loan_msg)\n                 }\n \n                 euv::OverloadedOperator(..) |\n@@ -496,8 +526,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ForLoop(..) |\n                 euv::RefBinding(..) |\n                 euv::MatchDiscriminant(..) => {\n-                    format!(\"previous borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                    format!(\"previous borrow of `{}` occurs here{}\",\n+                            ol, old_loan_msg)\n                 }\n             };\n "}, {"sha": "b411620dac0e7a92be5cbd2da3fae45a9d5752ed", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 102, "deletions": 12, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -298,6 +298,51 @@ impl LoanPath {\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n+\n+    fn has_fork(&self, other: &LoanPath) -> bool {\n+        match (self, other) {\n+            (&LpExtend(ref base, _, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+                if id == id2 {\n+                    base.has_fork(&**base2)\n+                } else {\n+                    true\n+                },\n+            (&LpExtend(ref base, _, LpDeref(_)), _) => base.has_fork(other),\n+            (_, &LpExtend(ref base, _, LpDeref(_))) => self.has_fork(&**base),\n+            _ => false,\n+        }\n+    }\n+\n+    fn depth(&self) -> uint {\n+        match *self {\n+            LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n+            LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n+            _ => 0,\n+        }\n+    }\n+\n+    fn common(&self, other: &LoanPath) -> Option<LoanPath> {\n+        match (self, other) {\n+            (&LpExtend(ref base, a, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+                if id == id2 {\n+                    base.common(&**base2).map(|x| {\n+                        let xd = x.depth();\n+                        if base.depth() == xd && base2.depth() == xd {\n+                            LpExtend(Rc::new(x), a, LpInterior(id))\n+                        } else {\n+                            x\n+                        }\n+                    })\n+                } else {\n+                    base.common(&**base2)\n+                },\n+            (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n+            (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&**other),\n+            (&LpVar(id), &LpVar(id2)) => if id == id2 { Some(LpVar(id)) } else { None },\n+            (&LpUpvar(id), &LpUpvar(id2)) => if id == id2 { Some(LpUpvar(id)) } else { None },\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n@@ -416,24 +461,58 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             MovedInCapture => \"capture\",\n         };\n \n-        match the_move.kind {\n+        let (ol, moved_lp_msg) = match the_move.kind {\n             move_data::Declared => {\n                 self.tcx.sess.span_err(\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n                             self.loan_path_to_string(lp)).as_slice());\n+                (self.loan_path_to_string(moved_lp),\n+                 String::new())\n             }\n             _ => {\n-                let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n+                // If moved_lp is something like `x.a`, and lp is something like `x.b`, we would\n+                // normally generate a rather confusing message:\n+                //\n+                //     error: use of moved value: `x.b`\n+                //     note: `x.a` moved here...\n+                //\n+                // What we want to do instead is get the 'common ancestor' of the two moves and\n+                // use that for most of the message instead, giving is something like this:\n+                //\n+                //     error: use of moved value: `x`\n+                //     note: `x` moved here (through moving `x.a`)...\n+\n+                let common = moved_lp.common(lp);\n+                let has_common = common.is_some();\n+                let has_fork = moved_lp.has_fork(lp);\n+                let (nl, ol, moved_lp_msg) =\n+                    if has_fork && has_common {\n+                        let nl = self.loan_path_to_string(&common.unwrap());\n+                        let ol = nl.clone();\n+                        let moved_lp_msg = format!(\" (through moving `{}`)\",\n+                                                   self.loan_path_to_string(moved_lp));\n+                        (nl, ol, moved_lp_msg)\n+                    } else {\n+                        (self.loan_path_to_string(lp),\n+                         self.loan_path_to_string(moved_lp),\n+                         String::new())\n+                    };\n+\n+                let partial = moved_lp.depth() > lp.depth();\n+                let msg = if !has_fork && partial { \"partially \" }\n+                          else if has_fork && !has_common { \"collaterally \"}\n+                          else { \"\" };\n                 self.tcx.sess.span_err(\n                     use_span,\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n-                            partially,\n-                            self.loan_path_to_string(lp)).as_slice());\n+                            msg,\n+                            nl).as_slice());\n+                (ol, moved_lp_msg)\n             }\n-        }\n+        };\n \n         match the_move.kind {\n             move_data::Declared => {}\n@@ -456,19 +535,21 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved here because it has type `{}`, which is {}\",\n-                            self.loan_path_to_string(moved_lp),\n+                    format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n+                            ol,\n+                            moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n                             suggestion).as_slice());\n             }\n \n             move_data::MovePat => {\n                 let pat_ty = ty::node_id_to_type(self.tcx, the_move.id);\n                 self.tcx.sess.span_note(self.tcx.map.span(the_move.id),\n-                    format!(\"`{}` moved here because it has type `{}`, \\\n+                    format!(\"`{}` moved here{} because it has type `{}`, \\\n                              which is moved by default (use `ref` to \\\n                              override)\",\n-                            self.loan_path_to_string(moved_lp),\n+                            ol,\n+                            moved_lp_msg,\n                             pat_ty.user_string(self.tcx)).as_slice());\n             }\n \n@@ -491,9 +572,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                          capture that instead to override)\");\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved into closure environment here because it \\\n+                    format!(\"`{}` moved into closure environment here{} because it \\\n                             has type `{}`, which is {}\",\n-                            self.loan_path_to_string(moved_lp),\n+                            ol,\n+                            moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n                             suggestion).as_slice());\n             }\n@@ -602,6 +684,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                          span: Span,\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n+        let mut is_closure = false;\n         let prefix = match kind {\n             MutabilityViolation => {\n                 \"cannot assign to data\"\n@@ -625,6 +708,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             BorrowViolation(euv::ClosureInvocation) => {\n+                is_closure = true;\n                 \"closure invocation\"\n             }\n \n@@ -649,14 +733,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableManaged => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `@` pointer\", prefix).as_slice());\n+                    format!(\"{} in a `Gc` pointer\", prefix).as_slice());\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in a `&` reference\", prefix).as_slice());\n             }\n         }\n+\n+        if is_closure {\n+            self.tcx.sess.span_note(\n+                span,\n+                \"closures behind references must be called via `&mut`\");\n+        }\n     }\n \n     pub fn note_and_explain_bckerr(&self, err: BckError) {"}, {"sha": "b73fa172d3f7b036dd432c1f147fc81412223c92", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -59,18 +59,19 @@ use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::infer;\n-use middle::typeck::rscope::{ExplicitRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n use util::ppaux::{Repr, UserString};\n \n use std::collections::HashMap;\n use std::rc::Rc;\n-use syntax::abi;\n-use syntax::{ast, ast_util};\n+use std::iter::AdditiveIterator;\n+use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n@@ -147,10 +148,49 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n         None => {\n             match rscope.anon_regions(default_span, 1) {\n-                Err(()) => {\n+                Err(v) => {\n                     debug!(\"optional region in illegal location\");\n                     span_err!(this.tcx().sess, default_span, E0106,\n                         \"missing lifetime specifier\");\n+                    match v {\n+                        Some(v) => {\n+                            let mut m = String::new();\n+                            let len = v.len();\n+                            for (i, (name, n)) in v.move_iter().enumerate() {\n+                                m.push_str(if n == 1 {\n+                                    format!(\"`{}`\", name)\n+                                } else {\n+                                    format!(\"one of `{}`'s {} elided lifetimes\", name, n)\n+                                }.as_slice());\n+\n+                                if len == 2 && i == 0 {\n+                                    m.push_str(\" or \");\n+                                } else if i == len - 2 {\n+                                    m.push_str(\", or \");\n+                                } else if i != len - 1 {\n+                                    m.push_str(\", \");\n+                                }\n+                            }\n+                            if len == 1 {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     the signature does not say which {} it is borrowed from\",\n+                                    m);\n+                            } else if len == 0 {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     there is no value for it to be borrowed from\");\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"consider giving it a 'static lifetime\");\n+                            } else {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     the signature does not say whether it is borrowed from {}\",\n+                                    m);\n+                            }\n+                        }\n+                        None => {},\n+                    }\n                     ty::ReStatic\n                 }\n \n@@ -217,7 +257,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(()) => Vec::from_fn(expected_num_region_params,\n+            Err(_) => Vec::from_fn(expected_num_region_params,\n                                     |_| ty::ReStatic) // hokey\n         }\n     };\n@@ -1153,15 +1193,20 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     };\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n-    let input_tys = if self_ty.is_some() {\n+    let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n         decl.inputs.as_slice()\n     };\n-    let input_tys = input_tys.iter().map(|a| ty_of_arg(this, &rb, a, None));\n-    let self_and_input_tys: Vec<_> =\n+    let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n+    let input_pats: Vec<String> = input_params.iter()\n+                                              .map(|a| pprust::pat_to_string(&*a.pat))\n+                                              .collect();\n+    let self_and_input_tys: Vec<ty::t> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n+    let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n+\n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n@@ -1172,15 +1217,25 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n             drop(self_and_input_tys_iter.next())\n         }\n \n-        let mut accumulator = Vec::new();\n-        for input_type in self_and_input_tys_iter {\n-            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type)\n+        for (input_type, input_pat) in self_and_input_tys_iter.zip(input_pats.into_iter()) {\n+            let mut accumulator = Vec::new();\n+            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+            lifetimes_for_params.push((input_pat, accumulator));\n         }\n-        if accumulator.len() == 1 {\n-            implied_output_region = Some(*accumulator.get(0));\n+\n+        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum() == 1 {\n+            implied_output_region =\n+                Some(lifetimes_for_params.iter()\n+                                         .filter_map(|&(_, ref x)|\n+                                            if x.len() == 1 { Some(x[0]) } else { None })\n+                                         .next().unwrap());\n         }\n     }\n \n+    let param_lifetimes: Vec<(String, uint)> = lifetimes_for_params.into_iter()\n+                                                                   .map(|(n, v)| (n, v.len()))\n+                                                                   .collect();\n+\n     let output_ty = match decl.output.node {\n         ast::TyInfer => this.ty_infer(decl.output.span),\n         _ => {\n@@ -1193,7 +1248,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                     // All regions must be explicitly specified in the output\n                     // if the lifetime elision rules do not apply. This saves\n                     // the user from potentially-confusing errors.\n-                    let rb = ExplicitRscope;\n+                    let rb = UnelidableRscope::new(param_lifetimes);\n                     ast_ty_to_ty(this, &rb, &*decl.output)\n                 }\n             }"}, {"sha": "5f7f77ea7da58d98094c48ba4550a96cf0e9e62a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -1601,7 +1601,7 @@ impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n     }\n \n     fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region> , ()> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n         Ok(Vec::from_fn(count, |_| {\n             self.next_region_var(infer::MiscVariable(span))\n         }))"}, {"sha": "2845e3954b5c6c6f2fb514cb212bf7c8b9b4acdb", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -29,7 +29,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>;\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n \n     fn default_region_bound(&self, span: Span) -> Option<ty::Region>;\n }\n@@ -46,8 +46,31 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n-                    -> Result<Vec<ty::Region> , ()> {\n-        Err(())\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        Err(None)\n+    }\n+}\n+\n+// Same as `ExplicitRscope`, but provides some extra information for diagnostics\n+pub struct UnelidableRscope(Vec<(String, uint)>);\n+\n+impl UnelidableRscope {\n+    pub fn new(v: Vec<(String, uint)>) -> UnelidableRscope {\n+        UnelidableRscope(v)\n+    }\n+}\n+\n+impl RegionScope for UnelidableRscope {\n+    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+        None\n+    }\n+\n+    fn anon_regions(&self,\n+                    _span: Span,\n+                    _count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        let UnelidableRscope(ref v) = *self;\n+        Err(Some(v.clone()))\n     }\n }\n \n@@ -72,7 +95,7 @@ impl RegionScope for SpecificRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n         Ok(Vec::from_elem(count, self.default))\n     }\n@@ -109,7 +132,7 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n         Ok(Vec::from_fn(count, |_| self.next_region()))\n     }"}, {"sha": "d05c03547ac4caf4813c373771e688ec3a38491d", "filename": "src/test/compile-fail/borrowck-box-insensitivity.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -31,19 +31,22 @@ struct D {\n fn copy_after_move() {\n     let a = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    let _y = a.y; //~ ERROR use of partially moved\n+    let _y = a.y; //~ ERROR use of moved\n+    //~^^ NOTE `a` moved here (through moving `a.x`)\n }\n \n fn move_after_move() {\n     let a = box B { x: box 0, y: box 1 };\n     let _x = a.x;\n-    let _y = a.y; //~ ERROR use of partially moved\n+    let _y = a.y; //~ ERROR use of moved\n+    //~^^ NOTE `a` moved here (through moving `a.x`)\n }\n \n fn borrow_after_move() {\n     let a = box A { x: box 0, y: 1 };\n     let _x = a.x;\n-    let _y = &a.y; //~ ERROR use of partially moved\n+    let _y = &a.y; //~ ERROR use of moved\n+    //~^^ NOTE `a` moved here (through moving `a.x`)\n }\n \n fn move_after_borrow() {\n@@ -79,19 +82,19 @@ fn mut_borrow_after_borrow() {\n fn copy_after_move_nested() {\n     let a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    let _y = a.y; //~ ERROR use of partially moved\n+    let _y = a.y; //~ ERROR use of collaterally moved\n }\n \n fn move_after_move_nested() {\n     let a = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = a.x.x;\n-    let _y = a.y; //~ ERROR use of partially moved\n+    let _y = a.y; //~ ERROR use of collaterally moved\n }\n \n fn borrow_after_move_nested() {\n     let a = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    let _y = &a.y; //~ ERROR use of partially moved\n+    let _y = &a.y; //~ ERROR use of collaterally moved\n }\n \n fn move_after_borrow_nested() {"}, {"sha": "49c93e3aa9e0ce324b7a170b57535a9c38bc5e5f", "filename": "src/test/compile-fail/borrowck-field-sensitivity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -13,13 +13,13 @@ struct A { a: int, b: Box<int> }\n fn deref_after_move() {\n     let x = A { a: 1, b: box 2 };\n     drop(x.b);\n-    drop(*x.b); //~ ERROR use of partially moved value: `*x.b`\n+    drop(*x.b); //~ ERROR use of moved value: `*x.b`\n }\n \n fn deref_after_fu_move() {\n     let x = A { a: 1, b: box 2 };\n     let y = A { a: 3, .. x };\n-    drop(*x.b); //~ ERROR use of partially moved value: `*x.b`\n+    drop(*x.b); //~ ERROR use of moved value: `*x.b`\n }\n \n fn borrow_after_move() {"}, {"sha": "b610a2b0c91d668a3d2b35543db5bd4a12291b98", "filename": "src/test/compile-fail/issue-17263.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo { a: int, b: int }\n+\n+fn main() {\n+    let mut x = box Foo { a: 1, b: 2 };\n+    let (a, b) = (&mut x.a, &mut x.b);\n+    //~^ ERROR cannot borrow `x` (here through borrowing `x.b`) as mutable more than once at a time\n+    //~^^ NOTE previous borrow of `x` occurs here (through borrowing `x.a`)\n+\n+    let mut foo = box Foo { a: 1, b: 2 };\n+    let (c, d) = (&mut foo.a, &foo.b);\n+    //~^ ERROR cannot borrow `foo` (here through borrowing `foo.b`) as immutable\n+    //~^^ NOTE previous borrow of `foo` occurs here (through borrowing `foo.a`)\n+}"}, {"sha": "5fa8c5db5b01c95a9dd9f73c17ad3e6cbae96c82", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -10,11 +10,13 @@\n \n // Lifetime annotation needed because we have no arguments.\n fn f() -> &int {    //~ ERROR missing lifetime specifier\n+//~^ NOTE there is no value for it to be borrowed from\n     fail!()\n }\n \n // Lifetime annotation needed because we have two by-reference parameters.\n-fn g(_: &int, _: &int) -> &int {    //~ ERROR missing lifetime specifier\n+fn g(_x: &int, _y: &int) -> &int {    //~ ERROR missing lifetime specifier\n+//~^ NOTE the signature does not say whether it is borrowed from `_x` or `_y`\n     fail!()\n }\n \n@@ -24,7 +26,8 @@ struct Foo<'a> {\n \n // Lifetime annotation needed because we have two lifetimes: one as a parameter\n // and one on the reference.\n-fn h(_: &Foo) -> &int { //~ ERROR missing lifetime specifier\n+fn h(_x: &Foo) -> &int { //~ ERROR missing lifetime specifier\n+//~^ NOTE the signature does not say which one of `_x`'s 2 elided lifetimes it is borrowed from\n     fail!()\n }\n "}, {"sha": "cd7401a65aeaac71221b8bfb4c39aba1a78a1e6f", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -13,6 +13,6 @@ extern crate debug;\n fn main() {\n     let x = box 5i;\n     let y = x;\n-    println!(\"{:?}\", *x); //~ ERROR use of partially moved value: `*x`\n+    println!(\"{:?}\", *x); //~ ERROR use of moved value: `*x`\n     y.clone();\n }"}, {"sha": "a1b7f83da2fcf8b5e6ffb3ffad70051c3156a659", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -19,7 +19,7 @@ impl Drop for S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of partially moved value: `self.x`\n+        return self.x;  //~ ERROR use of moved value: `self.x`\n     }\n \n     pub fn bar(self) {}"}, {"sha": "607d6163208c982c430e0376a9a8b8b2c0bfb6b0", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a4a07bbd66f9b1a05591d2c1a4964944c47d83/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=84a4a07bbd66f9b1a05591d2c1a4964944c47d83", "patch": "@@ -16,7 +16,7 @@ struct S {\n impl S {\n     pub fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of partially moved value: `*self.x`\n+        return *self.x;  //~ ERROR use of moved value: `*self.x`\n     }\n \n     pub fn bar(self) {}"}]}