{"sha": "fda3f9874627fee7a8d3605c76b441d4c9b2540f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkYTNmOTg3NDYyN2ZlZTdhOGQzNjA1Yzc2YjQ0MWQ0YzliMjU0MGY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-01T03:55:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-01T03:55:28Z"}, "message": "Rollup merge of #39944 - GuillaumeGomez:associated-consts, r=frewsxcv\n\nImprove associated constant rendering in rustdoc\n\nBefore:\n\n<img width=\"1440\" alt=\"screen shot 2017-02-19 at 00 30 51\" src=\"https://cloud.githubusercontent.com/assets/3050060/23097697/caeed80e-f63a-11e6-98c2-5d27e4efd76d.png\">\n\nAfter:\n\n<img width=\"1440\" alt=\"screen shot 2017-02-19 at 00 30 39\" src=\"https://cloud.githubusercontent.com/assets/3050060/23097698/cfb4874e-f63a-11e6-80cf-ffbf5c5c6162.png\">\n\ncc @SergioBenitez\n\nr? @rust-lang/docs", "tree": {"sha": "b5a4d4ee300f22b5acdff5f215346124422a52a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5a4d4ee300f22b5acdff5f215346124422a52a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fda3f9874627fee7a8d3605c76b441d4c9b2540f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fda3f9874627fee7a8d3605c76b441d4c9b2540f", "html_url": "https://github.com/rust-lang/rust/commit/fda3f9874627fee7a8d3605c76b441d4c9b2540f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fda3f9874627fee7a8d3605c76b441d4c9b2540f/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43df65fb3fe554d451ea88ec75ec8cc2991d1a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/43df65fb3fe554d451ea88ec75ec8cc2991d1a3e", "html_url": "https://github.com/rust-lang/rust/commit/43df65fb3fe554d451ea88ec75ec8cc2991d1a3e"}, {"sha": "bd704baaf1cb632011c215245779cc5605d5fd4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd704baaf1cb632011c215245779cc5605d5fd4c", "html_url": "https://github.com/rust-lang/rust/commit/bd704baaf1cb632011c215245779cc5605d5fd4c"}], "stats": {"total": 239, "additions": 176, "deletions": 63}, "files": [{"sha": "1294296840ebd75b329bd6df6c81e1309883caf3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -1476,7 +1476,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n pub enum Type {\n     /// structs/enums/traits (most that'd be an hir::TyPath)\n     ResolvedPath {"}, {"sha": "23507dc889b710be084cb53985f9575d7ba87dc3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 91, "deletions": 25, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -90,6 +90,16 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     }\n }\n \n+impl<'a, T: fmt::Debug> fmt::Debug for CommaSep<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, item) in self.0.iter().enumerate() {\n+            if i != 0 { write!(f, \", \")?; }\n+            fmt::Debug::fmt(item, f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> fmt::Display for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n@@ -165,7 +175,7 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if f.alternate() {\n             clause.push_str(\" where \");\n         } else {\n-            clause.push_str(\" <span class='where fmt-newline'>where \");\n+            clause.push_str(\" <span class=\\\"where fmt-newline\\\">where \");\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n@@ -449,8 +459,8 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        write!(w, \"<a class='mod'\n-                                       href='{}index.html'>{}</a>::\",\n+                        write!(w, \"<a class=\\\"mod\\\"\n+                                       href=\\\"{}index.html\\\">{}</a>::\",\n                                  root,\n                                  seg.name)?;\n                     }\n@@ -491,7 +501,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n             Some(&def_id) if def_id.is_local() => {\n                 let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                 let len = if len == 0 {0} else {len - 1};\n-                write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+                write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n                        repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n@@ -508,7 +518,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                     (.., render::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n-                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}{}/primitive.{}.html\\\">\",\n                            root,\n                            cname,\n                            prim.to_url_str())?;\n@@ -550,7 +560,7 @@ impl<'a> fmt::Display for HRef<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match href(self.did) {\n             Some((url, shortty, fqp)) => if !f.alternate() {\n-                write!(f, \"<a class='{}' href='{}' title='{} {}'>{}</a>\",\n+                write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n                        shortty, url, shortty, fqp.join(\"::\"), self.text)\n             } else {\n                 write!(f, \"{}\", self.text)\n@@ -560,7 +570,8 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n+            is_not_debug: bool) -> fmt::Result {\n     match *t {\n         clean::Generic(ref name) => {\n             f.write_str(name)\n@@ -571,7 +582,8 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             tybounds(f, typarams)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::Primitive(prim) if is_not_debug => primitive_link(f, prim, prim.as_str()),\n+        clean::Primitive(prim) => write!(f, \"{}\", prim.as_str()),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{}fn{:#}{:#}\",\n@@ -589,26 +601,30 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                &[ref one] => {\n+                &[] if is_not_debug => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[] => write!(f, \"()\"),\n+                &[ref one] if is_not_debug => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     //carry f.alternate() into this display w/o branching manually\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-                many => {\n+                &[ref one] => write!(f, \"({:?},)\", one),\n+                many if is_not_debug => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     fmt::Display::fmt(&CommaSep(&many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n+                many => write!(f, \"({:?})\", &CommaSep(&many)),\n             }\n         }\n-        clean::Vector(ref t) => {\n+        clean::Vector(ref t) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n         }\n-        clean::FixedVector(ref t, ref s) => {\n+        clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n+        clean::FixedVector(ref t, ref s) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             if f.alternate() {\n@@ -619,10 +635,17 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                                &format!(\"; {}]\", Escape(s)))\n             }\n         }\n+        clean::FixedVector(ref t, ref s) => {\n+            if f.alternate() {\n+                write!(f, \"[{:?}; {}]\", t, s)\n+            } else {\n+                write!(f, \"[{:?}; {}]\", t, Escape(s))\n+            }\n+        }\n         clean::Never => f.write_str(\"!\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n-                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} if is_not_debug => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n@@ -631,11 +654,21 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n-                _ => {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                    if f.alternate() {\n+                        write!(f, \"*{}{:#?}\", RawMutableSpace(m), t)\n+                    } else {\n+                        write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n+                    }\n+                }\n+                _ if is_not_debug => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer,\n                                    &format!(\"*{}\", RawMutableSpace(m)))?;\n                     fmt::Display::fmt(t, f)\n                 }\n+                _ => {\n+                    write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n+                }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n@@ -647,15 +680,23 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             match **ty {\n                 clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                     match **bt {\n-                        clean::Generic(_) =>\n+                        clean::Generic(_) if is_not_debug => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n-                            },\n-                        _ => {\n+                            }\n+                        }\n+                        clean::Generic(_) => {\n+                            if f.alternate() {\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n+                            } else {\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n+                            }\n+                        }\n+                        _ if is_not_debug => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                                &format!(\"&{}{}[\", lt, m))?;\n@@ -667,15 +708,26 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n+                        _ => {\n+                            if f.alternate() {\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n+                            } else {\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n+                            }\n+                        }\n                     }\n                 }\n                 _ => {\n                     if f.alternate() {\n                         write!(f, \"&{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n+                        fmt_type(&ty, f, use_absolute, is_not_debug)\n                     } else {\n-                        write!(f, \"&amp;{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n+                        if is_not_debug {\n+                            write!(f, \"&amp;{}{}\", lt, m)?;\n+                        } else {\n+                            write!(f, \"&{}{}\", lt, m)?;\n+                        }\n+                        fmt_type(&ty, f, use_absolute, is_not_debug)\n                     }\n                 }\n             }\n@@ -723,9 +775,17 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n             if f.alternate() {\n-                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                if is_not_debug {\n+                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"<{:#?} as {:#?}>::{}\", self_type, trait_, name)\n+                }\n             } else {\n-                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                if is_not_debug {\n+                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"<{:?} as {:?}>::{}\", self_type, trait_, name)\n+                }\n             }\n         }\n         clean::Unique(..) => {\n@@ -736,7 +796,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n \n impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_type(self, f, false)\n+        fmt_type(self, f, false, true)\n+    }\n+}\n+\n+impl fmt::Debug for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt_type(self, f, false, false)\n     }\n }\n \n@@ -777,7 +843,7 @@ fn fmt_impl(i: &clean::Impl,\n         plain.push_str(\" for \");\n     }\n \n-    fmt_type(&i.for_, f, use_absolute)?;\n+    fmt_type(&i.for_, f, use_absolute, true)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n     fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;"}, {"sha": "0dafc4225a3210653e6d9b445914c825db8c9a35", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -144,12 +144,12 @@ impl<U: Write> Writer for U {\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n-            klass => write!(self, \"<span class='{}'>{}</span>\", klass.rustdoc_class(), text),\n+            klass => write!(self, \"<span class=\\\"{}\\\">{}</span>\", klass.rustdoc_class(), text),\n         }\n     }\n \n     fn enter_span(&mut self, klass: Class) -> io::Result<()> {\n-        write!(self, \"<span class='{}'>\", klass.rustdoc_class())\n+        write!(self, \"<span class=\\\"{}\\\">\", klass.rustdoc_class())\n     }\n \n     fn exit_span(&mut self) -> io::Result<()> {\n@@ -363,7 +363,7 @@ fn write_header(class: Option<&str>,\n     if let Some(id) = id {\n         write!(out, \"id='{}' \", id)?;\n     }\n-    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n+    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut Write) -> io::Result<()> {"}, {"sha": "44f71d8952985b0098e482d561dad83d960969da", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -1547,7 +1547,7 @@ impl<'a> fmt::Display for Item<'a> {\n                        component)?;\n             }\n         }\n-        write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+        write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n                self.item.type_(), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n@@ -1654,9 +1654,35 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n     Ok(())\n }\n \n+fn md_render_assoc_item(item: &clean::Item) -> String {\n+    match item.inner {\n+        clean::AssociatedConstItem(ref ty, ref default) => {\n+            if let Some(default) = default.as_ref() {\n+                format!(\"```\\n{}: {:?} = {}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty, default)\n+            } else {\n+                format!(\"```\\n{}: {:?}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty)\n+            }\n+        }\n+        _ => String::new(),\n+    }\n+}\n+\n+fn get_doc_value(item: &clean::Item) -> Option<&str> {\n+    let x = item.doc_value();\n+    if x.is_none() {\n+        match item.inner {\n+            clean::AssociatedConstItem(_, _) => Some(\"\"),\n+            _ => None,\n+        }\n+    } else {\n+        x\n+    }\n+}\n+\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    if let Some(s) = item.doc_value() {\n-        write!(w, \"<div class='docblock'>{}</div>\", Markdown(s))?;\n+    if let Some(s) = get_doc_value(item) {\n+        write!(w, \"<div class='docblock'>{}</div>\",\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n     Ok(())\n }\n@@ -1817,7 +1843,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \"\n                        <tr class='{stab} module-item'>\n-                           <td><a class='{class}' href='{href}'\n+                           <td><a class=\\\"{class}\\\" href=\\\"{href}\\\"\n                                   title='{title_type} {title}'>{name}</a>{unsafety_flag}</td>\n                            <td class='docblock-short'>\n                                {stab_docs} {docs}\n@@ -2215,24 +2241,20 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n fn assoc_const(w: &mut fmt::Formatter,\n                it: &clean::Item,\n                ty: &clean::Type,\n-               default: Option<&String>,\n+               _default: Option<&String>,\n                link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"const <a href='{}' class='constant'>{}</a>\",\n+    write!(w, \"const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            naive_assoc_href(it, link),\n-           it.name.as_ref().unwrap())?;\n-\n-    write!(w, \": {}\", ty)?;\n-    if let Some(default) = default {\n-        write!(w, \" = {}\", Escape(default))?;\n-    }\n+           it.name.as_ref().unwrap(),\n+           ty)?;\n     Ok(())\n }\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: Option<&clean::Type>,\n               link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"type <a href='{}' class='type'>{}</a>\",\n+    write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n@@ -2375,7 +2397,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 let ns_id = derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n-                write!(w, \"<span id='{id}' class='{item_type}'>\n+                write!(w, \"<span id='{id}' class=\\\"{item_type}\\\">\n                            <span id='{ns_id}' class='invisible'>\n                            <code>{name}: {ty}</code>\n                            </span></span>\",\n@@ -2417,7 +2439,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if fields.peek().is_some() {\n         write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n-            write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n+            write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n                    shortty = ItemType::StructField,\n                    name = field.name.as_ref().unwrap(),\n@@ -2902,7 +2924,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 if render_method_item {\n                     let id = derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n@@ -2914,31 +2936,31 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n@@ -2956,7 +2978,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n-                        if item.doc_value().is_some() {\n+                        if get_doc_value(item).is_some() {\n                             document_full(w, item)?;\n                         } else {\n                             // In case the item isn't documented,"}, {"sha": "200285862276a5f8e63ea479e02fde2268a9538c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -979,7 +979,7 @@\n             .html(\"[<span class='inner'></span>]\");\n         toggle.children(\".inner\").text(labelForToggleButton(false));\n \n-        $(\".method\").each(function() {\n+        $(\".method, .impl-items > .associatedconstant\").each(function() {\n             if ($(this).next().is(\".docblock\") ||\n                 ($(this).next().is(\".stability\") && $(this).next().next().is(\".docblock\"))) {\n                     $(this).children().last().after(toggle.clone());"}, {"sha": "b0bf69b0181f22ae2de2705e1a333788bda169d5", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -89,7 +89,7 @@ h2 {\n h3 {\n \tfont-size: 1.3em;\n }\n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tfont-weight: 500;\n \tmargin: 20px 0 15px 0;\n \tpadding-bottom: 6px;\n@@ -99,10 +99,10 @@ h1.fqn {\n \tmargin-top: 0;\n \tposition: relative;\n }\n-h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tborder-bottom: 1px solid;\n }\n-h3.impl, h3.method, h4.method, h3.type, h4.type {\n+h3.impl, h3.method, h4.method, h3.type, h4.type, h4.associatedconstant {\n \tfont-weight: 600;\n \tmargin-top: 10px;\n \tmargin-bottom: 10px;\n@@ -382,7 +382,7 @@ h4 > code, h3 > code, .invisible > code {\n .content .impl-items .docblock, .content .impl-items .stability {\n \tmargin-left: 40px;\n }\n-.content .impl-items .method, .content .impl-items > .type {\n+.content .impl-items .method, .content .impl-items > .type, .impl-items > .associatedconstant {\n \tmargin-left: 20px;\n }\n "}, {"sha": "d4119f5d351c16fecae2c652bae61a8282b16bc1", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -13,14 +13,16 @@\n pub trait Foo {\n     // @has assoc_consts/trait.Foo.html '//*[@class=\"rust trait\"]' \\\n     //      'const FOO: usize;'\n-    // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO'\n-    const FOO: usize;\n+    // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'FOO: usize = 12'\n+    const FOO: usize = 12;\n }\n \n pub struct Bar;\n \n impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAR\"]' \\\n-    //      'const BAR: usize = 3'\n+    //      'const BAR: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'BAR: usize = 3'\n     pub const BAR: usize = 3;\n }"}, {"sha": "493c08693e94a6d1e317f5d69000dff1d4792780", "filename": "src/test/rustdoc/issue-28478.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -16,7 +16,8 @@ pub trait Bar {\n     // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = ()'\n     // @has - '//*[@href=\"#associatedtype.Bar\"]' 'Bar'\n     type Bar = ();\n-    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize = 7'\n+    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'Baz: usize = 7'\n     // @has - '//*[@href=\"#associatedconstant.Baz\"]' 'Baz'\n     const Baz: usize = 7;\n     // @has - '//*[@id=\"tymethod.bar\"]' 'fn bar'"}, {"sha": "a34ee908ef295adff271c5ef0aa09044fc29ac78", "filename": "src/test/rustdoc/issue-33302.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fda3f9874627fee7a8d3605c76b441d4c9b2540f/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33302.rs?ref=fda3f9874627fee7a8d3605c76b441d4c9b2540f", "patch": "@@ -28,18 +28,40 @@ macro_rules! make {\n             fn ignore(_: &X) {}\n             const C: X;\n             // @has issue_33302/trait.T.html \\\n-            //        '//*[@class=\"rust trait\"]' 'const D: i32 = 4 * 4;'\n-            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+            //        '//*[@class=\"rust trait\"]' 'const D: i32'\n+            // @has - '//*[@class=\"docblock\"]' 'D: i32 = 4 * 4'\n+            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32'\n             const D: i32 = ($n * $n);\n         }\n \n         // @has issue_33302/struct.S.html \\\n         //        '//h3[@class=\"impl\"]' 'impl T<[i32; 16]> for S'\n-        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 16] = [0; 4 * 4]'\n-        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 16]'\n+        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: [i32; 16] = [0; 4 * 4]'\n         impl T<[i32; ($n * $n)]> for S {\n             const C: [i32; ($n * $n)] = [0; ($n * $n)];\n         }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 16]> for S'\n+        // @has - '//*[@id=\"associatedconstant.C-1\"]' 'const C: (i32,)'\n+        // @has - '//*[@id=\"associatedconstant.D-1\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: (i32,) = (4,)'\n+        impl T<(i32,)> for S {\n+            const C: (i32,) = ($n,);\n+        }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<(i32, i32)> for S'\n+        // @has - '//*[@id=\"associatedconstant.C-2\"]' 'const C: (i32, i32)'\n+        // @has - '//*[@id=\"associatedconstant.D-2\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: (i32, i32) = (4, 4)'\n+        // @has - '//*[@class=\"docblock\"]' 'D: i32 = 4 / 4'\n+        impl T<(i32, i32)> for S {\n+            const C: (i32, i32) = ($n, $n);\n+            const D: i32 = ($n / $n);\n+        }\n     }\n }\n "}]}