{"sha": "032d97fa018de3d50136b338e02dabe84ab9c695", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMmQ5N2ZhMDE4ZGUzZDUwMTM2YjMzOGUwMmRhYmU4NGFiOWM2OTU=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-08-26T19:22:04Z"}, "committer": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-09-28T03:24:14Z"}, "message": "in which inferable outlives-requirements are linted\n\nRFC 2093 (tracking issue #44493) lets us leave off\ncommonsensically inferable `T: 'a` outlives requirements. (A separate\nfeature-gate was split off for the case of 'static lifetimes, for\nwhich questions still remain.) Detecting these was requested as an\nidioms-2018 lint.\n\nIt turns out that issuing a correct, autofixable suggestion here is\nsomewhat subtle in the presence of other bounds and generic\nparameters. Basically, we want to handle these three cases:\n\n \u2022 One outlives-bound. We want to drop the bound altogether, including\n   the colon\u2014\n\n   MyStruct<'a, T: 'a>\n                 ^^^^ help: remove this bound\n\n \u2022 An outlives bound first, followed by a trait bound. We want to\n   delete the outlives bound and the following plus sign (and\n   hopefully get the whitespace right, too)\u2014\n\n   MyStruct<'a, T: 'a + MyTrait>\n                   ^^^^^ help: remove this bound\n\n \u2022 An outlives bound after a trait bound. We want to delete the\n   outlives lifetime and the preceding plus sign\u2014\n\n   MyStruct<'a, T: MyTrait + 'a>\n                          ^^^^^ help: remove this bound\n\nThis gets (slightly) even more complicated in the case of where\nclauses, where we want to drop the where clause altogether if there's\njust the one bound. Hopefully the comments are enough to explain\nwhat's going on!\n\nA script (in Python, sorry) was used to generate the\nhopefully-sufficiently-exhaustive UI test input. Some of these are\nsplit off into a different file because rust-lang-nursery/rustfix#141\n(and, causally upstream of that, #53934) prevents them from being\n`run-rustfix`-tested.\n\nWe also make sure to include a UI test of a case (copied from RFC\n2093) where the outlives-bound can't be inferred. Special thanks to\nNiko Matsakis for pointing out the `inferred_outlives_of` query,\nrather than blindly stripping outlives requirements as if we weren't a\nproduction compiler and didn't care.\n\nThis concerns #52042.", "tree": {"sha": "5f573f7e9921d61e633af79e6d2336608e58941d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f573f7e9921d61e633af79e6d2336608e58941d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/032d97fa018de3d50136b338e02dabe84ab9c695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/032d97fa018de3d50136b338e02dabe84ab9c695", "html_url": "https://github.com/rust-lang/rust/commit/032d97fa018de3d50136b338e02dabe84ab9c695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/032d97fa018de3d50136b338e02dabe84ab9c695/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d52cbce6db83e4fc2d8706b4e4b9c7da76cbcf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d52cbce6db83e4fc2d8706b4e4b9c7da76cbcf8", "html_url": "https://github.com/rust-lang/rust/commit/7d52cbce6db83e4fc2d8706b4e4b9c7da76cbcf8"}], "stats": {"total": 1096, "additions": 1095, "deletions": 1}, "files": [{"sha": "38ec414fda9e383c9c91ee9a719d036fba52ba24", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -338,6 +338,12 @@ declare_lint! {\n      cannot be referred to by absolute paths\"\n }\n \n+declare_lint! {\n+    pub EXPLICIT_OUTLIVES_REQUIREMENTS,\n+    Allow,\n+    \"outlives requirements can be inferred\"\n+}\n+\n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {"}, {"sha": "1b4a783be0b14aed388eec2ae88556fce83681f3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -1999,3 +1999,233 @@ impl EarlyLintPass for KeywordIdents {\n         lint.emit()\n     }\n }\n+\n+\n+pub struct ExplicitOutlivesRequirements;\n+\n+impl LintPass for ExplicitOutlivesRequirements {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![EXPLICIT_OUTLIVES_REQUIREMENTS]\n+    }\n+}\n+\n+impl ExplicitOutlivesRequirements {\n+    fn collect_outlives_bound_spans(\n+        &self,\n+        cx: &LateContext,\n+        item_def_id: DefId,\n+        param_name: &str,\n+        bounds: &hir::GenericBounds,\n+        infer_static: bool\n+    ) -> Vec<(usize, Span)> {\n+        // For lack of a more elegant strategy for comparing the `ty::Predicate`s\n+        // returned by this query with the params/bounds grabbed from the HIR\u2014and\n+        // with some regrets\u2014we're going to covert the param/lifetime names to\n+        // strings\n+        let inferred_outlives = cx.tcx.inferred_outlives_of(item_def_id);\n+\n+        let ty_lt_names = inferred_outlives.iter().filter_map(|pred| {\n+            let binder = match pred {\n+                ty::Predicate::TypeOutlives(binder) => binder,\n+                _ => { return None; }\n+            };\n+            let ty_outlives_pred = binder.skip_binder();\n+            let ty_name = match ty_outlives_pred.0.sty {\n+                ty::Param(param) => param.name.to_string(),\n+                _ => { return None; }\n+            };\n+            let lt_name = match ty_outlives_pred.1 {\n+                ty::RegionKind::ReEarlyBound(region) => {\n+                    region.name.to_string()\n+                },\n+                _ => { return None; }\n+            };\n+            Some((ty_name, lt_name))\n+        }).collect::<Vec<_>>();\n+\n+        let mut bound_spans = Vec::new();\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if let hir::GenericBound::Outlives(lifetime) = bound {\n+                let is_static = match lifetime.name {\n+                    hir::LifetimeName::Static => true,\n+                    _ => false\n+                };\n+                if is_static && !infer_static {\n+                    // infer-outlives for 'static is still feature-gated (tracking issue #44493)\n+                    continue;\n+                }\n+\n+                let lt_name = &lifetime.name.ident().to_string();\n+                if ty_lt_names.contains(&(param_name.to_owned(), lt_name.to_owned())) {\n+                    bound_spans.push((i, bound.span()));\n+                }\n+            }\n+        }\n+        bound_spans\n+    }\n+\n+    fn consolidate_outlives_bound_spans(\n+        &self,\n+        lo: Span,\n+        bounds: &hir::GenericBounds,\n+        bound_spans: Vec<(usize, Span)>\n+    ) -> Vec<Span> {\n+        if bounds.is_empty() {\n+            return Vec::new();\n+        }\n+        if bound_spans.len() == bounds.len() {\n+            let (_, last_bound_span) = bound_spans[bound_spans.len()-1];\n+            // If all bounds are inferable, we want to delete the colon, so\n+            // start from just after the parameter (span passed as argument)\n+            vec![lo.to(last_bound_span)]\n+        } else {\n+            let mut merged = Vec::new();\n+            let mut last_merged_i = None;\n+\n+            let mut from_start = true;\n+            for (i, bound_span) in bound_spans {\n+                match last_merged_i {\n+                    // If the first bound is inferable, our span should also eat the trailing `+`\n+                    None if i == 0 => {\n+                        merged.push(bound_span.to(bounds[1].span().shrink_to_lo()));\n+                        last_merged_i = Some(0);\n+                    },\n+                    // If consecutive bounds are inferable, merge their spans\n+                    Some(h) if i == h+1 => {\n+                        if let Some(tail) = merged.last_mut() {\n+                            // Also eat the trailing `+` if the first\n+                            // more-than-one bound is inferable\n+                            let to_span = if from_start && i < bounds.len() {\n+                                bounds[i+1].span().shrink_to_lo()\n+                            } else {\n+                                bound_span\n+                            };\n+                            *tail = tail.to(to_span);\n+                            last_merged_i = Some(i);\n+                        } else {\n+                            bug!(\"another bound-span visited earlier\");\n+                        }\n+                    },\n+                    _ => {\n+                        // When we find a non-inferable bound, subsequent inferable bounds\n+                        // won't be consecutive from the start (and we'll eat the leading\n+                        // `+` rather than the trailing one)\n+                        from_start = false;\n+                        merged.push(bounds[i-1].span().shrink_to_hi().to(bound_span));\n+                        last_merged_i = Some(i);\n+                    }\n+                }\n+            }\n+            merged\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n+        let def_id = cx.tcx.hir.local_def_id(item.id);\n+        if let hir::ItemKind::Struct(_, ref generics) = item.node {\n+            let mut bound_count = 0;\n+            let mut lint_spans = Vec::new();\n+\n+            for param in &generics.params {\n+                let param_name = match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => { continue; },\n+                    hir::GenericParamKind::Type { .. } => {\n+                        match param.name {\n+                            hir::ParamName::Fresh(_) => { continue; },\n+                            hir::ParamName::Plain(name) => name.to_string()\n+                        }\n+                    }\n+                };\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx, def_id, &param_name, &param.bounds, infer_static\n+                );\n+                bound_count += bound_spans.len();\n+                lint_spans.extend(\n+                    self.consolidate_outlives_bound_spans(\n+                        param.span.shrink_to_hi(), &param.bounds, bound_spans\n+                    )\n+                );\n+            }\n+\n+            let mut where_lint_spans = Vec::new();\n+            let mut dropped_predicate_count = 0;\n+            let num_predicates = generics.where_clause.predicates.len();\n+            for (i, where_predicate) in generics.where_clause.predicates.iter().enumerate() {\n+                if let hir::WherePredicate::BoundPredicate(predicate) = where_predicate {\n+                    let param_name = match predicate.bounded_ty.node {\n+                        hir::TyKind::Path(ref qpath) => {\n+                            if let hir::QPath::Resolved(None, ty_param_path) = qpath {\n+                                ty_param_path.segments[0].ident.to_string()\n+                            } else {\n+                                continue;\n+                            }\n+                        },\n+                        _ => { continue; }\n+                    };\n+                    let bound_spans = self.collect_outlives_bound_spans(\n+                        cx, def_id, &param_name, &predicate.bounds, infer_static\n+                    );\n+                    bound_count += bound_spans.len();\n+\n+                    let drop_predicate = bound_spans.len() == predicate.bounds.len();\n+                    if drop_predicate {\n+                        dropped_predicate_count += 1;\n+                    }\n+\n+                    // If all the bounds on a predicate were inferable and there are\n+                    // further predicates, we want to eat the trailing comma\n+                    if drop_predicate && i + 1 < num_predicates {\n+                        let next_predicate_span = generics.where_clause.predicates[i+1].span();\n+                        where_lint_spans.push(\n+                            predicate.span.to(next_predicate_span.shrink_to_lo())\n+                        );\n+                    } else {\n+                        where_lint_spans.extend(\n+                            self.consolidate_outlives_bound_spans(\n+                                predicate.span.shrink_to_lo(),\n+                                &predicate.bounds,\n+                                bound_spans\n+                            )\n+                        );\n+                    }\n+                }\n+            }\n+\n+            // If all predicates are inferable, drop the entire clause\n+            // (including the `where`)\n+            if num_predicates > 0 && dropped_predicate_count == num_predicates {\n+                let full_where_span = generics.span.shrink_to_hi()\n+                    .to(generics.where_clause.span()\n+                    .expect(\"span of (nonempty) where clause should exist\"));\n+                lint_spans.push(\n+                    full_where_span\n+                );\n+            } else {\n+                lint_spans.extend(where_lint_spans);\n+            }\n+\n+            if !lint_spans.is_empty() {\n+                let mut err = cx.struct_span_lint(\n+                    EXPLICIT_OUTLIVES_REQUIREMENTS,\n+                    lint_spans.clone(),\n+                    \"outlives requirements can be inferred\"\n+                );\n+                err.multipart_suggestion_with_applicability(\n+                    if bound_count == 1 {\n+                        \"remove this bound\"\n+                    } else {\n+                        \"remove these bounds\"\n+                    },\n+                    lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n+                    Applicability::MachineApplicable\n+                );\n+                err.emit();\n+            }\n+\n+        }\n+    }\n+\n+}"}, {"sha": "9e0471f59fbab6548fa741fb4765ca68b20be392", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -48,6 +48,7 @@ use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n     ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     ELIDED_LIFETIMES_IN_PATHS,\n+    EXPLICIT_OUTLIVES_REQUIREMENTS,\n     parser::QUESTION_MARK_MACRO_SEP\n };\n use rustc::session;\n@@ -157,6 +158,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         TypeLimits: TypeLimits::new(),\n         MissingDoc: MissingDoc::new(),\n         MissingDebugImplementations: MissingDebugImplementations::new(),\n+        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n     ]], ['tcx]);\n \n     store.register_late_pass(sess, false, box BuiltinCombinedLateLintPass::new());\n@@ -199,7 +201,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     BARE_TRAIT_OBJECTS,\n                     UNUSED_EXTERN_CRATES,\n                     ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n-                    ELIDED_LIFETIMES_IN_PATHS\n+                    ELIDED_LIFETIMES_IN_PATHS,\n+                    EXPLICIT_OUTLIVES_REQUIREMENTS\n \n                     // FIXME(#52665, #47816) not always applicable and not all\n                     // macros are ready for this yet."}, {"sha": "441e1446e5ad0bf26e85e12b5e35370addf79af7", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-multispan.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+#![deny(explicit_outlives_requirements)]\n+\n+use std::fmt::{Debug, Display};\n+\n+// These examples should live in edition-lint-infer-outlives.rs, but are split\n+// into this separate file because they can't be `rustfix`'d (and thus, can't\n+// be part of a `run-rustfix` test file) until rust-lang-nursery/rustfix#141\n+// is solved\n+\n+struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: &'b U\n+}\n+\n+fn main() {}"}, {"sha": "8b05a8094619bdcf76e643e42d8a56a2fd453bbe", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-multispan.stderr", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-multispan.stderr?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,118 @@\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:21:43\n+   |\n+LL | struct TeeOutlivesAyIsDebugBee<'a, 'b, T: 'a + Debug + 'b> {\n+   |                                           ^^^^^     ^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:12:9\n+   |\n+LL | #![deny(explicit_outlives_requirements)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyIsDebugBee<'a, 'b, T: Debug> {\n+   |                                          --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:26:57\n+   |\n+LL | struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: 'a + Debug + 'b {\n+   |                                                         ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeWhereOutlivesAyIsDebugBee<'a, 'b, T> where T: Debug {\n+   |                                                        --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:31:49\n+   |\n+LL | struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: 'a + Debug + 'b> {\n+   |                                                 ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeYooOutlivesAyIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                                --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:37:44\n+   |\n+LL | struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T: 'a, U: 'b + Debug> {\n+   |                                            ^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyYooBeeIsDebug<'a, 'b, T, U: Debug> {\n+   |                                           --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:43:44\n+   |\n+LL | struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T: 'a, U: Debug + 'b> {\n+   |                                            ^^^^          ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyYooIsDebugBee<'a, 'b, T, U: Debug> {\n+   |                                           --        --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:49:42\n+   |\n+LL | struct TeeOutlivesAyYooWhereBee<'a, 'b, T: 'a, U> where U: 'b {\n+   |                                          ^^^^    ^^^^^^^^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyYooWhereBee<'a, 'b, T, U> {\n+   |                                         --  --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:55:63\n+   |\n+LL | struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: 'a + Debug + 'b {\n+   |                                                               ^^^^^     ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeYooWhereOutlivesAyIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                              --   --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:61:49\n+   |\n+LL | struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T: 'a, U> where U: 'b + Debug {\n+   |                                                 ^^^^              ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                --            --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:67:49\n+   |\n+LL | struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T: 'a, U> where U: Debug + 'b {\n+   |                                                 ^^^^                   ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                --                 --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:73:65\n+   |\n+LL | struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where T: 'a, U: 'b + Debug {\n+   |                                                                 ^^^^^^^   ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeWhereOutlivesAyYooWhereBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+   |                                                                -- --\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-multispan.rs:79:65\n+   |\n+LL | struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where T: 'a, U: Debug + 'b {\n+   |                                                                 ^^^^^^^        ^^^^^\n+help: remove these bounds\n+   |\n+LL | struct TeeWhereOutlivesAyYooWhereIsDebugBee<'a, 'b, T, U> where U: Debug {\n+   |                                                                --      --\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "d70c847e9fe6826d37837ad61664e284c9fecf1d", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.fixed", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![allow(unused)]\n+#![deny(explicit_outlives_requirements)]\n+\n+use std::fmt::{Debug, Display};\n+\n+\n+// Programmatically generated examples!\n+//\n+// Exercise outlives bounds for each of the following parameter/position\n+// combinations\u2014\n+//\n+// \u2022 one generic parameter (T) bound inline\n+// \u2022 one parameter (T) with a where clause\n+// \u2022 two parameters (T and U), both bound inline\n+// \u2022 two paramters (T and U), one bound inline, one with a where clause\n+// \u2022 two parameters (T and U), both with where clauses\n+//\n+// \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1\n+// trait bounds distributed among said parameters (subject to no where clause\n+// being empty and the struct having at least one lifetime).\n+\n+\n+struct TeeOutlivesAy<'a, T> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeOutlivesAyIsDebug<'a, T: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeIsDebugOutlivesAy<'a, T: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeOutlivesAyBee<'a, 'b, T> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereOutlivesAy<'a, T> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereOutlivesAyIsDebug<'a, T> where T: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereOutlivesAyBee<'a, 'b, T> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeYooOutlivesAy<'a, T, U> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooOutlivesAyIsDebug<'a, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeOutlivesAyYooIsDebug<'a, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeYooOutlivesAyBee<'a, 'b, T, U> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+struct TeeYooWhereOutlivesAy<'a, T, U> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+\n+// But outlives inference for 'static lifetimes is under a separate\n+// feature-gate for now\n+// (https://github.com/rust-lang/rust/issues/44493#issuecomment-407846046).\n+struct StaticRef<T: 'static> {\n+    field: &'static T\n+}\n+\n+\n+fn main() {}"}, {"sha": "0e4436fe1632f7742458f8afdbcfa9b15fb3593b", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![allow(unused)]\n+#![deny(explicit_outlives_requirements)]\n+\n+use std::fmt::{Debug, Display};\n+\n+\n+// Programmatically generated examples!\n+//\n+// Exercise outlives bounds for each of the following parameter/position\n+// combinations\u2014\n+//\n+// \u2022 one generic parameter (T) bound inline\n+// \u2022 one parameter (T) with a where clause\n+// \u2022 two parameters (T and U), both bound inline\n+// \u2022 two paramters (T and U), one bound inline, one with a where clause\n+// \u2022 two parameters (T and U), both with where clauses\n+//\n+// \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1\n+// trait bounds distributed among said parameters (subject to no where clause\n+// being empty and the struct having at least one lifetime).\n+\n+\n+struct TeeOutlivesAy<'a, T: 'a> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T\n+}\n+\n+struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T\n+}\n+\n+struct TeeYooOutlivesAy<'a, T, U: 'a> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a U\n+}\n+\n+struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: T,\n+    yoo: &'a &'b U\n+}\n+\n+struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a T,\n+    yoo: U\n+}\n+\n+struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+    //~^ ERROR outlives requirements can be inferred\n+    tee: &'a &'b T,\n+    yoo: U\n+}\n+\n+\n+// But outlives inference for 'static lifetimes is under a separate\n+// feature-gate for now\n+// (https://github.com/rust-lang/rust/issues/44493#issuecomment-407846046).\n+struct StaticRef<T: 'static> {\n+    field: &'static T\n+}\n+\n+\n+fn main() {}"}, {"sha": "910de1dd06c0e1f7d85f18f64d1e0f5e3ee8f8b1", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.stderr", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,188 @@\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:35:27\n+   |\n+LL | struct TeeOutlivesAy<'a, T: 'a> {\n+   |                           ^^^^ help: remove this bound\n+   |\n+note: lint level defined here\n+  --> $DIR/edition-lint-infer-outlives.rs:14:9\n+   |\n+LL | #![deny(explicit_outlives_requirements)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:40:36\n+   |\n+LL | struct TeeOutlivesAyIsDebug<'a, T: 'a + Debug> {\n+   |                                    ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:45:41\n+   |\n+LL | struct TeeIsDebugOutlivesAy<'a, T: Debug + 'a> {\n+   |                                         ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:50:34\n+   |\n+LL | struct TeeOutlivesAyBee<'a, 'b, T: 'a + 'b> {\n+   |                                  ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:55:43\n+   |\n+LL | struct TeeOutlivesAyBeeIsDebug<'a, 'b, T: 'a + 'b + Debug> {\n+   |                                           ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:60:48\n+   |\n+LL | struct TeeIsDebugOutlivesAyBee<'a, 'b, T: Debug + 'a + 'b> {\n+   |                                                ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:65:33\n+   |\n+LL | struct TeeWhereOutlivesAy<'a, T> where T: 'a {\n+   |                                 ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:70:50\n+   |\n+LL | struct TeeWhereOutlivesAyIsDebug<'a, T> where T: 'a + Debug {\n+   |                                                  ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:75:55\n+   |\n+LL | struct TeeWhereIsDebugOutlivesAy<'a, T> where T: Debug + 'a {\n+   |                                                       ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:80:40\n+   |\n+LL | struct TeeWhereOutlivesAyBee<'a, 'b, T> where T: 'a + 'b {\n+   |                                        ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:85:57\n+   |\n+LL | struct TeeWhereOutlivesAyBeeIsDebug<'a, 'b, T> where T: 'a + 'b + Debug {\n+   |                                                         ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:90:62\n+   |\n+LL | struct TeeWhereIsDebugOutlivesAyBee<'a, 'b, T> where T: Debug + 'a + 'b {\n+   |                                                              ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:95:33\n+   |\n+LL | struct TeeYooOutlivesAy<'a, T, U: 'a> {\n+   |                                 ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:101:42\n+   |\n+LL | struct TeeYooOutlivesAyIsDebug<'a, T, U: 'a + Debug> {\n+   |                                          ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:107:47\n+   |\n+LL | struct TeeYooIsDebugOutlivesAy<'a, T, U: Debug + 'a> {\n+   |                                               ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:113:37\n+   |\n+LL | struct TeeOutlivesAyYooIsDebug<'a, T: 'a, U: Debug> {\n+   |                                     ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:119:40\n+   |\n+LL | struct TeeYooOutlivesAyBee<'a, 'b, T, U: 'a + 'b> {\n+   |                                        ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:125:49\n+   |\n+LL | struct TeeYooOutlivesAyBeeIsDebug<'a, 'b, T, U: 'a + 'b + Debug> {\n+   |                                                 ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:131:54\n+   |\n+LL | struct TeeYooIsDebugOutlivesAyBee<'a, 'b, T, U: Debug + 'a + 'b> {\n+   |                                                      ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:137:44\n+   |\n+LL | struct TeeOutlivesAyBeeYooIsDebug<'a, 'b, T: 'a + 'b, U: Debug> {\n+   |                                            ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:143:39\n+   |\n+LL | struct TeeYooWhereOutlivesAy<'a, T, U> where U: 'a {\n+   |                                       ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:149:56\n+   |\n+LL | struct TeeYooWhereOutlivesAyIsDebug<'a, T, U> where U: 'a + Debug {\n+   |                                                        ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:155:61\n+   |\n+LL | struct TeeYooWhereIsDebugOutlivesAy<'a, T, U> where U: Debug + 'a {\n+   |                                                             ^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:161:42\n+   |\n+LL | struct TeeOutlivesAyYooWhereIsDebug<'a, T: 'a, U> where U: Debug {\n+   |                                          ^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:167:46\n+   |\n+LL | struct TeeYooWhereOutlivesAyBee<'a, 'b, T, U> where U: 'a + 'b {\n+   |                                              ^^^^^^^^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:173:63\n+   |\n+LL | struct TeeYooWhereOutlivesAyBeeIsDebug<'a, 'b, T, U> where U: 'a + 'b + Debug {\n+   |                                                               ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:179:68\n+   |\n+LL | struct TeeYooWhereIsDebugOutlivesAyBee<'a, 'b, T, U> where U: Debug + 'a + 'b {\n+   |                                                                    ^^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:185:49\n+   |\n+LL | struct TeeOutlivesAyBeeYooWhereIsDebug<'a, 'b, T: 'a + 'b, U> where U: Debug {\n+   |                                                 ^^^^^^^^^ help: remove these bounds\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:191:58\n+   |\n+LL | struct TeeWhereOutlivesAyYooWhereIsDebug<'a, T, U> where T: 'a, U: Debug {\n+   |                                                          ^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:197:65\n+   |\n+LL | struct TeeWhereOutlivesAyBeeYooWhereIsDebug<'a, 'b, T, U> where T: 'a + 'b, U: Debug {\n+   |                                                                 ^^^^^^^^^^^^ help: remove these bounds\n+\n+error: aborting due to 30 previous errors\n+"}, {"sha": "00059294a97649db5603f7740cf3c0eef561a466", "filename": "src/test/ui/rust-2018/edition-lint-uninferable-outlives.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-uninferable-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/032d97fa018de3d50136b338e02dabe84ab9c695/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-uninferable-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-uninferable-outlives.rs?ref=032d97fa018de3d50136b338e02dabe84ab9c695", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![allow(unused)]\n+#![deny(explicit_outlives_requirements)]\n+\n+// A case where we can't infer the outlives requirement. Example copied from\n+// RFC 2093.\n+// (https://rust-lang.github.io/rfcs/2093-infer-outlives.html\n+// #where-explicit-annotations-would-still-be-required)\n+\n+\n+trait MakeRef<'a> {\n+    type Type;\n+}\n+\n+impl<'a, T> MakeRef<'a> for Vec<T>\n+    where T: 'a  // still required\n+{\n+    type Type = &'a T;\n+}\n+\n+\n+struct Foo<'a, T>\n+    where T: 'a  // still required, not inferred from `field`\n+{\n+    field: <Vec<T> as MakeRef<'a>>::Type\n+}\n+\n+\n+fn main() {}"}]}