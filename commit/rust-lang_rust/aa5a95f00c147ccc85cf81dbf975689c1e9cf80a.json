{"sha": "aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNWE5NWYwMGMxNDdjY2M4NWNmODFkYmY5NzU2ODljMWU5Y2Y4MGE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-11-18T15:38:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-11-19T07:49:58Z"}, "message": "Rustup to rustc 1.41.0-nightly (a0d40f8bd 2019-11-18)", "tree": {"sha": "837e426c027904130a892f9622579bac2bf2cedb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/837e426c027904130a892f9622579bac2bf2cedb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "html_url": "https://github.com/rust-lang/rust/commit/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4f1769734b6204fc6bece8556b7b80a7683271e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f1769734b6204fc6bece8556b7b80a7683271e", "html_url": "https://github.com/rust-lang/rust/commit/b4f1769734b6204fc6bece8556b7b80a7683271e"}], "stats": {"total": 97, "additions": 38, "deletions": 59}, "files": [{"sha": "82a2e71bb2b9eeaa9a22fe91fc168ad349d3d11d", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "patch": "@@ -41,7 +41,8 @@ rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n \n [dev-dependencies]\n cargo_metadata = \"0.9.0\"\n-compiletest_rs = { version = \"0.3.24\", features = [\"tmp\"] }\n+compiletest_rs = { version = \"0.4.0\", features = [\"tmp\"] }\n+tester = \"0.7\"\n lazy_static = \"1.0\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "07e8fb34c72f0ac8fceec23534c8315d8b7e16e0", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 35, "deletions": 57, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::Applicability;\n use rustc_lexer::unescape::{self, EscapeError};\n use rustc_parse::parser;\n use syntax::ast::*;\n+use syntax::symbol::Symbol;\n use syntax::token;\n use syntax::tokenstream::TokenStream;\n use syntax_pos::{BytePos, Span};\n@@ -190,7 +191,7 @@ impl EarlyLintPass for Write {\n         if mac.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n             if let (Some(fmt_str), _) = check_tts(cx, &mac.tts, false) {\n-                if fmt_str.contents.is_empty() {\n+                if fmt_str.symbol == Symbol::intern(\"\") {\n                     span_lint_and_sugg(\n                         cx,\n                         PRINTLN_EMPTY_STRING,\n@@ -205,7 +206,7 @@ impl EarlyLintPass for Write {\n         } else if mac.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n             if let (Some(fmt_str), _) = check_tts(cx, &mac.tts, false) {\n-                if check_newlines(&fmt_str.contents, fmt_str.style) {\n+                if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n                         PRINT_WITH_NEWLINE,\n@@ -216,7 +217,7 @@ impl EarlyLintPass for Write {\n                                 \"use `println!` instead\",\n                                 vec![\n                                     (mac.path.span, String::from(\"println\")),\n-                                    (fmt_str.newline_span(), String::new()),\n+                                    (newline_span(&fmt_str), String::new()),\n                                 ],\n                                 Applicability::MachineApplicable,\n                             );\n@@ -226,7 +227,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(write) {\n             if let (Some(fmt_str), _) = check_tts(cx, &mac.tts, true) {\n-                if check_newlines(&fmt_str.contents, fmt_str.style) {\n+                if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n                         WRITE_WITH_NEWLINE,\n@@ -237,7 +238,7 @@ impl EarlyLintPass for Write {\n                                 \"use `writeln!()` instead\",\n                                 vec![\n                                     (mac.path.span, String::from(\"writeln\")),\n-                                    (fmt_str.newline_span(), String::new()),\n+                                    (newline_span(&fmt_str), String::new()),\n                                 ],\n                                 Applicability::MachineApplicable,\n                             );\n@@ -247,7 +248,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(writeln) {\n             if let (Some(fmt_str), expr) = check_tts(cx, &mac.tts, true) {\n-                if fmt_str.contents.is_empty() {\n+                if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let suggestion = expr.map_or_else(\n                         move || {\n@@ -272,37 +273,27 @@ impl EarlyLintPass for Write {\n     }\n }\n \n-/// The arguments of a `print[ln]!` or `write[ln]!` invocation.\n-struct FmtStr {\n-    /// The contents of the format string (inside the quotes).\n-    contents: String,\n-    style: StrStyle,\n-    /// The span of the format string, including quotes, the raw marker, and any raw hashes.\n-    span: Span,\n-}\n-\n-impl FmtStr {\n-    /// Given a format string that ends in a newline and its span, calculates the span of the\n-    /// newline.\n-    fn newline_span(&self) -> Span {\n-        let sp = self.span;\n+/// Given a format string that ends in a newline and its span, calculates the span of the\n+/// newline.\n+fn newline_span(fmtstr: &StrLit) -> Span {\n+    let sp = fmtstr.span;\n+    let contents = &fmtstr.symbol.as_str();\n \n-        let newline_sp_hi = sp.hi()\n-            - match self.style {\n-                StrStyle::Cooked => BytePos(1),\n-                StrStyle::Raw(hashes) => BytePos((1 + hashes).into()),\n-            };\n-\n-        let newline_sp_len = if self.contents.ends_with('\\n') {\n-            BytePos(1)\n-        } else if self.contents.ends_with(r\"\\n\") {\n-            BytePos(2)\n-        } else {\n-            panic!(\"expected format string to contain a newline\");\n+    let newline_sp_hi = sp.hi()\n+        - match fmtstr.style {\n+            StrStyle::Cooked => BytePos(1),\n+            StrStyle::Raw(hashes) => BytePos((1 + hashes).into()),\n         };\n \n-        sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n-    }\n+    let newline_sp_len = if contents.ends_with('\\n') {\n+        BytePos(1)\n+    } else if contents.ends_with(r\"\\n\") {\n+        BytePos(2)\n+    } else {\n+        panic!(\"expected format string to contain a newline\");\n+    };\n+\n+    sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n }\n \n /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n@@ -325,7 +316,7 @@ impl FmtStr {\n /// (Some(\"string to write: {}\"), Some(buf))\n /// ```\n #[allow(clippy::too_many_lines)]\n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<FmtStr>, Option<Expr>) {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n     use fmt_macros::*;\n     let tts = tts.clone();\n \n@@ -342,12 +333,11 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n         }\n     }\n \n-    let (fmtstr, fmtstyle) = match parser.parse_str().map_err(|mut err| err.cancel()) {\n-        Ok((fmtstr, fmtstyle)) => (fmtstr.to_string(), fmtstyle),\n+    let fmtstr = match parser.parse_str_lit() {\n+        Ok(fmtstr) => fmtstr,\n         Err(_) => return (None, expr),\n     };\n-    let fmtspan = parser.prev_span;\n-    let tmp = fmtstr.clone();\n+    let tmp = fmtstr.symbol.as_str();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n     while let Some(piece) = fmt_parser.next() {\n@@ -377,26 +367,12 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n             ty_span: None,\n         };\n         if !parser.eat(&token::Comma) {\n-            return (\n-                Some(FmtStr {\n-                    contents: fmtstr,\n-                    style: fmtstyle,\n-                    span: fmtspan,\n-                }),\n-                expr,\n-            );\n+            return (Some(fmtstr), expr);\n         }\n         let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n             expr\n         } else {\n-            return (\n-                Some(FmtStr {\n-                    contents: fmtstr,\n-                    style: fmtstyle,\n-                    span: fmtspan,\n-                }),\n-                None,\n-            );\n+            return (Some(fmtstr), None);\n         };\n         match &token_expr.kind {\n             ExprKind::Lit(_) => {\n@@ -448,11 +424,13 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n /// Checks if the format string contains a single newline that terminates it.\n ///\n /// Literal and escaped newlines are both checked (only literal for raw strings).\n-fn check_newlines(contents: &str, style: StrStyle) -> bool {\n+fn check_newlines(fmtstr: &StrLit) -> bool {\n     let mut has_internal_newline = false;\n     let mut last_was_cr = false;\n     let mut should_lint = false;\n \n+    let contents = &fmtstr.symbol.as_str();\n+\n     let mut cb = |r: Range<usize>, c: Result<char, EscapeError>| {\n         let c = c.unwrap();\n \n@@ -466,7 +444,7 @@ fn check_newlines(contents: &str, style: StrStyle) -> bool {\n         }\n     };\n \n-    match style {\n+    match fmtstr.style {\n         StrStyle::Cooked => unescape::unescape_str(contents, &mut cb),\n         StrStyle::Raw(_) => unescape::unescape_raw_str(contents, &mut cb),\n     }"}, {"sha": "43139e95666e3fc4ec3c21cd225c4eec6ba5ec50", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5a95f00c147ccc85cf81dbf975689c1e9cf80a/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=aa5a95f00c147ccc85cf81dbf975689c1e9cf80a", "patch": "@@ -1,7 +1,7 @@\n #![feature(test)]\n \n use compiletest_rs as compiletest;\n-extern crate test;\n+extern crate tester as test;\n \n use std::env::{set_var, var};\n use std::ffi::OsStr;"}]}