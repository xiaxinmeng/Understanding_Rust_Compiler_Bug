{"sha": "8578fee5d823979ea760e1633eefa003db98cb0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NzhmZWU1ZDgyMzk3OWVhNzYwZTE2MzNlZWZhMDAzZGI5OGNiMGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-09T19:56:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-09T19:57:04Z"}, "message": "Don't use skolemized parameters but rather fresh variables in\ncoherence. Skolemized parameters wind up preventing unification.\nSurprised we had no test for this! Fixes #24241.", "tree": {"sha": "86fd72075b0750dc0f63e6ee0d68875d0040327b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86fd72075b0750dc0f63e6ee0d68875d0040327b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8578fee5d823979ea760e1633eefa003db98cb0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8578fee5d823979ea760e1633eefa003db98cb0c", "html_url": "https://github.com/rust-lang/rust/commit/8578fee5d823979ea760e1633eefa003db98cb0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8578fee5d823979ea760e1633eefa003db98cb0c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e326aa197b1ee35b41c992eec171589197a7459d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e326aa197b1ee35b41c992eec171589197a7459d", "html_url": "https://github.com/rust-lang/rust/commit/e326aa197b1ee35b41c992eec171589197a7459d"}], "stats": {"total": 99, "additions": 49, "deletions": 50}, "files": [{"sha": "d21891ab23f1ceb0e52cc37a05a64039db53266d", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=8578fee5d823979ea760e1633eefa003db98cb0c", "patch": "@@ -26,7 +26,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n \n #[derive(Copy, Clone)]\n-struct ParamIsLocal(bool);\n+struct InferIsLocal(bool);\n \n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n@@ -60,7 +60,7 @@ fn overlap(selcx: &mut SelectionContext,\n \n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 a_def_id,\n-                                                                util::free_substs_for_impl);\n+                                                                util::fresh_type_vars_for_impl);\n \n     let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 b_def_id,\n@@ -104,7 +104,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n \n     // if the orphan rules pass, that means that no ancestor crate can\n     // impl this, so it's up to us.\n-    if orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(false)).is_ok() {\n+    if orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false)).is_ok() {\n         debug!(\"trait_ref_is_knowable: orphan check passed\");\n         return true;\n     }\n@@ -126,7 +126,7 @@ pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRe\n     // implemented by an upstream crate, which means that the impl\n     // must be visible to us, and -- since the trait is fundamental\n     // -- we can test.\n-    orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(true)).is_err()\n+    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n }\n \n type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n@@ -196,16 +196,16 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, &trait_ref, ParamIsLocal(false))\n+    orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 trait_ref: &ty::TraitRef<'tcx>,\n-                                param_is_local: ParamIsLocal)\n+                                infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={}, param_is_local={})\",\n-           trait_ref.repr(tcx), param_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={}, infer_is_local={})\",\n+           trait_ref.repr(tcx), infer_is_local.0);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n@@ -215,12 +215,12 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n     for input_ty in input_tys {\n-        if ty_is_local(tcx, input_ty, param_is_local) {\n+        if ty_is_local(tcx, input_ty, infer_is_local) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, param_is_local);\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n                     debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n@@ -234,7 +234,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Otherwise, enforce invariant that there are no type\n         // parameters reachable.\n-        if !param_is_local.0 {\n+        if !infer_is_local.0 {\n             if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n                 debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n                 return Err(OrphanCheckErr::UncoveredTy(param));\n@@ -249,14 +249,14 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n                        ty: Ty<'tcx>,\n-                       param_is_local: ParamIsLocal)\n+                       infer_is_local: InferIsLocal)\n                        -> Vec<Ty<'tcx>>\n {\n-    if ty_is_local_constructor(tcx, ty, param_is_local) {\n+    if ty_is_local_constructor(tcx, ty, infer_is_local) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, param_is_local).into_iter())\n+          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local).into_iter())\n           .collect()\n     } else {\n         vec![ty]\n@@ -271,10 +271,10 @@ fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, param_is_local: ParamIsLocal) -> bool\n+fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n {\n-    ty_is_local_constructor(tcx, ty, param_is_local) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, param_is_local))\n+    ty_is_local_constructor(tcx, ty, infer_is_local) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n@@ -293,7 +293,7 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n \n fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  ty: Ty<'tcx>,\n-                                 param_is_local: ParamIsLocal)\n+                                 infer_is_local: InferIsLocal)\n                                  -> bool\n {\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n@@ -310,13 +310,13 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_tup(..) |\n-        ty::ty_infer(..) |\n+        ty::ty_param(..) |\n         ty::ty_projection(..) => {\n             false\n         }\n \n-        ty::ty_param(..) => {\n-            param_is_local.0\n+        ty::ty_infer(..) => {\n+            infer_is_local.0\n         }\n \n         ty::ty_enum(def_id, _) |"}, {"sha": "3a1be785580af1d4cb6746c04b6d97d88bb37dde", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=8578fee5d823979ea760e1633eefa003db98cb0c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::region;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n@@ -304,34 +303,6 @@ pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-// determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n-// would return ($0, $1) where $0 and $1 are freshly instantiated type\n-// variables.\n-pub fn free_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      _span: Span,\n-                                      impl_def_id: ast::DefId)\n-                                      -> Substs<'tcx>\n-{\n-    let tcx = infcx.tcx;\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-\n-    let some_types = impl_generics.types.map(|def| {\n-        ty::mk_param_from_def(tcx, def)\n-    });\n-\n-    let some_regions = impl_generics.regions.map(|def| {\n-        // FIXME. This destruction scope information is pretty darn\n-        // bogus; after all, the impl might not even be in this crate!\n-        // But given what we do in coherence, it is harmless enough\n-        // for now I think. -nmatsakis\n-        let extent = region::DestructionScopeData::new(ast::DUMMY_NODE_ID);\n-        ty::free_region_from_def(extent, def)\n-    });\n-\n-    Substs::new(some_types, some_regions)\n-}\n-\n impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)"}, {"sha": "3fd635b3d616f33840d8571ef21d620c7f22ebc4", "filename": "src/test/compile-fail/coherence-overlap-all-t-and-tuple.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8578fee5d823979ea760e1633eefa003db98cb0c/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs?ref=8578fee5d823979ea760e1633eefa003db98cb0c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we detect an overlap here in the case where:\n+//\n+//    for some type X:\n+//      T = (X,)\n+//      T11 = X, U11 = X\n+//\n+// Seems pretty basic, but then there was issue #24241. :)\n+\n+trait From<U> {\n+}\n+\n+impl <T> From<T> for T { //~ ERROR E0119\n+}\n+\n+impl <T11, U11> From<(U11,)> for (T11,) {\n+}\n+\n+fn main() { }"}]}