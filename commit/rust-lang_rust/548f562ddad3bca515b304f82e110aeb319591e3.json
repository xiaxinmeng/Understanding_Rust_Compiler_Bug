{"sha": "548f562ddad3bca515b304f82e110aeb319591e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OGY1NjJkZGFkM2JjYTUxNWIzMDRmODJlMTEwYWViMzE5NTkxZTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T08:29:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "Other delimiters", "tree": {"sha": "71da0dc60264eee24fa809539f9d218b3c4c4a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71da0dc60264eee24fa809539f9d218b3c4c4a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/548f562ddad3bca515b304f82e110aeb319591e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/548f562ddad3bca515b304f82e110aeb319591e3", "html_url": "https://github.com/rust-lang/rust/commit/548f562ddad3bca515b304f82e110aeb319591e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/548f562ddad3bca515b304f82e110aeb319591e3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "460c8bbdec8561a581d035f9767b7dd1ba36cfd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/460c8bbdec8561a581d035f9767b7dd1ba36cfd7", "html_url": "https://github.com/rust-lang/rust/commit/460c8bbdec8561a581d035f9767b7dd1ba36cfd7"}], "stats": {"total": 104, "additions": 54, "deletions": 50}, "files": [{"sha": "0ae5db9fc23e994bb61c54d9201497629abec701", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/548f562ddad3bca515b304f82e110aeb319591e3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548f562ddad3bca515b304f82e110aeb319591e3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=548f562ddad3bca515b304f82e110aeb319591e3", "patch": "@@ -187,9 +187,9 @@ impl AstNode for TupleFieldDefList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleFieldDefList {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn fields(&self) -> AstChildren<TupleFieldDef> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleFieldDef {\n@@ -483,9 +483,9 @@ impl AstNode for ParenType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenType {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TupleType {\n@@ -503,9 +503,9 @@ impl AstNode for TupleType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TupleType {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn fields(&self) -> AstChildren<TypeRef> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NeverType {\n@@ -580,11 +580,11 @@ impl AstNode for ArrayType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArrayType {\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SliceType {\n@@ -602,9 +602,9 @@ impl AstNode for SliceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SliceType {\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ReferenceType {\n@@ -742,9 +742,9 @@ impl AstNode for TupleExpr {\n }\n impl ast::AttrsOwner for TupleExpr {}\n impl TupleExpr {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ArrayExpr {\n@@ -763,10 +763,10 @@ impl AstNode for ArrayExpr {\n }\n impl ast::AttrsOwner for ArrayExpr {}\n impl ArrayExpr {\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -785,9 +785,9 @@ impl AstNode for ParenExpr {\n }\n impl ast::AttrsOwner for ParenExpr {}\n impl ParenExpr {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathExpr {\n@@ -1095,8 +1095,8 @@ impl AstNode for IndexExpr {\n }\n impl ast::AttrsOwner for IndexExpr {}\n impl IndexExpr {\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FieldExpr {\n@@ -1478,9 +1478,9 @@ impl AstNode for ParenPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParenPat {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n@@ -1614,9 +1614,9 @@ impl AstNode for SlicePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl SlicePat {\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RangePat {\n@@ -1756,9 +1756,9 @@ impl AstNode for TupleStructPat {\n }\n impl TupleStructPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TuplePat {\n@@ -1776,9 +1776,9 @@ impl AstNode for TuplePat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TuplePat {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Visibility {\n@@ -1879,11 +1879,11 @@ impl AstNode for Attr {\n impl Attr {\n     pub fn pound_token(&self) -> Option<Pound> { support::token(&self.syntax) }\n     pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n-    pub fn l_brack_token(&self) -> Option<LBrack> { support::token(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<Eq> { support::token(&self.syntax) }\n     pub fn input(&self) -> Option<AttrInput> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<RBrack> { support::token(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -2186,10 +2186,10 @@ impl AstNode for ParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ParamList {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n     pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n@@ -2354,9 +2354,9 @@ impl AstNode for ArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ArgList {\n-    pub fn l_paren_token(&self) -> Option<LParen> { support::token(&self.syntax) }\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<RParen> { support::token(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {"}, {"sha": "943c91e236cd5e23bd8a274256839fbddefdc8a3", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/548f562ddad3bca515b304f82e110aeb319591e3/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548f562ddad3bca515b304f82e110aeb319591e3/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=548f562ddad3bca515b304f82e110aeb319591e3", "patch": "@@ -338,7 +338,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct RecordFieldDefList { T!['{'], fields: [RecordFieldDef], T!['}'] }\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n-        struct TupleFieldDefList { LParen, fields: [TupleFieldDef], RParen }\n+        struct TupleFieldDefList { T!['('], fields: [TupleFieldDef], T![')'] }\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n@@ -411,23 +411,23 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             ItemList,\n         }\n \n-        struct ParenType { LParen, TypeRef, RParen }\n-        struct TupleType { LParen, fields: [TypeRef], RParen }\n+        struct ParenType { T!['('], TypeRef, T![')'] }\n+        struct TupleType { T!['('], fields: [TypeRef], T![')'] }\n         struct NeverType { Excl }\n         struct PathType { Path }\n         struct PointerType { Star, T![const], T![mut], TypeRef }\n-        struct ArrayType { LBrack, TypeRef, T![;], Expr, RBrack }\n-        struct SliceType { LBrack, TypeRef, RBrack }\n+        struct ArrayType { T!['['], TypeRef, T![;], Expr, T![']'] }\n+        struct SliceType { T!['['], TypeRef, T![']'] }\n         struct ReferenceType { Amp, Lifetime, T![mut], TypeRef }\n         struct PlaceholderType { Underscore }\n         struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n         struct ForType { T![for], TypeParamList, TypeRef }\n         struct ImplTraitType: TypeBoundsOwner { T![impl] }\n         struct DynTraitType: TypeBoundsOwner { T![dyn] }\n \n-        struct TupleExpr: AttrsOwner { LParen, exprs: [Expr], RParen }\n-        struct ArrayExpr: AttrsOwner { LBrack, exprs: [Expr], T![;], RBrack }\n-        struct ParenExpr: AttrsOwner { LParen, Expr, RParen }\n+        struct TupleExpr: AttrsOwner { T!['('], exprs: [Expr], T![')'] }\n+        struct ArrayExpr: AttrsOwner { T!['['], exprs: [Expr], T![;], T![']'] }\n+        struct ParenExpr: AttrsOwner { T!['('], Expr, T![')'] }\n         struct PathExpr  { Path }\n         struct LambdaExpr: AttrsOwner {\n             T![static],\n@@ -456,7 +456,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n             Expr, Dot, NameRef, TypeArgList,\n         }\n-        struct IndexExpr: AttrsOwner { LBrack, RBrack }\n+        struct IndexExpr: AttrsOwner { T!['['], T![']'] }\n         struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n         struct AwaitExpr: AttrsOwner { Expr, Dot, T![await] }\n         struct TryExpr: AttrsOwner { T![try], Expr }\n@@ -489,14 +489,14 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct RecordField: AttrsOwner { NameRef, Colon, Expr }\n \n         struct OrPat { pats: [Pat] }\n-        struct ParenPat { LParen, Pat, RParen }\n+        struct ParenPat { T!['('], Pat, T![')'] }\n         struct RefPat { Amp, T![mut], Pat }\n         struct BoxPat { T![box], Pat }\n         struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], At, Pat }\n         struct PlaceholderPat { Underscore }\n         struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n-        struct SlicePat { LBrack, args: [Pat], RBrack }\n+        struct SlicePat { T!['['], args: [Pat], T![']'] }\n         struct RangePat { RangeSeparator }\n         struct LiteralPat { Literal }\n         struct MacroPat { MacroCall }\n@@ -512,8 +512,8 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n         struct RecordFieldPat: AttrsOwner, NameOwner { Colon, Pat }\n \n-        struct TupleStructPat { Path, LParen, args: [Pat], RParen }\n-        struct TuplePat { LParen, args: [Pat], RParen }\n+        struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n+        struct TuplePat { T!['('], args: [Pat], T![')'] }\n \n         struct Visibility { T![pub], T![super], T![self], T![crate] }\n         struct Name { Ident }\n@@ -522,7 +522,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n             Path, Excl, TokenTree, T![;]\n         }\n-        struct Attr { Pound, Excl, LBrack, Path, Eq, input: AttrInput, RBrack }\n+        struct Attr { Pound, Excl, T!['['], Path, Eq, input: AttrInput, T![']'] }\n         struct TokenTree {}\n         struct TypeParamList {\n             LAngle,\n@@ -562,10 +562,10 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T!['}'],\n         }\n         struct ParamList {\n-            LParen,\n+            T!['('],\n             SelfParam,\n             params: [Param],\n-            RParen\n+            T![')']\n         }\n         struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, T![self] }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n@@ -585,9 +585,9 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![extern], T![crate], NameRef, Alias,\n         }\n         struct ArgList {\n-            LParen,\n+            T!['('],\n             args: [Expr],\n-            RParen\n+            T![')']\n         }\n         struct Path {\n             segment: PathSegment,"}, {"sha": "a903d1da77ed1e6285ba5f74f4d2d09fb01446a5", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/548f562ddad3bca515b304f82e110aeb319591e3/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548f562ddad3bca515b304f82e110aeb319591e3/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=548f562ddad3bca515b304f82e110aeb319591e3", "patch": "@@ -531,6 +531,10 @@ impl Field<'_> {\n                     \"->\" => \"thin_arrow\",\n                     \"'{'\" => \"l_curly\",\n                     \"'}'\" => \"r_curly\",\n+                    \"'('\" => \"l_paren\",\n+                    \"')'\" => \"r_paren\",\n+                    \"'['\" => \"l_brack\",\n+                    \"']'\" => \"r_brack\",\n                     _ => name,\n                 };\n                 format_ident!(\"{}_token\", name)"}]}