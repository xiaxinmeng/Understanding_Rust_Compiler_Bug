{"sha": "017450a6111a430eca86caf4ee6021ed654b552f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNzQ1MGE2MTExYTQzMGVjYTg2Y2FmNGVlNjAyMWVkNjU0YjU1MmY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T06:23:05Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:54Z"}, "message": "std: replace str::find_str* with a method", "tree": {"sha": "9b9c0a76d6583902d02d69327de6da6ad0233da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b9c0a76d6583902d02d69327de6da6ad0233da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/017450a6111a430eca86caf4ee6021ed654b552f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/017450a6111a430eca86caf4ee6021ed654b552f", "html_url": "https://github.com/rust-lang/rust/commit/017450a6111a430eca86caf4ee6021ed654b552f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/017450a6111a430eca86caf4ee6021ed654b552f/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7281fb948a48f56e06f9a324d52e70e056071005", "url": "https://api.github.com/repos/rust-lang/rust/commits/7281fb948a48f56e06f9a324d52e70e056071005", "html_url": "https://github.com/rust-lang/rust/commit/7281fb948a48f56e06f9a324d52e70e056071005"}], "stats": {"total": 179, "additions": 54, "deletions": 125}, "files": [{"sha": "f524f1424b4f5197e335938607a4f650455f8c2c", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -31,7 +31,7 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     let error_tag = ~\"//~\";\n     let mut idx;\n-    match str::find_str(line, error_tag) {\n+    match line.find_str(error_tag) {\n       None => return ~[],\n       Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }"}, {"sha": "0adcb924a49927fcebdbacee341ffa652f92873d", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -175,7 +175,7 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n fn parse_name_value_directive(line: &str,\n                               directive: ~str) -> Option<~str> {\n     let keycolon = directive + \":\";\n-    match str::find_str(line, keycolon) {\n+    match line.find_str(keycolon) {\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n                                    line.len()).to_owned();"}, {"sha": "36d91382fb286f56967d1a84b344f17af28fb0fc", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -407,8 +407,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = str::find_str(s, \"a\").get();\n-    let bpos = str::find_str(s, \"b\").get();\n+    let apos = s.find_str(\"a\").get();\n+    let bpos = s.find_str(\"b\").get();\n     assert!(apos < bpos);\n }\n "}, {"sha": "6b13c1fe1f65a2f4488e667feb858e6a32333c31", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -633,10 +633,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = str::find_str(markdown, \"# Module `a`\").get();\n-        let idx_b = str::find_str(markdown, \"## Function `b`\").get();\n-        let idx_c = str::find_str(markdown, \"# Module `c`\").get();\n-        let idx_d = str::find_str(markdown, \"## Function `d`\").get();\n+        let idx_a = markdown.find_str(\"# Module `a`\").get();\n+        let idx_b = markdown.find_str(\"## Function `b`\").get();\n+        let idx_c = markdown.find_str(\"# Module `c`\").get();\n+        let idx_d = markdown.find_str(\"## Function `d`\").get();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);"}, {"sha": "98b210dd5a912abcc38adba97d95a3b3557aba0b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 44, "deletions": 115, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -1166,88 +1166,6 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     return true;\n }\n \n-/**\n- * Returns the byte index of the first matching substring\n- *\n- * # Arguments\n- *\n- * * `haystack` - The string to search\n- * * `needle` - The string to search for\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching substring\n- * or `none` if there is no match\n- */\n-pub fn find_str<'a,'b>(haystack: &'a str, needle: &'b str) -> Option<uint> {\n-    find_str_between(haystack, needle, 0u, haystack.len())\n-}\n-\n-/**\n- * Returns the byte index of the first matching substring beginning\n- * from a given byte offset\n- *\n- * # Arguments\n- *\n- * * `haystack` - The string to search\n- * * `needle` - The string to search for\n- * * `start` - The byte index to begin searching at, inclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `s.len()`\n- */\n-pub fn find_str_from<'a,'b>(haystack: &'a str,\n-                            needle: &'b str,\n-                            start: uint)\n-                         -> Option<uint> {\n-    find_str_between(haystack, needle, start, haystack.len())\n-}\n-\n-/**\n- * Returns the byte index of the first matching substring within a given range\n- *\n- * # Arguments\n- *\n- * * `haystack` - The string to search\n- * * `needle` - The string to search for\n- * * `start` - The byte index to begin searching at, inclusive\n- * * `end` - The byte index to end searching at, exclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `s.len()`.\n- */\n-pub fn find_str_between<'a,'b>(haystack: &'a str,\n-                               needle: &'b str,\n-                               start: uint,\n-                               end:uint)\n-                            -> Option<uint> {\n-    // See Issue #1932 for why this is a naive search\n-    assert!(end <= haystack.len());\n-    let needle_len = needle.len();\n-    if needle_len == 0u { return Some(start); }\n-    if needle_len > end { return None; }\n-\n-    let mut i = start;\n-    let e = end - needle_len;\n-    while i <= e {\n-        if match_at(haystack, needle, i) { return Some(i); }\n-        i += 1u;\n-    }\n-    return None;\n-}\n \n /**\n  * Returns true if one string contains another\n@@ -1258,7 +1176,7 @@ pub fn find_str_between<'a,'b>(haystack: &'a str,\n  * * needle - The string to look for\n  */\n pub fn contains<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    find_str(haystack, needle).is_some()\n+    haystack.find_str(needle).is_some()\n }\n \n /**\n@@ -2096,6 +2014,7 @@ pub trait StrSlice<'self> {\n \n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n+    fn find_str(&self, &str) -> Option<uint>;\n }\n \n /// Extension methods for strings\n@@ -2341,6 +2260,28 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         None\n     }\n+\n+    /**\n+     * Returns the byte index of the first matching substring\n+     *\n+     * # Arguments\n+     *\n+     * * `needle` - The string to search for\n+     *\n+     * # Return value\n+     *\n+     * `Some` containing the byte index of the first matching substring\n+     * or `None` if there is no match\n+     */\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n+        if needle.is_empty() {\n+            Some(0)\n+        } else {\n+            self.matches_index_iter(needle)\n+                .next()\n+                .map_consume(|(start, _end)| start)\n+        }\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2550,43 +2491,31 @@ mod tests {\n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert!(find_str(\"banana\", \"apple pie\").is_none());\n-        assert_eq!(find_str(\"\", \"\"), Some(0u));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert_eq!(find_str(data, \"\"), Some(0u));\n-        assert_eq!(find_str(data, \"\u0e1b\u0e23\u0e30\u0e40\"), Some( 0u));\n-        assert_eq!(find_str(data, \"\u0e30\u0e40\"), Some( 6u));\n-        assert_eq!(find_str(data, \"\u4e2d\u534e\"), Some(27u));\n-        assert!(find_str(data, \"\u0e44\u0e17\u534e\").is_none());\n-    }\n-\n-    #[test]\n-    fn test_find_str_between() {\n-        // byte positions\n-        assert_eq!(find_str_between(\"\", \"\", 0u, 0u), Some(0u));\n+        assert_eq!(\"\".find_str(\"\"), Some(0u));\n+        assert!(\"banana\".find_str(\"apple pie\").is_none());\n \n         let data = \"abcabc\";\n-        assert_eq!(find_str_between(data, \"ab\", 0u, 6u), Some(0u));\n-        assert_eq!(find_str_between(data, \"ab\", 2u, 6u), Some(3u));\n-        assert!(find_str_between(data, \"ab\", 2u, 4u).is_none());\n+        assert_eq!(data.slice(0u, 6u).find_str(\"ab\"), Some(0u));\n+        assert_eq!(data.slice(2u, 6u).find_str(\"ab\"), Some(3u));\n+        assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        assert_eq!(find_str_between(data, \"\", 0u, 43u), Some(0u));\n-        assert_eq!(find_str_between(data, \"\", 6u, 43u), Some(6u));\n-\n-        assert_eq!(find_str_between(data, \"\u0e1b\u0e23\u0e30\", 0u, 43u), Some( 0u));\n-        assert_eq!(find_str_between(data, \"\u0e17\u0e28\u0e44\", 0u, 43u), Some(12u));\n-        assert_eq!(find_str_between(data, \"\u0e22\u4e2d\", 0u, 43u), Some(24u));\n-        assert_eq!(find_str_between(data, \"i\u1ec7t\", 0u, 43u), Some(34u));\n-        assert_eq!(find_str_between(data, \"Nam\", 0u, 43u), Some(40u));\n-\n-        assert_eq!(find_str_between(data, \"\u0e1b\u0e23\u0e30\", 43u, 86u), Some(43u));\n-        assert_eq!(find_str_between(data, \"\u0e17\u0e28\u0e44\", 43u, 86u), Some(55u));\n-        assert_eq!(find_str_between(data, \"\u0e22\u4e2d\", 43u, 86u), Some(67u));\n-        assert_eq!(find_str_between(data, \"i\u1ec7t\", 43u, 86u), Some(77u));\n-        assert_eq!(find_str_between(data, \"Nam\", 43u, 86u), Some(83u));\n+        assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\"), Some(0u));\n+        assert_eq!(data.slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n+\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n+\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n     }\n \n     #[test]"}, {"sha": "9ba9b9759fd1122ac43195276a7b27c485b8cb8e", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -197,7 +197,7 @@ fn main() {\n \n          // start processing if this is the one\n          ('>', false) => {\n-            match str::find_str_from(line, ~\"THREE\", 1u) {\n+            match line.slice_from(1).find_str(~\"THREE\") {\n                option::Some(_) => { proc_mode = true; }\n                option::None    => { }\n             }"}, {"sha": "f37f40935abe74ec82ea764952bd7a849f3d345f", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/017450a6111a430eca86caf4ee6021ed654b552f/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017450a6111a430eca86caf4ee6021ed654b552f/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=017450a6111a430eca86caf4ee6021ed654b552f", "patch": "@@ -12,7 +12,7 @@ use std::str;\n \n pub fn main() {\n     let thing = ~\"{{ f }}\";\n-    let f = str::find_str(thing, ~\"{{\");\n+    let f = thing.find_str(~\"{{\");\n \n     if f.is_none() {\n         println(~\"None!\");"}]}