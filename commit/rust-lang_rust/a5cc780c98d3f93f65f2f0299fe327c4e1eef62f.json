{"sha": "a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1Y2M3ODBjOThkM2Y5M2Y2NWYyZjAyOTlmZTMyN2M0ZTFlZWY2MmY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-03-24T22:24:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-24T22:24:57Z"}, "message": "Merge pull request #3468 from topecongiro/refactor-create_config\n\nMove some code out of create_config", "tree": {"sha": "2ea4272e671857a0a5ea2b155f775072f2ba2b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ea4272e671857a0a5ea2b155f775072f2ba2b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmAO5CRBK7hj4Ov3rIwAAdHIIAJkcL+SUZfKd59jR2SrI+WsW\nSVCEYyB9ly+GjHYZkXbwAYvMdwycnwipP3RVSbFjD4tQTsNTxj44mjGh/YSFVcfu\n52e9QbRMHsbDFSIT0R52J1hLfuzzg3beEXt75KzY90REHGOVDsDi+9FOIzlpSpM+\nSMvldEom7EsDPhNPjlG0U1GNIrxVGCavRazFq4R4ZPimfFUYwMQxiWg/LaVLlVcQ\nsjwC61fhWRFzm2bqojo97cY4MH2oBF7ndwKt5DkwmxpYnnvbpzVeLrX5unHXqgH3\nsVKWRCzrsMT6VvfFTWxIDhbl8gfIU7P8F4A7AK/xm1qiaWaMqCxOGReZepRbT2o=\n=zZQT\n-----END PGP SIGNATURE-----\n", "payload": "tree 2ea4272e671857a0a5ea2b155f775072f2ba2b8d\nparent 9b4344161b39d9463d95719018c4bf16243cf45f\nparent 0d67db47443591db1e678f3d54bd845fbc1e4d6f\nauthor Seiichi Uchida <seuchida@gmail.com> 1553466297 +0900\ncommitter GitHub <noreply@github.com> 1553466297 +0900\n\nMerge pull request #3468 from topecongiro/refactor-create_config\n\nMove some code out of create_config"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "html_url": "https://github.com/rust-lang/rust/commit/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b4344161b39d9463d95719018c4bf16243cf45f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4344161b39d9463d95719018c4bf16243cf45f", "html_url": "https://github.com/rust-lang/rust/commit/9b4344161b39d9463d95719018c4bf16243cf45f"}, {"sha": "0d67db47443591db1e678f3d54bd845fbc1e4d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d67db47443591db1e678f3d54bd845fbc1e4d6f", "html_url": "https://github.com/rust-lang/rust/commit/0d67db47443591db1e678f3d54bd845fbc1e4d6f"}], "stats": {"total": 273, "additions": 136, "deletions": 137}, "files": [{"sha": "14c2dcbb8db3279db911b26a8ad5a9ccc000578b", "filename": "src/config/config_type.rs", "status": "modified", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "patch": "@@ -93,19 +93,6 @@ macro_rules! create_config {\n             $(pub $i: Option<$ty>),+\n         }\n \n-        impl PartialConfig {\n-            pub fn to_toml(&self) -> Result<String, String> {\n-                // Non-user-facing options can't be specified in TOML\n-                let mut cloned = self.clone();\n-                cloned.file_lines = None;\n-                cloned.verbose = None;\n-                cloned.width_heuristics = None;\n-\n-                ::toml::to_string(&cloned)\n-                    .map_err(|e| format!(\"Could not output config: {}\", e))\n-            }\n-        }\n-\n         // Macro hygiene won't allow us to make `set_$i()` methods on Config\n         // for each item, so this struct is used to give the API to set values:\n         // `config.set().option(false)`. It's pretty ugly. Consider replacing\n@@ -139,23 +126,6 @@ macro_rules! create_config {\n         }\n \n         impl Config {\n-            pub(crate) fn version_meets_requirement(&self) -> bool {\n-                if self.was_set().required_version() {\n-                    let version = env!(\"CARGO_PKG_VERSION\");\n-                    let required_version = self.required_version();\n-                    if version != required_version {\n-                        println!(\n-                            \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n-                            version,\n-                            required_version,\n-                        );\n-                        return false;\n-                    }\n-                }\n-\n-                true\n-            }\n-\n             $(\n             pub fn $i(&self) -> $ty {\n                 self.$i.0.set(true);\n@@ -213,37 +183,6 @@ macro_rules! create_config {\n                 }\n             }\n \n-            pub(crate) fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n-                let parsed: ::toml::Value =\n-                    toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n-                let mut err: String = String::new();\n-                {\n-                    let table = parsed\n-                        .as_table()\n-                        .ok_or(String::from(\"Parsed config was not table\"))?;\n-                    for key in table.keys() {\n-                        if !Config::is_valid_name(key) {\n-                            let msg = &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n-                            err.push_str(msg)\n-                        }\n-                    }\n-                }\n-                match parsed.try_into() {\n-                    Ok(parsed_config) => {\n-                        if !err.is_empty() {\n-                            eprint!(\"{}\", err);\n-                        }\n-                        Ok(Config::default().fill_from_parsed_config(parsed_config, dir))\n-                    }\n-                    Err(e) => {\n-                        err.push_str(\"Error: Decoding config file failed:\\n\");\n-                        err.push_str(format!(\"{}\\n\", e).as_str());\n-                        err.push_str(\"Please check your config file.\");\n-                        Err(err)\n-                    }\n-                }\n-            }\n-\n             pub fn used_options(&self) -> PartialConfig {\n                 PartialConfig {\n                     $(\n@@ -287,82 +226,6 @@ macro_rules! create_config {\n                 }\n             }\n \n-            /// Constructs a `Config` from the toml file specified at `file_path`.\n-            ///\n-            /// This method only looks at the provided path, for a method that\n-            /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n-            ///\n-            /// Returns a `Config` if the config could be read and parsed from\n-            /// the file, otherwise errors.\n-            pub(super) fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n-                let mut file = File::open(&file_path)?;\n-                let mut toml = String::new();\n-                file.read_to_string(&mut toml)?;\n-                Config::from_toml(&toml, file_path.parent().unwrap())\n-                    .map_err(|err| Error::new(ErrorKind::InvalidData, err))\n-            }\n-\n-            /// Resolves the config for input in `dir`.\n-            ///\n-            /// Searches for `rustfmt.toml` beginning with `dir`, and\n-            /// recursively checking parents of `dir` if no config file is found.\n-            /// If no config file exists in `dir` or in any parent, a\n-            /// default `Config` will be returned (and the returned path will be empty).\n-            ///\n-            /// Returns the `Config` to use, and the path of the project file if there was\n-            /// one.\n-            pub(super) fn from_resolved_toml_path(\n-                dir: &Path,\n-            ) -> Result<(Config, Option<PathBuf>), Error> {\n-                /// Try to find a project file in the given directory and its parents.\n-                /// Returns the path of a the nearest project file if one exists,\n-                /// or `None` if no project file was found.\n-                fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n-                    let mut current = if dir.is_relative() {\n-                        env::current_dir()?.join(dir)\n-                    } else {\n-                        dir.to_path_buf()\n-                    };\n-\n-                    current = fs::canonicalize(current)?;\n-\n-                    loop {\n-                        match get_toml_path(&current) {\n-                            Ok(Some(path)) => return Ok(Some(path)),\n-                            Err(e) => return Err(e),\n-                            _ => ()\n-                        }\n-\n-                        // If the current directory has no parent, we're done searching.\n-                        if !current.pop() {\n-                            break;\n-                        }\n-                    }\n-\n-                    // If nothing was found, check in the home directory.\n-                    if let Some(home_dir) = dirs::home_dir() {\n-                        if let Some(path) = get_toml_path(&home_dir)? {\n-                            return Ok(Some(path));\n-                        }\n-                    }\n-\n-                    // If none was found ther either, check in the user's configuration directory.\n-                    if let Some(mut config_dir) = dirs::config_dir() {\n-                        config_dir.push(\"rustfmt\");\n-                        if let Some(path) = get_toml_path(&config_dir)? {\n-                            return Ok(Some(path));\n-                        }\n-                    }\n-\n-                    return Ok(None);\n-                }\n-\n-                match resolve_project_file(dir)? {\n-                    None => Ok((Config::default(), None)),\n-                    Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n-                }\n-            }\n-\n             pub fn is_hidden_option(name: &str) -> bool {\n                 const HIDE_OPTIONS: [&str; 4] =\n                     [\"verbose\", \"verbose_diff\", \"file_lines\", \"width_heuristics\"];"}, {"sha": "0790a3be2a6e47b62828354909eb84daee48a1fb", "filename": "src/config/mod.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "patch": "@@ -150,6 +150,142 @@ create_config! {\n     make_backup: bool, false, false, \"Backup changed files\";\n }\n \n+impl PartialConfig {\n+    pub fn to_toml(&self) -> Result<String, String> {\n+        // Non-user-facing options can't be specified in TOML\n+        let mut cloned = self.clone();\n+        cloned.file_lines = None;\n+        cloned.verbose = None;\n+        cloned.width_heuristics = None;\n+\n+        ::toml::to_string(&cloned).map_err(|e| format!(\"Could not output config: {}\", e))\n+    }\n+}\n+\n+impl Config {\n+    pub(crate) fn version_meets_requirement(&self) -> bool {\n+        if self.was_set().required_version() {\n+            let version = env!(\"CARGO_PKG_VERSION\");\n+            let required_version = self.required_version();\n+            if version != required_version {\n+                println!(\n+                    \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n+                    version, required_version,\n+                );\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    /// Constructs a `Config` from the toml file specified at `file_path`.\n+    ///\n+    /// This method only looks at the provided path, for a method that\n+    /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n+    ///\n+    /// Returns a `Config` if the config could be read and parsed from\n+    /// the file, otherwise errors.\n+    pub(super) fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+        let mut file = File::open(&file_path)?;\n+        let mut toml = String::new();\n+        file.read_to_string(&mut toml)?;\n+        Config::from_toml(&toml, file_path.parent().unwrap())\n+            .map_err(|err| Error::new(ErrorKind::InvalidData, err))\n+    }\n+\n+    /// Resolves the config for input in `dir`.\n+    ///\n+    /// Searches for `rustfmt.toml` beginning with `dir`, and\n+    /// recursively checking parents of `dir` if no config file is found.\n+    /// If no config file exists in `dir` or in any parent, a\n+    /// default `Config` will be returned (and the returned path will be empty).\n+    ///\n+    /// Returns the `Config` to use, and the path of the project file if there was\n+    /// one.\n+    pub(super) fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n+        /// Try to find a project file in the given directory and its parents.\n+        /// Returns the path of a the nearest project file if one exists,\n+        /// or `None` if no project file was found.\n+        fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+            let mut current = if dir.is_relative() {\n+                env::current_dir()?.join(dir)\n+            } else {\n+                dir.to_path_buf()\n+            };\n+\n+            current = fs::canonicalize(current)?;\n+\n+            loop {\n+                match get_toml_path(&current) {\n+                    Ok(Some(path)) => return Ok(Some(path)),\n+                    Err(e) => return Err(e),\n+                    _ => (),\n+                }\n+\n+                // If the current directory has no parent, we're done searching.\n+                if !current.pop() {\n+                    break;\n+                }\n+            }\n+\n+            // If nothing was found, check in the home directory.\n+            if let Some(home_dir) = dirs::home_dir() {\n+                if let Some(path) = get_toml_path(&home_dir)? {\n+                    return Ok(Some(path));\n+                }\n+            }\n+\n+            // If none was found ther either, check in the user's configuration directory.\n+            if let Some(mut config_dir) = dirs::config_dir() {\n+                config_dir.push(\"rustfmt\");\n+                if let Some(path) = get_toml_path(&config_dir)? {\n+                    return Ok(Some(path));\n+                }\n+            }\n+\n+            return Ok(None);\n+        }\n+\n+        match resolve_project_file(dir)? {\n+            None => Ok((Config::default(), None)),\n+            Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n+        }\n+    }\n+\n+    pub(crate) fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n+        let parsed: ::toml::Value = toml\n+            .parse()\n+            .map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n+        let mut err: String = String::new();\n+        {\n+            let table = parsed\n+                .as_table()\n+                .ok_or(String::from(\"Parsed config was not table\"))?;\n+            for key in table.keys() {\n+                if !Config::is_valid_name(key) {\n+                    let msg = &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n+                    err.push_str(msg)\n+                }\n+            }\n+        }\n+        match parsed.try_into() {\n+            Ok(parsed_config) => {\n+                if !err.is_empty() {\n+                    eprint!(\"{}\", err);\n+                }\n+                Ok(Config::default().fill_from_parsed_config(parsed_config, dir))\n+            }\n+            Err(e) => {\n+                err.push_str(\"Error: Decoding config file failed:\\n\");\n+                err.push_str(format!(\"{}\\n\", e).as_str());\n+                err.push_str(\"Please check your config file.\");\n+                Err(err)\n+            }\n+        }\n+    }\n+}\n+\n /// Loads a config by checking the client-supplied options and if appropriate, the\n /// file system (including searching the file system for overrides).\n pub fn load_config<O: CliOptions>("}]}