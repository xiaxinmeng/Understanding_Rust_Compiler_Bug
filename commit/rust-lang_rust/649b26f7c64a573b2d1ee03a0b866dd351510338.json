{"sha": "649b26f7c64a573b2d1ee03a0b866dd351510338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OWIyNmY3YzY0YTU3M2IyZDFlZTAzYTBiODY2ZGQzNTE1MTAzMzg=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-27T00:20:53Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-28T23:12:08Z"}, "message": "Rework vtable_res to not be flattened. It is now a list of the resolutions for each param.", "tree": {"sha": "132d46f96442dea7b5c3f833693aa46edc70d075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/132d46f96442dea7b5c3f833693aa46edc70d075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/649b26f7c64a573b2d1ee03a0b866dd351510338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/649b26f7c64a573b2d1ee03a0b866dd351510338", "html_url": "https://github.com/rust-lang/rust/commit/649b26f7c64a573b2d1ee03a0b866dd351510338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/649b26f7c64a573b2d1ee03a0b866dd351510338/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ee34c2bf66a26527959b0a1dc2b7e23638e67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ee34c2bf66a26527959b0a1dc2b7e23638e67b", "html_url": "https://github.com/rust-lang/rust/commit/57ee34c2bf66a26527959b0a1dc2b7e23638e67b"}], "stats": {"total": 166, "additions": 76, "deletions": 90}, "files": [{"sha": "16e3bd34cddeb173658a66b026b0c7762655cfd9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -599,8 +599,10 @@ fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |ebml_w, vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+    do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n+        do ebml_w.emit_from_vec(**param_tables) |ebml_w, vtable_origin| {\n+            encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+        }\n     }\n }\n \n@@ -653,7 +655,9 @@ trait vtable_decoder_helpers {\n impl vtable_decoder_helpers for reader::Decoder {\n     fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this| this.read_vtable_origin(xcx))\n+        @self.read_to_vec(|this|\n+           @this.read_to_vec(|this|\n+               this.read_vtable_origin(xcx)))\n     }\n \n     fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)"}, {"sha": "7032b559f76fc3df50c886afeeca401d0b1c24a7", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -17,6 +17,7 @@\n // closure.\n \n use core::prelude::*;\n+use core::vec;\n \n use back::abi;\n use driver::session;\n@@ -274,9 +275,7 @@ pub fn trans_fn_ref_with_vtables(\n             let receiver_vtables = match vtables {\n                 None => @~[],\n                 Some(call_vtables) => {\n-                    let num_method_vtables =\n-                        ty::count_traits_and_supertraits(tcx, *param_defs);\n-                    @call_vtables.initn(num_method_vtables).to_owned()\n+                    @call_vtables.initn(param_defs.len()).to_owned()\n                 }\n             };\n \n@@ -305,6 +304,27 @@ pub fn trans_fn_ref_with_vtables(\n         }\n     };\n \n+    // XXX: this is *completely* bad and wrong. I feel bad.  Handling\n+    // of vtables is currently bogus for default methods, and changing\n+    // to an unflattented representation of vtables causes this to\n+    // show up in cases that it did not previously. We need to make\n+    // the vtables list be the same length as the substs.  There is\n+    // nothing right about this. I really need to emphasize just how\n+    // wrong it is: it is completely wrong.\n+    // XXX: bad.\n+    // This will be fixed in the next commit.\n+    let vtables = do vtables.map |vtbls| {\n+        if vtbls.len() < substs.tps.len() {\n+            @(vec::from_elem(substs.tps.len() - vtbls.len(), @~[]) +\n+              **vtbls)\n+        } else if vtbls.len() > substs.tps.len() {\n+            @vtbls.tailn(vtbls.len() - substs.tps.len()).to_owned()\n+        } else {\n+            *vtbls\n+        }\n+    };\n+\n+\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {"}, {"sha": "b30510062389e8531f01ea97a4d9ec1efbd018b5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -1035,7 +1035,8 @@ pub fn node_vtables(bcx: block, id: ast::node_id)\n \n pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, copy *d))\n+    @vec::map(*vts, |ds|\n+      @vec::map(**ds, |d|  resolve_vtable_in_fn_ctxt(fcx, copy *d)))\n }\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n@@ -1090,13 +1091,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    // Vtables are stored in a flat array, finding the right one is\n-    // somewhat awkward\n-    let first_n_type_param_defs = ps.type_param_defs.slice(0, n_param);\n-    let vtables_to_skip =\n-        ty::count_traits_and_supertraits(tcx, first_n_type_param_defs);\n-    let vtable_off = vtables_to_skip + n_bound;\n-    /*bad*/ copy ps.vtables.get()[vtable_off]\n+    /*bad*/ copy ps.vtables.get()[n_param][n_bound]\n }\n \n pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "11ae094b799f07283845d3753f4b741ab388e63a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -292,15 +292,9 @@ pub fn trans_static_method_callee(bcx: block,\n     //\n     // So when we see a call to this function foo, we have to figure\n     // out which impl the `Trait<T1...Tn>` bound on the type `self` was\n-    // bound to.  Due to the fact that we use a flattened list of\n-    // impls, one per bound, this means we have to total up the bounds\n-    // found on the type parametesr T1...Tn to find the index of the\n-    // one we are interested in.\n-    let bound_index = {\n-        let trait_def = ty::lookup_trait_def(bcx.tcx(), trait_id);\n-        ty::count_traits_and_supertraits(\n-            bcx.tcx(), *trait_def.generics.type_param_defs)\n-    };\n+    // bound to.\n+    let bound_index = ty::lookup_trait_def(bcx.tcx(), trait_id).\n+        generics.type_param_defs.len();\n \n     let mname = if method_id.crate == ast::local_crate {\n         match bcx.tcx().items.get_copy(&method_id.node) {\n@@ -322,17 +316,17 @@ pub fn trans_static_method_callee(bcx: block,\n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n \n-    match vtbls[bound_index] {\n+    match vtbls[bound_index][0] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name_or_default(bcx.ccx(),\n                                                      impl_did,\n                                                      mname);\n-            let callee_substs = combine_impl_and_methods_tps(\n-                bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n-            let callee_origins = combine_impl_and_methods_origins(\n-                bcx, mth_id, impl_did, callee_id, rcvr_origins);\n+            let (callee_substs, callee_origins) =\n+                combine_impl_and_methods_tps(\n+                    bcx, mth_id, impl_did, callee_id,\n+                    *rcvr_substs, rcvr_origins);\n \n             let FnData {llfn: lval} =\n                 trans_fn_ref_with_vtables(bcx,\n@@ -428,10 +422,10 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n-          let callee_substs = combine_impl_and_methods_tps(\n-              bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n-          let callee_origins = combine_impl_and_methods_origins(\n-              bcx, mth_id, impl_did, callee_id, rcvr_origins);\n+          let (callee_substs, callee_origins) =\n+              combine_impl_and_methods_tps(\n+                  bcx, mth_id, impl_did, callee_id,\n+                  *rcvr_substs, rcvr_origins);\n \n           // translate the function\n           let callee = trans_fn_ref_with_vtables(bcx,\n@@ -471,8 +465,9 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n                                     mth_did: ast::def_id,\n                                     impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n-                                    rcvr_substs: &[ty::t])\n-                                    -> ~[ty::t] {\n+                                    rcvr_substs: &[ty::t],\n+                                    rcvr_origins: typeck::vtable_res)\n+                                    -> (~[ty::t], typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -501,52 +496,18 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n \n-    return ty_substs;\n-}\n-\n-pub fn combine_impl_and_methods_origins(bcx: block,\n-                                        mth_did: ast::def_id,\n-                                        impl_did: ast::def_id,\n-                                        callee_id: ast::node_id,\n-                                        rcvr_origins: typeck::vtable_res)\n-                                     -> typeck::vtable_res {\n-    /*!\n-     *\n-     * Similar to `combine_impl_and_methods_tps`, but for vtables.\n-     * This is much messier because of the flattened layout we are\n-     * currently using (for some reason that I fail to understand).\n-     * The proper fix is described in #3446.\n-     */\n-\n \n-    // Find the bounds for the method, which are the tail of the\n-    // bounds found in the item type, as the item type combines the\n-    // rcvr + method bounds.\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n-    let ty::ty_param_bounds_and_ty {\n-        generics: r_m_generics,\n-        _\n-    } = ty::lookup_item_type(tcx, mth_did);\n-    let n_r_m_tps = r_m_generics.type_param_defs.len(); // rcvr + method tps\n-    let m_type_param_defs =\n-        r_m_generics.type_param_defs.slice(n_r_m_tps - n_m_tps, n_r_m_tps);\n-\n-    // Flatten out to find the number of vtables the method expects.\n-    let m_vtables = ty::count_traits_and_supertraits(tcx, m_type_param_defs);\n-\n-    // Find the vtables we computed at type check time and monomorphize them\n+    // Now, do the same work for the vtables.  The vtables might not\n+    // exist, in which case we need to make them.\n     let r_m_origins = match node_vtables(bcx, callee_id) {\n         Some(vt) => vt,\n-        None => @~[]\n+        None => @vec::from_elem(node_substs.len(), @~[])\n     };\n+    let vtables\n+        = @vec::append(rcvr_origins.to_owned(),\n+                       r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n-    // Extract those that belong to method:\n-    let m_origins = r_m_origins.tailn(r_m_origins.len() - m_vtables);\n-\n-    // Combine rcvr + method to find the final result:\n-    @vec::append(/*bad*/copy *rcvr_origins, m_origins)\n+    return (ty_substs, vtables);\n }\n \n \n@@ -845,7 +806,7 @@ pub fn trans_trait_cast(bcx: block,\n     bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n \n     // Store the vtable into the pair or triple.\n-    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n+    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0][0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,"}, {"sha": "3011f0c5d844a7806c37c384b814f7c1d1a15c8f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -340,14 +340,10 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n-        let item_ty = ty::lookup_item_type(ccx.tcx, item);\n-        let mut i = 0;\n-        vec::map_zip(*item_ty.generics.type_param_defs, substs, |type_param_def, subst| {\n-            let mut v = ~[];\n-            for type_param_def.bounds.trait_bounds.iter().advance |_bound| {\n-                v.push(meth::vtable_id(ccx, &vts[i]));\n-                i += 1;\n-            }\n+        debug!(\"make_mono_id vtables=%s substs=%s\",\n+               vts.repr(ccx.tcx), substs.repr(ccx.tcx));\n+        vec::map_zip(*vts, substs, |vtable, subst| {\n+            let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         })\n       }"}, {"sha": "0bf20f9fbcb94a59d79a8534f49f9579e2fb0a62", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -90,6 +90,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let mut i = 0u;\n     for substs.tps.iter().advance |ty| {\n         // ty is the value supplied for the type parameter A...\n+        let mut param_result = ~[];\n \n         for ty::each_bound_trait_and_supertraits(\n             tcx, type_param_defs[i].bounds) |trait_ref|\n@@ -106,7 +107,7 @@ fn lookup_vtables(vcx: &VtableContext,\n             debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n             match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n-                Some(vtable) => result.push(vtable),\n+                Some(vtable) => param_result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n@@ -117,6 +118,7 @@ fn lookup_vtables(vcx: &VtableContext,\n                 }\n             }\n         }\n+        result.push(@param_result);\n         i += 1u;\n     }\n     debug!(\"lookup_vtables result(\\\n@@ -600,7 +602,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                   // vtable (that is: \"ex has vtable\n                                   // <vtable>\")\n                                   if !is_early {\n-                                      insert_vtables(fcx, ex.id, @~[vtable]);\n+                                      insert_vtables(fcx, ex.id,\n+                                                     @~[@~[vtable]]);\n                                   }\n                               }\n                               None => {"}, {"sha": "e2efdc51fcad4bacbc57a0d55f10d5284c9a39ff", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -20,7 +20,8 @@ use middle::typeck::check::{FnCtxt, SelfInfo};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use middle::typeck::{vtable_origin, vtable_static, vtable_param, vtable_self};\n+use middle::typeck::{vtable_res, vtable_origin};\n+use middle::typeck::{vtable_static, vtable_param, vtable_self};\n use middle::typeck::method_map_entry;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n@@ -84,21 +85,26 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     match fcx.inh.vtable_map.find(&id) {\n         None => {}\n         Some(origins) => {\n-            let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+            let r_origins = resolve_origins(fcx, sp, *origins);\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(id=%d, vtables=%?)\",\n                    id, r_origins.repr(fcx.tcx()));\n         }\n     }\n \n+    fn resolve_origins(fcx: @mut FnCtxt, sp: span,\n+                       vtbls: vtable_res) -> vtable_res {\n+        @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n+    }\n+\n     fn resolve_origin(fcx: @mut FnCtxt,\n                       sp: span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n             &vtable_static(def_id, ref tys, origins) => {\n                 let r_tys = resolve_type_vars_in_types(fcx, sp, *tys);\n-                let r_origins = @origins.map(|o| resolve_origin(fcx, sp, o));\n+                let r_origins = resolve_origins(fcx, sp, origins);\n                 vtable_static(def_id, r_tys, r_origins)\n             }\n             &vtable_param(n, b) => {"}, {"sha": "98f7af4bfd4de53a9de6028b2aa8a1498fa403a7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649b26f7c64a573b2d1ee03a0b866dd351510338/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=649b26f7c64a573b2d1ee03a0b866dd351510338", "patch": "@@ -135,8 +135,9 @@ pub struct method_map_entry {\n // of the method to be invoked\n pub type method_map = @mut HashMap<ast::node_id, method_map_entry>;\n \n+pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @~[vtable_origin];\n+pub type vtable_res = @~[vtable_param_res];\n \n pub enum vtable_origin {\n     /*"}]}