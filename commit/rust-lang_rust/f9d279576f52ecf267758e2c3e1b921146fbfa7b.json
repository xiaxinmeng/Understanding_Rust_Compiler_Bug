{"sha": "f9d279576f52ecf267758e2c3e1b921146fbfa7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZDI3OTU3NmY1MmVjZjI2Nzc1OGUyYzNlMWI5MjExNDZmYmZhN2I=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-18T14:15:56Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-18T14:15:56Z"}, "message": "Use write_list() for rewriting match arms", "tree": {"sha": "1d9dc7cfe27c3139893a05168f74115561640024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d9dc7cfe27c3139893a05168f74115561640024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9d279576f52ecf267758e2c3e1b921146fbfa7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d279576f52ecf267758e2c3e1b921146fbfa7b", "html_url": "https://github.com/rust-lang/rust/commit/f9d279576f52ecf267758e2c3e1b921146fbfa7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9d279576f52ecf267758e2c3e1b921146fbfa7b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c166004e6da83e4c90459bf96e95574c065ee306", "url": "https://api.github.com/repos/rust-lang/rust/commits/c166004e6da83e4c90459bf96e95574c065ee306", "html_url": "https://github.com/rust-lang/rust/commit/c166004e6da83e4c90459bf96e95574c065ee306"}], "stats": {"total": 278, "additions": 142, "deletions": 136}, "files": [{"sha": "7953c344b40c029341a94caaa49e9f33b763dba2", "filename": "src/expr.rs", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/f9d279576f52ecf267758e2c3e1b921146fbfa7b/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d279576f52ecf267758e2c3e1b921146fbfa7b/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=f9d279576f52ecf267758e2c3e1b921146fbfa7b", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp::{min, Ordering};\n use std::fmt::Write;\n-use std::iter::ExactSizeIterator;\n+use std::iter::{repeat, ExactSizeIterator};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, CodeMap, Span};\n@@ -1425,44 +1425,24 @@ fn is_unsafe_block(block: &ast::Block) -> bool {\n     }\n }\n \n-// inter-match-arm-comment-rules:\n-//  - all comments following a match arm before the start of the next arm\n-//    are about the second arm\n-fn rewrite_match_arm_comment(\n-    context: &RewriteContext,\n-    missed_str: &str,\n-    shape: Shape,\n-    arm_indent_str: &str,\n-) -> Option<String> {\n-    // The leading \",\" is not part of the arm-comment\n-    let missed_str = match missed_str.find_uncommented(\",\") {\n-        Some(n) => &missed_str[n + 1..],\n-        None => &missed_str[..],\n-    };\n-\n-    let mut result = String::new();\n-    // any text not preceeded by a newline is pushed unmodified to the block\n-    let first_brk = missed_str.find(|c: char| c == '\\n').unwrap_or(0);\n-    result.push_str(&missed_str[..first_brk]);\n-    let missed_str = &missed_str[first_brk..]; // If missed_str had one newline, it starts with it\n+// A simple wrapper type against ast::Arm. Used inside write_list().\n+struct ArmWrapper<'a> {\n+    pub arm: &'a ast::Arm,\n+    // True if the arm is the last one in match expression. Used to decide on whether we should add\n+    // trailing comma to the match arm when `config.trailing_comma() == Never`.\n+    pub is_last: bool,\n+}\n \n-    let first = missed_str\n-        .find(|c: char| !c.is_whitespace())\n-        .unwrap_or(missed_str.len());\n-    if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n-        // Excessive vertical whitespace before comment should be preserved\n-        // FIXME handle vertical whitespace better\n-        result.push('\\n');\n-    }\n-    let missed_str = missed_str[first..].trim();\n-    if !missed_str.is_empty() {\n-        let comment = try_opt!(rewrite_comment(&missed_str, false, shape, context.config));\n-        result.push('\\n');\n-        result.push_str(arm_indent_str);\n-        result.push_str(&comment);\n+impl<'a> ArmWrapper<'a> {\n+    pub fn new(arm: &'a ast::Arm, is_last: bool) -> ArmWrapper<'a> {\n+        ArmWrapper { arm, is_last }\n     }\n+}\n \n-    Some(result)\n+impl<'a> Rewrite for ArmWrapper<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_match_arm(context, self.arm, shape, self.is_last)\n+    }\n }\n \n fn rewrite_match(\n@@ -1511,7 +1491,7 @@ fn rewrite_match(\n         try_opt!(\n             inner_attrs\n                 .rewrite(context, shape)\n-                .map(|s| format!(\"\\n{}{}\", nested_indent_str, s))\n+                .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))\n         )\n     };\n \n@@ -1523,11 +1503,18 @@ fn rewrite_match(\n         inner_attrs[inner_attrs.len() - 1].span().hi\n     };\n \n+    let arm_indent_str = if context.config.indent_match_arms() {\n+        nested_indent_str\n+    } else {\n+        shape.indent.to_string(context.config)\n+    };\n+\n     Some(format!(\n-        \"match {}{}{{{}{}\\n{}}}\",\n+        \"match {}{}{{\\n{}{}{}\\n{}}}\",\n         cond_str,\n         block_sep,\n         inner_attrs_str,\n+        arm_indent_str,\n         try_opt!(rewrite_match_arms(\n             context,\n             arms,\n@@ -1539,8 +1526,10 @@ fn rewrite_match(\n     ))\n }\n \n-fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma() {\n+fn arm_comma(config: &Config, body: &ast::Expr, is_last: bool) -> &'static str {\n+    if is_last && config.trailing_comma() == SeparatorTactic::Never {\n+        \"\"\n+    } else if config.match_block_trailing_comma() {\n         \",\"\n     } else if let ast::ExprKind::Block(ref block) = body.node {\n         if let ast::BlockCheckMode::Default = block.rules {\n@@ -1560,84 +1549,87 @@ fn rewrite_match_arms(\n     span: Span,\n     open_brace_pos: BytePos,\n ) -> Option<String> {\n-    let mut result = String::new();\n-\n     let arm_shape = if context.config.indent_match_arms() {\n         shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n     }.with_max_width(context.config);\n-    let arm_indent_str = arm_shape.indent.to_string(context.config);\n-\n-    let arm_num = arms.len();\n-    for (i, arm) in arms.iter().enumerate() {\n-        // Make sure we get the stuff between arms.\n-        let missed_str = if i == 0 {\n-            context.snippet(mk_sp(open_brace_pos, arm.span().lo))\n-        } else {\n-            context.snippet(mk_sp(arms[i - 1].span().hi, arm.span().lo))\n-        };\n-        let comment = try_opt!(rewrite_match_arm_comment(\n-            context,\n-            &missed_str,\n-            arm_shape,\n-            &arm_indent_str,\n-        ));\n-        if !comment.chars().all(|c| c == ' ') {\n-            result.push_str(&comment);\n-        }\n-        result.push('\\n');\n-        result.push_str(&arm_indent_str);\n \n-        let arm_str = rewrite_match_arm(context, arm, arm_shape);\n-        if let Some(ref arm_str) = arm_str {\n-            // Trim the trailing comma if necessary.\n-            if i == arm_num - 1 && context.config.trailing_comma() == SeparatorTactic::Never &&\n-                arm_str.ends_with(',')\n-            {\n-                result.push_str(&arm_str[0..arm_str.len() - 1])\n-            } else {\n-                result.push_str(arm_str)\n-            }\n-        } else {\n-            // We couldn't format the arm, just reproduce the source.\n-            let snippet = context.snippet(arm.span());\n-            result.push_str(&snippet);\n-            if context.config.trailing_comma() != SeparatorTactic::Never {\n-                result.push_str(arm_comma(context.config, &arm.body))\n-            }\n-        }\n-    }\n-    // BytePos(1) = closing match brace.\n-    let last_span = mk_sp(arms[arms.len() - 1].span().hi, span.hi - BytePos(1));\n-    let last_comment = context.snippet(last_span);\n-    let comment = try_opt!(rewrite_match_arm_comment(\n-        context,\n-        &last_comment,\n-        arm_shape,\n-        &arm_indent_str,\n-    ));\n-    result.push_str(&comment);\n+    let arm_len = arms.len();\n+    let is_last_iter = repeat(false)\n+        .take(arm_len.checked_sub(1).unwrap_or(0))\n+        .chain(repeat(true));\n+    let items = itemize_list(\n+        context.codemap,\n+        arms.iter()\n+            .zip(is_last_iter)\n+            .map(|(arm, is_last)| ArmWrapper::new(arm, is_last)),\n+        \"}\",\n+        |arm| arm.arm.span().lo,\n+        |arm| arm.arm.span().hi,\n+        |arm| arm.rewrite(context, arm_shape),\n+        open_brace_pos,\n+        span.hi,\n+        false,\n+    );\n+    let arms_vec: Vec<_> = items.collect();\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        // We will add/remove commas inside `arm.rewrite()`, and hence no separator here.\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        shape: arm_shape,\n+        ends_with_newline: true,\n+        preserve_newline: true,\n+        config: context.config,\n+    };\n \n-    Some(result)\n+    write_list(&arms_vec, &fmt)\n }\n \n-fn rewrite_match_arm(context: &RewriteContext, arm: &ast::Arm, shape: Shape) -> Option<String> {\n-    let attr_str = if !arm.attrs.is_empty() {\n+fn rewrite_match_arm(\n+    context: &RewriteContext,\n+    arm: &ast::Arm,\n+    shape: Shape,\n+    is_last: bool,\n+) -> Option<String> {\n+    let (missing_span, attrs_str) = if !arm.attrs.is_empty() {\n         if contains_skip(&arm.attrs) {\n-            return None;\n+            let (_, body) = flatten_arm_body(context, &arm.body);\n+            // `arm.span()` does not include trailing comma, add it manually.\n+            return Some(format!(\n+                \"{}{}\",\n+                context.snippet(arm.span()),\n+                arm_comma(context.config, body, is_last),\n+            ));\n         }\n-        format!(\n-            \"{}\\n{}\",\n+        (\n+            mk_sp(arm.attrs[arm.attrs.len() - 1].span.hi, arm.pats[0].span.lo),\n             try_opt!(arm.attrs.rewrite(context, shape)),\n-            shape.indent.to_string(context.config)\n         )\n     } else {\n-        String::new()\n+        (mk_sp(arm.span().lo, arm.span().lo), String::new())\n     };\n-    let pats_str = try_opt!(rewrite_match_pattern(context, &arm.pats, &arm.guard, shape));\n-    let pats_str = attr_str + &pats_str;\n-    rewrite_match_body(context, &arm.body, &pats_str, shape, arm.guard.is_some())\n+    let pats_str = try_opt!(\n+        rewrite_match_pattern(context, &arm.pats, &arm.guard, shape).and_then(|pats_str| {\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &pats_str,\n+                missing_span,\n+                shape,\n+                false,\n+            )\n+        })\n+    );\n+    rewrite_match_body(\n+        context,\n+        &arm.body,\n+        &pats_str,\n+        shape,\n+        arm.guard.is_some(),\n+        is_last,\n+    )\n }\n \n fn rewrite_match_pattern(\n@@ -1685,27 +1677,35 @@ fn rewrite_match_pattern(\n     Some(format!(\"{}{}\", pats_str, guard_str))\n }\n \n-fn rewrite_match_body(\n-    context: &RewriteContext,\n-    body: &ptr::P<ast::Expr>,\n-    pats_str: &str,\n-    shape: Shape,\n-    has_guard: bool,\n-) -> Option<String> {\n-    let (extend, body) = match body.node {\n+// (extend, body)\n+// @extend: true if the arm body can be put next to `=>`\n+// @body: flattened body, if the body is block with a single expression\n+fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bool, &'a ast::Expr) {\n+    match body.node {\n         ast::ExprKind::Block(ref block)\n             if !is_unsafe_block(block) && is_simple_block(block, context.codemap) =>\n         {\n             if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                 (expr.can_be_overflowed(context, 1), &**expr)\n             } else {\n-                (false, &**body)\n+                (false, &*body)\n             }\n         }\n-        _ => (body.can_be_overflowed(context, 1), &**body),\n-    };\n+        _ => (body.can_be_overflowed(context, 1), &*body),\n+    }\n+}\n+\n+fn rewrite_match_body(\n+    context: &RewriteContext,\n+    body: &ptr::P<ast::Expr>,\n+    pats_str: &str,\n+    shape: Shape,\n+    has_guard: bool,\n+    is_last: bool,\n+) -> Option<String> {\n+    let (extend, body) = flatten_arm_body(context, &body);\n \n-    let comma = arm_comma(&context.config, body);\n+    let comma = arm_comma(&context.config, body, is_last);\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let alt_block_sep = alt_block_sep.as_str();\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {"}, {"sha": "3fd9b1ab93cc28f027d83ef753f261900453a7c8", "filename": "src/lists.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f9d279576f52ecf267758e2c3e1b921146fbfa7b/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d279576f52ecf267758e2c3e1b921146fbfa7b/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=f9d279576f52ecf267758e2c3e1b921146fbfa7b", "patch": "@@ -380,8 +380,9 @@ where\n                 for _ in 0..(comment_alignment + 1) {\n                     result.push(' ');\n                 }\n-                // An additional space for the missing trailing comma\n-                if last && item_max_width.is_some() && !separate {\n+                // An additional space for the missing trailing separator.\n+                if last && item_max_width.is_some() && !separate && !formatting.separator.is_empty()\n+                {\n                     result.push(' ');\n                 }\n             }\n@@ -525,25 +526,30 @@ where\n                         }\n                     }\n                     let newline_index = post_snippet.find('\\n');\n-                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                    match (block_open_index, newline_index) {\n-                        // Separator before comment, with the next item on same line.\n-                        // Comment belongs to next item.\n-                        (Some(i), None) if i > separator_index => separator_index + 1,\n-                        // Block-style post-comment before the separator.\n-                        (Some(i), None) => cmp::max(\n-                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                            separator_index + 1,\n-                        ),\n-                        // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => cmp::max(\n-                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                            separator_index + 1,\n-                        ),\n-                        // Potential *single* line comment.\n-                        (_, Some(j)) if j > separator_index => j + 1,\n-                        _ => post_snippet.len(),\n+                    if let Some(separator_index) = post_snippet.find_uncommented(\",\") {\n+                        match (block_open_index, newline_index) {\n+                            // Separator before comment, with the next item on same line.\n+                            // Comment belongs to next item.\n+                            (Some(i), None) if i > separator_index => separator_index + 1,\n+                            // Block-style post-comment before the separator.\n+                            (Some(i), None) => cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            ),\n+                            // Block-style post-comment. Either before or after the separator.\n+                            (Some(i), Some(j)) if i < j => cmp::max(\n+                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                separator_index + 1,\n+                            ),\n+                            // Potential *single* line comment.\n+                            (_, Some(j)) if j > separator_index => j + 1,\n+                            _ => post_snippet.len(),\n+                        }\n+                    } else {\n+                        // Match arms may not have trailing comma. In any case, for match arms,\n+                        // we will assume that the post comment belongs to the next arm if they\n+                        // do not end with trailing comma.\n+                        1\n                     }\n                 }\n                 None => post_snippet"}]}