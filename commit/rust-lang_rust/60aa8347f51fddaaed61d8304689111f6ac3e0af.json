{"sha": "60aa8347f51fddaaed61d8304689111f6ac3e0af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYWE4MzQ3ZjUxZmRkYWFlZDYxZDgzMDQ2ODkxMTFmNmFjM2UwYWY=", "commit": {"author": {"name": "John-John Tedro", "email": "udoprog@tedro.se", "date": "2017-11-25T20:14:37Z"}, "committer": {"name": "John-John Tedro", "email": "udoprog@tedro.se", "date": "2017-11-25T20:28:49Z"}, "message": "Implement LinkedList::drain_filter\n\nRelates to rust-lang/rfcs#2140 - drain_filter for all collections\n\n`drain_filter` is implemented instead of `LinkedList::remove_if` based\non review feedback.", "tree": {"sha": "a11ec0a871e36cbd728c82cdcbc69ec838cf3cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a11ec0a871e36cbd728c82cdcbc69ec838cf3cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60aa8347f51fddaaed61d8304689111f6ac3e0af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60aa8347f51fddaaed61d8304689111f6ac3e0af", "html_url": "https://github.com/rust-lang/rust/commit/60aa8347f51fddaaed61d8304689111f6ac3e0af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60aa8347f51fddaaed61d8304689111f6ac3e0af/comments", "author": {"login": "udoprog", "id": 111092, "node_id": "MDQ6VXNlcjExMTA5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/111092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/udoprog", "html_url": "https://github.com/udoprog", "followers_url": "https://api.github.com/users/udoprog/followers", "following_url": "https://api.github.com/users/udoprog/following{/other_user}", "gists_url": "https://api.github.com/users/udoprog/gists{/gist_id}", "starred_url": "https://api.github.com/users/udoprog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/udoprog/subscriptions", "organizations_url": "https://api.github.com/users/udoprog/orgs", "repos_url": "https://api.github.com/users/udoprog/repos", "events_url": "https://api.github.com/users/udoprog/events{/privacy}", "received_events_url": "https://api.github.com/users/udoprog/received_events", "type": "User", "site_admin": false}, "committer": {"login": "udoprog", "id": 111092, "node_id": "MDQ6VXNlcjExMTA5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/111092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/udoprog", "html_url": "https://github.com/udoprog", "followers_url": "https://api.github.com/users/udoprog/followers", "following_url": "https://api.github.com/users/udoprog/following{/other_user}", "gists_url": "https://api.github.com/users/udoprog/gists{/gist_id}", "starred_url": "https://api.github.com/users/udoprog/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/udoprog/subscriptions", "organizations_url": "https://api.github.com/users/udoprog/orgs", "repos_url": "https://api.github.com/users/udoprog/repos", "events_url": "https://api.github.com/users/udoprog/events{/privacy}", "received_events_url": "https://api.github.com/users/udoprog/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de41d84ddfda90c9cc439ca12fce455fe2f7aaf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/de41d84ddfda90c9cc439ca12fce455fe2f7aaf1", "html_url": "https://github.com/rust-lang/rust/commit/de41d84ddfda90c9cc439ca12fce455fe2f7aaf1"}], "stats": {"total": 318, "additions": 283, "deletions": 35}, "files": [{"sha": "7bd1e1f0504476f15e236fb808eca6d1a67d1bc2", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 95, "deletions": 35, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/60aa8347f51fddaaed61d8304689111f6ac3e0af/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60aa8347f51fddaaed61d8304689111f6ac3e0af/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=60aa8347f51fddaaed61d8304689111f6ac3e0af", "patch": "@@ -744,48 +744,47 @@ impl<T> LinkedList<T> {\n         second_part\n     }\n \n-    /// Removes any element matching the given predicate. Returns the elements which were removed\n-    /// in a new list.\n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// If the closure returns true, then the element is removed and yielded.\n+    /// If the closure returns false, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n     ///\n     /// # Examples\n     ///\n-    /// ```\n-    /// #![feature(linked_list_remove_if)]\n+    /// Splitting a list into evens and odds, reusing the original list:\n     ///\n+    /// ```\n+    /// #![feature(drain_filter)]\n     /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = LinkedList::new();\n-    /// d.push_back(1);\n-    /// d.push_back(2);\n-    /// d.push_back(3);\n-    /// assert_eq!(d.remove_if(|v| *v < 3).len(), 2);\n-    /// assert_eq!(d.len(), 1);\n+    /// let mut numbers: LinkedList<u32> = LinkedList::new();\n+    /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n+    ///\n+    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n+    /// let odds = numbers;\n+    ///\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n-    #[unstable(feature = \"linked_list_remove_if\",\n-               reason = \"experimental method\",\n-               issue = \"0\")]\n-    pub fn remove_if<P>(&mut self, predicate: P) -> LinkedList<T>\n-        where P: Fn(&T) -> bool\n+    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+        where F: FnMut(&mut T) -> bool\n     {\n-        let mut deleted = LinkedList::new();\n-\n-        let mut it = self.head;\n-\n-        while let Some(node) = it {\n-            unsafe {\n-                it = node.as_ref().next;\n+        // avoid borrow issues.\n+        let it = self.head;\n+        let old_len = self.len;\n \n-                if predicate(&node.as_ref().element) {\n-                    self.unlink_node(node);\n-                    // move the unlinked node into the deleted list.\n-                    deleted.push_back_node(Box::from_raw(node.as_ptr()));\n-                }\n-            }\n+        DrainFilter {\n+            list: self,\n+            it: it,\n+            pred: filter,\n+            idx: 0,\n+            old_len: old_len,\n         }\n-\n-        deleted\n     }\n \n     /// Returns a place for insertion at the front of the list.\n@@ -1033,6 +1032,56 @@ impl<'a, T> IterMut<'a, T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on LinkedList.\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub struct DrainFilter<'a, T: 'a, F: 'a>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    list: &'a mut LinkedList<T>,\n+    it: Option<Shared<Node<T>>>,\n+    pred: F,\n+    idx: usize,\n+    old_len: usize,\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        while let Some(mut node) = self.it {\n+            unsafe {\n+                self.it = node.as_ref().next;\n+                self.idx += 1;\n+\n+                if (self.pred)(&mut node.as_mut().element) {\n+                    self.list.unlink_node(node);\n+                    return Some(Box::from_raw(node.as_ptr()).element);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n+    where F: FnMut(&mut T) -> bool\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\")\n+         .field(&self.list)\n+         .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n@@ -1570,15 +1619,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn remove_if_test() {\n+    fn drain_filter_test() {\n         let mut m: LinkedList<u32> = LinkedList::new();\n         m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.remove_if(|v| *v < 4);\n+        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n \n         check_links(&m);\n-        check_links(&deleted);\n \n-        assert_eq!(deleted.into_iter().collect::<Vec<_>>(), &[1, 2, 3]);\n+        assert_eq!(deleted, &[1, 2, 3]);\n         assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n     }\n+\n+    #[test]\n+    fn drain_to_empty_test() {\n+        let mut m: LinkedList<u32> = LinkedList::new();\n+        m.extend(&[1, 2, 3, 4, 5, 6]);\n+        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+        check_links(&m);\n+\n+        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    }\n }"}, {"sha": "4e3e855105eb8523f970e3019c508a0e4fdf8c22", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/60aa8347f51fddaaed61d8304689111f6ac3e0af/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60aa8347f51fddaaed61d8304689111f6ac3e0af/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=60aa8347f51fddaaed61d8304689111f6ac3e0af", "patch": "@@ -366,3 +366,191 @@ fn test_contains() {\n \n     assert!(!l.contains(&3));\n }\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = vec![(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+\n+    {   //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            1,\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x++]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36,\n+            37, 39\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {   // [xxx++++++xxxxx++++x+x]\n+        let mut list = vec![\n+            2, 4, 6,\n+            7, 9, 11, 13, 15, 17,\n+            18, 20, 22, 24, 26,\n+            27, 29, 31, 33,\n+            34,\n+            35,\n+            36\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {   // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {   // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![\n+            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n+            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n+        ].into_iter().collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}"}]}