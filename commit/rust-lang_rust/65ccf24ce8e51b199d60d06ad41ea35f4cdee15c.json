{"sha": "65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Y2NmMjRjZThlNTFiMTk5ZDYwZDA2YWQ0MWVhMzVmNGNkZWUxNWM=", "commit": {"author": {"name": "Agustin Chiappe Berrini", "email": "jnieve@gmail.com", "date": "2017-12-06T09:28:01Z"}, "committer": {"name": "Agustin Chiappe Berrini", "email": "jnieve@gmail.com", "date": "2017-12-06T09:28:01Z"}, "message": "and refactor to just move the checking", "tree": {"sha": "733ff2b5a3998cc91517bb2aa1fae3ea5f42ad7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/733ff2b5a3998cc91517bb2aa1fae3ea5f42ad7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "html_url": "https://github.com/rust-lang/rust/commit/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/comments", "author": null, "committer": null, "parents": [{"sha": "a2899408dd162bfe349e7ff8bceaee60b34e77cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2899408dd162bfe349e7ff8bceaee60b34e77cc", "html_url": "https://github.com/rust-lang/rust/commit/a2899408dd162bfe349e7ff8bceaee60b34e77cc"}], "stats": {"total": 139, "additions": 100, "deletions": 39}, "files": [{"sha": "8f21028c4bdbb6cff16cf05b0ca993f948f8073a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -21,7 +21,6 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n@@ -35,8 +34,16 @@ impl<'a> AstValidator<'a> {\n         &self.session.parse_sess.span_diagnostic\n     }\n \n+    fn check_lifetime(&self, lifetime: &Lifetime) {\n+        if !lifetime.ident.without_first_quote().is_valid() &&\n+            !lifetime.ident.name.is_static_keyword() {\n+            self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n+        }\n+    }\n+\n     fn check_label(&self, label: Ident, span: Span) {\n-        if label.name == keywords::StaticLifetime.name() || label.name == \"'_\" {\n+        if label.name.is_static_keyword() || !label.without_first_quote().is_valid()\n+            || label.name == \"'_\" {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n     }\n@@ -202,19 +209,21 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n-            ItemKind::Impl(.., Some(..), _, ref impl_items) => {\n+            ItemKind::Impl(.., ref generics, Some(..), _, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n                     }\n                 }\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n-            ItemKind::Impl(.., None, _, _) => {\n+            ItemKind::Impl(.., ref generics, None, _, _) => {\n                 self.invalid_visibility(&item.vis,\n                                         item.span,\n                                         Some(\"place qualifiers on individual impl items instead\"));\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::AutoImpl(..) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n@@ -225,13 +234,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                         Some(\"place qualifiers on individual foreign items \\\n                                               instead\"));\n             }\n-            ItemKind::Enum(ref def, _) => {\n+            ItemKind::Enum(ref def, ref generics) => {\n                 for variant in &def.variants {\n                     self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n                         self.invalid_visibility(&field.vis, field.span, None);\n                     }\n                 }\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::Trait(is_auto, _, ref generics, ref bounds, ref trait_items) => {\n                 if is_auto == IsAuto::Yes {\n@@ -268,6 +278,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         }\n                     }\n                 }\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n@@ -278,7 +289,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.session.buffer_lint(lint, item.id, item.span, msg);\n                 }\n             }\n-            ItemKind::Union(ref vdata, _) => {\n+            ItemKind::Union(ref vdata, ref generics) => {\n                 if !vdata.is_struct() {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n@@ -287,6 +298,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span,\n                                                 \"unions cannot have zero fields\");\n                 }\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n+            }\n+            ItemKind::Fn(.., ref generics, _) |\n+            ItemKind::Ty(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) => {\n+                generics.lifetimes.iter().for_each(|l| self.check_lifetime(&l.lifetime))\n             }\n             _ => {}\n         }"}, {"sha": "5de5e1fd5deb703de900ef213a352191d36154a1", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -14,7 +14,7 @@ use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n-use symbol::{Symbol, keywords};\n+use symbol::{Symbol};\n use std_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -1296,18 +1296,6 @@ impl<'a> StringReader<'a> {\n                         self.mk_ident(&format!(\"'{}\", lifetime_name))\n                     });\n \n-                    // Conjure up a \"keyword checking ident\" to make sure that\n-                    // the lifetime name is not a keyword.\n-                    let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n-                        self.mk_ident(lifetime_name)\n-                    });\n-                    let keyword_checking_token = &token::Ident(keyword_checking_ident);\n-                    let last_bpos = self.pos;\n-                    if keyword_checking_token.is_reserved_ident() &&\n-                       !keyword_checking_token.is_keyword(keywords::Static) {\n-                        self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n-                    }\n-\n                     return Ok(token::Lifetime(ident));\n                 }\n "}, {"sha": "94b279d2bdc3565c1d2da17d79ba54cb37b98a95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -364,18 +364,12 @@ impl Token {\n \n     /// Returns `true` if the token is a keyword used in the language.\n     pub fn is_used_keyword(&self) -> bool {\n-        match self.ident() {\n-            Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n-            _ => false,\n-        }\n+        self.ident().map(|id| id.name.is_used_keyword()).unwrap_or(false)\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_unused_keyword(&self) -> bool {\n-        match self.ident() {\n-            Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n-            _ => false,\n-        }\n+        self.ident().map(|id| id.name.is_unused_keyword()).unwrap_or(false)\n     }\n \n     pub fn glue(self, joint: Token) -> Option<Token> {"}, {"sha": "c904e93e63ad7c68e6c45ec0e87402bc7d16f9bc", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -35,9 +35,17 @@ impl Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n+    pub fn without_first_quote(&self) -> Ident {\n+        Ident { name: self.name.without_first_quote(), ctxt: self.ctxt }\n+    }\n+\n     pub fn modern(self) -> Ident {\n         Ident { name: self.name, ctxt: self.ctxt.modern() }\n     }\n+\n+    pub fn is_valid(&self) -> bool {\n+        !self.name.is_used_keyword() && !self.name.is_unused_keyword()\n+    }\n }\n \n impl fmt::Debug for Ident {\n@@ -113,6 +121,24 @@ impl Symbol {\n     pub fn as_u32(self) -> u32 {\n         self.0\n     }\n+\n+    /// Returns `true` if the token is a keyword used in the language.\n+    pub fn is_used_keyword(&self) -> bool {\n+        self >= &keywords::As.name() && self <= &keywords::While.name()\n+    }\n+\n+    /// Returns `true` if the token is a keyword reserved for possible future use.\n+    pub fn is_unused_keyword(&self) -> bool {\n+        self >= &keywords::Abstract.name() && self <= &keywords::Yield.name()\n+    }\n+\n+    pub fn is_static_keyword(&self) -> bool {\n+        self == &keywords::StaticLifetime.name()\n+    }\n+\n+    pub fn without_first_quote(&self) -> Symbol {\n+        Symbol::from(self.as_str().trim_left_matches('\\''))\n+    }\n }\n \n impl<'a> From<&'a str> for Symbol {\n@@ -428,4 +454,30 @@ mod tests {\n         // gensym of *existing* string gets new number:\n         assert_eq!(i.gensym(\"dog\"), Symbol(4294967293));\n     }\n+\n+    #[test]\n+    fn is_used_keyword_test() {\n+        let s = Symbol(5);\n+        assert_eq!(s.is_used_keyword(), true);\n+    }\n+\n+    #[test]\n+    fn is_unused_keyword_test() {\n+        let s = Symbol(40);\n+        assert_eq!(s.is_unused_keyword(), true);\n+    }\n+\n+    #[test]\n+    fn is_valid_test() {\n+        let i = Ident { name: Symbol(40), ctxt: SyntaxContext(0) };\n+        assert_eq!(i.is_valid(), false);\n+        let i = Ident { name: Symbol(61), ctxt: SyntaxContext(0) };\n+        assert_eq!(i.is_valid(), true);\n+    }\n+\n+    #[test]\n+    fn without_first_quote_test() {\n+        let i = Ident::from_str(\"'break\");\n+        assert_eq!(i.without_first_quote().name, keywords::Break.name());\n+    }\n }"}, {"sha": "20421bfc7c49150620ab2e420aa28f4fd788f00f", "filename": "src/test/compile-fail/issue-10412.rs", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10412.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only -Z continue-parse-after-error\n-\n-\n trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n-    fn serialize(val : &'self T) -> Vec<u8> ; //~ ERROR lifetimes cannot use keyword names\n-    fn deserialize(repr : &[u8]) -> &'self T; //~ ERROR lifetimes cannot use keyword names\n+    fn serialize(val : &'self T) -> Vec<u8> ;\n+    fn deserialize(repr : &[u8]) -> &'self T;\n }\n \n-impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n+impl<'self> Serializable<str> for &'self str {\n     //~^ ERROR lifetimes cannot use keyword names\n-    fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n+    //~| ERROR missing lifetime specifier\n+    fn serialize(val : &'self str) -> Vec<u8> {\n         vec![1]\n     }\n-    fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n+    fn deserialize(repr: &[u8]) -> &'self str {\n         \"hi\"\n     }\n }", "previous_filename": "src/test/parse-fail/issue-10412.rs"}, {"sha": "82f55f2c14241b6f8e613a6273735266b7ff1611", "filename": "src/test/compile-fail/issue-46311.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46311.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    'break: loop { //~ ERROR invalid label name `'break`\n+    }\n+}"}, {"sha": "e2465663dd0d00e22eedac0ea9d6c241cc17c77a", "filename": "src/test/compile-fail/lifetime-no-keyword.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ccf24ce8e51b199d60d06ad41ea35f4cdee15c/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs?ref=65ccf24ce8e51b199d60d06ad41ea35f4cdee15c", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only -Z continue-parse-after-error\n-\n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }\n-fn baz(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n-fn zab(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n+fn baz<'let>(a: &'let isize) { } //~ ERROR lifetimes cannot use keyword names\n+fn zab<'self>(a: &'self isize) { } //~ ERROR lifetimes cannot use keyword names\n \n fn main() { }", "previous_filename": "src/test/parse-fail/lifetime-no-keyword.rs"}]}