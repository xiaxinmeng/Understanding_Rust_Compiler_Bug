{"sha": "d2f8c30951581fa35bde0dbdd3260c5019b50421", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZjhjMzA5NTE1ODFmYTM1YmRlMGRiZGQzMjYwYzUwMTliNTA0MjE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-11T06:26:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-11T06:26:47Z"}, "message": "Rollup merge of #74127 - tamird:allowlist, r=oli-obk\n\nAvoid \"whitelist\"\n\nOther terms are more inclusive and precise.", "tree": {"sha": "86833fd7f4c2bad113e785f84c86a3cb1f8b5328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86833fd7f4c2bad113e785f84c86a3cb1f8b5328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f8c30951581fa35bde0dbdd3260c5019b50421", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfCVunCRBK7hj4Ov3rIwAAdHIIAI5JZOIPqKhfB/y6hyG7Edog\nsW5E3J+omWySQfTVUsGXpVgs9hDNDBAxegpVvBT6LupJFRWYEyjcz7Dl51BYQOr5\nTgb/bkRp5tHTJR/5/3e38MmXT6OG3B/yj9V4BjATyNHU33vso0rCI019lYJaF1XF\nx2FT0cxGllKkYEd0Wti6nOWuJkKsPuylbi3sLLmsyZLQqwQqWSSmCCSWV315jVyK\nbVYPkh8prUrn80478o3GrHQxmlMuEGzpMlC39x1GI5WyqSV6taZHxRZ4i5AFLh11\nQJKGA7DaE/b0ttyafETDw5BLvaRtywoSzAuAdeamaEPWEwGLJr0jjMnNBsG1PHg=\n=FrF9\n-----END PGP SIGNATURE-----\n", "payload": "tree 86833fd7f4c2bad113e785f84c86a3cb1f8b5328\nparent 8355024ed0cda6b041bc0adb2ca17193946b6c8e\nparent 62cf767a4a39b47677d18110359d9e7152dc9d1c\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594448807 -0700\ncommitter GitHub <noreply@github.com> 1594448807 -0700\n\nRollup merge of #74127 - tamird:allowlist, r=oli-obk\n\nAvoid \"whitelist\"\n\nOther terms are more inclusive and precise.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8c30951581fa35bde0dbdd3260c5019b50421", "html_url": "https://github.com/rust-lang/rust/commit/d2f8c30951581fa35bde0dbdd3260c5019b50421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8c30951581fa35bde0dbdd3260c5019b50421/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8355024ed0cda6b041bc0adb2ca17193946b6c8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8355024ed0cda6b041bc0adb2ca17193946b6c8e", "html_url": "https://github.com/rust-lang/rust/commit/8355024ed0cda6b041bc0adb2ca17193946b6c8e"}, {"sha": "62cf767a4a39b47677d18110359d9e7152dc9d1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/62cf767a4a39b47677d18110359d9e7152dc9d1c", "html_url": "https://github.com/rust-lang/rust/commit/62cf767a4a39b47677d18110359d9e7152dc9d1c"}], "stats": {"total": 574, "additions": 296, "deletions": 278}, "files": [{"sha": "582bc9da0e804d4838da8b343b9f21de04957f9a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -439,8 +439,6 @@ impl Step for Std {\n                 builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"rustdoc\");\n             compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n \n-            // Keep a whitelist so we do not build internal stdlib crates, these will be\n-            // build by the rustc step later if enabled.\n             cargo.arg(\"-p\").arg(package);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links.\n@@ -460,6 +458,10 @@ impl Step for Std {\n \n             builder.run(&mut cargo.into());\n         };\n+        // Only build the following crates. While we could just iterate over the\n+        // folder structure, that would also build internal crates that we do\n+        // not want to show in documentation. These crates will later be visited\n+        // by the rustc step, so internal documentation will show them.\n         let krates = [\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"];\n         for krate in &krates {\n             run_cargo_rustdoc_for(krate);"}, {"sha": "7106078f897cf30fa4ce15635b0a124db8c9e9ec", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -195,9 +195,9 @@ def main():\n     global MAILBOX\n     tests = [os.path.splitext(f)[0] for f in glob('*.rs')\n                                     if not f.startswith('_')]\n-    whitelist = sys.argv[1:]\n-    if whitelist:\n-        tests = [test for test in tests if test in whitelist]\n+    listed = sys.argv[1:]\n+    if listed:\n+        tests = [test for test in tests if test in listed]\n     if not tests:\n         print(\"Error: No tests to run\")\n         sys.exit(1)\n@@ -210,8 +210,6 @@ def main():\n     mailman.daemon = True\n     mailman.start()\n     for test in tests:\n-        if whitelist and test not in whitelist:\n-            continue\n         run(test)\n     MAILBOX.put(None)\n     mailman.join()"}, {"sha": "e9689af39d51f649b474a8fef71e99936fe12aba", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n // within a private module. Once RFC 2145 has been implemented look into\n // improving this.\n mod sealed_trait {\n-    /// Trait which whitelists the allowed types to be used with [VaList::arg]\n+    /// Trait which permits the allowed types to be used with [VaList::arg].\n     ///\n     /// [VaList::arg]: ../struct.VaList.html#method.arg\n     #[unstable("}, {"sha": "89b548a9c5ab23a36300b97ac13e7d19141755d9", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -263,7 +263,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // Windows we end up still needing the `uwtable` attribute even if the `-C\n     // panic=abort` flag is passed.\n     //\n-    // You can also find more info on why Windows is whitelisted here in:\n+    // You can also find more info on why Windows always requires uwtables here:\n     //      https://bugzilla.mozilla.org/show_bug.cgi?id=1302078\n     if cx.sess().must_emit_unwind_tables() {\n         attributes::emit_uwtable(llfn, true);\n@@ -343,14 +343,14 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.target_features_whitelist = |tcx, cnum| {\n+    providers.supported_target_features = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         if tcx.sess.opts.actually_rustdoc {\n             // rustdoc needs to be able to document functions that use all the features, so\n-            // whitelist them all\n+            // provide them all.\n             llvm_util::all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n         } else {\n-            llvm_util::target_feature_whitelist(tcx.sess)\n+            llvm_util::supported_target_features(tcx.sess)\n                 .iter()\n                 .map(|&(a, b)| (a.to_string(), b))\n                 .collect()"}, {"sha": "6b02b5e8120db7c77fbadf9b07ee1b1d82dfd077", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -62,11 +62,11 @@ fn prepare_lto(\n         }\n     };\n     let exported_symbols = cgcx.exported_symbols.as_ref().expect(\"needs exported symbols for LTO\");\n-    let mut symbol_white_list = {\n-        let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n+    let mut symbols_below_threshold = {\n+        let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbols_below_threshold\");\n         exported_symbols[&LOCAL_CRATE].iter().filter_map(symbol_filter).collect::<Vec<CString>>()\n     };\n-    info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n+    info!(\"{} symbols to preserve in this crate\", symbols_below_threshold.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n     // upstream dependencies, find the corresponding rlib and load the bitcode\n@@ -102,8 +102,10 @@ fn prepare_lto(\n             let exported_symbols =\n                 cgcx.exported_symbols.as_ref().expect(\"needs exported symbols for LTO\");\n             {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n-                symbol_white_list.extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n+                let _timer =\n+                    cgcx.prof.generic_activity(\"LLVM_lto_generate_symbols_below_threshold\");\n+                symbols_below_threshold\n+                    .extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n             }\n \n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n@@ -124,7 +126,7 @@ fn prepare_lto(\n         }\n     }\n \n-    Ok((symbol_white_list, upstream_modules))\n+    Ok((symbols_below_threshold, upstream_modules))\n }\n \n fn get_bitcode_slice_from_object_data(obj: &[u8]) -> Result<&[u8], String> {\n@@ -155,9 +157,17 @@ pub(crate) fn run_fat(\n     cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n ) -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n-    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n-    let symbol_white_list = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n-    fat_lto(cgcx, &diag_handler, modules, cached_modules, upstream_modules, &symbol_white_list)\n+    let (symbols_below_threshold, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n+    let symbols_below_threshold =\n+        symbols_below_threshold.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n+    fat_lto(\n+        cgcx,\n+        &diag_handler,\n+        modules,\n+        cached_modules,\n+        upstream_modules,\n+        &symbols_below_threshold,\n+    )\n }\n \n /// Performs thin LTO by performing necessary global analysis and returning two\n@@ -169,15 +179,23 @@ pub(crate) fn run_thin(\n     cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n ) -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n-    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n-    let symbol_white_list = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n+    let (symbols_below_threshold, upstream_modules) = prepare_lto(cgcx, &diag_handler)?;\n+    let symbols_below_threshold =\n+        symbols_below_threshold.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n     if cgcx.opts.cg.linker_plugin_lto.enabled() {\n         unreachable!(\n             \"We should never reach this case if the LTO step \\\n                       is deferred to the linker\"\n         );\n     }\n-    thin_lto(cgcx, &diag_handler, modules, upstream_modules, cached_modules, &symbol_white_list)\n+    thin_lto(\n+        cgcx,\n+        &diag_handler,\n+        modules,\n+        upstream_modules,\n+        cached_modules,\n+        &symbols_below_threshold,\n+    )\n }\n \n pub(crate) fn prepare_thin(module: ModuleCodegen<ModuleLlvm>) -> (String, ThinBuffer) {\n@@ -192,7 +210,7 @@ fn fat_lto(\n     modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n     cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n     mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n-    symbol_white_list: &[*const libc::c_char],\n+    symbols_below_threshold: &[*const libc::c_char],\n ) -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError> {\n     let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_build_monolithic_module\");\n     info!(\"going for a fat lto\");\n@@ -306,14 +324,13 @@ fn fat_lto(\n         drop(linker);\n         save_temp_bitcode(&cgcx, &module, \"lto.input\");\n \n-        // Internalize everything that *isn't* in our whitelist to help strip out\n-        // more modules and such\n+        // Internalize everything below threshold to help strip out more modules and such.\n         unsafe {\n-            let ptr = symbol_white_list.as_ptr();\n+            let ptr = symbols_below_threshold.as_ptr();\n             llvm::LLVMRustRunRestrictionPass(\n                 llmod,\n                 ptr as *const *const libc::c_char,\n-                symbol_white_list.len() as libc::size_t,\n+                symbols_below_threshold.len() as libc::size_t,\n             );\n             save_temp_bitcode(&cgcx, &module, \"lto.after-restriction\");\n         }\n@@ -395,7 +412,7 @@ fn thin_lto(\n     modules: Vec<(String, ThinBuffer)>,\n     serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n     cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-    symbol_white_list: &[*const libc::c_char],\n+    symbols_below_threshold: &[*const libc::c_char],\n ) -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError> {\n     let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_global_analysis\");\n     unsafe {\n@@ -463,8 +480,8 @@ fn thin_lto(\n         let data = llvm::LLVMRustCreateThinLTOData(\n             thin_modules.as_ptr(),\n             thin_modules.len() as u32,\n-            symbol_white_list.as_ptr(),\n-            symbol_white_list.len() as u32,\n+            symbols_below_threshold.as_ptr(),\n+            symbols_below_threshold.len() as u32,\n         )\n         .ok_or_else(|| write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\"))?;\n "}, {"sha": "b631c10334cd13954e95e0885e1dca2d74c52a7c", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -139,7 +139,7 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n \n-const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"aclass\", Some(sym::arm_target_feature)),\n     (\"mclass\", Some(sym::arm_target_feature)),\n     (\"rclass\", Some(sym::arm_target_feature)),\n@@ -162,7 +162,7 @@ const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n ];\n \n-const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"fp\", Some(sym::aarch64_target_feature)),\n     (\"neon\", Some(sym::aarch64_target_feature)),\n     (\"sve\", Some(sym::aarch64_target_feature)),\n@@ -180,7 +180,7 @@ const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"v8.3a\", Some(sym::aarch64_target_feature)),\n ];\n \n-const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"adx\", Some(sym::adx_target_feature)),\n     (\"aes\", None),\n     (\"avx\", None),\n@@ -224,12 +224,12 @@ const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"xsaves\", None),\n ];\n \n-const HEXAGON_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"hvx\", Some(sym::hexagon_target_feature)),\n     (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n ];\n \n-const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"altivec\", Some(sym::powerpc_target_feature)),\n     (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n     (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n@@ -238,10 +238,10 @@ const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_WHITELIST: &[(&str, Option<Symbol>)] =\n+const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n     &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n \n-const RISCV_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"m\", Some(sym::riscv_target_feature)),\n     (\"a\", Some(sym::riscv_target_feature)),\n     (\"c\", Some(sym::riscv_target_feature)),\n@@ -250,7 +250,7 @@ const RISCV_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"e\", Some(sym::riscv_target_feature)),\n ];\n \n-const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"simd128\", Some(sym::wasm_target_feature)),\n     (\"atomics\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n@@ -259,19 +259,18 @@ const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented.\n ///\n-/// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n-/// iterator!\n+/// IMPORTANT: If you're adding another feature list above, make sure to add it to this iterator!\n pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n-    ARM_WHITELIST\n-        .iter()\n+    std::iter::empty()\n+        .chain(ARM_ALLOWED_FEATURES.iter())\n+        .chain(AARCH64_ALLOWED_FEATURES.iter())\n+        .chain(X86_ALLOWED_FEATURES.iter())\n+        .chain(HEXAGON_ALLOWED_FEATURES.iter())\n+        .chain(POWERPC_ALLOWED_FEATURES.iter())\n+        .chain(MIPS_ALLOWED_FEATURES.iter())\n+        .chain(RISCV_ALLOWED_FEATURES.iter())\n+        .chain(WASM_ALLOWED_FEATURES.iter())\n         .cloned()\n-        .chain(AARCH64_WHITELIST.iter().cloned())\n-        .chain(X86_WHITELIST.iter().cloned())\n-        .chain(HEXAGON_WHITELIST.iter().cloned())\n-        .chain(POWERPC_WHITELIST.iter().cloned())\n-        .chain(MIPS_WHITELIST.iter().cloned())\n-        .chain(RISCV_WHITELIST.iter().cloned())\n-        .chain(WASM_WHITELIST.iter().cloned())\n }\n \n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n@@ -289,7 +288,7 @@ pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n     let target_machine = create_informational_target_machine(sess);\n-    target_feature_whitelist(sess)\n+    supported_target_features(sess)\n         .iter()\n         .filter_map(|&(feature, gate)| {\n             if UnstableFeatures::from_environment().is_nightly_build() || gate.is_none() {\n@@ -307,16 +306,16 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .collect()\n }\n \n-pub fn target_feature_whitelist(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n+pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n     match &*sess.target.target.arch {\n-        \"arm\" => ARM_WHITELIST,\n-        \"aarch64\" => AARCH64_WHITELIST,\n-        \"x86\" | \"x86_64\" => X86_WHITELIST,\n-        \"hexagon\" => HEXAGON_WHITELIST,\n-        \"mips\" | \"mips64\" => MIPS_WHITELIST,\n-        \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n-        \"riscv32\" | \"riscv64\" => RISCV_WHITELIST,\n-        \"wasm32\" => WASM_WHITELIST,\n+        \"arm\" => ARM_ALLOWED_FEATURES,\n+        \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n+        \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n+        \"hexagon\" => HEXAGON_ALLOWED_FEATURES,\n+        \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n+        \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n+        \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n+        \"wasm32\" => WASM_ALLOWED_FEATURES,\n         _ => &[],\n     }\n }"}, {"sha": "7a07da0d3a65bdb54f36da79bb56627d6fac356f", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1170,10 +1170,10 @@ impl<'a> Linker for WasmLd<'a> {\n             self.cmd.arg(\"--export\").arg(&sym);\n         }\n \n-        // LLD will hide these otherwise-internal symbols since our `--export`\n-        // list above is a whitelist of what to export. Various bits and pieces\n-        // of tooling use this, so be sure these symbols make their way out of\n-        // the linker as well.\n+        // LLD will hide these otherwise-internal symbols since it only exports\n+        // symbols explicity passed via the `--export` flags above and hides all\n+        // others. Various bits and pieces of tooling use this, so be sure these\n+        // symbols make their way out of the linker as well.\n         self.cmd.arg(\"--export=__heap_base\");\n         self.cmd.arg(\"--export=__data_end\");\n     }"}, {"sha": "b28cb071de6592d18de7b4708da301bfcc5509cb", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -842,10 +842,9 @@ impl CrateInfo {\n                 }\n             }\n \n-            // No need to look for lang items that are whitelisted and don't\n-            // actually need to exist.\n+            // No need to look for lang items that don't actually need to exist.\n             let missing =\n-                missing.iter().cloned().filter(|&l| !lang_items::whitelisted(tcx, l)).collect();\n+                missing.iter().cloned().filter(|&l| lang_items::required(tcx, l)).collect();\n             info.missing_lang_items.insert(cnum, missing);\n         }\n "}, {"sha": "3e48224ef9f2006995ec15c49e33b3cc5325d282", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -735,7 +735,7 @@ pub struct SyntaxExtension {\n     pub kind: SyntaxExtensionKind,\n     /// Span of the macro definition.\n     pub span: Span,\n-    /// Whitelist of unstable features that are treated as stable inside this macro.\n+    /// List of unstable features that are treated as stable inside this macro.\n     pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     /// Suppresses the `unsafe_code` lint for code produced by this macro.\n     pub allow_internal_unsafe: bool,"}, {"sha": "4e2aea34fe7fb713d5eab44c83de0faea28ac7f0", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -47,7 +47,7 @@ pub enum AttributeType {\n     /// Builtin attribute that may not be consumed by the compiler\n     /// before the unused_attribute check. These attributes\n     /// will be ignored by the unused_attribute lint\n-    Whitelisted,\n+    AssumedUsed,\n \n     /// Builtin attribute that is only allowed at the crate level\n     CrateLevel,\n@@ -202,7 +202,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n     ungated!(forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n     ungated!(deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n-    ungated!(must_use, Whitelisted, template!(Word, NameValueStr: \"reason\")),\n+    ungated!(must_use, AssumedUsed, template!(Word, NameValueStr: \"reason\")),\n     // FIXME(#14407)\n     ungated!(\n         deprecated, Normal,\n@@ -220,16 +220,16 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // ABI, linking, symbols, and FFI\n     ungated!(\n-        link, Whitelisted,\n+        link, AssumedUsed,\n         template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n     ),\n-    ungated!(link_name, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(link_name, AssumedUsed, template!(NameValueStr: \"name\")),\n     ungated!(no_link, Normal, template!(Word)),\n     ungated!(repr, Normal, template!(List: \"C\")),\n-    ungated!(export_name, Whitelisted, template!(NameValueStr: \"name\")),\n-    ungated!(link_section, Whitelisted, template!(NameValueStr: \"name\")),\n-    ungated!(no_mangle, Whitelisted, template!(Word)),\n-    ungated!(used, Whitelisted, template!(Word)),\n+    ungated!(export_name, AssumedUsed, template!(NameValueStr: \"name\")),\n+    ungated!(link_section, AssumedUsed, template!(NameValueStr: \"name\")),\n+    ungated!(no_mangle, AssumedUsed, template!(Word)),\n+    ungated!(used, AssumedUsed, template!(Word)),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\")),\n@@ -249,40 +249,40 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(path, Normal, template!(NameValueStr: \"file\")),\n     ungated!(no_std, CrateLevel, template!(Word)),\n     ungated!(no_implicit_prelude, Normal, template!(Word)),\n-    ungated!(non_exhaustive, Whitelisted, template!(Word)),\n+    ungated!(non_exhaustive, AssumedUsed, template!(Word)),\n \n     // Runtime\n-    ungated!(windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\")),\n+    ungated!(windows_subsystem, AssumedUsed, template!(NameValueStr: \"windows|console\")),\n     ungated!(panic_handler, Normal, template!(Word)), // RFC 2070\n \n     // Code generation:\n-    ungated!(inline, Whitelisted, template!(Word, List: \"always|never\")),\n-    ungated!(cold, Whitelisted, template!(Word)),\n-    ungated!(no_builtins, Whitelisted, template!(Word)),\n-    ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n-    ungated!(track_caller, Whitelisted, template!(Word)),\n+    ungated!(inline, AssumedUsed, template!(Word, List: \"always|never\")),\n+    ungated!(cold, AssumedUsed, template!(Word)),\n+    ungated!(no_builtins, AssumedUsed, template!(Word)),\n+    ungated!(target_feature, AssumedUsed, template!(List: r#\"enable = \"name\"\"#)),\n+    ungated!(track_caller, AssumedUsed, template!(Word)),\n     gated!(\n-        no_sanitize, Whitelisted,\n+        no_sanitize, AssumedUsed,\n         template!(List: \"address, memory, thread\"),\n         experimental!(no_sanitize)\n     ),\n \n-    // FIXME: #14408 whitelist docs since rustdoc looks at them\n-    ungated!(doc, Whitelisted, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n+    // FIXME: #14408 assume docs are used since rustdoc looks at them.\n+    ungated!(doc, AssumedUsed, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n \n     // ==========================================================================\n     // Unstable attributes:\n     // ==========================================================================\n \n     // Linking:\n-    gated!(naked, Whitelisted, template!(Word), naked_functions, experimental!(naked)),\n+    gated!(naked, AssumedUsed, template!(Word), naked_functions, experimental!(naked)),\n     gated!(\n         link_args, Normal, template!(NameValueStr: \"args\"),\n         \"the `link_args` attribute is experimental and not portable across platforms, \\\n         it is recommended to use `#[link(name = \\\"foo\\\")] instead\",\n     ),\n     gated!(\n-        link_ordinal, Whitelisted, template!(List: \"ordinal\"), raw_dylib,\n+        link_ordinal, AssumedUsed, template!(List: \"ordinal\"), raw_dylib,\n         experimental!(link_ordinal)\n     ),\n \n@@ -321,19 +321,19 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // RFC #1268\n     gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n     gated!(\n-        thread_local, Whitelisted, template!(Word),\n+        thread_local, AssumedUsed, template!(Word),\n         \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n     ),\n     gated!(no_core, CrateLevel, template!(Word), experimental!(no_core)),\n     // RFC 2412\n     gated!(\n-        optimize, Whitelisted, template!(List: \"size|speed\"), optimize_attribute,\n+        optimize, AssumedUsed, template!(List: \"size|speed\"), optimize_attribute,\n         experimental!(optimize),\n     ),\n \n-    gated!(ffi_returns_twice, Whitelisted, template!(Word), experimental!(ffi_returns_twice)),\n-    gated!(ffi_pure, Whitelisted, template!(Word), experimental!(ffi_pure)),\n-    gated!(ffi_const, Whitelisted, template!(Word), experimental!(ffi_const)),\n+    gated!(ffi_returns_twice, AssumedUsed, template!(Word), experimental!(ffi_returns_twice)),\n+    gated!(ffi_pure, AssumedUsed, template!(Word), experimental!(ffi_pure)),\n+    gated!(ffi_const, AssumedUsed, template!(Word), experimental!(ffi_const)),\n     gated!(\n         register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"),\n         experimental!(register_attr),\n@@ -351,22 +351,22 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // FIXME(#14407) -- only looked at on-demand so we can't\n     // guarantee they'll have already been checked.\n     ungated!(\n-        rustc_deprecated, Whitelisted,\n+        rustc_deprecated, AssumedUsed,\n         template!(List: r#\"since = \"version\", reason = \"...\"\"#)\n     ),\n     // FIXME(#14407)\n-    ungated!(stable, Whitelisted, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n+    ungated!(stable, AssumedUsed, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n     // FIXME(#14407)\n     ungated!(\n-        unstable, Whitelisted,\n+        unstable, AssumedUsed,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n     ),\n     // FIXME(#14407)\n-    ungated!(rustc_const_unstable, Whitelisted, template!(List: r#\"feature = \"name\"\"#)),\n+    ungated!(rustc_const_unstable, AssumedUsed, template!(List: r#\"feature = \"name\"\"#)),\n     // FIXME(#14407)\n-    ungated!(rustc_const_stable, Whitelisted, template!(List: r#\"feature = \"name\"\"#)),\n+    ungated!(rustc_const_stable, AssumedUsed, template!(List: r#\"feature = \"name\"\"#)),\n     gated!(\n-        allow_internal_unstable, Whitelisted, template!(Word, List: \"feat1, feat2, ...\"),\n+        allow_internal_unstable, AssumedUsed, template!(Word, List: \"feat1, feat2, ...\"),\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n     ),\n     gated!(\n@@ -378,7 +378,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes: Type system related:\n     // ==========================================================================\n \n-    gated!(fundamental, Whitelisted, template!(Word), experimental!(fundamental)),\n+    gated!(fundamental, AssumedUsed, template!(Word), experimental!(fundamental)),\n     gated!(\n         may_dangle, Normal, template!(Word), dropck_eyepatch,\n         \"`may_dangle` has unstable semantics and may be removed in the future\",\n@@ -388,30 +388,30 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes: Runtime related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_allocator, Whitelisted, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_allocator_nounwind, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator, AssumedUsed, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_nounwind, AssumedUsed, template!(Word), IMPL_DETAIL),\n     gated!(alloc_error_handler, Normal, template!(Word), experimental!(alloc_error_handler)),\n     gated!(\n-        default_lib_allocator, Whitelisted, template!(Word), allocator_internals,\n+        default_lib_allocator, AssumedUsed, template!(Word), allocator_internals,\n         experimental!(default_lib_allocator),\n     ),\n     gated!(\n         needs_allocator, Normal, template!(Word), allocator_internals,\n         experimental!(needs_allocator),\n     ),\n-    gated!(panic_runtime, Whitelisted, template!(Word), experimental!(panic_runtime)),\n-    gated!(needs_panic_runtime, Whitelisted, template!(Word), experimental!(needs_panic_runtime)),\n+    gated!(panic_runtime, AssumedUsed, template!(Word), experimental!(panic_runtime)),\n+    gated!(needs_panic_runtime, AssumedUsed, template!(Word), experimental!(needs_panic_runtime)),\n     gated!(\n-        unwind, Whitelisted, template!(List: \"allowed|aborts\"), unwind_attributes,\n+        unwind, AssumedUsed, template!(List: \"allowed|aborts\"), unwind_attributes,\n         experimental!(unwind),\n     ),\n     gated!(\n-        compiler_builtins, Whitelisted, template!(Word),\n+        compiler_builtins, AssumedUsed, template!(Word),\n         \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\\n         which contains compiler-rt intrinsics and will never be stable\",\n     ),\n     gated!(\n-        profiler_runtime, Whitelisted, template!(Word),\n+        profiler_runtime, AssumedUsed, template!(Word),\n         \"the `#[profiler_runtime]` attribute is used to identify the `profiler_builtins` crate \\\n         which contains the profiler runtime and will never be stable\",\n     ),\n@@ -421,19 +421,19 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     gated!(\n-        linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n+        linkage, AssumedUsed, template!(NameValueStr: \"external|internal|...\"),\n         \"the `linkage` attribute is experimental and not portable across platforms\",\n     ),\n-    rustc_attr!(rustc_std_internal_symbol, Whitelisted, template!(Word), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_std_internal_symbol, AssumedUsed, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Macro related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_builtin_macro, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_builtin_macro, AssumedUsed, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERNAL_UNSTABLE),\n     rustc_attr!(\n-        rustc_macro_transparency, Whitelisted,\n+        rustc_macro_transparency, AssumedUsed,\n         template!(NameValueStr: \"transparent|semitransparent|opaque\"),\n         \"used internally for testing macro hygiene\",\n     ),\n@@ -443,40 +443,40 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(\n-        rustc_on_unimplemented, Whitelisted,\n+        rustc_on_unimplemented, AssumedUsed,\n         template!(\n             List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n             NameValueStr: \"message\"\n         ),\n         INTERNAL_UNSTABLE\n     ),\n-    // Whitelists \"identity-like\" conversion methods to suggest on type mismatch.\n-    rustc_attr!(rustc_conversion_suggestion, Whitelisted, template!(Word), INTERNAL_UNSTABLE),\n+    // Enumerates \"identity-like\" conversion methods to suggest on type mismatch.\n+    rustc_attr!(rustc_conversion_suggestion, AssumedUsed, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_promotable, Whitelisted, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_allow_const_fn_ptr, Whitelisted, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_args_required_const, Whitelisted, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allow_const_fn_ptr, AssumedUsed, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:\n     // ==========================================================================\n \n     rustc_attr!(\n-        rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n+        rustc_layout_scalar_valid_range_start, AssumedUsed, template!(List: \"value\"),\n         \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n     rustc_attr!(\n-        rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n+        rustc_layout_scalar_valid_range_end, AssumedUsed, template!(List: \"value\"),\n         \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n     rustc_attr!(\n-        rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n+        rustc_nonnull_optimization_guaranteed, AssumedUsed, template!(Word),\n         \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n         niche optimizations in libcore and will never be stable\",\n     ),\n@@ -501,15 +501,15 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     gated!(\n         // Used in resolve:\n-        prelude_import, Whitelisted, template!(Word),\n+        prelude_import, AssumedUsed, template!(Word),\n         \"`#[prelude_import]` is for use by rustc only\",\n     ),\n     gated!(\n         rustc_paren_sugar, Normal, template!(Word), unboxed_closures,\n         \"unboxed_closures are still evolving\",\n     ),\n     rustc_attr!(\n-        rustc_inherit_overflow_checks, Whitelisted, template!(Word),\n+        rustc_inherit_overflow_checks, AssumedUsed, template!(Word),\n         \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n         overflow checking behavior of several libcore functions that are inlined \\\n         across crates and will never be stable\",\n@@ -540,42 +540,42 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n     rustc_attr!(\n-        TEST, rustc_error, Whitelisted,\n+        TEST, rustc_error, AssumedUsed,\n         template!(Word, List: \"delay_span_bug_from_inside_query\")\n     ),\n-    rustc_attr!(TEST, rustc_dump_user_substs, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\")),\n-    rustc_attr!(TEST, rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_dump_user_substs, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_if_this_changed, AssumedUsed, template!(Word, List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_then_this_would_need, AssumedUsed, template!(List: \"DepNode\")),\n     rustc_attr!(\n-        TEST, rustc_dirty, Whitelisted,\n+        TEST, rustc_dirty, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_clean, Whitelisted,\n+        TEST, rustc_clean, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_partition_reused, Whitelisted,\n+        TEST, rustc_partition_reused, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_partition_codegened, Whitelisted,\n+        TEST, rustc_partition_codegened, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n     ),\n     rustc_attr!(\n-        TEST, rustc_expected_cgu_reuse, Whitelisted,\n+        TEST, rustc_expected_cgu_reuse, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", module = \"...\", kind = \"...\"\"#),\n     ),\n-    rustc_attr!(TEST, rustc_synthetic, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_symbol_name, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_def_path, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\")),\n-    rustc_attr!(TEST, rustc_dump_program_clauses, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_dump_env_program_clauses, Whitelisted, template!(Word)),\n-    rustc_attr!(TEST, rustc_object_lifetime_default, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_synthetic, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_symbol_name, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_def_path, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_mir, AssumedUsed, template!(List: \"arg1, arg2, ...\")),\n+    rustc_attr!(TEST, rustc_dump_program_clauses, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_env_program_clauses, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_object_lifetime_default, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/)),\n     gated!(\n-        omit_gdb_pretty_printer_section, Whitelisted, template!(Word),\n+        omit_gdb_pretty_printer_section, AssumedUsed, template!(Word),\n         \"the `#[omit_gdb_pretty_printer_section]` attribute is just used for the Rust test suite\",\n     ),\n ];"}, {"sha": "043aff90ce404fd5fed5edfe47437556f4b7c20c", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -168,7 +168,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n \n         // Note that we cannot use the existing \"unused attribute\"-infrastructure\n         // here, since that is running before codegen. This is also the reason why\n-        // all codegen-specific attributes are `Whitelisted` in rustc_ast::feature_gate.\n+        // all codegen-specific attributes are `AssumedUsed` in rustc_ast::feature_gate.\n         all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n     })\n }"}, {"sha": "0c8c713c4cf0c7e329800d4dddc7a4c4c6c5fdf4", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -38,8 +38,8 @@ use std::{panic, thread};\n /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n-/// This is performed by checking whether a whitelisted set of\n-/// features is available on the target machine, by querying LLVM.\n+/// This is performed by checking whether a set of permitted features\n+/// is available on the target machine, by querying LLVM.\n pub fn add_configuration(\n     cfg: &mut CrateConfig,\n     sess: &mut Session,"}, {"sha": "2431f7ba54b36edacb66ce34e48007eb461d1162", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -287,8 +287,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n         let attr_info = attr.ident().and_then(|ident| self.builtin_attributes.get(&ident.name));\n \n         if let Some(&&(name, ty, ..)) = attr_info {\n-            if let AttributeType::Whitelisted = ty {\n-                debug!(\"{:?} is Whitelisted\", name);\n+            if let AttributeType::AssumedUsed = ty {\n+                debug!(\"{:?} is AssumedUsed\", name);\n                 return;\n             }\n         }"}, {"sha": "4746e53ce59a92d332b6d081423ead4462117675", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1386,9 +1386,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let constness = match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n-            // Some intrinsics can be const fn. While we could recompute this (at least until we\n-            // stop having hardcoded whitelists and move to stability attributes), it seems cleaner\n-            // to treat all const fns equally.\n             EntryKind::ForeignFn(data) => data.decode(self).constness,\n             EntryKind::Variant(..) | EntryKind::Struct(..) => hir::Constness::Const,\n             _ => hir::Constness::NotConst,"}, {"sha": "3f0939239e85c1d1f2cae567c2cbed302943eeb8", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -230,8 +230,9 @@ pub fn struct_lint_level<'s, 'd>(\n             err.allow_suggestions(false);\n \n             // If this is a future incompatible lint it'll become a hard error, so\n-            // we have to emit *something*. Also allow lints to whitelist themselves\n-            // on a case-by-case basis for emission in a foreign macro.\n+            // we have to emit *something*. Also, if this lint occurs in the\n+            // expansion of a macro from an external crate, allow individual lints\n+            // to opt-out from being reported.\n             if future_incompatible.is_none() && !lint.report_in_external_macro {\n                 err.cancel();\n                 // Don't continue further, since we don't want to have"}, {"sha": "70c90198276c1700a91850037f0b4a851dab4b57", "filename": "src/librustc_middle/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flang_items.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -42,19 +42,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// Returns `true` if the specified `lang_item` doesn't actually need to be\n-/// present for this compilation.\n+/// Returns `true` if the specified `lang_item` must be present for this\n+/// compilation.\n ///\n /// Not all lang items are always required for each compilation, particularly in\n /// the case of panic=abort. In these situations some lang items are injected by\n /// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n+pub fn required(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n     // If we're not compiling with unwinding, we won't actually need these\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == LangItem::EhPersonalityLangItem;\n+    match tcx.sess.panic_strategy() {\n+        PanicStrategy::Abort => lang_item != LangItem::EhPersonalityLangItem,\n+        PanicStrategy::Unwind => true,\n     }\n-\n-    false\n }"}, {"sha": "0faf389aa385c617337be26b3ba4a19ec89ee97f", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1413,10 +1413,10 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n+        query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n             storage(ArenaCacheSelector<'tcx>)\n             eval_always\n-            desc { \"looking up the whitelist of target features\" }\n+            desc { \"looking up supported target features\" }\n         }\n \n         // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning."}, {"sha": "70ddd79ee40b082916e3f0f85bf47f5780dae605", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -88,7 +88,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n }\n \n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n-/// said intrinsic is on the whitelist for being const callable.\n+/// said intrinsic has a `rustc_const_{un,}stable` attribute.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n "}, {"sha": "f95ac309424d04201d0976bd6dfe04ddfaec7d5b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -45,7 +45,7 @@ macro_rules! throw_validation_failure {\n /// If $e throws an error matching the pattern, throw a validation failure.\n /// Other errors are passed back to the caller, unchanged -- and if they reach the root of\n /// the visitor, we make sure only validation errors and `InvalidProgram` errors are left.\n-/// This lets you use the patterns as a kind of validation whitelist, asserting which errors\n+/// This lets you use the patterns as a kind of validation list, asserting which errors\n /// can possibly happen:\n ///\n /// ```"}, {"sha": "12925af8170f0b4458239dadbe8c046e692c5306", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::lang_items;\n use rustc_hir::lang_items::ITEM_REFS;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n-use rustc_middle::middle::lang_items::whitelisted;\n+use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n use rustc_span::symbol::sym;\n@@ -59,7 +59,7 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     }\n \n     for (name, &item) in WEAK_ITEMS_REFS.iter() {\n-        if missing.contains(&item) && !whitelisted(tcx, item) && items.require(item).is_err() {\n+        if missing.contains(&item) && required(tcx, item) && items.require(item).is_err() {\n             if item == lang_items::PanicImplLangItem {\n                 tcx.sess.err(\"`#[panic_handler]` function required, but not found\");\n             } else if item == lang_items::OomLangItem {"}, {"sha": "1467bf537eb49169f8aa0274a35547d5570a3ea3", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -2122,7 +2122,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         self.impl_self\n                     {\n                         match path.res {\n-                            // Whitelist the types that unambiguously always\n+                            // Permit the types that unambiguously always\n                             // result in the same type constructor being used\n                             // (it can't differ between `Self` and `self`).\n                             Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum, _)"}, {"sha": "b2c2b8254d8f05844cc658f937b5101cd01db104", "filename": "src/librustc_target/spec/tests/tests_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -16,8 +16,8 @@ pub(super) fn test_target(target: TargetResult) {\n impl Target {\n     fn check_consistency(&self) {\n         // Check that LLD with the given flavor is treated identically to the linker it emulates.\n-        // If you target really needs to deviate from the rules below, whitelist it\n-        // and document the reasons.\n+        // If your target really needs to deviate from the rules below, except it and document the\n+        // reasons.\n         assert_eq!(\n             self.linker_flavor == LinkerFlavor::Msvc\n                 || self.linker_flavor == LinkerFlavor::Lld(LldFlavor::Link),"}, {"sha": "8423573b52d5111cc86419ba2c86fd9bb1098ace", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -40,14 +40,14 @@ pub fn options() -> TargetOptions {\n     // corrupting static data.\n     arg(\"--stack-first\");\n \n-    // FIXME we probably shouldn't pass this but instead pass an explicit\n-    // whitelist of symbols we'll allow to be undefined. We don't currently have\n-    // a mechanism of knowing, however, which symbols are intended to be\n-    // imported from the environment and which are intended to be imported from\n-    // other objects linked elsewhere. This is a coarse approximation but is\n-    // sure to hide some bugs and frustrate someone at some point, so we should\n-    // ideally work towards a world where we can explicitly list symbols that\n-    // are supposed to be imported and have all other symbols generate errors if\n+    // FIXME we probably shouldn't pass this but instead pass an explicit list\n+    // of symbols we'll allow to be undefined. We don't currently have a\n+    // mechanism of knowing, however, which symbols are intended to be imported\n+    // from the environment and which are intended to be imported from other\n+    // objects linked elsewhere. This is a coarse approximation but is sure to\n+    // hide some bugs and frustrate someone at some point, so we should ideally\n+    // work towards a world where we can explicitly list symbols that are\n+    // supposed to be imported and have all other symbols generate errors if\n     // they remain undefined.\n     arg(\"--allow-undefined\");\n "}, {"sha": "d677d84b2ba1305910f3f4ed303720eb5b00e2ef", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -2139,7 +2139,7 @@ pub trait NextTypeParamName {\n \n impl NextTypeParamName for &[hir::GenericParam<'_>] {\n     fn next_type_param_name(&self, name: Option<&str>) -> String {\n-        // This is the whitelist of possible parameter names that we might suggest.\n+        // This is the list of possible parameter names that we might suggest.\n         let name = name.and_then(|n| n.chars().next()).map(|c| c.to_string().to_uppercase());\n         let name = name.as_deref();\n         let possible_names = [name.unwrap_or(\"T\"), \"T\", \"U\", \"V\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"];"}, {"sha": "9a9630f09588698fc551517f3c8286641d016e27", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .tcx\n                     .get_attrs(m.def_id)\n                     .iter()\n-                    // This special internal attribute is used to whitelist\n+                    // This special internal attribute is used to permit\n                     // \"identity-like\" conversion methods to be suggested here.\n                     //\n                     // FIXME (#46459 and #46460): ideally"}, {"sha": "e6b51f4c2cd2a1bdd213f0b0dc9f13d4e6ee307e", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -913,7 +913,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Adt(..) = rcvr_t.kind {\n                 // Try alternative arbitrary self types that could fulfill this call.\n                 // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                // just this whitelist.\n+                // just this list.\n                 try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, lang_items::OwnedBoxLangItem));\n                 try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, lang_items::PinTypeLangItem));\n                 try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Arc));\n@@ -1806,7 +1806,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // If this is an input value, we require its type to be fully resolved\n         // at this point. This allows us to provide helpful coercions which help\n-        // pass the type whitelist in a later pass.\n+        // pass the type candidate list in a later pass.\n         //\n         // We don't require output types to be resolved at this point, which\n         // allows them to be inferred based on how they are used later in the"}, {"sha": "15481660a52186d3ee67d37e133baefd6a04b1af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -2150,7 +2150,7 @@ fn from_target_feature(\n     tcx: TyCtxt<'_>,\n     id: DefId,\n     attr: &ast::Attribute,\n-    whitelist: &FxHashMap<String, Option<Symbol>>,\n+    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n     let list = match attr.meta_item_list() {\n@@ -2184,8 +2184,7 @@ fn from_target_feature(\n \n         // We allow comma separation to enable multiple features.\n         target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            // Only allow whitelisted features per platform.\n-            let feature_gate = match whitelist.get(feature) {\n+            let feature_gate = match supported_target_features.get(feature) {\n                 Some(g) => g,\n                 None => {\n                     let msg =\n@@ -2196,7 +2195,7 @@ fn from_target_feature(\n                         format!(\"`{}` is not valid for this target\", feature),\n                     );\n                     if feature.starts_with('+') {\n-                        let valid = whitelist.contains_key(&feature[1..]);\n+                        let valid = supported_target_features.contains_key(&feature[1..]);\n                         if valid {\n                             err.help(\"consider removing the leading `+` in the feature name\");\n                         }\n@@ -2246,9 +2245,9 @@ fn linkage_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Linkage {\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n+    // Rust code in the first place but allow them anyway and trust that the\n+    // user knows what s/he's doing. Who knows, unanticipated use cases may pop\n+    // up in the future.\n     //\n     // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n     // and don't have to be, LLVM treats them as no-ops.\n@@ -2283,7 +2282,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n     }\n \n-    let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n+    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n \n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n@@ -2386,7 +2385,13 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     check_target_feature_trait_unsafe(tcx, local_id, attr.span);\n                 }\n             }\n-            from_target_feature(tcx, id, attr, &whitelist, &mut codegen_fn_attrs.target_features);\n+            from_target_feature(\n+                tcx,\n+                id,\n+                attr,\n+                &supported_target_features,\n+                &mut codegen_fn_attrs.target_features,\n+            );\n         } else if attr.check_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));"}, {"sha": "a222920c7d292a2e09c89a387ebb1c76d829d57a", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -225,7 +225,7 @@ pub fn new_handler(\n ///  * Vector of tuples of lints' name and their associated \"max\" level\n ///  * HashMap of lint id with their associated \"max\" level\n pub fn init_lints<F>(\n-    mut whitelisted_lints: Vec<String>,\n+    mut allowed_lints: Vec<String>,\n     lint_opts: Vec<(String, lint::Level)>,\n     filter_call: F,\n ) -> (Vec<(String, lint::Level)>, FxHashMap<lint::LintId, lint::Level>)\n@@ -234,8 +234,8 @@ where\n {\n     let warnings_lint_name = lint::builtin::WARNINGS.name;\n \n-    whitelisted_lints.push(warnings_lint_name.to_owned());\n-    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n+    allowed_lints.push(warnings_lint_name.to_owned());\n+    allowed_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n     let lints = || {\n         lint::builtin::HardwiredLints::get_lints()\n@@ -245,7 +245,7 @@ where\n \n     let lint_opts = lints()\n         .filter_map(|lint| {\n-            // Whitelist feature-gated lints to avoid feature errors when trying to\n+            // Permit feature-gated lints to avoid feature errors when trying to\n             // allow all lints.\n             if lint.name == warnings_lint_name || lint.feature_gate.is_some() {\n                 None\n@@ -258,9 +258,9 @@ where\n \n     let lint_caps = lints()\n         .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+            // We don't want to allow *all* lints so let's ignore\n+            // those ones.\n+            if allowed_lints.iter().any(|l| lint.name == l) {\n                 None\n             } else {\n                 Some((lint::LintId::of(lint), lint::Allow))\n@@ -317,9 +317,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let no_crate_level_docs = rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS.name;\n     let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n \n-    // In addition to those specific lints, we also need to whitelist those given through\n+    // In addition to those specific lints, we also need to allow those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let whitelisted_lints = vec![\n+    let allowed_lints = vec![\n         intra_link_resolution_failure_name.to_owned(),\n         missing_docs.to_owned(),\n         missing_doc_example.to_owned(),\n@@ -328,7 +328,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n-    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, lint_opts, |lint| {\n+    let (lint_opts, lint_caps) = init_lints(allowed_lints, lint_opts, |lint| {\n         if lint.name == intra_link_resolution_failure_name\n             || lint.name == invalid_codeblock_attribute_name\n         {"}, {"sha": "8bba21a2e7acef1ff62308d09921aa00167bef1a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -3151,7 +3151,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-const ATTRIBUTE_WHITELIST: &[Symbol] = &[\n+const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n     sym::export_name,\n     sym::lang,\n     sym::link_section,\n@@ -3173,7 +3173,7 @@ fn render_attributes(w: &mut Buffer, it: &clean::Item, top: bool) {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        if !ATTRIBUTE_WHITELIST.contains(&attr.name_or_empty()) {\n+        if !ALLOWED_ATTRIBUTES.contains(&attr.name_or_empty()) {\n             continue;\n         }\n "}, {"sha": "c2d644bdd05f1894f28d3ecf34b57644ac8d9eb1", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -47,11 +47,11 @@ pub fn run(options: Options) -> Result<(), String> {\n \n     let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n \n-    // In addition to those specific lints, we also need to whitelist those given through\n+    // In addition to those specific lints, we also need to allow those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let whitelisted_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n+    let allowed_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n \n-    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, options.lint_opts.clone(), |lint| {\n+    let (lint_opts, lint_caps) = init_lints(allowed_lints, options.lint_opts.clone(), |lint| {\n         if lint.name == invalid_codeblock_attribute_name {\n             None\n         } else {"}, {"sha": "9f4fa89cd550624fad5d92716c5f14519c82d084", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -241,7 +241,7 @@ impl Instant {\n         // returned instead of what the OS says if the OS goes backwards.\n         //\n         // To hopefully mitigate the impact of this, a few platforms are\n-        // whitelisted as \"these at least haven't gone backwards yet\".\n+        // excluded as \"these at least haven't gone backwards yet\".\n         if time::Instant::actually_monotonic() {\n             return Instant(os_now);\n         }"}, {"sha": "dd49ca67c67484a437907687aeb6ee6f8dc461c6", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -52,7 +52,7 @@ impl CodegenBackend for TheBackend {\n     fn provide(&self, providers: &mut Providers) {\n         rustc_symbol_mangling::provide(providers);\n \n-        providers.target_features_whitelist = |tcx, _cnum| {\n+        providers.supported_target_features = |tcx, _cnum| {\n             Default::default() // Just a dummy\n         };\n         providers.is_reachable_non_generic = |_tcx, _defid| true;"}, {"sha": "f479bdabb9c0c67313bfe2632114c5a9de4fd84e", "filename": "src/test/run-make-fulldeps/sysroot-crates-are-unstable/test.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Frun-make-fulldeps%2Fsysroot-crates-are-unstable%2Ftest.py", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Frun-make-fulldeps%2Fsysroot-crates-are-unstable%2Ftest.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsysroot-crates-are-unstable%2Ftest.py?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -5,7 +5,7 @@\n from subprocess import PIPE, Popen\n \n \n-# This is a whitelist of files which are stable crates or simply are not crates,\n+# This is n list of files which are stable crates or simply are not crates,\n # we don't check for the instability of these crates as they're all stable!\n STABLE_CRATES = ['std', 'alloc', 'core', 'proc_macro',\n                  'rsbegin.o', 'rsend.o', 'dllcrt2.o', 'crt2.o', 'clang_rt']"}, {"sha": "4e9d4d342734c6f1e9e983d6a01552f1f3126bd2", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -21,19 +21,19 @@ use rustc_span::source_map;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.lint_store.register_lints(&[&MISSING_WHITELISTED_ATTR]);\n-    reg.lint_store.register_late_pass(|| box MissingWhitelistedAttrPass);\n+    reg.lint_store.register_lints(&[&MISSING_ALLOWED_ATTR]);\n+    reg.lint_store.register_late_pass(|| box MissingAllowedAttrPass);\n }\n \n declare_lint! {\n-    MISSING_WHITELISTED_ATTR,\n+    MISSING_ALLOWED_ATTR,\n     Deny,\n-    \"Checks for missing `whitelisted_attr` attribute\"\n+    \"Checks for missing `allowed_attr` attribute\"\n }\n \n-declare_lint_pass!(MissingWhitelistedAttrPass => [MISSING_WHITELISTED_ATTR]);\n+declare_lint_pass!(MissingAllowedAttrPass => [MISSING_ALLOWED_ATTR]);\n \n-impl<'tcx> LateLintPass<'tcx> for MissingWhitelistedAttrPass {\n+impl<'tcx> LateLintPass<'tcx> for MissingAllowedAttrPass {\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,\n@@ -48,10 +48,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingWhitelistedAttrPass {\n             _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n         };\n \n-        let whitelisted = |attr| pprust::attribute_to_string(attr).contains(\"whitelisted_attr\");\n-        if !item.attrs.iter().any(whitelisted) {\n-            cx.lint(MISSING_WHITELISTED_ATTR, |lint| {\n-                lint.build(\"Missing 'whitelisted_attr' attribute\").set_span(span).emit()\n+        let allowed = |attr| pprust::attribute_to_string(attr).contains(\"allowed_attr\");\n+        if !item.attrs.iter().any(allowed) {\n+            cx.lint(MISSING_ALLOWED_ATTR, |lint| {\n+                lint.build(\"Missing 'allowed_attr' attribute\").set_span(span).emit()\n             });\n         }\n     }"}, {"sha": "e14338fdbbf356f80c8bc117506b0cac65c6df52", "filename": "src/test/ui-fulldeps/issue-40001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui-fulldeps%2Fissue-40001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui-fulldeps%2Fissue-40001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-40001.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -6,5 +6,5 @@\n #![plugin(issue_40001_plugin)] //~ WARNING compiler plugins are deprecated\n #![register_tool(plugin)]\n \n-#[plugin::whitelisted_attr]\n+#[plugin::allowed_attr]\n fn main() {}"}, {"sha": "0f803eff17b8a932ee71410724ac6994cb314e7e", "filename": "src/test/ui/asm/type-check-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -7,7 +7,7 @@ use std::arch::x86_64::{_mm256_setzero_ps, _mm_setzero_ps};\n \n fn main() {\n     unsafe {\n-        // Types must be in the whitelist for the register class\n+        // Types must be listed in the register class.\n \n         asm!(\"{}\", in(reg) 0i128);\n         //~^ ERROR type `i128` cannot be used with this register class"}, {"sha": "1fb5878ca2ace18c9f079a663a28dc6c3dcf8493", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/meta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fmeta.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n \n-// Tests that `meta` is whitelisted, even if the crate doesn't exist\n-// yet (i.e., it causes a different error than `not-whitelisted.rs`).\n+// Tests that `meta` is allowed, even if the crate doesn't exist\n+// yet (i.e., it causes a different error than `not-allowed.rs`).\n use meta; //~ ERROR can't find crate for `meta`\n \n fn main() {}"}, {"sha": "acb4bbebe7f532a531a9076fb3db4495ea59deef", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-allowed.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "previous_filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.rs"}, {"sha": "6d2b4508a05927759ca05452051b045e1c5512fe", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-allowed.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-allowed.stderr?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1,5 +1,5 @@\n error[E0432]: unresolved import `alloc`\n-  --> $DIR/not-whitelisted.rs:5:5\n+  --> $DIR/not-allowed.rs:5:5\n    |\n LL | use alloc;\n    |     ^^^^^ no `alloc` external crate", "previous_filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.stderr"}, {"sha": "7726972b95b6465faee6206638f8ddd096eebe43", "filename": "src/test/ui/sse2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Fsse2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftest%2Fui%2Fsse2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsse2.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -20,7 +20,7 @@ fn main() {\n         assert!(cfg!(target_feature = \"sse2\"),\n                 \"SSE2 was not detected as available on an x86 platform\");\n     }\n-    // check a negative case too -- whitelisted on x86, but not enabled by default\n+    // check a negative case too -- allowed on x86, but not enabled by default\n     assert!(cfg!(not(target_feature = \"avx2\")),\n             \"AVX2 shouldn't be detected as available by default on any platform\");\n }"}, {"sha": "3f7d6ba6467701fd2a5aec843328a61037123f10", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -72,7 +72,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for `extern crate` and `use` items annotated with\n     /// lint attributes.\n     ///\n-    /// This lint whitelists `#[allow(unused_imports)]`, `#[allow(deprecated)]` and\n+    /// This lint permits `#[allow(unused_imports)]`, `#[allow(deprecated)]` and\n     /// `#[allow(unreachable_pub)]` on `use` items and `#[allow(unused_imports)]` on\n     /// `extern crate` items with a `#[macro_use]` attribute.\n     ///\n@@ -294,7 +294,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                         if let Some(ident) = attr.ident() {\n                             match &*ident.as_str() {\n                                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                    // whitelist `unused_imports`, `deprecated` and `unreachable_pub` for `use` items\n+                                    // permit `unused_imports`, `deprecated` and `unreachable_pub` for `use` items\n                                     // and `unused_imports` for `extern crate` items with `macro_use`\n                                     for lint in lint_list {\n                                         match item.kind {"}, {"sha": "cbc93d772dd91b04b344ae2dd9003a657e3a2aad", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -16,7 +16,7 @@ declare_clippy_lint! {\n     /// **Known problems:** False negatives: We had some false positives regarding\n     /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n     /// of `x.pop() && x.pop()`), so we removed matching any function or method\n-    /// calls. We may introduce a whitelist of known pure functions in the future.\n+    /// calls. We may introduce a list of known pure functions in the future.\n     ///\n     /// **Example:**\n     /// ```rust"}, {"sha": "29e5d4d1664986fbed4e31198c5f2e770359a950", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         // Allow `Borrow` or functions to be taken by value\n         let borrow_trait = need!(get_trait_def_id(cx, &paths::BORROW_TRAIT));\n-        let whitelisted_traits = [\n+        let allowed_traits = [\n             need!(cx.tcx.lang_items().fn_trait()),\n             need!(cx.tcx.lang_items().fn_once_trait()),\n             need!(cx.tcx.lang_items().fn_mut_trait()),\n@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n-                if !whitelisted_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n+                if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n "}, {"sha": "7128fee9bcf5157c238e089486bdf75db299a080", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -78,7 +78,7 @@ struct ExistingName {\n     interned: SymbolStr,\n     span: Span,\n     len: usize,\n-    whitelist: &'static [&'static str],\n+    exemptions: &'static [&'static str],\n }\n \n struct SimilarNamesLocalVisitor<'a, 'tcx> {\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> SimilarNamesLocalVisitor<'a, 'tcx> {\n // this list contains lists of names that are allowed to be similar\n // the assumption is that no name is ever contained in multiple lists.\n #[rustfmt::skip]\n-const WHITELIST: &[&[&str]] = &[\n+const ALLOWED_TO_BE_SIMILAR: &[&[&str]] = &[\n     &[\"parsed\", \"parser\"],\n     &[\"lhs\", \"rhs\"],\n     &[\"tx\", \"rx\"],\n@@ -156,17 +156,17 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n }\n \n #[must_use]\n-fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n-    for &allow in WHITELIST {\n-        if whitelisted(interned_name, allow) {\n-            return Some(allow);\n+fn get_exemptions(interned_name: &str) -> Option<&'static [&'static str]> {\n+    for &list in ALLOWED_TO_BE_SIMILAR {\n+        if allowed_to_be_similar(interned_name, list) {\n+            return Some(list);\n         }\n     }\n     None\n }\n \n #[must_use]\n-fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n+fn allowed_to_be_similar(interned_name: &str, list: &[&str]) -> bool {\n     list.iter()\n         .any(|&name| interned_name.starts_with(name) || interned_name.ends_with(name))\n }\n@@ -212,7 +212,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             return;\n         }\n         for existing_name in &self.0.names {\n-            if whitelisted(&interned_name, existing_name.whitelist) {\n+            if allowed_to_be_similar(&interned_name, existing_name.exemptions) {\n                 continue;\n             }\n             let mut split_at = None;\n@@ -301,7 +301,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             return;\n         }\n         self.0.names.push(ExistingName {\n-            whitelist: get_whitelist(&interned_name).unwrap_or(&[]),\n+            exemptions: get_exemptions(&interned_name).unwrap_or(&[]),\n             interned: interned_name,\n             span: ident.span,\n             len: count,"}, {"sha": "23793678fa0e2ae7ee55a2919606b04325340381", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n \n-const ODD_FUNCTIONS_WHITELIST: [&str; 14] = [\n+const ALLOWED_ODD_FUNCTIONS: [&str; 14] = [\n     \"asin\",\n     \"asinh\",\n     \"atan\",\n@@ -109,7 +109,7 @@ impl EarlyLintPass for Precedence {\n                     if let ExprKind::Lit(ref lit) = slf.kind {\n                         match lit.kind {\n                             LitKind::Int(..) | LitKind::Float(..) => {\n-                                if ODD_FUNCTIONS_WHITELIST\n+                                if ALLOWED_ODD_FUNCTIONS\n                                     .iter()\n                                     .any(|odd_function| **odd_function == *path_segment_str)\n                                 {"}, {"sha": "68f51f0afdccd158a91da17f2ba0b845649dc15c", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -1256,7 +1256,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // don't lint for the result of methods that always return non-negative values\n     if let ExprKind::MethodCall(ref path, _, _, _) = op.kind {\n         let mut method_name = path.ident.name.as_str();\n-        let whitelisted_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n+        let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n         if_chain! {\n             if method_name == \"unwrap\";\n@@ -1267,7 +1267,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n             }\n         }\n \n-        if whitelisted_methods.iter().any(|&name| method_name == name) {\n+        if allowed_methods.iter().any(|&name| method_name == name) {\n             return;\n         }\n     }"}, {"sha": "9f87de20baff36866965bccd7c4ef87774789645", "filename": "src/tools/clippy/tests/ui/crashes/third-party/clippy.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fclippy.toml?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "previous_filename": "src/tools/clippy/tests/ui/crashes/whitelist/clippy.toml"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/tools/clippy/tests/ui/crashes/third-party/conf_allowlisted.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fconf_allowlisted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fconf_allowlisted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fthird-party%2Fconf_allowlisted.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "previous_filename": "src/tools/clippy/tests/ui/crashes/whitelist/conf_whitelisted.rs"}, {"sha": "7a9ba55590dce0c0154ead2ef1c5506915fda7e6", "filename": "src/tools/clippy/tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_pass_by_value.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -116,7 +116,7 @@ extern \"C\" fn ext(x: MaybeUninit<usize>) -> usize {\n     unsafe { x.assume_init() }\n }\n \n-// whitelist RangeArgument\n+// exempt RangeArgument\n fn range<T: ::std::ops::RangeBounds<usize>>(range: T) {\n     let _ = range.start_bound();\n }"}, {"sha": "0b471195272473cdd4d971c8fb91cf9826f7dbe0", "filename": "src/tools/clippy/tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -57,6 +57,6 @@ fn main() {\n     // The macro always negates the result of the given comparison in its\n     // internal check which automatically triggered the lint. As it's an\n     // external macro there was no chance to do anything about it which led\n-    // to a whitelisting of all external macros.\n+    // to an exempting of all external macros.\n     assert!(a_value < another_value);\n }"}, {"sha": "74601f9e4c679f096eba3a8b5401d039e08fd78c", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -11,8 +11,8 @@\n //! These values are then translated to file URLs if possible and then the\n //! destination is asserted to exist.\n //!\n-//! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n-//! but this should catch the majority of \"broken link\" cases.\n+//! A few exceptions are allowed as there's known bugs in rustdoc, but this\n+//! should catch the majority of \"broken link\" cases.\n \n use std::collections::hash_map::Entry;\n use std::collections::{HashMap, HashSet};\n@@ -118,7 +118,7 @@ fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Opti\n     }\n \n     // Unfortunately we're not 100% full of valid links today to we need a few\n-    // whitelists to get this past `make check` today.\n+    // exceptions to get this past `make check` today.\n     // FIXME(#32129)\n     if file.ends_with(\"std/io/struct.IoSlice.html\")\n         || file.ends_with(\"std/string/struct.String.html\")"}, {"sha": "7bdd78a91e7de58d61de26803d4234c91560ef20", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -73,8 +73,8 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n \n         // This is intentional -- this dependency just makes the crate available\n         // for others later on.\n-        let whitelisted = krate.starts_with(\"panic\");\n-        if toml.contains(\"name = \\\"std\\\"\") && whitelisted {\n+        let allowed = krate.starts_with(\"panic\");\n+        if toml.contains(\"name = \\\"std\\\"\") && allowed {\n             continue;\n         }\n "}, {"sha": "b7d3d428cd28340aa3ace9124f6c08885fd061a8", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -49,14 +49,14 @@ const EXCEPTIONS: &[(&str, &str)] = &[\n /// these and all their dependencies *must not* be in the exception list.\n const RUNTIME_CRATES: &[&str] = &[\"std\", \"core\", \"alloc\", \"test\", \"panic_abort\", \"panic_unwind\"];\n \n-/// Which crates to check against the whitelist?\n-const WHITELIST_CRATES: &[&str] = &[\"rustc_middle\", \"rustc_codegen_llvm\"];\n+/// Crates whose dependencies must be explicitly permitted.\n+const RESTRICTED_DEPENDENCY_CRATES: &[&str] = &[\"rustc_middle\", \"rustc_codegen_llvm\"];\n \n-/// Whitelist of crates rustc is allowed to depend on. Avoid adding to the list if possible.\n+/// Crates rustc is allowed to depend on. Avoid adding to the list if possible.\n ///\n /// This list is here to provide a speed-bump to adding a new dependency to\n /// rustc. Please check with the compiler team before adding an entry.\n-const WHITELIST: &[&str] = &[\n+const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"adler32\",\n     \"aho-corasick\",\n     \"annotate-snippets\",\n@@ -190,7 +190,7 @@ pub fn check(path: &Path, cargo: &Path, bad: &mut bool) {\n         .features(cargo_metadata::CargoOpt::AllFeatures);\n     let metadata = t!(cmd.exec());\n     check_exceptions(&metadata, bad);\n-    check_whitelist(&metadata, bad);\n+    check_dependencies(&metadata, bad);\n     check_crate_duplicate(&metadata, bad);\n }\n \n@@ -272,36 +272,37 @@ fn check_exceptions(metadata: &Metadata, bad: &mut bool) {\n     }\n }\n \n-/// Checks the dependency of `WHITELIST_CRATES` at the given path. Changes `bad` to `true` if a\n-/// check failed.\n+/// Checks the dependency of `RESTRICTED_DEPENDENCY_CRATES` at the given path. Changes `bad` to\n+/// `true` if a check failed.\n ///\n-/// Specifically, this checks that the dependencies are on the `WHITELIST`.\n-fn check_whitelist(metadata: &Metadata, bad: &mut bool) {\n-    // Check that the WHITELIST does not have unused entries.\n-    for name in WHITELIST {\n+/// Specifically, this checks that the dependencies are on the `PERMITTED_DEPENDENCIES`.\n+fn check_dependencies(metadata: &Metadata, bad: &mut bool) {\n+    // Check that the PERMITTED_DEPENDENCIES does not have unused entries.\n+    for name in PERMITTED_DEPENDENCIES {\n         if !metadata.packages.iter().any(|p| p.name == *name) {\n             println!(\n-                \"could not find whitelisted package `{}`\\n\\\n-                Remove from WHITELIST list if it is no longer used.\",\n+                \"could not find allowed package `{}`\\n\\\n+                Remove from PERMITTED_DEPENDENCIES list if it is no longer used.\",\n                 name\n             );\n             *bad = true;\n         }\n     }\n-    // Get the whitelist in a convenient form.\n-    let whitelist: HashSet<_> = WHITELIST.iter().cloned().collect();\n+    // Get the list in a convenient form.\n+    let permitted_dependencies: HashSet<_> = PERMITTED_DEPENDENCIES.iter().cloned().collect();\n \n     // Check dependencies.\n     let mut visited = BTreeSet::new();\n     let mut unapproved = BTreeSet::new();\n-    for &krate in WHITELIST_CRATES.iter() {\n+    for &krate in RESTRICTED_DEPENDENCY_CRATES.iter() {\n         let pkg = pkg_from_name(metadata, krate);\n-        let mut bad = check_crate_whitelist(&whitelist, metadata, &mut visited, pkg);\n+        let mut bad =\n+            check_crate_dependencies(&permitted_dependencies, metadata, &mut visited, pkg);\n         unapproved.append(&mut bad);\n     }\n \n     if !unapproved.is_empty() {\n-        println!(\"Dependencies not on the whitelist:\");\n+        println!(\"Dependencies not explicitly permitted:\");\n         for dep in unapproved {\n             println!(\"* {}\", dep);\n         }\n@@ -310,9 +311,9 @@ fn check_whitelist(metadata: &Metadata, bad: &mut bool) {\n }\n \n /// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n-/// the whitelist. Returns a list of illegal dependencies.\n-fn check_crate_whitelist<'a>(\n-    whitelist: &'a HashSet<&'static str>,\n+/// the list of permitted dependencies. Returns a list of disallowed dependencies.\n+fn check_crate_dependencies<'a>(\n+    permitted_dependencies: &'a HashSet<&'static str>,\n     metadata: &'a Metadata,\n     visited: &mut BTreeSet<&'a PackageId>,\n     krate: &'a Package,\n@@ -327,10 +328,10 @@ fn check_crate_whitelist<'a>(\n \n     visited.insert(&krate.id);\n \n-    // If this path is in-tree, we don't require it to be on the whitelist.\n+    // If this path is in-tree, we don't require it to be explicitly permitted.\n     if krate.source.is_some() {\n-        // If this dependency is not on `WHITELIST`, add to bad set.\n-        if !whitelist.contains(krate.name.as_str()) {\n+        // If this dependency is not on `PERMITTED_DEPENDENCIES`, add to bad set.\n+        if !permitted_dependencies.contains(krate.name.as_str()) {\n             unapproved.insert(&krate.id);\n         }\n     }\n@@ -339,7 +340,7 @@ fn check_crate_whitelist<'a>(\n     let to_check = deps_of(metadata, &krate.id);\n \n     for dep in to_check {\n-        let mut bad = check_crate_whitelist(whitelist, metadata, visited, dep);\n+        let mut bad = check_crate_dependencies(permitted_dependencies, metadata, visited, dep);\n         unapproved.append(&mut bad);\n     }\n "}, {"sha": "3af71f69d2457c162a6bd183f0609852b599fc90", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -7,7 +7,7 @@ use std::fs::read_to_string;\n use std::path::Path;\n \n // A few of those error codes can't be tested but all the others can and *should* be tested!\n-const WHITELIST: &[&str] = &[\n+const EXEMPTED_FROM_TEST: &[&str] = &[\n     \"E0183\", \"E0227\", \"E0279\", \"E0280\", \"E0311\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0456\",\n     \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0472\", \"E0473\", \"E0474\", \"E0475\", \"E0476\", \"E0479\",\n     \"E0480\", \"E0481\", \"E0482\", \"E0483\", \"E0484\", \"E0485\", \"E0486\", \"E0487\", \"E0488\", \"E0489\",\n@@ -166,7 +166,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         println!(\"Found {} error codes\", error_codes.len());\n \n         for (err_code, nb) in &error_codes {\n-            if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n+            if !*nb && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n             }\n         }"}, {"sha": "4d666a502a160eebd8aeb66b8dabc842c40d10e5", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8c30951581fa35bde0dbdd3260c5019b50421/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=d2f8c30951581fa35bde0dbdd3260c5019b50421", "patch": "@@ -3,8 +3,8 @@\n use std::fs;\n use std::path::Path;\n \n-/// List of whitelisted sources for packages.\n-const WHITELISTED_SOURCES: &[&str] = &[\"\\\"registry+https://github.com/rust-lang/crates.io-index\\\"\"];\n+/// List of allowed sources for packages.\n+const ALLOWED_SOURCES: &[&str] = &[\"\\\"registry+https://github.com/rust-lang/crates.io-index\\\"\"];\n \n /// Checks for external package sources.\n pub fn check(path: &Path, bad: &mut bool) {\n@@ -24,8 +24,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n         // Extract source value.\n         let source = line.splitn(2, '=').nth(1).unwrap().trim();\n \n-        // Ensure source is whitelisted.\n-        if !WHITELISTED_SOURCES.contains(&&*source) {\n+        // Ensure source is allowed.\n+        if !ALLOWED_SOURCES.contains(&&*source) {\n             println!(\"invalid source: {}\", source);\n             *bad = true;\n         }"}]}