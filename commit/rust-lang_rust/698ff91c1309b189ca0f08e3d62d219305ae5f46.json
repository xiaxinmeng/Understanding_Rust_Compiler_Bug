{"sha": "698ff91c1309b189ca0f08e3d62d219305ae5f46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OGZmOTFjMTMwOWIxODljYTBmMDhlM2Q2MmQyMTkzMDVhZTVmNDY=", "commit": {"author": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-01-29T02:30:53Z"}, "committer": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-01-29T02:33:12Z"}, "message": "Already implemented fn will no longer be suggested for trait implementations.", "tree": {"sha": "52839b309aab60cd528c08c97a5a303a2a969cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52839b309aab60cd528c08c97a5a303a2a969cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/698ff91c1309b189ca0f08e3d62d219305ae5f46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/698ff91c1309b189ca0f08e3d62d219305ae5f46", "html_url": "https://github.com/rust-lang/rust/commit/698ff91c1309b189ca0f08e3d62d219305ae5f46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/698ff91c1309b189ca0f08e3d62d219305ae5f46/comments", "author": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1fc6239d67708112f4f3997b104934dd11b7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1fc6239d67708112f4f3997b104934dd11b7fd", "html_url": "https://github.com/rust-lang/rust/commit/bc1fc6239d67708112f4f3997b104934dd11b7fd"}], "stats": {"total": 148, "additions": 131, "deletions": 17}, "files": [{"sha": "52ad7dd9da184962380951c6d2ddbcc0b96cebab", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 129, "deletions": 15, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/698ff91c1309b189ca0f08e3d62d219305ae5f46/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698ff91c1309b189ca0f08e3d62d219305ae5f46/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=698ff91c1309b189ca0f08e3d62d219305ae5f46", "patch": "@@ -1,22 +1,104 @@\n-\n use crate::completion::{CompletionContext, Completions};\n \n-use hir::{ self, db::HirDatabase, HasSource };\n+use ast::{ NameOwner };\n+use hir::{ self, db::HirDatabase };\n \n use ra_syntax::{ ast, ast::AstNode };\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n-    let impl_trait = ast::ItemList::cast(ctx.token.parent())\n-        .and_then(|item_list| item_list.syntax().parent())\n-        .and_then(|item_list_parent| ast::ImplBlock::cast(item_list_parent))\n-        .and_then(|impl_block| resolve_target_trait(ctx.db, &ctx.analyzer, &impl_block));\n-\n-    if let Some(x) = &impl_trait {\n-        for trait_item in x.0.items(ctx.db) {\n-            match trait_item {\n-                hir::AssocItem::Function(f) => acc.add_function_impl(ctx, f),\n-                _ => {}\n+    let item_list = ast::ItemList::cast(ctx.token.parent());\n+    let impl_block = item_list\n+        .clone()\n+        .and_then(|i| i.syntax().parent())\n+        .and_then(|p| ast::ImplBlock::cast(p));\n+\n+    if item_list.is_none() || impl_block.is_none() {\n+        return;\n+    }\n+\n+    let item_list = item_list.unwrap();\n+    let impl_block = impl_block.unwrap();\n+\n+    let target_trait = resolve_target_trait(ctx.db, &ctx.analyzer, &impl_block);\n+    if target_trait.is_none() {\n+        return;\n+    }\n+\n+    let trait_ = target_trait.unwrap();\n+\n+    let trait_items = trait_.items(ctx.db);\n+    let missing_items = trait_items\n+        .iter()\n+        .filter(|i| {\n+            match i {\n+                hir::AssocItem::Function(f) => {\n+                    let f_name = f.name(ctx.db).to_string();\n+\n+                    item_list\n+                        .impl_items()\n+                        .find(|impl_item| {\n+                            match impl_item {\n+                                ast::ImplItem::FnDef(impl_f) => {\n+                                    if let Some(n) = impl_f.name() { \n+                                        f_name == n.syntax().to_string()\n+                                    } else { \n+                                        false\n+                                    }\n+                                },\n+                                _ => false\n+                            }\n+                        }).is_none()\n+                },\n+                hir::AssocItem::Const(c) => {\n+                    let c_name = c.name(ctx.db)\n+                        .map(|f| f.to_string());\n+\n+                    if c_name.is_none() {\n+                        return false;\n+                    }\n+\n+                    let c_name = c_name.unwrap();\n+\n+                    item_list\n+                        .impl_items()\n+                        .find(|impl_item| {\n+                            match impl_item {\n+                                ast::ImplItem::ConstDef(c) => {\n+                                    if let Some(n) = c.name() { \n+                                        c_name == n.syntax().to_string()\n+                                    } else { \n+                                        false\n+                                    }\n+                                },\n+                                _ => false\n+                            }\n+                        }).is_none()\n+                },\n+                hir::AssocItem::TypeAlias(t) => {\n+                    let t_name = t.name(ctx.db).to_string();\n+\n+                    item_list\n+                        .impl_items()\n+                        .find(|impl_item| {\n+                            match impl_item {\n+                                ast::ImplItem::TypeAliasDef(t) => {\n+                                    if let Some(n) = t.name() { \n+                                        t_name == n.syntax().to_string()\n+                                    } else { \n+                                        false\n+                                    }\n+                                },\n+                                _ => false\n+                            }\n+                        }).is_none()\n+                }\n             }\n+        });\n+\n+    for item in missing_items {\n+        match item {\n+            hir::AssocItem::Function(f) => acc.add_function_impl(ctx, f),\n+            _ => {}\n         }\n     }\n }\n@@ -25,7 +107,7 @@ fn resolve_target_trait(\n     db: &impl HirDatabase,\n     analyzer: &hir::SourceAnalyzer,\n     impl_block: &ast::ImplBlock\n-) -> Option<(hir::Trait, ast::TraitDef)> {\n+) -> Option<hir::Trait> {\n     let ast_path = impl_block\n         .target_trait()\n         .map(|it| it.syntax().clone())\n@@ -34,7 +116,7 @@ fn resolve_target_trait(\n \n     match analyzer.resolve_path(db, &ast_path) {\n         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => {\n-            Some((def, def.source(db).value))\n+            Some(def)\n         }\n         _ => None,\n     }\n@@ -70,11 +152,43 @@ mod tests {\n                 label: \"fn foo()\",\n                 source_range: [138; 138),\n                 delete: [138; 138),\n-                insert: \"fn foo() { $0 }\",\n+                insert: \"fn foo() { $0}\",\n                 kind: Function,\n                 lookup: \"foo\",\n             },\n         ]\n         \"###);\n     }\n+\n+    #[test]\n+    fn hide_implemented_fn() {\n+        let completions = complete(\n+            r\"\n+            trait Test {\n+                fn foo();\n+                fn bar();\n+            }\n+\n+            struct T1;\n+\n+            impl Test for T1 {\n+                fn foo() {}\n+\n+                <|>\n+            }\n+            \",\n+        );\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"fn bar()\",\n+                source_range: [193; 193),\n+                delete: [193; 193),\n+                insert: \"fn bar() { $0}\",\n+                kind: Function,\n+                lookup: \"bar\",\n+            },\n+        ]\n+        \"###);\n+    }\n }\n\\ No newline at end of file"}, {"sha": "0689013baddac98edbae87f149109af8d1d78004", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/698ff91c1309b189ca0f08e3d62d219305ae5f46/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698ff91c1309b189ca0f08e3d62d219305ae5f46/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=698ff91c1309b189ca0f08e3d62d219305ae5f46", "patch": "@@ -129,7 +129,7 @@ impl Completions {\n         self.add_function_with_name(ctx, None, func)\n     }\n \n-    pub(crate) fn add_function_impl(&mut self, ctx: &CompletionContext, func: hir::Function) {\n+    pub(crate) fn add_function_impl(&mut self, ctx: &CompletionContext, func: &hir::Function) {\n         use crate::display::FunctionSignature;\n \n         let display = FunctionSignature::from_hir(ctx.db, func.clone());\n@@ -150,7 +150,7 @@ impl Completions {\n         \n         let snippet = {\n             let mut s = format!(\"{}\", display);\n-            s.push_str(\" { $0 }\");\n+            s.push_str(\" { $0}\");\n             s\n         };\n "}]}