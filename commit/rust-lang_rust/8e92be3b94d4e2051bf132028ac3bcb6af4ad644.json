{"sha": "8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTJiZTNiOTRkNGUyMDUxYmYxMzIwMjhhYzNiY2I2YWY0YWQ2NDQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-12T23:32:07Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-12T23:36:50Z"}, "message": "Small whitespace cleanups.", "tree": {"sha": "8bf1c836544fb0ea89cde57edb1b6ad2f261c9d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bf1c836544fb0ea89cde57edb1b6ad2f261c9d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "html_url": "https://github.com/rust-lang/rust/commit/8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e92be3b94d4e2051bf132028ac3bcb6af4ad644/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01e48748504934e27ac89b2ca12d7d626e3be42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01e48748504934e27ac89b2ca12d7d626e3be42", "html_url": "https://github.com/rust-lang/rust/commit/c01e48748504934e27ac89b2ca12d7d626e3be42"}], "stats": {"total": 17, "additions": 5, "deletions": 12}, "files": [{"sha": "ec30df1212d90def4015f20e254982ca18114762", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e92be3b94d4e2051bf132028ac3bcb6af4ad644/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e92be3b94d4e2051bf132028ac3bcb6af4ad644/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "patch": "@@ -3316,8 +3316,6 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: &ty::t) -> result_t {\n \n fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n                 b: &@ast::expr) -> result {\n-\n-\n     // First couple cases are lazy:\n     alt op {\n       ast::and. {\n@@ -3333,11 +3331,11 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n                       ty::expr_ty(bcx_tcx(cx), b));\n         let lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n         let lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n+\n         // The following line ensures that any cleanups for rhs\n         // are done within the block for rhs. This is necessary\n         // because and/or are lazy. So the rhs may never execute,\n         // and the cleanups can't be pushed into later code.\n-\n         let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n         lhs_res.bcx.build.CondBr(lhs_res.val, rhs_cx.llbb, lhs_false_cx.llbb);\n         ret join_results(cx, T_bool(),\n@@ -3356,8 +3354,8 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n                       ty::expr_ty(bcx_tcx(cx), b));\n         let lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n         let lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n-        // see the and case for an explanation\n \n+        // see the and case for an explanation\n         let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n         lhs_res.bcx.build.CondBr(lhs_res.val, lhs_true_cx.llbb, rhs_cx.llbb);\n         ret join_results(cx, T_bool(),"}, {"sha": "9b5416fdd595914d406019a1bf749bc8dac86a23", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e92be3b94d4e2051bf132028ac3bcb6af4ad644/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e92be3b94d4e2051bf132028ac3bcb6af4ad644/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=8e92be3b94d4e2051bf132028ac3bcb6af4ad644", "patch": "@@ -883,7 +883,6 @@ mod collect {\n \n \n // Type unification\n-\n mod unify {\n     fn unify(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) ->\n        ty::unify::result {\n@@ -1009,12 +1008,12 @@ mod demand {\n         } else if (adk == AUTODEREF_BLOCK_COERCE) {\n             actual_1 = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n+\n         let ty_param_substs: [mutable ty::t] = ~[mutable];\n         let ty_param_subst_var_ids: [int] = ~[];\n         for ty_param_subst: ty::t  in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n-\n             let t_0 = next_ty_var(fcx);\n             ty_param_substs += ~[mutable t_0];\n             ty_param_subst_var_ids += ~[ty::ty_var_id(fcx.ccx.tcx, t_0)];\n@@ -1370,12 +1369,11 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n         let v_def_ids = ast::variant_def_ids(v_def);\n         let tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n         let path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n-        // Take the tag type params out of `expected`.\n \n+        // Take the tag type params out of `expected`.\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tag(_, expected_tps) {\n             // Unify with the expected tag type.\n-\n             let ctor_ty =\n                 ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n                                                            path_tpot);\n@@ -1385,8 +1383,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                              NO_AUTODEREF);\n             path_tpot =\n                 {substs: some[[ty::t]](path_tpt.substs), ty: path_tpt.ty};\n-            // Get the number of arguments in this tag variant.\n \n+            // Get the number of arguments in this tag variant.\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n@@ -1417,9 +1415,6 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                 }\n             } else if (subpats_len > 0u) {\n                 // TODO: note definition of tag variant\n-                // TODO (issue #448): Wrap a #fmt string over multiple\n-                // lines...\n-\n                 fcx.ccx.tcx.sess.span_fatal\n                     (pat.span, #fmt(\"this pattern has %u field%s, \\\n                                      but the corresponding \\"}]}