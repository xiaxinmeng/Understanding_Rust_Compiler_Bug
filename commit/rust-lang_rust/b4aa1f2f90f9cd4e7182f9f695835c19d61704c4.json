{"sha": "b4aa1f2f90f9cd4e7182f9f695835c19d61704c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YWExZjJmOTBmOWNkNGU3MTgyZjlmNjk1ODM1YzE5ZDYxNzA0YzQ=", "commit": {"author": {"name": "Douglas Campos", "email": "qmx@qmx.me", "date": "2018-07-05T13:36:17Z"}, "committer": {"name": "Douglas Campos", "email": "qmx@qmx.me", "date": "2018-08-16T19:19:36Z"}, "message": "extract helper fn", "tree": {"sha": "236a0134d042c7b85956e8115810a35adec88105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/236a0134d042c7b85956e8115810a35adec88105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4", "html_url": "https://github.com/rust-lang/rust/commit/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4/comments", "author": {"login": "qmx", "id": 66734, "node_id": "MDQ6VXNlcjY2NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/66734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qmx", "html_url": "https://github.com/qmx", "followers_url": "https://api.github.com/users/qmx/followers", "following_url": "https://api.github.com/users/qmx/following{/other_user}", "gists_url": "https://api.github.com/users/qmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/qmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qmx/subscriptions", "organizations_url": "https://api.github.com/users/qmx/orgs", "repos_url": "https://api.github.com/users/qmx/repos", "events_url": "https://api.github.com/users/qmx/events{/privacy}", "received_events_url": "https://api.github.com/users/qmx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qmx", "id": 66734, "node_id": "MDQ6VXNlcjY2NzM0", "avatar_url": "https://avatars.githubusercontent.com/u/66734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qmx", "html_url": "https://github.com/qmx", "followers_url": "https://api.github.com/users/qmx/followers", "following_url": "https://api.github.com/users/qmx/following{/other_user}", "gists_url": "https://api.github.com/users/qmx/gists{/gist_id}", "starred_url": "https://api.github.com/users/qmx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qmx/subscriptions", "organizations_url": "https://api.github.com/users/qmx/orgs", "repos_url": "https://api.github.com/users/qmx/repos", "events_url": "https://api.github.com/users/qmx/events{/privacy}", "received_events_url": "https://api.github.com/users/qmx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af727dfd3f86ab7f907fadccde013bfaa99fc48c", "url": "https://api.github.com/repos/rust-lang/rust/commits/af727dfd3f86ab7f907fadccde013bfaa99fc48c", "html_url": "https://github.com/rust-lang/rust/commit/af727dfd3f86ab7f907fadccde013bfaa99fc48c"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "958c496d9845bba7618afed9b99f3110acb691f5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa1f2f90f9cd4e7182f9f695835c19d61704c4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b4aa1f2f90f9cd4e7182f9f695835c19d61704c4", "patch": "@@ -4232,24 +4232,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n     }\n \n-    /// When name resolution fails, this method can be used to look up candidate\n-    /// entities with the expected name. It allows filtering them using the\n-    /// supplied predicate (which should be used to only accept the types of\n-    /// definitions expected e.g. traits). The lookup spans across all crates.\n-    ///\n-    /// NOTE: The method does not look into imports, but this is not a problem,\n-    /// since we report the definitions (thus, the de-aliased imports).\n-    fn lookup_import_candidates<FilterFn>(&mut self,\n+    fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n                                           lookup_name: Name,\n                                           namespace: Namespace,\n+                                          start_module: &'a ModuleData<'a>,\n                                           filter_fn: FilterFn)\n                                           -> Vec<ImportSuggestion>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let mut candidates = Vec::new();\n         let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n-        worklist.push((self.graph_root, Vec::new(), false));\n+        worklist.push((start_module, Vec::new(), false));\n \n         while let Some((in_module,\n                         path_segments,\n@@ -4318,6 +4312,23 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         candidates\n     }\n \n+    /// When name resolution fails, this method can be used to look up candidate\n+    /// entities with the expected name. It allows filtering them using the\n+    /// supplied predicate (which should be used to only accept the types of\n+    /// definitions expected e.g. traits). The lookup spans across all crates.\n+    ///\n+    /// NOTE: The method does not look into imports, but this is not a problem,\n+    /// since we report the definitions (thus, the de-aliased imports).\n+    fn lookup_import_candidates<FilterFn>(&mut self,\n+                                          lookup_name: Name,\n+                                          namespace: Namespace,\n+                                          filter_fn: FilterFn)\n+                                          -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Def) -> bool\n+    {\n+        self.lookup_import_candidates_from_module(lookup_name, namespace, self.graph_root, filter_fn)\n+    }\n+\n     fn find_module(&mut self,\n                    module_def: Def)\n                    -> Option<(Module<'a>, ImportSuggestion)>"}]}