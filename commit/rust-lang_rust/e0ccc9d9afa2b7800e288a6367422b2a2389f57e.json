{"sha": "e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwY2NjOWQ5YWZhMmI3ODAwZTI4OGE2MzY3NDIyYjJhMjM4OWY1N2U=", "commit": {"author": {"name": "Guillem Nieto", "email": "gnieto.talo@gmail.com", "date": "2018-10-18T23:15:48Z"}, "committer": {"name": "Guillem Nieto", "email": "gnieto@scopely.com", "date": "2018-11-25T22:34:23Z"}, "message": "Add slow zero-filled vector initialization lint\n\nAdd lint to detect slow zero-filled vector initialization. It detects\nwhen a vector is zero-filled with extended with `repeat(0).take(len)`\nor `resize(len, 0)`.\nThis zero-fillings are usually slower than simply using `vec![0; len]`.", "tree": {"sha": "7aa1d4780f2f22a1c38225522914920d7ddd0e7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aa1d4780f2f22a1c38225522914920d7ddd0e7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "html_url": "https://github.com/rust-lang/rust/commit/e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/comments", "author": {"login": "gnieto", "id": 4637936, "node_id": "MDQ6VXNlcjQ2Mzc5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/4637936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnieto", "html_url": "https://github.com/gnieto", "followers_url": "https://api.github.com/users/gnieto/followers", "following_url": "https://api.github.com/users/gnieto/following{/other_user}", "gists_url": "https://api.github.com/users/gnieto/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnieto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnieto/subscriptions", "organizations_url": "https://api.github.com/users/gnieto/orgs", "repos_url": "https://api.github.com/users/gnieto/repos", "events_url": "https://api.github.com/users/gnieto/events{/privacy}", "received_events_url": "https://api.github.com/users/gnieto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnieto", "id": 4637936, "node_id": "MDQ6VXNlcjQ2Mzc5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/4637936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnieto", "html_url": "https://github.com/gnieto", "followers_url": "https://api.github.com/users/gnieto/followers", "following_url": "https://api.github.com/users/gnieto/following{/other_user}", "gists_url": "https://api.github.com/users/gnieto/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnieto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnieto/subscriptions", "organizations_url": "https://api.github.com/users/gnieto/orgs", "repos_url": "https://api.github.com/users/gnieto/repos", "events_url": "https://api.github.com/users/gnieto/events{/privacy}", "received_events_url": "https://api.github.com/users/gnieto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69d09fbfc6fe10dd20cf27f737e7ff6175e2c642", "url": "https://api.github.com/repos/rust-lang/rust/commits/69d09fbfc6fe10dd20cf27f737e7ff6175e2c642", "html_url": "https://github.com/rust-lang/rust/commit/69d09fbfc6fe10dd20cf27f737e7ff6175e2c642"}], "stats": {"total": 471, "additions": 471, "deletions": 0}, "files": [{"sha": "cf754d4866773ba4b70efdbd445f3791d5862a6e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "patch": "@@ -190,6 +190,7 @@ pub mod replace_consts;\n pub mod returns;\n pub mod serde_api;\n pub mod shadow;\n+pub mod slow_vector_initialization;\n pub mod strings;\n pub mod suspicious_trait_impl;\n pub mod swap;\n@@ -459,6 +460,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box non_copy_const::NonCopyConst);\n     reg.register_late_lint_pass(box ptr_offset_with_cast::Pass);\n     reg.register_late_lint_pass(box redundant_clone::RedundantClone);\n+    reg.register_late_lint_pass(box slow_vector_initialization::Pass);\n \n     reg.register_lint_group(\"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -980,6 +982,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,\n+        slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n         trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         types::BOX_VEC,\n         vec::USELESS_VEC,"}, {"sha": "52855031a5a2e63791363dcef0699e1f82c50bed", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::hir::*;\n+use if_chain::if_chain;\n+use crate::syntax_pos::symbol::Symbol;\n+use crate::syntax::ast::{LitKind, NodeId};\n+use crate::syntax::source_map::Span;\n+use crate::utils::{match_qpath, span_lint_and_then, SpanlessEq};\n+use crate::utils::get_enclosing_block;\n+use crate::rustc_errors::{Applicability};\n+\n+/// **What it does:** Checks slow zero-filled vector initialization\n+///\n+/// **Why is this bad?** This structures are non-idiomatic and less efficient than simply using\n+/// `vec![len; 0]`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let mut vec1 = Vec::with_capacity(len);\n+/// vec1.resize(len, 0);\n+///\n+/// let mut vec2 = Vec::with_capacity(len);\n+/// vec2.extend(repeat(0).take(len))\n+/// ```\n+declare_clippy_lint! {\n+    pub SLOW_VECTOR_INITIALIZATION,\n+    perf,\n+    \"slow or unsafe vector initialization\"\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SLOW_VECTOR_INITIALIZATION)\n+    }\n+}\n+\n+/// VecInitialization contains data regarding a vector initialized with `with_capacity` and then\n+/// assigned to a variable. For example, `let mut vec = Vec::with_capacity(0)` or\n+/// `vec = Vec::with_capacity(0)`\n+struct VecInitialization<'tcx> {\n+    /// Symbol of the local variable name\n+    variable_name: Symbol,\n+\n+    /// Reference to the expression which initializes the vector\n+    initialization_expr: &'tcx Expr,\n+\n+    /// Reference to the expression used as argument on `with_capacity` call. This is used\n+    /// to only match slow zero-filling idioms of the same length than vector initialization.\n+    len_expr: &'tcx Expr,\n+}\n+\n+/// Type of slow initialization\n+enum InitializationType<'tcx> {\n+    /// Extend is a slow initialization with the form `vec.extend(repeat(0).take(..))`\n+    Extend(&'tcx Expr),\n+\n+    /// Resize is a slow initialization with the form `vec.resize(.., 0)`\n+    Resize(&'tcx Expr),\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n+        if_chain! {\n+            if let ExprKind::Assign(ref left, ref right) = expr.node;\n+\n+            // Extract variable name\n+            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node;\n+            if let Some(variable_name) = path.segments.get(0);\n+\n+            // Extract len argument\n+            if let Some(ref len_arg) = Pass::is_vec_with_capacity(right);\n+\n+            then {\n+                let vi = VecInitialization {\n+                    variable_name: variable_name.ident.name,\n+                    initialization_expr: right,\n+                    len_expr: len_arg,\n+                };\n+\n+                Pass::search_slow_zero_filling(cx, vi, expr.id, expr.span);\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+        // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n+        if_chain! {\n+            if let StmtKind::Decl(ref decl, _) = stmt.node;\n+            if let DeclKind::Local(ref local) = decl.node;\n+            if let PatKind::Binding(BindingAnnotation::Mutable, _, variable_name, None) = local.pat.node;\n+            if let Some(ref init) = local.init;\n+            if let Some(ref len_arg) = Pass::is_vec_with_capacity(init);\n+\n+            then {\n+                let vi = VecInitialization {\n+                    variable_name: variable_name.name,\n+                    initialization_expr: init,\n+                    len_expr: len_arg,\n+                };\n+\n+                Pass::search_slow_zero_filling(cx, vi, stmt.node.id(), stmt.span);\n+            }\n+        }\n+    }\n+}\n+\n+impl Pass {\n+    /// Checks if the given expression is `Vec::with_capacity(..)`. It will return the expression\n+    /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n+    fn is_vec_with_capacity(expr: &Expr) -> Option<&Expr> {\n+        if_chain! {\n+            if let ExprKind::Call(ref func, ref args) = expr.node;\n+            if let ExprKind::Path(ref path) = func.node;\n+            if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n+            if args.len() == 1;\n+\n+            then {\n+                return Some(&args[0]);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Search for slow zero filling vector initialization for the given vector\n+    fn search_slow_zero_filling<'tcx>(\n+        cx: &LateContext<'_, 'tcx>,\n+        vec_initialization: VecInitialization<'tcx>,\n+        parent_node: NodeId,\n+        parent_span: Span\n+    ) {\n+        let enclosing_body = get_enclosing_block(cx, parent_node);\n+\n+        if enclosing_body.is_none() {\n+            return;\n+        }\n+\n+        let mut v = SlowInitializationVisitor {\n+            cx,\n+            vec_ini: vec_initialization,\n+            slow_expression: None,\n+            initialization_found: false,\n+        };\n+\n+        v.visit_block(enclosing_body.unwrap());\n+\n+        if let Some(ref repeat_expr) = v.slow_expression {\n+            span_lint_and_then(\n+                cx,\n+                SLOW_VECTOR_INITIALIZATION,\n+                parent_span,\n+                \"detected slow zero-filling initialization\",\n+                |db| {\n+                    db.span_suggestion_with_applicability(v.vec_ini.initialization_expr.span, \"consider replacing with\", \"vec![0; ..]\".to_string(), Applicability::Unspecified);\n+\n+                    match repeat_expr {\n+                        InitializationType::Extend(e) => {\n+                            db.span_note(e.span, \"extended here with .. 0\");\n+                        },\n+                        InitializationType::Resize(e) => {\n+                            db.span_note(e.span, \"resize here with .. 0\");\n+                        }\n+                    }\n+                }\n+            );\n+        }\n+    }\n+}\n+\n+/// SlowInitializationVisitor searches for slow zero filling vector initialization, for the given\n+/// vector.\n+struct SlowInitializationVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+\n+    /// Contains the information\n+    vec_ini: VecInitialization<'tcx>,\n+\n+    /// Contains, if found, the slow initialization expression\n+    slow_expression: Option<InitializationType<'tcx>>,\n+\n+    /// true if the initialization of the vector has been found on the visited block\n+    initialization_found: bool,\n+}\n+\n+impl<'a, 'tcx> SlowInitializationVisitor<'a, 'tcx> {\n+    /// Checks if the given expression is extending a vector with `repeat(0).take(..)`\n+    fn search_slow_extend_filling(&mut self, expr: &'tcx Expr) {\n+        if_chain! {\n+            if self.initialization_found;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if match_qpath(&qpath_subj, &[&self.vec_ini.variable_name.to_string()]);\n+            if path.ident.name == \"extend\";\n+            if let Some(ref extend_arg) = args.get(1);\n+            if self.is_repeat_take(extend_arg);\n+\n+            then {\n+                self.slow_expression = Some(InitializationType::Extend(expr));\n+            }\n+        }\n+    }\n+\n+    /// Checks if the given expression is resizing a vector with 0\n+    fn search_slow_resize_filling(&mut self, expr: &'tcx Expr) {\n+        if_chain! {\n+            if self.initialization_found;\n+            if let ExprKind::MethodCall(ref path, _, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath_subj) = args[0].node;\n+            if match_qpath(&qpath_subj, &[&self.vec_ini.variable_name.to_string()]);\n+            if path.ident.name == \"resize\";\n+            if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n+\n+            // Check that is filled with 0\n+            if let ExprKind::Lit(ref lit) = fill_arg.node;\n+            if let LitKind::Int(0, _) = lit.node;\n+\n+            // Check that len expression is equals to `with_capacity` expression\n+            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_ini.len_expr);\n+\n+            then {\n+                self.slow_expression = Some(InitializationType::Resize(expr));\n+            }\n+        }\n+    }\n+\n+    /// Returns `true` if give expression is `repeat(0).take(...)`\n+    fn is_repeat_take(&self, expr: &Expr) -> bool {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.node;\n+            if take_path.ident.name == \"take\";\n+\n+            // Check that take is applied to `repeat(0)`\n+            if let Some(ref repeat_expr) = take_args.get(0);\n+            if self.is_repeat_zero(repeat_expr);\n+\n+            // Check that len expression is equals to `with_capacity` expression\n+            if let Some(ref len_arg) = take_args.get(1);\n+            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_ini.len_expr);\n+\n+            then {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// Returns `true` if given expression is `repeat(0)`\n+    fn is_repeat_zero(&self, expr: &Expr) -> bool {\n+        if_chain! {\n+            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.node;\n+            if let ExprKind::Path(ref qpath_repeat) = fn_expr.node;\n+            if match_qpath(&qpath_repeat, &[\"repeat\"]);\n+            if let Some(ref repeat_arg) = repeat_args.get(0);\n+            if let ExprKind::Lit(ref lit) = repeat_arg.node;\n+            if let LitKind::Int(0, _) = lit.node;\n+\n+            then {\n+                return true\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SlowInitializationVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        // Stop the search if we already found a slow zero-filling initialization\n+        if self.slow_expression.is_some() {\n+            return\n+        }\n+\n+        // Skip all the expressions previous to the vector initialization\n+        if self.vec_ini.initialization_expr.id == expr.id {\n+            self.initialization_found = true;\n+        }\n+        \n+        self.search_slow_extend_filling(expr);\n+        self.search_slow_resize_filling(expr);\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "f79abe8327e0a1cbd94baa6249808dc159592c8c", "filename": "tests/ui/slow_vector_initialization.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.rs?ref=e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::repeat;\n+\n+fn main() {\n+    resize_vector();\n+    extend_vector();\n+    mixed_extend_resize_vector();\n+}\n+\n+fn extend_vector() {\n+    // Extend with constant expression\n+    let len = 300;\n+    let mut vec1 = Vec::with_capacity(len);\n+    vec1.extend(repeat(0).take(len));\n+\n+    // Extend with len expression\n+    let mut vec2 = Vec::with_capacity(len - 10);\n+    vec2.extend(repeat(0).take(len - 10));\n+\n+    // Extend with mismatching expression should not be warned\n+    let mut vec3 = Vec::with_capacity(24322);\n+    vec3.extend(repeat(0).take(2));\n+}\n+\n+fn mixed_extend_resize_vector() {\n+    // Mismatching len\n+    let mut mismatching_len = Vec::with_capacity(30);\n+\n+    // Slow initialization\n+    let mut resized_vec = Vec::with_capacity(30);\n+    let mut extend_vec = Vec::with_capacity(30);\n+\n+    resized_vec.resize(30, 0);\n+    mismatching_len.extend(repeat(0).take(40));\n+    extend_vec.extend(repeat(0).take(30));\n+}\n+\n+fn resize_vector() {\n+    // Resize with constant expression\n+    let len = 300;\n+    let mut vec1 = Vec::with_capacity(len);\n+    vec1.resize(len, 0);\n+\n+    // Resize mismatch len\n+    let mut vec2 = Vec::with_capacity(200);\n+    vec2.resize(10, 0);\n+\n+    // Resize with len expression\n+    let mut vec3 = Vec::with_capacity(len - 10);\n+    vec3.resize(len - 10, 0);\n+\n+    // Reinitialization should be warned\n+    vec1 = Vec::with_capacity(10);\n+    vec1.resize(10, 0);\n+}"}, {"sha": "4941794d541a83215d40b158f0b91b0bd5386ae1", "filename": "tests/ui/slow_vector_initialization.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.stderr?ref=e0ccc9d9afa2b7800e288a6367422b2a2389f57e", "patch": "@@ -0,0 +1,101 @@\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:21:5\n+   |\n+21 |     let mut vec1 = Vec::with_capacity(len);\n+   |     ^^^^^^^^^^^^^^^-----------------------^\n+   |                    |\n+   |                    help: consider replacing with: `vec![0; ..]`\n+   |\n+   = note: `-D clippy::slow-vector-initialization` implied by `-D warnings`\n+note: extended here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:22:5\n+   |\n+22 |     vec1.extend(repeat(0).take(len));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:25:5\n+   |\n+25 |     let mut vec2 = Vec::with_capacity(len - 10);\n+   |     ^^^^^^^^^^^^^^^----------------------------^\n+   |                    |\n+   |                    help: consider replacing with: `vec![0; ..]`\n+   |\n+note: extended here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:26:5\n+   |\n+26 |     vec2.extend(repeat(0).take(len - 10));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:38:5\n+   |\n+38 |     let mut resized_vec = Vec::with_capacity(30);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^----------------------^\n+   |                           |\n+   |                           help: consider replacing with: `vec![0; ..]`\n+   |\n+note: resize here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:41:5\n+   |\n+41 |     resized_vec.resize(30, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:39:5\n+   |\n+39 |     let mut extend_vec = Vec::with_capacity(30);\n+   |     ^^^^^^^^^^^^^^^^^^^^^----------------------^\n+   |                          |\n+   |                          help: consider replacing with: `vec![0; ..]`\n+   |\n+note: extended here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:43:5\n+   |\n+43 |     extend_vec.extend(repeat(0).take(30));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:49:5\n+   |\n+49 |     let mut vec1 = Vec::with_capacity(len);\n+   |     ^^^^^^^^^^^^^^^-----------------------^\n+   |                    |\n+   |                    help: consider replacing with: `vec![0; ..]`\n+   |\n+note: resize here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:50:5\n+   |\n+50 |     vec1.resize(len, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:57:5\n+   |\n+57 |     let mut vec3 = Vec::with_capacity(len - 10);\n+   |     ^^^^^^^^^^^^^^^----------------------------^\n+   |                    |\n+   |                    help: consider replacing with: `vec![0; ..]`\n+   |\n+note: resize here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:58:5\n+   |\n+58 |     vec3.resize(len - 10, 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: detected slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:61:5\n+   |\n+61 |     vec1 = Vec::with_capacity(10);\n+   |     ^^^^^^^----------------------\n+   |            |\n+   |            help: consider replacing with: `vec![0; ..]`\n+   |\n+note: resize here with .. 0\n+  --> $DIR/slow_vector_initialization.rs:62:5\n+   |\n+62 |     vec1.resize(10, 0);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/slow_vector_initialization.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e0ccc9d9afa2b7800e288a6367422b2a2389f57e/tests%2Fui%2Fslow_vector_initialization.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fslow_vector_initialization.stdout?ref=e0ccc9d9afa2b7800e288a6367422b2a2389f57e"}]}