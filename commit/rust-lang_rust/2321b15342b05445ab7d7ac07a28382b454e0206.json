{"sha": "2321b15342b05445ab7d7ac07a28382b454e0206", "node_id": "C_kwDOAAsO6NoAKDIzMjFiMTUzNDJiMDU0NDVhYjdkN2FjMDdhMjgzODJiNDU0ZTAyMDY", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-24T20:07:22Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:57Z"}, "message": "Differentiate between not multithreading and temp disabling race detection", "tree": {"sha": "fbf0904fa0a4253b275c1f80484c32a3c76cc475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbf0904fa0a4253b275c1f80484c32a3c76cc475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2321b15342b05445ab7d7ac07a28382b454e0206", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRF0ACgkQGBtJ+fOP\nM3SHVwwAhH8NTB4OKQHzKbRZqAwq+A6pqG8h0xfE03Hf1rVFhR5wOCY7FGp1klHS\nNMHlu701ja7xCwKdYChPH3yNmFVrfDbFydGZVPYiC2EOKOBx1eM7kd1lz/q3cEiV\n3lHLSFEGLyPTh2JoBo6hc7XhvTmPPdRrtJNRlEjGbgPoxHeFnN6rz7/qFU4KC29z\nXBzB4y25PAqM2IK5U4La/chPm/2nJpEcjcQgDBbOT9JoD5uKHzg4fqYRMw6y86T4\nikDrjJ1qHya0ZmRrKmKlL0kC43R2L6GbDlbehBOYDR2e0TFqNyO0NI4oeD3aTiqS\nub2XAzUwwOvEe2K0Qy+eyAqQXXSVk1rapdf5aYNrS6gWS0hDZ+sceIbmBJmAzWA2\nWzdT9ZikZRW9KkloT8aC4vnGHxqtMB4Syh5xMjYFp48Lzxj4pckIvwS530qfOuFc\n2FGQsKWTCS71Shjm8rpHcHwOMF2GD4VSPjRFttMITrjW5c7nsc/q0rtjkmKnxg4b\nE9+NtZLT\n=c5Hx\n-----END PGP SIGNATURE-----", "payload": "tree fbf0904fa0a4253b275c1f80484c32a3c76cc475\nparent 7dcb19ead429e526afac7800a0b90f2b39cfa4f1\nauthor Andy Wang <cbeuw.andy@gmail.com> 1653422842 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539357 +0100\n\nDifferentiate between not multithreading and temp disabling race detection\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2321b15342b05445ab7d7ac07a28382b454e0206", "html_url": "https://github.com/rust-lang/rust/commit/2321b15342b05445ab7d7ac07a28382b454e0206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2321b15342b05445ab7d7ac07a28382b454e0206/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dcb19ead429e526afac7800a0b90f2b39cfa4f1", "html_url": "https://github.com/rust-lang/rust/commit/7dcb19ead429e526afac7800a0b90f2b39cfa4f1"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "7ac2ed615a11fb62bbdb80e681e2a0c10e52b00d", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2321b15342b05445ab7d7ac07a28382b454e0206/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2321b15342b05445ab7d7ac07a28382b454e0206/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=2321b15342b05445ab7d7ac07a28382b454e0206", "patch": "@@ -445,14 +445,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     #[inline]\n     fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_atomic_access.set(true);\n+        }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n+            data_race.ongoing_atomic_access.set(false);\n         }\n         result\n     }\n@@ -466,14 +464,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n     ) -> R {\n         let this = self.eval_context_mut();\n-        let old = if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.replace(false)\n-        } else {\n-            false\n-        };\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_atomic_access.set(true);\n+        }\n         let result = op(this);\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.multi_threaded.set(old);\n+            data_race.ongoing_atomic_access.set(false);\n         }\n         result\n     }\n@@ -923,7 +919,7 @@ impl VClockAlloc {\n     }\n \n     /// Detect data-races for an unsynchronized read operation, will not perform\n-    /// data-race detection if `multi-threaded` is false, either due to no threads\n+    /// data-race detection if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n     /// atomic read operations.\n@@ -933,7 +929,7 @@ impl VClockAlloc {\n         range: AllocRange,\n         global: &GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if global.multi_threaded.get() {\n+        if global.race_detecting() {\n             let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n@@ -962,7 +958,7 @@ impl VClockAlloc {\n         write_type: WriteType,\n         global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if global.multi_threaded.get() {\n+        if global.race_detecting() {\n             let (index, clocks) = global.current_thread_state();\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n@@ -983,7 +979,7 @@ impl VClockAlloc {\n     }\n \n     /// Detect data-races for an unsynchronized write operation, will not perform\n-    /// data-race threads if `multi-threaded` is false, either due to no threads\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn write<'tcx>(\n@@ -996,7 +992,7 @@ impl VClockAlloc {\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n-    /// data-race threads if `multi-threaded` is false, either due to no threads\n+    /// data-race threads if `race_detecting()` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n     pub fn deallocate<'tcx>(\n@@ -1026,7 +1022,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.machine.data_race {\n-            if data_race.multi_threaded.get() {\n+            if data_race.race_detecting() {\n                 let size = place.layout.size;\n                 let (alloc_id, base_offset, _tag) = this.ptr_get_alloc_id(place.ptr)?;\n                 // Load and log the atomic operation.\n@@ -1116,6 +1112,10 @@ pub struct GlobalState {\n     /// any data-races.\n     multi_threaded: Cell<bool>,\n \n+    /// A flag to mark we are currently performing\n+    /// an atomic access to supress data race detection\n+    ongoing_atomic_access: Cell<bool>,\n+\n     /// Mapping of a vector index to a known set of thread\n     /// clocks, this is not directly mapping from a thread id\n     /// since it may refer to multiple threads.\n@@ -1167,6 +1167,7 @@ impl GlobalState {\n     pub fn new() -> Self {\n         let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n+            ongoing_atomic_access: Cell::new(false),\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n             thread_info: RefCell::new(IndexVec::new()),\n@@ -1192,6 +1193,13 @@ impl GlobalState {\n         global_state\n     }\n \n+    // We perform data race detection when there are more than 1 active thread\n+    // and we are not currently in the middle of an atomic acces where data race\n+    // is impossible\n+    fn race_detecting(&self) -> bool {\n+        self.multi_threaded.get() && !self.ongoing_atomic_access.get()\n+    }\n+\n     // Try to find vector index values that can potentially be re-used\n     // by a new thread instead of a new vector index being created.\n     fn find_vector_index_reuse_candidate(&self) -> Option<VectorIdx> {"}]}