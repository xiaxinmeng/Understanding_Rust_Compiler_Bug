{"sha": "3003d05a8b351031596eb5952746b2c80982952e", "node_id": "C_kwDOAAsO6NoAKDMwMDNkMDVhOGIzNTEwMzE1OTZlYjU5NTI3NDZiMmM4MDk4Mjk1MmU", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-05-29T18:07:06Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-05-29T18:16:18Z"}, "message": "disable some layout optimizations for unsizable structs", "tree": {"sha": "85e7ebbd50609973118f0200c91f2afec09acb03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e7ebbd50609973118f0200c91f2afec09acb03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3003d05a8b351031596eb5952746b2c80982952e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3003d05a8b351031596eb5952746b2c80982952e", "html_url": "https://github.com/rust-lang/rust/commit/3003d05a8b351031596eb5952746b2c80982952e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3003d05a8b351031596eb5952746b2c80982952e/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381b778d27e74e4fc8cc161af5a45d7bee572f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/381b778d27e74e4fc8cc161af5a45d7bee572f47", "html_url": "https://github.com/rust-lang/rust/commit/381b778d27e74e4fc8cc161af5a45d7bee572f47"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "73f9deb3143a708006deac00d802740b8f5e17d3", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3003d05a8b351031596eb5952746b2c80982952e/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3003d05a8b351031596eb5952746b2c80982952e/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=3003d05a8b351031596eb5952746b2c80982952e", "patch": "@@ -57,48 +57,54 @@ pub trait LayoutCalculator {\n         // run and bias niches to the right and then check which one is closer to one of the struct's\n         // edges.\n         if let Some(layout) = &layout {\n-            if let Some(niche) = layout.largest_niche {\n-                let head_space = niche.offset.bytes();\n-                let niche_length = niche.value.size(dl).bytes();\n-                let tail_space = layout.size.bytes() - head_space - niche_length;\n-\n-                // This may end up doing redundant work if the niche is already in the last field\n-                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n-                // the unpadded size so we try anyway.\n-                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n-                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n-                        .expect(\"alt layout should always work\");\n-                    let niche = alt_layout\n-                        .largest_niche\n-                        .expect(\"alt layout should have a niche like the regular one\");\n-                    let alt_head_space = niche.offset.bytes();\n-                    let alt_niche_len = niche.value.size(dl).bytes();\n-                    let alt_tail_space = alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n-\n-                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n-\n-                    let prefer_alt_layout =\n-                        alt_head_space > head_space && alt_head_space > tail_space;\n-\n-                    debug!(\n-                        \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n-                        layout: {}\\n\\\n-                        alt_layout: {}\\n\",\n-                        layout.size.bytes(),\n-                        head_space,\n-                        niche_length,\n-                        tail_space,\n-                        alt_head_space,\n-                        alt_niche_len,\n-                        alt_tail_space,\n-                        layout.fields.count(),\n-                        prefer_alt_layout,\n-                        format_field_niches(&layout, &fields, &dl),\n-                        format_field_niches(&alt_layout, &fields, &dl),\n-                    );\n-\n-                    if prefer_alt_layout {\n-                        return Some(alt_layout);\n+            // Don't try to calculate an end-biased layout for unsizable structs,\n+            // otherwise we could end up with different layouts for\n+            // Foo<Type> and Foo<dyn Trait> which would break unsizing\n+            if !matches!(kind, StructKind::MaybeUnsized) {\n+                if let Some(niche) = layout.largest_niche {\n+                    let head_space = niche.offset.bytes();\n+                    let niche_length = niche.value.size(dl).bytes();\n+                    let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                    // This may end up doing redundant work if the niche is already in the last field\n+                    // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                    // the unpadded size so we try anyway.\n+                    if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                        let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n+                            .expect(\"alt layout should always work\");\n+                        let niche = alt_layout\n+                            .largest_niche\n+                            .expect(\"alt layout should have a niche like the regular one\");\n+                        let alt_head_space = niche.offset.bytes();\n+                        let alt_niche_len = niche.value.size(dl).bytes();\n+                        let alt_tail_space =\n+                            alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n+\n+                        debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                        let prefer_alt_layout =\n+                            alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                        debug!(\n+                            \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n+                            layout: {}\\n\\\n+                            alt_layout: {}\\n\",\n+                            layout.size.bytes(),\n+                            head_space,\n+                            niche_length,\n+                            tail_space,\n+                            alt_head_space,\n+                            alt_niche_len,\n+                            alt_tail_space,\n+                            layout.fields.count(),\n+                            prefer_alt_layout,\n+                            format_field_niches(&layout, &fields, &dl),\n+                            format_field_niches(&alt_layout, &fields, &dl),\n+                        );\n+\n+                        if prefer_alt_layout {\n+                            return Some(alt_layout);\n+                        }\n                     }\n                 }\n             }"}]}