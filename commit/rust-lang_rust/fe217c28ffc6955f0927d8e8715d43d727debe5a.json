{"sha": "fe217c28ffc6955f0927d8e8715d43d727debe5a", "node_id": "C_kwDOAAsO6NoAKGZlMjE3YzI4ZmZjNjk1NWYwOTI3ZDhlODcxNWQ0M2Q3MjdkZWJlNWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T02:45:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T02:45:13Z"}, "message": "Auto merge of #102292 - fee1-dead-contrib:rollup-61ptdkt, r=fee1-dead\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #101851 (Clean up (sub)diagnostic derives)\n - #102244 (Only generate closure def id for async fns with body)\n - #102263 (Clarify Iterator::rposition code example)\n - #102280 (rustdoc: clean up `.out-of-band`/`.in-band` CSS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7985619ad60d5d8c690b6d4b54a1ddb609fe43cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7985619ad60d5d8c690b6d4b54a1ddb609fe43cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe217c28ffc6955f0927d8e8715d43d727debe5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe217c28ffc6955f0927d8e8715d43d727debe5a", "html_url": "https://github.com/rust-lang/rust/commit/fe217c28ffc6955f0927d8e8715d43d727debe5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe217c28ffc6955f0927d8e8715d43d727debe5a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "html_url": "https://github.com/rust-lang/rust/commit/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5"}, {"sha": "a7d45de3227c5cbba9c89e4ee76ed8929030cd72", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d45de3227c5cbba9c89e4ee76ed8929030cd72", "html_url": "https://github.com/rust-lang/rust/commit/a7d45de3227c5cbba9c89e4ee76ed8929030cd72"}], "stats": {"total": 2037, "additions": 1097, "deletions": 940}, "files": [{"sha": "d9b18d68e537f3b2250da035f28030fade1f8cf9", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1055,9 +1055,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         asyncness: Async,\n         body: Option<&Block>,\n     ) -> hir::BodyId {\n-        let closure_id = match asyncness {\n-            Async::Yes { closure_id, .. } => closure_id,\n-            Async::No => return self.lower_fn_body_block(span, decl, body),\n+        let (closure_id, body) = match (asyncness, body) {\n+            (Async::Yes { closure_id, .. }, Some(body)) => (closure_id, body),\n+            _ => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1199,16 +1199,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 parameters.push(new_parameter);\n             }\n \n-            let body_span = body.map_or(span, |b| b.span);\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n                 closure_id,\n                 None,\n-                body_span,\n+                body.span,\n                 hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n-                    let user_body = this.lower_block_expr_opt(body_span, body);\n+                    let user_body = this.lower_block_expr(body);\n \n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n@@ -1240,7 +1239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             (\n                 this.arena.alloc_from_iter(parameters),\n-                this.expr(body_span, async_expr, AttrVec::new()),\n+                this.expr(body.span, async_expr, AttrVec::new()),\n             )\n         })\n     }"}, {"sha": "2aa292bbce2b6493b86c23e12d46c0fdecf7696b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 165, "deletions": 323, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,17 +1,17 @@\n #![deny(unused_must_use)]\n \n+use super::error::throw_invalid_nested_attr;\n+use super::utils::{SpannedOption, SubdiagnosticKind};\n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    invalid_nested_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n-    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+    FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n-use std::str::FromStr;\n use syn::{\n     parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n     Path, Type,\n@@ -40,10 +40,10 @@ pub(crate) struct DiagnosticDeriveBuilder {\n     pub kind: DiagnosticDeriveKind,\n     /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n     /// has the actual diagnostic message.\n-    pub slug: Option<(Path, proc_macro::Span)>,\n+    pub slug: SpannedOption<Path>,\n     /// Error codes are a optional part of the struct attribute - this is only set to detect\n     /// multiple specifications.\n-    pub code: Option<(String, proc_macro::Span)>,\n+    pub code: SpannedOption<()>,\n }\n \n impl HasFieldMap for DiagnosticDeriveBuilder {\n@@ -127,6 +127,30 @@ impl DiagnosticDeriveBuilder {\n             || is_subdiagnostic\n     }\n \n+    fn parse_subdiag_attribute(\n+        &self,\n+        attr: &Attribute,\n+    ) -> Result<(SubdiagnosticKind, Path), DiagnosticDeriveError> {\n+        let (subdiag, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n+\n+        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n+            let meta = attr.parse_meta()?;\n+            throw_invalid_attr!(attr, &meta, |diag| diag\n+                .help(\"consider creating a `Subdiagnostic` instead\"));\n+        }\n+\n+        let slug = slug.unwrap_or_else(|| match subdiag {\n+            SubdiagnosticKind::Label => parse_quote! { _subdiag::label },\n+            SubdiagnosticKind::Note => parse_quote! { _subdiag::note },\n+            SubdiagnosticKind::Help => parse_quote! { _subdiag::help },\n+            SubdiagnosticKind::Warn => parse_quote! { _subdiag::warn },\n+            SubdiagnosticKind::Suggestion { .. } => parse_quote! { _subdiag::suggestion },\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n+        });\n+\n+        Ok((subdiag, slug))\n+    }\n+\n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[diag(..)]`, such as the slug and error code. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n@@ -135,111 +159,87 @@ impl DiagnosticDeriveBuilder {\n         attr: &Attribute,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.diag;\n-        let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        let is_diag = name == \"diag\";\n-\n-        let nested = match meta {\n-            // Most attributes are lists, like `#[diag(..)]` for most cases or\n-            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n-            Meta::List(MetaList { ref nested, .. }) => nested,\n-            // Subdiagnostics without spans can be applied to the type too, and these are just\n-            // paths: `#[help]`, `#[note]` and `#[warning]`\n-            Meta::Path(_) if !is_diag => {\n-                let fn_name = if name == \"warning\" {\n-                    Ident::new(\"warn\", attr.span())\n-                } else {\n-                    Ident::new(name, attr.span())\n-                };\n-                return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // Check the kind before doing any further processing so that there aren't misleading\n-        // \"no kind specified\" errors if there are failures later.\n-        match name {\n-            \"error\" | \"lint\" => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"`error` and `lint` have been replaced by `diag`\")\n-            }),\n-            \"warn_\" => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"`warn_` have been replaced by `warning`\")\n-            }),\n-            \"diag\" | \"help\" | \"note\" | \"warning\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `diag`, `help`, `note` and `warning` are valid attributes\")\n-            }),\n-        }\n+        if name == \"diag\" {\n+            let Meta::List(MetaList { ref nested, .. }) = meta else {\n+                throw_invalid_attr!(\n+                    attr,\n+                    &meta\n+                );\n+            };\n \n-        // First nested element should always be the path, e.g. `#[diag(typeck::invalid)]` or\n-        // `#[help(typeck::another_help)]`.\n-        let mut nested_iter = nested.into_iter();\n-        if let Some(nested_attr) = nested_iter.next() {\n-            // Report an error if there are any other list items after the path.\n-            if !is_diag && nested_iter.next().is_some() {\n-                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\n-                        \"`help`, `note` and `warning` struct attributes can only have one argument\",\n-                    )\n-                });\n-            }\n+            let mut nested_iter = nested.into_iter().peekable();\n \n-            match nested_attr {\n-                NestedMeta::Meta(Meta::Path(path)) => {\n-                    if is_diag {\n-                        self.slug.set_once((path.clone(), span));\n-                    } else {\n-                        let fn_name = proc_macro2::Ident::new(name, attr.span());\n-                        return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n-                    }\n-                }\n-                NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                    if is_diag && meta.path().segments.last().unwrap().ident == \"code\" =>\n-                {\n-                    // don't error for valid follow-up attributes\n+            match nested_iter.peek() {\n+                Some(NestedMeta::Meta(Meta::Path(slug))) => {\n+                    self.slug.set_once(slug.clone(), slug.span().unwrap());\n+                    nested_iter.next();\n                 }\n-                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n-                }),\n+                Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n+                Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| diag\n+                    .help(\"a diagnostic slug is required as the first argument\")),\n+                None => throw_invalid_attr!(attr, &meta, |diag| diag\n+                    .help(\"a diagnostic slug is required as the first argument\")),\n             };\n-        }\n \n-        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-        let mut tokens = Vec::new();\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(meta) => meta,\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n+            // Remaining attributes are optional, only `code = \"..\"` at the moment.\n+            let mut tokens = TokenStream::new();\n+            for nested_attr in nested_iter {\n+                let (value, path) = match nested_attr {\n+                    NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n+                        lit: syn::Lit::Str(value),\n+                        path,\n+                        ..\n+                    })) => (value, path),\n+                    NestedMeta::Meta(Meta::Path(_)) => {\n+                        invalid_nested_attr(attr, &nested_attr)\n+                            .help(\"diagnostic slug must be the first argument\")\n+                            .emit();\n+                        continue;\n+                    }\n+                    _ => {\n+                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        continue;\n+                    }\n+                };\n \n-            let path = meta.path();\n-            let nested_name = path.segments.last().unwrap().ident.to_string();\n-            // Struct attributes are only allowed to be applied once, and the diagnostic\n-            // changes will be set in the initialisation code.\n-            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n-                let span = s.span().unwrap();\n+                let nested_name = path.segments.last().unwrap().ident.to_string();\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                let span = value.span().unwrap();\n                 match nested_name.as_str() {\n                     \"code\" => {\n-                        self.code.set_once((s.value(), span));\n-                        let code = &self.code.as_ref().map(|(v, _)| v);\n-                        tokens.push(quote! {\n+                        self.code.set_once((), span);\n+\n+                        let code = value.value();\n+                        tokens.extend(quote! {\n                             #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n                         });\n                     }\n                     _ => invalid_nested_attr(attr, &nested_attr)\n                         .help(\"only `code` is a valid nested attributes following the slug\")\n                         .emit(),\n                 }\n-            } else {\n-                invalid_nested_attr(attr, &nested_attr).emit()\n             }\n+            return Ok(tokens);\n         }\n \n-        Ok(tokens.into_iter().collect())\n+        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n+        let fn_ident = format_ident!(\"{}\", subdiag);\n+        match subdiag {\n+            SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n+                Ok(self.add_subdiagnostic(&fn_ident, slug))\n+            }\n+            SubdiagnosticKind::Label | SubdiagnosticKind::Suggestion { .. } => {\n+                throw_invalid_attr!(attr, &meta, |diag| diag\n+                    .help(\"`#[label]` and `#[suggestion]` can only be applied to fields\"));\n+            }\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n+        }\n     }\n \n     fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n@@ -303,232 +303,83 @@ impl DiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n-            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_path(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n         let diag = &self.diag;\n-\n         let meta = attr.parse_meta()?;\n \n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = ident.to_string();\n-        let name = name.as_str();\n-        match name {\n-            \"skip_arg\" => {\n-                // Don't need to do anything - by virtue of the attribute existing, the\n-                // `set_arg` call will not be generated.\n-                Ok(quote! {})\n-            }\n-            \"primary_span\" => {\n-                match self.kind {\n+        if let Meta::Path(_) = meta {\n+            let ident = &attr.path.segments.last().unwrap().ident;\n+            let name = ident.to_string();\n+            let name = name.as_str();\n+            match name {\n+                \"skip_arg\" => {\n+                    // Don't need to do anything - by virtue of the attribute existing, the\n+                    // `set_arg` call will not be generated.\n+                    return Ok(quote! {});\n+                }\n+                \"primary_span\" => match self.kind {\n                     DiagnosticDeriveKind::Diagnostic => {\n                         report_error_if_not_applied_to_span(attr, &info)?;\n \n-                        Ok(quote! {\n+                        return Ok(quote! {\n                             #diag.set_span(#binding);\n-                        })\n+                        });\n                     }\n                     DiagnosticDeriveKind::LintDiagnostic => {\n                         throw_invalid_attr!(attr, &meta, |diag| {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n-                }\n+                },\n+                \"subdiagnostic\" => return Ok(quote! { #diag.subdiagnostic(#binding); }),\n+                _ => {}\n             }\n-            \"label\" => {\n+        }\n+\n+        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n+\n+        let fn_ident = format_ident!(\"{}\", subdiag);\n+        match subdiag {\n+            SubdiagnosticKind::Label => {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n+                Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n-            \"note\" | \"help\" | \"warning\" => {\n-                let warn_ident = Ident::new(\"warn\", Span::call_site());\n-                let (ident, path) = match name {\n-                    \"note\" => (ident, parse_quote! { _subdiag::note }),\n-                    \"help\" => (ident, parse_quote! { _subdiag::help }),\n-                    \"warning\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n-                    _ => unreachable!(),\n-                };\n+            SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n                 if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n+                    Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n                 } else if type_is_unit(&info.ty) {\n-                    Ok(self.add_subdiagnostic(ident, path))\n+                    Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?\n                 }\n             }\n-            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n-                     are valid field attributes\",\n-                )\n-            }),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_list(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n-\n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_ref();\n-        match name {\n-            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n-                return self.generate_inner_field_code_suggestion(attr, info);\n-            }\n-            \"label\" | \"help\" | \"note\" | \"warning\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `label`, `help`, `note`, `warn` or `suggestion{,_short,_hidden,_verbose}` are \\\n-                     valid field attributes\",\n-                )\n-            }),\n-        }\n-\n-        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n-        // path, e.g. `#[label(typeck::label)]`.\n-        let mut nested_iter = nested.into_iter();\n-        let msg = match nested_iter.next() {\n-            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n-            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            None => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // None of these attributes should have anything following the slug.\n-        if nested_iter.next().is_some() {\n-            throw_invalid_attr!(attr, &meta);\n-        }\n-\n-        match name {\n-            \"label\" => {\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            // `warning` must be special-cased because the attribute `warn` already has meaning and\n-            // so isn't used, despite the diagnostic API being named `warn`.\n-            \"warning\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n-                .add_spanned_subdiagnostic(binding, &Ident::new(\"warn\", Span::call_site()), msg)),\n-            \"warning\" if type_is_unit(&info.ty) => {\n-                Ok(self.add_subdiagnostic(&Ident::new(\"warn\", Span::call_site()), msg))\n-            }\n-            \"note\" | \"help\" | \"warning\" => report_type_error(attr, \"`Span` or `()`\")?,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_suggestion(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let diag = &self.diag;\n-\n-        let mut meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n-\n-        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n-\n-        let mut msg = None;\n-        let mut code = None;\n-\n-        let mut nested_iter = nested.into_iter().peekable();\n-        if let Some(nested_attr) = nested_iter.peek() {\n-            if let NestedMeta::Meta(Meta::Path(path)) = nested_attr {\n-                msg = Some(path.clone());\n-            }\n-        };\n-        // Move the iterator forward if a path was found (don't otherwise so that\n-        // code/applicability can be found or an error emitted).\n-        if msg.is_some() {\n-            let _ = nested_iter.next();\n-        }\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(ref meta) => meta,\n-                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n-\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-            let nested_name = nested_name.as_str();\n-            match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    let span = meta.span().unwrap();\n-                    match nested_name {\n-                        \"code\" => {\n-                            let formatted_str = self.build_format(&s.value(), s.span());\n-                            code = Some(formatted_str);\n-                        }\n-                        \"applicability\" => {\n-                            applicability = match applicability {\n-                                Some(v) => {\n-                                    span_err(\n-                                        span,\n-                                        \"applicability cannot be set in both the field and \\\n-                                         attribute\",\n-                                    )\n-                                    .emit();\n-                                    Some(v)\n-                                }\n-                                None => match Applicability::from_str(&s.value()) {\n-                                    Ok(v) => Some(quote! { #v }),\n-                                    Err(()) => {\n-                                        span_err(span, \"invalid applicability\").emit();\n-                                        None\n-                                    }\n-                                },\n-                            }\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"only `message`, `code` and `applicability` are valid field \\\n-                                 attributes\",\n-                            )\n-                        }),\n-                    }\n+            SubdiagnosticKind::Suggestion {\n+                suggestion_kind,\n+                applicability: static_applicability,\n+                code,\n+            } => {\n+                let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+                if let Some((static_applicability, span)) = static_applicability {\n+                    applicability.set_once(quote! { #static_applicability }, span);\n                 }\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    if matches!(meta, Meta::Path(_)) {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    } else {\n-                        diag\n-                    }\n-                }),\n+\n+                let applicability = applicability\n+                    .value()\n+                    .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+                let style = suggestion_kind.to_suggestion_style();\n+\n+                Ok(quote! {\n+                    #diag.span_suggestion_with_style(\n+                        #span_field,\n+                        rustc_errors::fluent::#slug,\n+                        #code,\n+                        #applicability,\n+                        #style\n+                    );\n+                })\n             }\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n         }\n-\n-        let applicability =\n-            applicability.unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let method = format_ident!(\"span_{}\", name);\n-\n-        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n-        let msg = quote! { rustc_errors::fluent::#msg };\n-        let code = code.unwrap_or_else(|| quote! { String::new() });\n-\n-        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n     }\n \n     /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n@@ -561,7 +412,7 @@ impl DiagnosticDeriveBuilder {\n     fn span_and_applicability_of_ty(\n         &self,\n         info: FieldInfo<'_>,\n-    ) -> Result<(TokenStream, Option<TokenStream>), DiagnosticDeriveError> {\n+    ) -> Result<(TokenStream, SpannedOption<TokenStream>), DiagnosticDeriveError> {\n         match &info.ty {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n@@ -573,46 +424,37 @@ impl DiagnosticDeriveBuilder {\n                 let mut span_idx = None;\n                 let mut applicability_idx = None;\n \n+                fn type_err(span: &Span) -> Result<!, DiagnosticDeriveError> {\n+                    span_err(span.unwrap(), \"wrong types for suggestion\")\n+                        .help(\n+                            \"`#[suggestion(...)]` on a tuple field must be applied to fields \\\n+                             of type `(Span, Applicability)`\",\n+                        )\n+                        .emit();\n+                    Err(DiagnosticDeriveError::ErrorHandled)\n+                }\n+\n                 for (idx, elem) in tup.elems.iter().enumerate() {\n                     if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                        if span_idx.is_none() {\n-                            span_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n-                                 than one `Span`\"\n-                            );\n-                        }\n+                        span_idx.set_once(syn::Index::from(idx), elem.span().unwrap());\n                     } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n-                        if applicability_idx.is_none() {\n-                            applicability_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n-                                 than one Applicability\"\n-                            );\n-                        }\n+                        applicability_idx.set_once(syn::Index::from(idx), elem.span().unwrap());\n+                    } else {\n+                        type_err(&elem.span())?;\n                     }\n                 }\n \n-                if let Some(span_idx) = span_idx {\n-                    let binding = &info.binding.binding;\n-                    let span = quote!(#binding.#span_idx);\n-                    let applicability = applicability_idx\n-                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n-                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-                    return Ok((span, Some(applicability)));\n-                }\n+                let Some((span_idx, _)) = span_idx else {\n+                    type_err(&tup.span())?;\n+                };\n+                let Some((applicability_idx, applicability_span)) = applicability_idx else {\n+                    type_err(&tup.span())?;\n+                };\n+                let binding = &info.binding.binding;\n+                let span = quote!(#binding.#span_idx);\n+                let applicability = quote!(#binding.#applicability_idx);\n \n-                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\n-                        \"`#[suggestion(...)]` on a tuple field must be applied to fields of type \\\n-                         `(Span, Applicability)`\",\n-                    )\n-                });\n+                Ok((span, Some((applicability, applicability_span))))\n             }\n             // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n             _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {"}, {"sha": "6545ae086b15801e6106258d904c5c85a1a1d719", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 75, "deletions": 253, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -4,98 +4,17 @@ use crate::diagnostics::error::{\n     span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n-    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n+    FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n-use std::fmt;\n-use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n-/// Which kind of suggestion is being created?\n-#[derive(Clone, Copy)]\n-enum SubdiagnosticSuggestionKind {\n-    /// `#[suggestion]`\n-    Normal,\n-    /// `#[suggestion_short]`\n-    Short,\n-    /// `#[suggestion_hidden]`\n-    Hidden,\n-    /// `#[suggestion_verbose]`\n-    Verbose,\n-}\n-\n-impl FromStr for SubdiagnosticSuggestionKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"\" => Ok(SubdiagnosticSuggestionKind::Normal),\n-            \"_short\" => Ok(SubdiagnosticSuggestionKind::Short),\n-            \"_hidden\" => Ok(SubdiagnosticSuggestionKind::Hidden),\n-            \"_verbose\" => Ok(SubdiagnosticSuggestionKind::Verbose),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-impl SubdiagnosticSuggestionKind {\n-    pub fn to_suggestion_style(&self) -> TokenStream {\n-        match self {\n-            SubdiagnosticSuggestionKind::Normal => {\n-                quote! { rustc_errors::SuggestionStyle::ShowCode }\n-            }\n-            SubdiagnosticSuggestionKind::Short => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n-            }\n-            SubdiagnosticSuggestionKind::Hidden => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n-            }\n-            SubdiagnosticSuggestionKind::Verbose => {\n-                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n-            }\n-        }\n-    }\n-}\n-\n-/// Which kind of subdiagnostic is being created from a variant?\n-#[derive(Clone)]\n-enum SubdiagnosticKind {\n-    /// `#[label(...)]`\n-    Label,\n-    /// `#[note(...)]`\n-    Note,\n-    /// `#[help(...)]`\n-    Help,\n-    /// `#[warning(...)]`\n-    Warn,\n-    /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion { suggestion_kind: SubdiagnosticSuggestionKind, code: TokenStream },\n-    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n-    MultipartSuggestion { suggestion_kind: SubdiagnosticSuggestionKind },\n-}\n-\n-impl quote::IdentFragment for SubdiagnosticKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SubdiagnosticKind::Label => write!(f, \"label\"),\n-            SubdiagnosticKind::Note => write!(f, \"note\"),\n-            SubdiagnosticKind::Help => write!(f, \"help\"),\n-            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n-            SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                write!(f, \"multipart_suggestion_with_style\")\n-            }\n-        }\n-    }\n-\n-    fn span(&self) -> Option<proc_macro2::Span> {\n-        None\n-    }\n-}\n+use super::error::invalid_attr;\n+use super::utils::{SpannedOption, SubdiagnosticKind};\n \n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDerive<'a> {\n@@ -195,10 +114,10 @@ struct SubdiagnosticDeriveBuilder<'a> {\n     fields: HashMap<String, TokenStream>,\n \n     /// Identifier for the binding to the `#[primary_span]` field.\n-    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n-    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n-    /// `rustc_errors::Applicability::*` variant directly.\n-    applicability: Option<(TokenStream, proc_macro::Span)>,\n+    span_field: SpannedOption<proc_macro2::Ident>,\n+\n+    /// The binding to the `#[applicability]` field, if present.\n+    applicability: SpannedOption<TokenStream>,\n \n     /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n     /// during finalization if still `false`.\n@@ -217,6 +136,7 @@ struct KindsStatistics {\n     has_multipart_suggestion: bool,\n     all_multipart_suggestions: bool,\n     has_normal_suggestion: bool,\n+    all_applicabilities_static: bool,\n }\n \n impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n@@ -225,8 +145,15 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n             has_multipart_suggestion: false,\n             all_multipart_suggestions: true,\n             has_normal_suggestion: false,\n+            all_applicabilities_static: true,\n         };\n+\n         for kind in kinds {\n+            if let SubdiagnosticKind::MultipartSuggestion { applicability: None, .. }\n+            | SubdiagnosticKind::Suggestion { applicability: None, .. } = kind\n+            {\n+                ret.all_applicabilities_static = false;\n+            }\n             if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n                 ret.has_multipart_suggestion = true;\n             } else {\n@@ -246,151 +173,22 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         let mut kind_slugs = vec![];\n \n         for attr in self.variant.ast().attrs {\n-            let span = attr.span().unwrap();\n-\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-\n-            let meta = attr.parse_meta()?;\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(attr, &meta);\n-            };\n-\n-            let mut kind = match name {\n-                \"label\" => SubdiagnosticKind::Label,\n-                \"note\" => SubdiagnosticKind::Note,\n-                \"help\" => SubdiagnosticKind::Help,\n-                \"warning\" => SubdiagnosticKind::Warn,\n-                _ => {\n-                    if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::Suggestion { suggestion_kind, code: TokenStream::new() }\n-                    } else if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::MultipartSuggestion { suggestion_kind }\n-                    } else {\n-                        throw_invalid_attr!(attr, &meta);\n-                    }\n-                }\n-            };\n+            let (kind, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n \n-            let mut slug = None;\n-            let mut code = None;\n+            let Some(slug) = slug else {\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_str();\n \n-            let mut nested_iter = nested.into_iter();\n-            if let Some(nested_attr) = nested_iter.next() {\n-                match nested_attr {\n-                    NestedMeta::Meta(Meta::Path(path)) => {\n-                        slug.set_once((path.clone(), span));\n-                    }\n-                    NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                        if matches!(\n-                            meta.path().segments.last().unwrap().ident.to_string().as_str(),\n-                            \"code\" | \"applicability\"\n-                        ) =>\n-                    {\n-                        // Don't error for valid follow-up attributes.\n-                    }\n-                    nested_attr => {\n-                        throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"first argument of the attribute should be the diagnostic \\\n-                                 slug\",\n-                            )\n-                        })\n-                    }\n-                };\n-            }\n-\n-            for nested_attr in nested_iter {\n-                let meta = match nested_attr {\n-                    NestedMeta::Meta(ref meta) => meta,\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n-\n-                let span = meta.span().unwrap();\n-                let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                let nested_name = nested_name.as_str();\n-\n-                let value = match meta {\n-                    Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n-                    Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    }),\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n-\n-                match nested_name {\n-                    \"code\" => {\n-                        if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`code` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                ),\n-                            )\n-                            .emit();\n-                        }\n-                    }\n-                    \"applicability\" => {\n-                        if matches!(\n-                            kind,\n-                            SubdiagnosticKind::Suggestion { .. }\n-                                | SubdiagnosticKind::MultipartSuggestion { .. }\n-                        ) {\n-                            let value =\n-                                Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                                    span_err(span, \"invalid applicability\").emit();\n-                                    Applicability::Unspecified\n-                                });\n-                            self.applicability.set_once((quote! { #value }, span));\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                )\n-                            ).emit();\n-                        }\n-                    }\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"only `code` and `applicability` are valid nested attributes\")\n-                    }),\n-                }\n-            }\n-\n-            let Some((slug, _)) = slug else {\n                 throw_span_err!(\n-                    span,\n+                    attr.span().unwrap(),\n                     &format!(\n                         \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n                         name\n                     )\n                 );\n             };\n \n-            match kind {\n-                SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                    let Some((code, _)) = code else {\n-                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\");\n-                    };\n-                    *code_field = code;\n-                }\n-                SubdiagnosticKind::Label\n-                | SubdiagnosticKind::Note\n-                | SubdiagnosticKind::Help\n-                | SubdiagnosticKind::Warn\n-                | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n-            }\n-\n-            kind_slugs.push((kind, slug))\n+            kind_slugs.push((kind, slug));\n         }\n \n         Ok(kind_slugs)\n@@ -474,18 +272,18 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             \"skip_arg\" => Ok(quote! {}),\n             \"primary_span\" => {\n                 if kind_stats.has_multipart_suggestion {\n-                    throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n-                        diag.help(\n+                    invalid_attr(attr, &Meta::Path(path))\n+                        .help(\n                             \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n                             than one `#[primary_span]`\",\n                         )\n-                    })\n-                }\n-\n-                report_error_if_not_applied_to_span(attr, &info)?;\n+                        .emit();\n+                } else {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n \n-                let binding = info.binding.binding.clone();\n-                self.span_field.set_once((binding, span));\n+                    let binding = info.binding.binding.clone();\n+                    self.span_field.set_once(binding, span);\n+                }\n \n                 Ok(quote! {})\n             }\n@@ -495,40 +293,56 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                 if kind_stats.has_multipart_suggestion {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n-                    Ok(quote! {})\n                 } else {\n-                    throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n-                        diag.help(\n-                                \"`#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\",\n-                            )\n-                    });\n+                    invalid_attr(attr, &Meta::Path(path))\n+                        .help(\n+                            \"`#[suggestion_part(...)]` is only valid in multipart suggestions, \\\n+                             use `#[primary_span]` instead\",\n+                        )\n+                        .emit();\n                 }\n+\n+                Ok(quote! {})\n             }\n             \"applicability\" => {\n                 if kind_stats.has_multipart_suggestion || kind_stats.has_normal_suggestion {\n                     report_error_if_not_applied_to_applicability(attr, &info)?;\n \n+                    if kind_stats.all_applicabilities_static {\n+                        span_err(\n+                            span,\n+                            \"`#[applicability]` has no effect if all `#[suggestion]`/\\\n+                             `#[multipart_suggestion]` attributes have a static \\\n+                             `applicability = \\\"...\\\"`\",\n+                        )\n+                        .emit();\n+                    }\n                     let binding = info.binding.binding.clone();\n-                    self.applicability.set_once((quote! { #binding }, span));\n+                    self.applicability.set_once(quote! { #binding }, span);\n                 } else {\n                     span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n                 }\n \n                 Ok(quote! {})\n             }\n-            _ => throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+            _ => {\n                 let mut span_attrs = vec![];\n                 if kind_stats.has_multipart_suggestion {\n                     span_attrs.push(\"suggestion_part\");\n                 }\n                 if !kind_stats.all_multipart_suggestions {\n                     span_attrs.push(\"primary_span\")\n                 }\n-                diag.help(format!(\n-                    \"only `{}`, `applicability` and `skip_arg` are valid field attributes\",\n-                    span_attrs.join(\", \")\n-                ))\n-            }),\n+\n+                invalid_attr(attr, &Meta::Path(path))\n+                    .help(format!(\n+                        \"only `{}`, `applicability` and `skip_arg` are valid field attributes\",\n+                        span_attrs.join(\", \")\n+                    ))\n+                    .emit();\n+\n+                Ok(quote! {})\n+            }\n         }\n     }\n \n@@ -577,7 +391,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n+                            code.set_once(formatted_str, span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n@@ -635,19 +449,21 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             .map(|binding| self.generate_field_attr_code(binding, kind_stats))\n             .collect();\n \n-        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = self.applicability.take().map_or_else(\n-            || quote! { rustc_errors::Applicability::Unspecified },\n-            |(applicability, _)| applicability,\n-        );\n+        let span_field = self.span_field.value_ref();\n \n         let diag = &self.diag;\n         let mut calls = TokenStream::new();\n         for (kind, slug) in kind_slugs {\n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n             let message = quote! { rustc_errors::fluent::#slug };\n             let call = match kind {\n-                SubdiagnosticKind::Suggestion { suggestion_kind, code } => {\n+                SubdiagnosticKind::Suggestion { suggestion_kind, applicability, code } => {\n+                    let applicability = applicability\n+                        .value()\n+                        .map(|a| quote! { #a })\n+                        .or_else(|| self.applicability.take().value())\n+                        .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+\n                     if let Some(span) = span_field {\n                         let style = suggestion_kind.to_suggestion_style();\n \n@@ -657,7 +473,13 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                         quote! { unreachable!(); }\n                     }\n                 }\n-                SubdiagnosticKind::MultipartSuggestion { suggestion_kind } => {\n+                SubdiagnosticKind::MultipartSuggestion { suggestion_kind, applicability } => {\n+                    let applicability = applicability\n+                        .value()\n+                        .map(|a| quote! { #a })\n+                        .or_else(|| self.applicability.take().value())\n+                        .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+\n                     if !self.has_suggestion_parts {\n                         span_err(\n                             self.span,"}, {"sha": "a31bda9ca0def7dfab11df273586e4fc4e5156e0", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 266, "deletions": 4, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,12 +1,18 @@\n-use crate::diagnostics::error::{span_err, throw_span_err, DiagnosticDeriveError};\n+use crate::diagnostics::error::{\n+    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n+};\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n use std::collections::{BTreeSet, HashMap};\n+use std::fmt;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, Type, TypeTuple};\n+use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure};\n \n+use super::error::invalid_nested_attr;\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n@@ -172,13 +178,17 @@ pub(crate) struct FieldInfo<'a> {\n /// Small helper trait for abstracting over `Option` fields that contain a value and a `Span`\n /// for error reporting if they are set more than once.\n pub(crate) trait SetOnce<T> {\n-    fn set_once(&mut self, _: (T, Span));\n+    fn set_once(&mut self, value: T, span: Span);\n \n     fn value(self) -> Option<T>;\n+    fn value_ref(&self) -> Option<&T>;\n }\n \n-impl<T> SetOnce<T> for Option<(T, Span)> {\n-    fn set_once(&mut self, (value, span): (T, Span)) {\n+/// An [`Option<T>`] that keeps track of the span that caused it to be set; used with [`SetOnce`].\n+pub(super) type SpannedOption<T> = Option<(T, Span)>;\n+\n+impl<T> SetOnce<T> for SpannedOption<T> {\n+    fn set_once(&mut self, value: T, span: Span) {\n         match self {\n             None => {\n                 *self = Some((value, span));\n@@ -194,6 +204,10 @@ impl<T> SetOnce<T> for Option<(T, Span)> {\n     fn value(self) -> Option<T> {\n         self.map(|(v, _)| v)\n     }\n+\n+    fn value_ref(&self) -> Option<&T> {\n+        self.as_ref().map(|(v, _)| v)\n+    }\n }\n \n pub(crate) trait HasFieldMap {\n@@ -303,6 +317,7 @@ pub(crate) trait HasFieldMap {\n \n /// `Applicability` of a suggestion - mirrors `rustc_errors::Applicability` - and used to represent\n /// the user's selection of applicability if specified in an attribute.\n+#[derive(Clone, Copy)]\n pub(crate) enum Applicability {\n     MachineApplicable,\n     MaybeIncorrect,\n@@ -359,3 +374,250 @@ pub(crate) fn build_field_mapping<'a>(structure: &Structure<'a>) -> HashMap<Stri\n \n     fields_map\n }\n+\n+/// Possible styles for suggestion subdiagnostics.\n+#[derive(Clone, Copy)]\n+pub(super) enum SuggestionKind {\n+    /// `#[suggestion]`\n+    Normal,\n+    /// `#[suggestion_short]`\n+    Short,\n+    /// `#[suggestion_hidden]`\n+    Hidden,\n+    /// `#[suggestion_verbose]`\n+    Verbose,\n+}\n+\n+impl FromStr for SuggestionKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"\" => Ok(SuggestionKind::Normal),\n+            \"_short\" => Ok(SuggestionKind::Short),\n+            \"_hidden\" => Ok(SuggestionKind::Hidden),\n+            \"_verbose\" => Ok(SuggestionKind::Verbose),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl SuggestionKind {\n+    pub fn to_suggestion_style(&self) -> TokenStream {\n+        match self {\n+            SuggestionKind::Normal => {\n+                quote! { rustc_errors::SuggestionStyle::ShowCode }\n+            }\n+            SuggestionKind::Short => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n+            }\n+            SuggestionKind::Hidden => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n+            }\n+            SuggestionKind::Verbose => {\n+                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n+            }\n+        }\n+    }\n+}\n+\n+/// Types of subdiagnostics that can be created using attributes\n+#[derive(Clone)]\n+pub(super) enum SubdiagnosticKind {\n+    /// `#[label(...)]`\n+    Label,\n+    /// `#[note(...)]`\n+    Note,\n+    /// `#[help(...)]`\n+    Help,\n+    /// `#[warning(...)]`\n+    Warn,\n+    /// `#[suggestion{,_short,_hidden,_verbose}]`\n+    Suggestion {\n+        suggestion_kind: SuggestionKind,\n+        applicability: SpannedOption<Applicability>,\n+        code: TokenStream,\n+    },\n+    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n+    MultipartSuggestion {\n+        suggestion_kind: SuggestionKind,\n+        applicability: SpannedOption<Applicability>,\n+    },\n+}\n+\n+impl SubdiagnosticKind {\n+    /// Constructs a `SubdiagnosticKind` from a field or type attribute such as `#[note]`,\n+    /// `#[error(parser::add_paren)]` or `#[suggestion(code = \"...\")]`. Returns the\n+    /// `SubdiagnosticKind` and the diagnostic slug, if specified.\n+    pub(super) fn from_attr(\n+        attr: &Attribute,\n+        fields: &impl HasFieldMap,\n+    ) -> Result<(SubdiagnosticKind, Option<Path>), DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+\n+        let meta = attr.parse_meta()?;\n+        let mut kind = match name {\n+            \"label\" => SubdiagnosticKind::Label,\n+            \"note\" => SubdiagnosticKind::Note,\n+            \"help\" => SubdiagnosticKind::Help,\n+            \"warning\" => SubdiagnosticKind::Warn,\n+            _ => {\n+                if let Some(suggestion_kind) =\n+                    name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n+                {\n+                    SubdiagnosticKind::Suggestion {\n+                        suggestion_kind,\n+                        applicability: None,\n+                        code: TokenStream::new(),\n+                    }\n+                } else if let Some(suggestion_kind) =\n+                    name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n+                {\n+                    SubdiagnosticKind::MultipartSuggestion { suggestion_kind, applicability: None }\n+                } else {\n+                    throw_invalid_attr!(attr, &meta);\n+                }\n+            }\n+        };\n+\n+        let nested = match meta {\n+            Meta::List(MetaList { ref nested, .. }) => {\n+                // An attribute with properties, such as `#[suggestion(code = \"...\")]` or\n+                // `#[error(some::slug)]`\n+                nested\n+            }\n+            Meta::Path(_) => {\n+                // An attribute without a slug or other properties, such as `#[note]` - return\n+                // without further processing.\n+                //\n+                // Only allow this if there are no mandatory properties, such as `code = \"...\"` in\n+                // `#[suggestion(...)]`\n+                match kind {\n+                    SubdiagnosticKind::Label\n+                    | SubdiagnosticKind::Note\n+                    | SubdiagnosticKind::Help\n+                    | SubdiagnosticKind::Warn\n+                    | SubdiagnosticKind::MultipartSuggestion { .. } => return Ok((kind, None)),\n+                    SubdiagnosticKind::Suggestion { .. } => {\n+                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\")\n+                    }\n+                }\n+            }\n+            _ => {\n+                throw_invalid_attr!(attr, &meta)\n+            }\n+        };\n+\n+        let mut code = None;\n+\n+        let mut nested_iter = nested.into_iter().peekable();\n+\n+        // Peek at the first nested attribute: if it's a slug path, consume it.\n+        let slug = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n+            let path = path.clone();\n+            // Advance the iterator.\n+            nested_iter.next();\n+            Some(path)\n+        } else {\n+            None\n+        };\n+\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                NestedMeta::Meta(ref meta) => meta,\n+                NestedMeta::Lit(_) => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    continue;\n+                }\n+            };\n+\n+            let span = meta.span().unwrap();\n+            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+            let nested_name = nested_name.as_str();\n+\n+            let value = match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+                Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                }),\n+                _ => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    continue;\n+                }\n+            };\n+\n+            match (nested_name, &mut kind) {\n+                (\"code\", SubdiagnosticKind::Suggestion { .. }) => {\n+                    let formatted_str = fields.build_format(&value.value(), value.span());\n+                    code.set_once(formatted_str, span);\n+                }\n+                (\n+                    \"applicability\",\n+                    SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n+                    | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n+                ) => {\n+                    let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n+                        span_err(span, \"invalid applicability\").emit();\n+                        Applicability::Unspecified\n+                    });\n+                    applicability.set_once(value, span);\n+                }\n+\n+                // Invalid nested attribute\n+                (_, SubdiagnosticKind::Suggestion { .. }) => {\n+                    invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `code` and `applicability` are valid nested attributes\")\n+                        .emit();\n+                }\n+                (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n+                    invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `applicability` is a valid nested attributes\")\n+                        .emit()\n+                }\n+                _ => {\n+                    invalid_nested_attr(attr, &nested_attr).emit();\n+                }\n+            }\n+        }\n+\n+        match kind {\n+            SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n+                *code_field = if let Some((code, _)) = code {\n+                    code\n+                } else {\n+                    span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                    quote! { \"\" }\n+                }\n+            }\n+            SubdiagnosticKind::Label\n+            | SubdiagnosticKind::Note\n+            | SubdiagnosticKind::Help\n+            | SubdiagnosticKind::Warn\n+            | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n+        }\n+\n+        Ok((kind, slug))\n+    }\n+}\n+\n+impl quote::IdentFragment for SubdiagnosticKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SubdiagnosticKind::Label => write!(f, \"label\"),\n+            SubdiagnosticKind::Note => write!(f, \"note\"),\n+            SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                write!(f, \"multipart_suggestion_with_style\")\n+            }\n+        }\n+    }\n+\n+    fn span(&self) -> Option<proc_macro2::Span> {\n+        None\n+    }\n+}"}, {"sha": "0a81cde93be9c2bd7fa26cd4ea6a994b2b182332", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -289,7 +289,7 @@ pub enum BadTypePlusSub {\n #[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n struct BadQPathStage2 {\n     #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\")]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n     span: Span,\n     ty: String,\n }\n@@ -298,7 +298,7 @@ struct BadQPathStage2 {\n #[diag(parser::incorrect_semicolon)]\n struct IncorrectSemicolon<'a> {\n     #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\")]\n+    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n     span: Span,\n     #[help]\n     opt_help: Option<()>,\n@@ -309,7 +309,7 @@ struct IncorrectSemicolon<'a> {\n #[diag(parser::incorrect_use_of_await)]\n struct IncorrectUseOfAwait {\n     #[primary_span]\n-    #[suggestion(parser::parentheses_suggestion, applicability = \"machine-applicable\")]\n+    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     span: Span,\n }\n \n@@ -329,7 +329,7 @@ struct IncorrectAwait {\n struct InInTypo {\n     #[primary_span]\n     span: Span,\n-    #[suggestion(applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     sugg_span: Span,\n }\n "}, {"sha": "cc231af71a2748c3de43f0651273d178bc8e29f0", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -462,7 +462,7 @@ pub struct LinkSection {\n pub struct NoMangleForeign {\n     #[label]\n     pub span: Span,\n-    #[suggestion(applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub attr_span: Span,\n     pub foreign_item_kind: &'static str,\n }\n@@ -596,7 +596,7 @@ pub enum UnusedNote {\n #[derive(LintDiagnostic)]\n #[diag(passes::unused)]\n pub struct Unused {\n-    #[suggestion(applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub attr_span: Span,\n     #[subdiagnostic]\n     pub note: UnusedNote,"}, {"sha": "7e83f2a72210765b5559e03805e29881ff685c41", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,6 +1,5 @@\n use crate::{ImplTraitContext, Resolver};\n use rustc_ast::visit::{self, FnKind};\n-use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n@@ -148,8 +147,13 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n                 self.with_parent(return_impl_trait_id, |this| {\n                     this.visit_fn_ret_ty(&sig.decl.output)\n                 });\n-                let closure_def = self.create_def(closure_id, DefPathData::ClosureExpr, span);\n-                self.with_parent(closure_def, |this| walk_list!(this, visit_block, body));\n+                // If this async fn has no body (i.e. it's an async fn signature in a trait)\n+                // then the closure_def will never be used, and we should avoid generating a\n+                // def-id for it.\n+                if let Some(body) = body {\n+                    let closure_def = self.create_def(closure_id, DefPathData::ClosureExpr, span);\n+                    self.with_parent(closure_def, |this| this.visit_block(body));\n+                }\n                 return;\n             }\n         }"}, {"sha": "e26920b25ccf6a3f73af558593ef2974197be700", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -2906,14 +2906,14 @@ pub trait Iterator {\n     /// Stopping at the first `true`:\n     ///\n     /// ```\n-    /// let a = [1, 2, 3];\n+    /// let a = [-1, 2, 3, 4];\n     ///\n     /// let mut iter = a.iter();\n     ///\n-    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));\n+    /// assert_eq!(iter.rposition(|&x| x >= 2), Some(3));\n     ///\n     /// // we can still use `iter`, as there are more elements.\n-    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&-1));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "75ac11a3a886ecba25b2ac99bb774be88a9af799", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1790,7 +1790,7 @@ pub(crate) fn render_impl_summary(\n     write!(w, \"<section id=\\\"{}\\\" class=\\\"impl has-srclink\\\"{}>\", id, aliases);\n     render_rightside(w, cx, &i.impl_item, containing_item, RenderMode::Normal);\n     write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n-    write!(w, \"<h3 class=\\\"code-header in-band\\\">\");\n+    write!(w, \"<h3 class=\\\"code-header\\\">\");\n \n     if let Some(use_absolute) = use_absolute {\n         write!(w, \"{}\", inner_impl.print(use_absolute, cx));"}, {"sha": "28dc4bf30108eba811c72c91ee4606f5c8818071", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -176,8 +176,8 @@ h4.code-header {\n \tborder-bottom-style: none;\n \tmargin: 0;\n \tpadding: 0;\n-\tmargin-top: 0.6em;\n-\tmargin-bottom: 0.4em;\n+\tmargin-top: 0.6rem;\n+\tmargin-bottom: 0.4rem;\n }\n .impl,\n .impl-items .method,\n@@ -658,18 +658,17 @@ h2.location a {\n \toverflow-x: auto;\n }\n \n-.content .out-of-band {\n+.out-of-band {\n \tflex-grow: 0;\n \tfont-size: 1.125rem;\n \tfont-weight: normal;\n-\tfloat: right;\n }\n \n .method > .code-header, .trait-impl > .code-header {\n \tdisplay: block;\n }\n \n-.content .in-band {\n+.in-band {\n \tflex-grow: 1;\n \tmargin: 0px;\n \tpadding: 0px;\n@@ -682,10 +681,6 @@ h2.location a {\n \tbackground-color: var(--main-background-color);\n }\n \n-.in-band > code, .in-band > .code-header {\n-\tdisplay: inline-block;\n-}\n-\n .docblock code, .docblock-short code,\n pre, .rustdoc.source .example-wrap {\n \tbackground-color: var(--code-block-background-color);\n@@ -1731,13 +1726,13 @@ in storage.js plus the media query with (min-width: 701px)\n \t\tflex-direction: column;\n \t}\n \n-\t.content .out-of-band {\n+\t.out-of-band {\n \t\ttext-align: left;\n \t\tmargin-left: initial;\n \t\tpadding: initial;\n \t}\n \n-\t.content .out-of-band .since::before {\n+\t.out-of-band .since::before {\n \t\tcontent: \"Since \";\n \t}\n \n@@ -1969,7 +1964,7 @@ in storage.js plus the media query with (min-width: 701px)\n }\n \n @media print {\n-\tnav.sidebar, nav.sub, .content .out-of-band, a.srclink, #copy-path,\n+\tnav.sidebar, nav.sub, .out-of-band, a.srclink, #copy-path,\n \tdetails.rustdoc-toggle[open] > summary::before, details.rustdoc-toggle > summary::before,\n \tdetails.rustdoc-toggle.top-doc > summary {\n \t\tdisplay: none;"}, {"sha": "c9674f11a5ecf9ca47f356c04946fbcd2dcd52b6", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -555,7 +555,6 @@ function loadCss(cssFileName) {\n                 const code = document.createElement(\"h3\");\n                 code.innerHTML = struct[TEXT_IDX];\n                 addClass(code, \"code-header\");\n-                addClass(code, \"in-band\");\n \n                 onEachLazy(code.getElementsByTagName(\"a\"), elem => {\n                     const href = elem.getAttribute(\"href\");"}, {"sha": "4f01f1a162457d7cea3a6d54d6d965bea03e3106", "filename": "src/test/rustdoc-gui/headers-color.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fheaders-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fheaders-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheaders-color.goml?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -19,7 +19,7 @@ assert-css: (\n )\n assert-css: (\n     \".impl .code-header\",\n-    {\"color\": \"rgb(230, 225, 207)\", \"background-color\": \"rgb(15, 20, 25)\"},\n+    {\"color\": \"rgb(230, 225, 207)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n     ALL,\n )\n \n@@ -58,7 +58,7 @@ assert-css: (\n )\n assert-css: (\n     \".impl .code-header\",\n-    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgb(53, 53, 53)\"},\n+    {\"color\": \"rgb(221, 221, 221)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n     ALL,\n )\n \n@@ -95,7 +95,7 @@ assert-css: (\n )\n assert-css: (\n     \".impl .code-header\",\n-    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgb(255, 255, 255)\"},\n+    {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n     ALL,\n )\n "}, {"sha": "2fcbee27147e498210502dd257e17e790d2f79a1", "filename": "src/test/rustdoc-gui/implementors.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -8,23 +8,23 @@ assert-count: (\"#implementors-list .impl\", 2)\n assert: (\"#implementors-list .impl:nth-child(1) > a.anchor\")\n assert-attribute: (\"#implementors-list .impl:nth-child(1)\", {\"id\": \"impl-Whatever-for-Struct\"})\n assert-attribute: (\"#implementors-list .impl:nth-child(1) > a.anchor\", {\"href\": \"#impl-Whatever-for-Struct\"})\n-assert: \"#implementors-list .impl:nth-child(1) > .code-header.in-band\"\n+assert: \"#implementors-list .impl:nth-child(1) > .code-header\"\n \n assert: (\"#implementors-list .impl:nth-child(2) > a.anchor\")\n assert-attribute: (\"#implementors-list .impl:nth-child(2)\", {\"id\": \"impl-Whatever-1\"})\n assert-attribute: (\"#implementors-list .impl:nth-child(2) > a.anchor\", {\"href\": \"#impl-Whatever-1\"})\n-assert: \"#implementors-list .impl:nth-child(2) > .code-header.in-band\"\n+assert: \"#implementors-list .impl:nth-child(2) > .code-header\"\n \n goto: file://|DOC_PATH|/test_docs/struct.HasEmptyTraits.html\n compare-elements-position-near-false: (\n     \"#impl-EmptyTrait1-for-HasEmptyTraits\",\n     \"#impl-EmptyTrait2-for-HasEmptyTraits\",\n-    {\"y\": 30},\n+    {\"y\": 34},\n )\n compare-elements-position-near: (\n     \"#impl-EmptyTrait3-for-HasEmptyTraits h3\",\n     \"#impl-EmptyTrait3-for-HasEmptyTraits .item-info\",\n-    {\"y\": 30},\n+    {\"y\": 34},\n )\n \n // Now check that re-exports work correctly."}, {"sha": "9797f196c554586ca97d3b3fb5abde323ca8861e", "filename": "src/test/rustdoc-gui/src-font-size.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc-font-size.goml?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,7 +5,7 @@ goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n show-text: true\n // Check the impl headers.\n assert-css: (\".impl.has-srclink .srclink\", {\"font-size\": \"16px\"}, ALL)\n-assert-css: (\".impl.has-srclink .code-header.in-band\", {\"font-size\": \"18px\"}, ALL)\n+assert-css: (\".impl.has-srclink .code-header\", {\"font-size\": \"18px\"}, ALL)\n // Check the impl items.\n assert-css: (\".impl-items .has-srclink .srclink\", {\"font-size\": \"16px\"}, ALL)\n assert-css: (\".impl-items .has-srclink .code-header\", {\"font-size\": \"16px\"}, ALL)"}, {"sha": "390ed5a1f938b2b834de443fc5b79dafbd97d668", "filename": "src/test/rustdoc/anonymous-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fanonymous-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fanonymous-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fanonymous-lifetime.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -12,7 +12,7 @@ pub trait Stream {\n }\n \n // @has 'foo/trait.Stream.html'\n-// @has - '//*[@class=\"code-header in-band\"]' 'impl<S: ?Sized + Stream + Unpin> Stream for &mut S'\n+// @has - '//*[@class=\"code-header\"]' 'impl<S: ?Sized + Stream + Unpin> Stream for &mut S'\n impl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n     type Item = S::Item;\n "}, {"sha": "a3e10ee5555a026122f6f098546e42ad7b689d7b", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -13,7 +13,7 @@ pub trait Foo {\n pub struct Bar;\n \n impl Foo for Bar {\n-    // @has assoc_consts/struct.Bar.html '//h3[@class=\"code-header in-band\"]' 'impl Foo for Bar'\n+    // @has assoc_consts/struct.Bar.html '//h3[@class=\"code-header\"]' 'impl Foo for Bar'\n     // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO: usize'\n     const FOO: usize = 12;\n     // @has - '//*[@id=\"associatedconstant.FOO_NO_DEFAULT\"]' 'const FOO_NO_DEFAULT: bool'\n@@ -81,7 +81,7 @@ pub trait Qux {\n     const QUX_DEFAULT2: u32 = 3;\n }\n \n-// @has assoc_consts/struct.Bar.html '//h3[@class=\"code-header in-band\"]' 'impl Qux for Bar'\n+// @has assoc_consts/struct.Bar.html '//h3[@class=\"code-header\"]' 'impl Qux for Bar'\n impl Qux for Bar {\n     // @has - '//*[@id=\"associatedconstant.QUX0\"]' 'const QUX0: u8'\n     // @has - '//*[@class=\"docblock\"]' \"Docs for QUX0 in trait.\""}, {"sha": "437f0001fcfc443afb0ad1bf66e6ec95c2ad1a56", "filename": "src/test/rustdoc/blanket-reexport-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,6 +1,6 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/struct.S.html '//*[@id=\"impl-Into%3CU%3E-for-S\"]//h3[@class=\"code-header in-band\"]' 'impl<T, U> Into<U> for T'\n+// @has foo/struct.S.html '//*[@id=\"impl-Into%3CU%3E-for-S\"]//h3[@class=\"code-header\"]' 'impl<T, U> Into<U> for T'\n pub struct S2 {}\n mod m {\n     pub struct S {}"}, {"sha": "6cbae9abebb73021d2f43d5ee852a92336e128f0", "filename": "src/test/rustdoc/const-generics/add-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -7,7 +7,7 @@ pub struct Simd<T, const WIDTH: usize> {\n     inner: T,\n }\n \n-// @has foo/struct.Simd.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header in-band\"]' 'impl Add<Simd<u8, 16>> for Simd<u8, 16>'\n+// @has foo/struct.Simd.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header\"]' 'impl Add<Simd<u8, 16>> for Simd<u8, 16>'\n impl Add for Simd<u8, 16> {\n     type Output = Self;\n "}, {"sha": "5bf76e3c4690818b361e7bfa8e2665e0b1c7ee11", "filename": "src/test/rustdoc/const-generics/const-generics-docs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -19,10 +19,10 @@ pub use extern_crate::WTrait;\n \n // @has foo/trait.Trait.html '//pre[@class=\"rust trait\"]' \\\n //      'pub trait Trait<const N: usize>'\n-// @has - '//*[@id=\"impl-Trait%3C1%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<1> for u8'\n-// @has - '//*[@id=\"impl-Trait%3C2%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<2> for u8'\n-// @has - '//*[@id=\"impl-Trait%3C{1%20+%202}%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<{1 + 2}> for u8'\n-// @has - '//*[@id=\"impl-Trait%3CN%3E-for-%5Bu8%3B%20N%5D\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"impl-Trait%3C1%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<1> for u8'\n+// @has - '//*[@id=\"impl-Trait%3C2%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<2> for u8'\n+// @has - '//*[@id=\"impl-Trait%3C{1%20+%202}%3E-for-u8\"]//h3[@class=\"code-header\"]' 'impl Trait<{1 + 2}> for u8'\n+// @has - '//*[@id=\"impl-Trait%3CN%3E-for-%5Bu8%3B%20N%5D\"]//h3[@class=\"code-header\"]' \\\n //      'impl<const N: usize> Trait<N> for [u8; N]'\n pub trait Trait<const N: usize> {}\n impl Trait<1> for u8 {}\n@@ -36,7 +36,7 @@ pub struct Foo<const N: usize> where u8: Trait<N>;\n // @has foo/struct.Bar.html '//pre[@class=\"rust struct\"]' 'pub struct Bar<T, const N: usize>(_)'\n pub struct Bar<T, const N: usize>([T; N]);\n \n-// @has foo/struct.Foo.html '//*[@id=\"impl-Foo%3CM%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<const M: usize> Foo<M>where u8: Trait<M>'\n+// @has foo/struct.Foo.html '//*[@id=\"impl-Foo%3CM%3E\"]/h3[@class=\"code-header\"]' 'impl<const M: usize> Foo<M>where u8: Trait<M>'\n impl<const M: usize> Foo<M> where u8: Trait<M> {\n     // @has - '//*[@id=\"associatedconstant.FOO_ASSOC\"]' 'pub const FOO_ASSOC: usize'\n     pub const FOO_ASSOC: usize = M + 13;\n@@ -47,7 +47,7 @@ impl<const M: usize> Foo<M> where u8: Trait<M> {\n     }\n }\n \n-// @has foo/struct.Bar.html '//*[@id=\"impl-Bar%3Cu8%2C%20M%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<const M: usize> Bar<u8, M>'\n+// @has foo/struct.Bar.html '//*[@id=\"impl-Bar%3Cu8%2C%20M%3E\"]/h3[@class=\"code-header\"]' 'impl<const M: usize> Bar<u8, M>'\n impl<const M: usize> Bar<u8, M> {\n     // @has - '//*[@id=\"method.hey\"]' \\\n     //      'pub fn hey<const N: usize>(&self) -> Foo<N>where u8: Trait<N>'"}, {"sha": "75ee84279be3c840976325a93401735af5b4c800", "filename": "src/test/rustdoc/const-generics/const-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,20 +9,20 @@ pub enum Order {\n }\n \n // @has foo/struct.VSet.html '//pre[@class=\"rust struct\"]' 'pub struct VSet<T, const ORDER: Order>'\n-// @has foo/struct.VSet.html '//*[@id=\"impl-Send-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<T, const ORDER: Order> Send for VSet<T, ORDER>'\n-// @has foo/struct.VSet.html '//*[@id=\"impl-Sync-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<T, const ORDER: Order> Sync for VSet<T, ORDER>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-Send-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Send for VSet<T, ORDER>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-Sync-for-VSet%3CT%2C%20ORDER%3E\"]/h3[@class=\"code-header\"]' 'impl<T, const ORDER: Order> Sync for VSet<T, ORDER>'\n pub struct VSet<T, const ORDER: Order> {\n     inner: Vec<T>,\n }\n \n-// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3ASorted%20}%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<T> VSet<T, { Order::Sorted }>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3ASorted%20}%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Sorted }>'\n impl<T> VSet<T, { Order::Sorted }> {\n     pub fn new() -> Self {\n         Self { inner: Vec::new() }\n     }\n }\n \n-// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3AUnsorted%20}%3E\"]/h3[@class=\"code-header in-band\"]' 'impl<T> VSet<T, { Order::Unsorted }>'\n+// @has foo/struct.VSet.html '//*[@id=\"impl-VSet%3CT%2C%20{%20Order%3A%3AUnsorted%20}%3E\"]/h3[@class=\"code-header\"]' 'impl<T> VSet<T, { Order::Unsorted }>'\n impl<T> VSet<T, { Order::Unsorted }> {\n     pub fn new() -> Self {\n         Self { inner: Vec::new() }\n@@ -31,7 +31,7 @@ impl<T> VSet<T, { Order::Unsorted }> {\n \n pub struct Escape<const S: &'static str>;\n \n-// @has foo/struct.Escape.html '//*[@id=\"impl-Escape%3Cr#%22%3Cscript%3Ealert(%22Escape%22)%3B%3C/script%3E%22#%3E\"]/h3[@class=\"code-header in-band\"]' 'impl Escape<r#\"<script>alert(\"Escape\");</script>\"#>'\n+// @has foo/struct.Escape.html '//*[@id=\"impl-Escape%3Cr#%22%3Cscript%3Ealert(%22Escape%22)%3B%3C/script%3E%22#%3E\"]/h3[@class=\"code-header\"]' 'impl Escape<r#\"<script>alert(\"Escape\");</script>\"#>'\n impl Escape<r#\"<script>alert(\"Escape\");</script>\"#> {\n     pub fn f() {}\n }"}, {"sha": "310e89a35c4a9a52ba62baa1a1faf5a383ab17a9", "filename": "src/test/rustdoc/const-generics/lazy_normalization_consts/const-equate-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Flazy_normalization_consts%2Fconst-equate-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fconst-generics%2Flazy_normalization_consts%2Fconst-equate-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Flazy_normalization_consts%2Fconst-equate-pred.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -12,7 +12,7 @@ pub struct Hasher<T> {\n unsafe impl<T: Default> Send for Hasher<T> {}\n \n // @has foo/struct.Foo.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Send for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Send for Foo'\n pub struct Foo {\n     hasher: Hasher<[u8; 3]>,\n }"}, {"sha": "c1f95ac91c394d7717bda3393d0f97a20d338a7c", "filename": "src/test/rustdoc/duplicate_impls/issue-33054.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,12 +1,12 @@\n // ignore-tidy-linelength\n \n // @has issue_33054/impls/struct.Foo.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Foo'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for Foo'\n // @count - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]' 1\n // @count - '//*[@id=\"main-content\"]/div[@id=\"implementations-list\"]/details/summary/*[@class=\"impl has-srclink\"]' 1\n // @has issue_33054/impls/bar/trait.Bar.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for Foo'\n // @count - '//*[@class=\"struct\"]' 1\n pub mod impls;\n "}, {"sha": "95d4db06b3171f7606dbba351238b799682ff2e7", "filename": "src/test/rustdoc/empty-impl-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -16,5 +16,5 @@ pub struct Another;\n pub trait Bar {}\n \n // @has 'foo/struct.Another.html'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for Another'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for Another'\n impl Bar for Another {}"}, {"sha": "fd1bc21400837eedb18c0da8c3b37c939f1cbebe", "filename": "src/test/rustdoc/extern-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fextern-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fextern-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -19,9 +19,9 @@ impl Foo {\n // @has foo/trait.Bar.html\n pub trait Bar {}\n \n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for fn()'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for fn()'\n impl Bar for fn() {}\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for extern \"C\" fn()'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for extern \"C\" fn()'\n impl Bar for extern fn() {}\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for extern \"system\" fn()'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Bar for extern \"system\" fn()'\n impl Bar for extern \"system\" fn() {}"}, {"sha": "9e060ff2026f6c64f34227c38bf5efb08e448d77", "filename": "src/test/rustdoc/fn-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ffn-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ffn-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ffn-bound.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -11,7 +11,7 @@ pub struct ConditionalIterator<F> {\n }\n \n \n-// @has 'fn_bound/struct.ConditionalIterator.html' '//h3[@class=\"code-header in-band\"]' 'impl<F: Fn(&i32)> Iterator for ConditionalIterator<F>'\n+// @has 'fn_bound/struct.ConditionalIterator.html' '//h3[@class=\"code-header\"]' 'impl<F: Fn(&i32)> Iterator for ConditionalIterator<F>'\n impl<F: Fn(&i32)> Iterator for ConditionalIterator<F> {\n     type Item = ();\n "}, {"sha": "6f68b1574992b4baa9e9c95a687c558bb5f3c67e", "filename": "src/test/rustdoc/generic-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fgeneric-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n // @!has foo/struct.Bar.html '//*[@id=\"impl-ToString-for-Bar\"]' ''\n pub struct Bar;\n \n-// @has foo/struct.Foo.html '//*[@id=\"impl-ToString-for-Foo\"]//h3[@class=\"code-header in-band\"]' 'impl<T> ToString for T'\n+// @has foo/struct.Foo.html '//*[@id=\"impl-ToString-for-Foo\"]//h3[@class=\"code-header\"]' 'impl<T> ToString for T'\n pub struct Foo;\n // @has foo/struct.Foo.html '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-ToString-for-Foo\"]' 'ToString'\n "}, {"sha": "3493ae6d2bbb59cb5f72ccbb5e4cfe49b2e8a69d", "filename": "src/test/rustdoc/higher-ranked-trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -49,7 +49,7 @@ impl<'a> Foo<'a> {\n // @has foo/trait.B.html\n pub trait B<'x> {}\n \n-// @has - '//h3[@class=\"code-header in-band\"]' \"impl<'a> B<'a> for dyn for<'b> Trait<'b>\"\n+// @has - '//h3[@class=\"code-header\"]' \"impl<'a> B<'a> for dyn for<'b> Trait<'b>\"\n impl<'a> B<'a> for dyn for<'b> Trait<'b> {}\n \n // @has foo/struct.Bar.html"}, {"sha": "bb978dc0f3ec83eaef98f3f7833618098d694bc1", "filename": "src/test/rustdoc/impl-disambiguation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fimpl-disambiguation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fimpl-disambiguation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-disambiguation.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -4,13 +4,13 @@ pub trait Foo {}\n \n pub struct Bar<T> { field: T }\n \n-// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl Foo for Bar<u8>\"\n impl Foo for Bar<u8> {}\n-// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl Foo for Bar<u16>\"\n impl Foo for Bar<u16> {}\n-// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl<'a> Foo for &'a Bar<u8>\"\n impl<'a> Foo for &'a Bar<u8> {}\n \n@@ -22,9 +22,9 @@ pub mod mod2 {\n     pub enum Baz {}\n }\n \n-// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl Foo for foo::mod1::Baz\"\n impl Foo for mod1::Baz {}\n-// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.Foo.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl<'a> Foo for &'a foo::mod2::Baz\"\n impl<'a> Foo for &'a mod2::Baz {}"}, {"sha": "0a8c2c8d2a9e6619cf31a81272c3697f81e4bc2d", "filename": "src/test/rustdoc/impl-parts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-parts.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,8 +5,8 @@ pub auto trait AnAutoTrait {}\n \n pub struct Foo<T> { field: T }\n \n-// @has impl_parts/struct.Foo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has impl_parts/struct.Foo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n //     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n-// @has impl_parts/trait.AnAutoTrait.html '//*[@class=\"item-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has impl_parts/trait.AnAutoTrait.html '//*[@class=\"item-list\"]//h3[@class=\"code-header\"]' \\\n //     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n impl<T: Clone> !AnAutoTrait for Foo<T> where T: Sync {}"}, {"sha": "6e89167b3a4512fa44ccf57466fbbad4beb855c3", "filename": "src/test/rustdoc/inline_cross/issue-31948-1.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-1.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,22 +5,22 @@\n extern crate rustdoc_nonreachable_impls;\n \n // @has issue_31948_1/struct.Wobble.html\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Bark for'\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Woof for'\n-// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header in-band\"]' 'Bar for'\n-// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header in-band\"]' 'Qux for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Bark for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Woof for'\n+// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' 'Bar for'\n+// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' 'Qux for'\n pub use rustdoc_nonreachable_impls::hidden::Wobble;\n \n // @has issue_31948_1/trait.Bark.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Foo'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Wobble'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wibble'\n+// @has - '//h3[@class=\"code-header\"]' 'for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'for Wobble'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wibble'\n pub use rustdoc_nonreachable_impls::Bark;\n \n // @has issue_31948_1/trait.Woof.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Foo'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Wobble'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wibble'\n+// @has - '//h3[@class=\"code-header\"]' 'for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'for Wobble'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wibble'\n pub use rustdoc_nonreachable_impls::Woof;\n \n // @!has issue_31948_1/trait.Bar.html"}, {"sha": "141e07656a09c48b2ac298d73ea1308a8175697c", "filename": "src/test/rustdoc/inline_cross/issue-31948-2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948-2.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,15 +5,15 @@\n extern crate rustdoc_nonreachable_impls;\n \n // @has issue_31948_2/struct.Wobble.html\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Qux for'\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Bark for'\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Woof for'\n-// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header in-band\"]' 'Bar for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Qux for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Bark for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Woof for'\n+// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' 'Bar for'\n pub use rustdoc_nonreachable_impls::hidden::Wobble;\n \n // @has issue_31948_2/trait.Qux.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Foo'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Wobble'\n+// @has - '//h3[@class=\"code-header\"]' 'for Foo'\n+// @has - '//h3[@class=\"code-header\"]' 'for Wobble'\n pub use rustdoc_nonreachable_impls::hidden::Qux;\n \n // @!has issue_31948_2/trait.Bar.html"}, {"sha": "96fc6ca47e7f656d95691bffaa164e033dbba5fe", "filename": "src/test/rustdoc/inline_cross/issue-31948.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-31948.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,22 +5,22 @@\n extern crate rustdoc_nonreachable_impls;\n \n // @has issue_31948/struct.Foo.html\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Bark for'\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Woof for'\n-// @!has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'Bar for'\n-// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header in-band\"]' 'Qux for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Bark for'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Woof for'\n+// @!has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'Bar for'\n+// @!has - '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' 'Qux for'\n pub use rustdoc_nonreachable_impls::Foo;\n \n // @has issue_31948/trait.Bark.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Foo'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wibble'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wobble'\n+// @has - '//h3[@class=\"code-header\"]' 'for Foo'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wibble'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wobble'\n pub use rustdoc_nonreachable_impls::Bark;\n \n // @has issue_31948/trait.Woof.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'for Foo'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wibble'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'for Wobble'\n+// @has - '//h3[@class=\"code-header\"]' 'for Foo'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wibble'\n+// @!has - '//h3[@class=\"code-header\"]' 'for Wobble'\n pub use rustdoc_nonreachable_impls::Woof;\n \n // @!has issue_31948/trait.Bar.html"}, {"sha": "183fd15abbe17f85a2614589c0c92992bf3a67f1", "filename": "src/test/rustdoc/inline_cross/issue-32881.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,7 +5,7 @@\n extern crate rustdoc_trait_object_impl;\n \n // @has issue_32881/trait.Bar.html\n-// @has - '//h3[@class=\"code-header in-band\"]' \"impl<'a> dyn Bar\"\n-// @has - '//h3[@class=\"code-header in-band\"]' \"impl<'a> Debug for dyn Bar\"\n+// @has - '//h3[@class=\"code-header\"]' \"impl<'a> dyn Bar\"\n+// @has - '//h3[@class=\"code-header\"]' \"impl<'a> Debug for dyn Bar\"\n \n pub use rustdoc_trait_object_impl::Bar;"}, {"sha": "d954707facfe652bb4dc7489e1cd47f06499526a", "filename": "src/test/rustdoc/inline_cross/issue-33113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-33113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-33113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-33113.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,6 +5,6 @@\n extern crate bar;\n \n // @has issue_33113/trait.Bar.html\n-// @has - '//h3[@class=\"code-header in-band\"]' \"for &'a char\"\n-// @has - '//h3[@class=\"code-header in-band\"]' \"for Foo\"\n+// @has - '//h3[@class=\"code-header\"]' \"for &'a char\"\n+// @has - '//h3[@class=\"code-header\"]' \"for Foo\"\n pub use bar::Bar;"}, {"sha": "b646babacc5cc9ca49375a7a972bfccb720d846d", "filename": "src/test/rustdoc/inline_cross/trait-vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -3,5 +3,5 @@\n extern crate inner;\n \n // @has trait_vis/struct.SomeStruct.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Clone for SomeStruct'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Clone for SomeStruct'\n pub use inner::SomeStruct;"}, {"sha": "19b69da15138be6bdfac7e5ba5a603ef281779fa", "filename": "src/test/rustdoc/inline_local/trait-vis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -13,6 +13,6 @@ mod asdf {\n }\n \n // @has trait_vis/struct.SomeStruct.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl ThisTrait for SomeStruct'\n-// @!has - '//h3[@class=\"code-header in-band\"]' 'impl PrivateTrait for SomeStruct'\n+// @has - '//h3[@class=\"code-header\"]' 'impl ThisTrait for SomeStruct'\n+// @!has - '//h3[@class=\"code-header\"]' 'impl PrivateTrait for SomeStruct'\n pub use asdf::SomeStruct;"}, {"sha": "01ae4438500da03d36c3ead7533a5502243c302c", "filename": "src/test/rustdoc/issue-29503.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-29503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-29503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-29503.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,7 +5,7 @@ pub trait MyTrait {\n     fn my_string(&self) -> String;\n }\n \n-// @has - \"//div[@id='implementors-list']//*[@id='impl-MyTrait-for-T']//h3[@class='code-header in-band']\" \"impl<T> MyTrait for Twhere T: Debug\"\n+// @has - \"//div[@id='implementors-list']//*[@id='impl-MyTrait-for-T']//h3[@class='code-header']\" \"impl<T> MyTrait for Twhere T: Debug\"\n impl<T> MyTrait for T\n where\n     T: fmt::Debug,"}, {"sha": "7a128f0b897ed67b665a397c7bdc4ccdb305cdb4", "filename": "src/test/rustdoc/issue-33592.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-33592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-33592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33592.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -6,8 +6,8 @@ pub struct Bar;\n \n pub struct Baz;\n \n-// @has foo/trait.Foo.html '//h3[@class=\"code-header in-band\"]' 'impl Foo<i32> for Bar'\n+// @has foo/trait.Foo.html '//h3[@class=\"code-header\"]' 'impl Foo<i32> for Bar'\n impl Foo<i32> for Bar {}\n \n-// @has foo/trait.Foo.html '//h3[@class=\"code-header in-band\"]' 'impl<T> Foo<T> for Baz'\n+// @has foo/trait.Foo.html '//h3[@class=\"code-header\"]' 'impl<T> Foo<T> for Baz'\n impl<T> Foo<T> for Baz {}"}, {"sha": "8cfc4827a7f4cfeba5dbf035da503904d5b3e8db", "filename": "src/test/rustdoc/issue-46727.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-46727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-46727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-46727.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -3,5 +3,5 @@\n extern crate issue_46727;\n \n // @has issue_46727/trait.Foo.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<T> Foo for Bar<[T; 3]>'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<T> Foo for Bar<[T; 3]>'\n pub use issue_46727::{Foo, Bar};"}, {"sha": "04bc4f304d68acc8e72e5021b42a22282bee7231", "filename": "src/test/rustdoc/issue-50159.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-50159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-50159.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -11,8 +11,8 @@ impl<B, C> Signal2 for B where B: Signal<Item = C> {\n }\n \n // @has issue_50159/struct.Switch.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<B> Send for Switch<B>where <B as Signal>::Item: Send'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<B> Sync for Switch<B>where <B as Signal>::Item: Sync'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<B> Send for Switch<B>where <B as Signal>::Item: Send'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<B> Sync for Switch<B>where <B as Signal>::Item: Sync'\n // @count - '//*[@id=\"implementations-list\"]//*[@class=\"impl\"]' 0\n // @count - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]' 5\n pub struct Switch<B: Signal> {"}, {"sha": "1c7aa9c7eefe50c7153bf1b5009a9cc99cc6ca9b", "filename": "src/test/rustdoc/issue-51236.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-51236.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -7,7 +7,7 @@ pub mod traits {\n }\n \n // @has issue_51236/struct.Owned.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> Send for Owned<T>where <T as Owned<'static>>::Reader: Send\"\n pub struct Owned<T> where T: for<'a> ::traits::Owned<'a> {\n     marker: PhantomData<<T as ::traits::Owned<'static>>::Reader>,"}, {"sha": "7b7290ab4b77c39cf862408852b13a9cd8355832", "filename": "src/test/rustdoc/issue-54705.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-54705.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,10 +1,10 @@\n pub trait ScopeHandle<'scope> {}\n \n // @has issue_54705/struct.ScopeFutureContents.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'scope, S> Send for ScopeFutureContents<'scope, S>where S: Sync\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'scope, S> Sync for ScopeFutureContents<'scope, S>where S: Sync\"\n pub struct ScopeFutureContents<'scope, S>\n     where S: ScopeHandle<'scope>,"}, {"sha": "22a18ef90e13ad68b3c57e16f0eda6e45b173c8a", "filename": "src/test/rustdoc/issue-55321.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55321.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,18 +1,18 @@\n #![feature(negative_impls)]\n \n // @has issue_55321/struct.A.html\n-// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl !Send for A\"\n-// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl !Sync for A\"\n pub struct A();\n \n impl !Send for A {}\n impl !Sync for A {}\n \n // @has issue_55321/struct.B.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Send for B<T>\"\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Sync for B<T>\"\n pub struct B<T: ?Sized>(A, Box<T>);"}, {"sha": "b4eef344b5f3b6f01abd00cc4bdae13d9934b496", "filename": "src/test/rustdoc/issue-56822.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-56822.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -17,7 +17,7 @@ impl<'a, T> MyTrait for Inner<'a, T> {\n }\n \n // @has issue_56822/struct.Parser.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'a> Send for Parser<'a>\"\n pub struct Parser<'a> {\n     field: <Wrapper<Inner<'a, u8>> as MyTrait>::Output"}, {"sha": "fbb0f82ae39577701447ddd905e69b7b2723c5f7", "filename": "src/test/rustdoc/issue-60726.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-60726.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -26,9 +26,9 @@ where\n {}\n \n // @has issue_60726/struct.IntoIter.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Send for IntoIter<T>\"\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Sync for IntoIter<T>\"\n pub struct IntoIter<T>{\n     hello:DynTrait<FooInterface<T>>,"}, {"sha": "3b11059a755d0f23a57ed2460fe5a96d88e37861", "filename": "src/test/rustdoc/issue-75588.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-75588.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-75588.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-75588.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -10,8 +10,8 @@ extern crate realcore;\n extern crate real_gimli;\n \n // issue #74672\n-// @!has foo/trait.Deref.html '//*[@id=\"impl-Deref-for-EndianSlice\"]//h3[@class=\"code-header in-band\"]' 'impl Deref for EndianSlice'\n+// @!has foo/trait.Deref.html '//*[@id=\"impl-Deref-for-EndianSlice\"]//h3[@class=\"code-header\"]' 'impl Deref for EndianSlice'\n pub use realcore::Deref;\n \n-// @has foo/trait.Join.html '//*[@id=\"impl-Join-for-Foo\"]//h3[@class=\"code-header in-band\"]' 'impl Join for Foo'\n+// @has foo/trait.Join.html '//*[@id=\"impl-Join-for-Foo\"]//h3[@class=\"code-header\"]' 'impl Join for Foo'\n pub use realcore::Join;"}, {"sha": "62fbc2444dbc297976e6bb264f3453b20d0e5f58", "filename": "src/test/rustdoc/issue-80233-normalize-auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-80233-normalize-auto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-80233-normalize-auto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-80233-normalize-auto-trait.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -31,7 +31,7 @@ impl<T: Trait3> Trait3 for Vec<T> {\n pub struct Struct1 {}\n \n // @has issue_80233_normalize_auto_trait/struct.Question.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<T> Send for Question<T>'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<T> Send for Question<T>'\n pub struct Question<T: Trait1> {\n     pub ins: <<Vec<T> as Trait3>::Type3 as Trait2>::Type2,\n }"}, {"sha": "adf4d111a6cb91b08748a7487a340e5fdbd57569", "filename": "src/test/rustdoc/issue-82465-asref-for-and-of-local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,14 +1,14 @@\n use std::convert::AsRef;\n pub struct Local;\n \n-// @has issue_82465_asref_for_and_of_local/struct.Local.html '//h3[@class=\"code-header in-band\"]' 'impl AsRef<str> for Local'\n+// @has issue_82465_asref_for_and_of_local/struct.Local.html '//h3[@class=\"code-header\"]' 'impl AsRef<str> for Local'\n impl AsRef<str> for Local {\n     fn as_ref(&self) -> &str {\n         todo!()\n     }\n }\n \n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl AsRef<Local> for str'\n+// @has - '//h3[@class=\"code-header\"]' 'impl AsRef<Local> for str'\n impl AsRef<Local> for str {\n     fn as_ref(&self) -> &Local {\n         todo!()"}, {"sha": "d50268509b2c1ababc06f03b2a4d123202869fd3", "filename": "src/test/rustdoc/issue-98697.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-98697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fissue-98697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-98697.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -12,6 +12,6 @@ extern crate issue_98697_reexport_with_anonymous_lifetime;\n // @!has issue_98697/fn.repro.html '//pre[@class=\"rust fn\"]/code' 'for<'\n pub use issue_98697_reexport_with_anonymous_lifetime::repro;\n \n-// @has issue_98697/struct.Extra.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header in-band\"]' 'impl MyTrait<&Extra> for Extra'\n-// @!has issue_98697/struct.Extra.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header in-band\"]' 'impl<'\n+// @has issue_98697/struct.Extra.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header\"]' 'impl MyTrait<&Extra> for Extra'\n+// @!has issue_98697/struct.Extra.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header\"]' 'impl<'\n pub use issue_98697_reexport_with_anonymous_lifetime::Extra;"}, {"sha": "af19c784d6d0514c85cf4cd8148d94778d5d4090", "filename": "src/test/rustdoc/negative-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fnegative-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fnegative-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnegative-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -5,10 +5,10 @@ pub struct Alpha;\n // @matches negative_impl/struct.Bravo.html '//pre' \"pub struct Bravo<B>\"\n pub struct Bravo<B>(B);\n \n-// @matches negative_impl/struct.Alpha.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @matches negative_impl/struct.Alpha.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl !Send for Alpha\"\n impl !Send for Alpha {}\n \n-// @matches negative_impl/struct.Bravo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \"\\\n+// @matches negative_impl/struct.Bravo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \"\\\n // impl<B> !Send for Bravo<B>\"\n impl<B> !Send for Bravo<B> {}"}, {"sha": "431c9aa79c7f9f84bc5ef3f06279503d2e84a9b7", "filename": "src/test/rustdoc/primitive-reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-reference.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -14,7 +14,7 @@\n \n // There should be only one implementation listed.\n // @count - '//*[@class=\"impl has-srclink\"]' 1\n-// @has - '//*[@id=\"impl-Foo%3C%26A%3E-for-%26B\"]/*[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"impl-Foo%3C%26A%3E-for-%26B\"]/*[@class=\"code-header\"]' \\\n //        'impl<A, B> Foo<&A> for &B'\n #[doc(primitive = \"reference\")]\n /// this is a test!"}, {"sha": "7b336b398104752946849261388462e0f60bdc71", "filename": "src/test/rustdoc/primitive/primitive-generic-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive%2Fprimitive-generic-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,7 +1,7 @@\n #![feature(rustdoc_internals)]\n #![crate_name = \"foo\"]\n \n-// @has foo/primitive.i32.html '//*[@id=\"impl-ToString-for-i32\"]//h3[@class=\"code-header in-band\"]' 'impl<T> ToString for T'\n+// @has foo/primitive.i32.html '//*[@id=\"impl-ToString-for-i32\"]//h3[@class=\"code-header\"]' 'impl<T> ToString for T'\n \n #[doc(primitive = \"i32\")]\n /// Some useless docs, wouhou!"}, {"sha": "aa38485c44558b7658d0e0100fdaaa7105597222", "filename": "src/test/rustdoc/recursive-deref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frecursive-deref.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,7 +9,7 @@ impl C {\n     pub fn c(&self) {}\n }\n \n-// @has recursive_deref/struct.A.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for A'\n+// @has recursive_deref/struct.A.html '//h3[@class=\"code-header\"]' 'impl Deref for A'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for A {\n     type Target = B;\n@@ -19,7 +19,7 @@ impl Deref for A {\n     }\n }\n \n-// @has recursive_deref/struct.B.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for B'\n+// @has recursive_deref/struct.B.html '//h3[@class=\"code-header\"]' 'impl Deref for B'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for B {\n     type Target = C;\n@@ -29,7 +29,7 @@ impl Deref for B {\n     }\n }\n \n-// @has recursive_deref/struct.C.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for C'\n+// @has recursive_deref/struct.C.html '//h3[@class=\"code-header\"]' 'impl Deref for C'\n impl Deref for C {\n     type Target = B;\n \n@@ -49,7 +49,7 @@ impl G {\n     pub fn g() {}\n }\n \n-// @has recursive_deref/struct.D.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for D'\n+// @has recursive_deref/struct.D.html '//h3[@class=\"code-header\"]' 'impl Deref for D'\n // We also check that `G::g` method isn't rendered because there is no `self` argument.\n // @!has '-' '//*[@id=\"deref-methods-G\"]' ''\n impl Deref for D {\n@@ -60,7 +60,7 @@ impl Deref for D {\n     }\n }\n \n-// @has recursive_deref/struct.E.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for E'\n+// @has recursive_deref/struct.E.html '//h3[@class=\"code-header\"]' 'impl Deref for E'\n // We also check that `G::g` method isn't rendered because there is no `self` argument.\n // @!has '-' '//*[@id=\"deref-methods-G\"]' ''\n impl Deref for E {\n@@ -71,7 +71,7 @@ impl Deref for E {\n     }\n }\n \n-// @has recursive_deref/struct.F.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for F'\n+// @has recursive_deref/struct.F.html '//h3[@class=\"code-header\"]' 'impl Deref for F'\n // We also check that `G::g` method isn't rendered because there is no `self` argument.\n // @!has '-' '//*[@id=\"deref-methods-G\"]' ''\n impl Deref for F {\n@@ -82,7 +82,7 @@ impl Deref for F {\n     }\n }\n \n-// @has recursive_deref/struct.G.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for G'\n+// @has recursive_deref/struct.G.html '//h3[@class=\"code-header\"]' 'impl Deref for G'\n impl Deref for G {\n     type Target = E;\n \n@@ -100,7 +100,7 @@ impl I {\n     pub fn i() {}\n }\n \n-// @has recursive_deref/struct.H.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for H'\n+// @has recursive_deref/struct.H.html '//h3[@class=\"code-header\"]' 'impl Deref for H'\n // @!has '-' '//*[@id=\"deref-methods-I\"]' ''\n impl Deref for H {\n     type Target = I;\n@@ -110,7 +110,7 @@ impl Deref for H {\n     }\n }\n \n-// @has recursive_deref/struct.I.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for I'\n+// @has recursive_deref/struct.I.html '//h3[@class=\"code-header\"]' 'impl Deref for I'\n impl Deref for I {\n     type Target = H;\n "}, {"sha": "8bd402291aabf39bab65b3dd5c8a3fb48c497aef", "filename": "src/test/rustdoc/rfc-2632-const-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -30,10 +30,10 @@ pub trait Tr<T> {\n }\n \n // @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]' ''\n-// @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header in-band\"]' '~const'\n-// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header in-band\"]/a[@class=\"trait\"]' 'Clone'\n-// @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header in-band\"]/span[@class=\"where\"]' '~const'\n-// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header in-band\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n+// @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]' '~const'\n+// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n+// @!has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n+// @has - '//section[@id=\"impl-Tr%3CT%3E-for-T\"]/h3[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n impl<T: ~const Clone + ~const Destruct> const Tr<T> for T\n where\n     Option<T>: ~const Clone + ~const Destruct,"}, {"sha": "6712af527a3779ae0bac5d00b1d7dab378c7e5c8", "filename": "src/test/rustdoc/sidebar-links-to-foreign-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsidebar-links-to-foreign-impl.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -6,9 +6,9 @@\n // @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#foreign-impls\"]' 'Implementations on Foreign Types'\n // @has - '//h2[@id=\"foreign-impls\"]' 'Implementations on Foreign Types'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo-for-u32\"]' 'u32'\n-// @has - '//*[@id=\"impl-Foo-for-u32\"]//h3[@class=\"code-header in-band\"]' 'impl Foo for u32'\n+// @has - '//*[@id=\"impl-Foo-for-u32\"]//h3[@class=\"code-header\"]' 'impl Foo for u32'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a[@href=\"#impl-Foo-for-%26%27a%20str\"]' \"&'a str\"\n-// @has - '//*[@id=\"impl-Foo-for-%26%27a%20str\"]//h3[@class=\"code-header in-band\"]' \"impl<'a> Foo for &'a str\"\n+// @has - '//*[@id=\"impl-Foo-for-%26%27a%20str\"]//h3[@class=\"code-header\"]' \"impl<'a> Foo for &'a str\"\n pub trait Foo {}\n \n impl Foo for u32 {}"}, {"sha": "feef4de8d57fe12e246648c3ab760f517603503e", "filename": "src/test/rustdoc/sized_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsized_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsized_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsized_trait.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -11,7 +11,7 @@ pub struct Bar {\n pub struct Foo<T: ?Sized>(T);\n \n // @has foo/struct.Unsized.html\n-// @has - '//*[@id=\"impl-Sized-for-Unsized\"]//h3[@class=\"code-header in-band\"]' 'impl !Sized for Unsized'\n+// @has - '//*[@id=\"impl-Sized-for-Unsized\"]//h3[@class=\"code-header\"]' 'impl !Sized for Unsized'\n pub struct Unsized {\n     data: [u8],\n }"}, {"sha": "953563833c9c74f3b4efdd9891d599f07b1bc92e", "filename": "src/test/rustdoc/src-links-auto-impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsrc-links-auto-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsrc-links-auto-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links-auto-impls.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,11 +1,11 @@\n #![crate_name = \"foo\"]\n \n // @has foo/struct.Unsized.html\n-// @has - '//*[@id=\"impl-Sized-for-Unsized\"]/h3[@class=\"code-header in-band\"]' 'impl !Sized for Unsized'\n+// @has - '//*[@id=\"impl-Sized-for-Unsized\"]/h3[@class=\"code-header\"]' 'impl !Sized for Unsized'\n // @!has - '//*[@id=\"impl-Sized-for-Unsized\"]//a[@class=\"srclink\"]' 'source'\n-// @has - '//*[@id=\"impl-Sync-for-Unsized\"]/h3[@class=\"code-header in-band\"]' 'impl Sync for Unsized'\n+// @has - '//*[@id=\"impl-Sync-for-Unsized\"]/h3[@class=\"code-header\"]' 'impl Sync for Unsized'\n // @!has - '//*[@id=\"impl-Sync-for-Unsized\"]//a[@class=\"srclink\"]' 'source'\n-// @has - '//*[@id=\"impl-Any-for-Unsized\"]/h3[@class=\"code-header in-band\"]' 'impl<T> Any for T'\n+// @has - '//*[@id=\"impl-Any-for-Unsized\"]/h3[@class=\"code-header\"]' 'impl<T> Any for T'\n // @has - '//*[@id=\"impl-Any-for-Unsized\"]//a[@class=\"srclink rightside\"]' 'source'\n pub struct Unsized {\n     data: [u8],"}, {"sha": "7c6a388653c4987a3c766613afc91ccab65d986a", "filename": "src/test/rustdoc/synthetic_auto/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fbasic.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,6 +1,6 @@\n // @has basic/struct.Foo.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<T> Send for Foo<T>where T: Send'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl<T> Sync for Foo<T>where T: Sync'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<T> Send for Foo<T>where T: Send'\n+// @has - '//h3[@class=\"code-header\"]' 'impl<T> Sync for Foo<T>where T: Sync'\n // @count - '//*[@id=\"implementations-list\"]//*[@class=\"impl has-srclink\"]' 0\n // @count - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]' 5\n pub struct Foo<T> {"}, {"sha": "43393c21fddb41600b4039250f710337f90469d8", "filename": "src/test/rustdoc/synthetic_auto/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -20,7 +20,7 @@ mod foo {\n }\n \n // @has complex/struct.NotOuter.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'a, T, K: ?Sized> Send for Outer<'a, T, K>where K: for<'b> Fn((&'b bool, &'a u8)) \\\n // -> &'b i8, T: MyTrait<'a>, <T as MyTrait<'a>>::MyItem: Copy, 'a: 'static\"\n "}, {"sha": "ed01f63f998b96f4113a916ea71be12c1146172a", "filename": "src/test/rustdoc/synthetic_auto/crate-local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcrate-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcrate-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcrate-local.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -3,7 +3,7 @@\n pub auto trait Banana {}\n \n // @has crate_local/struct.Peach.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Banana for Peach'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Send for Peach'\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Sync for Peach'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Banana for Peach'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Send for Peach'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Sync for Peach'\n pub struct Peach;"}, {"sha": "33170a844359b3ca09c2c42a9e7e5963f691f127", "filename": "src/test/rustdoc/synthetic_auto/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,10 +9,10 @@ where\n {}\n \n // @has lifetimes/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'c, K> Send for Foo<'c, K>where K: for<'b> Fn(&'b bool) -> &'c u8, 'c: 'static\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'c, K> Sync for Foo<'c, K>where K: Sync\"\n pub struct Foo<'c, K: 'c> {\n     inner_field: Inner<'c, K>,"}, {"sha": "77c04ad2ad942af03c327cf708a075a555d7a75c", "filename": "src/test/rustdoc/synthetic_auto/manual.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -1,8 +1,8 @@\n // @has manual/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // 'impl<T> Sync for Foo<T>where T: Sync'\n //\n-// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // 'impl<T> Send for Foo<T>'\n //\n // @count - '//*[@id=\"trait-implementations-list\"]//*[@class=\"impl has-srclink\"]' 1"}, {"sha": "2c2c848a5e0fb16db2574bd8015bf3e458b8e39a", "filename": "src/test/rustdoc/synthetic_auto/negative.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -3,10 +3,10 @@ pub struct Inner<T: Copy> {\n }\n \n // @has negative/struct.Outer.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Send for Outer<T>\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> !Sync for Outer<T>\"\n pub struct Outer<T: Copy> {\n     inner_field: Inner<T>,"}, {"sha": "423bf115ab165c735a52d857921518db5a7a898d", "filename": "src/test/rustdoc/synthetic_auto/nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,10 +9,10 @@ where\n }\n \n // @has nested/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // 'impl<T> Send for Foo<T>where T: Copy'\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // 'impl<T> Sync for Foo<T>where T: Sync'\n pub struct Foo<T> {\n     inner_field: Inner<T>,"}, {"sha": "59f33623322a928d99a56cfeab77f79c6bb75ed6", "filename": "src/test/rustdoc/synthetic_auto/no-redundancy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,7 +9,7 @@ where\n }\n \n // @has no_redundancy/struct.Outer.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> Send for Outer<T>where T: Send + Copy\"\n pub struct Outer<T> {\n     inner_field: Inner<T>,"}, {"sha": "35a487c764dc36a18f81be0d7670774420fbf435", "filename": "src/test/rustdoc/synthetic_auto/overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Foverflow.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -21,7 +21,7 @@ enum TyData<I: Interner> {\n struct VariableKind<I: Interner>(I::InternedType);\n \n // @has overflow/struct.BoundVarsCollector.html\n-// @has - '//h3[@class=\"code-header in-band\"]' \"impl<'tcx> Send for BoundVarsCollector<'tcx>\"\n+// @has - '//h3[@class=\"code-header\"]' \"impl<'tcx> Send for BoundVarsCollector<'tcx>\"\n pub struct BoundVarsCollector<'tcx> {\n     val: VariableKind<RustInterner<'tcx>>\n }"}, {"sha": "558ff2add400cae71a218ba9ffcfb11012cd4f3e", "filename": "src/test/rustdoc/synthetic_auto/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -23,10 +23,10 @@ where\n }\n \n // @has project/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'c, K> Send for Foo<'c, K>where K: MyTrait<MyItem = bool>, 'c: 'static\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<'c, K> Sync for Foo<'c, K>where K: MyTrait, <K as MyTrait>::MyItem: OtherTrait, \\\n // 'c: 'static,\"\n pub struct Foo<'c, K: 'c> {"}, {"sha": "c6ae96de77672381bd308742f21f5a528e3f2c6c", "filename": "src/test/rustdoc/synthetic_auto/self-referential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -23,7 +23,7 @@ impl<T> Pattern for Wrapper<T> {\n \n \n // @has self_referential/struct.WriteAndThen.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<P1> Send for WriteAndThen<P1>where    <P1 as Pattern>::Value: Send\"\n pub struct WriteAndThen<P1>(pub P1::Value,pub <Constrain<P1, Wrapper<P1::Value>> as Pattern>::Value)\n     where P1: Pattern;"}, {"sha": "1a76cb919c2989748d476bbbfe3aabdf572ad941", "filename": "src/test/rustdoc/synthetic_auto/static-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -3,7 +3,7 @@ pub trait OwnedTrait<'a> {\n }\n \n // @has static_region/struct.Owned.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n // \"impl<T> Send for Owned<T>where <T as OwnedTrait<'static>>::Reader: Send\"\n pub struct Owned<T> where T: OwnedTrait<'static> {\n     marker: <T as OwnedTrait<'static>>::Reader,"}, {"sha": "a65dd7a546cdcfd2179fbab76a011d28bab6f73e", "filename": "src/test/rustdoc/traits-in-bodies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -4,7 +4,7 @@\n pub struct Bounded<T: Clone>(T);\n \n // @has traits_in_bodies/struct.SomeStruct.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Clone for SomeStruct'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Clone for SomeStruct'\n pub struct SomeStruct;\n \n fn asdf() -> Bounded<SomeStruct> {\n@@ -18,7 +18,7 @@ fn asdf() -> Bounded<SomeStruct> {\n }\n \n // @has traits_in_bodies/struct.Point.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Copy for Point'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Copy for Point'\n #[derive(Clone)]\n pub struct Point {\n     x: i32,\n@@ -31,7 +31,7 @@ const _FOO: () = {\n };\n \n // @has traits_in_bodies/struct.Inception.html\n-// @has - '//h3[@class=\"code-header in-band\"]' 'impl Clone for Inception'\n+// @has - '//h3[@class=\"code-header\"]' 'impl Clone for Inception'\n pub struct Inception;\n \n static _BAR: usize = {"}, {"sha": "d5dfa9484891a66a341c89c723ededde9d2030ee", "filename": "src/test/rustdoc/typedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ftypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Ftypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftypedef.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -9,8 +9,8 @@ impl MyStruct {\n }\n \n // @has typedef/type.MyAlias.html\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'impl MyAlias'\n-// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' 'impl MyTrait for MyAlias'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'impl MyAlias'\n+// @has - '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' 'impl MyTrait for MyAlias'\n // @hasraw - 'Alias docstring'\n // @has - '//*[@class=\"sidebar\"]//*[@class=\"location\"]' 'MyAlias'\n // @has - '//*[@class=\"sidebar\"]//a[@href=\"#implementations\"]' 'Methods'"}, {"sha": "8b5bce28f5a2ac4cbc3552fd7d0fb0cb5de95ce5", "filename": "src/test/rustdoc/where.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -13,7 +13,7 @@ pub fn charlie<C>() where C: MyTrait {}\n \n pub struct Delta<D>(D);\n \n-// @has foo/struct.Delta.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/struct.Delta.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n //          \"impl<D> Delta<D>where D: MyTrait\"\n impl<D> Delta<D> where D: MyTrait {\n     pub fn delta() {}\n@@ -43,17 +43,17 @@ pub trait TraitWhere {\n     { todo!() }\n }\n \n-// @has foo/struct.Echo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/struct.Echo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n //          \"impl<E> MyTrait for Echo<E>where E: MyTrait\"\n-// @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header\"]' \\\n //          \"impl<E> MyTrait for Echo<E>where E: MyTrait\"\n impl<E> MyTrait for Echo<E>where E: MyTrait {}\n \n pub enum Foxtrot<F> { Foxtrot1(F) }\n \n-// @has foo/enum.Foxtrot.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/enum.Foxtrot.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n //          \"impl<F> MyTrait for Foxtrot<F>where F: MyTrait\"\n-// @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header in-band\"]' \\\n+// @has foo/trait.MyTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header\"]' \\\n //          \"impl<F> MyTrait for Foxtrot<F>where F: MyTrait\"\n impl<F> MyTrait for Foxtrot<F>where F: MyTrait {}\n "}, {"sha": "ad481c14bab8d9905e4f69fbad4cd74d3fb81881", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 79, "deletions": 9, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -76,13 +76,15 @@ struct InvalidNestedStructAttr1 {}\n #[derive(Diagnostic)]\n #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr2 {}\n \n #[derive(Diagnostic)]\n #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr3 {}\n \n #[derive(Diagnostic)]\n@@ -217,6 +219,7 @@ struct Suggest {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutCode {\n     #[suggestion(typeck::suggestion)]\n+    //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -225,6 +228,7 @@ struct SuggestWithoutCode {\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n+    //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -233,6 +237,7 @@ struct SuggestWithBadKey {\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n+    //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -269,16 +274,16 @@ struct SuggestWithSpanOnly {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n-    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n     suggestion: (Span, Span, Applicability),\n+    //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n-    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n     suggestion: (Applicability, Applicability, Span),\n+    //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n@@ -294,7 +299,7 @@ struct WrongKindOfAnnotation {\n struct OptionsInErrors {\n     #[label(typeck::label)]\n     label: Option<Span>,\n-    #[suggestion(typeck::suggestion)]\n+    #[suggestion(typeck::suggestion, code = \"...\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n@@ -436,7 +441,7 @@ struct ErrorWithNoteCustomWrongOrder {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ApplicabilityInBoth {\n     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n-    //~^ ERROR applicability cannot be set in both the field and attribute\n+    //~^ ERROR specified multiple times\n     suggestion: (Span, Applicability),\n }\n \n@@ -507,23 +512,23 @@ struct OptUnitField {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingPath {\n     #[label(typeck::label, foo)]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n     #[label(typeck::label, foo = \"...\")]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo = ...)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingList {\n     #[label(typeck::label, foo(\"...\"))]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo(...))]` is not a valid attribute\n     span: Span,\n }\n \n@@ -581,3 +586,68 @@ struct LintAttributeOnSessionDiag {}\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `lint` in this scope\n struct LintAttributeOnLintDiag {}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct DuplicatedSuggestionCode {\n+    #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n+    //~^ ERROR specified multiple times\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct InvalidTypeInSuggestionTuple {\n+    #[suggestion(typeck::suggestion, code = \"...\")]\n+    suggestion: (Span, usize),\n+    //~^ ERROR wrong types for suggestion\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct MissingApplicabilityInSuggestionTuple {\n+    #[suggestion(typeck::suggestion, code = \"...\")]\n+    suggestion: (Span,),\n+    //~^ ERROR wrong types for suggestion\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct MissingCodeInSuggestion {\n+    #[suggestion(typeck::suggestion)]\n+    //~^ ERROR suggestion without `code = \"...\"`\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[multipart_suggestion(typeck::suggestion)]\n+//~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+//~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+#[multipart_suggestion()]\n+//~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+//~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+struct MultipartSuggestion {\n+    #[multipart_suggestion(typeck::suggestion)]\n+    //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+    //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[suggestion(typeck::suggestion, code = \"...\")]\n+//~^ ERROR `#[suggestion(...)]` is not a valid attribute\n+struct SuggestionOnStruct {\n+    #[primary_span]\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[label]\n+//~^ ERROR `#[label]` is not a valid attribute\n+struct LabelOnStruct {\n+    #[primary_span]\n+    suggestion: Span,\n+}"}, {"sha": "9919b12beaf0a54edf0b0f53122900e9583232ff", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 216, "deletions": 84, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -20,8 +20,6 @@ error: `#[nonsense(...)]` is not a valid attribute\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: only `diag`, `help`, `note` and `warning` are valid attributes\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:53:1\n@@ -41,7 +39,7 @@ error: `#[diag(\"...\")]` is not a valid attribute\n LL | #[diag(\"E0123\")]\n    |        ^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:60:1\n@@ -60,7 +58,7 @@ error: `#[diag(nonsense(...))]` is not a valid attribute\n LL | #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:71:1\n@@ -79,104 +77,122 @@ error: `#[diag(nonsense = ...)]` is not a valid attribute\n LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: only `code` is a valid nested attributes following the slug\n+\n+error: `#[diag(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:77:42\n+   |\n+LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+   |                                          ^^^^^^^^^^^^\n+   |\n+   = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:77:1\n    |\n LL | / #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n+LL | |\n LL | | struct InvalidNestedStructAttr2 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:83:8\n+  --> $DIR/diagnostic-derive.rs:84:8\n    |\n LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^\n+\n+error: `#[diag(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:84:38\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+   |                                      ^^^^^^^^^^^^\n+   |\n+   = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:83:1\n+  --> $DIR/diagnostic-derive.rs:84:1\n    |\n LL | / #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n+LL | |\n LL | | struct InvalidNestedStructAttr3 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:89:58\n+  --> $DIR/diagnostic-derive.rs:91:58\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n    |                                                          ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:96:5\n+  --> $DIR/diagnostic-derive.rs:98:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:103:1\n+  --> $DIR/diagnostic-derive.rs:105:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:102:1\n+  --> $DIR/diagnostic-derive.rs:104:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:103:49\n+  --> $DIR/diagnostic-derive.rs:105:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:102:49\n+  --> $DIR/diagnostic-derive.rs:104:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |                                                 ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:65\n+  --> $DIR/diagnostic-derive.rs:111:65\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:109:49\n+  --> $DIR/diagnostic-derive.rs:111:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                 ^^^^^^^\n \n error: `#[diag(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:114:42\n+  --> $DIR/diagnostic-derive.rs:116:42\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: diagnostic slug must be the first argument\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:119:1\n+  --> $DIR/diagnostic-derive.rs:121:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:122:1\n+  --> $DIR/diagnostic-derive.rs:124:1\n    |\n LL | / #[diag(code = \"E0456\")]\n LL | |\n@@ -186,33 +202,31 @@ LL | | struct SlugNotProvided {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:133:5\n+  --> $DIR/diagnostic-derive.rs:135:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:141:5\n+  --> $DIR/diagnostic-derive.rs:143:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n-   |\n-   = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:158:5\n+  --> $DIR/diagnostic-derive.rs:160:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:166:45\n+  --> $DIR/diagnostic-derive.rs:168:45\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n    |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:171:16\n+  --> $DIR/diagnostic-derive.rs:173:16\n    |\n LL | #[derive(Diagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -223,7 +237,7 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:181:15\n+  --> $DIR/diagnostic-derive.rs:183:15\n    |\n LL | #[derive(Diagnostic)]\n    |               ^ unmatched `}` in format string\n@@ -232,29 +246,47 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:201:5\n+  --> $DIR/diagnostic-derive.rs:203:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:221:5\n+   |\n+LL |     #[suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:226:18\n+  --> $DIR/diagnostic-derive.rs:229:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n-   = help: only `message`, `code` and `applicability` are valid field attributes\n+   = help: only `code` and `applicability` are valid nested attributes\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:229:5\n+   |\n+LL |     #[suggestion(nonsense = \"bar\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:234:18\n+  --> $DIR/diagnostic-derive.rs:238:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n-   = help: only `message`, `code` and `applicability` are valid field attributes\n+   = help: only `code` and `applicability` are valid nested attributes\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:238:5\n+   |\n+LL |     #[suggestion(msg = \"bar\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:256:5\n+  --> $DIR/diagnostic-derive.rs:261:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n@@ -263,76 +295,90 @@ LL | |     suggestion: Applicability,\n    |\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n-error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/diagnostic-derive.rs:271:5\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:277:24\n    |\n-LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n-LL | |\n-LL | |     suggestion: (Span, Span, Applicability),\n-   | |___________________________________________^\n+LL |     suggestion: (Span, Span, Applicability),\n+   |                        ^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:277:18\n+   |\n+LL |     suggestion: (Span, Span, Applicability),\n+   |                  ^^^^\n \n-error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/diagnostic-derive.rs:279:5\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:285:33\n    |\n-LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n-LL | |\n-LL | |     suggestion: (Applicability, Applicability, Span),\n-   | |____________________________________________________^\n+LL |     suggestion: (Applicability, Applicability, Span),\n+   |                                 ^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:285:18\n+   |\n+LL |     suggestion: (Applicability, Applicability, Span),\n+   |                  ^^^^^^^^^^^^^\n \n error: `#[label = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:287:5\n+  --> $DIR/diagnostic-derive.rs:292:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: applicability cannot be set in both the field and attribute\n-  --> $DIR/diagnostic-derive.rs:438:52\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:443:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:445:24\n+   |\n+LL |     suggestion: (Span, Applicability),\n+   |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:446:52\n+  --> $DIR/diagnostic-derive.rs:451:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:509:5\n+error: `#[label(foo)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:514:28\n    |\n LL |     #[label(typeck::label, foo)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^\n+   |\n+   = help: a diagnostic slug must be the first argument to the attribute\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:517:5\n+error: `#[label(foo = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:522:28\n    |\n LL |     #[label(typeck::label, foo = \"...\")]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:525:5\n+error: `#[label(foo(...))]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:530:28\n    |\n LL |     #[label(typeck::label, foo(\"...\"))]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:538:5\n+  --> $DIR/diagnostic-derive.rs:543:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: the `primary_span` field attribute is not valid for lint diagnostics\n \n error: `#[error(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:558:1\n+  --> $DIR/diagnostic-derive.rs:563:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:558:1\n+  --> $DIR/diagnostic-derive.rs:563:1\n    |\n LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -344,15 +390,13 @@ LL | | struct ErrorAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:565:1\n+  --> $DIR/diagnostic-derive.rs:570:1\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `warn_` have been replaced by `warning`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:565:1\n+  --> $DIR/diagnostic-derive.rs:570:1\n    |\n LL | / #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -364,15 +408,13 @@ LL | | struct WarnAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:572:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:572:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -384,15 +426,13 @@ LL | | struct LintAttributeOnSessionDiag {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:579:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:579:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -403,50 +443,142 @@ LL | | struct LintAttributeOnLintDiag {}\n    |\n    = help: specify the slug as the first argument to the attribute, such as `#[diag(typeck::example_error)]`\n \n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:593:52\n+   |\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n+   |                                                    ^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:593:38\n+   |\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n+   |                                      ^^^^^^^^^^^^\n+\n+error: wrong types for suggestion\n+  --> $DIR/diagnostic-derive.rs:602:24\n+   |\n+LL |     suggestion: (Span, usize),\n+   |                        ^^^^^\n+   |\n+   = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n+\n+error: wrong types for suggestion\n+  --> $DIR/diagnostic-derive.rs:610:17\n+   |\n+LL |     suggestion: (Span,),\n+   |                 ^^^^^^^\n+   |\n+   = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:617:5\n+   |\n+LL |     #[suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:624:1\n+   |\n+LL | #[multipart_suggestion(typeck::suggestion)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:627:1\n+   |\n+LL | #[multipart_suggestion()]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:631:5\n+   |\n+LL |     #[multipart_suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:639:1\n+   |\n+LL | #[suggestion(typeck::suggestion, code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `#[label]` and `#[suggestion]` can only be applied to fields\n+\n+error: `#[label]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:648:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+   |\n+   = help: `#[label]` and `#[suggestion]` can only be applied to fields\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:53:3\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:141:7\n+  --> $DIR/diagnostic-derive.rs:143:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error: cannot find attribute `error` in this scope\n-  --> $DIR/diagnostic-derive.rs:558:3\n+  --> $DIR/diagnostic-derive.rs:563:3\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n-  --> $DIR/diagnostic-derive.rs:565:3\n+  --> $DIR/diagnostic-derive.rs:570:3\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:572:3\n+  --> $DIR/diagnostic-derive.rs:577:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:579:3\n+  --> $DIR/diagnostic-derive.rs:584:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:624:3\n+   |\n+LL | #[multipart_suggestion(typeck::suggestion)]\n+   |   ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:627:3\n+   |\n+LL | #[multipart_suggestion()]\n+   |   ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:631:7\n+   |\n+LL |     #[multipart_suggestion(typeck::suggestion)]\n+   |       ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n   --> $DIR/diagnostic-derive.rs:66:8\n    |\n LL | #[diag(nonsense, code = \"E0123\")]\n    |        ^^^^^^^^ not found in `rustc_errors::fluent`\n \n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:331:10\n+  --> $DIR/diagnostic-derive.rs:336:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -459,7 +591,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 55 previous errors\n+error: aborting due to 72 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "606b3b5e5ebca1943bc5e3a74347bf9b75d48d71", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -52,7 +52,7 @@ struct C {\n \n #[derive(Subdiagnostic)]\n #[label]\n-//~^ ERROR `#[label]` is not a valid attribute\n+//~^ ERROR diagnostic slug must be first argument\n struct D {\n     #[primary_span]\n     span: Span,\n@@ -81,6 +81,7 @@ struct F {\n #[derive(Subdiagnostic)]\n #[label(bug = \"...\")]\n //~^ ERROR `#[label(bug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct G {\n     #[primary_span]\n     span: Span,\n@@ -90,6 +91,7 @@ struct G {\n #[derive(Subdiagnostic)]\n #[label(\"...\")]\n //~^ ERROR `#[label(\"...\")]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct H {\n     #[primary_span]\n     span: Span,\n@@ -99,6 +101,7 @@ struct H {\n #[derive(Subdiagnostic)]\n #[label(slug = 4)]\n //~^ ERROR `#[label(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct J {\n     #[primary_span]\n     span: Span,\n@@ -108,6 +111,7 @@ struct J {\n #[derive(Subdiagnostic)]\n #[label(slug(\"...\"))]\n //~^ ERROR `#[label(slug(...))]` is not a valid attribute\n+//~| ERROR diagnostic slug must be first argument\n struct K {\n     #[primary_span]\n     span: Span,\n@@ -135,7 +139,7 @@ struct M {\n \n #[derive(Subdiagnostic)]\n #[label(parser::add_paren, code = \"...\")]\n-//~^ ERROR `code` is not a valid nested attribute of a `label` attribute\n+//~^ ERROR `#[label(code = ...)]` is not a valid attribute\n struct N {\n     #[primary_span]\n     span: Span,\n@@ -144,7 +148,7 @@ struct N {\n \n #[derive(Subdiagnostic)]\n #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-//~^ ERROR `applicability` is not a valid nested attribute of a `label` attribute\n+//~^ ERROR `#[label(applicability = ...)]` is not a valid attribute\n struct O {\n     #[primary_span]\n     span: Span,\n@@ -216,6 +220,7 @@ enum T {\n enum U {\n     #[label(code = \"...\")]\n     //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+    //~| ERROR `#[label(code = ...)]` is not a valid attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -531,7 +536,7 @@ struct BA {\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n //~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n-//~| ERROR `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+//~| ERROR `#[multipart_suggestion(code = ...)]` is not a valid attribute\n struct BBa {\n     var: String,\n }\n@@ -612,10 +617,9 @@ struct BG {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-//~^ NOTE previously specified here\n struct BH {\n     #[applicability]\n-    //~^ ERROR specified multiple times\n+    //~^ ERROR `#[applicability]` has no effect\n     appl: Applicability,\n     #[suggestion_part(code = \"(\")]\n     first: Span,"}, {"sha": "171b89e657d81eb12d03766c8ef3325995fc526b", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 95, "deletions": 77, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -8,7 +8,7 @@ LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `#[label]` is not a valid attribute\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:54:1\n    |\n LL | #[label]\n@@ -31,101 +31,123 @@ error: `#[label(bug = ...)]` is not a valid attribute\n    |\n LL | #[label(bug = \"...\")]\n    |         ^^^^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:82:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(bug = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(\"...\")]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:91:9\n+  --> $DIR/subdiagnostic-derive.rs:92:9\n    |\n LL | #[label(\"...\")]\n    |         ^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:92:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(\"...\")]\n+   | ^^^^^^^^^^^^^^^\n \n error: `#[label(slug = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:100:9\n+  --> $DIR/subdiagnostic-derive.rs:102:9\n    |\n LL | #[label(slug = 4)]\n    |         ^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:102:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(slug = 4)]\n+   | ^^^^^^^^^^^^^^^^^^\n \n error: `#[label(slug(...))]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:109:9\n+  --> $DIR/subdiagnostic-derive.rs:112:9\n    |\n LL | #[label(slug(\"...\"))]\n    |         ^^^^^^^^^^^\n+\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:112:1\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[label(slug(\"...\"))]\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:128:1\n+  --> $DIR/subdiagnostic-derive.rs:132:1\n    |\n LL | #[label()]\n    | ^^^^^^^^^^\n \n-error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:137:28\n+error: `#[label(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:141:28\n    |\n LL | #[label(parser::add_paren, code = \"...\")]\n    |                            ^^^^^^^^^^^^\n \n-error: `applicability` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:146:28\n+error: `#[label(applicability = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:150:28\n    |\n LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:155:1\n+  --> $DIR/subdiagnostic-derive.rs:159:1\n    |\n LL | #[foo]\n    | ^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:169:5\n+  --> $DIR/subdiagnostic-derive.rs:173:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:181:5\n+  --> $DIR/subdiagnostic-derive.rs:185:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:193:5\n+  --> $DIR/subdiagnostic-derive.rs:197:5\n    |\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:205:5\n+  --> $DIR/subdiagnostic-derive.rs:209:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n+error: `#[label(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:221:13\n+   |\n+LL |     #[label(code = \"...\")]\n+   |             ^^^^^^^^^^^^\n+\n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:217:5\n+  --> $DIR/subdiagnostic-derive.rs:221:5\n    |\n LL |     #[label(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:234:5\n+  --> $DIR/subdiagnostic-derive.rs:239:5\n    |\n LL |     B {\n    |     ^\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:246:5\n+  --> $DIR/subdiagnostic-derive.rs:251:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: label without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:243:1\n+  --> $DIR/subdiagnostic-derive.rs:248:1\n    |\n LL | / #[label(parser::add_paren)]\n LL | |\n@@ -137,35 +159,35 @@ LL | | }\n    | |_^\n \n error: `#[applicability]` is only valid on suggestions\n-  --> $DIR/subdiagnostic-derive.rs:256:5\n+  --> $DIR/subdiagnostic-derive.rs:261:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:266:5\n+  --> $DIR/subdiagnostic-derive.rs:271:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:277:5\n+  --> $DIR/subdiagnostic-derive.rs:282:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:288:5\n+  --> $DIR/subdiagnostic-derive.rs:293:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n-  --> $DIR/subdiagnostic-derive.rs:304:1\n+  --> $DIR/subdiagnostic-derive.rs:309:1\n    |\n LL | / union AC {\n LL | |\n@@ -175,75 +197,75 @@ LL | | }\n    | |_^\n \n error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:319:28\n+  --> $DIR/subdiagnostic-derive.rs:324:28\n    |\n LL | #[label(parser::add_paren, parser::add_paren)]\n    |                            ^^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:332:5\n+  --> $DIR/subdiagnostic-derive.rs:337:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:329:5\n+  --> $DIR/subdiagnostic-derive.rs:334:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:338:8\n+  --> $DIR/subdiagnostic-derive.rs:343:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:375:47\n+  --> $DIR/subdiagnostic-derive.rs:380:47\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:375:33\n+  --> $DIR/subdiagnostic-derive.rs:380:33\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:393:5\n+  --> $DIR/subdiagnostic-derive.rs:398:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:390:5\n+  --> $DIR/subdiagnostic-derive.rs:395:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:403:5\n+  --> $DIR/subdiagnostic-derive.rs:408:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:416:1\n+  --> $DIR/subdiagnostic-derive.rs:421:1\n    |\n LL | #[suggestion(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:426:46\n+  --> $DIR/subdiagnostic-derive.rs:431:46\n    |\n LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n    |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:444:1\n+  --> $DIR/subdiagnostic-derive.rs:449:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n@@ -253,41 +275,41 @@ LL | | }\n    | |_^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:458:1\n+  --> $DIR/subdiagnostic-derive.rs:463:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:478:39\n+  --> $DIR/subdiagnostic-derive.rs:483:39\n    |\n LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n    |                                       ^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:497:43\n+  --> $DIR/subdiagnostic-derive.rs:502:43\n    |\n LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n    |                                           ^^^^^^^\n \n error: `#[suggestion_part]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:520:5\n+  --> $DIR/subdiagnostic-derive.rs:525:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n \n error: `#[suggestion_part(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:523:5\n+  --> $DIR/subdiagnostic-derive.rs:528:5\n    |\n LL |     #[suggestion_part(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:517:1\n+  --> $DIR/subdiagnostic-derive.rs:522:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n@@ -298,14 +320,16 @@ LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n-  --> $DIR/subdiagnostic-derive.rs:532:43\n+error: `#[multipart_suggestion(code = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:537:43\n    |\n LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n    |                                           ^^^^^^^^^^^^\n+   |\n+   = help: only `applicability` is a valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:532:1\n+  --> $DIR/subdiagnostic-derive.rs:537:1\n    |\n LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n@@ -316,27 +340,27 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:542:5\n+  --> $DIR/subdiagnostic-derive.rs:547:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:550:5\n+  --> $DIR/subdiagnostic-derive.rs:555:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:559:5\n+  --> $DIR/subdiagnostic-derive.rs:564:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:556:1\n+  --> $DIR/subdiagnostic-derive.rs:561:1\n    |\n LL | / #[multipart_suggestion(parser::add_paren)]\n LL | |\n@@ -348,60 +372,54 @@ LL | | }\n    | |_^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:567:5\n+  --> $DIR/subdiagnostic-derive.rs:572:5\n    |\n LL |     #[suggestion_part]\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:570:5\n+  --> $DIR/subdiagnostic-derive.rs:575:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:573:23\n+  --> $DIR/subdiagnostic-derive.rs:578:23\n    |\n LL |     #[suggestion_part(foo = \"bar\")]\n    |                       ^^^^^^^^^^^\n    |\n    = help: `code` is the only valid nested attribute\n \n error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:576:5\n+  --> $DIR/subdiagnostic-derive.rs:581:5\n    |\n LL |     #[suggestion_part(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:579:5\n+  --> $DIR/subdiagnostic-derive.rs:584:5\n    |\n LL |     #[suggestion_part()]\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:587:37\n+  --> $DIR/subdiagnostic-derive.rs:592:37\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n    |                                     ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:587:23\n+  --> $DIR/subdiagnostic-derive.rs:592:23\n    |\n LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n    |                       ^^^^^^^^^^^^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:617:5\n+error: `#[applicability]` has no effect if all `#[suggestion]`/`#[multipart_suggestion]` attributes have a static `applicability = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:621:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:614:43\n-   |\n-LL | #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -410,59 +428,59 @@ LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `foo` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:155:3\n+  --> $DIR/subdiagnostic-derive.rs:159:3\n    |\n LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:169:7\n+  --> $DIR/subdiagnostic-derive.rs:173:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:181:7\n+  --> $DIR/subdiagnostic-derive.rs:185:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:193:7\n+  --> $DIR/subdiagnostic-derive.rs:197:7\n    |\n LL |     #[bar = 4]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:205:7\n+  --> $DIR/subdiagnostic-derive.rs:209:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:266:7\n+  --> $DIR/subdiagnostic-derive.rs:271:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:277:7\n+  --> $DIR/subdiagnostic-derive.rs:282:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:288:7\n+  --> $DIR/subdiagnostic-derive.rs:293:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n-  --> $DIR/subdiagnostic-derive.rs:118:9\n+  --> $DIR/subdiagnostic-derive.rs:122:9\n    |\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 63 previous errors\n+error: aborting due to 68 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "9a35f6515cb1a5042d347347dca5a8cc8508fff3", "filename": "src/test/ui/async-await/in-trait/issue-102219.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe217c28ffc6955f0927d8e8715d43d727debe5a/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs?ref=fe217c28ffc6955f0927d8e8715d43d727debe5a", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags:--crate-type=lib\n+// edition:2021\n+// check-pass\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait T {\n+    async fn foo();\n+}"}]}