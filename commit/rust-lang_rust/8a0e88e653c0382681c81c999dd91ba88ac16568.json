{"sha": "8a0e88e653c0382681c81c999dd91ba88ac16568", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMGU4OGU2NTNjMDM4MjY4MWM4MWM5OTlkZDkxYmE4OGFjMTY1Njg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-24T00:47:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-24T00:47:38Z"}, "message": "Rollup merge of #71492 - LeSeulArtichaut:document-unsafe-2, r=Mark-Simulacrum\n\nDocument unsafety in core::{panicking, alloc::layout, hint, iter::adapters::zip}\n\nHelps with #66219.\nr? @Mark-Simulacrum do you want to continue reading safety comments? :D", "tree": {"sha": "be8f505326157d0cad29a4ca5c24ad6ce8eafb19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8f505326157d0cad29a4ca5c24ad6ce8eafb19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a0e88e653c0382681c81c999dd91ba88ac16568", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeojcqCRBK7hj4Ov3rIwAAdHIIAA5Am75gKlIslRL7LFdUvQl8\najwGEC98yEDN0R94ESwuY6U/WoQmAk5DXxUo3H1StzrGPCV5Wz+G9ZaEaRz2SyUQ\nf+nNWv7ffT0dgF7UVrW8XBdWhwJ8Q8Y7jIa3I9yDHY3q7XK//tJYAZOpRAdit3Ub\nEY72C7J6CcjX/9QVHeh8CTuacwVZusKRdX0IGCEmNUmzxfGKpnDbWonYGrqiUoC7\nA7vQjXYGOFXln2OrCGr3lRwEz2WiuxLmS+9/xezc0bx0WZoeJaLE5VxFbdv49Zay\nCs+M5D24eivHjg+JjzOPqW4elpQmFYBhZMDQGyYbzM06ctbPQdsoyI3xYjpXXw8=\n=znWm\n-----END PGP SIGNATURE-----\n", "payload": "tree be8f505326157d0cad29a4ca5c24ad6ce8eafb19\nparent ed25ca0efbb1f611ebf6f028ce4af3fdf9ef9c67\nparent d515168f3ba481ee633099753f75e4e62750e6b4\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587689258 +0200\ncommitter GitHub <noreply@github.com> 1587689258 +0200\n\nRollup merge of #71492 - LeSeulArtichaut:document-unsafe-2, r=Mark-Simulacrum\n\nDocument unsafety in core::{panicking, alloc::layout, hint, iter::adapters::zip}\n\nHelps with #66219.\nr? @Mark-Simulacrum do you want to continue reading safety comments? :D\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0e88e653c0382681c81c999dd91ba88ac16568", "html_url": "https://github.com/rust-lang/rust/commit/8a0e88e653c0382681c81c999dd91ba88ac16568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a0e88e653c0382681c81c999dd91ba88ac16568/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed25ca0efbb1f611ebf6f028ce4af3fdf9ef9c67", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed25ca0efbb1f611ebf6f028ce4af3fdf9ef9c67", "html_url": "https://github.com/rust-lang/rust/commit/ed25ca0efbb1f611ebf6f028ce4af3fdf9ef9c67"}, {"sha": "d515168f3ba481ee633099753f75e4e62750e6b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d515168f3ba481ee633099753f75e4e62750e6b4", "html_url": "https://github.com/rust-lang/rust/commit/d515168f3ba481ee633099753f75e4e62750e6b4"}], "stats": {"total": 44, "additions": 28, "deletions": 16}, "files": [{"sha": "a09c2387d0de2b597c476ffec8d78e3a568cefde", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=8a0e88e653c0382681c81c999dd91ba88ac16568", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-undocumented-unsafe\n-\n use crate::cmp;\n use crate::fmt;\n use crate::mem;\n@@ -77,6 +75,8 @@ impl Layout {\n             return Err(LayoutErr { private: () });\n         }\n \n+        // SAFETY: the conditions for `from_size_align_unchecked` have been\n+        // checked above.\n         unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n     }\n \n@@ -115,7 +115,7 @@ impl Layout {\n     #[inline]\n     pub const fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n-        // Note that the align is guaranteed by rustc to be a power of two and\n+        // SAFETY: the align is guaranteed by Rust to be a power of two and\n         // the size+align combo is guaranteed to fit in our address space. As a\n         // result use the unchecked constructor here to avoid inserting code\n         // that panics if it isn't optimized well enough.\n@@ -129,8 +129,8 @@ impl Layout {\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this is using an unsafe variant below\n         debug_assert!(Layout::from_size_align(size, align).is_ok());\n+        // SAFETY: see rationale in `new` for why this is using an unsafe variant below\n         unsafe { Layout::from_size_align_unchecked(size, align) }\n     }\n \n@@ -143,7 +143,7 @@ impl Layout {\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n     #[inline]\n     pub const fn dangling(&self) -> NonNull<u8> {\n-        // align is non-zero and a power of two\n+        // SAFETY: align is guaranteed to be non-zero\n         unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n     }\n \n@@ -249,11 +249,9 @@ impl Layout {\n         let padded_size = self.size() + self.padding_needed_for(self.align());\n         let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n \n-        unsafe {\n-            // self.align is already known to be valid and alloc_size has been\n-            // padded already.\n-            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n-        }\n+        // SAFETY: self.align is already known to be valid and alloc_size has been\n+        // padded already.\n+        unsafe { Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }\n     }\n \n     /// Creates a layout describing the record for `self` followed by"}, {"sha": "0d794de5fe84b3233d904382b15959203c126b33", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8a0e88e653c0382681c81c999dd91ba88ac16568", "patch": "@@ -2,8 +2,6 @@\n \n //! Hints to compiler that affects how code should be emitted or optimized.\n \n-// ignore-tidy-undocumented-unsafe\n-\n use crate::intrinsics;\n \n /// Informs the compiler that this point in the code is not reachable, enabling\n@@ -68,11 +66,13 @@ pub fn spin_loop() {\n     {\n         #[cfg(target_arch = \"x86\")]\n         {\n+            // SAFETY: the `cfg` attr ensures that we only execute this on x86 targets.\n             unsafe { crate::arch::x86::_mm_pause() };\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n         {\n+            // SAFETY: the `cfg` attr ensures that we only execute this on x86_64 targets.\n             unsafe { crate::arch::x86_64::_mm_pause() };\n         }\n     }\n@@ -81,10 +81,13 @@ pub fn spin_loop() {\n     {\n         #[cfg(target_arch = \"aarch64\")]\n         {\n+            // SAFETY: the `cfg` attr ensures that we only execute this on aarch64 targets.\n             unsafe { crate::arch::aarch64::__yield() };\n         }\n         #[cfg(target_arch = \"arm\")]\n         {\n+            // SAFETY: the `cfg` attr ensures that we only execute this on arm targets\n+            // with support for the v6 feature.\n             unsafe { crate::arch::arm::__yield() };\n         }\n     }\n@@ -112,6 +115,8 @@ pub fn black_box<T>(dummy: T) -> T {\n     // this. LLVM's interpretation of inline assembly is that it's, well, a black\n     // box. This isn't the greatest implementation since it probably deoptimizes\n     // more than we want, but it's so far good enough.\n+\n+    // SAFETY: the inline assembly is a no-op.\n     unsafe {\n         llvm_asm!(\"\" : : \"r\"(&dummy));\n         dummy"}, {"sha": "e83d36a580f06464022d3b0b51bb0f2c9f64f142", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=8a0e88e653c0382681c81c999dd91ba88ac16568", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-undocumented-unsafe\n-\n use crate::cmp;\n \n use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n@@ -176,9 +174,11 @@ where\n         if self.index < self.len {\n             let i = self.index;\n             self.index += 1;\n+            // SAFETY: `i` is smaller than `self.len`, thus smaller than `self.a.len()` and `self.b.len()`\n             unsafe { Some((self.a.get_unchecked(i), self.b.get_unchecked(i))) }\n         } else if A::may_have_side_effect() && self.index < self.a.len() {\n             // match the base implementation's potential side effects\n+            // SAFETY: we just checked that `self.index` < `self.a.len()`\n             unsafe {\n                 self.a.get_unchecked(self.index);\n             }\n@@ -203,11 +203,15 @@ where\n             let i = self.index;\n             self.index += 1;\n             if A::may_have_side_effect() {\n+                // SAFETY: the usage of `cmp::min` to calculate `delta`\n+                // ensures that `end` is smaller than or equal to `self.len`,\n+                // so `i` is also smaller than `self.len`.\n                 unsafe {\n                     self.a.get_unchecked(i);\n                 }\n             }\n             if B::may_have_side_effect() {\n+                // SAFETY: same as above.\n                 unsafe {\n                     self.b.get_unchecked(i);\n                 }\n@@ -243,6 +247,8 @@ where\n         if self.index < self.len {\n             self.len -= 1;\n             let i = self.len;\n+            // SAFETY: `i` is smaller than the previous value of `self.len`,\n+            // which is also smaller than or equal to `self.a.len()` and `self.b.len()`\n             unsafe { Some((self.a.get_unchecked(i), self.b.get_unchecked(i))) }\n         } else {\n             None"}, {"sha": "1e4209fd26be3b459e926ba0df8a60dadbf6e1e1", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0e88e653c0382681c81c999dd91ba88ac16568/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=8a0e88e653c0382681c81c999dd91ba88ac16568", "patch": "@@ -19,8 +19,6 @@\n //! necessary lang items for the compiler. All panics are funneled through this\n //! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![allow(dead_code, missing_docs)]\n #![unstable(\n     feature = \"core_panic\",\n@@ -41,6 +39,7 @@ use crate::panic::{Location, PanicInfo};\n #[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\n pub fn panic(expr: &str) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // SAFETY: the `abort` intrinsic has no requirements to be called.\n         unsafe { super::intrinsics::abort() }\n     }\n \n@@ -63,6 +62,7 @@ pub fn panic(expr: &str) -> ! {\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // SAFETY: the `abort` intrinsic has no requirements to be called.\n         unsafe { super::intrinsics::abort() }\n     }\n \n@@ -77,6 +77,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n #[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\n fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // SAFETY: the `abort` intrinsic has no requirements to be called.\n         unsafe { super::intrinsics::abort() }\n     }\n \n@@ -93,6 +94,7 @@ fn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n #[cfg_attr(not(bootstrap), track_caller)]\n pub fn panic_fmt(fmt: fmt::Arguments<'_>, #[cfg(bootstrap)] location: &Location<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n+        // SAFETY: the `abort` intrinsic has no requirements to be called.\n         unsafe { super::intrinsics::abort() }\n     }\n \n@@ -108,5 +110,6 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, #[cfg(bootstrap)] location: &Location<\n     #[cfg(not(bootstrap))]\n     let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller());\n \n+    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n     unsafe { panic_impl(&pi) }\n }"}]}