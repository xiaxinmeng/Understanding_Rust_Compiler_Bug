{"sha": "5bde40cb63b71a1dd805b37bb72300389af120a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZGU0MGNiNjNiNzFhMWRkODA1YjM3YmI3MjMwMDM4OWFmMTIwYTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-03T09:49:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-03T09:49:12Z"}, "message": "Merge pull request #557 from RalfJung/fix-mutability-gap\n\nfix mutability gap: do not allow shared mutation when creating frozen reference", "tree": {"sha": "462e4954874758b1c17bcc0870e6b0c868e6d1c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/462e4954874758b1c17bcc0870e6b0c868e6d1c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bde40cb63b71a1dd805b37bb72300389af120a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcBPwYCRBK7hj4Ov3rIwAAdHIIAAIG5L6JzmFH9jY+XR5FOEUR\nXpOa54u2QQtdDA6unwavvgZi5Wz8odAMqA1Xb6i97H7ZOvbBueTbR3wJRqyBQTFj\nyPtZzLZpgpqFsKb1Ok45xl6Z7YKNcDDR+WD1Uc6SS1DDyFAI16ldrFDl6f3aEdHZ\n704wIhYG8+XIqgaBS/2riuWjVTiROAo3JG7JMTf/KFArtqtIlx8wRwbypF5rWFMl\ndMLjr316aVpBlj+CLD6434nHES89rM63/MBx5aJ5RCutvciV527eebAFoEX2VBuL\njjOX4qHIi0Kc+BF45RzgIJU2RxD2YSKdnBGHNRTcuFGi2JwFPuMiEIK9dZA5v/Y=\n=psAr\n-----END PGP SIGNATURE-----\n", "payload": "tree 462e4954874758b1c17bcc0870e6b0c868e6d1c6\nparent 21fd5fd16895ccd28644134fb19e5771dcc96522\nparent d11a6766ad388c97e3a95b26a9350ff4ddefd004\nauthor Ralf Jung <post@ralfj.de> 1543830552 +0100\ncommitter GitHub <noreply@github.com> 1543830552 +0100\n\nMerge pull request #557 from RalfJung/fix-mutability-gap\n\nfix mutability gap: do not allow shared mutation when creating frozen reference"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bde40cb63b71a1dd805b37bb72300389af120a4", "html_url": "https://github.com/rust-lang/rust/commit/5bde40cb63b71a1dd805b37bb72300389af120a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bde40cb63b71a1dd805b37bb72300389af120a4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21fd5fd16895ccd28644134fb19e5771dcc96522", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fd5fd16895ccd28644134fb19e5771dcc96522", "html_url": "https://github.com/rust-lang/rust/commit/21fd5fd16895ccd28644134fb19e5771dcc96522"}, {"sha": "d11a6766ad388c97e3a95b26a9350ff4ddefd004", "url": "https://api.github.com/repos/rust-lang/rust/commits/d11a6766ad388c97e3a95b26a9350ff4ddefd004", "html_url": "https://github.com/rust-lang/rust/commit/d11a6766ad388c97e3a95b26a9350ff4ddefd004"}], "stats": {"total": 116, "additions": 84, "deletions": 32}, "files": [{"sha": "087b7c6642729415f3aff02ef6b3116433acb028", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -1 +1 @@\n-nightly-2018-11-30\n+nightly-2018-12-03"}, {"sha": "41b5cc2a239d12b80489fa4e792c0dc522a0b23d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -303,14 +303,28 @@ impl<'tcx> Stack {\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n     /// `kind` indicates which kind of reference is being created.\n     fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        if self.frozen_since.is_some() {\n-            // A frozen location?  Possible if we create a barrier, then push again.\n-            assert!(bor.is_shared(), \"We should never try creating a unique borrow for a frozen stack\");\n-            trace!(\"create: Not doing anything on frozen location\");\n+        // When creating a frozen reference, freeze.  This ensures F1.\n+        // We also do *not* push anything else to the stack, making sure that no nother kind\n+        // of access (like writing through raw pointers) is permitted.\n+        if kind == RefKind::Frozen {\n+            let bor_t = match bor {\n+                Borrow::Shr(Some(t)) => t,\n+                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n+            };\n+            // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n+            // the redundancy check would not have kicked in).\n+            match self.frozen_since {\n+                Some(loc_t) => assert!(loc_t <= bor_t, \"Trying to freeze location for longer than it was already frozen\"),\n+                None => {\n+                    trace!(\"create: Freezing\");\n+                    self.frozen_since = Some(bor_t);\n+                }\n+            }\n             return;\n         }\n-        // First, push.  We do this even if we will later freeze, because we\n-        // will allow mutation of shared data at the expense of unfreezing.\n+        assert!(self.frozen_since.is_none(), \"Trying to create non-frozen reference to frozen location\");\n+\n+        // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n             Borrow::Shr(_) => BorStackItem::Shr,\n@@ -325,15 +339,6 @@ impl<'tcx> Stack {\n             trace!(\"create: Pushing {:?}\", itm);\n             self.borrows.push(itm);\n         }\n-        // Then, maybe freeze.  This is part 2 of ensuring F1.\n-        if kind == RefKind::Frozen {\n-            let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n-                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n-            };\n-            trace!(\"create: Freezing\");\n-            self.frozen_since = Some(bor_t);\n-        }\n     }\n \n     /// Add a barrier"}, {"sha": "a653aa5003f6d4da712027e3f1abe154941ccffe", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR is not frozen\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n }"}, {"sha": "22a80e27103e1ec126c86de0664ca8c89fde6f07", "filename": "tests/compile-fail-fullmir/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -3,7 +3,7 @@ fn foo(_: &i32) {}\n \n fn main() {\n     let x = &mut 42;\n-    let xraw = &*x as *const _ as *mut _;\n+    let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     unsafe { *xraw = 42 }; // unfreeze\n     foo(xref); //~ ERROR is not frozen"}, {"sha": "560c9dfb665dd518d2474531f54d1a1d80f1a25e", "filename": "tests/compile-fail-fullmir/stacked_borrows/shr_frozen_violation1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -0,0 +1,16 @@\n+fn foo(x: &mut i32) -> i32 {\n+  *x = 5;\n+  unknown_code(&*x);\n+  *x // must return 5\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo(&mut 0));\n+}\n+\n+// If we replace the `*const` by `&`, my current dev version of miri\n+// *does* find the problem, but not for a good reason: It finds it because\n+// of barriers, and we shouldn't rely on unknown code using barriers.\n+fn unknown_code(x: *const i32) {\n+    unsafe { *(x as *mut i32) = 7; } //~ ERROR barrier\n+}"}, {"sha": "d92cff0b084e6b726f55ebedd4767163353a418a", "filename": "tests/run-pass-fullmir/vecdeque.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecdeque.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Validation disabled until https://github.com/rust-lang/rust/pull/56161 lands\n+// compile-flags: -Zmiri-disable-validation\n+\n use std::collections::VecDeque;\n \n fn main() {"}, {"sha": "0bc8b15c5f24ebbf2aed0659ce99378d500578f6", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -39,6 +39,13 @@ fn aliasing_mut_and_shr() {\n         *aliasing += 4;\n         let _shr = &*rc;\n         *aliasing += 4;\n+        // also turning this into a frozen ref now must work\n+        let aliasing = &*aliasing;\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n     }\n \n     let rc = RefCell::new(23);\n@@ -48,7 +55,23 @@ fn aliasing_mut_and_shr() {\n     assert_eq!(*rc.borrow(), 23+12);\n }\n \n+fn aliasing_frz_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &i32) {\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let bshr = rc.borrow();\n+    inner(&rc, &*bshr);\n+    assert_eq!(*rc.borrow(), 23);\n+}\n+\n fn main() {\n     lots_of_funny_borrows();\n     aliasing_mut_and_shr();\n+    aliasing_frz_and_shr();\n }"}, {"sha": "388765c29eabd6ff1f646df758852e1fe85e8e9f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bde40cb63b71a1dd805b37bb72300389af120a4/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=5bde40cb63b71a1dd805b37bb72300389af120a4", "patch": "@@ -4,10 +4,11 @@ fn main() {\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n     ref_raw_int_raw();\n-    mut_shr_raw();\n     mut_raw_then_mut_shr();\n+    mut_shr_then_mut_raw();\n     mut_raw_mut();\n     partially_invalidate_mut();\n+    drop_after_sharing();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -53,18 +54,6 @@ fn ref_raw_int_raw() {\n     assert_eq!(unsafe { *xraw }, 3);\n }\n \n-// Creating a raw from a `&mut` through an `&` works, even if we\n-// write through that raw.\n-fn mut_shr_raw() {\n-    let mut x = 2;\n-    {\n-        let xref = &mut x;\n-        let xraw = &*xref as *const i32 as *mut i32;\n-        unsafe { *xraw = 4; }\n-    }\n-    assert_eq!(x, 4);\n-}\n-\n // Escape a mut to raw, then share the same mut and use the share, then the raw.\n // That should work.\n fn mut_raw_then_mut_shr() {\n@@ -77,6 +66,16 @@ fn mut_raw_then_mut_shr() {\n     assert_eq!(x, 4);\n }\n \n+// Create first a shared reference and then a raw pointer from a `&mut`\n+// should permit mutation through that raw pointer.\n+fn mut_shr_then_mut_raw() {\n+    let xref = &mut 2;\n+    let _xshr = &*xref;\n+    let xraw = xref as *mut _;\n+    unsafe { *xraw = 3; }\n+    assert_eq!(*xref, 3);\n+}\n+\n // Ensure that if we derive from a mut a raw, and then from that a mut,\n // and then read through the original mut, that does not invalidate the raw.\n // This shows that the read-exception for `&mut` applies even if the `Shr` item\n@@ -107,3 +106,9 @@ fn partially_invalidate_mut() {\n     *shard += 1; // so we can still use `shard`.\n     assert_eq!(*data, (1, 1));\n }\n+\n+// Make sure that we can handle the situation where a loaction is frozen when being dropped.\n+fn drop_after_sharing() {\n+    let x = String::from(\"hello!\");\n+    let _len = x.len();\n+}"}]}