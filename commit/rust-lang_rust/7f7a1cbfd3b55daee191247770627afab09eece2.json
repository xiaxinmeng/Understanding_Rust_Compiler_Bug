{"sha": "7f7a1cbfd3b55daee191247770627afab09eece2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmN2ExY2JmZDNiNTVkYWVlMTkxMjQ3NzcwNjI3YWZhYjA5ZWVjZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T19:38:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T19:38:01Z"}, "message": "Auto merge of #77229 - tmiasko:liveness, r=lcnr\n\nSmall improvements in liveness pass\n\n* Remove redundant debug logging (`add_variable` already contains logging).\n* Remove redundant fields for a number of live nodes and variables.\n* Delay conversion from a symbol to a string until linting.\n* Inline contents of specials struct.\n* Remove unnecessary local variable exit_ln.\n* Use newtype_index for Variable and LiveNode.\n* Access live nodes directly through self.lnks[ln].\n\nNo functional changes intended (except those related to the logging).", "tree": {"sha": "dcab47cde5c638785c7aa66d8685155661a55b00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcab47cde5c638785c7aa66d8685155661a55b00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f7a1cbfd3b55daee191247770627afab09eece2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7a1cbfd3b55daee191247770627afab09eece2", "html_url": "https://github.com/rust-lang/rust/commit/7f7a1cbfd3b55daee191247770627afab09eece2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f7a1cbfd3b55daee191247770627afab09eece2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4529af972e55f8f85afaada0ee2dd18ab8653637", "url": "https://api.github.com/repos/rust-lang/rust/commits/4529af972e55f8f85afaada0ee2dd18ab8653637", "html_url": "https://github.com/rust-lang/rust/commit/4529af972e55f8f85afaada0ee2dd18ab8653637"}, {"sha": "d68aa227c6b7ab9c1cfa003e752c3600a7269485", "url": "https://api.github.com/repos/rust-lang/rust/commits/d68aa227c6b7ab9c1cfa003e752c3600a7269485", "html_url": "https://github.com/rust-lang/rust/commit/d68aa227c6b7ab9c1cfa003e752c3600a7269485"}], "stats": {"total": 212, "additions": 91, "deletions": 121}, "files": [{"sha": "b7e4b478853c506c9e28e263ec7bf5a63f8168bc", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f7a1cbfd3b55daee191247770627afab09eece2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f7a1cbfd3b55daee191247770627afab09eece2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7f7a1cbfd3b55daee191247770627afab09eece2", "patch": "@@ -3891,6 +3891,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "df6667a29d50b232fa5f5facc204138b4dbfee6c", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=7f7a1cbfd3b55daee191247770627afab09eece2", "patch": "@@ -15,5 +15,6 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "c32c9c8eaa68c09dd6081c65a3089ea3c49aa7a6", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=7f7a1cbfd3b55daee191247770627afab09eece2", "patch": "@@ -5,6 +5,8 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(const_fn)]\n+#![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]"}, {"sha": "9eac2f79e412c1781ae14528bca8982fff34b0db", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 87, "deletions": 121, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7a1cbfd3b55daee191247770627afab09eece2/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=7f7a1cbfd3b55daee191247770627afab09eece2", "patch": "@@ -62,13 +62,13 @@\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`. If the `reader` is `invalid_node()`, then the current\n+//!    write `V`. If the `reader` is `INVALID_NODE`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n //!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`. If the `writer` is `invalid_node()`, then there is no writer\n+//!    `V`. If the `writer` is `INVALID_NODE`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n //! - `used`: a boolean value indicating whether `V` is *used*. We\n@@ -79,7 +79,7 @@\n //! ## Special nodes and variables\n //!\n //! We generate various special nodes for various, well, special purposes.\n-//! These are described in the `Specials` struct.\n+//! These are described in the `Liveness` struct.\n \n use self::LiveNodeKind::*;\n use self::VarKind::*;\n@@ -92,34 +92,29 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet, Node};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::collections::VecDeque;\n-use std::fmt;\n use std::io;\n use std::io::prelude::*;\n use std::rc::Rc;\n \n-#[derive(Copy, Clone, PartialEq)]\n-struct Variable(u32);\n-\n-#[derive(Copy, Clone, PartialEq)]\n-struct LiveNode(u32);\n-\n-impl Variable {\n-    fn get(&self) -> usize {\n-        self.0 as usize\n+rustc_index::newtype_index! {\n+    pub struct Variable {\n+        DEBUG_FORMAT = \"v({})\",\n     }\n }\n \n-impl LiveNode {\n-    fn get(&self) -> usize {\n-        self.0 as usize\n+rustc_index::newtype_index! {\n+    pub struct LiveNode {\n+        DEBUG_FORMAT = \"ln({})\",\n+        const INVALID_NODE = LiveNode::MAX_AS_U32,\n     }\n }\n \n@@ -183,18 +178,6 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_liveness, ..*providers };\n }\n \n-impl fmt::Debug for LiveNode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ln({})\", self.get())\n-    }\n-}\n-\n-impl fmt::Debug for Variable {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"v({})\", self.get())\n-    }\n-}\n-\n // ______________________________________________________________________\n // Creating ir_maps\n //\n@@ -218,15 +201,11 @@ impl fmt::Debug for Variable {\n // assignment.  And so forth.\n \n impl LiveNode {\n-    fn is_valid(&self) -> bool {\n-        self.0 != u32::MAX\n+    fn is_valid(self) -> bool {\n+        self != INVALID_NODE\n     }\n }\n \n-fn invalid_node() -> LiveNode {\n-    LiveNode(u32::MAX)\n-}\n-\n struct CaptureInfo {\n     ln: LiveNode,\n     var_hid: HirId,\n@@ -249,34 +228,28 @@ enum VarKind {\n struct IrMaps<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body_owner: LocalDefId,\n-    num_live_nodes: usize,\n-    num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n     capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n-    var_kinds: Vec<VarKind>,\n-    lnks: Vec<LiveNodeKind>,\n+    var_kinds: IndexVec<Variable, VarKind>,\n+    lnks: IndexVec<LiveNode, LiveNodeKind>,\n }\n \n impl IrMaps<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, body_owner: LocalDefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,\n-            num_live_nodes: 0,\n-            num_vars: 0,\n             live_node_map: HirIdMap::default(),\n             variable_map: HirIdMap::default(),\n             capture_info_map: Default::default(),\n-            var_kinds: Vec::new(),\n-            lnks: Vec::new(),\n+            var_kinds: IndexVec::new(),\n+            lnks: IndexVec::new(),\n         }\n     }\n \n     fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n-        let ln = LiveNode(self.num_live_nodes as u32);\n-        self.lnks.push(lnk);\n-        self.num_live_nodes += 1;\n+        let ln = self.lnks.push(lnk);\n \n         debug!(\"{:?} is of kind {}\", ln, live_node_kind_to_string(lnk, self.tcx));\n \n@@ -291,9 +264,7 @@ impl IrMaps<'tcx> {\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n-        let v = Variable(self.num_vars as u32);\n-        self.var_kinds.push(vk);\n-        self.num_vars += 1;\n+        let v = self.var_kinds.push(vk);\n \n         match vk {\n             Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) | Upvar(node_id, _) => {\n@@ -315,14 +286,14 @@ impl IrMaps<'tcx> {\n         }\n     }\n \n-    fn variable_name(&self, var: Variable) -> String {\n-        match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Param(_, name) | Upvar(_, name) => name.to_string(),\n+    fn variable_name(&self, var: Variable) -> Symbol {\n+        match self.var_kinds[var] {\n+            Local(LocalInfo { name, .. }) | Param(_, name) | Upvar(_, name) => name,\n         }\n     }\n \n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n-        match self.var_kinds[var.get()] {\n+        match self.var_kinds[var] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n             Param(..) | Upvar(..) => false,\n         }\n@@ -331,10 +302,6 @@ impl IrMaps<'tcx> {\n     fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n         self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n-\n-    fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        self.lnks[ln.get()]\n-    }\n }\n \n fn visit_fn<'tcx>(\n@@ -367,7 +334,6 @@ fn visit_fn<'tcx>(\n \n     if let Some(upvars) = ir.tcx.upvars_mentioned(def_id) {\n         for (&var_hir_id, _upvar) in upvars {\n-            debug!(\"adding upvar {:?}\", var_hir_id);\n             let var_name = ir.tcx.hir().name(var_hir_id);\n             fn_maps.add_variable(Upvar(var_hir_id, var_name));\n         }\n@@ -379,7 +345,6 @@ fn visit_fn<'tcx>(\n             _ => false,\n         };\n         param.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            debug!(\"adding parameters {:?}\", hir_id);\n             let var = if is_shorthand {\n                 Local(LocalInfo { id: hir_id, name: ident.name, is_shorthand: true })\n             } else {\n@@ -564,10 +529,10 @@ struct RWUTable {\n     unpacked_rwus: Vec<RWU>,\n }\n \n-// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: false }`.\n+// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: false }`.\n const INV_INV_FALSE: u32 = u32::MAX;\n \n-// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: true }`.\n+// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: true }`.\n const INV_INV_TRUE: u32 = u32::MAX - 1;\n \n impl RWUTable {\n@@ -578,24 +543,24 @@ impl RWUTable {\n     fn get(&self, idx: usize) -> RWU {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: invalid_node(), writer: invalid_node(), used: false },\n-            INV_INV_TRUE => RWU { reader: invalid_node(), writer: invalid_node(), used: true },\n+            INV_INV_FALSE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: false },\n+            INV_INV_TRUE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: true },\n             _ => self.unpacked_rwus[packed_rwu as usize],\n         }\n     }\n \n     fn get_reader(&self, idx: usize) -> LiveNode {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n             _ => self.unpacked_rwus[packed_rwu as usize].reader,\n         }\n     }\n \n     fn get_writer(&self, idx: usize) -> LiveNode {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n             _ => self.unpacked_rwus[packed_rwu as usize].writer,\n         }\n     }\n@@ -615,7 +580,7 @@ impl RWUTable {\n     }\n \n     fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == invalid_node() && rwu.writer == invalid_node() {\n+        if rwu.reader == INVALID_NODE && rwu.writer == INVALID_NODE {\n             // When we overwrite an indexing entry in `self.packed_rwus` with\n             // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n             // from `self.unpacked_rwus`; it's not worth the effort, and we\n@@ -634,17 +599,6 @@ impl RWUTable {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-struct Specials {\n-    /// A live node representing a point of execution before closure entry &\n-    /// after closure exit. Used to calculate liveness of captured variables\n-    /// through calls to the same closure. Used for Fn & FnMut closures only.\n-    closure_ln: LiveNode,\n-    /// A live node representing every 'exit' from the function, whether it be\n-    /// by explicit return, panic, or other means.\n-    exit_ln: LiveNode,\n-}\n-\n const ACC_READ: u32 = 1;\n const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n@@ -653,10 +607,17 @@ struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    s: Specials,\n-    successors: Vec<LiveNode>,\n+    successors: IndexVec<LiveNode, LiveNode>,\n     rwu_table: RWUTable,\n \n+    /// A live node representing a point of execution before closure entry &\n+    /// after closure exit. Used to calculate liveness of captured variables\n+    /// through calls to the same closure. Used for Fn & FnMut closures only.\n+    closure_ln: LiveNode,\n+    /// A live node representing every 'exit' from the function, whether it be\n+    /// by explicit return, panic, or other means.\n+    exit_ln: LiveNode,\n+\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -666,24 +627,23 @@ struct Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        let specials = Specials {\n-            closure_ln: ir.add_live_node(ClosureNode),\n-            exit_ln: ir.add_live_node(ExitNode),\n-        };\n-\n         let typeck_results = ir.tcx.typeck(def_id);\n         let param_env = ir.tcx.param_env(def_id);\n \n-        let num_live_nodes = ir.num_live_nodes;\n-        let num_vars = ir.num_vars;\n+        let closure_ln = ir.add_live_node(ClosureNode);\n+        let exit_ln = ir.add_live_node(ExitNode);\n+\n+        let num_live_nodes = ir.lnks.len();\n+        let num_vars = ir.var_kinds.len();\n \n         Liveness {\n             ir,\n             typeck_results,\n             param_env,\n-            s: specials,\n-            successors: vec![invalid_node(); num_live_nodes],\n+            successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n+            closure_ln,\n+            exit_ln,\n             break_ln: Default::default(),\n             cont_ln: Default::default(),\n         }\n@@ -721,18 +681,18 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn idx(&self, ln: LiveNode, var: Variable) -> usize {\n-        ln.get() * self.ir.num_vars + var.get()\n+        ln.index() * self.ir.var_kinds.len() + var.index()\n     }\n \n     fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let reader = self.rwu_table.get_reader(self.idx(ln, var));\n-        if reader.is_valid() { Some(self.ir.lnk(reader)) } else { None }\n+        if reader.is_valid() { Some(self.ir.lnks[reader]) } else { None }\n     }\n \n     // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln.get()];\n+        let successor = self.successors[ln];\n         self.live_on_entry(successor, var)\n     }\n \n@@ -744,21 +704,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let writer = self.rwu_table.get_writer(self.idx(ln, var));\n-        if writer.is_valid() { Some(self.ir.lnk(writer)) } else { None }\n+        if writer.is_valid() { Some(self.ir.lnks[writer]) } else { None }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln.get()];\n+        let successor = self.successors[ln];\n         self.assigned_on_entry(successor, var)\n     }\n \n     fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F)\n     where\n         F: FnMut(&mut Liveness<'a, 'tcx>, usize, usize),\n     {\n-        let node_base_idx = self.idx(ln, Variable(0));\n-        let succ_base_idx = self.idx(succ_ln, Variable(0));\n-        for var_idx in 0..self.ir.num_vars {\n+        let node_base_idx = self.idx(ln, Variable::from(0u32));\n+        let succ_base_idx = self.idx(succ_ln, Variable::from(0u32));\n+        for var_idx in 0..self.ir.var_kinds.len() {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -767,11 +727,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     where\n         F: FnMut(usize) -> bool,\n     {\n-        let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in 0..self.ir.num_vars {\n+        let node_base_idx = self.idx(ln, Variable::from(0u32));\n+        for var_idx in 0..self.ir.var_kinds.len() {\n             let idx = node_base_idx + var_idx;\n             if test(idx) {\n-                write!(wr, \" {:?}\", Variable(var_idx as u32))?;\n+                write!(wr, \" {:?}\", Variable::from(var_idx))?;\n             }\n         }\n         Ok(())\n@@ -782,14 +742,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = Vec::new();\n         {\n             let wr = &mut wr as &mut dyn Write;\n-            write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnks[ln]);\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n             write!(wr, \"  uses\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n \n-            write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n+            write!(wr, \"  precedes {:?}]\", self.successors[ln]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n@@ -799,8 +759,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         debug!(\n             \"^^ liveness computation results for body {} (entry={:?})\",\n             {\n-                for ln_idx in 0..self.ir.num_live_nodes {\n-                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                for ln_idx in 0..self.ir.lnks.len() {\n+                    debug!(\"{:?}\", self.ln_str(LiveNode::from(ln_idx)));\n                 }\n                 hir_id\n             },\n@@ -809,7 +769,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[ln.get()] = succ_ln;\n+        self.successors[ln] = succ_ln;\n \n         // It is not necessary to initialize the RWUs here because they are all\n         // set to INV_INV_FALSE when they are created, and the sets only grow\n@@ -818,7 +778,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[ln.get()] = succ_ln;\n+        self.successors[ln] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             this.rwu_table.copy_packed(idx, succ_idx);\n@@ -891,7 +851,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = invalid_node();\n+            rwu.reader = INVALID_NODE;\n             rwu.writer = ln;\n         }\n \n@@ -943,14 +903,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 match self.typeck_results.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n                         let var = self.variable(var_hir_id, upvar.span);\n-                        self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n+                        self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n                     }\n                     ty::UpvarCapture::ByValue(_) => {}\n                 }\n             }\n         }\n \n-        let succ = self.propagate_through_expr(&body.value, self.s.exit_ln);\n+        let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n         match fk {\n             FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n@@ -973,19 +933,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // Propagate through calls to the closure.\n         let mut first_merge = true;\n         loop {\n-            self.init_from_succ(self.s.closure_ln, succ);\n+            self.init_from_succ(self.closure_ln, succ);\n             for param in body.params {\n                 param.pat.each_binding(|_bm, hir_id, _x, ident| {\n                     let var = self.variable(hir_id, ident.span);\n-                    self.define(self.s.closure_ln, var);\n+                    self.define(self.closure_ln, var);\n                 })\n             }\n \n-            if !self.merge_from_succ(self.s.exit_ln, self.s.closure_ln, first_merge) {\n+            if !self.merge_from_succ(self.exit_ln, self.closure_ln, first_merge) {\n                 break;\n             }\n             first_merge = false;\n-            assert_eq!(succ, self.propagate_through_expr(&body.value, self.s.exit_ln));\n+            assert_eq!(succ, self.propagate_through_expr(&body.value, self.exit_ln));\n         }\n \n         succ\n@@ -1106,9 +1066,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Ret(ref o_e) => {\n-                // ignore succ and subst exit_ln:\n-                let exit_ln = self.s.exit_ln;\n-                self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n+                // Ignore succ and subst exit_ln.\n+                self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), self.exit_ln)\n             }\n \n             hir::ExprKind::Break(label, ref opt_expr) => {\n@@ -1182,7 +1141,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1197,7 +1156,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.typeck_results.expr_ty(expr),\n                     self.param_env,\n                 ) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1234,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::InlineAsm(ref asm) => {\n                 // Handle non-returning asm\n                 let mut succ = if asm.options.contains(InlineAsmOptions::NORETURN) {\n-                    self.s.exit_ln\n+                    self.exit_ln\n                 } else {\n                     succ\n                 };\n@@ -1595,7 +1554,14 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.is_empty() || name.as_bytes()[0] == b'_' { None } else { Some(name) }\n+        if name == kw::Invalid {\n+            return None;\n+        }\n+        let name: &str = &name.as_str();\n+        if name.as_bytes()[0] == b'_' {\n+            return None;\n+        }\n+        Some(name.to_owned())\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n@@ -1667,7 +1633,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         // bindings, and we also consider the first pattern to be the \"authoritative\" set of ids.\n         // However, we should take the ids and spans of variables with the same name from the later\n         // patterns so the suggestions to prefix with underscores will apply to those too.\n-        let mut vars: FxIndexMap<String, (LiveNode, Variable, Vec<(HirId, Span)>)> = <_>::default();\n+        let mut vars: FxIndexMap<Symbol, (LiveNode, Variable, Vec<(HirId, Span)>)> = <_>::default();\n \n         pat.each_binding(|_, hir_id, pat_sp, ident| {\n             let ln = entry_ln.unwrap_or_else(|| self.live_node(hir_id, pat_sp));\n@@ -1697,7 +1663,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n             // {ret}`, there is only one node, so asking about\n             // assigned_on_exit() is not meaningful.\n             let is_assigned =\n-                if ln == self.s.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n+                if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n \n             if is_assigned {\n                 self.ir.tcx.struct_span_lint_hir("}]}