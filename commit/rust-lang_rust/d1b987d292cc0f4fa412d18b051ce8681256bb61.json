{"sha": "d1b987d292cc0f4fa412d18b051ce8681256bb61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYjk4N2QyOTJjYzBmNGZhNDEyZDE4YjA1MWNlODY4MTI1NmJiNjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-06T23:12:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:31Z"}, "message": "hack the tydesc that is registered with a malloc to be what cc expects", "tree": {"sha": "9c95c234f4a7af7e0eeea39821547b64ae5f91ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c95c234f4a7af7e0eeea39821547b64ae5f91ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1b987d292cc0f4fa412d18b051ce8681256bb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1b987d292cc0f4fa412d18b051ce8681256bb61", "html_url": "https://github.com/rust-lang/rust/commit/d1b987d292cc0f4fa412d18b051ce8681256bb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1b987d292cc0f4fa412d18b051ce8681256bb61/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8506241f3a0dce3f0d24764a3ce3d16f99bcb809", "url": "https://api.github.com/repos/rust-lang/rust/commits/8506241f3a0dce3f0d24764a3ce3d16f99bcb809", "html_url": "https://github.com/rust-lang/rust/commit/8506241f3a0dce3f0d24764a3ce3d16f99bcb809"}], "stats": {"total": 69, "additions": 47, "deletions": 22}, "files": [{"sha": "d3a56f20b7d9d3be338d6d3b69a7bc267af2450f", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d1b987d292cc0f4fa412d18b051ce8681256bb61/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1b987d292cc0f4fa412d18b051ce8681256bb61/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=d1b987d292cc0f4fa412d18b051ce8681256bb61", "patch": "@@ -12,6 +12,7 @@ import syntax::codemap::span;\n import back::link::{\n     mangle_internal_name_by_path,\n     mangle_internal_name_by_path_and_seq};\n+import util::ppaux::ty_to_str;\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n@@ -131,7 +132,8 @@ fn mk_tydesc_ty(tcx: ty::ctxt, ck: ty::closure_kind) -> ty::t {\n fn mk_closure_tys(tcx: ty::ctxt,\n                   ck: ty::closure_kind,\n                   ty_params: [fn_ty_param],\n-                  bound_values: [environment_value]) -> (ty::t, [ty::t]) {\n+                  bound_values: [environment_value])\n+    -> (ty::t, ty::t, [ty::t]) {\n     let bound_tys = [];\n \n     let tydesc_ty =\n@@ -157,23 +159,45 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n \n+    let norc_tys = [tydesc_ty, ty::mk_tup(tcx, param_ptrs), bound_data_ty];\n+\n+    // closure_norc_ty == everything but ref count\n+    //\n+    // This is a hack to integrate with the cycle coll.  When you\n+    // allocate memory in the task-local space, you are expected to\n+    // provide a descriptor for that memory which excludes the ref\n+    // count. That's what this represents.  However, this really\n+    // assumes a type setup like [uint, data] where data can be a\n+    // struct.  We don't use that structure here because we don't want\n+    // to alignment of the first few fields being bound up in the\n+    // alignment of the bound data, as would happen if we laid out\n+    // that way.  For now this should be fine but ultimately we need\n+    // to modify CC code or else modify box allocation interface to be\n+    // a bit more flexible, perhaps taking a vec of tys in the box\n+    // (which for normal rust code is always of length 1).\n+    let closure_norc_ty = ty::mk_tup(tcx, norc_tys);\n+\n+    #debug[\"closure_norc_ty=%s\", ty_to_str(tcx, closure_norc_ty)];\n+\n     // closure_ty == ref count, data tydesc, typarams, bound data\n-    let closure_ty =\n-        ty::mk_tup(tcx, [ty::mk_int(tcx), tydesc_ty,\n-                         ty::mk_tup(tcx, param_ptrs), bound_data_ty]);\n+    let closure_ty = ty::mk_tup(tcx, [ty::mk_int(tcx)] + norc_tys);\n+\n+    #debug[\"closure_ty=%s\", ty_to_str(tcx, closure_norc_ty)];\n \n-    ret (closure_ty, bound_tys);\n+    ret (closure_ty, closure_norc_ty, bound_tys);\n }\n \n fn allocate_cbox(bcx: @block_ctxt,\n                  ck: ty::closure_kind,\n-                 cbox_ty: ty::t)\n+                 cbox_ty: ty::t,\n+                 cbox_norc_ty: ty::t)\n     -> (@block_ctxt, ValueRef, [ValueRef]) {\n \n-    fn alloc_in_heap(bcx: @block_ctxt,\n-                     cbox_ty: ty::t,\n-                     shared: bool,\n-                     &temp_cleanups: [ValueRef])\n+    let ccx = bcx_ccx(bcx);\n+\n+    let alloc_in_heap = lambda(bcx: @block_ctxt,\n+                               xchgheap: bool,\n+                               &temp_cleanups: [ValueRef])\n         -> (@block_ctxt, ValueRef) {\n \n         // n.b. If you are wondering why we don't use\n@@ -183,28 +207,28 @@ fn allocate_cbox(bcx: @block_ctxt,\n \n         let {bcx, val:llsz} = size_of(bcx, cbox_ty);\n         let ti = none;\n+        let tydesc_ty = if xchgheap { cbox_ty } else { cbox_norc_ty };\n         let {bcx, val:lltydesc} =\n-            get_tydesc(bcx, cbox_ty, true, tps_normal, ti).result;\n-        let malloc =\n-            if shared { bcx_ccx(bcx).upcalls.shared_malloc }\n-            else { bcx_ccx(bcx).upcalls.malloc };\n+            get_tydesc(bcx, tydesc_ty, true, tps_normal, ti).result;\n+        let malloc = {\n+            if xchgheap { ccx.upcalls.shared_malloc}\n+            else { ccx.upcalls.malloc }\n+        };\n         let box = Call(bcx, malloc, [llsz, lltydesc]);\n-        add_clean_free(bcx, box, shared);\n+        add_clean_free(bcx, box, xchgheap);\n         temp_cleanups += [box];\n         (bcx, box)\n-    }\n-\n-    let ccx = bcx_ccx(bcx);\n+    };\n \n     // Allocate the box:\n     let temp_cleanups = [];\n     let (bcx, box, rc) = alt ck {\n       ty::closure_shared. {\n-        let (bcx, box) = alloc_in_heap(bcx, cbox_ty, false, temp_cleanups);\n+        let (bcx, box) = alloc_in_heap(bcx, false, temp_cleanups);\n         (bcx, box, 1)\n       }\n       ty::closure_send. {\n-        let (bcx, box) = alloc_in_heap(bcx, cbox_ty, true, temp_cleanups);\n+        let (bcx, box) = alloc_in_heap(bcx, true, temp_cleanups);\n         (bcx, box, 0xdeadc0de) // use arbitrary value for debugging\n       }\n       ty::closure_block. {\n@@ -264,11 +288,12 @@ fn store_environment(\n     let tcx = bcx_tcx(bcx);\n \n     // compute the shape of the closure\n-    let (cbox_ty, bound_tys) =\n+    let (cbox_ty, cbox_norc_ty, bound_tys) =\n         mk_closure_tys(tcx, ck, lltyparams, bound_values);\n \n     // allocate closure in the heap\n-    let (bcx, llbox, temp_cleanups) = allocate_cbox(bcx, ck, cbox_ty);\n+    let (bcx, llbox, temp_cleanups) =\n+        allocate_cbox(bcx, ck, cbox_ty, cbox_norc_ty);\n \n     // store data tydesc.\n     alt ck {"}]}