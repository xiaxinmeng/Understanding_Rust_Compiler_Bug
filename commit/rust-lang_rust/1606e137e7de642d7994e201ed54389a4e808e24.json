{"sha": "1606e137e7de642d7994e201ed54389a4e808e24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MDZlMTM3ZTdkZTY0MmQ3OTk0ZTIwMWVkNTQzODlhNGU4MDhlMjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-20T21:43:16Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:47:35Z"}, "message": "Rename PrimVal to Scalar", "tree": {"sha": "9780c77cbe8f3abcae68863732970c80b3ad739f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9780c77cbe8f3abcae68863732970c80b3ad739f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1606e137e7de642d7994e201ed54389a4e808e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1606e137e7de642d7994e201ed54389a4e808e24", "html_url": "https://github.com/rust-lang/rust/commit/1606e137e7de642d7994e201ed54389a4e808e24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1606e137e7de642d7994e201ed54389a4e808e24/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc5d927c9bde95cea30bdb7ba97a60078136dce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc5d927c9bde95cea30bdb7ba97a60078136dce", "html_url": "https://github.com/rust-lang/rust/commit/9cc5d927c9bde95cea30bdb7ba97a60078136dce"}], "stats": {"total": 552, "additions": 279, "deletions": 273}, "files": [{"sha": "369f889bbb2df12291e921cf97103354362cb880", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -475,7 +475,7 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n \n impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n \n-impl_stable_hash_for!(enum mir::interpret::PrimVal {\n+impl_stable_hash_for!(enum mir::interpret::Scalar {\n     Bytes(b),\n     Ptr(p),\n     Undef"}, {"sha": "2c78e20aa88a70280eaec78485544621b94f64ad", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, ConstValue};\n+pub use self::value::{Scalar, ScalarKind, Value, Pointer, ConstValue};\n \n use std::fmt;\n use mir;"}, {"sha": "1e41c79e27befb6abde329ed9fd275414a56e86e", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -9,10 +9,10 @@ use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n /// matches Value's optimizations for easy conversions between these two types\n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs which use PrimVal::Undef\n-    ByVal(PrimVal),\n+    /// Used only for types with layout::abi::Scalar ABI and ZSTs which use Scalar::Undef\n+    ByVal(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n-    ByValPair(PrimVal, PrimVal),\n+    ByValPair(Scalar, Scalar),\n     /// Used only for the remaining cases. An allocation + offset into the allocation\n     ByRef(&'tcx Allocation, Size),\n }\n@@ -37,12 +37,12 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n \n     #[inline]\n-    pub fn from_primval(val: PrimVal) -> Self {\n+    pub fn from_primval(val: Scalar) -> Self {\n         ConstValue::ByVal(val)\n     }\n \n     #[inline]\n-    pub fn to_primval(&self) -> Option<PrimVal> {\n+    pub fn to_primval(&self) -> Option<Scalar> {\n         match *self {\n             ConstValue::ByRef(..) => None,\n             ConstValue::ByValPair(..) => None,\n@@ -53,15 +53,15 @@ impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn to_bits(&self) -> Option<u128> {\n         match self.to_primval() {\n-            Some(PrimVal::Bytes(val)) => Some(val),\n+            Some(Scalar::Bytes(val)) => Some(val),\n             _ => None,\n         }\n     }\n \n     #[inline]\n     pub fn to_ptr(&self) -> Option<MemoryPointer> {\n         match self.to_primval() {\n-            Some(PrimVal::Ptr(ptr)) => Some(ptr),\n+            Some(Scalar::Ptr(ptr)) => Some(ptr),\n             _ => None,\n         }\n     }\n@@ -79,8 +79,8 @@ impl<'tcx> ConstValue<'tcx> {\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Value {\n     ByRef(Pointer, Align),\n-    ByVal(PrimVal),\n-    ByValPair(PrimVal, PrimVal),\n+    ByVal(Scalar),\n+    ByValPair(Scalar, Scalar),\n }\n \n impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n@@ -92,125 +92,125 @@ impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n     }\n }\n \n-/// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n-/// This type clears up a few APIs where having a `PrimVal` argument for something that is\n+/// A wrapper type around `Scalar` that cannot be turned back into a `Scalar` accidentally.\n+/// This type clears up a few APIs where having a `Scalar` argument for something that is\n /// potentially an integer pointer or a pointer to an allocation was unclear.\n ///\n /// I (@oli-obk) believe it is less easy to mix up generic primvals and primvals that are just\n /// the representation of pointers. Also all the sites that convert between primvals and pointers\n /// are explicit now (and rare!)\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pointer {\n-    pub primval: PrimVal,\n+    pub primval: Scalar,\n }\n \n impl<'tcx> Pointer {\n     pub fn null() -> Self {\n-        PrimVal::Bytes(0).into()\n+        Scalar::Bytes(0).into()\n     }\n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         self.primval.to_ptr()\n     }\n-    pub fn into_inner_primval(self) -> PrimVal {\n+    pub fn into_inner_primval(self) -> Scalar {\n         self.primval\n     }\n \n     pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n-            PrimVal::Bytes(b) => {\n+            Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n                 Ok(Pointer::from(\n-                    PrimVal::Bytes(layout.signed_offset(b as u64, i)? as u128),\n+                    Scalar::Bytes(layout.signed_offset(b as u64, i)? as u128),\n                 ))\n             }\n-            PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Pointer::from),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n-            PrimVal::Bytes(b) => {\n+            Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n                 Ok(Pointer::from(\n-                    PrimVal::Bytes(layout.offset(b as u64, i.bytes())? as u128),\n+                    Scalar::Bytes(layout.offset(b as u64, i.bytes())? as u128),\n                 ))\n             }\n-            PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Pointer::from),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n-            PrimVal::Bytes(b) => {\n+            Scalar::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n-                Ok(Pointer::from(PrimVal::Bytes(\n+                Ok(Pointer::from(Scalar::Bytes(\n                     layout.wrapping_signed_offset(b as u64, i) as u128,\n                 )))\n             }\n-            PrimVal::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Ptr(ptr) => Ok(Pointer::from(ptr.wrapping_signed_offset(i, layout))),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn is_null(self) -> EvalResult<'tcx, bool> {\n         match self.primval {\n-            PrimVal::Bytes(b) => Ok(b == 0),\n-            PrimVal::Ptr(_) => Ok(false),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Bytes(b) => Ok(b == 0),\n+            Scalar::Ptr(_) => Ok(false),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn to_value_with_len(self, len: u64) -> Value {\n-        Value::ByValPair(self.primval, PrimVal::from_u128(len as u128))\n+        Value::ByValPair(self.primval, Scalar::from_u128(len as u128))\n     }\n \n     pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n-        Value::ByValPair(self.primval, PrimVal::Ptr(vtable))\n+        Value::ByValPair(self.primval, Scalar::Ptr(vtable))\n     }\n \n     pub fn to_value(self) -> Value {\n         Value::ByVal(self.primval)\n     }\n }\n \n-impl ::std::convert::From<PrimVal> for Pointer {\n-    fn from(primval: PrimVal) -> Self {\n+impl ::std::convert::From<Scalar> for Pointer {\n+    fn from(primval: Scalar) -> Self {\n         Pointer { primval }\n     }\n }\n \n impl ::std::convert::From<MemoryPointer> for Pointer {\n     fn from(ptr: MemoryPointer) -> Self {\n-        PrimVal::Ptr(ptr).into()\n+        Scalar::Ptr(ptr).into()\n     }\n }\n \n-/// A `PrimVal` represents an immediate, primitive value existing outside of a\n+/// A `Scalar` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n-/// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n+/// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value, a pointer into another `Allocation`, or be undefined.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum PrimVal {\n+pub enum Scalar {\n     /// The raw bytes of a simple value.\n     Bytes(u128),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n-    /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n+    /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `MemoryPointer` here.\n     Ptr(MemoryPointer),\n \n-    /// An undefined `PrimVal`, for representing values that aren't safe to examine, but are safe\n+    /// An undefined `Scalar`, for representing values that aren't safe to examine, but are safe\n     /// to copy around, just like undefined bytes in an `Allocation`.\n     Undef,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PrimValKind {\n+pub enum ScalarKind {\n     I8, I16, I32, I64, I128,\n     U8, U16, U32, U64, U128,\n     F32, F64,\n@@ -219,56 +219,56 @@ pub enum PrimValKind {\n     Char,\n }\n \n-impl<'tcx> PrimVal {\n+impl<'tcx> Scalar {\n     pub fn from_u128(n: u128) -> Self {\n-        PrimVal::Bytes(n)\n+        Scalar::Bytes(n)\n     }\n \n     pub fn from_i128(n: i128) -> Self {\n-        PrimVal::Bytes(n as u128)\n+        Scalar::Bytes(n as u128)\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        PrimVal::Bytes(b as u128)\n+        Scalar::Bytes(b as u128)\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        PrimVal::Bytes(c as u128)\n+        Scalar::Bytes(c as u128)\n     }\n \n     pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n         match self {\n-            PrimVal::Bytes(b) => Ok(b),\n-            PrimVal::Ptr(_) => err!(ReadPointerAsBytes),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Bytes(b) => Ok(b),\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         match self {\n-            PrimVal::Bytes(_) => err!(ReadBytesAsPointer),\n-            PrimVal::Ptr(p) => Ok(p),\n-            PrimVal::Undef => err!(ReadUndefBytes),\n+            Scalar::Bytes(_) => err!(ReadBytesAsPointer),\n+            Scalar::Ptr(p) => Ok(p),\n+            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn is_bytes(self) -> bool {\n         match self {\n-            PrimVal::Bytes(_) => true,\n+            Scalar::Bytes(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_ptr(self) -> bool {\n         match self {\n-            PrimVal::Ptr(_) => true,\n+            Scalar::Ptr(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_undef(self) -> bool {\n         match self {\n-            PrimVal::Undef => true,\n+            Scalar::Undef => true,\n             _ => false,\n         }\n     }\n@@ -311,25 +311,25 @@ impl<'tcx> PrimVal {\n     }\n }\n \n-impl PrimValKind {\n+impl ScalarKind {\n     pub fn is_int(self) -> bool {\n-        use self::PrimValKind::*;\n+        use self::ScalarKind::*;\n         match self {\n             I8 | I16 | I32 | I64 | I128 | U8 | U16 | U32 | U64 | U128 => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_signed_int(self) -> bool {\n-        use self::PrimValKind::*;\n+        use self::ScalarKind::*;\n         match self {\n             I8 | I16 | I32 | I64 | I128 => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_float(self) -> bool {\n-        use self::PrimValKind::*;\n+        use self::ScalarKind::*;\n         match self {\n             F32 | F64 => true,\n             _ => false,\n@@ -338,28 +338,28 @@ impl PrimValKind {\n \n     pub fn from_uint_size(size: Size) -> Self {\n         match size.bytes() {\n-            1 => PrimValKind::U8,\n-            2 => PrimValKind::U16,\n-            4 => PrimValKind::U32,\n-            8 => PrimValKind::U64,\n-            16 => PrimValKind::U128,\n+            1 => ScalarKind::U8,\n+            2 => ScalarKind::U16,\n+            4 => ScalarKind::U32,\n+            8 => ScalarKind::U64,\n+            16 => ScalarKind::U128,\n             _ => bug!(\"can't make uint with size {}\", size.bytes()),\n         }\n     }\n \n     pub fn from_int_size(size: Size) -> Self {\n         match size.bytes() {\n-            1 => PrimValKind::I8,\n-            2 => PrimValKind::I16,\n-            4 => PrimValKind::I32,\n-            8 => PrimValKind::I64,\n-            16 => PrimValKind::I128,\n+            1 => ScalarKind::I8,\n+            2 => ScalarKind::I16,\n+            4 => ScalarKind::I32,\n+            8 => ScalarKind::I64,\n+            16 => ScalarKind::I128,\n             _ => bug!(\"can't make int with size {}\", size.bytes()),\n         }\n     }\n \n     pub fn is_ptr(self) -> bool {\n-        use self::PrimValKind::*;\n+        use self::ScalarKind::*;\n         match self {\n             Ptr | FnPtr => true,\n             _ => false,"}, {"sha": "8077429e526acd6b2163fea530f62a2fd88040a4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -24,7 +24,7 @@ use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n-use mir::interpret::{Value, PrimVal, EvalErrorKind};\n+use mir::interpret::{Value, Scalar, EvalErrorKind};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -1153,7 +1153,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                       .map(|&u| {\n                           let mut s = String::new();\n                           print_miri_value(\n-                              Value::ByVal(PrimVal::Bytes(u)),\n+                              Value::ByVal(Scalar::Bytes(u)),\n                               switch_ty,\n                               &mut s,\n                           ).unwrap();\n@@ -1893,19 +1893,19 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     match (value, &ty.sty) {\n-        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+        (Value::ByVal(Scalar::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(Scalar::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n             write!(f, \"{}f32\", Single::from_bits(bits)),\n-        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+        (Value::ByVal(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n             write!(f, \"{}f64\", Double::from_bits(bits)),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+        (Value::ByVal(Scalar::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n+        (Value::ByVal(Scalar::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n+        (Value::ByVal(Scalar::Bytes(n)), &TyChar) =>\n             write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n+        (Value::ByVal(Scalar::Undef), &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)),\n+        (Value::ByValPair(Scalar::Ptr(ptr), Scalar::Bytes(len)),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 match tcx.alloc_map.lock().get(ptr.alloc_id) {"}, {"sha": "2b07c8a197f467c26e4e1f5084cb49c376f05f26", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -19,7 +19,7 @@ use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use util::captures::Captures;\n-use mir::interpret::{PrimVal, MemoryPointer, Value, ConstValue};\n+use mir::interpret::{Scalar, MemoryPointer, Value, ConstValue};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1811,7 +1811,7 @@ impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn from_primval(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: PrimVal,\n+        val: Scalar,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n         Self::from_const_value(tcx, ConstValue::from_primval(val), ty)\n@@ -1823,12 +1823,12 @@ impl<'tcx> Const<'tcx> {\n         val: u128,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n-        Self::from_primval(tcx, PrimVal::Bytes(val), ty)\n+        Self::from_primval(tcx, Scalar::Bytes(val), ty)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_primval(tcx, PrimVal::Undef, ty)\n+        Self::from_primval(tcx, Scalar::Undef, ty)\n     }\n \n     #[inline]\n@@ -1869,7 +1869,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_primval(&self) -> Option<PrimVal> {\n+    pub fn to_primval(&self) -> Option<Scalar> {\n         match self.val {\n             ConstVal::Value(val) => val.to_primval(),\n             _ => None,"}, {"sha": "30f27dcfd52010ad2bbbe9ff2413eb6105572024", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -14,7 +14,7 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue, AllocType};\n+use rustc::mir::interpret::{GlobalId, MemoryPointer, Scalar, Allocation, ConstValue, AllocType};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar, Size};\n use builder::Builder;\n@@ -29,21 +29,21 @@ use super::super::callee;\n use super::FunctionCx;\n \n pub fn primval_to_llvm(cx: &CodegenCx,\n-                       cv: PrimVal,\n+                       cv: Scalar,\n                        scalar: &Scalar,\n                        llty: Type) -> ValueRef {\n     let bits = if scalar.is_bool() { 1 } else { scalar.value.size(cx).bits() };\n     match cv {\n-        PrimVal::Undef => C_undef(Type::ix(cx, bits)),\n-        PrimVal::Bytes(b) => {\n+        Scalar::Undef => C_undef(Type::ix(cx, bits)),\n+        Scalar::Bytes(b) => {\n             let llval = C_uint_big(Type::ix(cx, bits), b);\n             if scalar.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n         },\n-        PrimVal::Ptr(ptr) => {\n+        Scalar::Ptr(ptr) => {\n             let alloc_type = cx.tcx.alloc_map.lock().get(ptr.alloc_id);\n             let base_addr = match alloc_type {\n                 Some(AllocType::Memory(alloc)) => {\n@@ -96,7 +96,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n             cx,\n-            PrimVal::Ptr(MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }),\n+            Scalar::Ptr(MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }),\n             &Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0"}, {"sha": "0c2d6b69c72e8aac0029ec3eb98aa280f5d0f63e", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -184,23 +184,23 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n                 let ptr = MemoryPointer::zero(id);\n                 ConstValue::ByValPair(\n-                    PrimVal::Ptr(ptr),\n-                    PrimVal::from_u128(s.len() as u128),\n+                    Scalar::Ptr(ptr),\n+                    Scalar::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n                 let ptr = MemoryPointer::zero(id);\n-                ConstValue::ByVal(PrimVal::Ptr(ptr))\n+                ConstValue::ByVal(Scalar::Ptr(ptr))\n             },\n-            LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Byte(n) => ConstValue::ByVal(Scalar::Bytes(n as u128)),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n                 let n = clamp(n as u128);\n-                ConstValue::ByVal(PrimVal::Bytes(n))\n+                ConstValue::ByVal(Scalar::Bytes(n))\n             },\n-            LitKind::Int(n, _) => ConstValue::ByVal(PrimVal::Bytes(clamp(n))),\n+            LitKind::Int(n, _) => ConstValue::ByVal(Scalar::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n                 parse_float(n, fty)\n             }\n@@ -211,8 +211,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n-            LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n+            LitKind::Bool(b) => ConstValue::ByVal(Scalar::Bytes(b as u128)),\n+            LitKind::Char(c) => ConstValue::ByVal(Scalar::Bytes(c as u128)),\n         };\n         Literal::Value {\n             value: ty::Const::from_const_value(self.tcx, lit, ty)"}, {"sha": "d83471ff2e11a30f5465ccb2068861f5d7c03cd6", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -20,7 +20,7 @@ use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue, Value};\n+use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, Value};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -1084,13 +1084,19 @@ pub fn compare_const_vals<'a, 'tcx>(\n             match (a.to_byval_value(), b.to_byval_value()) {\n                 (\n                     Some(Value::ByValPair(\n-                        PrimVal::Ptr(ptr_a),\n-                        PrimVal::Bytes(size_a))\n-                    ),\n+                        Scalar::Ptr(ptr_a),\n+                        Scalar::Bits {\n+                            bits: size_a,\n+                            defined: tcx.data_layout.pointer_size.bits() as u8,\n+                        },\n+                    )),\n                     Some(Value::ByValPair(\n-                        PrimVal::Ptr(ptr_b),\n-                        PrimVal::Bytes(size_b))\n-                    )\n+                        Scalar::Ptr(ptr_b),\n+                        Scalar::Bits {\n+                            bits: size_b,\n+                            defined: tcx.data_layout.pointer_size.bits() as u8,\n+                        },\n+                    ))\n                 ) if size_a == size_b => {\n                     if ptr_a.offset == Size::from_bytes(0) && ptr_b.offset == Size::from_bytes(0) {\n                         let map = tcx.alloc_map.lock();\n@@ -1124,16 +1130,16 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             let id = tcx.allocate_bytes(s.as_bytes());\n             let ptr = MemoryPointer::zero(id);\n             ConstValue::ByValPair(\n-                PrimVal::Ptr(ptr),\n-                PrimVal::from_u128(s.len() as u128),\n+                Scalar::Ptr(ptr),\n+                Scalar::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             let ptr = MemoryPointer::zero(id);\n-            ConstValue::ByVal(PrimVal::Ptr(ptr))\n+            ConstValue::ByVal(Scalar::Ptr(ptr))\n         },\n-        LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Byte(n) => ConstValue::ByVal(Scalar::Bytes(n as u128)),\n         LitKind::Int(n, _) => {\n             enum Int {\n                 Signed(IntTy),\n@@ -1147,7 +1153,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 _ => bug!(),\n             };\n             // This converts from LitKind::Int (which is sign extended) to\n-            // PrimVal::Bytes (which is zero extended)\n+            // Scalar::Bytes (which is zero extended)\n             let n = match ty {\n                 // FIXME(oli-obk): are these casts correct?\n                 Int::Signed(IntTy::I8) if neg =>\n@@ -1167,7 +1173,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            ConstValue::ByVal(PrimVal::Bytes(n))\n+            ConstValue::ByVal(Scalar::Bytes(n))\n         },\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg)?\n@@ -1179,8 +1185,8 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg)?\n         }\n-        LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n-        LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n+        LitKind::Bool(b) => ConstValue::ByVal(Scalar::Bytes(b as u128)),\n+        LitKind::Char(c) => ConstValue::ByVal(Scalar::Bytes(c as u128)),\n     };\n     Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n@@ -1216,5 +1222,5 @@ pub fn parse_float<'tcx>(\n         }\n     };\n \n-    Ok(ConstValue::ByVal(PrimVal::Bytes(bits)))\n+    Ok(ConstValue::ByVal(Scalar::Bytes(bits)))\n }"}, {"sha": "d8c5f80ebbc2db71d60cc5782a305b9e83c9b2ad", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -4,23 +4,23 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n-use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, EvalResult, MemoryPointer, PointerArithmetic};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n-        val: PrimVal,\n+        val: Scalar,\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n \n         match val {\n-            PrimVal::Undef => Ok(PrimVal::Undef),\n-            PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            PrimVal::Bytes(b) => {\n+            Scalar::Undef => Ok(Scalar::Undef),\n+            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n+            Scalar::Bytes(b) => {\n                 match src_ty.sty {\n                     TyFloat(fty) => self.cast_from_float(b, fty, dest_ty),\n                     _ => self.cast_from_int(b, src_ty, dest_ty),\n@@ -34,7 +34,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         v: u128,\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         let signed = self.layout_of(src_ty)?.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_ty)?\n@@ -46,68 +46,68 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             TyInt(_) | TyUint(_) => {\n                 let v = self.truncate(v, dest_ty)?;\n-                Ok(PrimVal::Bytes(v))\n+                Ok(Scalar::Bytes(v))\n             }\n \n-            TyFloat(FloatTy::F32) if signed => Ok(PrimVal::Bytes(Single::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F64) if signed => Ok(PrimVal::Bytes(Double::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F32) => Ok(PrimVal::Bytes(Single::from_u128(v).value.to_bits())),\n-            TyFloat(FloatTy::F64) => Ok(PrimVal::Bytes(Double::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bytes(Single::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bytes(Double::from_i128(v as i128).value.to_bits())),\n+            TyFloat(FloatTy::F32) => Ok(Scalar::Bytes(Single::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F64) => Ok(Scalar::Bytes(Double::from_u128(v).value.to_bits())),\n \n-            TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n+            TyChar if v as u8 as u128 == v => Ok(Scalar::Bytes(v)),\n             TyChar => err!(InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n-                Ok(PrimVal::Bytes(self.memory.truncate_to_ptr(v).0 as u128))\n+                Ok(Scalar::Bytes(self.memory.truncate_to_ptr(v).0 as u128))\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n             // float -> uint\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n-                    FloatTy::F32 => Ok(PrimVal::Bytes(Single::from_bits(bits).to_u128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::Bytes(Double::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::Bytes(Single::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F64 => Ok(Scalar::Bytes(Double::from_bits(bits).to_u128(width).value)),\n                 }\n             },\n             // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n-                    FloatTy::F32 => Ok(PrimVal::from_i128(Single::from_bits(bits).to_i128(width).value)),\n-                    FloatTy::F64 => Ok(PrimVal::from_i128(Double::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::from_i128(Single::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F64 => Ok(Scalar::from_i128(Double::from_bits(bits).to_i128(width).value)),\n                 }\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(PrimVal::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n             },\n             // f32 -> f64\n             TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(PrimVal::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n             },\n             // identity cast\n-            TyFloat(_) => Ok(PrimVal::Bytes(bits)),\n+            TyFloat(_) => Ok(Scalar::Bytes(bits)),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }\n \n-    fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) |\n             TyInt(IntTy::Isize) |\n-            TyUint(UintTy::Usize) => Ok(PrimVal::Ptr(ptr)),\n+            TyUint(UintTy::Usize) => Ok(Scalar::Ptr(ptr)),\n             TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "b4b072769ee5ffabb313fa148134952389218100", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -12,7 +12,7 @@ use syntax::codemap::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Value, Pointer, PrimVal, AllocId, Allocation, ConstValue,\n+    Value, Pointer, Scalar, AllocId, Allocation, ConstValue,\n };\n use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory, MemoryKind};\n \n@@ -100,7 +100,7 @@ pub fn value_to_const_value<'tcx>(\n ) -> &'tcx ty::Const<'tcx> {\n     let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n     match (val, &layout.abi) {\n-        (Value::ByVal(PrimVal::Undef), _) if layout.is_zst() => {},\n+        (Value::ByVal(Scalar::Undef), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n         (Value::ByVal(_), &layout::Abi::Scalar(_)) |\n         (Value::ByValPair(..), &layout::Abi::ScalarPair(..)) => {},\n@@ -319,20 +319,20 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n+                let align_val = Scalar::from_u128(elem_align as u128);\n                 ecx.write_primval(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                ecx.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n+                ecx.write_primval(dest, Scalar::from_u128(size), dest_layout.ty)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n-                ecx.write_primval(dest, PrimVal::from_u128(type_id), dest_layout.ty)?;\n+                ecx.write_primval(dest, Scalar::from_u128(type_id), dest_layout.ty)?;\n             }\n \n             name => return Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()),\n@@ -349,11 +349,11 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn try_ptr_op<'a>(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         _left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         _right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         if left.is_bytes() && right.is_bytes() {\n             Ok(None)\n         } else {"}, {"sha": "b21c5d186cf1f37db282b1e97eaaf218a5375b2f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -14,7 +14,7 @@ use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Pointer, PrimVal, PrimValKind,\n+    GlobalId, Value, Pointer, Scalar, ScalarKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer, ConstValue,\n };\n use std::mem;\n@@ -74,9 +74,9 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     /// The list of locals for this stack frame, stored in order as\n     /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n-    /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n+    /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     ///\n-    /// Before being initialized, arguments are `Value::ByVal(PrimVal::Undef)` and other locals are `None`.\n+    /// Before being initialized, arguments are `Value::ByVal(Scalar::Undef)` and other locals are `None`.\n     pub locals: IndexVec<mir::Local, Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n@@ -231,8 +231,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_bytes(s.as_bytes());\n         Ok(Value::ByValPair(\n-            PrimVal::Ptr(ptr),\n-            PrimVal::from_u128(s.len() as u128),\n+            Scalar::Ptr(ptr),\n+            Scalar::from_u128(s.len() as u128),\n         ))\n     }\n \n@@ -408,7 +408,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ::log_settings::settings().indentation += 1;\n \n         let locals = if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(Some(Value::ByVal(PrimVal::Undef)), &mir.local_decls);\n+            let mut locals = IndexVec::from_elem(Some(Value::ByVal(Scalar::Undef)), &mir.local_decls);\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -608,7 +608,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n                 self.write_primval(\n                     dest,\n-                    PrimVal::from_u128(len as u128),\n+                    Scalar::from_u128(len as u128),\n                     dest_ty,\n                 )?;\n             }\n@@ -646,7 +646,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         \"SizeOf nullary MIR operator called for unsized type\");\n                 self.write_primval(\n                     dest,\n-                    PrimVal::from_u128(layout.size.bytes() as u128),\n+                    Scalar::from_u128(layout.size.bytes() as u128),\n                     dest_ty,\n                 )?;\n             }\n@@ -696,7 +696,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                             .val;\n                                         return self.write_primval(\n                                             dest,\n-                                            PrimVal::Bytes(discr_val),\n+                                            Scalar::Bytes(discr_val),\n                                             dest_ty);\n                                     }\n                                 }\n@@ -729,7 +729,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 ).ok_or_else(|| EvalErrorKind::TypeckError.into());\n                                 let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    value: Value::ByVal(Scalar::Ptr(fn_ptr)),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -765,7 +765,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                 );\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {\n-                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    value: Value::ByVal(Scalar::Ptr(fn_ptr)),\n                                     ty: dest_ty,\n                                 };\n                                 self.write_value(valty, dest)?;\n@@ -780,7 +780,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ty = self.place_ty(place);\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n+                self.write_primval(dest, Scalar::Bytes(discr_val), dest_ty)?;\n             }\n         }\n \n@@ -801,7 +801,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub(super) fn eval_operand_to_primval(\n         &mut self,\n         op: &mir::Operand<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         let valty = self.eval_operand(op)?;\n         self.value_to_primval(valty)\n     }\n@@ -937,12 +937,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let variants_start = *niche_variants.start() as u128;\n                 let variants_end = *niche_variants.end() as u128;\n                 match raw_discr {\n-                    PrimVal::Ptr(_) => {\n+                    Scalar::Ptr(_) => {\n                         assert!(niche_start == 0);\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n                     },\n-                    PrimVal::Bytes(raw_discr) => {\n+                    Scalar::Bytes(raw_discr) => {\n                         let discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= discr && discr <= variants_end {\n@@ -951,7 +951,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             dataful_variant as u128\n                         }\n                     },\n-                    PrimVal::Undef => return err!(ReadUndefBytes),\n+                    Scalar::Undef => return err!(ReadUndefBytes),\n                 }\n             }\n         };\n@@ -990,7 +990,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let discr_val = (discr_val << amt) >> amt;\n \n                 let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n-                self.write_primval(discr_dest, PrimVal::Bytes(discr_val), tag.ty)?;\n+                self.write_primval(discr_dest, Scalar::Bytes(discr_val), tag.ty)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -1003,7 +1003,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    self.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n+                    self.write_primval(niche_dest, Scalar::Bytes(niche_value), niche.ty)?;\n                 }\n             }\n         }\n@@ -1090,7 +1090,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn value_to_primval(\n         &self,\n         ValTy { value, ty } : ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n@@ -1115,7 +1115,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn write_primval(\n         &mut self,\n         dest: Place,\n-        val: PrimVal,\n+        val: Scalar,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let valty = ValTy {\n@@ -1239,12 +1239,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimValKind> {\n+    pub fn ty_to_primval_kind(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, ScalarKind> {\n         use syntax::ast::FloatTy;\n \n         let kind = match ty.sty {\n-            ty::TyBool => PrimValKind::Bool,\n-            ty::TyChar => PrimValKind::Char,\n+            ty::TyBool => ScalarKind::Bool,\n+            ty::TyChar => ScalarKind::Char,\n \n             ty::TyInt(int_ty) => {\n                 use syntax::ast::IntTy::*;\n@@ -1256,7 +1256,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     I128 => Size::from_bytes(16),\n                     Isize => self.memory.pointer_size(),\n                 };\n-                PrimValKind::from_int_size(size)\n+                ScalarKind::from_int_size(size)\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1269,31 +1269,31 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     U128 => Size::from_bytes(16),\n                     Usize => self.memory.pointer_size(),\n                 };\n-                PrimValKind::from_uint_size(size)\n+                ScalarKind::from_uint_size(size)\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimValKind::F32,\n-            ty::TyFloat(FloatTy::F64) => PrimValKind::F64,\n+            ty::TyFloat(FloatTy::F32) => ScalarKind::F32,\n+            ty::TyFloat(FloatTy::F64) => ScalarKind::F64,\n \n-            ty::TyFnPtr(_) => PrimValKind::FnPtr,\n+            ty::TyFnPtr(_) => ScalarKind::FnPtr,\n \n             ty::TyRef(_, ty, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => {\n-                PrimValKind::Ptr\n+                ScalarKind::Ptr\n             }\n \n-            ty::TyAdt(def, _) if def.is_box() => PrimValKind::Ptr,\n+            ty::TyAdt(def, _) if def.is_box() => ScalarKind::Ptr,\n \n             ty::TyAdt(..) => {\n                 match self.layout_of(ty)?.abi {\n                     layout::Abi::Scalar(ref scalar) => {\n                         use rustc::ty::layout::Primitive::*;\n                         match scalar.value {\n-                            Int(i, false) => PrimValKind::from_uint_size(i.size()),\n-                            Int(i, true) => PrimValKind::from_int_size(i.size()),\n-                            F32 => PrimValKind::F32,\n-                            F64 => PrimValKind::F64,\n-                            Pointer => PrimValKind::Ptr,\n+                            Int(i, false) => ScalarKind::from_uint_size(i.size()),\n+                            Int(i, true) => ScalarKind::from_int_size(i.size()),\n+                            F32 => ScalarKind::F32,\n+                            F64 => ScalarKind::F64,\n+                            Pointer => ScalarKind::Ptr,\n                         }\n                     }\n \n@@ -1307,7 +1307,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(kind)\n     }\n \n-    fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn ensure_valid_value(&self, val: Scalar, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool if val.to_bytes()? > 1 => err!(InvalidBool),\n \n@@ -1366,7 +1366,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             ty::TyBool => {\n                 let val = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(1))?;\n                 match val {\n-                    PrimVal::Bytes(0) | PrimVal::Bytes(1) => (),\n+                    Scalar::Bytes(0) | Scalar::Bytes(1) => (),\n                     // TODO: This seems a little overeager, should reading at bool type already be insta-UB?\n                     _ => return err!(InvalidBool),\n                 }\n@@ -1419,7 +1419,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::ByVal(PrimVal::Undef)));\n+            return Ok(Some(Value::ByVal(Scalar::Undef)));\n         }\n \n         let ptr = ptr.to_ptr()?;\n@@ -1615,7 +1615,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     }\n                     Ok(Value::ByRef(ptr, align)) => {\n                         match ptr.into_inner_primval() {\n-                            PrimVal::Ptr(ptr) => {\n+                            Scalar::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n@@ -1624,16 +1624,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     }\n                     Ok(Value::ByVal(val)) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val {\n+                        if let Scalar::Ptr(ptr) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     Ok(Value::ByValPair(val1, val2)) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n-                        if let PrimVal::Ptr(ptr) = val1 {\n+                        if let Scalar::Ptr(ptr) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        if let PrimVal::Ptr(ptr) = val2 {\n+                        if let Scalar::Ptr(ptr) = val2 {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n@@ -1644,7 +1644,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             Place::Ptr { ptr, align, .. } => {\n                 match ptr.into_inner_primval() {\n-                    PrimVal::Ptr(ptr) => {\n+                    Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n@@ -1797,7 +1797,7 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         trace!(\"{:?} is now live\", local);\n \n         // StorageLive *always* kills the value that's currently stored\n-        mem::replace(&mut self.locals[local], Some(Value::ByVal(PrimVal::Undef)))\n+        mem::replace(&mut self.locals[local], Some(Value::ByVal(Scalar::Undef)))\n     }\n \n     /// Returns the old value of the local"}, {"sha": "3054bbd1d77eb22e101a0cea149cad17dc477f98", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{AllocId, EvalResult, PrimVal, MemoryPointer, AccessKind, GlobalId};\n+use rustc::mir::interpret::{AllocId, EvalResult, Scalar, MemoryPointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n@@ -54,11 +54,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn try_ptr_op<'a>(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n     fn mark_static_initialized<'a>("}, {"sha": "589ef4f1d2caba89710c8ba7ff23571c268e29e9", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -11,7 +11,7 @@ use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n-                            EvalResult, PrimVal, EvalErrorKind, GlobalId, AllocType};\n+                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n use super::{EvalContext, Machine};\n@@ -231,19 +231,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn check_align(&self, ptr: Pointer, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr.into_inner_primval() {\n-            PrimVal::Ptr(ptr) => {\n+            Scalar::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 (ptr.offset.bytes(), alloc.align)\n             }\n-            PrimVal::Bytes(bytes) => {\n+            Scalar::Bytes(bytes) => {\n                 let v = ((bytes as u128) % (1 << self.pointer_size().bytes())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the base address if the \"integer allocation\" is 0 and hence always aligned\n                 (v, required_align)\n             }\n-            PrimVal::Undef => return err!(ReadUndefBytes),\n+            Scalar::Undef => return err!(ReadUndefBytes),\n         };\n         // Check alignment\n         if alloc_align.abi() < required_align.abi() {\n@@ -707,14 +707,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, Scalar> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            return Ok(PrimVal::Undef.into());\n+            return Ok(Scalar::Undef.into());\n         }\n         // Now we do the actual reading\n         let bytes = read_target_uint(endianness, bytes).unwrap();\n@@ -726,30 +726,30 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)))),\n+                Some(&alloc_id) => return Ok(Scalar::Ptr(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)))),\n                 None => {},\n             }\n         }\n         // We don't. Just return the bytes.\n-        Ok(PrimVal::Bytes(bytes))\n+        Ok(Scalar::Bytes(bytes))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_ptr_sized(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n         self.read_primval(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: PrimVal, size: Size, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, ptr: Pointer, ptr_align: Align, val: Scalar, size: Size, signed: bool) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n \n         let bytes = match val {\n-            PrimVal::Ptr(val) => {\n+            Scalar::Ptr(val) => {\n                 assert_eq!(size, self.pointer_size());\n                 val.offset.bytes() as u128\n             }\n \n-            PrimVal::Bytes(bytes) => bytes,\n+            Scalar::Bytes(bytes) => bytes,\n \n-            PrimVal::Undef => {\n+            Scalar::Undef => {\n                 self.check_align(ptr.into(), ptr_align)?;\n                 self.mark_definedness(ptr, size, false)?;\n                 return Ok(());\n@@ -770,7 +770,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         // See if we have to also write a relocation\n         match val {\n-            PrimVal::Ptr(val) => {\n+            Scalar::Ptr(val) => {\n                 self.get_mut(ptr.alloc_id)?.relocations.insert(\n                     ptr.offset,\n                     val.alloc_id,\n@@ -782,7 +782,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: Scalar) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_primval(ptr.into(), ptr_align, val, ptr_size, false)\n     }\n@@ -954,7 +954,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n \n             Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n-            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n+            Value::ByVal(Scalar::Undef) => err!(ReadUndefBytes),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n@@ -978,7 +978,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 assert_eq!(len as u64 as u128, len);\n                 Ok((ptr.into(), len as u64))\n             }\n-            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n+            Value::ByVal(Scalar::Undef) => err!(ReadUndefBytes),\n             Value::ByVal(_) => bug!(\"expected ptr and length, got {:?}\", value),\n         }\n     }"}, {"sha": "eece3ec6f05bbc2ace83acaf8135cac891db4df8", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -7,15 +7,15 @@ use rustc_apfloat::Float;\n \n use super::{EvalContext, Place, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         let left_val = self.value_to_primval(left)?;\n         let right_val = self.value_to_primval(right)?;\n         self.binary_op(op, left_val, left.ty, right_val, right.ty)\n@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n+        let val = Value::ByValPair(val, Scalar::from_bool(overflowed));\n         let valty = ValTy {\n             value: val,\n             ty: dest_ty,\n@@ -61,11 +61,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n         let left_kind = self.ty_to_primval_kind(left_ty)?;\n@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_ty)?;\n-            return Ok((PrimVal::Bytes(truncated), oflo));\n+            return Ok((Scalar::Bytes(truncated), oflo));\n         }\n \n         if left_kind != right_kind {\n@@ -136,7 +136,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l = self.sign_extend(l, left_ty)? as i128;\n                 let r = self.sign_extend(r, right_ty)? as i128;\n-                return Ok((PrimVal::from_bool(op(&l, &r)), false));\n+                return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n                 Div if r == 0 => return err!(DivisionByZero),\n@@ -156,7 +156,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size - 1)) {\n-                            return Ok((PrimVal::Bytes(l), true));\n+                            return Ok((Scalar::Bytes(l), true));\n                         }\n                     },\n                     _ => {},\n@@ -170,7 +170,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((PrimVal::Bytes(truncated), oflo));\n+                return Ok((Scalar::Bytes(truncated), oflo));\n             }\n         }\n \n@@ -180,17 +180,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     let l = <$ty>::from_bits(l);\n                     let r = <$ty>::from_bits(r);\n                     let val = match bin_op {\n-                        Eq => PrimVal::from_bool(l == r),\n-                        Ne => PrimVal::from_bool(l != r),\n-                        Lt => PrimVal::from_bool(l < r),\n-                        Le => PrimVal::from_bool(l <= r),\n-                        Gt => PrimVal::from_bool(l > r),\n-                        Ge => PrimVal::from_bool(l >= r),\n-                        Add => PrimVal::Bytes((l + r).value.to_bits()),\n-                        Sub => PrimVal::Bytes((l - r).value.to_bits()),\n-                        Mul => PrimVal::Bytes((l * r).value.to_bits()),\n-                        Div => PrimVal::Bytes((l / r).value.to_bits()),\n-                        Rem => PrimVal::Bytes((l % r).value.to_bits()),\n+                        Eq => Scalar::from_bool(l == r),\n+                        Ne => Scalar::from_bool(l != r),\n+                        Lt => Scalar::from_bool(l < r),\n+                        Le => Scalar::from_bool(l <= r),\n+                        Gt => Scalar::from_bool(l > r),\n+                        Ge => Scalar::from_bool(l >= r),\n+                        Add => Scalar::Bytes((l + r).value.to_bits()),\n+                        Sub => Scalar::Bytes((l - r).value.to_bits()),\n+                        Mul => Scalar::Bytes((l * r).value.to_bits()),\n+                        Div => Scalar::Bytes((l / r).value.to_bits()),\n+                        Rem => Scalar::Bytes((l % r).value.to_bits()),\n                         _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n                     };\n                     return Ok((val, false));\n@@ -204,17 +204,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         // only ints left\n         let val = match bin_op {\n-            Eq => PrimVal::from_bool(l == r),\n-            Ne => PrimVal::from_bool(l != r),\n+            Eq => Scalar::from_bool(l == r),\n+            Ne => Scalar::from_bool(l != r),\n \n-            Lt => PrimVal::from_bool(l < r),\n-            Le => PrimVal::from_bool(l <= r),\n-            Gt => PrimVal::from_bool(l > r),\n-            Ge => PrimVal::from_bool(l >= r),\n+            Lt => Scalar::from_bool(l < r),\n+            Le => Scalar::from_bool(l <= r),\n+            Gt => Scalar::from_bool(l > r),\n+            Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => PrimVal::Bytes(l | r),\n-            BitAnd => PrimVal::Bytes(l & r),\n-            BitXor => PrimVal::Bytes(l ^ r),\n+            BitOr => Scalar::Bytes(l | r),\n+            BitAnd => Scalar::Bytes(l & r),\n+            BitXor => Scalar::Bytes(l ^ r),\n \n             Add | Sub | Mul | Rem | Div => {\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n@@ -229,7 +229,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((PrimVal::Bytes(truncated), oflo || truncated != result));\n+                return Ok((Scalar::Bytes(truncated), oflo || truncated != result));\n             }\n \n             _ => {\n@@ -251,9 +251,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: PrimVal,\n+        val: Scalar,\n         ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, PrimVal> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         use rustc::mir::UnOp::*;\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n@@ -274,6 +274,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n \n-        Ok(PrimVal::Bytes(self.truncate(result_bytes, ty)?))\n+        Ok(Scalar::Bytes(self.truncate(result_bytes, ty)?))\n     }\n }"}, {"sha": "c0586cde4eb2ff907bd3342260c46f3b0a73b349", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer, MemoryPointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -35,7 +35,7 @@ pub enum PlaceExtra {\n impl<'tcx> Place {\n     /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n+        Self::from_primval_ptr(Scalar::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n     pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n@@ -128,7 +128,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(Some((Value::ByVal(PrimVal::Undef), field.ty)))\n+            return Ok(Some((Value::ByVal(Scalar::Undef), field.ty)))\n         }\n         let offset = base_layout.fields.offset(field_index);\n         match base {"}, {"sha": "aebf5cdfda597031cb00f277b12d4b9b3565aeac", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -2,7 +2,7 @@ use rustc::mir::BasicBlock;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n                 let vtable = match arg {\n-                    Value::ByValPair(_, PrimVal::Ptr(vtable)) => vtable,\n+                    Value::ByValPair(_, Scalar::Ptr(vtable)) => vtable,\n                     _ => bug!(\"expected fat ptr, got {:?}\", arg),\n                 };\n                 match self.read_drop_type_from_vtable(vtable)? {"}, {"sha": "3fe7cbffdb0eb1ce3ca4d2ce0a18f0d596918a23", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                             self.write_value(valty, dest)?;\n                                         }\n                                     }\n-                                    Value::ByVal(PrimVal::Undef) => {}\n+                                    Value::ByVal(Scalar::Undef) => {}\n                                     other => {\n                                         trace!(\"{:#?}, {:#?}\", other, layout);\n                                         let mut layout = layout;"}, {"sha": "70b8094ab917b03ce3cc1fdb7a64890509214c13", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Value, MemoryPointer, EvalResult};\n use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -35,19 +35,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, Scalar::Ptr(drop))?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, PrimVal::Bytes(size as u128))?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bytes(size as u128))?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, PrimVal::Bytes(align as u128))?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bytes(align as u128))?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, PrimVal::Ptr(fn_ptr))?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, Scalar::Ptr(fn_ptr))?;\n             }\n         }\n \n@@ -67,8 +67,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n-            Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n-            Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n+            Value::ByVal(Scalar::Bytes(0)) => Ok(None),\n+            Value::ByVal(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n     }"}, {"sha": "bc7f1b69e85d915f6d32573f5040605c10cc6f62", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -203,7 +203,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::{PrimVal, GlobalId, AllocType};\n+use rustc::mir::interpret::{Scalar, GlobalId, AllocType};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1245,13 +1245,13 @@ fn collect_const<'a, 'tcx>(\n     };\n     match val {\n         ConstVal::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n-        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n+        ConstVal::Value(ConstValue::ByValPair(Scalar::Ptr(a), Scalar::Ptr(b))) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);\n         }\n-        ConstVal::Value(ConstValue::ByValPair(_, PrimVal::Ptr(ptr))) |\n-        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(ptr), _)) |\n-        ConstVal::Value(ConstValue::ByVal(PrimVal::Ptr(ptr))) =>\n+        ConstVal::Value(ConstValue::ByValPair(_, Scalar::Ptr(ptr))) |\n+        ConstVal::Value(ConstValue::ByValPair(Scalar::Ptr(ptr), _)) |\n+        ConstVal::Value(ConstValue::ByVal(Scalar::Ptr(ptr))) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstVal::Value(ConstValue::ByRef(alloc, _offset)) => {\n             for &id in alloc.relocations.values() {"}, {"sha": "de25a532e493f7ca2dce52bf8af317cdb6390c50", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1606e137e7de642d7994e201ed54389a4e808e24/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1606e137e7de642d7994e201ed54389a4e808e24", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionE\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{TyCtxt, self, Instance};\n-use rustc::mir::interpret::{Value, PrimVal, GlobalId, EvalResult};\n+use rustc::mir::interpret::{Value, Scalar, GlobalId, EvalResult};\n use interpret::EvalContext;\n use interpret::CompileTimeEvaluator;\n use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n@@ -283,7 +283,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 let param_env = self.tcx.param_env(self.source.def_id);\n                 type_size_of(self.tcx, param_env, ty).map(|n| (\n-                    Value::ByVal(PrimVal::Bytes(n as u128)),\n+                    Value::ByVal(Scalar::Bytes(n as u128)),\n                     self.tcx.types.usize,\n                     span,\n                 ))\n@@ -359,7 +359,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ByValPair(\n                         val,\n-                        PrimVal::from_bool(overflow),\n+                        Scalar::from_bool(overflow),\n                     )\n                 } else {\n                     if overflow {\n@@ -485,7 +485,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::ByVal(PrimVal::from_bool(*expected)) != value.0 {\n+                if Value::ByVal(Scalar::from_bool(*expected)) != value.0 {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -520,14 +520,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n-                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                Value::ByVal(Scalar::Bytes(n)) => n,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n                             };\n                             let index = self\n                                 .eval_operand(index)\n                                 .expect(\"index must be const\");\n                             let index = match index.0 {\n-                                Value::ByVal(PrimVal::Bytes(n)) => n,\n+                                Value::ByVal(Scalar::Bytes(n)) => n,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),\n                             };\n                             format!("}]}