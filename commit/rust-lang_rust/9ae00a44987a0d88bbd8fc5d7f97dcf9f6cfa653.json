{"sha": "9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZTAwYTQ0OTg3YTBkODhiYmQ4ZmM1ZDdmOTdkY2Y5ZjZjZmE2NTM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-02T02:28:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-02T02:28:48Z"}, "message": "Merge pull request #1847 from topecongiro/issue-1843\n\nImplement single-line where", "tree": {"sha": "c342cbb736f84d103e8245156f2e6e500274a263", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c342cbb736f84d103e8245156f2e6e500274a263"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "html_url": "https://github.com/rust-lang/rust/commit/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39745b954015e96e7cd35f31be33be46bb1a9bd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/39745b954015e96e7cd35f31be33be46bb1a9bd1", "html_url": "https://github.com/rust-lang/rust/commit/39745b954015e96e7cd35f31be33be46bb1a9bd1"}, {"sha": "d2acd9970381a500e99dc2f51f98844a7b0c46cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2acd9970381a500e99dc2f51f98844a7b0c46cb", "html_url": "https://github.com/rust-lang/rust/commit/d2acd9970381a500e99dc2f51f98844a7b0c46cb"}], "stats": {"total": 282, "additions": 149, "deletions": 133}, "files": [{"sha": "65292d60b2686f909641cccd610b5316d479ff86", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -539,7 +539,7 @@ create_config! {\n     // 1. Should we at least try to put the where clause on the same line as the rest of the\n     // function decl?\n     // 2. Currently options `Tall` and `Vertical` produce the same output.\n-    where_density: Density, Density::CompressedIfEmpty, \"Density of a where clause\";\n+    where_density: Density, Density::Vertical, \"Density of a where clause\";\n     where_layout: ListTactic, ListTactic::Vertical, \"Element layout inside a where clause\";\n     where_pred_indent: IndentStyle, IndentStyle::Visual,\n         \"Indentation style of a where predicate\";"}, {"sha": "dccae7342e69951f54bd9baf2d484207c90871d6", "filename": "src/items.rs", "status": "modified", "additions": 113, "deletions": 110, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -26,8 +26,9 @@ use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, L\n             ListItem, ListTactic, Separator, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::join_bounds;\n-use utils::{colon_spaces, contains_skip, end_typaram, format_defaultness, format_mutability,\n-            format_unsafety, format_visibility, last_line_width, mk_sp, semicolon_for_expr,\n+use utils::{colon_spaces, contains_skip, end_typaram, first_line_width, format_abi,\n+            format_constness, format_defaultness, format_mutability, format_unsafety,\n+            format_visibility, last_line_used_width, last_line_width, mk_sp, semicolon_for_expr,\n             stmt_expr, trim_newlines, trimmed_last_line_width, wrap_str};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n@@ -257,12 +258,12 @@ impl<'a> FmtVisitor<'a> {\n         span: Span,\n         block: &ast::Block,\n     ) -> Option<String> {\n-        let mut newline_brace = newline_for_brace(self.config, &generics.where_clause);\n         let context = self.get_context();\n \n         let block_snippet = self.snippet(mk_sp(block.span.lo, block.span.hi));\n         let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n             !context.config.fn_empty_single_line();\n+        let mut newline_brace = newline_for_brace(self.config, &generics.where_clause, has_body);\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(\n             &context,\n@@ -589,6 +590,7 @@ pub fn format_impl(\n             \"{\",\n             false,\n             last_line_width(&ref_and_type) == 1,\n+            false,\n             where_span_end,\n             self_ty.span.hi,\n         ));\n@@ -833,11 +835,7 @@ fn rewrite_trait_ref(\n     result_len: usize,\n ) -> Option<String> {\n     // 1 = space between generics and trait_ref\n-    let used_space = 1 + polarity_str.len() + if generics_str.contains('\\n') {\n-        last_line_width(&generics_str)\n-    } else {\n-        result_len + generics_str.len()\n-    };\n+    let used_space = 1 + polarity_str.len() + last_line_used_width(generics_str, result_len);\n     let shape = Shape::indented(offset + used_space, context.config);\n     if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n         if !(retry && trait_ref_str.contains('\\n')) {\n@@ -984,6 +982,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             \"{\",\n             false,\n             trait_bound_str.is_empty() && last_line_width(&generics_str) == 1,\n+            false,\n             None,\n             pos_before_where,\n         ));\n@@ -1216,6 +1215,7 @@ fn format_tuple_struct(\n                 \";\",\n                 true,\n                 false,\n+                false,\n                 None,\n                 body_hi,\n             ))\n@@ -1225,11 +1225,7 @@ fn format_tuple_struct(\n \n     if fields.is_empty() {\n         // 3 = `();`\n-        let used_width = if result.contains('\\n') {\n-            last_line_width(&result) + 3\n-        } else {\n-            offset.width() + result.len() + 3\n-        };\n+        let used_width = last_line_used_width(&result, offset.width()) + 3;\n         if used_width > context.config.max_width() {\n             result.push('\\n');\n             result.push_str(&offset\n@@ -1316,6 +1312,7 @@ pub fn rewrite_type_alias(\n         \"=\",\n         true,\n         true,\n+        false,\n         Some(span.hi),\n         generics.span.hi,\n     ));\n@@ -1785,24 +1782,13 @@ fn rewrite_fn_base(\n     let where_clause = &generics.where_clause;\n \n     let mut result = String::with_capacity(1024);\n-    // Vis unsafety abi.\n+    // Vis defaultness constness unsafety abi.\n     result.push_str(&*format_visibility(vis));\n-\n-    if let ast::Defaultness::Default = defaultness {\n-        result.push_str(\"default \");\n-    }\n-\n-    if let ast::Constness::Const = constness {\n-        result.push_str(\"const \");\n-    }\n-\n-    result.push_str(::utils::format_unsafety(unsafety));\n-\n+    result.push_str(format_defaultness(defaultness));\n+    result.push_str(format_constness(constness));\n+    result.push_str(format_unsafety(unsafety));\n     if abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(\n-            abi,\n-            context.config.force_explicit_abi(),\n-        ));\n+        result.push_str(&format_abi(abi, context.config.force_explicit_abi()));\n     }\n \n     // fn foo\n@@ -1817,9 +1803,17 @@ fn rewrite_fn_base(\n         // 2 = `()`\n         2\n     };\n-    let shape = try_opt!(\n-        Shape::indented(indent + last_line_width(&result), context.config).sub_width(overhead)\n-    );\n+    let used_width = last_line_used_width(&result, indent.width());\n+    let one_line_budget = context\n+        .config\n+        .max_width()\n+        .checked_sub(used_width + overhead)\n+        .unwrap_or(0);\n+    let shape = Shape {\n+        width: one_line_budget,\n+        indent: indent,\n+        offset: used_width,\n+    };\n     let g_span = mk_sp(span.lo, fd.output.span().lo);\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n@@ -1840,21 +1834,15 @@ fn rewrite_fn_base(\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n     // Args.\n-    let (mut one_line_budget, mut multi_line_budget, mut arg_indent) =\n-        try_opt!(compute_budgets_for_args(\n-            context,\n-            &result,\n-            indent,\n-            ret_str_len,\n-            newline_brace,\n-            has_braces,\n-        ));\n-\n-    if context.config.fn_args_layout() == IndentStyle::Block {\n-        arg_indent = indent.block_indent(context.config);\n-        // 1 = \",\"\n-        multi_line_budget = context.config.max_width() - (arg_indent.width() + 1);\n-    }\n+    let (one_line_budget, multi_line_budget, mut arg_indent) = try_opt!(compute_budgets_for_args(\n+        context,\n+        &result,\n+        indent,\n+        ret_str_len,\n+        newline_brace,\n+        has_braces,\n+        multi_line_ret_str,\n+    ));\n \n     debug!(\n         \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n@@ -1890,10 +1878,6 @@ fn rewrite_fn_base(\n         result.push(' ')\n     }\n \n-    if multi_line_ret_str {\n-        one_line_budget = 0;\n-    }\n-\n     // A conservative estimation, to goal is to be over all parens in generics\n     let args_start = generics\n         .ty_params\n@@ -1922,11 +1906,8 @@ fn rewrite_fn_base(\n         generics_str.contains('\\n'),\n     ));\n \n-    let multi_line_arg_str =\n-        arg_str.contains('\\n') || arg_str.chars().last().map_or(false, |c| c == ',');\n-\n     let put_args_in_block = match context.config.fn_args_layout() {\n-        IndentStyle::Block => multi_line_arg_str || generics_str.contains('\\n'),\n+        IndentStyle::Block => arg_str.contains('\\n') || arg_str.len() > one_line_budget,\n         _ => false,\n     } && !fd.inputs.is_empty();\n \n@@ -1941,6 +1922,12 @@ fn rewrite_fn_base(\n         result.push(')');\n     } else {\n         result.push_str(&arg_str);\n+        let used_width = last_line_used_width(&result, indent.width()) + first_line_width(&ret_str);\n+        // Put the closing brace on the next line if it overflows the max width.\n+        // 1 = `)`\n+        if fd.inputs.len() == 0 && used_width + 1 > context.config.max_width() {\n+            result.push('\\n');\n+        }\n         if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n@@ -1959,15 +1946,16 @@ fn rewrite_fn_base(\n     }\n \n     // Return type.\n-    if !ret_str.is_empty() {\n+    if let ast::FunctionRetTy::Ty(..) = fd.output {\n         let ret_should_indent = match context.config.fn_args_layout() {\n             // If our args are block layout then we surely must have space.\n-            IndentStyle::Block if put_args_in_block => false,\n+            IndentStyle::Block if put_args_in_block || fd.inputs.len() == 0 => false,\n+            _ if args_last_line_contains_comment => false,\n+            _ if result.contains('\\n') || multi_line_ret_str => true,\n             _ => {\n-                // If we've already gone multi-line, or the return type would push over the max\n-                // width, then put the return type on a new line. With the +1 for the signature\n-                // length an additional space between the closing parenthesis of the argument and\n-                // the arrow '->' is considered.\n+                // If the return type would push over the max width, then put the return type on\n+                // a new line. With the +1 for the signature length an additional space between\n+                // the closing parenthesis of the argument and the arrow '->' is considered.\n                 let mut sig_length = result.len() + indent.width() + ret_str_len + 1;\n \n                 // If there is no where clause, take into account the space after the return type\n@@ -1976,10 +1964,7 @@ fn rewrite_fn_base(\n                     sig_length += 2;\n                 }\n \n-                let overlong_sig = sig_length > context.config.max_width();\n-\n-                (!args_last_line_contains_comment) &&\n-                    (result.contains('\\n') || multi_line_ret_str || overlong_sig)\n+                sig_length > context.config.max_width()\n             }\n         };\n         let ret_indent = if ret_should_indent {\n@@ -2044,44 +2029,38 @@ fn rewrite_fn_base(\n     }\n \n     let should_compress_where = match context.config.where_density() {\n-        Density::Compressed => !result.contains('\\n') || put_args_in_block,\n+        Density::Compressed => !result.contains('\\n'),\n         Density::CompressedIfEmpty => !has_body && !result.contains('\\n'),\n         _ => false,\n-    } || (put_args_in_block && ret_str.is_empty());\n+    };\n \n     let pos_before_where = match fd.output {\n         ast::FunctionRetTy::Default(..) => args_span.hi,\n         ast::FunctionRetTy::Ty(ref ty) => ty.span.hi,\n     };\n+\n     if where_clause.predicates.len() == 1 && should_compress_where {\n-        let budget = try_opt!(\n-            context\n-                .config\n-                .max_width()\n-                .checked_sub(last_line_width(&result))\n-        );\n+        let budget = context\n+            .config\n+            .max_width()\n+            .checked_sub(last_line_used_width(&result, indent.width()))\n+            .unwrap_or(0);\n         if let Some(where_clause_str) = rewrite_where_clause(\n             context,\n             where_clause,\n             context.config.fn_brace_style(),\n             Shape::legacy(budget, indent),\n             Density::Compressed,\n             \"{\",\n-            !has_braces,\n-            put_args_in_block && ret_str.is_empty(),\n+            true,\n+            false, // Force where clause on the next line\n+            true,  // Compress where\n             Some(span.hi),\n             pos_before_where,\n         ) {\n-            if !where_clause_str.contains('\\n') {\n-                if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n-                    result.push('\\n');\n-                }\n-\n-                result.push_str(&where_clause_str);\n-\n-                force_new_line_for_brace |= last_line_contains_single_line_comment(&result);\n-                return Some((result, force_new_line_for_brace));\n-            }\n+            result.push_str(&where_clause_str);\n+            force_new_line_for_brace |= last_line_contains_single_line_comment(&result);\n+            return Some((result, force_new_line_for_brace));\n         }\n     }\n \n@@ -2094,6 +2073,7 @@ fn rewrite_fn_base(\n         \"{\",\n         !has_braces,\n         put_args_in_block && ret_str.is_empty(),\n+        false,\n         Some(span.hi),\n         pos_before_where,\n     ));\n@@ -2275,6 +2255,7 @@ fn compute_budgets_for_args(\n     ret_str_len: usize,\n     newline_brace: bool,\n     has_braces: bool,\n+    force_vertical_layout: bool,\n ) -> Option<((usize, usize, Indent))> {\n     debug!(\n         \"compute_budgets_for_args {} {:?}, {}, {}\",\n@@ -2284,7 +2265,7 @@ fn compute_budgets_for_args(\n         newline_brace\n     );\n     // Try keeping everything on the same line.\n-    if !result.contains('\\n') {\n+    if !result.contains('\\n') && !force_vertical_layout {\n         // 2 = `()`, 3 = `() `, space is before ret_string.\n         let overhead = if ret_str_len == 0 { 2 } else { 3 };\n         let mut used_space = indent.width() + result.len() + ret_str_len + overhead;\n@@ -2305,31 +2286,45 @@ fn compute_budgets_for_args(\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n-            let multi_line_overhead =\n-                indent.width() + result.len() + if newline_brace { 2 } else { 4 };\n-            let multi_line_budget =\n-                try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n-\n-            return Some((\n-                one_line_budget,\n-                multi_line_budget,\n-                indent + result.len() + 1,\n-            ));\n+            let (indent, multi_line_budget) = match context.config.fn_args_layout() {\n+                IndentStyle::Block => {\n+                    let indent = indent.block_indent(context.config);\n+                    let budget =\n+                        try_opt!(context.config.max_width().checked_sub(indent.width() + 1));\n+                    (indent, budget)\n+                }\n+                IndentStyle::Visual => {\n+                    let indent = indent + result.len() + 1;\n+                    let multi_line_overhead =\n+                        indent.width() + result.len() + if newline_brace { 2 } else { 4 };\n+                    let budget =\n+                        try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n+                    (indent, budget)\n+                }\n+            };\n+\n+            return Some((one_line_budget, multi_line_budget, indent));\n         }\n     }\n \n     // Didn't work. we must force vertical layout and put args on a newline.\n     let new_indent = indent.block_indent(context.config);\n-    // Account for `)` and possibly ` {`.\n-    let used_space = new_indent.width() + if ret_str_len == 0 { 1 } else { 3 };\n+    let used_space = match context.config.fn_args_layout() {\n+        // 1 = `,`\n+        IndentStyle::Block => new_indent.width() + 1,\n+        // Account for `)` and possibly ` {`.\n+        IndentStyle::Visual => new_indent.width() + if ret_str_len == 0 { 1 } else { 3 },\n+    };\n     let max_space = try_opt!(context.config.max_width().checked_sub(used_space));\n     Some((0, max_space, new_indent))\n }\n \n-fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n-    match config.fn_brace_style() {\n-        BraceStyle::AlwaysNextLine => true,\n-        BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n+fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause, has_body: bool) -> bool {\n+    match (config.fn_brace_style(), config.where_density()) {\n+        (BraceStyle::AlwaysNextLine, _) => true,\n+        (_, Density::Compressed) if where_clause.predicates.len() == 1 => false,\n+        (_, Density::CompressedIfEmpty) if where_clause.predicates.len() == 1 && !has_body => false,\n+        (BraceStyle::SameLineWhere, _) if !where_clause.predicates.is_empty() => true,\n         _ => false,\n     }\n }\n@@ -2495,6 +2490,8 @@ fn rewrite_where_clause_rfc_style(\n     suppress_comma: bool,\n     // where clause can be kept on the current line.\n     snuggle: bool,\n+    // copmressed single where clause\n+    compress_where: bool,\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n ) -> Option<String> {\n@@ -2560,14 +2557,21 @@ fn rewrite_where_clause_rfc_style(\n     } else {\n         \"\\n\".to_owned() + &clause_shape.indent.to_string(context.config)\n     };\n+    let clause_sep = if compress_where && comment_before.is_empty() && comment_after.is_empty() &&\n+        !preds_str.contains('\\n') && 6 + preds_str.len() <= shape.width\n+    {\n+        String::from(\" \")\n+    } else {\n+        format!(\"\\n{}\", clause_shape.indent.to_string(context.config))\n+    };\n     Some(format!(\n-        \"{}{}{}where{}{}\\n{}{}\",\n+        \"{}{}{}where{}{}{}{}\",\n         starting_newline,\n         comment_before,\n         newline_before_where,\n         newline_after_where,\n         comment_after,\n-        clause_shape.indent.to_string(context.config),\n+        clause_sep,\n         preds_str\n     ))\n }\n@@ -2581,6 +2585,7 @@ fn rewrite_where_clause(\n     terminator: &str,\n     suppress_comma: bool,\n     snuggle: bool,\n+    compress_where: bool,\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n ) -> Option<String> {\n@@ -2596,6 +2601,7 @@ fn rewrite_where_clause(\n             terminator,\n             suppress_comma,\n             snuggle,\n+            compress_where,\n             span_end,\n             span_end_before_where,\n         );\n@@ -2745,7 +2751,7 @@ fn format_generics(\n         let budget = context\n             .config\n             .max_width()\n-            .checked_sub(last_line_width(&result))\n+            .checked_sub(last_line_used_width(&result, offset.width()))\n             .unwrap_or(0);\n         let where_clause_str = try_opt!(rewrite_where_clause(\n             context,\n@@ -2756,6 +2762,7 @@ fn format_generics(\n             terminator,\n             false,\n             trimmed_last_line_width(&result) == 1,\n+            false,\n             Some(span.hi),\n             generics.span.hi,\n         ));\n@@ -2766,11 +2773,7 @@ fn format_generics(\n         force_same_line_brace || trimmed_last_line_width(&result) == 1 ||\n             brace_style != BraceStyle::AlwaysNextLine\n     };\n-    let total_used_width = if result.contains('\\n') {\n-        last_line_width(&result)\n-    } else {\n-        used_width + result.len()\n-    };\n+    let total_used_width = last_line_used_width(&result, used_width);\n     let remaining_budget = context\n         .config\n         .max_width()"}, {"sha": "d0917721898a217e9e5857fc18c64828d3ad214b", "filename": "src/utils.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -56,6 +56,14 @@ pub fn format_visibility(vis: &Visibility) -> Cow<'static, str> {\n     }\n }\n \n+#[inline]\n+pub fn format_constness(constness: ast::Constness) -> &'static str {\n+    match constness {\n+        ast::Constness::Const => \"const \",\n+        ast::Constness::NotConst => \"\",\n+    }\n+}\n+\n #[inline]\n pub fn format_defaultness(defaultness: ast::Defaultness) -> &'static str {\n     match defaultness {\n@@ -107,6 +115,16 @@ pub fn last_line_width(s: &str) -> usize {\n     }\n }\n \n+// The total used width of the last line.\n+#[inline]\n+pub fn last_line_used_width(s: &str, offset: usize) -> usize {\n+    if s.contains('\\n') {\n+        last_line_width(s)\n+    } else {\n+        offset + s.len()\n+    }\n+}\n+\n #[inline]\n pub fn trimmed_last_line_width(s: &str) -> usize {\n     match s.rfind('\\n') {"}, {"sha": "deddbee459f480334a0965946f63b4f6afa9859a", "filename": "tests/target/configs-where_density-compressed.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fconfigs-where_density-compressed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fconfigs-where_density-compressed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-where_density-compressed.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -3,13 +3,10 @@\n \n trait Lorem {\n     fn ipsum<Dolor>(dolor: Dolor) -> Sit\n-    where\n-        Dolor: Eq;\n+    where Dolor: Eq;\n \n     fn ipsum<Dolor>(dolor: Dolor) -> Sit\n-    where\n-        Dolor: Eq,\n-    {\n+    where Dolor: Eq {\n         // body\n     }\n }"}, {"sha": "45f22eb602c4c835f60c4b010b3ac3c3526875fa", "filename": "tests/target/configs-where_density-compressed_if_empty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fconfigs-where_density-compressed_if_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fconfigs-where_density-compressed_if_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-where_density-compressed_if_empty.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -3,8 +3,7 @@\n \n trait Lorem {\n     fn ipsum<Dolor>(dolor: Dolor) -> Sit\n-    where\n-        Dolor: Eq;\n+    where Dolor: Eq;\n \n     fn ipsum<Dolor>(dolor: Dolor) -> Sit\n     where"}, {"sha": "297aae5123b9aaecf7e3e9deceacfbc4fdb8c7a0", "filename": "tests/target/fn-custom-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Ffn-custom-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Ffn-custom-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-custom-4.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -13,9 +13,7 @@ where\n }\n \n fn qux()\n-where\n-    X: TTTTTTTTTTTTTTTTTTTTTTTTTTTT,\n-{\n+where X: TTTTTTTTTTTTTTTTTTTTTTTTTTTT {\n     baz();\n }\n "}, {"sha": "c8847768e13eb5101f6f81ae1dd4ec0a6783eca7", "filename": "tests/target/fn_args_layout-block.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Ffn_args_layout-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Ffn_args_layout-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn_args_layout-block.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -86,14 +86,12 @@ where\n {\n }\n \n-fn foo()\n-    -> (\n+fn foo() -> (\n     Loooooooooooooooooooooong,\n     Reeeeeeeeeeeeeeeeeeeeeeeeturn,\n     iiiiiiiiis,\n     Looooooooooooooooong,\n-)\n-{\n+) {\n     foo();\n }\n \n@@ -136,13 +134,11 @@ fn foo<L: Loooooooooooooooooooong, G: Geeeeeeeeeeneric, I: iiiiiiiiis, L: Looooo\n     foo();\n }\n \n-fn foo()\n-    -> (\n+fn foo() -> (\n     Looooooooooooooooooooooooooong,\n     Reeeeeeeeeeeeeeeeeeeeeeeeeeeeeturn,\n     iiiiiiiiiiiiiis,\n     Loooooooooooooooooooooong,\n-)\n-{\n+) {\n     foo();\n }"}, {"sha": "c3d44de7c69be40ffd1f499a8b48748a5201f048", "filename": "tests/target/long-fn-1.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Flong-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Flong-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flong-fn-1.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -12,3 +12,10 @@ impl Foo {\n     fn some_inpu(&mut self, input: Input, input_path: Option<PathBuf>) -> (Input, Option<PathBuf>) {\n     }\n }\n+\n+// #1843\n+#[allow(non_snake_case)]\n+pub extern \"C\" fn Java_com_exonum_binding_storage_indices_ValueSetIndexProxy_nativeContainsByHash(\n+) -> bool {\n+    false\n+}"}, {"sha": "6e61c82e5f61ccdc934c9eac77b04b2d8f04641e", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=9ae00a44987a0d88bbd8fc5d7f97dcf9f6cfa653", "patch": "@@ -151,16 +151,14 @@ fn main() {\n     let s = expand(a, b);\n }\n \n-fn deconstruct()\n-    -> (\n+fn deconstruct() -> (\n     SocketAddr,\n     Method,\n     Headers,\n     RequestUri,\n     HttpVersion,\n     AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n-)\n-{\n+) {\n }\n \n fn deconstruct("}]}