{"sha": "021d97d1c5e053176961970ccbcad9f2802e9c91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMWQ5N2QxYzVlMDUzMTc2OTYxOTcwY2NiY2FkOWYyODAyZTljOTE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-26T21:53:47Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "Move suggestion list creation to coerce check", "tree": {"sha": "2426658ee5c0fe7d2130afc5cc36e5683804f6bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2426658ee5c0fe7d2130afc5cc36e5683804f6bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/021d97d1c5e053176961970ccbcad9f2802e9c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/021d97d1c5e053176961970ccbcad9f2802e9c91", "html_url": "https://github.com/rust-lang/rust/commit/021d97d1c5e053176961970ccbcad9f2802e9c91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/021d97d1c5e053176961970ccbcad9f2802e9c91/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "164f0105bb65f31b89e5fb7f368c9e6f5833a3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/164f0105bb65f31b89e5fb7f368c9e6f5833a3f8", "html_url": "https://github.com/rust-lang/rust/commit/164f0105bb65f31b89e5fb7f368c9e6f5833a3f8"}], "stats": {"total": 394, "additions": 333, "deletions": 61}, "files": [{"sha": "8fed2a8209516158db87e566b348c5247d8a81ed", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=021d97d1c5e053176961970ccbcad9f2802e9c91", "patch": "@@ -83,13 +83,14 @@ use hir::def_id::DefId;\n use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, ImplOrTraitItem, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n+//use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n@@ -233,6 +234,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+/*struct MethodInfo<'tcx> {\n+    ast: Option<ast::Attribute>,\n+    id: DefId,\n+    item: Rc<ImplOrTraitItem<'tcx>>,\n+}\n+\n+impl<'tcx> MethodInfo<'tcx> {\n+    fn new(ast: Option<ast::Attribute>, id: DefId, item: Rc<ImplOrTraitItem<'tcx>>) -> MethodInfo {\n+        MethodInfo {\n+            ast: ast,\n+            id: id,\n+            item: item,\n+        }\n+    }\n+}*/\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_region_errors(&self,\n                                 errors: &Vec<RegionResolutionError<'tcx>>) {\n@@ -583,36 +600,53 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            if let Some((found, (expected_ty, _))) = self.get_ids(values) {\n+            //if let Some((found, (expected_ty, expected))) = self.get_ids(values) {\n                 // look for expected with found id\n-                self.tcx.populate_inherent_implementations_for_type_if_necessary(found);\n+                /*self.tcx.populate_inherent_implementations_for_type_if_necessary(found);\n                 if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&found) {\n-                    let mut methods: Vec<(Option<ast::Attribute>, DefId, ImplOrTraitItem<'tcx>)> = Vec::new();\n+                    let mut methods: Vec<MethodInfo> = Vec::new();\n                     for impl_ in impl_infos {\n                         methods.append(&mut self.tcx\n                                                 .impl_or_trait_items(*impl_)\n                                                 .iter()\n-                                                .map(|&did| (None, did, self.tcx.impl_or_trait_item(did)))\n-                                                .filter(|&(_, _, ref x)| {\n-                                                    self.matches_return_type(x, &expected_ty)\n+                                                .map(|&did| MethodInfo::new(None, did, Rc::new(self.tcx.impl_or_trait_item(did))))\n+                                                .filter(|ref x| {\n+                                                    self.matches_return_type(&*x.item, &expected_ty)\n                                                 })\n                                                 .collect());\n                     }\n-                    let safe_suggestions: Vec<_> = methods.iter()\n-                                                  .map(|&(_, ref id, ref x)| (self.find_attr(*id, \"safe_suggestion\"), id, x))\n-                                                  .filter(|&(ref res, _, _)| res.is_some())\n-                                                  .collect();\n-                    if safe_suggestions.len() > 0 {\n-                        for (_, _, method) in safe_suggestions {\n-                            println!(\"safe ==> {:?}\", method.name());\n-                        }\n-                    } else {\n-                        for &(_, _, ref method) in methods.iter() {\n-                            println!(\"not safe ==> {:?}\", method.name());\n+                    for did in self.tcx.sess.cstore.implementations_of_trait(None) {\n+                        if did == found {\n+                            methods.append(\n+                                self.tcx.sess.cstore.impl_or_trait_items(did)\n+                                                    .iter()\n+                                                    .map(|&did| MethodInfo::new(None, did, Rc::new(self.tcx.impl_or_trait_item(did))))\n+                                                    .filter(|ref x| {\n+                                                        self.matches_return_type(&*x.item, &expected_ty)\n+                                                    })\n+                                                    .collect());\n+                            ;\n                         }\n                     }\n-                }\n-            }\n+                    let safe_suggestions: Vec<_> =\n+                        methods.iter()\n+                               .map(|ref x| MethodInfo::new(self.find_attr(x.id, \"safe_suggestion\"), x.id, x.item.clone()))\n+                               .filter(|ref x| x.ast.is_some())\n+                               .collect();\n+                    if safe_suggestions.len() > 0 {\n+                        println!(\"safe\");\n+                        self.get_best_match(&safe_suggestions);\n+                    } else {\n+                        println!(\"not safe\");\n+                        self.get_best_match(&methods);\n+                    }*/\n+                    /*let mode = probe::Mode::MethodCall;\n+                    if let Ok(ret) = self.probe_return(DUMMY_SP, mode, expected, found,                               DUMMY_NODE_ID) {\n+                        println!(\"got it\");\n+                    } else {\n+                        println!(\"sad...\");\n+                    }*/\n+            //}\n         }\n \n         diag.span_label(span, &terr);\n@@ -625,14 +659,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n \n+    /*fn get_best_match(&self, methods: &[MethodInfo<'tcx>]) -> String {\n+        let no_argument_methods: Vec<&MethodInfo> =\n+            methods.iter()\n+                   .filter(|ref x| self.has_not_input_arg(&*x.item))\n+                   .collect();\n+        if no_argument_methods.len() > 0 {\n+            for ref method in no_argument_methods {\n+                println!(\"best match ==> {:?}\", method.item.name());\n+            }\n+        } else {\n+            for ref method in methods.iter() {\n+                println!(\"not best ==> {:?}\", method.item.name());\n+            }\n+        }\n+        String::new()\n+    }\n+\n     fn find_attr(&self, def_id: DefId, attr_name: &str) -> Option<ast::Attribute> {\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(attr_name) {\n                 return Some(item.clone());\n             }\n         }\n         None\n-    }\n+    }*/\n \n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n@@ -662,6 +713,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /*fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n+        match *method {\n+            ImplOrTraitItem::MethodTraitItem(ref x) => {\n+                x.fty.sig.skip_binder().inputs.len() == 1\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn matches_return_type(&self, method: &ImplOrTraitItem<'tcx>, expected: &ty::Ty<'tcx>) -> bool {\n         match *method {\n             ImplOrTraitItem::MethodTraitItem(ref x) => {\n@@ -714,7 +774,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             _ => None,\n         }\n-    }\n+    }*/\n \n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,"}, {"sha": "db711e4a31db4ec3902ea926fdda17e72cb3653b", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=021d97d1c5e053176961970ccbcad9f2802e9c91", "patch": "@@ -14,8 +14,32 @@ use rustc::ty::Ty;\n use rustc::infer::{InferOk};\n use rustc::traits::ObligationCause;\n \n-use syntax_pos::Span;\n+use syntax::ast;\n+use syntax_pos::{self, Span};\n use rustc::hir;\n+use rustc::ty::{self, ImplOrTraitItem};\n+\n+use hir::def_id::DefId;\n+\n+use std::rc::Rc;\n+\n+use super::method::probe;\n+\n+struct MethodInfo<'tcx> {\n+    ast: Option<ast::Attribute>,\n+    id: DefId,\n+    item: Rc<ImplOrTraitItem<'tcx>>,\n+}\n+\n+impl<'tcx> MethodInfo<'tcx> {\n+    fn new(ast: Option<ast::Attribute>, id: DefId, item: Rc<ImplOrTraitItem<'tcx>>) -> MethodInfo {\n+        MethodInfo {\n+            ast: ast,\n+            id: id,\n+            item: item,\n+        }\n+    }\n+}\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n@@ -57,7 +81,70 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n+            let mode = probe::Mode::MethodCall;\n+            if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP, mode, expected,\n+                                                   checked_ty, ast::DUMMY_NODE_ID) {\n+                let suggestions: Vec<_> =\n+                    methods.iter()\n+                           .filter_map(|ref x| {\n+                            if let Some(id) = self.get_impl_id(&x.item) {\n+                                Some(MethodInfo::new(None, id, Rc::new(x.item.clone())))\n+                            } else {\n+                                None\n+                            }})\n+                           .collect();\n+                let safe_suggestions: Vec<_> =\n+                    suggestions.iter()\n+                               .map(|ref x| MethodInfo::new(\n+                                                self.find_attr(x.id, \"safe_suggestion\"),\n+                                                               x.id,\n+                                                               x.item.clone()))\n+                               .filter(|ref x| x.ast.is_some())\n+                               .collect();\n+                if safe_suggestions.len() > 0 {\n+                    self.get_best_match(&safe_suggestions);\n+                } else {\n+                    self.get_best_match(&suggestions);\n+                }\n+            }\n             self.report_mismatched_types(&cause, expected, expr_ty, e);\n         }\n     }\n+\n+    fn get_best_match(&self, methods: &[MethodInfo<'tcx>]) -> String {\n+        if methods.len() == 1 {\n+            println!(\"unique match ==> {:?}\", methods[0].item.name());\n+            return String::new();\n+        }\n+        let no_argument_methods: Vec<&MethodInfo> =\n+            methods.iter()\n+                   .filter(|ref x| self.has_not_input_arg(&*x.item))\n+                   .collect();\n+        if no_argument_methods.len() > 0 {\n+            for ref method in no_argument_methods {\n+                println!(\"best match ==> {:?}\", method.item.name());\n+            }\n+        } else {\n+            for ref method in methods.iter() {\n+                println!(\"not best ==> {:?}\", method.item.name());\n+            }\n+        }\n+        String::new()\n+    }\n+\n+    fn get_impl_id(&self, impl_: &ImplOrTraitItem<'tcx>) -> Option<DefId> {\n+        match *impl_ {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref m) => Some((*m).def_id),\n+            _ => None,\n+        }\n+    }\n+\n+    fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n+        match *method {\n+            ImplOrTraitItem::MethodTraitItem(ref x) => {\n+                x.fty.sig.skip_binder().inputs.len() == 1\n+            }\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "0af32c8fe6dca9d68960df03dd0d17e313a0a1df", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=021d97d1c5e053176961970ccbcad9f2802e9c91", "patch": "@@ -30,7 +30,7 @@ pub use self::CandidateSource::*;\n pub use self::suggest::AllTraitsVec;\n \n mod confirm;\n-mod probe;\n+pub mod probe;\n mod suggest;\n \n pub enum MethodError<'tcx> {\n@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n+        let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?.remove(0);\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -328,7 +328,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n-        let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n+        let picks = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n+        let pick = &picks[0];\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -353,4 +354,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            -> Option<ty::AssociatedItem> {\n         self.tcx.associated_items(def_id).find(|item| item.name == item_name)\n     }\n+\n+    fn matches_return_type(&self, method: &ty::ImplOrTraitItem<'tcx>,\n+                           expected: ty::Ty<'tcx>) -> bool {\n+        match *method {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref x) => {\n+                self.can_sub_types(x.fty.sig.skip_binder().output, expected).is_ok()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn impl_or_return_item(&self,\n+                               def_id: DefId,\n+                               return_type: ty::Ty<'tcx>)\n+                               -> Option<ty::ImplOrTraitItem<'tcx>> {\n+        self.tcx\n+            .impl_or_trait_items(def_id)\n+            .iter()\n+            .map(|&did| self.tcx.impl_or_trait_item(did))\n+            .find(|m| self.matches_return_type(m, return_type))\n+    }\n }"}, {"sha": "32de37764f6e8b1a9ed5c189231f63579d3f8258", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 138, "deletions": 35, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d97d1c5e053176961970ccbcad9f2802e9c91/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=021d97d1c5e053176961970ccbcad9f2802e9c91", "patch": "@@ -32,11 +32,16 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n+pub enum LookingFor<'tcx> {\n+    MethodName(ast::Name),\n+    ReturnType(Ty<'tcx>),\n+}\n+\n struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    item_name: ast::Name,\n+    looking_for: LookingFor<'tcx>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -129,7 +134,7 @@ pub enum PickKind<'tcx> {\n                     ty::PolyTraitRef<'tcx>),\n }\n \n-pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n+pub type PickResult<'tcx> = Result<Vec<Pick<'tcx>>, MethodError<'tcx>>;\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n@@ -144,6 +149,20 @@ pub enum Mode {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    pub fn probe_return(&self,\n+                        span: Span,\n+                        mode: Mode,\n+                        return_type: Ty<'tcx>,\n+                        self_ty: Ty<'tcx>,\n+                        scope_expr_id: ast::NodeId)\n+                        -> PickResult<'tcx> {\n+        debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n+               self_ty,\n+               return_type,\n+               scope_expr_id);\n+        self._probe(span, mode, LookingFor::ReturnType(return_type), self_ty, scope_expr_id)\n+    }\n+\n     pub fn probe_method(&self,\n                         span: Span,\n                         mode: Mode,\n@@ -155,6 +174,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                self_ty,\n                item_name,\n                scope_expr_id);\n+        self._probe(span, mode, LookingFor::MethodName(item_name), self_ty, scope_expr_id)\n+    }\n+\n+    fn _probe(&self,\n+              span: Span,\n+              mode: Mode,\n+              looking_for: LookingFor<'tcx>,\n+              self_ty: Ty<'tcx>,\n+              scope_expr_id: ast::NodeId)\n+              -> PickResult<'tcx> {\n \n         // FIXME(#18741) -- right now, creating the steps involves evaluating the\n         // `*` operator, which registers obligations that then escape into\n@@ -207,14 +236,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, item_name, steps, opt_simplified_steps);\n+                ProbeContext::new(self, span, mode, looking_for,\n+                                  steps, opt_simplified_steps);\n             probe_cx.assemble_inherent_candidates();\n             probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n             probe_cx.pick()\n         })\n     }\n \n-    fn create_steps(&self, span: Span, self_ty: Ty<'tcx>) -> Option<Vec<CandidateStep<'tcx>>> {\n+    fn create_steps(&self,\n+                    span: Span,\n+                    self_ty: Ty<'tcx>)\n+                    -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n         let mut autoderef = self.autoderef(span, self_ty);\n@@ -247,21 +280,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         Some(steps)\n     }\n+\n+    pub fn find_attr(&self, def_id: DefId, attr_name: &str) -> Option<ast::Attribute> {\n+        for item in self.tcx.get_attrs(def_id).iter() {\n+            if item.check_name(attr_name) {\n+                return Some(item.clone());\n+            }\n+        }\n+        None\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           item_name: ast::Name,\n+           looking_for: LookingFor<'tcx>,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx: fcx,\n             span: span,\n             mode: mode,\n-            item_name: item_name,\n+            looking_for: looking_for,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n@@ -584,15 +626,36 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    fn matches_return_type(&self, method: &ty::ImplOrTraitItem<'tcx>,\n+                           expected: &ty::Ty<'tcx>) -> bool {\n+        match *method {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref x) => {\n+                self.can_sub_types(x.fty.sig.skip_binder().output, expected).is_ok()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: DefId)\n                                                -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        let maybe_item = self.tcx.associated_items(trait_def_id)\n-                             .find(|item| item.name == self.item_name);\n+        let trait_items = self.tcx.associated_items(trait_def_id);\n+        let maybe_item = match self.looking_for {\n+            LookingFor::MethodName(item_name) => {\n+                trait_items.iter()\n+                           .find(|item| item.name == item_name)\n+            }\n+            LookingFor::ReturnType(item_ty) => {\n+                trait_items.iter()\n+                           .find(|item| {\n+                                self.matches_return_type(item, &item_ty)\n+                            })\n+            }\n+        };\n         let item = match maybe_item {\n             Some(i) => i,\n             None => {\n@@ -837,8 +900,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n-        if let Some(r) = self.pick_core() {\n-            return r;\n+        if let Some(ret) = self.pick_core() {\n+            return ret;\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n@@ -855,6 +918,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container.id()],\n+            //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n                     .map(|source| {\n@@ -896,9 +960,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n         let steps = self.steps.clone();\n+        let mut ret = Vec::new();\n \n-        // find the first step that works\n-        steps.iter().filter_map(|step| self.pick_step(step)).next()\n+        for step in steps.iter() {\n+            match self.pick_step(step) {\n+                Some(Ok(mut elems)) => ret.append(&mut elems),\n+                _ => {}\n+            }\n+        }\n+        if ret.len() < 1 {\n+            None\n+        } else {\n+            Some(Ok(ret))\n+        }\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -929,16 +1003,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         self.pick_method(step.self_ty).map(|r| {\n-            r.map(|mut pick| {\n-                pick.autoderefs = step.autoderefs;\n-\n-                // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::TyRef(_, mt) = step.self_ty.sty {\n-                    pick.autoderefs += 1;\n-                    pick.autoref = Some(mt.mutbl);\n+            r.map(|mut picks| {\n+                for pick in picks.iter_mut() {\n+                    pick.autoderefs = step.autoderefs;\n+\n+                    // Insert a `&*` or `&mut *` if this is a reference type:\n+                    if let ty::TyRef(_, mt) = step.self_ty.sty {\n+                        pick.autoderefs += 1;\n+                        pick.autoref = Some(mt.mutbl);\n+                    }\n                 }\n \n-                pick\n+                picks\n             })\n         })\n     }\n@@ -949,9 +1025,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n         let region = tcx.mk_region(ty::ReErased);\n+        let mut res = Vec::new();\n \n         // Search through mutabilities in order to find one where pick works:\n-        [hir::MutImmutable, hir::MutMutable]\n+        for _ in [hir::MutImmutable, hir::MutMutable]\n             .iter()\n             .filter_map(|&m| {\n                 let autoref_ty = tcx.mk_ref(region,\n@@ -960,19 +1037,26 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                 mutbl: m,\n                                             });\n                 self.pick_method(autoref_ty).map(|r| {\n-                    r.map(|mut pick| {\n-                        pick.autoderefs = step.autoderefs;\n-                        pick.autoref = Some(m);\n-                        pick.unsize = if step.unsize {\n-                            Some(step.self_ty)\n-                        } else {\n-                            None\n-                        };\n-                        pick\n+                    r.map(|mut picks| {\n+                        for pick in picks.iter_mut() {\n+                            pick.autoderefs = step.autoderefs;\n+                            pick.autoref = Some(m);\n+                            pick.unsize = if step.unsize {\n+                                Some(step.self_ty)\n+                            } else {\n+                                None\n+                            };\n+                        }\n+                        res.append(&mut picks);\n                     })\n                 })\n-            })\n-            .nth(0)\n+            }) {}\n+\n+        if res.len() < 1 {\n+            None\n+        } else {\n+            Some(Ok(res))\n+        }\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1002,7 +1086,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            probes: &[Candidate<'tcx>],\n                            possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n-        let mut applicable_candidates: Vec<_> = probes.iter()\n+        let applicable_candidates: Vec<_> = probes.iter()\n             .filter(|&probe| self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             .collect();\n \n@@ -1011,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n                 Some(pick) => {\n-                    return Some(Ok(pick));\n+                    return Some(Ok(vec![pick]));\n                 }\n                 None => {}\n             }\n@@ -1022,7 +1106,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n+        let ret: Vec<_> = applicable_candidates.iter()\n+                                               .map(|probe| probe.to_unadjusted_pick())\n+                                               .collect();\n+\n+        if ret.len() < 1 {\n+            None\n+        } else {\n+            Some(Ok(ret))\n+        }\n     }\n \n     fn consider_probe(&self,\n@@ -1262,6 +1354,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn associated_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n         self.fcx.associated_item(def_id, self.item_name)\n     }\n+\n+    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::ImplOrTraitItem<'tcx>> {\n+        match self.looking_for {\n+            LookingFor::MethodName(name) => {\n+                self.fcx.impl_or_trait_item(def_id, name)\n+            }\n+            LookingFor::ReturnType(return_ty) => {\n+                self.fcx.impl_or_return_item(def_id, return_ty)\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Candidate<'tcx> {"}]}