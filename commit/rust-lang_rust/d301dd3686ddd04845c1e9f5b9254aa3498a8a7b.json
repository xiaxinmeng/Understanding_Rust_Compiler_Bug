{"sha": "d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMDFkZDM2ODZkZGQwNDg0NWMxZTlmNWI5MjU0YWEzNDk4YThhN2I=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-07T21:56:18Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-07T21:56:18Z"}, "message": "remove the old auto_serialize syntax extension", "tree": {"sha": "cd486ef0e451fe8ce7c98a6a212f3237e4f390b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd486ef0e451fe8ce7c98a6a212f3237e4f390b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "html_url": "https://github.com/rust-lang/rust/commit/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c517ca4815273285ac5699a88ccf0bcdb6103e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c517ca4815273285ac5699a88ccf0bcdb6103e", "html_url": "https://github.com/rust-lang/rust/commit/e1c517ca4815273285ac5699a88ccf0bcdb6103e"}], "stats": {"total": 462, "additions": 146, "deletions": 316}, "files": [{"sha": "63a6551bf888fe7fae98e0edd360dce0f6d1194d", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 108, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "patch": "@@ -122,34 +122,7 @@ fn expand(cx: ext_ctxt,\n     }\n }\n \n-trait ext_ctxt_helpers {\n-    fn helper_path(base_path: @ast::path, helper_name: ~str) -> @ast::path;\n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path;\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path;\n-    fn ty_path(span: span, strs: ~[ast::ident], tps: ~[@ast::ty]) -> @ast::ty;\n-    fn ty_fn(span: span,\n-             -input_tys: ~[@ast::ty],\n-             -output: @ast::ty) -> @ast::ty;\n-    fn ty_nil(span: span) -> @ast::ty;\n-    fn expr(span: span, node: ast::expr_) -> @ast::expr;\n-    fn var_ref(span: span, name: ast::ident) -> @ast::expr;\n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n-    fn expr_blk(expr: @ast::expr) -> ast::blk;\n-    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat;\n-    fn stmt(expr: @ast::expr) -> @ast::stmt;\n-    fn alt_stmt(arms: ~[ast::arm], span: span, -v: @ast::expr) -> @ast::stmt;\n-    fn lit_str(span: span, s: @~str) -> @ast::expr;\n-    fn lit_uint(span: span, i: uint) -> @ast::expr;\n-    fn lambda(blk: ast::blk) -> @ast::expr;\n-    fn clone_folder() -> fold::ast_fold;\n-    fn clone(v: @ast::expr) -> @ast::expr;\n-    fn clone_ty(v: @ast::ty) -> @ast::ty;\n-    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param;\n-    fn at(span: span, expr: @ast::expr) -> @ast::expr;\n-}\n-\n-impl ext_ctxt: ext_ctxt_helpers {\n+priv impl ext_ctxt {\n     fn helper_path(base_path: @ast::path,\n                    helper_name: ~str) -> @ast::path {\n         let head = vec::init(base_path.idents);\n@@ -162,22 +135,6 @@ impl ext_ctxt: ext_ctxt_helpers {\n                                              tail)))]))\n     }\n \n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n-    }\n-\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: tps}\n-    }\n-\n-    fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::ty]) -> @ast::ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n-          span: span}\n-    }\n-\n     fn ty_fn(span: span,\n              -input_tys: ~[@ast::ty],\n              -output: @ast::ty) -> @ast::ty {\n@@ -202,48 +159,10 @@ impl ext_ctxt: ext_ctxt_helpers {\n         @{id: self.next_id(), node: ast::ty_nil, span: span}\n     }\n \n-    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n-        @{id: self.next_id(), callee_id: self.next_id(),\n-          node: node, span: span}\n-    }\n-\n     fn var_ref(span: span, name: ast::ident) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, ~[name])))\n     }\n \n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: span}\n-    }\n-\n-    fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: expr.span}\n-    }\n-\n-    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        let path = @{span: span, global: false, idents: ~[nm],\n-                     rp: None, types: ~[]};\n-        @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_implicit_ref,\n-                               path,\n-                               None),\n-          span: span}\n-    }\n-\n-    fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @{node: ast::stmt_semi(expr, self.next_id()),\n-          span: expr.span}\n-    }\n-\n     fn alt_stmt(arms: ~[ast::arm],\n                 span: span, -v: @ast::expr) -> @ast::stmt {\n         self.stmt(\n@@ -252,32 +171,6 @@ impl ext_ctxt: ext_ctxt_helpers {\n                 ast::expr_match(v, arms)))\n     }\n \n-    fn lit_str(span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @{node: ast::lit_str(s),\n-                          span: span})),\n-                ast::expr_vstore_uniq))\n-    }\n-\n-    fn lit_uint(span: span, i: uint) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_lit(\n-                @{node: ast::lit_uint(i as u64, ast::ty_u),\n-                  span: span}))\n-    }\n-\n-    fn lambda(blk: ast::blk) -> @ast::expr {\n-        let ext_cx = self;\n-        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast{ || $(blk_e) }\n-    }\n-\n     fn clone_folder() -> fold::ast_fold {\n         fold::make_fold(@{\n             new_id: |_id| self.next_id(),"}, {"sha": "ba48b0d3f5fac77d2234aedfb7eac22e2f4ede68", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "patch": "@@ -215,6 +215,86 @@ fn expand_auto_deserialize(\n }\n \n priv impl ext_ctxt {\n+    fn expr(span: span, node: ast::expr_) -> @ast::expr {\n+        @{id: self.next_id(), callee_id: self.next_id(),\n+          node: node, span: span}\n+    }\n+\n+    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n+    }\n+\n+    fn path_tps(span: span, strs: ~[ast::ident],\n+                tps: ~[@ast::ty]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: tps}\n+    }\n+\n+    fn ty_path(span: span, strs: ~[ast::ident],\n+               tps: ~[@ast::ty]) -> @ast::ty {\n+        @{id: self.next_id(),\n+          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n+          span: span}\n+    }\n+\n+    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n+        let path = @{span: span, global: false, idents: ~[nm],\n+                     rp: None, types: ~[]};\n+        @{id: self.next_id(),\n+          node: ast::pat_ident(ast::bind_by_implicit_ref,\n+                               path,\n+                               None),\n+          span: span}\n+    }\n+\n+    fn stmt(expr: @ast::expr) -> @ast::stmt {\n+        @{node: ast::stmt_semi(expr, self.next_id()),\n+          span: expr.span}\n+    }\n+\n+    fn lit_str(span: span, s: @~str) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_vstore(\n+                self.expr(\n+                    span,\n+                    ast::expr_lit(\n+                        @{node: ast::lit_str(s),\n+                          span: span})),\n+                ast::expr_vstore_uniq))\n+    }\n+\n+    fn lit_uint(span: span, i: uint) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @{node: ast::lit_uint(i as u64, ast::ty_u),\n+                  span: span}))\n+    }\n+\n+    fn lambda(blk: ast::blk) -> @ast::expr {\n+        let ext_cx = self;\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk));\n+        #ast{ || $(blk_e) }\n+    }\n+\n+    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: span}\n+    }\n+\n+    fn expr_blk(expr: @ast::expr) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: expr.span}\n+    }\n+\n     fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, strs)))\n     }"}, {"sha": "794c5233e21ebc3377d321bcb28883a04ded4b32", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "patch": "@@ -64,6 +64,7 @@ enum syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n+#[cfg(stage0)]\n fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     fn builtin(f: syntax_expander_) -> syntax_extension\n         {normal({expander: f, span: None})}\n@@ -122,6 +123,69 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     return syntax_expanders;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n+    fn builtin(f: syntax_expander_) -> syntax_extension\n+        {normal({expander: f, span: None})}\n+    fn builtin_expr_tt(f: syntax_expander_tt_) -> syntax_extension {\n+        expr_tt({expander: f, span: None})\n+    }\n+    fn builtin_item_tt(f: syntax_expander_tt_item_) -> syntax_extension {\n+        item_tt({expander: f, span: None})\n+    }\n+    let syntax_expanders = HashMap();\n+    syntax_expanders.insert(~\"macro\",\n+                            macro_defining(ext::simplext::add_new_extension));\n+    syntax_expanders.insert(~\"macro_rules\",\n+                            builtin_item_tt(\n+                                ext::tt::macro_rules::add_new_extension));\n+    syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(\n+        ~\"auto_serialize\",\n+        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n+    syntax_expanders.insert(\n+        ~\"auto_deserialize\",\n+        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n+    syntax_expanders.insert(\n+        ~\"auto_serialize2\",\n+        item_decorator(ext::auto_serialize2::expand_auto_serialize));\n+    syntax_expanders.insert(\n+        ~\"auto_deserialize2\",\n+        item_decorator(ext::auto_serialize2::expand_auto_deserialize));\n+    syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(~\"concat_idents\",\n+                            builtin(ext::concat_idents::expand_syntax_ext));\n+    syntax_expanders.insert(~\"ident_to_str\",\n+                            builtin(ext::ident_to_str::expand_syntax_ext));\n+    syntax_expanders.insert(~\"log_syntax\",\n+                            builtin_expr_tt(\n+                                ext::log_syntax::expand_syntax_ext));\n+    syntax_expanders.insert(~\"ast\",\n+                            builtin(ext::qquote::expand_ast));\n+    syntax_expanders.insert(~\"line\",\n+                            builtin(ext::source_util::expand_line));\n+    syntax_expanders.insert(~\"col\",\n+                            builtin(ext::source_util::expand_col));\n+    syntax_expanders.insert(~\"file\",\n+                            builtin(ext::source_util::expand_file));\n+    syntax_expanders.insert(~\"stringify\",\n+                            builtin(ext::source_util::expand_stringify));\n+    syntax_expanders.insert(~\"include\",\n+                            builtin(ext::source_util::expand_include));\n+    syntax_expanders.insert(~\"include_str\",\n+                            builtin(ext::source_util::expand_include_str));\n+    syntax_expanders.insert(~\"include_bin\",\n+                            builtin(ext::source_util::expand_include_bin));\n+    syntax_expanders.insert(~\"module_path\",\n+                            builtin(ext::source_util::expand_mod));\n+    syntax_expanders.insert(~\"proto\",\n+                            builtin_item_tt(ext::pipes::expand_proto));\n+    syntax_expanders.insert(\n+        ~\"trace_macros\",\n+        builtin_expr_tt(ext::trace_macros::expand_trace_macros));\n+    return syntax_expanders;\n+}\n \n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()"}, {"sha": "4a6bac9cd64b6cd071908e971fa95b6b033b602a", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d301dd3686ddd04845c1e9f5b9254aa3498a8a7b/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=d301dd3686ddd04845c1e9f5b9254aa3498a8a7b", "patch": "@@ -128,6 +128,7 @@ mod ext {\n     mod ident_to_str;\n     #[legacy_exports]\n     mod log_syntax;\n+    #[cfg(stage0)]\n     #[legacy_exports]\n     mod auto_serialize;\n     #[legacy_exports]"}, {"sha": "3a07faa75c5e591b7eb6fbf90ede7b64d55a1709", "filename": "src/test/run-pass/auto_serialize.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -1,208 +0,0 @@\n-// xfail-fast\n-#[legacy_modes];\n-\n-extern mod std;\n-\n-// These tests used to be separate files, but I wanted to refactor all\n-// the common code.\n-\n-use cmp::Eq;\n-use std::ebml;\n-use io::Writer;\n-use std::serialization::{serialize_uint, deserialize_uint};\n-\n-fn test_ser_and_deser<A:Eq>(a1: A,\n-                            expected: ~str,\n-                            ebml_ser_fn: fn(ebml::Writer, A),\n-                            ebml_deser_fn: fn(ebml::EbmlDeserializer) -> A,\n-                            io_ser_fn: fn(io::Writer, A)) {\n-\n-    // check the pretty printer:\n-    io_ser_fn(io::stdout(), a1);\n-    let s = io::with_str_writer(|w| io_ser_fn(w, a1) );\n-    debug!(\"s == %?\", s);\n-    assert s == expected;\n-\n-    // check the EBML serializer:\n-    let bytes = do io::with_bytes_writer |wr| {\n-        let w = ebml::Writer(wr);\n-        ebml_ser_fn(w, a1);\n-    };\n-    let d = ebml::Doc(@bytes);\n-    let a2 = ebml_deser_fn(ebml::ebml_deserializer(d));\n-    io::print(~\"\\na1 = \");\n-    io_ser_fn(io::stdout(), a1);\n-    io::print(~\"\\na2 = \");\n-    io_ser_fn(io::stdout(), a2);\n-    io::print(~\"\\n\");\n-    assert a1 == a2;\n-\n-}\n-\n-#[auto_serialize]\n-enum expr {\n-    val(uint),\n-    plus(@expr, @expr),\n-    minus(@expr, @expr)\n-}\n-\n-impl an_enum : cmp::Eq {\n-    pure fn eq(other: &an_enum) -> bool {\n-        self.v == (*other).v\n-    }\n-    pure fn ne(other: &an_enum) -> bool { !self.eq(other) }\n-}\n-\n-impl point : cmp::Eq {\n-    pure fn eq(other: &point) -> bool {\n-        self.x == (*other).x && self.y == (*other).y\n-    }\n-    pure fn ne(other: &point) -> bool { !self.eq(other) }\n-}\n-\n-impl<T:cmp::Eq> quark<T> : cmp::Eq {\n-    pure fn eq(other: &quark<T>) -> bool {\n-        match self {\n-          top(ref q) => match (*other) {\n-            top(ref r) => q == r,\n-            bottom(_) => false\n-          },\n-          bottom(ref q) => match (*other) {\n-            top(_) => false,\n-            bottom(ref r) => q == r\n-          }\n-        }\n-    }\n-    pure fn ne(other: &quark<T>) -> bool { !self.eq(other) }\n-}\n-\n-\n-impl c_like : cmp::Eq {\n-    pure fn eq(other: &c_like) -> bool {\n-        self as int == (*other) as int\n-    }\n-    pure fn ne(other: &c_like) -> bool { !self.eq(other) }\n-}\n-\n-impl expr : cmp::Eq {\n-    pure fn eq(other: &expr) -> bool {\n-        match self {\n-            val(e0a) => {\n-                match (*other) {\n-                    val(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            plus(e0a, e1a) => {\n-                match (*other) {\n-                    plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            minus(e0a, e1a) => {\n-                match (*other) {\n-                    minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(other: &expr) -> bool { !self.eq(other) }\n-}\n-\n-#[auto_serialize]\n-type spanned<T> = {lo: uint, hi: uint, node: T};\n-\n-impl<T:cmp::Eq> spanned<T> : cmp::Eq {\n-    pure fn eq(other: &spanned<T>) -> bool {\n-        self.lo == (*other).lo && self.hi == (*other).hi &&\n-        self.node.eq(&(*other).node)\n-    }\n-    pure fn ne(other: &spanned<T>) -> bool { !self.eq(other) }\n-}\n-\n-#[auto_serialize]\n-type spanned_uint = spanned<uint>;\n-\n-#[auto_serialize]\n-type some_rec = {v: uint_vec};\n-\n-#[auto_serialize]\n-enum an_enum = some_rec;\n-\n-#[auto_serialize]\n-type uint_vec = ~[uint];\n-\n-#[auto_serialize]\n-type point = {x: uint, y: uint};\n-\n-#[auto_serialize]\n-enum quark<T> {\n-    top(T),\n-    bottom(T)\n-}\n-\n-#[auto_serialize]\n-type uint_quark = quark<uint>;\n-\n-#[auto_serialize]\n-enum c_like { a, b, c }\n-\n-fn main() {\n-\n-    test_ser_and_deser(plus(@minus(@val(3u), @val(10u)),\n-                            @plus(@val(22u), @val(5u))),\n-                       ~\"plus(@minus(@val(3u), @val(10u)), \\\n-                        @plus(@val(22u), @val(5u)))\",\n-                       serialize_expr,\n-                       deserialize_expr,\n-                       serialize_expr);\n-\n-    test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n-                       ~\"{lo: 0u, hi: 5u, node: 22u}\",\n-                       serialize_spanned_uint,\n-                       deserialize_spanned_uint,\n-                       serialize_spanned_uint);\n-\n-    test_ser_and_deser(an_enum({v: ~[1u, 2u, 3u]}),\n-                       ~\"an_enum({v: [1u, 2u, 3u]})\",\n-                       serialize_an_enum,\n-                       deserialize_an_enum,\n-                       serialize_an_enum);\n-\n-    test_ser_and_deser({x: 3u, y: 5u},\n-                       ~\"{x: 3u, y: 5u}\",\n-                       serialize_point,\n-                       deserialize_point,\n-                       serialize_point);\n-\n-    test_ser_and_deser(~[1u, 2u, 3u],\n-                       ~\"[1u, 2u, 3u]\",\n-                       serialize_uint_vec,\n-                       deserialize_uint_vec,\n-                       serialize_uint_vec);\n-\n-    test_ser_and_deser(top(22u),\n-                       ~\"top(22u)\",\n-                       serialize_uint_quark,\n-                       deserialize_uint_quark,\n-                       serialize_uint_quark);\n-\n-    test_ser_and_deser(bottom(222u),\n-                       ~\"bottom(222u)\",\n-                       serialize_uint_quark,\n-                       deserialize_uint_quark,\n-                       serialize_uint_quark);\n-\n-    test_ser_and_deser(a,\n-                       ~\"a\",\n-                       serialize_c_like,\n-                       deserialize_c_like,\n-                       serialize_c_like);\n-\n-    test_ser_and_deser(b,\n-                       ~\"b\",\n-                       serialize_c_like,\n-                       deserialize_c_like,\n-                       serialize_c_like);\n-}"}]}