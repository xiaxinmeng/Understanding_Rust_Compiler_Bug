{"sha": "6c6ad229a3d52f9f059086e1b670aa4d75566094", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNmFkMjI5YTNkNTJmOWYwNTkwODZlMWI2NzBhYTRkNzU1NjYwOTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-01T17:46:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-01T17:50:19Z"}, "message": "break up borrowck into modules and begin to document how it works", "tree": {"sha": "b7d67ef164bf88be8c6bb87d5c8826fd50a52e36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d67ef164bf88be8c6bb87d5c8826fd50a52e36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c6ad229a3d52f9f059086e1b670aa4d75566094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6ad229a3d52f9f059086e1b670aa4d75566094", "html_url": "https://github.com/rust-lang/rust/commit/6c6ad229a3d52f9f059086e1b670aa4d75566094", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c6ad229a3d52f9f059086e1b670aa4d75566094/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c622a5b1278484f02d49cb37cfb7005239f30a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c622a5b1278484f02d49cb37cfb7005239f30a4", "html_url": "https://github.com/rust-lang/rust/commit/3c622a5b1278484f02d49cb37cfb7005239f30a4"}], "stats": {"total": 3304, "additions": 1744, "deletions": 1560}, "files": [{"sha": "babee32aeb8ab29daf304f8bcf0cd1a182064976", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 195, "deletions": 1559, "changes": 1754, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -1,11 +1,160 @@\n+#[doc = \"\n+\n+# Borrow check\n+\n+This pass is in job of enforcing *memory safety* and *purity*.  As\n+memory safety is by far the more complex topic, I'll focus on that in\n+this description, but purity will be covered later on. In the context\n+of Rust, memory safety means three basic things:\n+\n+- no writes to immutable memory;\n+- all pointers point to non-freed memory;\n+- all pointers point to memory of the same type as the pointer.\n+\n+The last point might seem confusing: after all, for the most part,\n+this condition is guaranteed by the type check.  However, there are\n+two cases where the type check effectively delegates to borrow check.\n+\n+The first case has to do with enums.  If there is a pointer to the\n+interior of an enum, and the enum is in a mutable location (such as a\n+local variable or field declared to be mutable), it is possible that\n+the user will overwrite the enum with a new value of a different\n+variant, and thus effectively change the type of the memory that the\n+pointer is pointing at.\n+\n+The second case has to do with mutability.  Basically, the type\n+checker has only a limited understanding of mutability.  It will allow\n+(for example) the user to get an immutable pointer with the address of\n+a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n+pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n+are in fact intentional; they allow the user to temporarily treat a\n+mutable value as immutable.  It is up to the borrow check to guarantee\n+that the value in question is not in fact mutated during the lifetime\n+`r` of the reference.\n+\n+# Summary of the safety check\n+\n+In order to enforce mutability, the borrow check has three tricks up\n+its sleeve.\n+\n+First, data which is uniquely tied to the current stack frame (that'll\n+be defined shortly) is tracked very precisely.  This means that, for\n+example, if an immutable pointer to a mutable local variable is\n+created, the borrowck will simply check for assignments to that\n+particular local variable: no other memory is affected.\n+\n+Second, if the data is not uniquely tied to the stack frame, it may\n+still be possible to ensure its validity by rooting garbage collected\n+pointers at runtime.  For example, if there is a mutable local\n+variable `x` of type `@T`, and its contents are borrowed with an\n+expression like `&*x`, then the value of `x` will be rooted (today,\n+that means its ref count will be temporary increased) for the lifetime\n+of the reference that is created.  This means that the pointer remains\n+valid even if `x` is reassigned.\n+\n+Finally, if neither of these two solutions are applicable, then we\n+require that all operations within the scope of the reference be\n+*pure*.  A pure operation is effectively one that does not write to\n+any aliasable memory.  This means that it is still possible to write\n+to local variables or other data that is uniquely tied to the stack\n+frame (there's that term again; formal definition still pending) but\n+not to data reached via a `&T` or `@T` pointer.  Such writes could\n+possibly have the side-effect of causing the data which must remain\n+valid to be overwritten.\n+\n+# Possible future directions\n+\n+There are numerous ways that the `borrowck` could be strengthened, but\n+these are the two most likely:\n+\n+- flow-sensitivity: we do not currently consider flow at all but only\n+  block-scoping.  This means that innocent code like the following is\n+  rejected:\n+\n+      let mut x: int;\n+      ...\n+      x = 5;\n+      let y: &int = &x; // immutable ptr created\n+      ...\n+\n+  The reason is that the scope of the pointer `y` is the entire\n+  enclosing block, and the assignment `x = 5` occurs within that\n+  block.  The analysis is not smart enough to see that `x = 5` always\n+  happens before the immutable pointer is created.  This is relatively\n+  easy to fix and will surely be fixed at some point.\n+\n+- finer-grained purity checks: currently, our fallback for\n+  guaranteeing random references into mutable, aliasable memory is to\n+  require *total purity*.  This is rather strong.  We could use local\n+  type-based alias analysis to distinguish writes that could not\n+  possibly invalid the references which must be guaranteed.  This\n+  would only work within the function boundaries; function calls would\n+  still require total purity.  This seems less likely to be\n+  implemented in the short term as it would make the code\n+  significantly more complex; there is currently no code to analyze\n+  the types and determine the possible impacts of a write.\n+\n+# Terminology\n+\n+A **loan** is .\n+\n+# How the code works\n+\n+The borrow check code is divided into several major modules, each of\n+which is documented in its own file.\n+\n+The `gather_loans` and `check_loans` are the two major passes of the\n+analysis.  The `gather_loans` pass runs over the IR once to determine\n+what memory must remain valid and for how long.  Its name is a bit of\n+a misnomer; it does in fact gather up the set of loans which are\n+granted, but it also determines when @T pointers must be rooted and\n+for which scopes purity must be required.\n+\n+The `check_loans` pass walks the IR and examines the loans and purity\n+requirements computed in `gather_loans`.  It checks to ensure that (a)\n+the conditions of all loans are honored; (b) no contradictory loans\n+were granted (for example, loaning out the same memory as mutable and\n+immutable simultaneously); and (c) any purity requirements are\n+honored.\n+\n+The remaining modules are helper modules used by `gather_loans` and\n+`check_loans`:\n+\n+- `categorization` has the job of analyzing an expression to determine\n+  what kind of memory is used in evaluating it (for example, where\n+  dereferences occur and what kind of pointer is dereferenced; whether\n+  the memory is mutable; etc)\n+- `loan` determines when data uniquely tied to the stack frame can be\n+  loaned out.\n+- `preserve` determines what actions (if any) must be taken to preserve\n+  aliasable data.  This is the code which decides when to root\n+  an @T pointer or to require purity.\n+\n+# Maps that are created\n+\n+Borrowck results in two maps.\n+\n+- `root_map`: identifies those expressions or patterns whose result\n+  needs to be rooted.  Conceptually the root_map maps from an\n+  expression or pattern node to a `node_id` identifying the scope for\n+  which the expression must be rooted (this `node_id` should identify\n+  a block or call).  The actual key to the map is not an expression id,\n+  however, but a `root_map_key`, which combines an expression id with a\n+  deref count and is used to cope with auto-deref.\n+\n+- `mutbl_map`: identifies those local variables which are modified or\n+  moved. This is used by trans to guarantee that such variables are\n+  given a memory location and not used as immediates.\n+\n+\"];\n+\n import syntax::ast;\n import syntax::ast::{m_mutbl, m_imm, m_const};\n import syntax::visit;\n import syntax::ast_util;\n import syntax::ast_map;\n import syntax::codemap::span;\n import util::ppaux::{ty_to_str, region_to_str};\n-import driver::session::session;\n import std::map::{int_hash, hashmap, set};\n import std::list;\n import std::list::{list, cons, nil};\n@@ -14,6 +163,7 @@ import syntax::print::pprust;\n import util::common::indenter;\n import ast_util::op_expr_callee_id;\n import ty::to_str;\n+import driver::session::session;\n \n export check_crate, root_map, mutbl_map;\n \n@@ -37,17 +187,15 @@ fn check_crate(tcx: ty::ctxt,\n                  mutbl_map: int_hash()};\n \n     let req_maps = if msg_level > 0u {\n-        gather_loans(bccx, crate)\n+        gather_loans::gather_loans(bccx, crate)\n     } else {\n         {req_loan_map: int_hash(),\n          pure_map: int_hash()}\n     };\n-    check_loans(bccx, req_maps, crate);\n+    check_loans::check_loans(bccx, req_maps, crate);\n     ret (bccx.root_map, bccx.mutbl_map);\n }\n \n-const TREAT_CONST_AS_IMM: bool = true;\n-\n // ----------------------------------------------------------------------\n // Type definitions\n \n@@ -57,9 +205,9 @@ type borrowck_ctxt = @{tcx: ty::ctxt,\n                        root_map: root_map,\n                        mutbl_map: mutbl_map};\n \n-// a map mapping id's of expressions of task-local type (@T, []/@, etc) where\n-// the box needs to be kept live to the id of the scope for which they must\n-// stay live.\n+// a map mapping id's of expressions of gc'd type (@T, []/@, etc) where\n+// the box needs to be kept live to the id of the scope for which they\n+// must stay live.\n type root_map = hashmap<root_map_key, ast::node_id>;\n \n // the keys to the root map combine the `id` of the expression with\n@@ -73,6 +221,7 @@ type root_map_key = {id: ast::node_id, derefs: uint};\n // this is used in trans for optimization purposes.\n type mutbl_map = std::map::hashmap<ast::node_id, ()>;\n \n+// Errors that can occur\"]\n enum bckerr_code {\n     err_mut_uniq,\n     err_mut_variant,\n@@ -81,8 +230,11 @@ enum bckerr_code {\n               ast::mutability)\n }\n \n+// Combination of an error code and the categorization of the expression\n+// that caused it\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n+// shorthand for something that fails with `bckerr` or succeeds with `T`\n type bckres<T> = result<T, bckerr>;\n \n enum categorization {\n@@ -139,13 +291,20 @@ enum loan_path {\n // a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n+// maps computed by `gather_loans` that are then used by `check_loans`\n+type req_maps = {\n+    req_loan_map: hashmap<ast::node_id, @mut [@const [loan]]>,\n+    pure_map: hashmap<ast::node_id, bckerr>\n+};\n+\n fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n     let old_save_and_restore_t = save_and_restore_t;\n     let u <- f();\n     save_and_restore_t = old_save_and_restore_t;\n     ret u;\n }\n \n+#[doc = \"Creates and returns a new root_map\"]\n fn root_map() -> root_map {\n     ret hashmap(root_map_key_hash, root_map_key_eq);\n \n@@ -158,942 +317,8 @@ fn root_map() -> root_map {\n     }\n }\n \n-// ----------------------------------------------------------------------\n-// Gathering loans\n-//\n-// The borrow check proceeds in two phases. In phase one, we gather the full\n-// set of loans that are required at any point.  These are sorted according to\n-// their associated scopes.  In phase two, checking loans, we will then make\n-// sure that all of these loans are honored.\n-\n-type req_maps = {\n-    req_loan_map: hashmap<ast::node_id, @mut [@const [loan]]>,\n-    pure_map: hashmap<ast::node_id, bckerr>\n-};\n-\n-enum gather_loan_ctxt = @{bccx: borrowck_ctxt, req_maps: req_maps};\n-\n-fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n-    let glcx = gather_loan_ctxt(@{bccx: bccx,\n-                                  req_maps: {req_loan_map: int_hash(),\n-                                             pure_map: int_hash()}});\n-    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr\n-                           with *visit::default_visitor()});\n-    visit::visit_crate(*crate, glcx, v);\n-    ret glcx.req_maps;\n-}\n-\n-fn req_loans_in_expr(ex: @ast::expr,\n-                     &&self: gather_loan_ctxt,\n-                     vt: visit::vt<gather_loan_ctxt>) {\n-    let bccx = self.bccx;\n-    let tcx = bccx.tcx;\n-\n-    // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.borrowings.find(ex.id).each { |borrow|\n-        let cmt = self.bccx.cat_borrow_of_expr(ex);\n-        let scope_r = ty::re_scope(borrow.scope_id);\n-        self.guarantee_valid(cmt, borrow.mutbl, scope_r);\n-    }\n-\n-    // Special checks for various kinds of expressions:\n-    alt ex.node {\n-      ast::expr_addr_of(mutbl, base) {\n-        let base_cmt = self.bccx.cat_expr(base);\n-\n-        // make sure that the thing we are pointing out stays valid\n-        // for the lifetime `scope_r` of the resulting ptr:\n-        let scope_r =\n-            alt check ty::get(tcx.ty(ex)).struct {\n-              ty::ty_rptr(r, _) { r }\n-            };\n-        self.guarantee_valid(base_cmt, mutbl, scope_r);\n-      }\n-\n-      ast::expr_call(f, args, _) {\n-        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n-        let scope_r = ty::re_scope(ex.id);\n-        vec::iter2(args, arg_tys) { |arg, arg_ty|\n-            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_mutbl_ref {\n-                let arg_cmt = self.bccx.cat_expr(arg);\n-                self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n-              }\n-              ast::by_ref {\n-                let arg_cmt = self.bccx.cat_expr(arg);\n-                if TREAT_CONST_AS_IMM {\n-                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-                } else {\n-                    self.guarantee_valid(arg_cmt, m_const, scope_r);\n-                }\n-              }\n-              ast::by_move | ast::by_copy | ast::by_val {}\n-            }\n-        }\n-      }\n-\n-      ast::expr_alt(ex_v, arms, _) {\n-        let cmt = self.bccx.cat_expr(ex_v);\n-        for arms.each { |arm|\n-            for arm.pats.each { |pat|\n-                self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n-            }\n-        }\n-      }\n-\n-      _ { /*ok*/ }\n-    }\n-\n-    // Check any contained expressions:\n-    visit::visit_expr(ex, self, vt);\n-}\n-\n-impl methods for gather_loan_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n-\n-    // guarantees that addr_of(cmt) will be valid for the duration of\n-    // `static_scope_r`, or reports an error.  This may entail taking\n-    // out loans, which will be added to the `req_loan_map`.  This can\n-    // also entail \"rooting\" GC'd pointers, which means ensuring\n-    // dynamically that they are not freed.\n-    fn guarantee_valid(cmt: cmt,\n-                       req_mutbl: ast::mutability,\n-                       scope_r: ty::region) {\n-\n-        #debug[\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl),\n-               region_to_str(self.tcx(), scope_r)];\n-        let _i = indenter();\n-\n-        alt cmt.lp {\n-          // If this expression is a loanable path, we MUST take out a loan.\n-          // This is somewhat non-obvious.  You might think, for example, that\n-          // if we have an immutable local variable `x` whose value is being\n-          // borrowed, we could rely on `x` not to change.  This is not so,\n-          // however, because even immutable locals can be moved.  So we take\n-          // out a loan on `x`, guaranteeing that it remains immutable for the\n-          // duration of the reference: if there is an attempt to move it\n-          // within that scope, the loan will be detected and an error will be\n-          // reported.\n-          some(_) {\n-            alt scope_r {\n-              ty::re_scope(scope_id) {\n-                let loans = self.bccx.loan(cmt, req_mutbl);\n-                self.add_loans(scope_id, loans);\n-              }\n-              _ {\n-                self.bccx.span_err(\n-                    cmt.span,\n-                    #fmt[\"cannot guarantee the stability \\\n-                          of this expression for the entirety of \\\n-                          its lifetime, %s\",\n-                         region_to_str(self.tcx(), scope_r)]);\n-              }\n-            }\n-          }\n-\n-          // The path is not loanable: in that case, we must try and preserve\n-          // it dynamically (or see that it is preserved by virtue of being\n-          // rooted in some immutable path)\n-          none {\n-            let opt_scope_id = alt scope_r {\n-              ty::re_scope(scope_id) { some(scope_id) }\n-              _ { none }\n-            };\n-\n-            let result = {\n-                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n-                    self.bccx.preserve(cmt, opt_scope_id)\n-                }\n-            };\n-\n-            alt result {\n-              ok(()) {\n-                // we were able guarantee the validity of the ptr,\n-                // perhaps by rooting or because it is immutably\n-                // rooted.  good.\n-              }\n-              err(e) {\n-                // not able to guarantee the validity of the ptr.\n-                // rather than report an error, presuming that the\n-                // borrow is for a limited scope, we'll make one last\n-                // ditch effort and require that the scope where the\n-                // borrow occurs be pure.\n-                alt opt_scope_id {\n-                  some(scope_id) {\n-                    self.req_maps.pure_map.insert(scope_id, e);\n-                  }\n-                  none {\n-                    // otherwise, fine, I give up.\n-                    self.bccx.report(e);\n-                  }\n-                }\n-              }\n-            }\n-          }\n-        }\n-    }\n-\n-    // Check that the pat `cmt` is compatible with the required\n-    // mutability, presuming that it can be preserved to stay alive\n-    // long enough.\n-    //\n-    // For example, if you have an expression like `&x.f` where `x`\n-    // has type `@mut{f:int}`, this check might fail because `&x.f`\n-    // reqires an immutable pointer, but `f` lives in (aliased)\n-    // mutable memory.\n-    fn check_mutbl(req_mutbl: ast::mutability,\n-                   cmt: cmt) -> bckres<()> {\n-        alt (req_mutbl, cmt.mutbl) {\n-          (m_const, _) |\n-          (m_imm, m_imm) |\n-          (m_mutbl, m_mutbl) {\n-            ok(())\n-          }\n-\n-          (_, m_const) |\n-          (m_imm, m_mutbl) |\n-          (m_mutbl, m_imm) {\n-            err({cmt: cmt,\n-                 code: err_mutbl(req_mutbl, cmt.mutbl)})\n-          }\n-        }\n-    }\n-\n-    fn add_loans(scope_id: ast::node_id, loans: @const [loan]) {\n-        alt self.req_maps.req_loan_map.find(scope_id) {\n-          some(l) {\n-            *l += [loans];\n-          }\n-          none {\n-            self.req_maps.req_loan_map.insert(scope_id, @mut [loans]);\n-          }\n-        }\n-    }\n-\n-    fn gather_pat(cmt: cmt, pat: @ast::pat,\n-                  arm_id: ast::node_id, alt_id: ast::node_id) {\n-\n-        // Here, `cmt` is the categorization for the value being\n-        // matched and pat is the pattern it is being matched against.\n-        //\n-        // In general, the way that this works is that we walk down\n-        // the pattern, constructing a cmt that represents the path\n-        // that will be taken to reach the value being matched.\n-        //\n-        // When we encounter named bindings, we take the cmt that has\n-        // been built up and pass it off to guarantee_valid() so that\n-        // we can be sure that the binding will remain valid for the\n-        // duration of the arm.\n-        //\n-        // The correspondence between the id in the cmt and which\n-        // pattern is being referred to is somewhat...subtle.  In\n-        // general, the id of the cmt is the id of the node that\n-        // produces the value.  For patterns, that's actually the\n-        // *subpattern*, generally speaking.\n-        //\n-        // To see what I mean about ids etc, consider:\n-        //\n-        //     let x = @@3;\n-        //     alt x {\n-        //       @@y { ... }\n-        //     }\n-        //\n-        // Here the cmt for `y` would be something like\n-        //\n-        //     local(x)->@->@\n-        //\n-        // where the id of `local(x)` is the id of the `x` that appears\n-        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n-        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n-\n-        #debug[\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n-               pat.id, pprust::pat_to_str(pat),\n-               self.bccx.cmt_to_repr(cmt), arm_id, alt_id];\n-        let _i = indenter();\n-\n-        let tcx = self.tcx();\n-        alt pat.node {\n-          ast::pat_wild {\n-            // _\n-          }\n-\n-          ast::pat_enum(_, none) {\n-            // variant(*)\n-          }\n-          ast::pat_enum(_, some(subpats)) {\n-            // variant(x, y, z)\n-            for subpats.each { |subpat|\n-                let subcmt = self.bccx.cat_variant(subpat, cmt);\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_ident(_, none) if self.pat_is_variant(pat) {\n-            // nullary variant\n-            #debug[\"nullary variant\"];\n-          }\n-          ast::pat_ident(id, o_pat) {\n-            // x or x @ p --- `x` must remain valid for the scope of the alt\n-            #debug[\"defines identifier %s\", pprust::path_to_str(id)];\n-\n-            // Note: there is a discussion of the function of\n-            // cat_discr in the method preserve():\n-            let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n-            let arm_scope = ty::re_scope(arm_id);\n-            self.guarantee_valid(cmt1, m_const, arm_scope);\n-\n-            for o_pat.each { |p|\n-                self.gather_pat(cmt, p, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_rec(field_pats, _) {\n-            // {f1: p1, ..., fN: pN}\n-            for field_pats.each { |fp|\n-                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n-                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_tup(subpats) {\n-            // (p1, ..., pN)\n-            for subpats.each { |subpat|\n-                let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n-            // @p1, ~p1\n-            alt self.bccx.cat_deref(subpat, cmt, 0u, true) {\n-              some(subcmt) {\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n-              }\n-              none {\n-                tcx.sess.span_bug(pat.span, \"Non derefable type\");\n-              }\n-            }\n-          }\n-\n-          ast::pat_lit(_) | ast::pat_range(_, _) { /*always ok*/ }\n-        }\n-    }\n-\n-    fn pat_is_variant(pat: @ast::pat) -> bool {\n-        pat_util::pat_is_variant(self.bccx.tcx.def_map, pat)\n-    }\n-}\n-\n-// ----------------------------------------------------------------------\n-// Checking loans\n-//\n-// Phase 2 of check: we walk down the tree and check that:\n-// 1. assignments are always made to mutable locations;\n-// 2. loans made in overlapping scopes do not conflict\n-// 3. assignments do not affect things loaned out as immutable\n-// 4. moves to dnot affect things loaned out in any way\n-\n-enum check_loan_ctxt = @{\n-    bccx: borrowck_ctxt,\n-    req_maps: req_maps,\n-\n-    reported: hashmap<ast::node_id, ()>,\n-\n-    // Keep track of whether we're inside a ctor, so as to\n-    // allow mutating immutable fields in the same class if\n-    // we are in a ctor, we track the self id\n-    mut in_ctor: bool,\n-    mut declared_purity: ast::purity,\n-    mut fn_args: [ast::node_id]\n-};\n-\n-// if we are enforcing purity, why are we doing so?\n-enum purity_cause {\n-    // enforcing purity because fn was declared pure:\n-    pc_pure_fn,\n-\n-    // enforce purity because we need to guarantee the\n-    // validity of some alias; `bckerr` describes the\n-    // reason we needed to enforce purity.\n-    pc_cmt(bckerr)\n-}\n-\n-fn check_loans(bccx: borrowck_ctxt,\n-               req_maps: req_maps,\n-               crate: @ast::crate) {\n-    let clcx = check_loan_ctxt(@{bccx: bccx,\n-                                 req_maps: req_maps,\n-                                 reported: int_hash(),\n-                                 mut in_ctor: false,\n-                                 mut declared_purity: ast::impure_fn,\n-                                 mut fn_args: []});\n-    let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n-                            visit_block: check_loans_in_block,\n-                            visit_fn: check_loans_in_fn\n-                            with *visit::default_visitor()});\n-    visit::visit_crate(*crate, clcx, vt);\n-}\n-\n-enum assignment_type {\n-    at_straight_up,\n-    at_swap,\n-    at_mutbl_ref,\n-}\n-\n-impl methods for assignment_type {\n-    fn checked_by_liveness() -> bool {\n-        // the liveness pass guarantees that immutable local variables\n-        // are only assigned once; but it doesn't consider &mut\n-        alt self {\n-          at_straight_up {true}\n-          at_swap {true}\n-          at_mutbl_ref {false}\n-        }\n-    }\n-    fn ing_form(desc: str) -> str {\n-        alt self {\n-          at_straight_up { \"assigning to \" + desc }\n-          at_swap { \"swapping to and from \" + desc }\n-          at_mutbl_ref { \"taking mut reference to \" + desc }\n-        }\n-    }\n-}\n-\n-impl methods for check_loan_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n-\n-    fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n-        let default_purity = alt self.declared_purity {\n-          // an unsafe declaration overrides all\n-          ast::unsafe_fn { ret none; }\n-\n-          // otherwise, remember what was declared as the\n-          // default, but we must scan for requirements\n-          // imposed by the borrow check\n-          ast::pure_fn { some(pc_pure_fn) }\n-          ast::crust_fn | ast::impure_fn { none }\n-        };\n-\n-        // scan to see if this scope or any enclosing scope requires\n-        // purity.  if so, that overrides the declaration.\n-\n-        let mut scope_id = scope_id;\n-        let region_map = self.tcx().region_map;\n-        let pure_map = self.req_maps.pure_map;\n-        loop {\n-            alt pure_map.find(scope_id) {\n-              none {}\n-              some(e) {ret some(pc_cmt(e));}\n-            }\n-\n-            alt region_map.find(scope_id) {\n-              none { ret default_purity; }\n-              some(next_scope_id) { scope_id = next_scope_id; }\n-            }\n-        }\n-    }\n-\n-    fn walk_loans(scope_id: ast::node_id,\n-                  f: fn(loan) -> bool) {\n-        let mut scope_id = scope_id;\n-        let region_map = self.tcx().region_map;\n-        let req_loan_map = self.req_maps.req_loan_map;\n-\n-        loop {\n-            for req_loan_map.find(scope_id).each { |loanss|\n-                for (*loanss).each { |loans|\n-                    for (*loans).each { |loan|\n-                        if !f(loan) { ret; }\n-                    }\n-                }\n-            }\n-\n-            alt region_map.find(scope_id) {\n-              none { ret; }\n-              some(next_scope_id) { scope_id = next_scope_id; }\n-            }\n-        }\n-    }\n-\n-    fn walk_loans_of(scope_id: ast::node_id,\n-                     lp: @loan_path,\n-                     f: fn(loan) -> bool) {\n-        for self.walk_loans(scope_id) { |loan|\n-            if loan.lp == lp {\n-                if !f(loan) { ret; }\n-            }\n-        }\n-    }\n-\n-    // when we are in a pure context, we check each call to ensure\n-    // that the function which is invoked is itself pure.\n-    fn check_pure_callee_or_arg(pc: purity_cause, expr: @ast::expr) {\n-        let tcx = self.tcx();\n-\n-        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%s, ty=%s)\",\n-               pc, pprust::expr_to_str(expr),\n-               ty_to_str(self.tcx(), tcx.ty(expr))];\n-\n-        // Purity rules: an expr B is a legal callee or argument to a\n-        // call within a pure function A if at least one of the\n-        // following holds:\n-        //\n-        // (a) A was declared pure and B is one of its arguments;\n-        // (b) B is a stack closure;\n-        // (c) B is a pure fn;\n-        // (d) B is not a fn.\n-\n-        alt expr.node {\n-          ast::expr_path(_) if pc == pc_pure_fn {\n-            let def = self.tcx().def_map.get(expr.id);\n-            let did = ast_util::def_id_of_def(def);\n-            let is_fn_arg =\n-                did.crate == ast::local_crate &&\n-                self.fn_args.contains(did.node);\n-            if is_fn_arg { ret; } // case (a) above\n-          }\n-          ast::expr_fn_block(*) | ast::expr_fn(*) | ast::expr_loop_body(*) {\n-            if self.is_stack_closure(expr.id) { ret; } // case (b) above\n-          }\n-          _ {}\n-        }\n-\n-        let expr_ty = tcx.ty(expr);\n-        alt ty::get(expr_ty).struct {\n-          ty::ty_fn(fn_ty) {\n-            alt fn_ty.purity {\n-              ast::pure_fn { ret; } // case (c) above\n-              ast::impure_fn | ast::unsafe_fn | ast::crust_fn {\n-                self.report_purity_error(\n-                    pc, expr.span,\n-                    #fmt[\"access to %s function\",\n-                         pprust::purity_to_str(fn_ty.purity)]);\n-              }\n-            }\n-          }\n-          _ { ret; } // case (d) above\n-        }\n-    }\n-\n-    // True if the expression with the given `id` is a stack closure.\n-    // The expression must be an expr_fn(*) or expr_fn_block(*)\n-    fn is_stack_closure(id: ast::node_id) -> bool {\n-        let fn_ty = ty::node_id_to_type(self.tcx(), id);\n-        let proto = ty::ty_fn_proto(fn_ty);\n-        alt proto {\n-          ast::proto_block | ast::proto_any {true}\n-          ast::proto_bare | ast::proto_uniq | ast::proto_box {false}\n-        }\n-    }\n-\n-    fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n-        ret alt expr.node {\n-          ast::expr_path(_) {\n-            let def = self.tcx().def_map.get(expr.id);\n-            let did = ast_util::def_id_of_def(def);\n-            did.crate == ast::local_crate && self.fn_args.contains(did.node)\n-          }\n-          ast::expr_fn_block(*) | ast::expr_fn(*) {\n-            self.is_stack_closure(expr.id)\n-          }\n-          _ {false}\n-        };\n-    }\n-\n-    fn check_for_conflicting_loans(scope_id: ast::node_id) {\n-        let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n-            none { ret; }\n-            some(loanss) { loanss }\n-        };\n-\n-        let par_scope_id = self.tcx().region_map.get(scope_id);\n-        for self.walk_loans(par_scope_id) { |old_loan|\n-            for (*new_loanss).each { |new_loans|\n-                for (*new_loans).each { |new_loan|\n-                    if old_loan.lp != new_loan.lp { cont; }\n-                    alt (old_loan.mutbl, new_loan.mutbl) {\n-                      (m_const, _) | (_, m_const) |\n-                      (m_mutbl, m_mutbl) | (m_imm, m_imm) {\n-                        /*ok*/\n-                      }\n-\n-                      (m_mutbl, m_imm) | (m_imm, m_mutbl) {\n-                        self.bccx.span_err(\n-                            new_loan.cmt.span,\n-                            #fmt[\"loan of %s as %s \\\n-                                  conflicts with prior loan\",\n-                                 self.bccx.cmt_to_str(new_loan.cmt),\n-                                 self.bccx.mut_to_str(new_loan.mutbl)]);\n-                        self.bccx.span_note(\n-                            old_loan.cmt.span,\n-                            #fmt[\"prior loan as %s granted here\",\n-                                 self.bccx.mut_to_str(old_loan.mutbl)]);\n-                      }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn is_local_variable(cmt: cmt) -> bool {\n-        alt cmt.cat {\n-          cat_local(_) {true}\n-          _ {false}\n-        }\n-    }\n-\n-    fn is_self_field(cmt: cmt) -> bool {\n-        alt cmt.cat {\n-          cat_comp(cmt_base, comp_field(_)) {\n-            alt cmt_base.cat {\n-              cat_special(sk_self) { true }\n-              _ { false }\n-            }\n-          }\n-          _ { false }\n-        }\n-    }\n-\n-    fn check_assignment(at: assignment_type, ex: @ast::expr) {\n-        let cmt = self.bccx.cat_expr(ex);\n-\n-        #debug[\"check_assignment(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)];\n-\n-        if self.in_ctor && self.is_self_field(cmt)\n-            && at.checked_by_liveness() {\n-            // assigning to self.foo in a ctor is always allowed.\n-        } else if self.is_local_variable(cmt) && at.checked_by_liveness() {\n-            // liveness guarantees that immutable local variables\n-            // are only assigned once\n-        } else {\n-            alt cmt.mutbl {\n-              m_mutbl { /*ok*/ }\n-              m_const | m_imm {\n-                self.bccx.span_err(\n-                    ex.span,\n-                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n-                ret;\n-              }\n-            }\n-        }\n-\n-        // if this is a pure function, only loan-able state can be\n-        // assigned, because it is uniquely tied to this function and\n-        // is not visible from the outside\n-        alt self.purity(ex.id) {\n-          none {}\n-          some(pc) {\n-            if cmt.lp.is_none() {\n-                self.report_purity_error(\n-                    pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n-            }\n-          }\n-        }\n-\n-        // check for a conflicting loan as well, except in the case of\n-        // taking a mutable ref.  that will create a loan of its own\n-        // which will be checked for compat separately in\n-        // check_for_conflicting_loans()\n-        if at != at_mutbl_ref {\n-            let lp = alt cmt.lp {\n-              none { ret; }\n-              some(lp) { lp }\n-            };\n-            for self.walk_loans_of(ex.id, lp) { |loan|\n-                alt loan.mutbl {\n-                  m_mutbl | m_const { /*ok*/ }\n-                  m_imm {\n-                    self.bccx.span_err(\n-                        ex.span,\n-                        #fmt[\"%s prohibited due to outstanding loan\",\n-                             at.ing_form(self.bccx.cmt_to_str(cmt))]);\n-                    self.bccx.span_note(\n-                        loan.cmt.span,\n-                        #fmt[\"loan of %s granted here\",\n-                             self.bccx.cmt_to_str(loan.cmt)]);\n-                    ret;\n-                  }\n-                }\n-            }\n-        }\n-\n-        self.bccx.add_to_mutbl_map(cmt);\n-    }\n-\n-    fn report_purity_error(pc: purity_cause, sp: span, msg: str) {\n-        alt pc {\n-          pc_pure_fn {\n-            self.tcx().sess.span_err(\n-                sp,\n-                #fmt[\"%s prohibited in pure context\", msg]);\n-          }\n-          pc_cmt(e) {\n-            if self.reported.insert(e.cmt.id, ()) {\n-                self.tcx().sess.span_err(\n-                    e.cmt.span,\n-                    #fmt[\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_code_to_str(e.code)]);\n-                self.tcx().sess.span_note(\n-                    sp,\n-                    #fmt[\"impure due to %s\", msg]);\n-            }\n-          }\n-        }\n-    }\n-\n-    fn check_move_out(ex: @ast::expr) {\n-        let cmt = self.bccx.cat_expr(ex);\n-        self.check_move_out_from_cmt(cmt);\n-    }\n-\n-    fn check_move_out_from_cmt(cmt: cmt) {\n-        #debug[\"check_move_out_from_cmt(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)];\n-\n-        alt cmt.cat {\n-          // Rvalues, locals, and arguments can be moved:\n-          cat_rvalue | cat_local(_) | cat_arg(_) { }\n-\n-          // We allow moving out of static items because the old code\n-          // did.  This seems consistent with permitting moves out of\n-          // rvalues, I guess.\n-          cat_special(sk_static_item) { }\n-\n-          // Nothing else.\n-          _ {\n-            self.bccx.span_err(\n-                cmt.span,\n-                #fmt[\"moving out of %s\", self.bccx.cmt_to_str(cmt)]);\n-            ret;\n-          }\n-        }\n-\n-        self.bccx.add_to_mutbl_map(cmt);\n-\n-        // check for a conflicting loan:\n-        let lp = alt cmt.lp {\n-          none { ret; }\n-          some(lp) { lp }\n-        };\n-        for self.walk_loans_of(cmt.id, lp) { |loan|\n-            self.bccx.span_err(\n-                cmt.span,\n-                #fmt[\"moving out of %s prohibited due to outstanding loan\",\n-                     self.bccx.cmt_to_str(cmt)]);\n-            self.bccx.span_note(\n-                loan.cmt.span,\n-                #fmt[\"loan of %s granted here\",\n-                     self.bccx.cmt_to_str(loan.cmt)]);\n-            ret;\n-        }\n-    }\n-}\n-\n-fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n-                     sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n-                     visitor: visit::vt<check_loan_ctxt>) {\n-\n-    #debug[\"purity on entry=%?\", self.declared_purity];\n-    save_and_restore(self.in_ctor) {||\n-        save_and_restore(self.declared_purity) {||\n-            save_and_restore(self.fn_args) {||\n-                let is_stack_closure = self.is_stack_closure(id);\n-\n-                // In principle, we could consider fk_anon(*) or\n-                // fk_fn_block(*) to be in a ctor, I suppose, but the\n-                // purpose of the in_ctor flag is to allow modifications\n-                // of otherwise immutable fields and typestate wouldn't be\n-                // able to \"see\" into those functions anyway, so it\n-                // wouldn't be very helpful.\n-                alt fk {\n-                  visit::fk_ctor(*) {\n-                    self.in_ctor = true;\n-                    self.declared_purity = decl.purity;\n-                    self.fn_args = decl.inputs.map({|i| i.id});\n-                  }\n-                  visit::fk_anon(*) |\n-                  visit::fk_fn_block(*) if is_stack_closure {\n-                    self.in_ctor = false;\n-                    // inherits the purity/fn_args from enclosing ctxt\n-                  }\n-                  visit::fk_anon(*) | visit::fk_fn_block(*) |\n-                  visit::fk_method(*) | visit::fk_item_fn(*) |\n-                  visit::fk_res(*) | visit::fk_dtor(*) {\n-                    self.in_ctor = false;\n-                    self.declared_purity = decl.purity;\n-                    self.fn_args = decl.inputs.map({|i| i.id});\n-                  }\n-                }\n-\n-                visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n-            }\n-        }\n-    }\n-    #debug[\"purity on exit=%?\", self.declared_purity];\n-}\n-\n-fn check_loans_in_expr(expr: @ast::expr,\n-                       &&self: check_loan_ctxt,\n-                       vt: visit::vt<check_loan_ctxt>) {\n-    self.check_for_conflicting_loans(expr.id);\n-\n-    alt expr.node {\n-      ast::expr_swap(l, r) {\n-        self.check_assignment(at_swap, l);\n-        self.check_assignment(at_swap, r);\n-      }\n-      ast::expr_move(dest, src) {\n-        self.check_assignment(at_straight_up, dest);\n-        self.check_move_out(src);\n-      }\n-      ast::expr_assign(dest, _) |\n-      ast::expr_assign_op(_, dest, _) {\n-        self.check_assignment(at_straight_up, dest);\n-      }\n-      ast::expr_fn(_, _, _, cap_clause) |\n-      ast::expr_fn_block(_, _, cap_clause) {\n-        for (*cap_clause).each { |cap_item|\n-            if cap_item.is_move {\n-                let def = self.tcx().def_map.get(cap_item.id);\n-\n-                // Hack: the type that is used in the cmt doesn't actually\n-                // matter here, so just subst nil instead of looking up\n-                // the type of the def that is referred to\n-                let cmt = self.bccx.cat_def(cap_item.id, cap_item.span,\n-                                            ty::mk_nil(self.tcx()), def);\n-                self.check_move_out_from_cmt(cmt);\n-            }\n-        }\n-      }\n-      ast::expr_addr_of(mutbl, base) {\n-        alt mutbl {\n-          m_const { /*all memory is const*/ }\n-          m_mutbl {\n-            // If we are taking an &mut ptr, make sure the memory\n-            // being pointed at is assignable in the first place:\n-            self.check_assignment(at_mutbl_ref, base);\n-          }\n-          m_imm {\n-            // XXX explain why no check is req'd here\n-          }\n-        }\n-      }\n-      ast::expr_call(f, args, _) {\n-        alt self.purity(expr.id) {\n-          none {}\n-          some(pc) {\n-            self.check_pure_callee_or_arg(pc, f);\n-            for args.each { |arg| self.check_pure_callee_or_arg(pc, arg) }\n-          }\n-        }\n-        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n-        vec::iter2(args, arg_tys) { |arg, arg_ty|\n-            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_move {\n-                self.check_move_out(arg);\n-              }\n-              ast::by_mutbl_ref {\n-                self.check_assignment(at_mutbl_ref, arg);\n-              }\n-              ast::by_ref | ast::by_copy | ast::by_val {\n-              }\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-\n-    visit::visit_expr(expr, self, vt);\n-}\n-\n-fn check_loans_in_block(blk: ast::blk,\n-                        &&self: check_loan_ctxt,\n-                        vt: visit::vt<check_loan_ctxt>) {\n-    save_and_restore(self.declared_purity) {||\n-        self.check_for_conflicting_loans(blk.node.id);\n-\n-        alt blk.node.rules {\n-          ast::default_blk {\n-          }\n-          ast::unchecked_blk {\n-            self.declared_purity = ast::impure_fn;\n-          }\n-          ast::unsafe_blk {\n-            self.declared_purity = ast::unsafe_fn;\n-          }\n-        }\n-\n-        visit::visit_block(blk, self, vt);\n-    }\n-}\n-\n-// ----------------------------------------------------------------------\n-// Categorization\n-//\n-// Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-// address where the result is to be found.  If Expr is an lvalue, then this\n-// is the address of the lvalue.  If Expr is an rvalue, this is the address of\n-// some temporary spot in memory where the result is stored.\n-//\n-// Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n-// as follows:\n-//\n-// - cat: what kind of expression was this?  This is a subset of the\n-//   full expression forms which only includes those that we care about\n-//   for the purpose of the analysis.\n-// - mutbl: mutability of the address A\n-// - ty: the type of data found at the address A\n-//\n-// The resulting categorization tree differs somewhat from the expressions\n-// themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n-// decomposed into two operations: a derefence to reach the array data and\n-// then an index to jump forward to the relevant item.\n-\n-// Categorizes a derefable type.  Note that we include vectors and strings as\n-// derefable (we model an index as the combination of a deref and then a\n-// pointer adjustment).\n-fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n-    alt ty::get(t).struct {\n-      ty::ty_uniq(*) | ty::ty_vec(*) | ty::ty_str |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) {\n-        deref_ptr(uniq_ptr)\n-      }\n-\n-      ty::ty_rptr(*) |\n-      ty::ty_evec(_, ty::vstore_slice(_)) |\n-      ty::ty_estr(ty::vstore_slice(_)) {\n-        deref_ptr(region_ptr)\n-      }\n-\n-      ty::ty_box(*) |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) {\n-        deref_ptr(gc_ptr)\n-      }\n-\n-      ty::ty_ptr(*) {\n-        deref_ptr(unsafe_ptr)\n-      }\n-\n-      ty::ty_enum(*) {\n-        deref_comp(comp_variant)\n-      }\n-\n-      ty::ty_res(*) {\n-        deref_comp(comp_res)\n-      }\n-\n-      _ {\n-        tcx.sess.bug(\n-            #fmt[\"deref_cat() invoked on non-derefable type %s\",\n-                 ty_to_str(tcx, t)]);\n-      }\n-    }\n-}\n+// ___________________________________________________________________________\n+// Misc\n \n iface ast_node {\n     fn id() -> ast::node_id;\n@@ -1116,324 +341,47 @@ impl methods for ty::ctxt {\n     }\n }\n \n-impl categorize_methods for borrowck_ctxt {\n-    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n-        // a borrowed expression must be either an @, ~, or a vec/@, vec/~\n-        let expr_ty = ty::expr_ty(self.tcx, expr);\n-        alt ty::get(expr_ty).struct {\n-          ty::ty_vec(*) | ty::ty_evec(*) |\n-          ty::ty_str | ty::ty_estr(*) {\n-            self.cat_index(expr, expr)\n-          }\n-\n-          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) {\n-            let cmt = self.cat_expr(expr);\n-            self.cat_deref(expr, cmt, 0u, true).get()\n-          }\n-\n-          _ {\n-            self.tcx.sess.span_bug(\n-                expr.span,\n-                #fmt[\"Borrowing of non-derefable type `%s`\",\n-                     ty_to_str(self.tcx, expr_ty)]);\n-          }\n-        }\n-    }\n-\n-    fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n-        @{id:expr.id, span:expr.span,\n-          cat:cat_special(sk_method), lp:none,\n-          mutbl:m_imm, ty:expr_ty}\n-    }\n-\n-    fn cat_rvalue(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n-        @{id:expr.id, span:expr.span,\n-          cat:cat_rvalue, lp:none,\n-          mutbl:m_imm, ty:expr_ty}\n-    }\n-\n-    fn cat_expr(expr: @ast::expr) -> cmt {\n-        #debug[\"cat_expr: id=%d expr=%s\",\n-               expr.id, pprust::expr_to_str(expr)];\n-\n-        let tcx = self.tcx;\n-        let expr_ty = tcx.ty(expr);\n-        alt expr.node {\n-          ast::expr_unary(ast::deref, e_base) {\n-            if self.method_map.contains_key(expr.id) {\n-                ret self.cat_rvalue(expr, expr_ty);\n-            }\n-\n-            let base_cmt = self.cat_expr(e_base);\n-            alt self.cat_deref(expr, base_cmt, 0u, true) {\n-              some(cmt) { ret cmt; }\n-              none {\n-                tcx.sess.span_bug(\n-                    e_base.span,\n-                    #fmt[\"Explicit deref of non-derefable type `%s`\",\n-                         ty_to_str(tcx, tcx.ty(e_base))]);\n-              }\n-            }\n-          }\n-\n-          ast::expr_field(base, f_name, _) {\n-            if self.method_map.contains_key(expr.id) {\n-                ret self.cat_method_ref(expr, expr_ty);\n-            }\n-\n-            let base_cmt = self.cat_autoderef(base);\n-            self.cat_field(expr, base_cmt, f_name)\n-          }\n-\n-          ast::expr_index(base, _) {\n-            if self.method_map.contains_key(expr.id) {\n-                ret self.cat_rvalue(expr, expr_ty);\n-            }\n-\n-            self.cat_index(expr, base)\n-          }\n-\n-          ast::expr_path(_) {\n-            let def = self.tcx.def_map.get(expr.id);\n-            self.cat_def(expr.id, expr.span, expr_ty, def)\n-          }\n-\n-          ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_bind(*) |\n-          ast::expr_swap(*) | ast::expr_move(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n-          ast::expr_assert(*) | ast::expr_check(*) | ast::expr_ret(*) |\n-          ast::expr_loop_body(*) | ast::expr_unary(*) |\n-          ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n-          ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n-          ast::expr_if_check(*) | ast::expr_if(*) | ast::expr_log(*) |\n-          ast::expr_new(*) | ast::expr_binary(*) | ast::expr_while(*) |\n-          ast::expr_block(*) | ast::expr_loop(*) | ast::expr_alt(*) |\n-          ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n-          ast::expr_cont | ast::expr_rec(*) {\n-            ret self.cat_rvalue(expr, expr_ty);\n-          }\n+impl error_methods for borrowck_ctxt {\n+    fn report_if_err(bres: bckres<()>) {\n+        alt bres {\n+          ok(()) { }\n+          err(e) { self.report(e); }\n         }\n     }\n \n-    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n-        ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n-    }\n-\n-    fn cat_field<N:ast_node>(node: N, base_cmt: cmt, f_name: str) -> cmt {\n-        let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n-          some(f_mutbl) { f_mutbl }\n-          none {\n-            self.tcx.sess.span_bug(\n-                node.span(),\n-                #fmt[\"Cannot find field `%s` in type `%s`\",\n-                     f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n-          }\n-        };\n-        let m = alt f_mutbl {\n-          m_imm { base_cmt.mutbl } // imm: as mutable as the container\n-          m_mutbl | m_const { f_mutbl }\n-        };\n-        let lp = base_cmt.lp.map { |lp|\n-            @lp_comp(lp, comp_field(f_name))\n-        };\n-        @{id: node.id(), span: node.span(),\n-          cat: cat_comp(base_cmt, comp_field(f_name)), lp:lp,\n-          mutbl: m, ty: self.tcx.ty(node)}\n-    }\n-\n-    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n-                             expl: bool) -> option<cmt> {\n-        ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n-            alt deref_kind(self.tcx, base_cmt.ty) {\n-              deref_ptr(ptr) {\n-                let lp = base_cmt.lp.chain { |l|\n-                    // Given that the ptr itself is loanable, we can\n-                    // loan out deref'd uniq ptrs as the data they are\n-                    // the only way to reach the data they point at.\n-                    // Other ptr types admit aliases and are therefore\n-                    // not loanable.\n-                    alt ptr {\n-                      uniq_ptr {some(@lp_deref(l, ptr))}\n-                      gc_ptr | region_ptr | unsafe_ptr {none}\n-                    }\n-                };\n-                @{id:node.id(), span:node.span(),\n-                  cat:cat_deref(base_cmt, derefs, ptr), lp:lp,\n-                  mutbl:mt.mutbl, ty:mt.ty}\n-              }\n-\n-              deref_comp(comp) {\n-                let lp = base_cmt.lp.map { |l| @lp_comp(l, comp) };\n-                @{id:node.id(), span:node.span(),\n-                  cat:cat_comp(base_cmt, comp), lp:lp,\n-                  mutbl:mt.mutbl, ty:mt.ty}\n-              }\n-            }\n-        }\n+    fn report(err: bckerr) {\n+        self.span_err(\n+            err.cmt.span,\n+            #fmt[\"illegal borrow: %s\",\n+                 self.bckerr_code_to_str(err.code)]);\n     }\n \n-    fn cat_autoderef(base: @ast::expr) -> cmt {\n-        // Creates a string of implicit derefences so long as base is\n-        // dereferencable.  n.b., it is important that these dereferences are\n-        // associated with the field/index that caused the autoderef (expr).\n-        // This is used later to adjust ref counts and so forth in trans.\n-\n-        // Given something like base.f where base has type @m1 @m2 T, we want\n-        // to yield the equivalent categories to (**base).f.\n-        let mut cmt = self.cat_expr(base);\n-        let mut ctr = 0u;\n-        loop {\n-            ctr += 1u;\n-            alt self.cat_deref(base, cmt, ctr, false) {\n-              none { ret cmt; }\n-              some(cmt1) { cmt = cmt1; }\n-            }\n+    fn span_err(s: span, m: str) {\n+        if self.msg_level == 1u {\n+            self.tcx.sess.span_warn(s, m);\n+        } else {\n+            self.tcx.sess.span_err(s, m);\n         }\n     }\n \n-    fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n-        let base_cmt = self.cat_autoderef(base);\n-\n-        let mt = alt ty::index(self.tcx, base_cmt.ty) {\n-          some(mt) { mt }\n-          none {\n-            self.tcx.sess.span_bug(\n-                expr.span,\n-                #fmt[\"Explicit index of non-index type `%s`\",\n-                     ty_to_str(self.tcx, base_cmt.ty)]);\n-          }\n-        };\n-\n-        let ptr = alt deref_kind(self.tcx, base_cmt.ty) {\n-          deref_ptr(ptr) { ptr }\n-          deref_comp(_) {\n-            self.tcx.sess.span_bug(\n-                expr.span,\n-                \"Deref of indexable type yielded comp kind\");\n-          }\n-        };\n-\n-        // make deref of vectors explicit, as explained in the comment at\n-        // the head of this section\n-        let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n-        let deref_cmt = @{id:expr.id, span:expr.span,\n-                          cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n-                          mutbl:mt.mutbl, ty:mt.ty};\n-        let comp = comp_index(base_cmt.ty);\n-        let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp) };\n-        @{id:expr.id, span:expr.span,\n-          cat:cat_comp(deref_cmt, comp), lp:index_lp,\n-          mutbl:mt.mutbl, ty:mt.ty}\n-    }\n-\n-    fn cat_variant<N: ast_node>(arg: N, cmt: cmt) -> cmt {\n-        @{id: arg.id(), span: arg.span(),\n-          cat: cat_comp(cmt, comp_variant),\n-          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant) },\n-          mutbl: cmt.mutbl, // imm iff in an immutable context\n-          ty: self.tcx.ty(arg)}\n-    }\n-\n-    fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n-        @{id: elt.id(), span: elt.span(),\n-          cat: cat_comp(cmt, comp_tuple),\n-          lp: cmt.lp.map { |l| @lp_comp(l, comp_tuple) },\n-          mutbl: cmt.mutbl, // imm iff in an immutable context\n-          ty: self.tcx.ty(elt)}\n+    fn span_note(s: span, m: str) {\n+        self.tcx.sess.span_note(s, m);\n     }\n \n-    fn cat_def(id: ast::node_id,\n-               span: span,\n-               expr_ty: ty::t,\n-               def: ast::def) -> cmt {\n-        alt def {\n-          ast::def_fn(_, _) | ast::def_mod(_) |\n-          ast::def_native_mod(_) | ast::def_const(_) |\n-          ast::def_use(_) | ast::def_variant(_, _) |\n-          ast::def_ty(_) | ast::def_prim_ty(_) |\n-          ast::def_ty_param(_, _) | ast::def_class(_) |\n-          ast::def_region(_) {\n-            @{id:id, span:span,\n-              cat:cat_special(sk_static_item), lp:none,\n-              mutbl:m_imm, ty:expr_ty}\n-          }\n-\n-          ast::def_arg(vid, mode) {\n-            // Idea: make this could be rewritten to model by-ref\n-            // stuff as `&const` and `&mut`?\n-\n-            // m: mutability of the argument\n-            // lp: loan path, must be none for aliasable things\n-            let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n-              ast::by_mutbl_ref {\n-                {m: m_mutbl,\n-                 lp: none}\n-              }\n-              ast::by_move | ast::by_copy {\n-                {m: m_imm,\n-                 lp: some(@lp_arg(vid))}\n-              }\n-              ast::by_ref {\n-                {m: if TREAT_CONST_AS_IMM {m_imm} else {m_const},\n-                 lp: none}\n-              }\n-              ast::by_val {\n-                // by-value is this hybrid mode where we have a\n-                // pointer but we do not own it.  This is not\n-                // considered loanable because, for example, a by-ref\n-                // and and by-val argument might both actually contain\n-                // the same unique ptr.\n-                {m: m_imm,\n-                 lp: none}\n-              }\n-            };\n-            @{id:id, span:span,\n-              cat:cat_arg(vid), lp:lp,\n-              mutbl:m, ty:expr_ty}\n-          }\n-\n-          ast::def_self(_) {\n-            @{id:id, span:span,\n-              cat:cat_special(sk_self), lp:none,\n-              mutbl:m_imm, ty:expr_ty}\n-          }\n-\n-          ast::def_upvar(upvid, inner, fn_node_id) {\n-            let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n-            let proto = ty::ty_fn_proto(ty);\n-            alt proto {\n-              ast::proto_any | ast::proto_block {\n-                let upcmt = self.cat_def(id, span, expr_ty, *inner);\n-                @{id:id, span:span,\n-                  cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n-                  mutbl:upcmt.mutbl, ty:upcmt.ty}\n-              }\n-              ast::proto_bare | ast::proto_uniq | ast::proto_box {\n-                // FIXME #2152 allow mutation of moved upvars\n-                @{id:id, span:span,\n-                  cat:cat_special(sk_heap_upvar), lp:none,\n-                  mutbl:m_imm, ty:expr_ty}\n-              }\n-            }\n-          }\n-\n-          ast::def_local(vid, mutbl) {\n-            let m = if mutbl {m_mutbl} else {m_imm};\n-            @{id:id, span:span,\n-              cat:cat_local(vid), lp:some(@lp_local(vid)),\n-              mutbl:m, ty:expr_ty}\n+    fn add_to_mutbl_map(cmt: cmt) {\n+        alt cmt.cat {\n+          cat_local(id) | cat_arg(id) {\n+            self.mutbl_map.insert(id, ());\n           }\n-\n-          ast::def_binding(vid) {\n-            // no difference between a binding and any other local variable\n-            // from out point of view, except that they are always immutable\n-            @{id:id, span:span,\n-              cat:cat_local(vid), lp:some(@lp_local(vid)),\n-              mutbl:m_imm, ty:expr_ty}\n+          cat_stack_upvar(cmt) {\n+            self.add_to_mutbl_map(cmt);\n           }\n+          _ {}\n         }\n     }\n+}\n \n+impl to_str_methods for borrowck_ctxt {\n     fn cat_to_repr(cat: categorization) -> str {\n         alt cat {\n           cat_special(sk_method) { \"method\" }\n@@ -1573,316 +521,4 @@ impl categorize_methods for borrowck_ctxt {\n           }\n         }\n     }\n-\n-    fn report_if_err(bres: bckres<()>) {\n-        alt bres {\n-          ok(()) { }\n-          err(e) { self.report(e); }\n-        }\n-    }\n-\n-    fn report(err: bckerr) {\n-        self.span_err(\n-            err.cmt.span,\n-            #fmt[\"illegal borrow: %s\",\n-                 self.bckerr_code_to_str(err.code)]);\n-    }\n-\n-    fn span_err(s: span, m: str) {\n-        if self.msg_level == 1u {\n-            self.tcx.sess.span_warn(s, m);\n-        } else {\n-            self.tcx.sess.span_err(s, m);\n-        }\n-    }\n-\n-    fn span_note(s: span, m: str) {\n-        self.tcx.sess.span_note(s, m);\n-    }\n-\n-    fn add_to_mutbl_map(cmt: cmt) {\n-        alt cmt.cat {\n-          cat_local(id) | cat_arg(id) {\n-            self.mutbl_map.insert(id, ());\n-          }\n-          cat_stack_upvar(cmt) {\n-            self.add_to_mutbl_map(cmt);\n-          }\n-          _ {}\n-        }\n-    }\n-}\n-\n-fn field_mutbl(tcx: ty::ctxt,\n-               base_ty: ty::t,\n-               f_name: str) -> option<ast::mutability> {\n-    // Need to refactor so that records/class fields can be treated uniformly.\n-    alt ty::get(base_ty).struct {\n-      ty::ty_rec(fields) {\n-        for fields.each { |f|\n-            if f.ident == f_name {\n-                ret some(f.mt.mutbl);\n-            }\n-        }\n-      }\n-      ty::ty_class(did, substs) {\n-        for ty::lookup_class_fields(tcx, did).each { |fld|\n-            if fld.ident == f_name {\n-                let m = alt fld.mutability {\n-                  ast::class_mutable { ast::m_mutbl }\n-                  ast::class_immutable { ast::m_imm }\n-                };\n-                ret some(m);\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-\n-    ret none;\n-}\n-\n-// ----------------------------------------------------------------------\n-// Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n-// the scope S.\n-\n-impl preserve_methods for borrowck_ctxt {\n-    fn preserve(cmt: cmt, opt_scope_id: option<ast::node_id>) -> bckres<()> {\n-        #debug[\"preserve(%s)\", self.cmt_to_repr(cmt)];\n-        let _i = indenter();\n-\n-        alt cmt.cat {\n-          cat_rvalue | cat_special(_) {\n-            ok(())\n-          }\n-          cat_stack_upvar(cmt) {\n-            self.preserve(cmt, opt_scope_id)\n-          }\n-          cat_local(_) {\n-            // This should never happen.  Local variables are always lendable,\n-            // so either `loan()` should be called or there must be some\n-            // intermediate @ or &---they are not lendable but do not recurse.\n-            self.tcx.sess.span_bug(\n-                cmt.span,\n-                \"preserve() called with local\");\n-          }\n-          cat_arg(_) {\n-            // This can happen as not all args are lendable (e.g., &&\n-            // modes).  In that case, the caller guarantees stability.\n-            // This is basically a deref of a region ptr.\n-            ok(())\n-          }\n-          cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index(_)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_res) {\n-            // Most embedded components: if the base is stable, the\n-            // type never changes.\n-            self.preserve(cmt_base, opt_scope_id)\n-          }\n-          cat_comp(cmt1, comp_variant) {\n-            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_variant)\n-          }\n-          cat_deref(cmt1, _, uniq_ptr) {\n-            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_uniq)\n-          }\n-          cat_deref(_, _, region_ptr) {\n-            // References are always \"stable\" by induction (when the\n-            // reference of type &MT was created, the memory must have\n-            // been stable)\n-            ok(())\n-          }\n-          cat_deref(_, _, unsafe_ptr) {\n-            // Unsafe pointers are the user's problem\n-            ok(())\n-          }\n-          cat_deref(base, derefs, gc_ptr) {\n-            // GC'd pointers of type @MT: always stable because we can\n-            // inc the ref count or keep a GC root as necessary.  We\n-            // need to insert this id into the root_map, however.\n-            alt opt_scope_id {\n-              some(scope_id) {\n-                #debug[\"Inserting root map entry for %s: \\\n-                        node %d:%u -> scope %d\",\n-                       self.cmt_to_repr(cmt), base.id,\n-                       derefs, scope_id];\n-\n-                let rk = {id: base.id, derefs: derefs};\n-                self.root_map.insert(rk, scope_id);\n-                ok(())\n-              }\n-              none {\n-                err({cmt:cmt, code:err_preserve_gc})\n-              }\n-            }\n-          }\n-          cat_discr(base, alt_id) {\n-            // Subtle: in an alt, we must ensure that each binding\n-            // variable remains valid for the duration of the arm in\n-            // which it appears, presuming that this arm is taken.\n-            // But it is inconvenient in trans to root something just\n-            // for one arm.  Therefore, we insert a cat_discr(),\n-            // basically a special kind of category that says \"if this\n-            // value must be dynamically rooted, root it for the scope\n-            // `alt_id`.\n-            //\n-            // As an example, consider this scenario:\n-            //\n-            //    let mut x = @some(3);\n-            //    alt *x { some(y) {...} none {...} }\n-            //\n-            // Technically, the value `x` need only be rooted\n-            // in the `some` arm.  However, we evaluate `x` in trans\n-            // before we know what arm will be taken, so we just\n-            // always root it for the duration of the alt.\n-            //\n-            // As a second example, consider *this* scenario:\n-            //\n-            //    let x = @mut @some(3);\n-            //    alt x { @@some(y) {...} @@none {...} }\n-            //\n-            // Here again, `x` need only be rooted in the `some` arm.\n-            // In this case, the value which needs to be rooted is\n-            // found only when checking which pattern matches: but\n-            // this check is done before entering the arm.  Therefore,\n-            // even in this case we just choose to keep the value\n-            // rooted for the entire alt.  This means the value will be\n-            // rooted even if the none arm is taken.  Oh well.\n-            //\n-            // At first, I tried to optimize the second case to only\n-            // root in one arm, but the result was suboptimal: first,\n-            // it interfered with the construction of phi nodes in the\n-            // arm, as we were adding code to root values before the\n-            // phi nodes were added.  This could have been addressed\n-            // with a second basic block.  However, the naive approach\n-            // also yielded suboptimal results for patterns like:\n-            //\n-            //    let x = @mut @...;\n-            //    alt x { @@some_variant(y) | @@some_other_variant(y) {...} }\n-            //\n-            // The reason is that we would root the value once for\n-            // each pattern and not once per arm.  This is also easily\n-            // fixed, but it's yet more code for what is really quite\n-            // the corner case.\n-            //\n-            // Nonetheless, if you decide to optimize this case in the\n-            // future, you need only adjust where the cat_discr()\n-            // node appears to draw the line between what will be rooted\n-            // in the *arm* vs the *alt*.\n-\n-            // current scope must be the arm, which is always a child of alt:\n-            assert self.tcx.region_map.get(opt_scope_id.get()) == alt_id;\n-\n-            self.preserve(base, some(alt_id))\n-          }\n-        }\n-    }\n-\n-    fn require_imm(cmt: cmt,\n-                   cmt1: cmt,\n-                   opt_scope_id: option<ast::node_id>,\n-                   code: bckerr_code) -> bckres<()> {\n-        // Variant contents and unique pointers: must be immutably\n-        // rooted to a preserved address.\n-        alt cmt1.mutbl {\n-          m_mutbl | m_const { err({cmt:cmt, code:code}) }\n-          m_imm { self.preserve(cmt1, opt_scope_id) }\n-        }\n-    }\n-}\n-\n-// ----------------------------------------------------------------------\n-// Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n-// of the scope S, presuming that the returned set of loans `Ls` are honored.\n-\n-type loan_ctxt = @{\n-    bccx: borrowck_ctxt,\n-    loans: @mut [loan]\n-};\n-\n-impl loan_methods for borrowck_ctxt {\n-    fn loan(cmt: cmt, mutbl: ast::mutability) -> @const [loan] {\n-        let lc = @{bccx: self, loans: @mut []};\n-        lc.loan(cmt, mutbl);\n-        ret lc.loans;\n-    }\n-}\n-\n-impl loan_methods for loan_ctxt {\n-    fn ok_with_loan_of(cmt: cmt,\n-                       mutbl: ast::mutability) {\n-        // Note: all cmt's that we deal with will have a non-none lp, because\n-        // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n-        // any cmt with a none-lp.\n-        *self.loans += [{lp:option::get(cmt.lp),\n-                         cmt:cmt,\n-                         mutbl:mutbl}];\n-    }\n-\n-    fn loan(cmt: cmt, req_mutbl: ast::mutability) {\n-\n-        #debug[\"loan(%s, %s)\",\n-               self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl)];\n-        let _i = indenter();\n-\n-        // see stable() above; should only be called when `cmt` is lendable\n-        if cmt.lp.is_none() {\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"loan() called with non-lendable value\");\n-        }\n-\n-        alt cmt.cat {\n-          cat_rvalue | cat_special(_) {\n-            // should never be loanable\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"rvalue with a non-none lp\");\n-          }\n-          cat_local(_) | cat_arg(_) | cat_stack_upvar(_) {\n-            self.ok_with_loan_of(cmt, req_mutbl)\n-          }\n-          cat_discr(base, _) {\n-            self.loan(base, req_mutbl)\n-          }\n-          cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index(_)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_res) {\n-            // For most components, the type of the embedded data is\n-            // stable.  Therefore, the base structure need only be\n-            // const---unless the component must be immutable.  In\n-            // that case, it must also be embedded in an immutable\n-            // location, or else the whole structure could be\n-            // overwritten and the component along with it.\n-            let base_mutbl = alt req_mutbl {\n-              m_imm { m_imm }\n-              m_const | m_mutbl { m_const }\n-            };\n-\n-            self.loan(cmt_base, base_mutbl);\n-            self.ok_with_loan_of(cmt, req_mutbl)\n-          }\n-          cat_comp(cmt1, comp_variant) |\n-          cat_deref(cmt1, _, uniq_ptr) {\n-            // Variant components: the base must be immutable, because\n-            // if it is overwritten, the types of the embedded data\n-            // could change.\n-            //\n-            // Unique pointers: the base must be immutable, because if\n-            // it is overwritten, the unique content will be freed.\n-            self.loan(cmt1, m_imm);\n-            self.ok_with_loan_of(cmt, req_mutbl)\n-          }\n-          cat_deref(cmt1, _, unsafe_ptr) |\n-          cat_deref(cmt1, _, gc_ptr) |\n-          cat_deref(cmt1, _, region_ptr) {\n-            // Aliased data is simply not lendable.\n-            self.bccx.tcx.sess.span_bug(\n-                cmt.span,\n-                \"aliased ptr with a non-none lp\");\n-          }\n-        }\n-    }\n }"}, {"sha": "325460bddbe95222494c94e07421572bdf8d20d5", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -0,0 +1,421 @@\n+#[doc = \"\n+\n+# Categorization\n+\n+The job of the categorization module is to analyze an expression to\n+determine what kind of memory is used in evaluating it (for example,\n+where dereferences occur and what kind of pointer is dereferenced;\n+whether the memory is mutable; etc)\n+\n+\n+\n+Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n+address where the result is to be found.  If Expr is an lvalue, then this\n+is the address of the lvalue.  If Expr is an rvalue, this is the address of\n+some temporary spot in memory where the result is stored.\n+\n+Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n+as follows:\n+\n+- cat: what kind of expression was this?  This is a subset of the\n+  full expression forms which only includes those that we care about\n+  for the purpose of the analysis.\n+- mutbl: mutability of the address A\n+- ty: the type of data found at the address A\n+\n+The resulting categorization tree differs somewhat from the expressions\n+themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+decomposed into two operations: a derefence to reach the array data and\n+then an index to jump forward to the relevant item.\n+\"];\n+\n+export public_methods;\n+\n+// Categorizes a derefable type.  Note that we include vectors and strings as\n+// derefable (we model an index as the combination of a deref and then a\n+// pointer adjustment).\n+fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+    alt ty::get(t).struct {\n+      ty::ty_uniq(*) | ty::ty_vec(*) | ty::ty_str |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) {\n+        deref_ptr(uniq_ptr)\n+      }\n+\n+      ty::ty_rptr(*) |\n+      ty::ty_evec(_, ty::vstore_slice(_)) |\n+      ty::ty_estr(ty::vstore_slice(_)) {\n+        deref_ptr(region_ptr)\n+      }\n+\n+      ty::ty_box(*) |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) {\n+        deref_ptr(gc_ptr)\n+      }\n+\n+      ty::ty_ptr(*) {\n+        deref_ptr(unsafe_ptr)\n+      }\n+\n+      ty::ty_enum(*) {\n+        deref_comp(comp_variant)\n+      }\n+\n+      ty::ty_res(*) {\n+        deref_comp(comp_res)\n+      }\n+\n+      _ {\n+        tcx.sess.bug(\n+            #fmt[\"deref_cat() invoked on non-derefable type %s\",\n+                 ty_to_str(tcx, t)]);\n+      }\n+    }\n+}\n+\n+impl public_methods for borrowck_ctxt {\n+    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n+        // a borrowed expression must be either an @, ~, or a vec/@, vec/~\n+        let expr_ty = ty::expr_ty(self.tcx, expr);\n+        alt ty::get(expr_ty).struct {\n+          ty::ty_vec(*) | ty::ty_evec(*) |\n+          ty::ty_str | ty::ty_estr(*) {\n+            self.cat_index(expr, expr)\n+          }\n+\n+          ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) {\n+            let cmt = self.cat_expr(expr);\n+            self.cat_deref(expr, cmt, 0u, true).get()\n+          }\n+\n+          _ {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                #fmt[\"Borrowing of non-derefable type `%s`\",\n+                     ty_to_str(self.tcx, expr_ty)]);\n+          }\n+        }\n+    }\n+\n+    fn cat_expr(expr: @ast::expr) -> cmt {\n+        #debug[\"cat_expr: id=%d expr=%s\",\n+               expr.id, pprust::expr_to_str(expr)];\n+\n+        let tcx = self.tcx;\n+        let expr_ty = tcx.ty(expr);\n+        alt expr.node {\n+          ast::expr_unary(ast::deref, e_base) {\n+            if self.method_map.contains_key(expr.id) {\n+                ret self.cat_rvalue(expr, expr_ty);\n+            }\n+\n+            let base_cmt = self.cat_expr(e_base);\n+            alt self.cat_deref(expr, base_cmt, 0u, true) {\n+              some(cmt) { ret cmt; }\n+              none {\n+                tcx.sess.span_bug(\n+                    e_base.span,\n+                    #fmt[\"Explicit deref of non-derefable type `%s`\",\n+                         ty_to_str(tcx, tcx.ty(e_base))]);\n+              }\n+            }\n+          }\n+\n+          ast::expr_field(base, f_name, _) {\n+            if self.method_map.contains_key(expr.id) {\n+                ret self.cat_method_ref(expr, expr_ty);\n+            }\n+\n+            let base_cmt = self.cat_autoderef(base);\n+            self.cat_field(expr, base_cmt, f_name)\n+          }\n+\n+          ast::expr_index(base, _) {\n+            if self.method_map.contains_key(expr.id) {\n+                ret self.cat_rvalue(expr, expr_ty);\n+            }\n+\n+            self.cat_index(expr, base)\n+          }\n+\n+          ast::expr_path(_) {\n+            let def = self.tcx.def_map.get(expr.id);\n+            self.cat_def(expr.id, expr.span, expr_ty, def)\n+          }\n+\n+          ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_bind(*) |\n+          ast::expr_swap(*) | ast::expr_move(*) | ast::expr_assign(*) |\n+          ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n+          ast::expr_assert(*) | ast::expr_check(*) | ast::expr_ret(*) |\n+          ast::expr_loop_body(*) | ast::expr_unary(*) |\n+          ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n+          ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n+          ast::expr_if_check(*) | ast::expr_if(*) | ast::expr_log(*) |\n+          ast::expr_new(*) | ast::expr_binary(*) | ast::expr_while(*) |\n+          ast::expr_block(*) | ast::expr_loop(*) | ast::expr_alt(*) |\n+          ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n+          ast::expr_cont | ast::expr_rec(*) {\n+            ret self.cat_rvalue(expr, expr_ty);\n+          }\n+        }\n+    }\n+\n+    fn cat_def(id: ast::node_id,\n+               span: span,\n+               expr_ty: ty::t,\n+               def: ast::def) -> cmt {\n+        alt def {\n+          ast::def_fn(_, _) | ast::def_mod(_) |\n+          ast::def_native_mod(_) | ast::def_const(_) |\n+          ast::def_use(_) | ast::def_variant(_, _) |\n+          ast::def_ty(_) | ast::def_prim_ty(_) |\n+          ast::def_ty_param(_, _) | ast::def_class(_) |\n+          ast::def_region(_) {\n+            @{id:id, span:span,\n+              cat:cat_special(sk_static_item), lp:none,\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+\n+          ast::def_arg(vid, mode) {\n+            // Idea: make this could be rewritten to model by-ref\n+            // stuff as `&const` and `&mut`?\n+\n+            // m: mutability of the argument\n+            // lp: loan path, must be none for aliasable things\n+            let {m,lp} = alt ty::resolved_mode(self.tcx, mode) {\n+              ast::by_mutbl_ref {\n+                {m: m_mutbl, lp: none}\n+              }\n+              ast::by_move | ast::by_copy {\n+                {m: m_imm, lp: some(@lp_arg(vid))}\n+              }\n+              ast::by_ref {\n+                {m: m_imm, lp: none}\n+              }\n+              ast::by_val {\n+                // by-value is this hybrid mode where we have a\n+                // pointer but we do not own it.  This is not\n+                // considered loanable because, for example, a by-ref\n+                // and and by-val argument might both actually contain\n+                // the same unique ptr.\n+                {m: m_imm, lp: none}\n+              }\n+            };\n+            @{id:id, span:span,\n+              cat:cat_arg(vid), lp:lp,\n+              mutbl:m, ty:expr_ty}\n+          }\n+\n+          ast::def_self(_) {\n+            @{id:id, span:span,\n+              cat:cat_special(sk_self), lp:none,\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+\n+          ast::def_upvar(upvid, inner, fn_node_id) {\n+            let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+            let proto = ty::ty_fn_proto(ty);\n+            alt proto {\n+              ast::proto_any | ast::proto_block {\n+                let upcmt = self.cat_def(id, span, expr_ty, *inner);\n+                @{id:id, span:span,\n+                  cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n+                  mutbl:upcmt.mutbl, ty:upcmt.ty}\n+              }\n+              ast::proto_bare | ast::proto_uniq | ast::proto_box {\n+                // FIXME #2152 allow mutation of moved upvars\n+                @{id:id, span:span,\n+                  cat:cat_special(sk_heap_upvar), lp:none,\n+                  mutbl:m_imm, ty:expr_ty}\n+              }\n+            }\n+          }\n+\n+          ast::def_local(vid, mutbl) {\n+            let m = if mutbl {m_mutbl} else {m_imm};\n+            @{id:id, span:span,\n+              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              mutbl:m, ty:expr_ty}\n+          }\n+\n+          ast::def_binding(vid) {\n+            // no difference between a binding and any other local variable\n+            // from out point of view, except that they are always immutable\n+            @{id:id, span:span,\n+              cat:cat_local(vid), lp:some(@lp_local(vid)),\n+              mutbl:m_imm, ty:expr_ty}\n+          }\n+        }\n+    }\n+\n+    fn cat_variant<N: ast_node>(arg: N, cmt: cmt) -> cmt {\n+        @{id: arg.id(), span: arg.span(),\n+          cat: cat_comp(cmt, comp_variant),\n+          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant) },\n+          mutbl: cmt.mutbl, // imm iff in an immutable context\n+          ty: self.tcx.ty(arg)}\n+    }\n+\n+    fn cat_rvalue(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n+        @{id:expr.id, span:expr.span,\n+          cat:cat_rvalue, lp:none,\n+          mutbl:m_imm, ty:expr_ty}\n+    }\n+\n+    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n+        ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n+    }\n+\n+    fn cat_field<N:ast_node>(node: N, base_cmt: cmt, f_name: str) -> cmt {\n+        let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n+          some(f_mutbl) { f_mutbl }\n+          none {\n+            self.tcx.sess.span_bug(\n+                node.span(),\n+                #fmt[\"Cannot find field `%s` in type `%s`\",\n+                     f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n+          }\n+        };\n+        let m = alt f_mutbl {\n+          m_imm { base_cmt.mutbl } // imm: as mutable as the container\n+          m_mutbl | m_const { f_mutbl }\n+        };\n+        let lp = base_cmt.lp.map { |lp|\n+            @lp_comp(lp, comp_field(f_name))\n+        };\n+        @{id: node.id(), span: node.span(),\n+          cat: cat_comp(base_cmt, comp_field(f_name)), lp:lp,\n+          mutbl: m, ty: self.tcx.ty(node)}\n+    }\n+\n+    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n+                             expl: bool) -> option<cmt> {\n+        ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n+            alt deref_kind(self.tcx, base_cmt.ty) {\n+              deref_ptr(ptr) {\n+                let lp = base_cmt.lp.chain { |l|\n+                    // Given that the ptr itself is loanable, we can\n+                    // loan out deref'd uniq ptrs as the data they are\n+                    // the only way to reach the data they point at.\n+                    // Other ptr types admit aliases and are therefore\n+                    // not loanable.\n+                    alt ptr {\n+                      uniq_ptr {some(@lp_deref(l, ptr))}\n+                      gc_ptr | region_ptr | unsafe_ptr {none}\n+                    }\n+                };\n+                @{id:node.id(), span:node.span(),\n+                  cat:cat_deref(base_cmt, derefs, ptr), lp:lp,\n+                  mutbl:mt.mutbl, ty:mt.ty}\n+              }\n+\n+              deref_comp(comp) {\n+                let lp = base_cmt.lp.map { |l| @lp_comp(l, comp) };\n+                @{id:node.id(), span:node.span(),\n+                  cat:cat_comp(base_cmt, comp), lp:lp,\n+                  mutbl:mt.mutbl, ty:mt.ty}\n+              }\n+            }\n+        }\n+    }\n+\n+    fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n+        let base_cmt = self.cat_autoderef(base);\n+\n+        let mt = alt ty::index(self.tcx, base_cmt.ty) {\n+          some(mt) { mt }\n+          none {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                #fmt[\"Explicit index of non-index type `%s`\",\n+                     ty_to_str(self.tcx, base_cmt.ty)]);\n+          }\n+        };\n+\n+        let ptr = alt deref_kind(self.tcx, base_cmt.ty) {\n+          deref_ptr(ptr) { ptr }\n+          deref_comp(_) {\n+            self.tcx.sess.span_bug(\n+                expr.span,\n+                \"Deref of indexable type yielded comp kind\");\n+          }\n+        };\n+\n+        // make deref of vectors explicit, as explained in the comment at\n+        // the head of this section\n+        let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n+        let deref_cmt = @{id:expr.id, span:expr.span,\n+                          cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n+                          mutbl:mt.mutbl, ty:mt.ty};\n+        let comp = comp_index(base_cmt.ty);\n+        let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp) };\n+        @{id:expr.id, span:expr.span,\n+          cat:cat_comp(deref_cmt, comp), lp:index_lp,\n+          mutbl:mt.mutbl, ty:mt.ty}\n+    }\n+\n+    fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n+        @{id: elt.id(), span: elt.span(),\n+          cat: cat_comp(cmt, comp_tuple),\n+          lp: cmt.lp.map { |l| @lp_comp(l, comp_tuple) },\n+          mutbl: cmt.mutbl, // imm iff in an immutable context\n+          ty: self.tcx.ty(elt)}\n+    }\n+}\n+\n+impl private_methods for borrowck_ctxt {\n+    fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n+        @{id:expr.id, span:expr.span,\n+          cat:cat_special(sk_method), lp:none,\n+          mutbl:m_imm, ty:expr_ty}\n+    }\n+\n+    fn cat_autoderef(base: @ast::expr) -> cmt {\n+        // Creates a string of implicit derefences so long as base is\n+        // dereferencable.  n.b., it is important that these dereferences are\n+        // associated with the field/index that caused the autoderef (expr).\n+        // This is used later to adjust ref counts and so forth in trans.\n+\n+        // Given something like base.f where base has type @m1 @m2 T, we want\n+        // to yield the equivalent categories to (**base).f.\n+        let mut cmt = self.cat_expr(base);\n+        let mut ctr = 0u;\n+        loop {\n+            ctr += 1u;\n+            alt self.cat_deref(base, cmt, ctr, false) {\n+              none { ret cmt; }\n+              some(cmt1) { cmt = cmt1; }\n+            }\n+        }\n+    }\n+}\n+\n+fn field_mutbl(tcx: ty::ctxt,\n+               base_ty: ty::t,\n+               f_name: str) -> option<ast::mutability> {\n+    // Need to refactor so that records/class fields can be treated uniformly.\n+    alt ty::get(base_ty).struct {\n+      ty::ty_rec(fields) {\n+        for fields.each { |f|\n+            if f.ident == f_name {\n+                ret some(f.mt.mutbl);\n+            }\n+        }\n+      }\n+      ty::ty_class(did, substs) {\n+        for ty::lookup_class_fields(tcx, did).each { |fld|\n+            if fld.ident == f_name {\n+                let m = alt fld.mutability {\n+                  ast::class_mutable { ast::m_mutbl }\n+                  ast::class_immutable { ast::m_imm }\n+                };\n+                ret some(m);\n+            }\n+        }\n+      }\n+      _ { }\n+    }\n+\n+    ret none;\n+}"}, {"sha": "a989a294401f7e661a07dfd2fb4bed7b260066ac", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -0,0 +1,548 @@\n+// ----------------------------------------------------------------------\n+// Checking loans\n+//\n+// Phase 2 of check: we walk down the tree and check that:\n+// 1. assignments are always made to mutable locations;\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves to dnot affect things loaned out in any way\n+\n+import categorization::public_methods;\n+\n+export check_loans;\n+\n+enum check_loan_ctxt = @{\n+    bccx: borrowck_ctxt,\n+    req_maps: req_maps,\n+\n+    reported: hashmap<ast::node_id, ()>,\n+\n+    // Keep track of whether we're inside a ctor, so as to\n+    // allow mutating immutable fields in the same class if\n+    // we are in a ctor, we track the self id\n+    mut in_ctor: bool,\n+    mut declared_purity: ast::purity,\n+    mut fn_args: [ast::node_id]\n+};\n+\n+// if we are enforcing purity, why are we doing so?\n+enum purity_cause {\n+    // enforcing purity because fn was declared pure:\n+    pc_pure_fn,\n+\n+    // enforce purity because we need to guarantee the\n+    // validity of some alias; `bckerr` describes the\n+    // reason we needed to enforce purity.\n+    pc_cmt(bckerr)\n+}\n+\n+fn check_loans(bccx: borrowck_ctxt,\n+               req_maps: req_maps,\n+               crate: @ast::crate) {\n+    let clcx = check_loan_ctxt(@{bccx: bccx,\n+                                 req_maps: req_maps,\n+                                 reported: int_hash(),\n+                                 mut in_ctor: false,\n+                                 mut declared_purity: ast::impure_fn,\n+                                 mut fn_args: []});\n+    let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n+                            visit_block: check_loans_in_block,\n+                            visit_fn: check_loans_in_fn\n+                            with *visit::default_visitor()});\n+    visit::visit_crate(*crate, clcx, vt);\n+}\n+\n+enum assignment_type {\n+    at_straight_up,\n+    at_swap,\n+    at_mutbl_ref,\n+}\n+\n+impl methods for assignment_type {\n+    fn checked_by_liveness() -> bool {\n+        // the liveness pass guarantees that immutable local variables\n+        // are only assigned once; but it doesn't consider &mut\n+        alt self {\n+          at_straight_up {true}\n+          at_swap {true}\n+          at_mutbl_ref {false}\n+        }\n+    }\n+    fn ing_form(desc: str) -> str {\n+        alt self {\n+          at_straight_up { \"assigning to \" + desc }\n+          at_swap { \"swapping to and from \" + desc }\n+          at_mutbl_ref { \"taking mut reference to \" + desc }\n+        }\n+    }\n+}\n+\n+impl methods for check_loan_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n+    fn purity(scope_id: ast::node_id) -> option<purity_cause> {\n+        let default_purity = alt self.declared_purity {\n+          // an unsafe declaration overrides all\n+          ast::unsafe_fn { ret none; }\n+\n+          // otherwise, remember what was declared as the\n+          // default, but we must scan for requirements\n+          // imposed by the borrow check\n+          ast::pure_fn { some(pc_pure_fn) }\n+          ast::crust_fn | ast::impure_fn { none }\n+        };\n+\n+        // scan to see if this scope or any enclosing scope requires\n+        // purity.  if so, that overrides the declaration.\n+\n+        let mut scope_id = scope_id;\n+        let region_map = self.tcx().region_map;\n+        let pure_map = self.req_maps.pure_map;\n+        loop {\n+            alt pure_map.find(scope_id) {\n+              none {}\n+              some(e) {ret some(pc_cmt(e));}\n+            }\n+\n+            alt region_map.find(scope_id) {\n+              none { ret default_purity; }\n+              some(next_scope_id) { scope_id = next_scope_id; }\n+            }\n+        }\n+    }\n+\n+    fn walk_loans(scope_id: ast::node_id,\n+                  f: fn(loan) -> bool) {\n+        let mut scope_id = scope_id;\n+        let region_map = self.tcx().region_map;\n+        let req_loan_map = self.req_maps.req_loan_map;\n+\n+        loop {\n+            for req_loan_map.find(scope_id).each { |loanss|\n+                for (*loanss).each { |loans|\n+                    for (*loans).each { |loan|\n+                        if !f(loan) { ret; }\n+                    }\n+                }\n+            }\n+\n+            alt region_map.find(scope_id) {\n+              none { ret; }\n+              some(next_scope_id) { scope_id = next_scope_id; }\n+            }\n+        }\n+    }\n+\n+    fn walk_loans_of(scope_id: ast::node_id,\n+                     lp: @loan_path,\n+                     f: fn(loan) -> bool) {\n+        for self.walk_loans(scope_id) { |loan|\n+            if loan.lp == lp {\n+                if !f(loan) { ret; }\n+            }\n+        }\n+    }\n+\n+    // when we are in a pure context, we check each call to ensure\n+    // that the function which is invoked is itself pure.\n+    fn check_pure_callee_or_arg(pc: purity_cause, expr: @ast::expr) {\n+        let tcx = self.tcx();\n+\n+        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%s, ty=%s)\",\n+               pc, pprust::expr_to_str(expr),\n+               ty_to_str(self.tcx(), tcx.ty(expr))];\n+\n+        // Purity rules: an expr B is a legal callee or argument to a\n+        // call within a pure function A if at least one of the\n+        // following holds:\n+        //\n+        // (a) A was declared pure and B is one of its arguments;\n+        // (b) B is a stack closure;\n+        // (c) B is a pure fn;\n+        // (d) B is not a fn.\n+\n+        alt expr.node {\n+          ast::expr_path(_) if pc == pc_pure_fn {\n+            let def = self.tcx().def_map.get(expr.id);\n+            let did = ast_util::def_id_of_def(def);\n+            let is_fn_arg =\n+                did.crate == ast::local_crate &&\n+                self.fn_args.contains(did.node);\n+            if is_fn_arg { ret; } // case (a) above\n+          }\n+          ast::expr_fn_block(*) | ast::expr_fn(*) | ast::expr_loop_body(*) {\n+            if self.is_stack_closure(expr.id) { ret; } // case (b) above\n+          }\n+          _ {}\n+        }\n+\n+        let expr_ty = tcx.ty(expr);\n+        alt ty::get(expr_ty).struct {\n+          ty::ty_fn(fn_ty) {\n+            alt fn_ty.purity {\n+              ast::pure_fn { ret; } // case (c) above\n+              ast::impure_fn | ast::unsafe_fn | ast::crust_fn {\n+                self.report_purity_error(\n+                    pc, expr.span,\n+                    #fmt[\"access to %s function\",\n+                         pprust::purity_to_str(fn_ty.purity)]);\n+              }\n+            }\n+          }\n+          _ { ret; } // case (d) above\n+        }\n+    }\n+\n+    // True if the expression with the given `id` is a stack closure.\n+    // The expression must be an expr_fn(*) or expr_fn_block(*)\n+    fn is_stack_closure(id: ast::node_id) -> bool {\n+        let fn_ty = ty::node_id_to_type(self.tcx(), id);\n+        let proto = ty::ty_fn_proto(fn_ty);\n+        alt proto {\n+          ast::proto_block | ast::proto_any {true}\n+          ast::proto_bare | ast::proto_uniq | ast::proto_box {false}\n+        }\n+    }\n+\n+    fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n+        ret alt expr.node {\n+          ast::expr_path(_) {\n+            let def = self.tcx().def_map.get(expr.id);\n+            let did = ast_util::def_id_of_def(def);\n+            did.crate == ast::local_crate && self.fn_args.contains(did.node)\n+          }\n+          ast::expr_fn_block(*) | ast::expr_fn(*) {\n+            self.is_stack_closure(expr.id)\n+          }\n+          _ {false}\n+        };\n+    }\n+\n+    fn check_for_conflicting_loans(scope_id: ast::node_id) {\n+        let new_loanss = alt self.req_maps.req_loan_map.find(scope_id) {\n+            none { ret; }\n+            some(loanss) { loanss }\n+        };\n+\n+        let par_scope_id = self.tcx().region_map.get(scope_id);\n+        for self.walk_loans(par_scope_id) { |old_loan|\n+            for (*new_loanss).each { |new_loans|\n+                for (*new_loans).each { |new_loan|\n+                    if old_loan.lp != new_loan.lp { cont; }\n+                    alt (old_loan.mutbl, new_loan.mutbl) {\n+                      (m_const, _) | (_, m_const) |\n+                      (m_mutbl, m_mutbl) | (m_imm, m_imm) {\n+                        /*ok*/\n+                      }\n+\n+                      (m_mutbl, m_imm) | (m_imm, m_mutbl) {\n+                        self.bccx.span_err(\n+                            new_loan.cmt.span,\n+                            #fmt[\"loan of %s as %s \\\n+                                  conflicts with prior loan\",\n+                                 self.bccx.cmt_to_str(new_loan.cmt),\n+                                 self.bccx.mut_to_str(new_loan.mutbl)]);\n+                        self.bccx.span_note(\n+                            old_loan.cmt.span,\n+                            #fmt[\"prior loan as %s granted here\",\n+                                 self.bccx.mut_to_str(old_loan.mutbl)]);\n+                      }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn is_local_variable(cmt: cmt) -> bool {\n+        alt cmt.cat {\n+          cat_local(_) {true}\n+          _ {false}\n+        }\n+    }\n+\n+    fn is_self_field(cmt: cmt) -> bool {\n+        alt cmt.cat {\n+          cat_comp(cmt_base, comp_field(_)) {\n+            alt cmt_base.cat {\n+              cat_special(sk_self) { true }\n+              _ { false }\n+            }\n+          }\n+          _ { false }\n+        }\n+    }\n+\n+    fn check_assignment(at: assignment_type, ex: @ast::expr) {\n+        let cmt = self.bccx.cat_expr(ex);\n+\n+        #debug[\"check_assignment(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)];\n+\n+        if self.in_ctor && self.is_self_field(cmt)\n+            && at.checked_by_liveness() {\n+            // assigning to self.foo in a ctor is always allowed.\n+        } else if self.is_local_variable(cmt) && at.checked_by_liveness() {\n+            // liveness guarantees that immutable local variables\n+            // are only assigned once\n+        } else {\n+            alt cmt.mutbl {\n+              m_mutbl { /*ok*/ }\n+              m_const | m_imm {\n+                self.bccx.span_err(\n+                    ex.span,\n+                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n+                ret;\n+              }\n+            }\n+        }\n+\n+        // if this is a pure function, only loan-able state can be\n+        // assigned, because it is uniquely tied to this function and\n+        // is not visible from the outside\n+        alt self.purity(ex.id) {\n+          none {}\n+          some(pc) {\n+            if cmt.lp.is_none() {\n+                self.report_purity_error(\n+                    pc, ex.span, at.ing_form(self.bccx.cmt_to_str(cmt)));\n+            }\n+          }\n+        }\n+\n+        // check for a conflicting loan as well, except in the case of\n+        // taking a mutable ref.  that will create a loan of its own\n+        // which will be checked for compat separately in\n+        // check_for_conflicting_loans()\n+        if at != at_mutbl_ref {\n+            let lp = alt cmt.lp {\n+              none { ret; }\n+              some(lp) { lp }\n+            };\n+            for self.walk_loans_of(ex.id, lp) { |loan|\n+                alt loan.mutbl {\n+                  m_mutbl | m_const { /*ok*/ }\n+                  m_imm {\n+                    self.bccx.span_err(\n+                        ex.span,\n+                        #fmt[\"%s prohibited due to outstanding loan\",\n+                             at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+                    self.bccx.span_note(\n+                        loan.cmt.span,\n+                        #fmt[\"loan of %s granted here\",\n+                             self.bccx.cmt_to_str(loan.cmt)]);\n+                    ret;\n+                  }\n+                }\n+            }\n+        }\n+\n+        self.bccx.add_to_mutbl_map(cmt);\n+    }\n+\n+    fn report_purity_error(pc: purity_cause, sp: span, msg: str) {\n+        alt pc {\n+          pc_pure_fn {\n+            self.tcx().sess.span_err(\n+                sp,\n+                #fmt[\"%s prohibited in pure context\", msg]);\n+          }\n+          pc_cmt(e) {\n+            if self.reported.insert(e.cmt.id, ()) {\n+                self.tcx().sess.span_err(\n+                    e.cmt.span,\n+                    #fmt[\"illegal borrow unless pure: %s\",\n+                         self.bccx.bckerr_code_to_str(e.code)]);\n+                self.tcx().sess.span_note(\n+                    sp,\n+                    #fmt[\"impure due to %s\", msg]);\n+            }\n+          }\n+        }\n+    }\n+\n+    fn check_move_out(ex: @ast::expr) {\n+        let cmt = self.bccx.cat_expr(ex);\n+        self.check_move_out_from_cmt(cmt);\n+    }\n+\n+    fn check_move_out_from_cmt(cmt: cmt) {\n+        #debug[\"check_move_out_from_cmt(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)];\n+\n+        alt cmt.cat {\n+          // Rvalues, locals, and arguments can be moved:\n+          cat_rvalue | cat_local(_) | cat_arg(_) { }\n+\n+          // We allow moving out of static items because the old code\n+          // did.  This seems consistent with permitting moves out of\n+          // rvalues, I guess.\n+          cat_special(sk_static_item) { }\n+\n+          // Nothing else.\n+          _ {\n+            self.bccx.span_err(\n+                cmt.span,\n+                #fmt[\"moving out of %s\", self.bccx.cmt_to_str(cmt)]);\n+            ret;\n+          }\n+        }\n+\n+        self.bccx.add_to_mutbl_map(cmt);\n+\n+        // check for a conflicting loan:\n+        let lp = alt cmt.lp {\n+          none { ret; }\n+          some(lp) { lp }\n+        };\n+        for self.walk_loans_of(cmt.id, lp) { |loan|\n+            self.bccx.span_err(\n+                cmt.span,\n+                #fmt[\"moving out of %s prohibited due to outstanding loan\",\n+                     self.bccx.cmt_to_str(cmt)]);\n+            self.bccx.span_note(\n+                loan.cmt.span,\n+                #fmt[\"loan of %s granted here\",\n+                     self.bccx.cmt_to_str(loan.cmt)]);\n+            ret;\n+        }\n+    }\n+}\n+\n+fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n+                     sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n+                     visitor: visit::vt<check_loan_ctxt>) {\n+\n+    #debug[\"purity on entry=%?\", self.declared_purity];\n+    save_and_restore(self.in_ctor) {||\n+        save_and_restore(self.declared_purity) {||\n+            save_and_restore(self.fn_args) {||\n+                let is_stack_closure = self.is_stack_closure(id);\n+\n+                // In principle, we could consider fk_anon(*) or\n+                // fk_fn_block(*) to be in a ctor, I suppose, but the\n+                // purpose of the in_ctor flag is to allow modifications\n+                // of otherwise immutable fields and typestate wouldn't be\n+                // able to \"see\" into those functions anyway, so it\n+                // wouldn't be very helpful.\n+                alt fk {\n+                  visit::fk_ctor(*) {\n+                    self.in_ctor = true;\n+                    self.declared_purity = decl.purity;\n+                    self.fn_args = decl.inputs.map({|i| i.id});\n+                  }\n+                  visit::fk_anon(*) |\n+                  visit::fk_fn_block(*) if is_stack_closure {\n+                    self.in_ctor = false;\n+                    // inherits the purity/fn_args from enclosing ctxt\n+                  }\n+                  visit::fk_anon(*) | visit::fk_fn_block(*) |\n+                  visit::fk_method(*) | visit::fk_item_fn(*) |\n+                  visit::fk_res(*) | visit::fk_dtor(*) {\n+                    self.in_ctor = false;\n+                    self.declared_purity = decl.purity;\n+                    self.fn_args = decl.inputs.map({|i| i.id});\n+                  }\n+                }\n+\n+                visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+            }\n+        }\n+    }\n+    #debug[\"purity on exit=%?\", self.declared_purity];\n+}\n+\n+fn check_loans_in_expr(expr: @ast::expr,\n+                       &&self: check_loan_ctxt,\n+                       vt: visit::vt<check_loan_ctxt>) {\n+    self.check_for_conflicting_loans(expr.id);\n+\n+    alt expr.node {\n+      ast::expr_swap(l, r) {\n+        self.check_assignment(at_swap, l);\n+        self.check_assignment(at_swap, r);\n+      }\n+      ast::expr_move(dest, src) {\n+        self.check_assignment(at_straight_up, dest);\n+        self.check_move_out(src);\n+      }\n+      ast::expr_assign(dest, _) |\n+      ast::expr_assign_op(_, dest, _) {\n+        self.check_assignment(at_straight_up, dest);\n+      }\n+      ast::expr_fn(_, _, _, cap_clause) |\n+      ast::expr_fn_block(_, _, cap_clause) {\n+        for (*cap_clause).each { |cap_item|\n+            if cap_item.is_move {\n+                let def = self.tcx().def_map.get(cap_item.id);\n+\n+                // Hack: the type that is used in the cmt doesn't actually\n+                // matter here, so just subst nil instead of looking up\n+                // the type of the def that is referred to\n+                let cmt = self.bccx.cat_def(cap_item.id, cap_item.span,\n+                                            ty::mk_nil(self.tcx()), def);\n+                self.check_move_out_from_cmt(cmt);\n+            }\n+        }\n+      }\n+      ast::expr_addr_of(mutbl, base) {\n+        alt mutbl {\n+          m_const { /*all memory is const*/ }\n+          m_mutbl {\n+            // If we are taking an &mut ptr, make sure the memory\n+            // being pointed at is assignable in the first place:\n+            self.check_assignment(at_mutbl_ref, base);\n+          }\n+          m_imm {\n+            // XXX explain why no check is req'd here\n+          }\n+        }\n+      }\n+      ast::expr_call(f, args, _) {\n+        alt self.purity(expr.id) {\n+          none {}\n+          some(pc) {\n+            self.check_pure_callee_or_arg(pc, f);\n+            for args.each { |arg| self.check_pure_callee_or_arg(pc, arg) }\n+          }\n+        }\n+        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_move {\n+                self.check_move_out(arg);\n+              }\n+              ast::by_mutbl_ref {\n+                self.check_assignment(at_mutbl_ref, arg);\n+              }\n+              ast::by_ref | ast::by_copy | ast::by_val {\n+              }\n+            }\n+        }\n+      }\n+      _ { }\n+    }\n+\n+    visit::visit_expr(expr, self, vt);\n+}\n+\n+fn check_loans_in_block(blk: ast::blk,\n+                        &&self: check_loan_ctxt,\n+                        vt: visit::vt<check_loan_ctxt>) {\n+    save_and_restore(self.declared_purity) {||\n+        self.check_for_conflicting_loans(blk.node.id);\n+\n+        alt blk.node.rules {\n+          ast::default_blk {\n+          }\n+          ast::unchecked_blk {\n+            self.declared_purity = ast::impure_fn;\n+          }\n+          ast::unsafe_blk {\n+            self.declared_purity = ast::unsafe_fn;\n+          }\n+        }\n+\n+        visit::visit_block(blk, self, vt);\n+    }\n+}\n+"}, {"sha": "04ea50bee03dd520c40c6d8a410ecc71f8b233e4", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -0,0 +1,325 @@\n+// ----------------------------------------------------------------------\n+// Gathering loans\n+//\n+// The borrow check proceeds in two phases. In phase one, we gather the full\n+// set of loans that are required at any point.  These are sorted according to\n+// their associated scopes.  In phase two, checking loans, we will then make\n+// sure that all of these loans are honored.\n+\n+import categorization::public_methods;\n+import loan::public_methods;\n+import preserve::public_methods;\n+\n+export gather_loans;\n+\n+enum gather_loan_ctxt = @{bccx: borrowck_ctxt, req_maps: req_maps};\n+\n+fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n+    let glcx = gather_loan_ctxt(@{bccx: bccx,\n+                                  req_maps: {req_loan_map: int_hash(),\n+                                             pure_map: int_hash()}});\n+    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr\n+                           with *visit::default_visitor()});\n+    visit::visit_crate(*crate, glcx, v);\n+    ret glcx.req_maps;\n+}\n+\n+fn req_loans_in_expr(ex: @ast::expr,\n+                     &&self: gather_loan_ctxt,\n+                     vt: visit::vt<gather_loan_ctxt>) {\n+    let bccx = self.bccx;\n+    let tcx = bccx.tcx;\n+\n+    // If this expression is borrowed, have to ensure it remains valid:\n+    for tcx.borrowings.find(ex.id).each { |borrow|\n+        let cmt = self.bccx.cat_borrow_of_expr(ex);\n+        let scope_r = ty::re_scope(borrow.scope_id);\n+        self.guarantee_valid(cmt, borrow.mutbl, scope_r);\n+    }\n+\n+    // Special checks for various kinds of expressions:\n+    alt ex.node {\n+      ast::expr_addr_of(mutbl, base) {\n+        let base_cmt = self.bccx.cat_expr(base);\n+\n+        // make sure that the thing we are pointing out stays valid\n+        // for the lifetime `scope_r` of the resulting ptr:\n+        let scope_r =\n+            alt check ty::get(tcx.ty(ex)).struct {\n+              ty::ty_rptr(r, _) { r }\n+            };\n+        self.guarantee_valid(base_cmt, mutbl, scope_r);\n+      }\n+\n+      ast::expr_call(f, args, _) {\n+        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        let scope_r = ty::re_scope(ex.id);\n+        vec::iter2(args, arg_tys) { |arg, arg_ty|\n+            alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n+              ast::by_mutbl_ref {\n+                let arg_cmt = self.bccx.cat_expr(arg);\n+                self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n+              }\n+              ast::by_ref {\n+                let arg_cmt = self.bccx.cat_expr(arg);\n+                self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n+              }\n+              ast::by_move | ast::by_copy | ast::by_val {}\n+            }\n+        }\n+      }\n+\n+      ast::expr_alt(ex_v, arms, _) {\n+        let cmt = self.bccx.cat_expr(ex_v);\n+        for arms.each { |arm|\n+            for arm.pats.each { |pat|\n+                self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n+            }\n+        }\n+      }\n+\n+      _ { /*ok*/ }\n+    }\n+\n+    // Check any contained expressions:\n+    visit::visit_expr(ex, self, vt);\n+}\n+\n+impl methods for gather_loan_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n+    // guarantees that addr_of(cmt) will be valid for the duration of\n+    // `static_scope_r`, or reports an error.  This may entail taking\n+    // out loans, which will be added to the `req_loan_map`.  This can\n+    // also entail \"rooting\" GC'd pointers, which means ensuring\n+    // dynamically that they are not freed.\n+    fn guarantee_valid(cmt: cmt,\n+                       req_mutbl: ast::mutability,\n+                       scope_r: ty::region) {\n+\n+        #debug[\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n+               self.bccx.cmt_to_repr(cmt),\n+               self.bccx.mut_to_str(req_mutbl),\n+               region_to_str(self.tcx(), scope_r)];\n+        let _i = indenter();\n+\n+        alt cmt.lp {\n+          // If this expression is a loanable path, we MUST take out a loan.\n+          // This is somewhat non-obvious.  You might think, for example, that\n+          // if we have an immutable local variable `x` whose value is being\n+          // borrowed, we could rely on `x` not to change.  This is not so,\n+          // however, because even immutable locals can be moved.  So we take\n+          // out a loan on `x`, guaranteeing that it remains immutable for the\n+          // duration of the reference: if there is an attempt to move it\n+          // within that scope, the loan will be detected and an error will be\n+          // reported.\n+          some(_) {\n+            alt scope_r {\n+              ty::re_scope(scope_id) {\n+                let loans = self.bccx.loan(cmt, req_mutbl);\n+                self.add_loans(scope_id, loans);\n+              }\n+              _ {\n+                self.bccx.span_err(\n+                    cmt.span,\n+                    #fmt[\"cannot guarantee the stability \\\n+                          of this expression for the entirety of \\\n+                          its lifetime, %s\",\n+                         region_to_str(self.tcx(), scope_r)]);\n+              }\n+            }\n+          }\n+\n+          // The path is not loanable: in that case, we must try and preserve\n+          // it dynamically (or see that it is preserved by virtue of being\n+          // rooted in some immutable path)\n+          none {\n+            let opt_scope_id = alt scope_r {\n+              ty::re_scope(scope_id) { some(scope_id) }\n+              _ { none }\n+            };\n+\n+            let result = {\n+                self.check_mutbl(req_mutbl, cmt).chain { |_ok|\n+                    self.bccx.preserve(cmt, opt_scope_id)\n+                }\n+            };\n+\n+            alt result {\n+              ok(()) {\n+                // we were able guarantee the validity of the ptr,\n+                // perhaps by rooting or because it is immutably\n+                // rooted.  good.\n+              }\n+              err(e) {\n+                // not able to guarantee the validity of the ptr.\n+                // rather than report an error, presuming that the\n+                // borrow is for a limited scope, we'll make one last\n+                // ditch effort and require that the scope where the\n+                // borrow occurs be pure.\n+                alt opt_scope_id {\n+                  some(scope_id) {\n+                    self.req_maps.pure_map.insert(scope_id, e);\n+                  }\n+                  none {\n+                    // otherwise, fine, I give up.\n+                    self.bccx.report(e);\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+    }\n+\n+    // Check that the pat `cmt` is compatible with the required\n+    // mutability, presuming that it can be preserved to stay alive\n+    // long enough.\n+    //\n+    // For example, if you have an expression like `&x.f` where `x`\n+    // has type `@mut{f:int}`, this check might fail because `&x.f`\n+    // reqires an immutable pointer, but `f` lives in (aliased)\n+    // mutable memory.\n+    fn check_mutbl(req_mutbl: ast::mutability,\n+                   cmt: cmt) -> bckres<()> {\n+        alt (req_mutbl, cmt.mutbl) {\n+          (m_const, _) |\n+          (m_imm, m_imm) |\n+          (m_mutbl, m_mutbl) {\n+            ok(())\n+          }\n+\n+          (_, m_const) |\n+          (m_imm, m_mutbl) |\n+          (m_mutbl, m_imm) {\n+            err({cmt: cmt,\n+                 code: err_mutbl(req_mutbl, cmt.mutbl)})\n+          }\n+        }\n+    }\n+\n+    fn add_loans(scope_id: ast::node_id, loans: @const [loan]) {\n+        alt self.req_maps.req_loan_map.find(scope_id) {\n+          some(l) {\n+            *l += [loans];\n+          }\n+          none {\n+            self.req_maps.req_loan_map.insert(scope_id, @mut [loans]);\n+          }\n+        }\n+    }\n+\n+    fn gather_pat(cmt: cmt, pat: @ast::pat,\n+                  arm_id: ast::node_id, alt_id: ast::node_id) {\n+\n+        // Here, `cmt` is the categorization for the value being\n+        // matched and pat is the pattern it is being matched against.\n+        //\n+        // In general, the way that this works is that we walk down\n+        // the pattern, constructing a cmt that represents the path\n+        // that will be taken to reach the value being matched.\n+        //\n+        // When we encounter named bindings, we take the cmt that has\n+        // been built up and pass it off to guarantee_valid() so that\n+        // we can be sure that the binding will remain valid for the\n+        // duration of the arm.\n+        //\n+        // The correspondence between the id in the cmt and which\n+        // pattern is being referred to is somewhat...subtle.  In\n+        // general, the id of the cmt is the id of the node that\n+        // produces the value.  For patterns, that's actually the\n+        // *subpattern*, generally speaking.\n+        //\n+        // To see what I mean about ids etc, consider:\n+        //\n+        //     let x = @@3;\n+        //     alt x {\n+        //       @@y { ... }\n+        //     }\n+        //\n+        // Here the cmt for `y` would be something like\n+        //\n+        //     local(x)->@->@\n+        //\n+        // where the id of `local(x)` is the id of the `x` that appears\n+        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n+        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n+\n+        #debug[\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n+               pat.id, pprust::pat_to_str(pat),\n+               self.bccx.cmt_to_repr(cmt), arm_id, alt_id];\n+        let _i = indenter();\n+\n+        let tcx = self.tcx();\n+        alt pat.node {\n+          ast::pat_wild {\n+            // _\n+          }\n+\n+          ast::pat_enum(_, none) {\n+            // variant(*)\n+          }\n+          ast::pat_enum(_, some(subpats)) {\n+            // variant(x, y, z)\n+            for subpats.each { |subpat|\n+                let subcmt = self.bccx.cat_variant(subpat, cmt);\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n+            }\n+          }\n+\n+          ast::pat_ident(_, none) if self.pat_is_variant(pat) {\n+            // nullary variant\n+            #debug[\"nullary variant\"];\n+          }\n+          ast::pat_ident(id, o_pat) {\n+            // x or x @ p --- `x` must remain valid for the scope of the alt\n+            #debug[\"defines identifier %s\", pprust::path_to_str(id)];\n+\n+            // Note: there is a discussion of the function of\n+            // cat_discr in the method preserve():\n+            let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n+            let arm_scope = ty::re_scope(arm_id);\n+            self.guarantee_valid(cmt1, m_const, arm_scope);\n+\n+            for o_pat.each { |p|\n+                self.gather_pat(cmt, p, arm_id, alt_id);\n+            }\n+          }\n+\n+          ast::pat_rec(field_pats, _) {\n+            // {f1: p1, ..., fN: pN}\n+            for field_pats.each { |fp|\n+                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n+                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n+            }\n+          }\n+\n+          ast::pat_tup(subpats) {\n+            // (p1, ..., pN)\n+            for subpats.each { |subpat|\n+                let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n+            }\n+          }\n+\n+          ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n+            // @p1, ~p1\n+            alt self.bccx.cat_deref(subpat, cmt, 0u, true) {\n+              some(subcmt) {\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n+              }\n+              none {\n+                tcx.sess.span_bug(pat.span, \"Non derefable type\");\n+              }\n+            }\n+          }\n+\n+          ast::pat_lit(_) | ast::pat_range(_, _) { /*always ok*/ }\n+        }\n+    }\n+\n+    fn pat_is_variant(pat: @ast::pat) -> bool {\n+        pat_util::pat_is_variant(self.bccx.tcx.def_map, pat)\n+    }\n+}\n+"}, {"sha": "26682661aada9cbf882274a4fb78d78ec25180a2", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -0,0 +1,97 @@\n+// ----------------------------------------------------------------------\n+// Loan(Ex, M, S) = Ls holds if ToAddr(Ex) will remain valid for the entirety\n+// of the scope S, presuming that the returned set of loans `Ls` are honored.\n+\n+export public_methods;\n+\n+impl public_methods for borrowck_ctxt {\n+    fn loan(cmt: cmt, mutbl: ast::mutability) -> @const [loan] {\n+        let lc = @{bccx: self, loans: @mut []};\n+        lc.loan(cmt, mutbl);\n+        ret lc.loans;\n+    }\n+}\n+\n+type loan_ctxt = @{\n+    bccx: borrowck_ctxt,\n+    loans: @mut [loan]\n+};\n+\n+impl loan_methods for loan_ctxt {\n+    fn ok_with_loan_of(cmt: cmt,\n+                       mutbl: ast::mutability) {\n+        // Note: all cmt's that we deal with will have a non-none lp, because\n+        // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n+        // any cmt with a none-lp.\n+        *self.loans += [{lp:option::get(cmt.lp),\n+                         cmt:cmt,\n+                         mutbl:mutbl}];\n+    }\n+\n+    fn loan(cmt: cmt, req_mutbl: ast::mutability) {\n+\n+        #debug[\"loan(%s, %s)\",\n+               self.bccx.cmt_to_repr(cmt),\n+               self.bccx.mut_to_str(req_mutbl)];\n+        let _i = indenter();\n+\n+        // see stable() above; should only be called when `cmt` is lendable\n+        if cmt.lp.is_none() {\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"loan() called with non-lendable value\");\n+        }\n+\n+        alt cmt.cat {\n+          cat_rvalue | cat_special(_) {\n+            // should never be loanable\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"rvalue with a non-none lp\");\n+          }\n+          cat_local(_) | cat_arg(_) | cat_stack_upvar(_) {\n+            self.ok_with_loan_of(cmt, req_mutbl)\n+          }\n+          cat_discr(base, _) {\n+            self.loan(base, req_mutbl)\n+          }\n+          cat_comp(cmt_base, comp_field(_)) |\n+          cat_comp(cmt_base, comp_index(_)) |\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_res) {\n+            // For most components, the type of the embedded data is\n+            // stable.  Therefore, the base structure need only be\n+            // const---unless the component must be immutable.  In\n+            // that case, it must also be embedded in an immutable\n+            // location, or else the whole structure could be\n+            // overwritten and the component along with it.\n+            let base_mutbl = alt req_mutbl {\n+              m_imm { m_imm }\n+              m_const | m_mutbl { m_const }\n+            };\n+\n+            self.loan(cmt_base, base_mutbl);\n+            self.ok_with_loan_of(cmt, req_mutbl)\n+          }\n+          cat_comp(cmt1, comp_variant) |\n+          cat_deref(cmt1, _, uniq_ptr) {\n+            // Variant components: the base must be immutable, because\n+            // if it is overwritten, the types of the embedded data\n+            // could change.\n+            //\n+            // Unique pointers: the base must be immutable, because if\n+            // it is overwritten, the unique content will be freed.\n+            self.loan(cmt1, m_imm);\n+            self.ok_with_loan_of(cmt, req_mutbl)\n+          }\n+          cat_deref(cmt1, _, unsafe_ptr) |\n+          cat_deref(cmt1, _, gc_ptr) |\n+          cat_deref(cmt1, _, region_ptr) {\n+            // Aliased data is simply not lendable.\n+            self.bccx.tcx.sess.span_bug(\n+                cmt.span,\n+                \"aliased ptr with a non-none lp\");\n+          }\n+        }\n+    }\n+}"}, {"sha": "d79c9b480e54834e4085cdad6c621f8141dce21d", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -0,0 +1,151 @@\n+// ----------------------------------------------------------------------\n+// Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n+// the scope S.\n+export public_methods;\n+\n+impl public_methods for borrowck_ctxt {\n+    fn preserve(cmt: cmt, opt_scope_id: option<ast::node_id>) -> bckres<()> {\n+        #debug[\"preserve(%s)\", self.cmt_to_repr(cmt)];\n+        let _i = indenter();\n+\n+        alt cmt.cat {\n+          cat_rvalue | cat_special(_) {\n+            ok(())\n+          }\n+          cat_stack_upvar(cmt) {\n+            self.preserve(cmt, opt_scope_id)\n+          }\n+          cat_local(_) {\n+            // This should never happen.  Local variables are always lendable,\n+            // so either `loan()` should be called or there must be some\n+            // intermediate @ or &---they are not lendable but do not recurse.\n+            self.tcx.sess.span_bug(\n+                cmt.span,\n+                \"preserve() called with local\");\n+          }\n+          cat_arg(_) {\n+            // This can happen as not all args are lendable (e.g., &&\n+            // modes).  In that case, the caller guarantees stability.\n+            // This is basically a deref of a region ptr.\n+            ok(())\n+          }\n+          cat_comp(cmt_base, comp_field(_)) |\n+          cat_comp(cmt_base, comp_index(_)) |\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_res) {\n+            // Most embedded components: if the base is stable, the\n+            // type never changes.\n+            self.preserve(cmt_base, opt_scope_id)\n+          }\n+          cat_comp(cmt1, comp_variant) {\n+            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_variant)\n+          }\n+          cat_deref(cmt1, _, uniq_ptr) {\n+            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_uniq)\n+          }\n+          cat_deref(_, _, region_ptr) {\n+            // References are always \"stable\" by induction (when the\n+            // reference of type &MT was created, the memory must have\n+            // been stable)\n+            ok(())\n+          }\n+          cat_deref(_, _, unsafe_ptr) {\n+            // Unsafe pointers are the user's problem\n+            ok(())\n+          }\n+          cat_deref(base, derefs, gc_ptr) {\n+            // GC'd pointers of type @MT: always stable because we can\n+            // inc the ref count or keep a GC root as necessary.  We\n+            // need to insert this id into the root_map, however.\n+            alt opt_scope_id {\n+              some(scope_id) {\n+                #debug[\"Inserting root map entry for %s: \\\n+                        node %d:%u -> scope %d\",\n+                       self.cmt_to_repr(cmt), base.id,\n+                       derefs, scope_id];\n+\n+                let rk = {id: base.id, derefs: derefs};\n+                self.root_map.insert(rk, scope_id);\n+                ok(())\n+              }\n+              none {\n+                err({cmt:cmt, code:err_preserve_gc})\n+              }\n+            }\n+          }\n+          cat_discr(base, alt_id) {\n+            // Subtle: in an alt, we must ensure that each binding\n+            // variable remains valid for the duration of the arm in\n+            // which it appears, presuming that this arm is taken.\n+            // But it is inconvenient in trans to root something just\n+            // for one arm.  Therefore, we insert a cat_discr(),\n+            // basically a special kind of category that says \"if this\n+            // value must be dynamically rooted, root it for the scope\n+            // `alt_id`.\n+            //\n+            // As an example, consider this scenario:\n+            //\n+            //    let mut x = @some(3);\n+            //    alt *x { some(y) {...} none {...} }\n+            //\n+            // Technically, the value `x` need only be rooted\n+            // in the `some` arm.  However, we evaluate `x` in trans\n+            // before we know what arm will be taken, so we just\n+            // always root it for the duration of the alt.\n+            //\n+            // As a second example, consider *this* scenario:\n+            //\n+            //    let x = @mut @some(3);\n+            //    alt x { @@some(y) {...} @@none {...} }\n+            //\n+            // Here again, `x` need only be rooted in the `some` arm.\n+            // In this case, the value which needs to be rooted is\n+            // found only when checking which pattern matches: but\n+            // this check is done before entering the arm.  Therefore,\n+            // even in this case we just choose to keep the value\n+            // rooted for the entire alt.  This means the value will be\n+            // rooted even if the none arm is taken.  Oh well.\n+            //\n+            // At first, I tried to optimize the second case to only\n+            // root in one arm, but the result was suboptimal: first,\n+            // it interfered with the construction of phi nodes in the\n+            // arm, as we were adding code to root values before the\n+            // phi nodes were added.  This could have been addressed\n+            // with a second basic block.  However, the naive approach\n+            // also yielded suboptimal results for patterns like:\n+            //\n+            //    let x = @mut @...;\n+            //    alt x { @@some_variant(y) | @@some_other_variant(y) {...} }\n+            //\n+            // The reason is that we would root the value once for\n+            // each pattern and not once per arm.  This is also easily\n+            // fixed, but it's yet more code for what is really quite\n+            // the corner case.\n+            //\n+            // Nonetheless, if you decide to optimize this case in the\n+            // future, you need only adjust where the cat_discr()\n+            // node appears to draw the line between what will be rooted\n+            // in the *arm* vs the *alt*.\n+\n+            // current scope must be the arm, which is always a child of alt:\n+            assert self.tcx.region_map.get(opt_scope_id.get()) == alt_id;\n+\n+            self.preserve(base, some(alt_id))\n+          }\n+        }\n+    }\n+}\n+\n+impl private_methods for borrowck_ctxt {\n+    fn require_imm(cmt: cmt,\n+                   cmt1: cmt,\n+                   opt_scope_id: option<ast::node_id>,\n+                   code: bckerr_code) -> bckres<()> {\n+        // Variant contents and unique pointers: must be immutably\n+        // rooted to a preserved address.\n+        alt cmt1.mutbl {\n+          m_mutbl | m_const { err({cmt:cmt, code:code}) }\n+          m_imm { self.preserve(cmt1, opt_scope_id) }\n+        }\n+    }\n+}"}, {"sha": "6a4d447af23402808d57c6ba29e1cf2fdb75ce0a", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6c6ad229a3d52f9f059086e1b670aa4d75566094/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=6c6ad229a3d52f9f059086e1b670aa4d75566094", "patch": "@@ -69,7 +69,13 @@ mod middle {\n     mod check_alt;\n     mod check_const;\n     mod lint;\n-    mod borrowck;\n+    mod borrowck {\n+        mod check_loans;\n+        mod gather_loans;\n+        mod categorization;\n+        mod loan;\n+        mod preserve;\n+    }\n     mod alias;\n     mod liveness;\n     mod block_use;"}]}