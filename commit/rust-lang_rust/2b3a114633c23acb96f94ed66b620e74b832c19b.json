{"sha": "2b3a114633c23acb96f94ed66b620e74b832c19b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiM2ExMTQ2MzNjMjNhY2I5NmY5NGVkNjZiNjIwZTc0YjgzMmMxOWI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-09T01:10:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-09T01:10:09Z"}, "message": "Rollup merge of #71942 - nnethercote:shrink-LocalDecl, r=matthewjasper\n\nShrink `LocalDecl`\n\n`LocalDecl` contributes 4-8% of peak heap memory usage on a range of benchmarks. This PR reduces its size from 128 bytes to 56 bytes on 64-bit, and does some clean-ups as well.\n\nr? @matthewjasper", "tree": {"sha": "5903be7640d312c9d2b581d53889a07de713b011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5903be7640d312c9d2b581d53889a07de713b011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b3a114633c23acb96f94ed66b620e74b832c19b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetgLxCRBK7hj4Ov3rIwAAdHIIAEDwPF55ItSoKlsvHNOVnasu\nMo+rsLzjdMrFXPt9wlOvNFzLMNTqdCW4yGcuYHZ4biYUR6gkvk8qkLqQglf3fhFt\nVFD7x7zIVtH7nJAtJQ5xb3vOfR3r1oWrQHqxPqi7dyFeawbufVTup18bdXl1j27w\n30sXiictthl9x4v2lwutUjf8RwcdDD4cIHonUDOY8JTzmb3VikWd5X/Z4aYX9UXe\n28YwWmqEPHFo16reGu0C2j7hR4wE5YAjDDsjfOnL/N1E1nvj2EhZVCp+0vWYEZfu\n7sPX3a5zmD47o9/TJPBGSErv/p2A5GM9QoJhcKWvD7erAHiA2kaedlgmpreXVyk=\n=RsRz\n-----END PGP SIGNATURE-----\n", "payload": "tree 5903be7640d312c9d2b581d53889a07de713b011\nparent d16d02b0114bbe86e5b674bf15b324cf7805b059\nparent 001496c0ebb27373ace8bd019b78b3f02ce531d1\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588986609 +0200\ncommitter GitHub <noreply@github.com> 1588986609 +0200\n\nRollup merge of #71942 - nnethercote:shrink-LocalDecl, r=matthewjasper\n\nShrink `LocalDecl`\n\n`LocalDecl` contributes 4-8% of peak heap memory usage on a range of benchmarks. This PR reduces its size from 128 bytes to 56 bytes on 64-bit, and does some clean-ups as well.\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3a114633c23acb96f94ed66b620e74b832c19b", "html_url": "https://github.com/rust-lang/rust/commit/2b3a114633c23acb96f94ed66b620e74b832c19b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b3a114633c23acb96f94ed66b620e74b832c19b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d16d02b0114bbe86e5b674bf15b324cf7805b059", "url": "https://api.github.com/repos/rust-lang/rust/commits/d16d02b0114bbe86e5b674bf15b324cf7805b059", "html_url": "https://github.com/rust-lang/rust/commit/d16d02b0114bbe86e5b674bf15b324cf7805b059"}, {"sha": "001496c0ebb27373ace8bd019b78b3f02ce531d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/001496c0ebb27373ace8bd019b78b3f02ce531d1", "html_url": "https://github.com/rust-lang/rust/commit/001496c0ebb27373ace8bd019b78b3f02ce531d1"}], "stats": {"total": 473, "additions": 206, "deletions": 267}, "files": [{"sha": "15862660512262811e6c3f27829f92d35792e75f", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -474,6 +474,13 @@ pub struct SourceInfo {\n     pub scope: SourceScope,\n }\n \n+impl SourceInfo {\n+    #[inline]\n+    pub fn outermost(span: Span) -> Self {\n+        SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Borrow kinds\n \n@@ -689,7 +696,7 @@ pub struct LocalDecl<'tcx> {\n     pub mutability: Mutability,\n \n     // FIXME(matthewjasper) Don't store in this in `Body`\n-    pub local_info: LocalInfo<'tcx>,\n+    pub local_info: Option<Box<LocalInfo<'tcx>>>,\n \n     /// `true` if this is an internal local.\n     ///\n@@ -725,7 +732,7 @@ pub struct LocalDecl<'tcx> {\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n     // FIXME(matthewjasper) Don't store in this in `Body`\n-    pub user_ty: UserTypeProjections,\n+    pub user_ty: Option<Box<UserTypeProjections>>,\n \n     /// The *syntactic* (i.e., not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n@@ -809,7 +816,13 @@ pub struct LocalDecl<'tcx> {\n     pub source_info: SourceInfo,\n }\n \n-/// Extra information about a local that's used for diagnostics.\n+// `LocalDecl` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(LocalDecl<'_>, 56);\n+\n+/// Extra information about a some locals that's used for diagnostics. (Not\n+/// used for non-StaticRef temporaries, the return place, or anonymous function\n+/// parameters.)\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub enum LocalInfo<'tcx> {\n     /// A user-defined local variable or function parameter\n@@ -820,8 +833,6 @@ pub enum LocalInfo<'tcx> {\n     User(ClearCrossCrate<BindingForm<'tcx>>),\n     /// A temporary created that references the static with the given `DefId`.\n     StaticRef { def_id: DefId, is_thread_local: bool },\n-    /// Any other temporary, the return place, or an anonymous function parameter.\n-    Other,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -833,16 +844,16 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n-            }))) => true,\n+            })))) => true,\n \n-            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n                 ImplicitSelfKind::Imm,\n-            ))) => true,\n+            )))) => true,\n \n             _ => false,\n         }\n@@ -853,14 +864,14 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n-            }))) => true,\n+            })))) => true,\n \n-            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_)))) => true,\n \n             _ => false,\n         }\n@@ -871,7 +882,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     #[inline]\n     pub fn is_user_variable(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::User(_) => true,\n+            Some(box LocalInfo::User(_)) => true,\n             _ => false,\n         }\n     }\n@@ -881,7 +892,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard))) => true,\n             _ => false,\n         }\n     }\n@@ -890,7 +901,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// access that static\n     pub fn is_ref_to_static(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::StaticRef { .. } => true,\n+            Some(box LocalInfo::StaticRef { .. }) => true,\n             _ => false,\n         }\n     }\n@@ -899,7 +910,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// access that static\n     pub fn is_ref_to_thread_local(&self) -> bool {\n         match self.local_info {\n-            LocalInfo::StaticRef { is_thread_local, .. } => is_thread_local,\n+            Some(box LocalInfo::StaticRef { is_thread_local, .. }) => is_thread_local,\n             _ => false,\n         }\n     }\n@@ -911,10 +922,31 @@ impl<'tcx> LocalDecl<'tcx> {\n         self.source_info.span.desugaring_kind().is_some()\n     }\n \n-    /// Creates a new `LocalDecl` for a temporary.\n+    /// Creates a new `LocalDecl` for a temporary: mutable, non-internal.\n     #[inline]\n-    pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n-        Self::new_local(ty, Mutability::Mut, false, span)\n+    pub fn new(ty: Ty<'tcx>, span: Span) -> Self {\n+        Self::with_source_info(ty, SourceInfo::outermost(span))\n+    }\n+\n+    /// Like `LocalDecl::new`, but takes a `SourceInfo` instead of a `Span`.\n+    #[inline]\n+    pub fn with_source_info(ty: Ty<'tcx>, source_info: SourceInfo) -> Self {\n+        LocalDecl {\n+            mutability: Mutability::Mut,\n+            local_info: None,\n+            internal: false,\n+            is_block_tail: None,\n+            ty,\n+            user_ty: None,\n+            source_info,\n+        }\n+    }\n+\n+    /// Converts `self` into same `LocalDecl` except tagged as internal.\n+    #[inline]\n+    pub fn internal(mut self) -> Self {\n+        self.internal = true;\n+        self\n     }\n \n     /// Converts `self` into same `LocalDecl` except tagged as immutable.\n@@ -931,41 +963,6 @@ impl<'tcx> LocalDecl<'tcx> {\n         self.is_block_tail = Some(info);\n         self\n     }\n-\n-    /// Creates a new `LocalDecl` for a internal temporary.\n-    #[inline]\n-    pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n-        Self::new_local(ty, Mutability::Mut, true, span)\n-    }\n-\n-    #[inline]\n-    fn new_local(ty: Ty<'tcx>, mutability: Mutability, internal: bool, span: Span) -> Self {\n-        LocalDecl {\n-            mutability,\n-            ty,\n-            user_ty: UserTypeProjections::none(),\n-            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            internal,\n-            local_info: LocalInfo::Other,\n-            is_block_tail: None,\n-        }\n-    }\n-\n-    /// Builds a `LocalDecl` for the return place.\n-    ///\n-    /// This must be inserted into the `local_decls` list as the first local.\n-    #[inline]\n-    pub fn new_return_place(return_ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n-        LocalDecl {\n-            mutability: Mutability::Mut,\n-            ty: return_ty,\n-            user_ty: UserTypeProjections::none(),\n-            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n-            internal: false,\n-            is_block_tail: None,\n-            local_info: LocalInfo::Other,\n-        }\n-    }\n }\n \n /// Debug information pertaining to a user variable.\n@@ -1406,10 +1403,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n         let mut gap = self.statements.len()..self.statements.len() + extra_stmts;\n         self.statements.resize(\n             gap.end,\n-            Statement {\n-                source_info: SourceInfo { span: DUMMY_SP, scope: OUTERMOST_SOURCE_SCOPE },\n-                kind: StatementKind::Nop,\n-            },\n+            Statement { source_info: SourceInfo::outermost(DUMMY_SP), kind: StatementKind::Nop },\n         );\n         for (splice_start, new_stmts) in splices.into_iter().rev() {\n             let splice_end = splice_start + new_stmts.size_hint().0;\n@@ -2457,14 +2451,18 @@ impl Constant<'tcx> {\n /// &'static str`.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct UserTypeProjections {\n-    pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n+    pub contents: Vec<(UserTypeProjection, Span)>,\n }\n \n impl<'tcx> UserTypeProjections {\n     pub fn none() -> Self {\n         UserTypeProjections { contents: vec![] }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.contents.is_empty()\n+    }\n+\n     pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }"}, {"sha": "2f3d89dc02980c6c17acdf9598c9bb9efd1ad2a0", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -242,10 +242,10 @@ macro_rules! make_mir_visitor {\n             ) {\n                 let span = body.span;\n                 if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n-                    self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n-                        span,\n-                        scope: OUTERMOST_SOURCE_SCOPE,\n-                    }));\n+                    self.visit_ty(\n+                        yield_ty,\n+                        TyContext::YieldTy(SourceInfo::outermost(span))\n+                    );\n                 }\n \n                 // for best performance, we want to use an iterator rather\n@@ -263,10 +263,10 @@ macro_rules! make_mir_visitor {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)? body.return_ty(), TyContext::ReturnTy(SourceInfo {\n-                    span: body.span,\n-                    scope: OUTERMOST_SOURCE_SCOPE,\n-                }));\n+                self.visit_ty(\n+                    &$($mutability)? body.return_ty(),\n+                    TyContext::ReturnTy(SourceInfo::outermost(body.span))\n+                );\n \n                 for local in body.local_decls.indices() {\n                     self.visit_local_decl(local, & $($mutability)? body.local_decls[local]);\n@@ -715,8 +715,10 @@ macro_rules! make_mir_visitor {\n                     local,\n                     source_info: *source_info,\n                 });\n-                for (user_ty, _) in & $($mutability)? user_ty.contents {\n-                    self.visit_user_type_projection(user_ty);\n+                if let Some(user_ty) = user_ty {\n+                    for (user_ty, _) in & $($mutability)? user_ty.contents {\n+                        self.visit_user_type_projection(user_ty);\n+                    }\n                 }\n                 self.visit_source_info(source_info);\n             }"}, {"sha": "5f1c0911da2bf879d23062eee46666f069165008", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -1447,15 +1447,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n                 local_info:\n-                    LocalInfo::User(\n+                    Some(box LocalInfo::User(\n                         ClearCrossCrate::Clear\n                         | ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                             opt_match_place: None,\n                             ..\n                         })),\n-                    )\n-                    | LocalInfo::StaticRef { .. }\n-                    | LocalInfo::Other,\n+                    ))\n+                    | Some(box LocalInfo::StaticRef { .. })\n+                    | None,\n                 ..\n             })\n             | None => (self.describe_any_place(place.as_ref()), assigned_span),"}, {"sha": "c218e3906fff2fa84220b9e2202b5fd94127fcc4", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -202,7 +202,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if self.body.local_decls[local].is_ref_to_static() =>\n             {\n                 let local_info = &self.body.local_decls[local].local_info;\n-                if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n                     buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n                 } else {\n                     unreachable!();"}, {"sha": "67254811ec52a6c8f36cd7756d6f381be5219a07", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -103,14 +103,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                        if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm {\n                                 opt_match_place: Some((opt_match_place, match_span)),\n                                 binding_mode: _,\n                                 opt_ty_info: _,\n                                 pat_span: _,\n                             },\n-                        ))) = local_decl.local_info\n+                        )))) = local_decl.local_info\n                         {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n@@ -482,10 +482,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                pat_span,\n-                ..\n-            }))) = bind_to.local_info\n+            if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                VarBindingForm { pat_span, .. },\n+            )))) = bind_to.local_info\n             {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {"}, {"sha": "402eac47c462bdfdaf84f56cb6a46a5befed80e8", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     let local_info = &self.body.local_decls[local].local_info;\n-                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{}` is an immutable static item\", static_name);\n                     } else {\n@@ -216,9 +216,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         .local_decls\n                         .get(local)\n                         .map(|local_decl| {\n-                            if let LocalInfo::User(ClearCrossCrate::Set(\n+                            if let Some(box LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(kind),\n-                            )) = local_decl.local_info\n+                            ))) = local_decl.local_info\n                             {\n                                 // Check if the user variable is a `&mut self` and we can therefore\n                                 // suggest removing the `&mut`.\n@@ -340,16 +340,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match local_decl.local_info {\n-                            LocalInfo::User(ClearCrossCrate::Set(\n+                        let label = match local_decl.local_info.as_ref().unwrap() {\n+                            box LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(_),\n                             )) => {\n                                 let (span, suggestion) =\n                                     suggest_ampmut_self(self.infcx.tcx, local_decl);\n                                 Some((true, span, suggestion))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                            box LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n                                     binding_mode: ty::BindingMode::BindByValue(_),\n                                     opt_ty_info,\n@@ -381,14 +381,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                             self.infcx.tcx,\n                                             local_decl,\n                                             opt_assignment_rhs_span,\n-                                            opt_ty_info,\n+                                            *opt_ty_info,\n                                         );\n                                         Some((true, span, suggestion))\n                                     }\n                                 }\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                            box LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n                                     binding_mode: ty::BindingMode::BindByReference(_),\n                                     ..\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     .map(|replacement| (true, pattern_span, replacement))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Clear) => {\n+                            box LocalInfo::User(ClearCrossCrate::Clear) => {\n                                 bug!(\"saw cleared local state\")\n                             }\n "}, {"sha": "ee8a4358147cf8e4ad006e44def74f05464523e5", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -405,35 +405,38 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         self.super_local_decl(local, local_decl);\n         self.sanitize_type(local_decl, local_decl.ty);\n \n-        for (user_ty, span) in local_decl.user_ty.projections_and_spans() {\n-            let ty = if !local_decl.is_nonref_binding() {\n-                // If we have a binding of the form `let ref x: T = ..` then remove the outermost\n-                // reference so we can check the type annotation for the remaining type.\n-                if let ty::Ref(_, rty, _) = local_decl.ty.kind {\n-                    rty\n+        if let Some(user_ty) = &local_decl.user_ty {\n+            for (user_ty, span) in user_ty.projections_and_spans() {\n+                let ty = if !local_decl.is_nonref_binding() {\n+                    // If we have a binding of the form `let ref x: T = ..`\n+                    // then remove the outermost reference so we can check the\n+                    // type annotation for the remaining type.\n+                    if let ty::Ref(_, rty, _) = local_decl.ty.kind {\n+                        rty\n+                    } else {\n+                        bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n+                    }\n                 } else {\n-                    bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n-                }\n-            } else {\n-                local_decl.ty\n-            };\n+                    local_decl.ty\n+                };\n \n-            if let Err(terr) = self.cx.relate_type_and_user_type(\n-                ty,\n-                ty::Variance::Invariant,\n-                user_ty,\n-                Locations::All(*span),\n-                ConstraintCategory::TypeAnnotation,\n-            ) {\n-                span_mirbug!(\n-                    self,\n-                    local,\n-                    \"bad user type on variable {:?}: {:?} != {:?} ({:?})\",\n-                    local,\n-                    local_decl.ty,\n-                    local_decl.user_ty,\n-                    terr,\n-                );\n+                if let Err(terr) = self.cx.relate_type_and_user_type(\n+                    ty,\n+                    ty::Variance::Invariant,\n+                    user_ty,\n+                    Locations::All(*span),\n+                    ConstraintCategory::TypeAnnotation,\n+                ) {\n+                    span_mirbug!(\n+                        self,\n+                        local,\n+                        \"bad user type on variable {:?}: {:?} != {:?} ({:?})\",\n+                        local,\n+                        local_decl.ty,\n+                        local_decl.user_ty,\n+                        terr,\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "3ed0a9594e7d5e57592ed53abeaa1caa39705b12", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -16,7 +16,7 @@ use crate::dataflow::BottomValue;\n /// This is the `Body` that will be used by the `MockAnalysis` below. The shape of its CFG is not\n /// important.\n fn mock_body() -> mir::Body<'static> {\n-    let source_info = mir::SourceInfo { scope: mir::OUTERMOST_SOURCE_SCOPE, span: DUMMY_SP };\n+    let source_info = mir::SourceInfo::outermost(DUMMY_SP);\n \n     let mut blocks = IndexVec::new();\n     let mut block = |n, kind| {"}, {"sha": "847f59b95e95913dcd151aee6dbc8436607a277a", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -145,25 +145,12 @@ enum CallKind {\n     Direct(DefId),\n }\n \n-fn temp_decl(mutability: Mutability, ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n-    let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span };\n-    LocalDecl {\n-        mutability,\n-        ty,\n-        user_ty: UserTypeProjections::none(),\n-        source_info,\n-        internal: false,\n-        local_info: LocalInfo::Other,\n-        is_block_tail: None,\n-    }\n-}\n-\n fn local_decls_for_sig<'tcx>(\n     sig: &ty::FnSig<'tcx>,\n     span: Span,\n ) -> IndexVec<Local, LocalDecl<'tcx>> {\n-    iter::once(temp_decl(Mutability::Mut, sig.output(), span))\n-        .chain(sig.inputs().iter().map(|ity| temp_decl(Mutability::Not, ity, span)))\n+    iter::once(LocalDecl::new(sig.output(), span))\n+        .chain(sig.inputs().iter().map(|ity| LocalDecl::new(ity, span).immutable()))\n         .collect()\n }\n \n@@ -185,7 +172,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     let sig = tcx.erase_late_bound_regions(&sig);\n     let span = tcx.def_span(def_id);\n \n-    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n+    let source_info = SourceInfo::outermost(span);\n \n     let return_block = BasicBlock::new(1);\n     let mut blocks = IndexVec::with_capacity(2);\n@@ -374,7 +361,7 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn source_info(&self) -> SourceInfo {\n-        SourceInfo { span: self.span, scope: OUTERMOST_SOURCE_SCOPE }\n+        SourceInfo::outermost(self.span)\n     }\n \n     fn block(\n@@ -414,7 +401,11 @@ impl CloneShimBuilder<'tcx> {\n \n     fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n-        Place::from(self.local_decls.push(temp_decl(mutability, ty, span)))\n+        let mut local = LocalDecl::new(ty, span);\n+        if mutability == Mutability::Not {\n+            local = local.immutable();\n+        }\n+        Place::from(self.local_decls.push(local))\n     }\n \n     fn make_clone_call(\n@@ -498,7 +489,7 @@ impl CloneShimBuilder<'tcx> {\n         let tcx = self.tcx;\n         let span = self.span;\n \n-        let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n+        let beg = self.local_decls.push(LocalDecl::new(tcx.types.usize, span));\n         let end = self.make_place(Mutability::Not, tcx.types.usize);\n \n         // BB #0\n@@ -553,7 +544,7 @@ impl CloneShimBuilder<'tcx> {\n         // `let mut beg = 0;`\n         // goto #6;\n         let end = beg;\n-        let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n+        let beg = self.local_decls.push(LocalDecl::new(tcx.types.usize, span));\n         let init = self.make_statement(StatementKind::Assign(box (\n             Place::from(beg),\n             Rvalue::Use(Operand::Constant(self.make_usize(0))),\n@@ -687,7 +678,7 @@ fn build_call_shim<'tcx>(\n     debug!(\"build_call_shim: sig={:?}\", sig);\n \n     let mut local_decls = local_decls_for_sig(&sig, span);\n-    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n+    let source_info = SourceInfo::outermost(span);\n \n     let rcvr_place = || {\n         assert!(rcvr_adjustment.is_some());\n@@ -701,14 +692,16 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => Operand::Move(tcx.mk_place_deref(rcvr_place())),\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n-            let ref_rcvr = local_decls.push(temp_decl(\n-                Mutability::Not,\n-                tcx.mk_ref(\n-                    tcx.lifetimes.re_erased,\n-                    ty::TypeAndMut { ty: sig.inputs()[0], mutbl: hir::Mutability::Mut },\n-                ),\n-                span,\n-            ));\n+            let ref_rcvr = local_decls.push(\n+                LocalDecl::new(\n+                    tcx.mk_ref(\n+                        tcx.lifetimes.re_erased,\n+                        ty::TypeAndMut { ty: sig.inputs()[0], mutbl: hir::Mutability::Mut },\n+                    ),\n+                    span,\n+                )\n+                .immutable(),\n+            );\n             let borrow_kind = BorrowKind::Mut { allow_two_phase_borrow: false };\n             statements.push(Statement {\n                 source_info,\n@@ -849,7 +842,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     let local_decls = local_decls_for_sig(&sig, span);\n \n-    let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n+    let source_info = SourceInfo::outermost(span);\n \n     let variant_index = if adt_def.is_enum() {\n         adt_def.variant_index_with_ctor_id(ctor_id)"}, {"sha": "baa3e5e1581c5c2f2f90652690de56cf5c16a6da", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -77,11 +77,9 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // PART 1\n         // Retag arguments at the beginning of the start block.\n         {\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span, // FIXME: Consider using just the span covering the function\n-                      // argument declaration.\n-            };\n+            // FIXME: Consider using just the span covering the function\n+            // argument declaration.\n+            let source_info = SourceInfo::outermost(span);\n             // Gather all arguments, skip return value.\n             let places = local_decls\n                 .iter_enumerated()"}, {"sha": "8c005fdcdbf77f81bbcdb7ffa888c1f542dfa6b1", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -455,7 +455,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     if proj_base.is_empty() {\n                         if let (local, []) = (place_local, proj_base) {\n                             let decl = &self.body.local_decls[local];\n-                            if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                            if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n                                 let span = decl.source_info.span;\n                                 self.check_static(def_id, span);\n                                 return;"}, {"sha": "0bd9b3e1b20842d39e5b05334548b2454c386d67", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             const_context,\n             min_const_fn,\n             violations: vec![],\n-            source_info: SourceInfo { span: body.span, scope: OUTERMOST_SOURCE_SCOPE },\n+            source_info: SourceInfo::outermost(body.span),\n             tcx,\n             param_env,\n             used_unsafe: Default::default(),\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             if let [] = proj_base {\n                 let decl = &self.body.local_decls[place.local];\n                 if decl.internal {\n-                    if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n                             self.require_unsafe(\n                                 \"use of mutable static\","}, {"sha": "d334006d7b528fc3d80a640afe1422754bcf9cb3", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -255,13 +255,13 @@ impl TransformVisitor<'tcx> {\n \n     // Create a statement which reads the discriminant into a temporary\n     fn get_discr(&self, body: &mut Body<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n-        let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, body.span);\n+        let temp_decl = LocalDecl::new(self.tcx.types.isize, body.span).internal();\n         let local_decls_len = body.local_decls.push(temp_decl);\n         let temp = Place::from(local_decls_len);\n \n         let self_place = Place::from(SELF_ARG);\n         let assign = Statement {\n-            source_info: source_info(body),\n+            source_info: SourceInfo::outermost(body.span),\n             kind: StatementKind::Assign(box (temp, Rvalue::Discriminant(self_place))),\n         };\n         (assign, temp)\n@@ -395,16 +395,7 @@ fn replace_local<'tcx>(\n     body: &mut Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n-    let source_info = source_info(body);\n-    let new_decl = LocalDecl {\n-        mutability: Mutability::Mut,\n-        ty,\n-        user_ty: UserTypeProjections::none(),\n-        source_info,\n-        internal: false,\n-        is_block_tail: None,\n-        local_info: LocalInfo::Other,\n-    };\n+    let new_decl = LocalDecl::new(ty, body.span);\n     let new_local = body.local_decls.push(new_decl);\n     body.local_decls.swap(local, new_local);\n \n@@ -784,7 +775,7 @@ fn insert_switch<'tcx>(\n         targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n-    let source_info = source_info(body);\n+    let source_info = SourceInfo::outermost(body.span);\n     body.basic_blocks_mut().raw.insert(\n         0,\n         BasicBlockData {\n@@ -858,7 +849,7 @@ fn create_generator_drop_shim<'tcx>(\n     let mut body = body.clone();\n     body.arg_count = 1; // make sure the resume argument is not included here\n \n-    let source_info = source_info(&body);\n+    let source_info = SourceInfo::outermost(body.span);\n \n     let mut cases = create_cases(&mut body, transform, Operation::Drop);\n \n@@ -877,28 +868,15 @@ fn create_generator_drop_shim<'tcx>(\n     }\n \n     // Replace the return variable\n-    body.local_decls[RETURN_PLACE] = LocalDecl {\n-        mutability: Mutability::Mut,\n-        ty: tcx.mk_unit(),\n-        user_ty: UserTypeProjections::none(),\n-        source_info,\n-        internal: false,\n-        is_block_tail: None,\n-        local_info: LocalInfo::Other,\n-    };\n+    body.local_decls[RETURN_PLACE] = LocalDecl::with_source_info(tcx.mk_unit(), source_info);\n \n     make_generator_state_argument_indirect(tcx, &mut body);\n \n     // Change the generator argument from &mut to *mut\n-    body.local_decls[SELF_ARG] = LocalDecl {\n-        mutability: Mutability::Mut,\n-        ty: tcx.mk_ptr(ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut }),\n-        user_ty: UserTypeProjections::none(),\n+    body.local_decls[SELF_ARG] = LocalDecl::with_source_info(\n+        tcx.mk_ptr(ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut }),\n         source_info,\n-        internal: false,\n-        is_block_tail: None,\n-        local_info: LocalInfo::Other,\n-    };\n+    );\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type\n         body.basic_blocks_mut()[START_BLOCK].statements.insert(\n@@ -922,7 +900,7 @@ fn create_generator_drop_shim<'tcx>(\n }\n \n fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-    let source_info = source_info(body);\n+    let source_info = SourceInfo::outermost(body.span);\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind }),\n@@ -948,7 +926,7 @@ fn insert_panic_block<'tcx>(\n         cleanup: None,\n     };\n \n-    let source_info = source_info(body);\n+    let source_info = SourceInfo::outermost(body.span);\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind: term }),\n@@ -1025,7 +1003,7 @@ fn create_generator_resume_function<'tcx>(\n \n     // Poison the generator when it unwinds\n     if can_unwind {\n-        let source_info = source_info(body);\n+        let source_info = SourceInfo::outermost(body.span);\n         let poison_block = body.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![transform.set_discr(VariantIdx::new(POISONED), source_info)],\n             terminator: Some(Terminator { source_info, kind: TerminatorKind::Resume }),\n@@ -1092,10 +1070,6 @@ fn create_generator_resume_function<'tcx>(\n     dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()));\n }\n \n-fn source_info(body: &Body<'_>) -> SourceInfo {\n-    SourceInfo { span: body.span, scope: OUTERMOST_SOURCE_SCOPE }\n-}\n-\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n@@ -1104,7 +1078,7 @@ fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n         target: return_block,\n         unwind: None,\n     };\n-    let source_info = source_info(body);\n+    let source_info = SourceInfo::outermost(body.span);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     body.basic_blocks_mut().push(BasicBlockData {\n@@ -1135,7 +1109,7 @@ fn create_cases<'tcx>(\n     transform: &TransformVisitor<'tcx>,\n     operation: Operation,\n ) -> Vec<(usize, BasicBlock)> {\n-    let source_info = source_info(body);\n+    let source_info = SourceInfo::outermost(body.span);\n \n     transform\n         .suspension_points\n@@ -1241,7 +1215,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx);\n \n         // When first entering the generator, move the resume argument into its new local.\n-        let source_info = source_info(body);\n+        let source_info = SourceInfo::outermost(body.span);\n         let stmts = &mut body.basic_blocks_mut()[BasicBlock::new(0)].statements;\n         stmts.insert(\n             0,"}, {"sha": "a8e949ecb3144cc9ebc4d1af058e23ac0b7db32c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -480,7 +480,7 @@ impl Inliner<'tcx> {\n \n                     let ty = dest.ty(caller_body, self.tcx);\n \n-                    let temp = LocalDecl::new_temp(ty, callsite.location.span);\n+                    let temp = LocalDecl::new(ty, callsite.location.span);\n \n                     let tmp = caller_body.local_decls.push(temp);\n                     let tmp = Place::from(tmp);\n@@ -631,7 +631,7 @@ impl Inliner<'tcx> {\n \n         let ty = arg.ty(caller_body, self.tcx);\n \n-        let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n+        let arg_tmp = LocalDecl::new(ty, callsite.location.span);\n         let arg_tmp = caller_body.local_decls.push(arg_tmp);\n \n         let stmt = Statement {"}, {"sha": "6dade3c8dca6ca308dc8913968446936b1a4566f", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -778,7 +778,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         self.promoted.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n-                source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+                source_info: SourceInfo::outermost(span),\n                 kind: TerminatorKind::Return,\n             }),\n             is_cleanup: false,\n@@ -789,7 +789,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let last = self.promoted.basic_blocks().last().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n-            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+            source_info: SourceInfo::outermost(span),\n             kind: StatementKind::Assign(box (Place::from(dest), rvalue)),\n         });\n     }\n@@ -818,7 +818,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         }\n \n         let num_stmts = self.source[loc.block].statements.len();\n-        let new_temp = self.promoted.local_decls.push(LocalDecl::new_temp(\n+        let new_temp = self.promoted.local_decls.push(LocalDecl::new(\n             self.source.local_decls[temp].ty,\n             self.source.local_decls[temp].source_info.span,\n         ));\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let tcx = self.tcx;\n             let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n-                promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n+                promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n \n                 Operand::Constant(Box::new(Constant {\n                     span,\n@@ -966,7 +966,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             // Create a temp to hold the promoted reference.\n                             // This is because `*r` requires `r` to be a local,\n                             // otherwise we would use the `promoted` directly.\n-                            let mut promoted_ref = LocalDecl::new_temp(ref_ty, span);\n+                            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n                             promoted_ref.source_info = statement.source_info;\n                             let promoted_ref = local_decls.push(promoted_ref);\n                             assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n@@ -1084,8 +1084,7 @@ pub fn promote_candidates<'tcx>(\n         }\n \n         // Declare return place local so that `mir::Body::new` doesn't complain.\n-        let initial_locals =\n-            iter::once(LocalDecl::new_return_place(tcx.types.never, body.span)).collect();\n+        let initial_locals = iter::once(LocalDecl::new(tcx.types.never, body.span)).collect();\n \n         let mut promoted = Body::new(\n             IndexVec::new(),"}, {"sha": "6566a996fe44285fa1a89ce0844982f2cffd44b5", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> MirPatch<'tcx> {\n             result.new_block(BasicBlockData {\n                 statements: vec![],\n                 terminator: Some(Terminator {\n-                    source_info: SourceInfo { span: body.span, scope: OUTERMOST_SOURCE_SCOPE },\n+                    source_info: SourceInfo::outermost(body.span),\n                     kind: TerminatorKind::Resume,\n                 }),\n                 is_cleanup: true,\n@@ -83,14 +83,14 @@ impl<'tcx> MirPatch<'tcx> {\n     pub fn new_temp(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n-        self.new_locals.push(LocalDecl::new_temp(ty, span));\n+        self.new_locals.push(LocalDecl::new(ty, span));\n         Local::new(index as usize)\n     }\n \n     pub fn new_internal(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n-        self.new_locals.push(LocalDecl::new_internal(ty, span));\n+        self.new_locals.push(LocalDecl::new(ty, span).internal());\n         Local::new(index as usize)\n     }\n "}, {"sha": "090cd41543733b038174d44c20090db88b316a4c", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -472,8 +472,10 @@ fn write_scope_tree(\n \n         let mut indented_decl =\n             format!(\"{0:1$}let {2}{3:?}: {4:?}\", INDENT, indent, mut_str, local, local_decl.ty);\n-        for user_ty in local_decl.user_ty.projections() {\n-            write!(indented_decl, \" as {:?}\", user_ty).unwrap();\n+        if let Some(user_ty) = &local_decl.user_ty {\n+            for user_ty in user_ty.projections() {\n+                write!(indented_decl, \" as {:?}\", user_ty).unwrap();\n+            }\n         }\n         indented_decl.push_str(\";\");\n "}, {"sha": "e08eedc6b6e916a9d19e9c5d7b295b43cb074877", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         let fake_borrow_ty =\n                             tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n                         let fake_borrow_temp =\n-                            self.local_decls.push(LocalDecl::new_temp(fake_borrow_ty, expr_span));\n+                            self.local_decls.push(LocalDecl::new(fake_borrow_ty, expr_span));\n                         let projection = tcx.intern_place_elems(&base_place.projection[..idx]);\n                         self.cfg.push_assign(\n                             block,"}, {"sha": "d934ba1dc841e5ca8522966e218096b159030d5c", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // The `Box<T>` temporary created here is not a part of the HIR,\n                 // and therefore is not considered during generator OIBIT\n                 // determination. See the comment about `box` at `yield_in_scope`.\n-                let result = this.local_decls.push(LocalDecl::new_internal(expr.ty, expr_span));\n+                let result = this.local_decls.push(LocalDecl::new(expr.ty, expr_span).internal());\n                 this.cfg.push(\n                     block,\n                     Statement { source_info, kind: StatementKind::StorageLive(result) },\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n \n         let source_info = this.source_info(upvar_span);\n-        let temp = this.local_decls.push(LocalDecl::new_temp(upvar_ty, upvar_span));\n+        let temp = this.local_decls.push(LocalDecl::new(upvar_ty, upvar_span));\n \n         this.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });\n "}, {"sha": "d82abd8776719554b542c5aaf1d155e9548f36e3", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let expr_ty = expr.ty;\n         let temp = {\n-            let mut local_decl = LocalDecl::new_temp(expr_ty, expr_span);\n+            let mut local_decl = LocalDecl::new(expr_ty, expr_span);\n             if mutability == Mutability::Not {\n                 local_decl = local_decl.immutable();\n             }\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let ExprKind::StaticRef { def_id, .. } = expr.kind {\n                 let is_thread_local = this.hir.tcx().is_thread_local_static(def_id);\n                 local_decl.internal = true;\n-                local_decl.local_info = LocalInfo::StaticRef { def_id, is_thread_local };\n+                local_decl.local_info = Some(box LocalInfo::StaticRef { def_id, is_thread_local });\n             }\n             this.local_decls.push(local_decl)\n         };"}, {"sha": "e26fb48a3f99736e6a7ed69a4990b452876a07a5", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -187,15 +187,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let ptr_ty = ptr.ty;\n                     // Create an *internal* temp for the pointer, so that unsafety\n                     // checking won't complain about the raw pointer assignment.\n-                    let ptr_temp = this.local_decls.push(LocalDecl {\n-                        mutability: Mutability::Mut,\n-                        ty: ptr_ty,\n-                        user_ty: UserTypeProjections::none(),\n+                    let ptr_temp = this.local_decls.push(LocalDecl::with_source_info(\n+                        ptr_ty,\n                         source_info,\n-                        internal: true,\n-                        local_info: LocalInfo::Other,\n-                        is_block_tail: None,\n-                    });\n+                    ).internal());\n                     let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(ptr_temp, block, ptr));\n                     this.into(this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n@@ -348,7 +343,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // value is Sized. Usually, this is caught in type checking, but\n                 // in the case of box expr there is no such check.\n                 if !destination.projection.is_empty() {\n-                    this.local_decls.push(LocalDecl::new_temp(expr.ty, expr.span));\n+                    this.local_decls.push(LocalDecl::new(expr.ty, expr.span));\n                 }\n \n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));"}, {"sha": "f14de38a3f9428acb11e83357e976f0b741c9ecc", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -470,9 +470,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                    if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                    if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    ))) = self.local_decls[local].local_info\n+                    )))) = self.local_decls[local].local_info\n                     {\n                         *match_place = Some(initializer);\n                     } else {\n@@ -1539,7 +1539,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n                 let fake_borrow_temp =\n-                    self.local_decls.push(LocalDecl::new_temp(fake_borrow_ty, temp_span));\n+                    self.local_decls.push(LocalDecl::new(fake_borrow_ty, temp_span));\n \n                 (matched_place, fake_borrow_temp)\n             })\n@@ -1949,11 +1949,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n-            user_ty,\n+            user_ty: if user_ty.is_empty() { None } else { Some(box user_ty) },\n             source_info,\n             internal: false,\n             is_block_tail: None,\n-            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+            local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode,\n                 // hypothetically, `visit_bindings` could try to unzip\n                 // an outermost hir::Ty as we descend, matching up\n@@ -1962,7 +1962,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 opt_ty_info: None,\n                 opt_match_place,\n                 pat_span,\n-            }))),\n+            })))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         self.var_debug_info.push(VarDebugInfo {\n@@ -1976,11 +1976,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // immutable to avoid the unused mut lint.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.lifetimes.re_erased, var_ty),\n-                user_ty: UserTypeProjections::none(),\n+                user_ty: None,\n                 source_info,\n                 internal: false,\n                 is_block_tail: None,\n-                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n+                local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard))),\n             });\n             self.var_debug_info.push(VarDebugInfo {\n                 name,"}, {"sha": "e8933ff8aa749a0db27435c8a481b606dd4ca749", "filename": "src/librustc_mir_build/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -15,7 +15,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// N.B., **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n     crate fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n-        let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n+        let temp = self.local_decls.push(LocalDecl::new(ty, span));\n         let place = Place::from(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\", place, self.local_decls[temp].ty);\n         place"}, {"sha": "6c61c27c4ed7fda49bc099abec55a4065e35f1fd", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -708,15 +708,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n     // Some MIR passes will expect the number of parameters to match the\n     // function declaration.\n     for _ in 0..num_params {\n-        builder.local_decls.push(LocalDecl {\n-            mutability: Mutability::Mut,\n-            ty,\n-            user_ty: UserTypeProjections::none(),\n-            source_info,\n-            internal: false,\n-            local_info: LocalInfo::Other,\n-            is_block_tail: None,\n-        });\n+        builder.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n     }\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     let mut body = builder.finish();\n@@ -750,10 +742,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n-            local_decls: IndexVec::from_elem_n(\n-                LocalDecl::new_return_place(return_ty, return_span),\n-                1,\n-            ),\n+            local_decls: IndexVec::from_elem_n(LocalDecl::new(return_ty, return_span), 1),\n             canonical_user_type_annotations: IndexVec::new(),\n             upvar_mutbls: vec![],\n             var_indices: Default::default(),\n@@ -804,19 +793,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: arg_opt.map_or(self.fn_span, |arg| arg.pat.span),\n-            };\n-            let arg_local = self.local_decls.push(LocalDecl {\n-                mutability: Mutability::Mut,\n-                ty,\n-                user_ty: UserTypeProjections::none(),\n-                source_info,\n-                internal: false,\n-                local_info: LocalInfo::Other,\n-                is_block_tail: None,\n-            });\n+            let source_info =\n+                SourceInfo::outermost(arg_opt.map_or(self.fn_span, |arg| arg.pat.span));\n+            let arg_local = self.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n \n             // If this is a simple binding pattern, give debuginfo a nice name.\n             if let Some(arg) = arg_opt {\n@@ -885,10 +864,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     self.var_debug_info.push(VarDebugInfo {\n                         name,\n-                        source_info: SourceInfo {\n-                            scope: OUTERMOST_SOURCE_SCOPE,\n-                            span: tcx_hir.span(var_id),\n-                        },\n+                        source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n                         place: Place {\n                             local: closure_env_arg,\n                             projection: tcx.intern_place_elems(&projs),\n@@ -933,17 +909,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n                         self.local_decls[local].local_info = if let Some(kind) = self_binding {\n-                            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n+                            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind))))\n                         } else {\n                             let binding_mode = ty::BindingMode::BindByValue(mutability);\n-                            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                                 VarBindingForm {\n                                     binding_mode,\n                                     opt_ty_info,\n                                     opt_match_place: Some((Some(place), span)),\n                                     pat_span: span,\n                                 },\n-                            )))\n+                            ))))\n                         };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }"}, {"sha": "4daf567d7d451497682ce5618fa9e840bff8747b", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3a114633c23acb96f94ed66b620e74b832c19b/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=2b3a114633c23acb96f94ed66b620e74b832c19b", "patch": "@@ -989,7 +989,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let resumeblk = self.cfg.start_new_cleanup_block();\n             self.cfg.terminate(\n                 resumeblk,\n-                SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span: self.fn_span },\n+                SourceInfo::outermost(self.fn_span),\n                 TerminatorKind::Resume,\n             );\n             self.cached_resume_block = Some(resumeblk);"}]}