{"sha": "3f6e6532ac17e97ce48b91e07340361a32ef480b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNmU2NTMyYWMxN2U5N2NlNDhiOTFlMDczNDAzNjFhMzJlZjQ4MGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-03T02:03:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-03T02:14:57Z"}, "message": "make vec fns/methods take imm slices.\n\nthis also repairs the unsoundness in typing of unpack_slice,\nwhich was silently converting a const ptr to an imm one.", "tree": {"sha": "8aba1f764b51f07fad2f41a67adbdae980023eb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aba1f764b51f07fad2f41a67adbdae980023eb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f6e6532ac17e97ce48b91e07340361a32ef480b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f6e6532ac17e97ce48b91e07340361a32ef480b", "html_url": "https://github.com/rust-lang/rust/commit/3f6e6532ac17e97ce48b91e07340361a32ef480b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f6e6532ac17e97ce48b91e07340361a32ef480b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94683dce9832dddf5af5c5ffd1384c7fd113729", "url": "https://api.github.com/repos/rust-lang/rust/commits/e94683dce9832dddf5af5c5ffd1384c7fd113729", "html_url": "https://github.com/rust-lang/rust/commit/e94683dce9832dddf5af5c5ffd1384c7fd113729"}], "stats": {"total": 429, "additions": 235, "deletions": 194}, "files": [{"sha": "c7b94c8e1550e591c2c750555c2a812c8f0af959", "filename": "doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -908,14 +908,13 @@ for the parameter list, as in `{|| ...}`.\n Partial application is done using the `bind` keyword in Rust.\n \n ~~~~\n-let daynum = bind vec::position_elem([\"mo\", \"tu\", \"we\", \"th\",\n-                                      \"fr\", \"sa\", \"su\"], _);\n+let findx = bind str::find_char(_, 'x');\n ~~~~\n \n Binding a function produces a boxed closure (`fn@` type) in which some\n of the arguments to the bound function have already been provided.\n-`daynum` will be a function taking a single string argument, and\n-returning the day of the week that string corresponds to (if any).\n+`findx` will be a function taking a single string argument, and\n+returning the position where the letter `x` occurs.\n \n ## Iteration\n "}, {"sha": "6aa24b9b651d847a597e44139703a7da1e971009", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -45,7 +45,7 @@ export swappable;\n export dvec, dvec_iter;\n \n // NDM seems to be necessary for resolve to work\n-export vec_iter, option_iter;\n+export option_iter;\n \n // FIXME: This creates some APIs that I do not want to commit to. It is\n // currently exported for the uv code in std, but when that code moves into\n@@ -146,11 +146,6 @@ mod f64;\n mod str;\n mod ptr;\n mod vec;\n-#[path=\"iter-trait\"]\n-mod vec_iter {\n-    #[path = \"vec.rs\"]\n-    mod inst;\n-}\n mod bool;\n mod tuple;\n "}, {"sha": "2522a98609c3f080a217022862a9e23bb6855539", "filename": "src/libcore/core.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -7,7 +7,6 @@ import option = option::option;\n import path = path::path;\n import str::extensions;\n import vec::extensions;\n-import vec_iter::extensions;\n import option::extensions;\n import option_iter::extensions;\n import ptr::extensions;"}, {"sha": "937aa5976ef8a4144adb94da8669a756d2d0933f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -331,7 +331,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n \n impl of writer for *libc::FILE {\n     fn write(v: [const u8]/&) unsafe {\n-        vec::unpack_slice(v) {|vbuf, len|\n+        vec::unpack_const_slice(v) {|vbuf, len|\n             let nout = libc::fwrite(vbuf as *c_void, len, 1u, self);\n             if nout < 1 as size_t {\n                 #error(\"error writing buffer\");\n@@ -359,9 +359,9 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n impl of writer for fd_t {\n     fn write(v: [const u8]/&) unsafe {\n         let mut count = 0u;\n-        vec::unpack_slice(v) {|vbuf, len|\n+        vec::unpack_const_slice(v) {|vbuf, len|\n             while count < len {\n-                let vb = ptr::offset(vbuf, count) as *c_void;\n+                let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len);\n                 if nout < 0 as ssize_t {\n                     #error(\"error writing buffer\");"}, {"sha": "62f9458303b70065edf94ffc378a6bf4b90c2110", "filename": "src/libcore/iter-trait/vec.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e94683dce9832dddf5af5c5ffd1384c7fd113729/src%2Flibcore%2Fiter-trait%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94683dce9832dddf5af5c5ffd1384c7fd113729/src%2Flibcore%2Fiter-trait%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fvec.rs?ref=e94683dce9832dddf5af5c5ffd1384c7fd113729", "patch": "@@ -1,9 +0,0 @@\n-type IMPL_T<A> = [const A];\n-\n-fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    vec::each(self, f)\n-}\n-\n-fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n-    some(vec::len(self))\n-}"}, {"sha": "e83c35f5ed8df95baf07bee35f35ab767f647cab", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -3,6 +3,7 @@\n export addr_of;\n export mut_addr_of;\n export offset;\n+export const_offset;\n export mut_offset;\n export null;\n export is_null;\n@@ -45,6 +46,12 @@ fn offset<T>(ptr: *T, count: uint) -> *T unsafe {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n+#[doc = \"Calculate the offset from a const pointer\"]\n+#[inline(always)]\n+fn const_offset<T>(ptr: *const T, count: uint) -> *const T unsafe {\n+    (ptr as uint + count * sys::size_of::<T>()) as *T\n+}\n+\n #[doc = \"Calculate the offset from a mut pointer\"]\n #[inline(always)]\n fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {"}, {"sha": "8613f378d7a4f375f34e482285910e54b54f0cd6", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 208, "deletions": 141, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -75,6 +75,7 @@ export windowed;\n export as_buf;\n export as_mut_buf;\n export unpack_slice;\n+export unpack_const_slice;\n export unsafe;\n export u8;\n export extensions;\n@@ -93,16 +94,18 @@ native mod rustrt {\n type init_op<T> = fn(uint) -> T;\n \n #[doc = \"Returns true if a vector contains no elements\"]\n-pure fn is_empty<T>(v: [const T]) -> bool {\n-    len(v) == 0u\n+pure fn is_empty<T>(v: [const T]/&) -> bool {\n+    unpack_const_slice(v) {|_p, len| len == 0u}\n }\n \n #[doc = \"Returns true if a vector contains some elements\"]\n-pure fn is_not_empty<T>(v: [const T]) -> bool { ret !is_empty(v); }\n+pure fn is_not_empty<T>(v: [const T]/&) -> bool {\n+    unpack_const_slice(v) {|_p, len| len > 0u}\n+}\n \n #[doc = \"Returns true if two vectors have the same length\"]\n-pure fn same_length<T, U>(xs: [const T], ys: [const U]) -> bool {\n-    vec::len(xs) == vec::len(ys)\n+pure fn same_length<T, U>(xs: [const T]/&, ys: [const U]/&) -> bool {\n+    len(xs) == len(ys)\n }\n \n #[doc = \"\n@@ -154,7 +157,7 @@ pure fn capacity<T>(&&v: [const T]) -> uint unsafe {\n #[doc = \"Returns the length of a vector\"]\n #[inline(always)]\n pure fn len<T>(&&v: [const T]/&) -> uint unsafe {\n-    unpack_slice(v) {|_p, len| len}\n+    unpack_const_slice(v) {|_p, len| len}\n }\n \n #[doc = \"\n@@ -202,43 +205,44 @@ fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n // Accessors\n \n #[doc = \"Returns the first element of a vector\"]\n-pure fn head<T: copy>(v: [const T]) -> T { v[0] }\n+pure fn head<T: copy>(v: [const T]/&) -> T { v[0] }\n \n-#[doc = \"Returns all but the first element of a vector\"]\n-fn tail<T: copy>(v: [const T]) -> [T] {\n+#[doc = \"Returns a vector containing all but the first element of a slice\"]\n+fn tail<T: copy>(v: [const T]/&) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n-#[doc = \"Returns all but the first `n` elements of a vector\"]\n-fn tailn<T: copy>(v: [const T], n: uint) -> [T] {\n+#[doc = \"Returns a vector containing all but the first `n` \\\n+         elements of a slice\"]\n+fn tailn<T: copy>(v: [const T]/&, n: uint) -> [T] {\n     slice(v, n, len(v))\n }\n \n-#[doc = \"Returns all but the last elemnt of a vector\"]\n-fn init<T: copy>(v: [const T]) -> [T] {\n+#[doc = \"Returns a vector containing all but the last element of a slice\"]\n+fn init<T: copy>(v: [const T]/&) -> [T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n #[doc = \"\n-Returns the last element of a `v`, failing if the vector is empty.\n+Returns the last element of the slice `v`, failing if the slice is empty.\n \"]\n-pure fn last<T: copy>(v: [const T]) -> T {\n+pure fn last<T: copy>(v: [const T]/&) -> T {\n     if len(v) == 0u { fail \"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n \n #[doc = \"\n-Returns some(x) where `x` is the last element of a vector `v`,\n-or none if the vector is empty.\n+Returns `some(x)` where `x` is the last element of the slice `v`,\n+or `none` if the vector is empty.\n \"]\n-pure fn last_opt<T: copy>(v: [const T]) -> option<T> {\n-   if len(v) == 0u { ret none; }\n+pure fn last_opt<T: copy>(v: [const T]/&) -> option<T> {\n+    if len(v) == 0u { ret none; }\n     some(v[len(v) - 1u])\n }\n \n #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n-pure fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n+pure fn slice<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = [];\n@@ -249,7 +253,7 @@ pure fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n }\n \n #[doc = \"Return a slice that points into another slice.\"]\n-pure fn view<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/&a {\n+pure fn view<T: copy>(v: [T]/&, start: uint, end: uint) -> [T]/&a {\n     assert (start <= end);\n     assert (end <= len(v));\n     unpack_slice(v) {|p, _len|\n@@ -263,7 +267,7 @@ pure fn view<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/&a {\n #[doc = \"\n Split the vector `v` by applying each element against the predicate `f`.\n \"]\n-fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n+fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -286,7 +290,7 @@ fn split<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n \"]\n-fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -312,7 +316,7 @@ fn splitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n \"]\n-fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n+fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -335,7 +339,7 @@ fn rsplit<T: copy>(v: [const T], f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n \"]\n-fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn rsplitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -447,7 +451,7 @@ fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-pure fn map<T, U>(v: [const T]/&, f: fn(T) -> U) -> [U] {\n+pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     unchecked{reserve(result, len(v));}\n     for each(v) {|elem| result += [f(elem)]; }\n@@ -457,7 +461,7 @@ pure fn map<T, U>(v: [const T]/&, f: fn(T) -> U) -> [U] {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-pure fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n+pure fn mapi<T, U>(v: [T]/&, f: fn(uint, T) -> U) -> [U] {\n     let mut result = [];\n     unchecked{reserve(result, len(v));}\n     for eachi(v) {|i, elem| result += [f(i, elem)]; }\n@@ -468,7 +472,7 @@ pure fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n Apply a function to each element of a vector and return a concatenation\n of each result vector\n \"]\n-pure fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n+pure fn flat_map<T, U>(v: [T]/&, f: fn(T) -> [U]) -> [U] {\n     let mut result = [];\n     for each(v) {|elem| result += f(elem); }\n     ret result;\n@@ -477,7 +481,7 @@ pure fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n #[doc = \"\n Apply a function to each pair of elements and return the results\n \"]\n-pure fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n+pure fn map2<T: copy, U: copy, V>(v0: [T]/&, v1: [U]/&,\n                                   f: fn(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n@@ -493,7 +497,7 @@ Apply a function to each element of a vector and return the results\n If function `f` returns `none` then that element is excluded from\n the resulting vector.\n \"]\n-pure fn filter_map<T, U: copy>(v: [T], f: fn(T) -> option<U>)\n+pure fn filter_map<T, U: copy>(v: [T]/&, f: fn(T) -> option<U>)\n     -> [U] {\n     let mut result = [];\n     for each(v) {|elem|\n@@ -512,7 +516,7 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n \"]\n-pure fn filter<T: copy>(v: [const T], f: fn(T) -> bool) -> [T] {\n+pure fn filter<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for each(v) {|elem|\n         if f(elem) { result += [elem]; }\n@@ -525,7 +529,7 @@ Concatenate a vector of vectors.\n \n Flattens a vector of vectors of T into a single vector of T.\n \"]\n-pure fn concat<T: copy>(v: [const [const T]]) -> [T] {\n+pure fn concat<T: copy>(v: [[T]]/&) -> [T] {\n     let mut r = [];\n     for each(v) {|inner| r += inner; }\n     ret r;\n@@ -534,7 +538,7 @@ pure fn concat<T: copy>(v: [const [const T]]) -> [T] {\n #[doc = \"\n Concatenate a vector of vectors, placing a given separator between each\n \"]\n-pure fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n+pure fn connect<T: copy>(v: [[T]]/&, sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n     for each(v) {|inner|\n@@ -545,7 +549,7 @@ pure fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n }\n \n #[doc = \"Reduce a vector from left to right\"]\n-pure fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n+pure fn foldl<T: copy, U>(z: T, v: [U]/&, p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n     iter(v) { |elt|\n         accum = p(accum, elt);\n@@ -554,7 +558,7 @@ pure fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n }\n \n #[doc = \"Reduce a vector from right to left\"]\n-pure fn foldr<T, U: copy>(v: [const T]/&, z: U, p: fn(T, U) -> U) -> U {\n+pure fn foldr<T, U: copy>(v: [T]/&, z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n@@ -567,7 +571,7 @@ Return true if a predicate matches any elements\n \n If the vector contains no elements then false is returned.\n \"]\n-pure fn any<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n+pure fn any<T>(v: [T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if f(elem) { ret true; } }\n     ret false;\n }\n@@ -577,7 +581,7 @@ Return true if a predicate matches any elements in both vectors.\n \n If the vectors contains no elements then false is returned.\n \"]\n-pure fn any2<T, U>(v0: [const T]/&, v1: [const U]/&,\n+pure fn any2<T, U>(v0: [T]/&, v1: [U]/&,\n                    f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n@@ -594,7 +598,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-pure fn all<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n+pure fn all<T>(v: [T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if !f(elem) { ret false; } }\n     ret true;\n }\n@@ -604,7 +608,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-pure fn alli<T>(v: [const T]/&, f: fn(uint, T) -> bool) -> bool {\n+pure fn alli<T>(v: [T]/&, f: fn(uint, T) -> bool) -> bool {\n     for eachi(v) {|i, elem| if !f(i, elem) { ret false; } }\n     ret true;\n }\n@@ -614,7 +618,7 @@ Return true if a predicate matches all elements in both vectors.\n \n If the vectors are not the same size then false is returned.\n \"]\n-pure fn all2<T, U>(v0: [const T]/&, v1: [const U]/&,\n+pure fn all2<T, U>(v0: [T]/&, v1: [U]/&,\n                    f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n@@ -624,13 +628,13 @@ pure fn all2<T, U>(v0: [const T]/&, v1: [const U]/&,\n }\n \n #[doc = \"Return true if a vector contains an element with the given value\"]\n-pure fn contains<T>(v: [const T], x: T) -> bool {\n+pure fn contains<T>(v: [T]/&, x: T) -> bool {\n     for each(v) {|elt| if x == elt { ret true; } }\n     ret false;\n }\n \n #[doc = \"Returns the number of elements that are equal to a given value\"]\n-pure fn count<T>(v: [const T], x: T) -> uint {\n+pure fn count<T>(v: [T]/&, x: T) -> uint {\n     let mut cnt = 0u;\n     for each(v) {|elt| if x == elt { cnt += 1u; } }\n     ret cnt;\n@@ -643,7 +647,7 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n \"]\n-pure fn find<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n+pure fn find<T: copy>(v: [T]/&, f: fn(T) -> bool) -> option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -654,7 +658,7 @@ Apply function `f` to each element of `v` within the range [`start`, `end`).\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n \"]\n-pure fn find_between<T: copy>(v: [const T], start: uint, end: uint,\n+pure fn find_between<T: copy>(v: [T]/&, start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n     option::map(position_between(v, start, end, f)) { |i| v[i] }\n }\n@@ -666,7 +670,7 @@ Apply function `f` to each element of `v` in reverse order. When function `f`\n returns true then an option containing the element is returned. If `f`\n matches no elements then none is returned.\n \"]\n-pure fn rfind<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n+pure fn rfind<T: copy>(v: [T]/&, f: fn(T) -> bool) -> option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -677,13 +681,13 @@ Apply function `f` to each element of `v` in reverse order within the range\n [`start`, `end`). When function `f` returns true then an option containing\n the element is returned. If `f` matches no elements then none is returned.\n \"]\n-pure fn rfind_between<T: copy>(v: [const T], start: uint, end: uint,\n+pure fn rfind_between<T: copy>(v: [T]/&, start: uint, end: uint,\n                                f: fn(T) -> bool) -> option<T> {\n     option::map(rposition_between(v, start, end, f)) { |i| v[i] }\n }\n \n #[doc = \"Find the first index containing a matching value\"]\n-pure fn position_elem<T>(v: [const T], x: T) -> option<uint> {\n+pure fn position_elem<T>(v: [T]/&, x: T) -> option<uint> {\n     position(v) { |y| x == y }\n }\n \n@@ -694,7 +698,7 @@ Apply function `f` to each element of `v`.  When function `f` returns true\n then an option containing the index is returned. If `f` matches no elements\n then none is returned.\n \"]\n-pure fn position<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n+pure fn position<T>(v: [T]/&, f: fn(T) -> bool) -> option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -705,7 +709,7 @@ Apply function `f` to each element of `v` between the range [`start`, `end`).\n When function `f` returns true then an option containing the index is\n returned. If `f` matches no elements then none is returned.\n \"]\n-pure fn position_between<T>(v: [const T], start: uint, end: uint,\n+pure fn position_between<T>(v: [T]/&, start: uint, end: uint,\n                             f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n@@ -715,7 +719,7 @@ pure fn position_between<T>(v: [const T], start: uint, end: uint,\n }\n \n #[doc = \"Find the last index containing a matching value\"]\n-pure fn rposition_elem<T>(v: [const T], x: T) -> option<uint> {\n+pure fn rposition_elem<T>(v: [T]/&, x: T) -> option<uint> {\n     rposition(v) { |y| x == y }\n }\n \n@@ -726,7 +730,7 @@ Apply function `f` to each element of `v` in reverse order.  When function\n `f` returns true then an option containing the index is returned. If `f`\n matches no elements then none is returned.\n \"]\n-pure fn rposition<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n+pure fn rposition<T>(v: [T]/&, f: fn(T) -> bool) -> option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -737,7 +741,7 @@ Apply function `f` to each element of `v` in reverse order between the range\n [`start`, `end`). When function `f` returns true then an option containing\n the index is returned. If `f` matches no elements then none is returned.\n \"]\n-pure fn rposition_between<T>(v: [const T], start: uint, end: uint,\n+pure fn rposition_between<T>(v: [T]/&, start: uint, end: uint,\n                              f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n@@ -761,7 +765,7 @@ vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n \"]\n-pure fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n+pure fn unzip<T: copy, U: copy>(v: [(T, U)]/&) -> ([T], [U]) {\n     let mut as = [], bs = [];\n     for each(v) {|p| let (a, b) = p; as += [a]; bs += [b]; }\n     ret (as, bs);\n@@ -804,7 +808,7 @@ fn reverse<T>(v: [mut T]) {\n \n \n #[doc = \"Returns a vector with the order of elements reversed\"]\n-fn reversed<T: copy>(v: [const T]) -> [T] {\n+fn reversed<T: copy>(v: [const T]/&) -> [T] {\n     let mut rs: [T] = [];\n     let mut i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -814,36 +818,38 @@ fn reversed<T: copy>(v: [const T]) -> [T] {\n }\n \n #[doc = \"\n-Iterates over a vector\n+Iterates over a slice\n \n-Iterates over vector `v` and, for each element, calls function `f` with the\n+Iterates over slice `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n #[inline(always)]\n-pure fn iter<T>(v: [const T], f: fn(T)) {\n+pure fn iter<T>(v: [T]/&, f: fn(T)) {\n     iter_between(v, 0u, vec::len(v), f)\n }\n \n /*\n Function: iter_between\n \n-Iterates over a vector\n+Iterates over a slice\n \n-Iterates over vector `v` and, for each element, calls function `f` with the\n+Iterates over slice `v` and, for each element, calls function `f` with the\n element's value.\n \n */\n #[inline(always)]\n-pure fn iter_between<T>(v: [const T], start: uint, end: uint, f: fn(T)) {\n-    assert start <= end;\n-    assert end <= vec::len(v);\n-    unsafe {\n-        let mut n = end;\n-        let mut p = ptr::offset(unsafe::to_ptr(v), start);\n-        while n > start {\n-            f(*p);\n-            p = ptr::offset(p, 1u);\n-            n -= 1u;\n+pure fn iter_between<T>(v: [T]/&, start: uint, end: uint, f: fn(T)) {\n+    unpack_slice(v) { |base_ptr, len|\n+        assert start <= end;\n+        assert end <= len;\n+        unsafe {\n+            let mut n = end;\n+            let mut p = ptr::offset(base_ptr, start);\n+            while n > start {\n+                f(*p);\n+                p = ptr::offset(p, 1u);\n+                n -= 1u;\n+            }\n         }\n     }\n }\n@@ -854,7 +860,7 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [T]/&, f: fn(T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n@@ -872,7 +878,7 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [T]/&, f: fn(uint, T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n@@ -892,7 +898,7 @@ Iterates over two vectors simultaneously\n Both vectors must have the same length\n \"]\n #[inline]\n-fn iter2<U, T>(v1: [const U], v2: [const T], f: fn(U, T)) {\n+fn iter2<U, T>(v1: [U]/&, v2: [T]/&, f: fn(U, T)) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) {|i|\n         f(v1[i], v2[i])\n@@ -906,7 +912,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n \"]\n #[inline(always)]\n-pure fn iteri<T>(v: [const T], f: fn(uint, T)) {\n+pure fn iteri<T>(v: [T]/&, f: fn(uint, T)) {\n     let mut i = 0u;\n     let l = len(v);\n     while i < l { f(i, v[i]); i += 1u; }\n@@ -918,7 +924,7 @@ Iterates over a vector in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n-pure fn riter<T>(v: [const T]/&, f: fn(T)) {\n+pure fn riter<T>(v: [T]/&, f: fn(T)) {\n     riteri(v) { |_i, v| f(v) }\n }\n \n@@ -928,7 +934,7 @@ Iterates over a vector's elements and indexes in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n \"]\n-pure fn riteri<T>(v: [const T]/&, f: fn(uint, T)) {\n+pure fn riteri<T>(v: [T]/&, f: fn(uint, T)) {\n     let mut i = len(v);\n     while 0u < i {\n         i -= 1u;\n@@ -946,7 +952,7 @@ lexicographically sorted).\n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n \"]\n-pure fn permute<T: copy>(v: [T], put: fn([T])) {\n+pure fn permute<T: copy>(v: [T]/&, put: fn([T])) {\n   let ln = len(v);\n   if ln == 0u {\n     put([]);\n@@ -961,7 +967,7 @@ pure fn permute<T: copy>(v: [T], put: fn([T])) {\n   }\n }\n \n-pure fn windowed<TT: copy>(nn: uint, xx: [const TT]) -> [[TT]] {\n+pure fn windowed<TT: copy>(nn: uint, xx: [TT]/&) -> [[TT]] {\n     let mut ww = [];\n     assert 1u <= nn;\n     vec::iteri (xx, {|ii, _x|\n@@ -979,35 +985,86 @@ Work with the buffer of a vector.\n Allows for unsafe manipulation of vector contents, which is useful for native\n interop.\n \"]\n-fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n-    let buf = unsafe::to_ptr(v); f(buf)\n+fn as_buf<E,T>(v: [E]/&, f: fn(*E) -> T) -> T unsafe {\n+    unpack_slice(v) { |buf, _len| f(buf) }\n }\n \n-fn as_mut_buf<E,T>(v: [mut E], f: fn(*mut E) -> T) -> T unsafe {\n-    let buf = unsafe::to_ptr(v) as *mut E; f(buf)\n+fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T unsafe {\n+    unpack_mut_slice(v) { |buf, _len| f(buf) }\n }\n \n #[doc = \"\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n-pure fn unpack_slice<T,U>(s: [const T]/&, f: fn(*T, uint) -> U) -> U unsafe {\n+pure fn unpack_slice<T,U>(s: [T]/&,\n+                          f: fn(*T, uint) -> U) -> U unsafe {\n     let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n     f(buf, len / sys::size_of::<T>())\n }\n \n+#[doc = \"\n+Work with the buffer and length of a slice.\n+\"]\n+#[inline(always)]\n+pure fn unpack_const_slice<T,U>(s: [const T]/&,\n+                                f: fn(*const T, uint) -> U) -> U unsafe {\n+    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+    let (buf,len) = *v;\n+    f(buf, len / sys::size_of::<T>())\n+}\n+\n+#[doc = \"\n+Work with the buffer and length of a slice.\n+\"]\n+#[inline(always)]\n+pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n+                              f: fn(*mut T, uint) -> U) -> U unsafe {\n+    let v : *(*const T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n+    let (buf,len) = *v;\n+    f(buf, len / sys::size_of::<T>())\n+}\n+\n #[doc = \"Extension methods for vectors\"]\n-impl extensions<T> for [const T] {\n-    #[doc = \"Reduce a vector from right to left\"]\n-    #[inline]\n-    fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+impl extensions/&<T> for [const T]/& {\n     #[doc = \"Returns true if a vector contains no elements\"]\n     #[inline]\n     fn is_empty() -> bool { is_empty(self) }\n     #[doc = \"Returns true if a vector contains some elements\"]\n     #[inline]\n     fn is_not_empty() -> bool { is_not_empty(self) }\n+    #[doc = \"Returns the length of a vector\"]\n+    #[inline]\n+    pure fn len() -> uint { len(self) }\n+}\n+\n+#[doc = \"Extension methods for vectors\"]\n+impl extensions/&<T: copy> for [const T]/& {\n+    #[doc = \"Returns the first element of a vector\"]\n+    #[inline]\n+    fn head() -> T { head(self) }\n+    #[doc = \"Returns all but the last elemnt of a vector\"]\n+    #[inline]\n+    fn init() -> [T] { init(self) }\n+    #[doc = \"\n+    Returns the last element of a `v`, failing if the vector is empty.\n+    \"]\n+    #[inline]\n+    fn last() -> T { last(self) }\n+    #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n+    #[inline]\n+    fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n+    #[doc = \"Returns all but the first element of a vector\"]\n+    #[inline]\n+    fn tail() -> [T] { tail(self) }\n+}\n+\n+#[doc = \"Extension methods for vectors\"]\n+impl extensions/&<T> for [T]/& {\n+    #[doc = \"Reduce a vector from right to left\"]\n+    #[inline]\n+    fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n     #[doc = \"\n     Iterates over a vector\n \n@@ -1024,9 +1081,6 @@ impl extensions<T> for [const T] {\n     \"]\n     #[inline]\n     fn iteri(f: fn(uint, T)) { iteri(self, f) }\n-    #[doc = \"Returns the length of a vector\"]\n-    #[inline]\n-    pure fn len() -> uint { len(self) }\n     #[doc = \"\n     Find the first index matching some predicate\n \n@@ -1067,58 +1121,6 @@ impl extensions<T> for [const T] {\n     #[doc = \"Find the last index containing a matching value\"]\n     #[inline]\n     fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n-}\n-\n-#[doc = \"Extension methods for vectors\"]\n-impl extensions<T: copy> for [const T] {\n-    #[doc = \"\n-    Construct a new vector from the elements of a vector for which some\n-    predicate holds.\n-\n-    Apply function `f` to each element of `v` and return a vector containing\n-    only those elements for which `f` returned true.\n-    \"]\n-    #[inline]\n-    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n-    #[doc = \"\n-    Search for the first element that matches a given predicate\n-\n-    Apply function `f` to each element of `v`, starting from the first.\n-    When function `f` returns true then an option containing the element\n-    is returned. If `f` matches no elements then none is returned.\n-    \"]\n-    #[inline]\n-    fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n-    #[doc = \"Returns the first element of a vector\"]\n-    #[inline]\n-    fn head() -> T { head(self) }\n-    #[doc = \"Returns all but the last elemnt of a vector\"]\n-    #[inline]\n-    fn init() -> [T] { init(self) }\n-    #[doc = \"\n-    Returns the last element of a `v`, failing if the vector is empty.\n-    \"]\n-    #[inline]\n-    fn last() -> T { last(self) }\n-    #[doc = \"\n-    Search for the last element that matches a given predicate\n-\n-    Apply function `f` to each element of `v` in reverse order. When function\n-    `f` returns true then an option containing the element is returned. If `f`\n-    matches no elements then none is returned.\n-    \"]\n-    #[inline]\n-    fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n-    #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n-    #[inline]\n-    fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n-    #[doc = \"Returns all but the first element of a vector\"]\n-    #[inline]\n-    fn tail() -> [T] { tail(self) }\n-}\n-\n-#[doc = \"Extension methods for vectors\"]\n-impl extensions<T> for [T] {\n     #[doc = \"\n     Apply a function to each element of a vector and return the results\n     \"]\n@@ -1155,6 +1157,37 @@ impl extensions<T> for [T] {\n     }\n }\n \n+#[doc = \"Extension methods for vectors\"]\n+impl extensions/&<T: copy> for [T]/& {\n+    #[doc = \"\n+    Construct a new vector from the elements of a vector for which some\n+    predicate holds.\n+\n+    Apply function `f` to each element of `v` and return a vector containing\n+    only those elements for which `f` returned true.\n+    \"]\n+    #[inline]\n+    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n+    #[doc = \"\n+    Search for the first element that matches a given predicate\n+\n+    Apply function `f` to each element of `v`, starting from the first.\n+    When function `f` returns true then an option containing the element\n+    is returned. If `f` matches no elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n+    #[doc = \"\n+    Search for the last element that matches a given predicate\n+\n+    Apply function `f` to each element of `v` in reverse order. When function\n+    `f` returns true then an option containing the element is returned. If `f`\n+    matches no elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n+}\n+\n #[doc = \"Unsafe operations\"]\n mod unsafe {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n@@ -1277,6 +1310,40 @@ mod u8 {\n     }\n }\n \n+// ___________________________________________________________________________\n+// ITERATION TRAIT METHODS\n+//\n+// This cannot be used with iter-trait.rs because of the region pointer\n+// required in the slice.\n+impl extensions/&<A> of iter::base_iter<A> for [A]/& {\n+    fn each(blk: fn(A) -> bool) { each(self, blk) }\n+    fn size_hint() -> option<uint> { some(len(self)) }\n+    fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n+    fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n+    fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    fn contains(x: A) -> bool { iter::contains(self, x) }\n+    fn count(x: A) -> uint { iter::count(self, x) }\n+}\n+impl extensions/&<A:copy> for [A]/& {\n+    fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n+        iter::filter_to_vec(self, pred)\n+    }\n+    fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n+    fn to_vec() -> [A] { iter::to_vec(self) }\n+\n+    // FIXME--bug in resolve prevents this from working\n+    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n+    //     iter::flat_map_to_vec(self, op)\n+    // }\n+\n+    fn min() -> A { iter::min(self) }\n+    fn max() -> A { iter::max(self) }\n+}\n+// ___________________________________________________________________________\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "5a468df4c889d30a7969c8f952c8530944cc7740", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -10,7 +10,7 @@ enum list<T> {\n }\n \n #[doc = \"Create a list from a vector\"]\n-fn from_vec<T: copy>(v: [const T]) -> @list<T> {\n+fn from_vec<T: copy>(v: [T]) -> @list<T> {\n     vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n }\n \n@@ -167,19 +167,6 @@ mod tests {\n         assert (empty == @list::nil::<int>);\n     }\n \n-    #[test]\n-    fn test_from_vec_mut() {\n-        let l = from_vec([mut 0, 1, 2]);\n-\n-        assert (head(l) == 0);\n-\n-        let tail_l = tail(l);\n-        assert (head(tail_l) == 1);\n-\n-        let tail_tail_l = tail(tail_l);\n-        assert (head(tail_tail_l) == 2);\n-    }\n-\n     #[test]\n     fn test_foldl() {\n         fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }"}, {"sha": "d12a7e71a632ac15957933619a81042db67b7c0d", "filename": "src/libstd/par.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -20,7 +20,7 @@ This is used to build most of the other parallel vector functions,\n like map or alli.\"]\n fn map_slices<A: copy send, B: copy send>(\n     xs: [A],\n-    f: fn() -> fn~(uint, [const A]/&) -> B)\n+    f: fn() -> fn~(uint, [A]/&) -> B)\n     -> [B] {\n \n     let len = xs.len();\n@@ -48,7 +48,7 @@ fn map_slices<A: copy send, B: copy send>(\n                         let slice = (ptr::offset(p, base),\n                                      len * sys::size_of::<A>());\n                         log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n-                        let slice : [const A]/& =\n+                        let slice : [A]/& =\n                             unsafe::reinterpret_cast(slice);\n                         log(info, #fmt(\"slice: %?\",\n                                        (base, vec::len(slice), end - base)));\n@@ -75,7 +75,7 @@ fn map_slices<A: copy send, B: copy send>(\n #[doc=\"A parallel version of map.\"]\n fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n     vec::concat(map_slices(xs) {||\n-        fn~(_base: uint, slice : [const A]/&, copy f) -> [B] {\n+        fn~(_base: uint, slice : [A]/&, copy f) -> [B] {\n             vec::map(slice, f)\n         }\n     })\n@@ -84,7 +84,7 @@ fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n #[doc=\"A parallel version of mapi.\"]\n fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n     let slices = map_slices(xs) {||\n-        fn~(base: uint, slice : [const A]/&, copy f) -> [B] {\n+        fn~(base: uint, slice : [A]/&, copy f) -> [B] {\n             vec::mapi(slice) {|i, x|\n                 f(i + base, x)\n             }\n@@ -104,7 +104,7 @@ fn mapi_factory<A: copy send, B: copy send>(\n     xs: [A], f: fn() -> fn~(uint, A) -> B) -> [B] {\n     let slices = map_slices(xs) {||\n         let f = f();\n-        fn~(base: uint, slice : [const A]/&, move f) -> [B] {\n+        fn~(base: uint, slice : [A]/&, move f) -> [B] {\n             vec::mapi(slice) {|i, x|\n                 f(i + base, x)\n             }\n@@ -119,7 +119,7 @@ fn mapi_factory<A: copy send, B: copy send>(\n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n     vec::all(map_slices(xs) {||\n-        fn~(base: uint, slice : [const A]/&, copy f) -> bool {\n+        fn~(base: uint, slice : [A]/&, copy f) -> bool {\n             vec::alli(slice) {|i, x|\n                 f(i + base, x)\n             }\n@@ -130,7 +130,7 @@ fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n     vec::any(map_slices(xs) {||\n-        fn~(_base : uint, slice: [const A]/&, copy f) -> bool {\n+        fn~(_base : uint, slice: [A]/&, copy f) -> bool {\n             vec::any(slice, f)\n         }\n     }) {|x| x }"}, {"sha": "f9393890f3c9066718a0ea86eff35e053d4a2cf7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -272,14 +272,9 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v: [mut @ast::meta_item] = [mut];\n-    for items.each {|mi| v += [mut mi]; }\n-\n+    let v: [mut @ast::meta_item] = vec::to_mut(items);\n     std::sort::quick_sort(lteq, v);\n-\n-    let mut v2: [@ast::meta_item] = [];\n-    for v.each {|mi| v2 += [mi]; }\n-    ret v2;\n+    ret vec::from_mut(v);\n }\n \n fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->"}, {"sha": "a92db033c229158d095932e8eedb7c82f8c70314", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -1512,7 +1512,8 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n           none { none }\n         }\n     }\n-    let matches = vec::filter_map(copy globs,\n+    let g = copy globs; // FIXME #2405\n+    let matches = vec::filter_map(g,\n                                   {|x| lookup_in_mod_(e, x, sp, id, ns, dr)});\n     if vec::len(matches) == 0u {\n         ret none;"}, {"sha": "445f300cb02528c091fad77ebcce0884b2d3e620", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6e6532ac17e97ce48b91e07340361a32ef480b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=3f6e6532ac17e97ce48b91e07340361a32ef480b", "patch": "@@ -120,7 +120,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n     }\n \n     fn all_mem(cls: [mut x86_64_reg_class]) {\n-        vec::iteri(cls) {|i, _c|\n+        for uint::range(0u, cls.len()) { |i|\n             cls[i] = memory_class;\n         }\n     }"}]}