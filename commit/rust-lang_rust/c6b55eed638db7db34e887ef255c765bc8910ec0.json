{"sha": "c6b55eed638db7db34e887ef255c765bc8910ec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YjU1ZWVkNjM4ZGI3ZGIzNGU4ODdlZjI1NWM3NjViYzg5MTBlYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-19T23:02:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-19T23:02:06Z"}, "message": "Auto merge of #70598 - vakaras:add-threads-cr3, r=oli-obk,RalfJung\n\nMake the necessary changes to support concurrency in Miri.\n\nThis pull request makes the necessary changes to the Rust compiler to allow Miri to support concurrency:\n\n1.  Move stack from the interpretation context (`InterpCx`) to machine, so that the machine can switch the stacks when it changes the thread being executed.\n2.  Add the callbacks that allow the machine to generate fresh allocation ids for each thread local allocation and to translate them back to original allocations when needed. This allows the machine to ensure the property that allocation ids are unique, which allows using a simpler representation of the memory.\n\nr? @oli-obk\n\ncc @RalfJung", "tree": {"sha": "94e4b3d39886e62ebf1f50bfa219f3175eaa4ce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94e4b3d39886e62ebf1f50bfa219f3175eaa4ce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b55eed638db7db34e887ef255c765bc8910ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b55eed638db7db34e887ef255c765bc8910ec0", "html_url": "https://github.com/rust-lang/rust/commit/c6b55eed638db7db34e887ef255c765bc8910ec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b55eed638db7db34e887ef255c765bc8910ec0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf8b6bf116c7bece2987ff4bd2792f008a6ee77", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf8b6bf116c7bece2987ff4bd2792f008a6ee77", "html_url": "https://github.com/rust-lang/rust/commit/dbf8b6bf116c7bece2987ff4bd2792f008a6ee77"}, {"sha": "cbd922288e8f07361645a07fe602f97b54d3afd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd922288e8f07361645a07fe602f97b54d3afd2", "html_url": "https://github.com/rust-lang/rust/commit/cbd922288e8f07361645a07fe602f97b54d3afd2"}], "stats": {"total": 242, "additions": 172, "deletions": 70}, "files": [{"sha": "3c3618f390c6160fd505122a420e27437c0689f2", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -50,7 +50,7 @@ impl Error for ConstEvalErrKind {}\n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n /// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n     ecx: &InterpCx<'mir, 'tcx, M>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {"}, {"sha": "30990853b516a9cd22568a3f97c895070aa19869", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -19,7 +19,7 @@ use crate::interpret::{\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     /// Evaluate a const function where all arguments (if any) are zero-sized types.\n     /// The evaluation is memoized thanks to the query system.\n     ///\n@@ -86,12 +86,15 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n }\n \n /// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter {\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// For now, the number of terminators that can be evaluated before we throw a resource\n     /// exhuastion error.\n     ///\n     /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n     pub steps_remaining: usize,\n+\n+    /// The virtual call stack.\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -100,9 +103,9 @@ pub struct MemoryExtra {\n     pub(super) can_access_statics: bool,\n }\n \n-impl CompileTimeInterpreter {\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) fn new(const_eval_limit: usize) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit }\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit, stack: Vec::new() }\n     }\n }\n \n@@ -156,7 +159,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, CompileTimeInterpreter>;\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -166,7 +170,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -349,6 +353,20 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n         Ok(frame)\n     }\n \n+    #[inline(always)]\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        &ecx.machine.stack\n+    }\n+\n+    #[inline(always)]\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        &mut ecx.machine.stack\n+    }\n+\n     fn before_access_global(\n         memory_extra: &MemoryExtra,\n         alloc_id: AllocId,"}, {"sha": "0e01652bc900273016bbfa1184ed52d15402c1e1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::sym;\n use rustc_target::abi::{LayoutOf, Size, Variants};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,"}, {"sha": "b2a041874d09d9dc180a44e4b1b6b98c5a52dd37", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -28,6 +28,8 @@ use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n+    ///\n+    /// Note: the stack is provided by the machine.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n@@ -39,9 +41,6 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The virtual memory system.\n     pub memory: Memory<'mir, 'tcx, M>,\n \n-    /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n-\n     /// A cache for deduplicating vtables\n     pub(super) vtables:\n         FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n@@ -297,7 +296,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -309,7 +308,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             tcx,\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n-            stack: Vec::new(),\n             vtables: FxHashMap::default(),\n         }\n     }\n@@ -349,24 +347,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n-        &self.stack\n+    pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n+        M::stack(self)\n+    }\n+\n+    #[inline(always)]\n+    pub(crate) fn stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>> {\n+        M::stack_mut(self)\n     }\n \n     #[inline(always)]\n-    pub fn cur_frame(&self) -> usize {\n-        assert!(!self.stack.is_empty());\n-        self.stack.len() - 1\n+    pub fn frame_idx(&self) -> usize {\n+        let stack = self.stack();\n+        assert!(!stack.is_empty());\n+        stack.len() - 1\n     }\n \n     #[inline(always)]\n     pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n-        self.stack.last().expect(\"no call frames exist\")\n+        self.stack().last().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra> {\n-        self.stack.last_mut().expect(\"no call frames exist\")\n+        self.stack_mut().last_mut().expect(\"no call frames exist\")\n     }\n \n     #[inline(always)]\n@@ -596,8 +602,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n-        if !self.stack.is_empty() {\n-            info!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n+        if !self.stack().is_empty() {\n+            info!(\"PAUSING({}) {}\", self.frame_idx(), self.frame().instance);\n         }\n         ::log_settings::settings().indentation += 1;\n \n@@ -615,7 +621,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             extra: (),\n         };\n         let frame = M::init_frame_extra(self, pre_frame)?;\n-        self.stack.push(frame);\n+        self.stack_mut().push(frame);\n \n         // don't allocate at all for trivial constants\n         if body.local_decls.len() > 1 {\n@@ -648,9 +654,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         M::after_stack_push(self)?;\n-        info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n+        info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n-        if self.stack.len() > *self.tcx.sess.recursion_limit.get() {\n+        if self.stack().len() > *self.tcx.sess.recursion_limit.get() {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n@@ -705,7 +711,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn pop_stack_frame(&mut self, unwinding: bool) -> InterpResult<'tcx> {\n         info!(\n             \"LEAVING({}) {} (unwinding = {})\",\n-            self.cur_frame(),\n+            self.frame_idx(),\n             self.frame().instance,\n             unwinding\n         );\n@@ -720,7 +726,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         );\n \n         ::log_settings::settings().indentation -= 1;\n-        let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        let frame =\n+            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n         // Now where do we jump next?\n \n@@ -735,7 +742,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         if !cleanup {\n-            assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n+            assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n             // Leak the locals, skip validation, skip machine hook.\n@@ -784,10 +791,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             info!(\n                 \"CONTINUING({}) {} (unwinding = {})\",\n-                self.cur_frame(),\n+                self.frame_idx(),\n                 self.frame().instance,\n                 unwinding\n             );\n@@ -895,12 +902,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();\n                 let mut msg = format!(\"{:?}\", local);\n-                if frame != self.cur_frame() {\n-                    write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n+                if frame != self.frame_idx() {\n+                    write!(msg, \" ({} frames up)\", self.frame_idx() - frame).unwrap();\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].locals[local].value {\n+                match self.stack()[frame].locals[local].value {\n                     LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n                     LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n                     LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {"}, {"sha": "8bc0e2ee6a4c6a232d1e90cfa53a2e6e685ec0aa", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -149,7 +149,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     for InternVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = MPlaceTy<'tcx>;\n@@ -286,7 +286,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const_validation: bool,\n-) -> InterpResult<'tcx> {\n+) -> InterpResult<'tcx>\n+where\n+    'tcx: 'mir,\n+{\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match intern_kind {\n         // `static mut` doesn't care about interior mutability, it's mutable anyway"}, {"sha": "c8bf328ce8eeedbc5611b2ce1472b0816a0756d9", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -73,7 +73,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     })\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "91b046d7bb264c4ebbb685e85189f0f242ccf7a6", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -10,11 +10,11 @@ use crate::interpret::{\n     MPlaceTy, MemoryKind, Scalar,\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n     crate fn find_closest_untracked_caller_location(&self) -> Span {\n-        self.stack\n+        self.stack()\n             .iter()\n             .rev()\n             // Find first non-`#[track_caller]` frame."}, {"sha": "dfdd95c95a36482fe80b997427f1fc592f39b99d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -230,6 +230,34 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id\n     }\n \n+    /// Called when converting a `ty::Const` to an operand (in\n+    /// `eval_const_to_op`).\n+    ///\n+    /// Miri uses this callback for creating per thread allocations for thread\n+    /// locals. In Rust, one way of creating a thread local is by marking a\n+    /// static with `#[thread_local]`. On supported platforms this gets\n+    /// translated to a LLVM thread local for which LLVM automatically ensures\n+    /// that each thread gets its own copy. Since LLVM automatically handles\n+    /// thread locals, the Rust compiler just treats thread local statics as\n+    /// regular statics even though accessing a thread local static should be an\n+    /// effectful computation that depends on the current thread. The long term\n+    /// plan is to change MIR to make accesses to thread locals explicit\n+    /// (https://github.com/rust-lang/rust/issues/70685). While the issue 70685\n+    /// is not fixed, our current workaround in Miri is to use this function to\n+    /// make per-thread copies of thread locals. Please note that we cannot make\n+    /// these copies in `canonical_alloc_id` because that is too late: for\n+    /// example, if one created a pointer in thread `t1` to a thread local and\n+    /// sent it to another thread `t2`, resolving the access in\n+    /// `canonical_alloc_id` would result in pointer pointing to `t2`'s thread\n+    /// local and not `t1` as it should.\n+    #[inline]\n+    fn adjust_global_const(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        val: mir::interpret::ConstValue<'tcx>,\n+    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n+        Ok(val)\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -285,6 +313,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame: Frame<'mir, 'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n \n+    /// Borrow the current thread's stack.\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n+\n+    /// Mutably borrow the current thread's stack.\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+\n     /// Called immediately after a stack frame got pushed and its locals got initialized.\n     fn after_stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())"}, {"sha": "31e6fbdceee4ac9e0dbea670903959e837188122", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -209,7 +209,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Normalice `place.ptr` to a `Pointer` if this is a place and not a ZST.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     #[inline]\n@@ -440,7 +440,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match *place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n-            Place::Local { frame, local } => *self.access_local(&self.stack[frame], local, None)?,\n+            Place::Local { frame, local } => {\n+                *self.access_local(&self.stack()[frame], local, None)?\n+            }\n         };\n         Ok(OpTy { op, layout: place.layout })\n     }\n@@ -528,6 +530,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // potentially requiring the current static to be evaluated again. This is not a\n                 // problem here, because we are building an operand which means an actual read is\n                 // happening.\n+                //\n+                // The machine callback `adjust_global_const` below is guaranteed to\n+                // be called for all constants because `const_eval` calls\n+                // `eval_const_to_op` recursively.\n                 return Ok(self.const_eval(GlobalId { instance, promoted }, val.ty)?);\n             }\n             ty::ConstKind::Infer(..)\n@@ -537,6 +543,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n+        // This call allows the machine to create fresh allocation ids for\n+        // thread-local statics (see the `adjust_global_const` function\n+        // documentation).\n+        let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n         let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {"}, {"sha": "d651267f82b7943e38e43189186592267a75c5f9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -9,7 +9,7 @@ use rustc_target::abi::LayoutOf;\n \n use super::{ImmTy, Immediate, InterpCx, Machine, PlaceTy};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -45,7 +45,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "af3a9da2f6ca6c33ef681c9d9a1f1a6a11646e30", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -283,7 +283,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx, Tag, M> InterpCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n@@ -662,7 +662,7 @@ where\n             }\n             local => PlaceTy {\n                 // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.cur_frame(), local },\n+                place: Place::Local { frame: self.frame_idx(), local },\n                 layout: self.layout_of_local(self.frame(), local, None)?,\n             },\n         };\n@@ -755,7 +755,7 @@ where\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access_mut()? {\n+                match self.stack_mut()[frame].locals[local].access_mut()? {\n                     Ok(local) => {\n                         // Local can be updated in-place.\n                         *local = LocalValue::Live(Operand::Immediate(src));\n@@ -985,14 +985,15 @@ where\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access_mut()? {\n+                match self.stack_mut()[frame].locals[local].access_mut()? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n-                        let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n+                        let local_layout =\n+                            self.layout_of_local(&self.stack()[frame], local, None)?;\n                         // We also need to support unsized types, and hence cannot use `allocate`.\n                         let (size, align) = self\n                             .size_and_align_of(meta, local_layout)?\n@@ -1008,7 +1009,7 @@ where\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n-                        *self.stack[frame].locals[local].access_mut().unwrap().unwrap() =\n+                        *self.stack_mut()[frame].locals[local].access_mut().unwrap().unwrap() =\n                             LocalValue::Live(Operand::Indirect(mplace));\n                         (mplace, Some(size))\n                     }"}, {"sha": "aae708827b953e8e835812f38eb5b8fc4752ec38", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -29,7 +29,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())\n@@ -42,7 +42,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This is marked `#inline(always)` to work around adverserial codegen when `opt-level = 3`\n     #[inline(always)]\n     pub fn step(&mut self) -> InterpResult<'tcx, bool> {\n-        if self.stack.is_empty() {\n+        if self.stack().is_empty() {\n             return Ok(false);\n         }\n \n@@ -60,18 +60,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let body = self.body();\n         let basic_block = &body.basic_blocks()[block];\n \n-        let old_frames = self.cur_frame();\n+        let old_frames = self.frame_idx();\n \n         if let Some(stmt) = basic_block.statements.get(stmt_id) {\n-            assert_eq!(old_frames, self.cur_frame());\n+            assert_eq!(old_frames, self.frame_idx());\n             self.statement(stmt)?;\n             return Ok(true);\n         }\n \n         M::before_terminator(self)?;\n \n         let terminator = basic_block.terminator();\n-        assert_eq!(old_frames, self.cur_frame());\n+        assert_eq!(old_frames, self.frame_idx());\n         self.terminator(terminator)?;\n         Ok(true)\n     }\n@@ -84,7 +84,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // Some statements (e.g., box) push new stack frames.\n         // We have to record the stack frame number *before* executing the statement.\n-        let frame_idx = self.cur_frame();\n+        let frame_idx = self.frame_idx();\n \n         match &stmt.kind {\n             Assign(box (place, rvalue)) => self.eval_rvalue_into_place(rvalue, *place)?,\n@@ -126,7 +126,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             LlvmInlineAsm { .. } => throw_unsup_format!(\"inline assembly is not supported\"),\n         }\n \n-        self.stack[frame_idx].stmt += 1;\n+        self.stack_mut()[frame_idx].stmt += 1;\n         Ok(())\n     }\n \n@@ -278,7 +278,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n-        if !self.stack.is_empty() {\n+        if !self.stack().is_empty() {\n             if let Some(block) = self.frame().block {\n                 info!(\"// executing {:?}\", block);\n             }"}, {"sha": "7157225e5c9bb398b565deded00205a1e417e29c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -11,7 +11,7 @@ use super::{\n     FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -52,7 +52,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Call { ref func, ref args, destination, ref cleanup, .. } => {\n-                let old_stack = self.cur_frame();\n+                let old_stack = self.frame_idx();\n                 let old_bb = self.frame().block;\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n@@ -80,7 +80,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n-                if self.cur_frame() == old_stack && self.frame().block == old_bb {\n+                if self.frame_idx() == old_stack && self.frame().block == old_bb {\n                     span_bug!(terminator.source_info.span, \"evaluating this call made no progress\");\n                 }\n             }\n@@ -372,7 +372,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 match res {\n                     Err(err) => {\n-                        self.stack.pop();\n+                        self.stack_mut().pop();\n                         Err(err)\n                     }\n                     Ok(()) => Ok(()),"}, {"sha": "7edd787c986bd9a943a4b9be96d1609ce858dc32", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -6,7 +6,7 @@ use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "e97a39f8c6fec347d6d7d4651d6fe38469c477eb", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -178,7 +178,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n+impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n@@ -610,7 +610,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n     }\n }\n \n-impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n@@ -813,7 +813,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn validate_operand_internal(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,"}, {"sha": "903aa377a3d7ddd74c2f1b778a81417056cfa90e", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -37,7 +37,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n \n // Operands and memory-places are both values.\n // Places in general are not due to `place_field` having to do `force_allocation`.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n@@ -75,7 +75,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n+    for MPlaceTy<'tcx, M::PointerTag>\n+{\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout"}, {"sha": "79dba2c5db8fbc0e37b17a94f66a489fa5ac408f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b55eed638db7db34e887ef255c765bc8910ec0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c6b55eed638db7db34e887ef255c765bc8910ec0", "patch": "@@ -158,9 +158,18 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine;\n+struct ConstPropMachine<'mir, 'tcx> {\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+}\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n+impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n+    fn new() -> Self {\n+        Self { stack: Vec::new() }\n+    }\n+}\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n     type MemoryKind = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -296,11 +305,25 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n         Ok(frame)\n     }\n+\n+    #[inline(always)]\n+    fn stack(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        &ecx.machine.stack\n+    }\n+\n+    #[inline(always)]\n+    fn stack_mut(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        &mut ecx.machine.stack\n+    }\n }\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n+    ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     param_env: ParamEnv<'tcx>,\n@@ -349,7 +372,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n+        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx"}]}