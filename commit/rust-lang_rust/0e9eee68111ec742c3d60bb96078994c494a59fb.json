{"sha": "0e9eee68111ec742c3d60bb96078994c494a59fb", "node_id": "C_kwDOAAsO6NoAKDBlOWVlZTY4MTExZWM3NDJjM2Q2MGJiOTYwNzg5OTRjNDk0YTU5ZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T04:09:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-27T04:09:53Z"}, "message": "Auto merge of #96451 - JakobDegen:dest-prop, r=tmiasko\n\nFix Dest Prop\n\nCloses #82678, #79191 .\n\nThis was not originally a total re-write of the pass but is has gradually turned into one. Notable changes:\n\n 1. Significant improvements to documentation all around. The top of the file has been extended with a more precise argument for soundness. The code should be fairly readable, and I've done my best to add useful comments wherever possible. I would very much like for the bus factor to not be one on this code.\n 3. Improved handling of conflicts that are not visible in normal dataflow.  This was the cause of #79191. Handling this correctly requires us to make decision about the semantics and specifically evaluation order of basically all MIR constructs (see specifically #68364 #71117.  The way this is implemented is based on my preferred resolution to these questions around the semantics of assignment statements.\n 4. Some re-architecting to improve performance. More details below.\n 5. Possible future improvements to this optimization are documented, and the code is written with the needs of those improvements in mind. The hope is that adding support for more precise analyses will not require a full re-write of this opt, but just localized changes.\n\n### Regarding Performance\n\nThe previous approach had some performance issues; letting `l` be the number of locals and `s` be the number of statements/terminators, the runtime of the pass was `O(l^2 * s)`, both in theory and in practice. This version is smarter about not calculating unnecessary things and doing more caching. Our runtime is now dominated by one invocation of `MaybeLiveLocals` for each \"round,\" and the number of rounds is less than 5 in over 90% of cases. This means it's linear-ish in practice.\n\nr? `@oli-obk` who reviewed the last version of this, but review from anyone else would be more than welcome", "tree": {"sha": "74a2c65e8f153b54fea79f62d7e424ab234e6448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74a2c65e8f153b54fea79f62d7e424ab234e6448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e9eee68111ec742c3d60bb96078994c494a59fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9eee68111ec742c3d60bb96078994c494a59fb", "html_url": "https://github.com/rust-lang/rust/commit/0e9eee68111ec742c3d60bb96078994c494a59fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e9eee68111ec742c3d60bb96078994c494a59fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf1891deb2633fe4040de8b71fd7b2045c45dc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf1891deb2633fe4040de8b71fd7b2045c45dc5", "html_url": "https://github.com/rust-lang/rust/commit/faf1891deb2633fe4040de8b71fd7b2045c45dc5"}, {"sha": "245c60749a20c9e8f3cca872446fb37d40b6e072", "url": "https://api.github.com/repos/rust-lang/rust/commits/245c60749a20c9e8f3cca872446fb37d40b6e072", "html_url": "https://github.com/rust-lang/rust/commit/245c60749a20c9e8f3cca872446fb37d40b6e072"}], "stats": {"total": 2263, "additions": 1039, "deletions": 1224}, "files": [{"sha": "83ce4c44b7144e5cfa97c5d5c67feb5f55364396", "filename": "compiler/rustc_mir_dataflow/src/impls/init_locals.rs", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/faf1891deb2633fe4040de8b71fd7b2045c45dc5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf1891deb2633fe4040de8b71fd7b2045c45dc5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Finit_locals.rs?ref=faf1891deb2633fe4040de8b71fd7b2045c45dc5", "patch": "@@ -1,122 +0,0 @@\n-//! A less precise version of `MaybeInitializedPlaces` whose domain is entire locals.\n-//!\n-//! A local will be maybe initialized if *any* projections of that local might be initialized.\n-\n-use crate::{CallReturnPlaces, GenKill};\n-\n-use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::visit::{PlaceContext, Visitor};\n-use rustc_middle::mir::{self, BasicBlock, Local, Location};\n-\n-pub struct MaybeInitializedLocals;\n-\n-impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeInitializedLocals {\n-    type Domain = BitSet<Local>;\n-\n-    const NAME: &'static str = \"maybe_init_locals\";\n-\n-    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        // bottom = uninit\n-        BitSet::new_empty(body.local_decls.len())\n-    }\n-\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, entry_set: &mut Self::Domain) {\n-        // Function arguments are initialized to begin with.\n-        for arg in body.args_iter() {\n-            entry_set.insert(arg);\n-        }\n-    }\n-}\n-\n-impl<'tcx> crate::GenKillAnalysis<'tcx> for MaybeInitializedLocals {\n-    type Idx = Local;\n-\n-    fn statement_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        statement: &mir::Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        TransferFunction { trans }.visit_statement(statement, loc)\n-    }\n-\n-    fn terminator_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        TransferFunction { trans }.visit_terminator(terminator, loc)\n-    }\n-\n-    fn call_return_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: BasicBlock,\n-        return_places: CallReturnPlaces<'_, 'tcx>,\n-    ) {\n-        return_places.for_each(|place| trans.gen(place.local));\n-    }\n-\n-    /// See `Analysis::apply_yield_resume_effect`.\n-    fn yield_resume_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _resume_block: BasicBlock,\n-        resume_place: mir::Place<'tcx>,\n-    ) {\n-        trans.gen(resume_place.local)\n-    }\n-}\n-\n-struct TransferFunction<'a, T> {\n-    trans: &'a mut T,\n-}\n-\n-impl<T> Visitor<'_> for TransferFunction<'_, T>\n-where\n-    T: GenKill<Local>,\n-{\n-    // FIXME: Using `visit_local` here is a bug. For example, on `move _5.field` we mark `_5` as\n-    // deinitialized, although clearly it is only partially deinitialized. This analysis is not\n-    // actually used anywhere at the moment, so this is not critical, but this does need to be fixed\n-    // before it starts being used again.\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, NonUseContext};\n-        match context {\n-            // These are handled specially in `call_return_effect` and `yield_resume_effect`.\n-            PlaceContext::MutatingUse(\n-                MutatingUseContext::Call\n-                | MutatingUseContext::AsmOutput\n-                | MutatingUseContext::Yield,\n-            ) => {}\n-\n-            // If it's deinitialized, it's no longer init\n-            PlaceContext::MutatingUse(MutatingUseContext::Deinit) => self.trans.kill(local),\n-\n-            // Otherwise, when a place is mutated, we must consider it possibly initialized.\n-            PlaceContext::MutatingUse(_) => self.trans.gen(local),\n-\n-            // If the local is moved out of, or if it gets marked `StorageDead`, consider it no\n-            // longer initialized.\n-            PlaceContext::NonUse(NonUseContext::StorageDead)\n-            | PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => self.trans.kill(local),\n-\n-            // All other uses do not affect this analysis.\n-            PlaceContext::NonUse(\n-                NonUseContext::StorageLive\n-                | NonUseContext::AscribeUserTy\n-                | NonUseContext::VarDebugInfo,\n-            )\n-            | PlaceContext::NonMutatingUse(\n-                NonMutatingUseContext::Inspect\n-                | NonMutatingUseContext::Copy\n-                | NonMutatingUseContext::SharedBorrow\n-                | NonMutatingUseContext::ShallowBorrow\n-                | NonMutatingUseContext::UniqueBorrow\n-                | NonMutatingUseContext::AddressOf\n-                | NonMutatingUseContext::Projection,\n-            ) => {}\n-        }\n-    }\n-}"}, {"sha": "bc31ec42b8b6e3af8e6b3dc4f2c13e9b646a8d37", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -19,13 +19,11 @@ use crate::{drop_flag_effects, on_all_children_bits};\n use crate::{lattice, AnalysisDomain, GenKill, GenKillAnalysis};\n \n mod borrowed_locals;\n-mod init_locals;\n mod liveness;\n mod storage_liveness;\n \n pub use self::borrowed_locals::borrowed_locals;\n pub use self::borrowed_locals::MaybeBorrowedLocals;\n-pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n pub use self::liveness::MaybeTransitiveLiveLocals;\n pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};"}, {"sha": "42c580c63f06046e56d9b81290c7bf8fb0ee4c75", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -70,6 +70,8 @@ pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitS\n     for Location { block, statement_index } in patch {\n         bbs[block].statements[statement_index].make_nop();\n     }\n+\n+    crate::simplify::SimplifyLocals.run_pass(tcx, body)\n }\n \n pub struct DeadStoreElimination;"}, {"sha": "92f1fff6beb950f7d1b72bef8d8ce775bc4fcf55", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -110,15 +110,16 @@ impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n \n         if let TerminatorKind::Call { ref args, .. } = terminator.kind {\n             for arg in args {\n-                if let Operand::Move(_) = *arg {\n-                    // ArgumentChecker panics if a direct move of an argument from a caller to a\n-                    // callee was detected.\n-                    //\n-                    // If, in the future, MIR optimizations cause arguments to be moved directly\n-                    // from callers to callees, change the panic to instead add the argument in\n-                    // question to `mutating_uses`.\n-                    ArgumentChecker::new(self.mutable_args.domain_size())\n-                        .visit_operand(arg, location)\n+                if let Operand::Move(place) = *arg {\n+                    let local = place.local;\n+                    if place.is_indirect()\n+                        || local == RETURN_PLACE\n+                        || local.index() > self.mutable_args.domain_size()\n+                    {\n+                        continue;\n+                    }\n+\n+                    self.mutable_args.insert(local.index() - 1);\n                 }\n             }\n         };\n@@ -127,35 +128,6 @@ impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n     }\n }\n \n-/// A visitor that simply panics if a direct move of an argument from a caller to a callee was\n-/// detected.\n-struct ArgumentChecker {\n-    /// The number of arguments to the calling function.\n-    arg_count: usize,\n-}\n-\n-impl ArgumentChecker {\n-    /// Creates a new ArgumentChecker.\n-    fn new(arg_count: usize) -> Self {\n-        Self { arg_count }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ArgumentChecker {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        // Check to make sure that, if this local is an argument, we didn't move directly from it.\n-        if matches!(context, PlaceContext::NonMutatingUse(NonMutatingUseContext::Move))\n-            && local != RETURN_PLACE\n-            && local.index() <= self.arg_count\n-        {\n-            // If, in the future, MIR optimizations cause arguments to be moved directly from\n-            // callers to callees, change this panic to instead add the argument in question to\n-            // `mutating_uses`.\n-            panic!(\"Detected a direct move from a caller's argument to a callee's argument!\")\n-        }\n-    }\n-}\n-\n /// Returns true if values of a given type will never be passed indirectly, regardless of ABI.\n fn type_will_always_be_passed_directly<'tcx>(ty: Ty<'tcx>) -> bool {\n     matches!("}, {"sha": "8cd44ab82ccc4cb35d392840d90ee7b8a24cf2d6", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 602, "deletions": 697, "changes": 1299, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -20,7 +20,8 @@\n //! values or the return place `_0`. On a very high level, independent of the actual implementation\n //! details, it does the following:\n //!\n-//! 1) Identify `dest = src;` statements that can be soundly eliminated.\n+//! 1) Identify `dest = src;` statements with values for `dest` and `src` whose storage can soundly\n+//!    be merged.\n //! 2) Replace all mentions of `src` with `dest` (\"unifying\" them and propagating the destination\n //!    backwards).\n //! 3) Delete the `dest = src;` statement (by making it a `nop`).\n@@ -29,53 +30,88 @@\n //!\n //! ## Soundness\n //!\n-//! Given an `Assign` statement `dest = src;`, where `dest` is a `Place` and `src` is an `Rvalue`,\n-//! there are a few requirements that must hold for the optimization to be sound:\n+//! We have a pair of places `p` and `q`, whose memory we would like to merge. In order for this to\n+//! be sound, we need to check a number of conditions:\n //!\n-//! * `dest` must not contain any *indirection* through a pointer. It must access part of the base\n-//!   local. Otherwise it might point to arbitrary memory that is hard to track.\n+//! * `p` and `q` must both be *constant* - it does not make much sense to talk about merging them\n+//!   if they do not consistently refer to the same place in memory. This is satisfied if they do\n+//!   not contain any indirection through a pointer or any indexing projections.\n //!\n-//!   It must also not contain any indexing projections, since those take an arbitrary `Local` as\n-//!   the index, and that local might only be initialized shortly before `dest` is used.\n+//! * We need to make sure that the goal of \"merging the memory\" is actually structurally possible\n+//!   in MIR. For example, even if all the other conditions are satisfied, there is no way to\n+//!   \"merge\" `_5.foo` and `_6.bar`. For now, we ensure this by requiring that both `p` and `q` are\n+//!   locals with no further projections. Future iterations of this pass should improve on this.\n //!\n-//! * `src` must be a bare `Local` without any indirections or field projections (FIXME: Is this a\n-//!   fundamental restriction or just current impl state?). It can be copied or moved by the\n-//!   assignment.\n+//! * Finally, we want `p` and `q` to use the same memory - however, we still need to make sure that\n+//!   each of them has enough \"ownership\" of that memory to continue \"doing its job.\" More\n+//!   precisely, what we will check is that whenever the program performs a write to `p`, then it\n+//!   does not currently care about what the value in `q` is (and vice versa). We formalize the\n+//!   notion of \"does not care what the value in `q` is\" by checking the *liveness* of `q`.\n //!\n-//! * The `dest` and `src` locals must never be [*live*][liveness] at the same time. If they are, it\n-//!   means that they both hold a (potentially different) value that is needed by a future use of\n-//!   the locals. Unifying them would overwrite one of the values.\n+//!   Because of the difficulty of computing liveness of places that have their address taken, we do\n+//!   not even attempt to do it. Any places that are in a local that has its address taken is\n+//!   excluded from the optimization.\n //!\n-//!   Note that computing liveness of locals that have had their address taken is more difficult:\n-//!   Short of doing full escape analysis on the address/pointer/reference, the pass would need to\n-//!   assume that any operation that can potentially involve opaque user code (such as function\n-//!   calls, destructors, and inline assembly) may access any local that had its address taken\n-//!   before that point.\n+//! The first two conditions are simple structural requirements on the `Assign` statements that can\n+//! be trivially checked. The third requirement however is more difficult and costly to check.\n //!\n-//! Here, the first two conditions are simple structural requirements on the `Assign` statements\n-//! that can be trivially checked. The liveness requirement however is more difficult and costly to\n-//! check.\n+//! ## Future Improvements\n+//!\n+//! There are a number of ways in which this pass could be improved in the future:\n+//!\n+//! * Merging storage liveness ranges instead of removing storage statements completely. This may\n+//!   improve stack usage.\n+//!\n+//! * Allow merging locals into places with projections, eg `_5` into `_6.foo`.\n+//!\n+//! * Liveness analysis with more precision than whole locals at a time. The smaller benefit of this\n+//!   is that it would allow us to dest prop at \"sub-local\" levels in some cases. The bigger benefit\n+//!   of this is that such liveness analysis can report more accurate results about whole locals at\n+//!   a time. For example, consider:\n+//!\n+//!   ```ignore (syntax-highliting-only)\n+//!   _1 = u;\n+//!   // unrelated code\n+//!   _1.f1 = v;\n+//!   _2 = _1.f1;\n+//!   ```\n+//!\n+//!   Because the current analysis only thinks in terms of locals, it does not have enough\n+//!   information to report that `_1` is dead in the \"unrelated code\" section.\n+//!\n+//! * Liveness analysis enabled by alias analysis. This would allow us to not just bail on locals\n+//!   that ever have their address taken. Of course that requires actually having alias analysis\n+//!   (and a model to build it on), so this might be a bit of a ways off.\n+//!\n+//! * Various perf improvents. There are a bunch of comments in here marked `PERF` with ideas for\n+//!   how to do things more efficiently. However, the complexity of the pass as a whole should be\n+//!   kept in mind.\n //!\n //! ## Previous Work\n //!\n-//! A [previous attempt] at implementing an optimization like this turned out to be a significant\n-//! regression in compiler performance. Fixing the regressions introduced a lot of undesirable\n-//! complexity to the implementation.\n+//! A [previous attempt][attempt 1] at implementing an optimization like this turned out to be a\n+//! significant regression in compiler performance. Fixing the regressions introduced a lot of\n+//! undesirable complexity to the implementation.\n+//!\n+//! A [subsequent approach][attempt 2] tried to avoid the costly computation by limiting itself to\n+//! acyclic CFGs, but still turned out to be far too costly to run due to suboptimal performance\n+//! within individual basic blocks, requiring a walk across the entire block for every assignment\n+//! found within the block. For the `tuple-stress` benchmark, which has 458745 statements in a\n+//! single block, this proved to be far too costly.\n //!\n-//! A [subsequent approach] tried to avoid the costly computation by limiting itself to acyclic\n-//! CFGs, but still turned out to be far too costly to run due to suboptimal performance within\n-//! individual basic blocks, requiring a walk across the entire block for every assignment found\n-//! within the block. For the `tuple-stress` benchmark, which has 458745 statements in a single\n-//! block, this proved to be far too costly.\n+//! [Another approach after that][attempt 3] was much closer to correct, but had some soundness\n+//! issues - it was failing to consider stores outside live ranges, and failed to uphold some of the\n+//! requirements that MIR has for non-overlapping places within statements. However, it also had\n+//! performance issues caused by `O(l\u00b2 * s)` runtime, where `l` is the number of locals and `s` is\n+//! the number of statements and terminators.\n //!\n //! Since the first attempt at this, the compiler has improved dramatically, and new analysis\n //! frameworks have been added that should make this approach viable without requiring a limited\n //! approach that only works for some classes of CFGs:\n //! - rustc now has a powerful dataflow analysis framework that can handle forwards and backwards\n //!   analyses efficiently.\n //! - Layout optimizations for generators have been added to improve code generation for\n-//!   async/await, which are very similar in spirit to what this optimization does. Both walk the\n-//!   MIR and record conflicting uses of locals in a `BitMatrix`.\n+//!   async/await, which are very similar in spirit to what this optimization does.\n //!\n //! Also, rustc now has a simple NRVO pass (see `nrvo.rs`), which handles a subset of the cases that\n //! this destination propagation pass handles, proving that similar optimizations can be performed\n@@ -87,253 +123,205 @@\n //! it replaces the eliminated assign statements with `nop`s and leaves unused locals behind.\n //!\n //! [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n-//! [previous attempt]: https://github.com/rust-lang/rust/pull/47954\n-//! [subsequent approach]: https://github.com/rust-lang/rust/pull/71003\n+//! [attempt 1]: https://github.com/rust-lang/rust/pull/47954\n+//! [attempt 2]: https://github.com/rust-lang/rust/pull/71003\n+//! [attempt 3]: https://github.com/rust-lang/rust/pull/72632\n+\n+use std::collections::hash_map::{Entry, OccupiedEntry};\n \n use crate::MirPass;\n-use itertools::Itertools;\n-use rustc_data_structures::unify::{InPlaceUnificationTable, UnifyKey};\n-use rustc_index::{\n-    bit_set::{BitMatrix, BitSet},\n-    vec::IndexVec,\n-};\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{dump_mir, PassWhere};\n use rustc_middle::mir::{\n-    traversal, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place, PlaceElem,\n-    Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n+    traversal, BasicBlock, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place,\n+    Rvalue, Statement, StatementKind, TerminatorKind,\n+};\n+use rustc_middle::mir::{\n+    visit::{MutVisitor, PlaceContext, Visitor},\n+    ProjectionElem,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_mir_dataflow::impls::{borrowed_locals, MaybeInitializedLocals, MaybeLiveLocals};\n-use rustc_mir_dataflow::Analysis;\n-\n-// Empirical measurements have resulted in some observations:\n-// - Running on a body with a single block and 500 locals takes barely any time\n-// - Running on a body with ~400 blocks and ~300 relevant locals takes \"too long\"\n-// ...so we just limit both to somewhat reasonable-ish looking values.\n-const MAX_LOCALS: usize = 500;\n-const MAX_BLOCKS: usize = 250;\n+use rustc_mir_dataflow::impls::MaybeLiveLocals;\n+use rustc_mir_dataflow::{Analysis, ResultsCursor};\n \n pub struct DestinationPropagation;\n \n impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        //  FIXME(#79191, #82678): This is unsound.\n-        //\n-        // Only run at mir-opt-level=3 or higher for now (we don't fix up debuginfo and remove\n-        // storage statements at the moment).\n-        sess.opts.unstable_opts.unsound_mir_opts && sess.mir_opt_level() >= 3\n+        // For now, only run at MIR opt level 3. Two things need to be changed before this can be\n+        // turned on by default:\n+        //  1. Because of the overeager removal of storage statements, this can cause stack space\n+        //     regressions. This opt is not the place to fix this though, it's a more general\n+        //     problem in MIR.\n+        //  2. Despite being an overall perf improvement, this still causes a 30% regression in\n+        //     keccak. We can temporarily fix this by bounding function size, but in the long term\n+        //     we should fix this by being smarter about invalidating analysis results.\n+        sess.mir_opt_level() >= 3\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = body.source.def_id();\n+        let mut allocations = Allocations::default();\n+        trace!(func = ?tcx.def_path_str(def_id));\n \n-        let candidates = find_candidates(body);\n-        if candidates.is_empty() {\n-            debug!(\"{:?}: no dest prop candidates, done\", def_id);\n-            return;\n-        }\n+        let borrowed = rustc_mir_dataflow::impls::borrowed_locals(body);\n \n-        // Collect all locals we care about. We only compute conflicts for these to save time.\n-        let mut relevant_locals = BitSet::new_empty(body.local_decls.len());\n-        for CandidateAssignment { dest, src, loc: _ } in &candidates {\n-            relevant_locals.insert(dest.local);\n-            relevant_locals.insert(*src);\n-        }\n-\n-        // This pass unfortunately has `O(l\u00b2 * s)` performance, where `l` is the number of locals\n-        // and `s` is the number of statements and terminators in the function.\n-        // To prevent blowing up compile times too much, we bail out when there are too many locals.\n-        let relevant = relevant_locals.count();\n-        debug!(\n-            \"{:?}: {} locals ({} relevant), {} blocks\",\n-            def_id,\n-            body.local_decls.len(),\n-            relevant,\n-            body.basic_blocks.len()\n-        );\n-        if relevant > MAX_LOCALS {\n-            warn!(\n-                \"too many candidate locals in {:?} ({}, max is {}), not optimizing\",\n-                def_id, relevant, MAX_LOCALS\n+        // In order to avoid having to collect data for every single pair of locals in the body, we\n+        // do not allow doing more than one merge for places that are derived from the same local at\n+        // once. To avoid missed opportunities, we instead iterate to a fixed point - we'll refer to\n+        // each of these iterations as a \"round.\"\n+        //\n+        // Reaching a fixed point could in theory take up to `min(l, s)` rounds - however, we do not\n+        // expect to see MIR like that. To verify this, a test was run against `[rust-lang/regex]` -\n+        // the average MIR body saw 1.32 full iterations of this loop. The most that was hit were 30\n+        // for a single function. Only 80/2801 (2.9%) of functions saw at least 5.\n+        //\n+        // [rust-lang/regex]:\n+        //     https://github.com/rust-lang/regex/tree/b5372864e2df6a2f5e543a556a62197f50ca3650\n+        let mut round_count = 0;\n+        loop {\n+            // PERF: Can we do something smarter than recalculating the candidates and liveness\n+            // results?\n+            let mut candidates = find_candidates(\n+                body,\n+                &borrowed,\n+                &mut allocations.candidates,\n+                &mut allocations.candidates_reverse,\n             );\n-            return;\n-        }\n-        if body.basic_blocks.len() > MAX_BLOCKS {\n-            warn!(\n-                \"too many blocks in {:?} ({}, max is {}), not optimizing\",\n-                def_id,\n-                body.basic_blocks.len(),\n-                MAX_BLOCKS\n+            trace!(?candidates);\n+            let mut live = MaybeLiveLocals\n+                .into_engine(tcx, body)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(body);\n+            dest_prop_mir_dump(tcx, body, &mut live, round_count);\n+\n+            FilterInformation::filter_liveness(\n+                &mut candidates,\n+                &mut live,\n+                &mut allocations.write_info,\n+                body,\n             );\n-            return;\n-        }\n \n-        let mut conflicts = Conflicts::build(tcx, body, &relevant_locals);\n+            // Because we do not update liveness information, it is unsound to use a local for more\n+            // than one merge operation within a single round of optimizations. We store here which\n+            // ones we have already used.\n+            let mut merged_locals: BitSet<Local> = BitSet::new_empty(body.local_decls.len());\n \n-        let mut replacements = Replacements::new(body.local_decls.len());\n-        for candidate @ CandidateAssignment { dest, src, loc } in candidates {\n-            // Merge locals that don't conflict.\n-            if !conflicts.can_unify(dest.local, src) {\n-                debug!(\"at assignment {:?}, conflict {:?} vs. {:?}\", loc, dest.local, src);\n-                continue;\n-            }\n+            // This is the set of merges we will apply this round. It is a subset of the candidates.\n+            let mut merges = FxHashMap::default();\n \n-            if replacements.for_src(candidate.src).is_some() {\n-                debug!(\"src {:?} already has replacement\", candidate.src);\n-                continue;\n+            for (src, candidates) in candidates.c.iter() {\n+                if merged_locals.contains(*src) {\n+                    continue;\n+                }\n+                let Some(dest) =\n+                    candidates.iter().find(|dest| !merged_locals.contains(**dest)) else {\n+                        continue;\n+                };\n+                if !tcx.consider_optimizing(|| {\n+                    format!(\"{} round {}\", tcx.def_path_str(def_id), round_count)\n+                }) {\n+                    break;\n+                }\n+                merges.insert(*src, *dest);\n+                merged_locals.insert(*src);\n+                merged_locals.insert(*dest);\n             }\n+            trace!(merging = ?merges);\n \n-            if !tcx.consider_optimizing(|| {\n-                format!(\"DestinationPropagation {:?} {:?}\", def_id, candidate)\n-            }) {\n+            if merges.is_empty() {\n                 break;\n             }\n+            round_count += 1;\n \n-            replacements.push(candidate);\n-            conflicts.unify(candidate.src, candidate.dest.local);\n+            apply_merges(body, tcx, &merges, &merged_locals);\n         }\n \n-        replacements.flatten(tcx);\n-\n-        debug!(\"replacements {:?}\", replacements.map);\n-\n-        Replacer { tcx, replacements, place_elem_cache: Vec::new() }.visit_body(body);\n-\n-        // FIXME fix debug info\n+        trace!(round_count);\n     }\n }\n \n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-struct UnifyLocal(Local);\n-\n-impl From<Local> for UnifyLocal {\n-    fn from(l: Local) -> Self {\n-        Self(l)\n-    }\n-}\n-\n-impl UnifyKey for UnifyLocal {\n-    type Value = ();\n-    #[inline]\n-    fn index(&self) -> u32 {\n-        self.0.as_u32()\n-    }\n-    #[inline]\n-    fn from_index(u: u32) -> Self {\n-        Self(Local::from_u32(u))\n-    }\n-    fn tag() -> &'static str {\n-        \"UnifyLocal\"\n-    }\n+/// Container for the various allocations that we need.\n+///\n+/// We store these here and hand out `&mut` access to them, instead of dropping and recreating them\n+/// frequently. Everything with a `&'alloc` lifetime points into here.\n+#[derive(Default)]\n+struct Allocations {\n+    candidates: FxHashMap<Local, Vec<Local>>,\n+    candidates_reverse: FxHashMap<Local, Vec<Local>>,\n+    write_info: WriteInfo,\n+    // PERF: Do this for `MaybeLiveLocals` allocations too.\n }\n \n-struct Replacements<'tcx> {\n-    /// Maps locals to their replacement.\n-    map: IndexVec<Local, Option<Place<'tcx>>>,\n-\n-    /// Whose locals' live ranges to kill.\n-    kill: BitSet<Local>,\n+#[derive(Debug)]\n+struct Candidates<'alloc> {\n+    /// The set of candidates we are considering in this optimization.\n+    ///\n+    /// We will always merge the key into at most one of its values.\n+    ///\n+    /// Whether a place ends up in the key or the value does not correspond to whether it appears as\n+    /// the lhs or rhs of any assignment. As a matter of fact, the places in here might never appear\n+    /// in an assignment at all. This happens because if we see an assignment like this:\n+    ///\n+    /// ```ignore (syntax-highlighting-only)\n+    /// _1.0 = _2.0\n+    /// ```\n+    ///\n+    /// We will still report that we would like to merge `_1` and `_2` in an attempt to allow us to\n+    /// remove that assignment.\n+    c: &'alloc mut FxHashMap<Local, Vec<Local>>,\n+    /// A reverse index of the `c` set; if the `c` set contains `a => Place { local: b, proj }`,\n+    /// then this contains `b => a`.\n+    // PERF: Possibly these should be `SmallVec`s?\n+    reverse: &'alloc mut FxHashMap<Local, Vec<Local>>,\n }\n \n-impl<'tcx> Replacements<'tcx> {\n-    fn new(locals: usize) -> Self {\n-        Self { map: IndexVec::from_elem_n(None, locals), kill: BitSet::new_empty(locals) }\n-    }\n-\n-    fn push(&mut self, candidate: CandidateAssignment<'tcx>) {\n-        trace!(\"Replacements::push({:?})\", candidate);\n-        let entry = &mut self.map[candidate.src];\n-        assert!(entry.is_none());\n-\n-        *entry = Some(candidate.dest);\n-        self.kill.insert(candidate.src);\n-        self.kill.insert(candidate.dest.local);\n-    }\n-\n-    /// Applies the stored replacements to all replacements, until no replacements would result in\n-    /// locals that need further replacements when applied.\n-    fn flatten(&mut self, tcx: TyCtxt<'tcx>) {\n-        // Note: This assumes that there are no cycles in the replacements, which is enforced via\n-        // `self.unified_locals`. Otherwise this can cause an infinite loop.\n-\n-        for local in self.map.indices() {\n-            if let Some(replacement) = self.map[local] {\n-                // Substitute the base local of `replacement` until fixpoint.\n-                let mut base = replacement.local;\n-                let mut reversed_projection_slices = Vec::with_capacity(1);\n-                while let Some(replacement_for_replacement) = self.map[base] {\n-                    base = replacement_for_replacement.local;\n-                    reversed_projection_slices.push(replacement_for_replacement.projection);\n-                }\n-\n-                let projection: Vec<_> = reversed_projection_slices\n-                    .iter()\n-                    .rev()\n-                    .flat_map(|projs| projs.iter())\n-                    .chain(replacement.projection.iter())\n-                    .collect();\n-                let projection = tcx.intern_place_elems(&projection);\n+//////////////////////////////////////////////////////////\n+// Merging\n+//\n+// Applies the actual optimization\n \n-                // Replace with the final `Place`.\n-                self.map[local] = Some(Place { local: base, projection });\n-            }\n-        }\n-    }\n-\n-    fn for_src(&self, src: Local) -> Option<Place<'tcx>> {\n-        self.map[src]\n-    }\n+fn apply_merges<'tcx>(\n+    body: &mut Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    merges: &FxHashMap<Local, Local>,\n+    merged_locals: &BitSet<Local>,\n+) {\n+    let mut merger = Merger { tcx, merges, merged_locals };\n+    merger.visit_body_preserves_cfg(body);\n }\n \n-struct Replacer<'tcx> {\n+struct Merger<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    replacements: Replacements<'tcx>,\n-    place_elem_cache: Vec<PlaceElem<'tcx>>,\n+    merges: &'a FxHashMap<Local, Local>,\n+    merged_locals: &'a BitSet<Local>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for Merger<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n-    fn visit_local(&mut self, local: &mut Local, context: PlaceContext, location: Location) {\n-        if context.is_use() && self.replacements.for_src(*local).is_some() {\n-            bug!(\n-                \"use of local {:?} should have been replaced by visit_place; context={:?}, loc={:?}\",\n-                local,\n-                context,\n-                location,\n-            );\n+    fn visit_local(&mut self, local: &mut Local, _: PlaceContext, _location: Location) {\n+        if let Some(dest) = self.merges.get(local) {\n+            *local = *dest;\n         }\n     }\n \n-    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if let Some(replacement) = self.replacements.for_src(place.local) {\n-            // Rebase `place`s projections onto `replacement`'s.\n-            self.place_elem_cache.clear();\n-            self.place_elem_cache.extend(replacement.projection.iter().chain(place.projection));\n-            let projection = self.tcx.intern_place_elems(&self.place_elem_cache);\n-            let new_place = Place { local: replacement.local, projection };\n-\n-            debug!(\"Replacer: {:?} -> {:?}\", place, new_place);\n-            *place = new_place;\n-        }\n-\n-        self.super_place(place, context, location);\n-    }\n-\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        self.super_statement(statement, location);\n-\n         match &statement.kind {\n-            // FIXME: Don't delete storage statements, merge the live ranges instead\n+            // FIXME: Don't delete storage statements, but \"merge\" the storage ranges instead.\n             StatementKind::StorageDead(local) | StatementKind::StorageLive(local)\n-                if self.replacements.kill.contains(*local) =>\n+                if self.merged_locals.contains(*local) =>\n             {\n-                statement.make_nop()\n+                statement.make_nop();\n+                return;\n             }\n-\n+            _ => (),\n+        };\n+        self.super_statement(statement, location);\n+        match &statement.kind {\n             StatementKind::Assign(box (dest, rvalue)) => {\n                 match rvalue {\n                     Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) => {\n@@ -353,524 +341,427 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n     }\n }\n \n-struct Conflicts<'a> {\n-    relevant_locals: &'a BitSet<Local>,\n-\n-    /// The conflict matrix. It is always symmetric and the adjacency matrix of the corresponding\n-    /// conflict graph.\n-    matrix: BitMatrix<Local, Local>,\n-\n-    /// Preallocated `BitSet` used by `unify`.\n-    unify_cache: BitSet<Local>,\n-\n-    /// Tracks locals that have been merged together to prevent cycles and propagate conflicts.\n-    unified_locals: InPlaceUnificationTable<UnifyLocal>,\n+//////////////////////////////////////////////////////////\n+// Liveness filtering\n+//\n+// This section enforces bullet point 2\n+\n+struct FilterInformation<'a, 'body, 'alloc, 'tcx> {\n+    body: &'body Body<'tcx>,\n+    live: &'a mut ResultsCursor<'body, 'tcx, MaybeLiveLocals>,\n+    candidates: &'a mut Candidates<'alloc>,\n+    write_info: &'alloc mut WriteInfo,\n+    at: Location,\n }\n \n-impl<'a> Conflicts<'a> {\n-    fn build<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'_ Body<'tcx>,\n-        relevant_locals: &'a BitSet<Local>,\n-    ) -> Self {\n-        // We don't have to look out for locals that have their address taken, since\n-        // `find_candidates` already takes care of that.\n-\n-        let conflicts = BitMatrix::from_row_n(\n-            &BitSet::new_empty(body.local_decls.len()),\n-            body.local_decls.len(),\n-        );\n-\n-        let mut init = MaybeInitializedLocals\n-            .into_engine(tcx, body)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(body);\n-        let mut live =\n-            MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint().into_results_cursor(body);\n-\n-        let mut reachable = None;\n-        dump_mir(tcx, None, \"DestinationPropagation-dataflow\", &\"\", body, |pass_where, w| {\n-            let reachable = reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n-\n-            match pass_where {\n-                PassWhere::BeforeLocation(loc) if reachable.contains(loc.block) => {\n-                    init.seek_before_primary_effect(loc);\n-                    live.seek_after_primary_effect(loc);\n-\n-                    writeln!(w, \"        // init: {:?}\", init.get())?;\n-                    writeln!(w, \"        // live: {:?}\", live.get())?;\n-                }\n-                PassWhere::AfterTerminator(bb) if reachable.contains(bb) => {\n-                    let loc = body.terminator_loc(bb);\n-                    init.seek_after_primary_effect(loc);\n-                    live.seek_before_primary_effect(loc);\n-\n-                    writeln!(w, \"        // init: {:?}\", init.get())?;\n-                    writeln!(w, \"        // live: {:?}\", live.get())?;\n-                }\n-\n-                PassWhere::BeforeBlock(bb) if reachable.contains(bb) => {\n-                    init.seek_to_block_start(bb);\n-                    live.seek_to_block_start(bb);\n-\n-                    writeln!(w, \"    // init: {:?}\", init.get())?;\n-                    writeln!(w, \"    // live: {:?}\", live.get())?;\n-                }\n-\n-                PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n-\n-                PassWhere::BeforeLocation(_) | PassWhere::AfterTerminator(_) => {\n-                    writeln!(w, \"        // init: <unreachable>\")?;\n-                    writeln!(w, \"        // live: <unreachable>\")?;\n-                }\n-\n-                PassWhere::BeforeBlock(_) => {\n-                    writeln!(w, \"    // init: <unreachable>\")?;\n-                    writeln!(w, \"    // live: <unreachable>\")?;\n-                }\n+// We first implement some utility functions which we will expose removing candidates according to\n+// different needs. Throughout the livenss filtering, the `candidates` are only ever accessed\n+// through these methods, and not directly.\n+impl<'alloc> Candidates<'alloc> {\n+    /// Just `Vec::retain`, but the condition is inverted and we add debugging output\n+    fn vec_remove_debug(\n+        src: Local,\n+        v: &mut Vec<Local>,\n+        mut f: impl FnMut(Local) -> bool,\n+        at: Location,\n+    ) {\n+        v.retain(|dest| {\n+            let remove = f(*dest);\n+            if remove {\n+                trace!(\"eliminating {:?} => {:?} due to conflict at {:?}\", src, dest, at);\n             }\n-\n-            Ok(())\n+            !remove\n         });\n+    }\n \n-        let mut this = Self {\n-            relevant_locals,\n-            matrix: conflicts,\n-            unify_cache: BitSet::new_empty(body.local_decls.len()),\n-            unified_locals: {\n-                let mut table = InPlaceUnificationTable::new();\n-                // Pre-fill table with all locals (this creates N nodes / \"connected\" components,\n-                // \"graph\"-ically speaking).\n-                for local in 0..body.local_decls.len() {\n-                    assert_eq!(table.new_key(()), UnifyLocal(Local::from_usize(local)));\n-                }\n-                table\n-            },\n-        };\n-\n-        let mut live_and_init_locals = Vec::new();\n-\n-        // Visit only reachable basic blocks. The exact order is not important.\n-        for (block, data) in traversal::preorder(body) {\n-            // We need to observe the dataflow state *before* all possible locations (statement or\n-            // terminator) in each basic block, and then observe the state *after* the terminator\n-            // effect is applied. As long as neither `init` nor `borrowed` has a \"before\" effect,\n-            // we will observe all possible dataflow states.\n-\n-            // Since liveness is a backwards analysis, we need to walk the results backwards. To do\n-            // that, we first collect in the `MaybeInitializedLocals` results in a forwards\n-            // traversal.\n-\n-            live_and_init_locals.resize_with(data.statements.len() + 1, || {\n-                BitSet::new_empty(body.local_decls.len())\n-            });\n-\n-            // First, go forwards for `MaybeInitializedLocals` and apply intra-statement/terminator\n-            // conflicts.\n-            for (i, statement) in data.statements.iter().enumerate() {\n-                this.record_statement_conflicts(statement);\n-\n-                let loc = Location { block, statement_index: i };\n-                init.seek_before_primary_effect(loc);\n+    /// `vec_remove_debug` but for an `Entry`\n+    fn entry_remove(\n+        mut entry: OccupiedEntry<'_, Local, Vec<Local>>,\n+        p: Local,\n+        f: impl FnMut(Local) -> bool,\n+        at: Location,\n+    ) {\n+        let candidates = entry.get_mut();\n+        Self::vec_remove_debug(p, candidates, f, at);\n+        if candidates.len() == 0 {\n+            entry.remove();\n+        }\n+    }\n \n-                live_and_init_locals[i].clone_from(init.get());\n+    /// Removes all candidates `(p, q)` or `(q, p)` where `p` is the indicated local and `f(q)` is true.\n+    fn remove_candidates_if(&mut self, p: Local, mut f: impl FnMut(Local) -> bool, at: Location) {\n+        // Cover the cases where `p` appears as a `src`\n+        if let Entry::Occupied(entry) = self.c.entry(p) {\n+            Self::entry_remove(entry, p, &mut f, at);\n+        }\n+        // And the cases where `p` appears as a `dest`\n+        let Some(srcs) = self.reverse.get_mut(&p) else {\n+            return;\n+        };\n+        // We use `retain` here to remove the elements from the reverse set if we've removed the\n+        // matching candidate in the forward set.\n+        srcs.retain(|src| {\n+            if !f(*src) {\n+                return true;\n             }\n+            let Entry::Occupied(entry) = self.c.entry(*src) else {\n+                return false;\n+            };\n+            Self::entry_remove(entry, *src, |dest| dest == p, at);\n+            false\n+        });\n+    }\n+}\n \n-            this.record_terminator_conflicts(data.terminator());\n-            let term_loc = Location { block, statement_index: data.statements.len() };\n-            init.seek_before_primary_effect(term_loc);\n-            live_and_init_locals[term_loc.statement_index].clone_from(init.get());\n-\n-            // Now, go backwards and union with the liveness results.\n-            for statement_index in (0..=data.statements.len()).rev() {\n-                let loc = Location { block, statement_index };\n-                live.seek_after_primary_effect(loc);\n-\n-                live_and_init_locals[statement_index].intersect(live.get());\n-\n-                trace!(\"record conflicts at {:?}\", loc);\n+impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n+    /// Filters the set of candidates to remove those that conflict.\n+    ///\n+    /// The steps we take are exactly those that are outlined at the top of the file. For each\n+    /// statement/terminator, we collect the set of locals that are written to in that\n+    /// statement/terminator, and then we remove all pairs of candidates that contain one such local\n+    /// and another one that is live.\n+    ///\n+    /// We need to be careful about the ordering of operations within each statement/terminator\n+    /// here. Many statements might write and read from more than one place, and we need to consider\n+    /// them all. The strategy for doing this is as follows: We first gather all the places that are\n+    /// written to within the statement/terminator via `WriteInfo`. Then, we use the liveness\n+    /// analysis from *before* the statement/terminator (in the control flow sense) to eliminate\n+    /// candidates - this is because we want to conservatively treat a pair of locals that is both\n+    /// read and written in the statement/terminator to be conflicting, and the liveness analysis\n+    /// before the statement/terminator will correctly report locals that are read in the\n+    /// statement/terminator to be live. We are additionally conservative by treating all written to\n+    /// locals as also being read from.\n+    fn filter_liveness<'b>(\n+        candidates: &mut Candidates<'alloc>,\n+        live: &mut ResultsCursor<'b, 'tcx, MaybeLiveLocals>,\n+        write_info_alloc: &'alloc mut WriteInfo,\n+        body: &'b Body<'tcx>,\n+    ) {\n+        let mut this = FilterInformation {\n+            body,\n+            live,\n+            candidates,\n+            // We don't actually store anything at this scope, we just keep things here to be able\n+            // to reuse the allocation.\n+            write_info: write_info_alloc,\n+            // Doesn't matter what we put here, will be overwritten before being used\n+            at: Location { block: BasicBlock::from_u32(0), statement_index: 0 },\n+        };\n+        this.internal_filter_liveness();\n+    }\n \n-                this.record_dataflow_conflicts(&mut live_and_init_locals[statement_index]);\n+    fn internal_filter_liveness(&mut self) {\n+        for (block, data) in traversal::preorder(self.body) {\n+            self.at = Location { block, statement_index: data.statements.len() };\n+            self.live.seek_after_primary_effect(self.at);\n+            self.write_info.for_terminator(&data.terminator().kind);\n+            self.apply_conflicts();\n+\n+            for (i, statement) in data.statements.iter().enumerate().rev() {\n+                self.at = Location { block, statement_index: i };\n+                self.live.seek_after_primary_effect(self.at);\n+                self.get_statement_write_info(&statement.kind);\n+                self.apply_conflicts();\n             }\n-\n-            init.seek_to_block_end(block);\n-            live.seek_to_block_end(block);\n-            let mut conflicts = init.get().clone();\n-            conflicts.intersect(live.get());\n-            trace!(\"record conflicts at end of {:?}\", block);\n-\n-            this.record_dataflow_conflicts(&mut conflicts);\n         }\n-\n-        this\n     }\n \n-    fn record_dataflow_conflicts(&mut self, new_conflicts: &mut BitSet<Local>) {\n-        // Remove all locals that are not candidates.\n-        new_conflicts.intersect(self.relevant_locals);\n+    fn apply_conflicts(&mut self) {\n+        let writes = &self.write_info.writes;\n+        for p in writes {\n+            self.candidates.remove_candidates_if(\n+                *p,\n+                // It is possible that a local may be live for less than the\n+                // duration of a statement This happens in the case of function\n+                // calls or inline asm. Because of this, we also mark locals as\n+                // conflicting when both of them are written to in the same\n+                // statement.\n+                |q| self.live.contains(q) || writes.contains(&q),\n+                self.at,\n+            );\n+        }\n+    }\n \n-        for local in new_conflicts.iter() {\n-            self.matrix.union_row_with(&new_conflicts, local);\n+    /// Gets the write info for the `statement`.\n+    fn get_statement_write_info(&mut self, statement: &StatementKind<'tcx>) {\n+        self.write_info.writes.clear();\n+        match statement {\n+            StatementKind::Assign(box (lhs, rhs)) => match rhs {\n+                Rvalue::Use(op) => {\n+                    if !lhs.is_indirect() {\n+                        self.get_assign_use_write_info(*lhs, op);\n+                        return;\n+                    }\n+                }\n+                _ => (),\n+            },\n+            _ => (),\n         }\n+\n+        self.write_info.for_statement(statement);\n     }\n \n-    fn record_local_conflict(&mut self, a: Local, b: Local, why: &str) {\n-        trace!(\"conflict {:?} <-> {:?} due to {}\", a, b, why);\n-        self.matrix.insert(a, b);\n-        self.matrix.insert(b, a);\n+    fn get_assign_use_write_info(&mut self, lhs: Place<'tcx>, rhs: &Operand<'tcx>) {\n+        // We register the writes for the operand unconditionally\n+        self.write_info.add_operand(rhs);\n+        // However, we cannot do the same thing for the `lhs` as that would always block the\n+        // optimization. Instead, we consider removing candidates manually.\n+        let Some(rhs) = rhs.place() else {\n+            self.write_info.add_place(lhs);\n+            return;\n+        };\n+        // Find out which candidate pair we should skip, if any\n+        let Some((src, dest)) = places_to_candidate_pair(lhs, rhs, self.body) else {\n+            self.write_info.add_place(lhs);\n+            return;\n+        };\n+        self.candidates.remove_candidates_if(\n+            lhs.local,\n+            |other| {\n+                // Check if this is the candidate pair that should not be removed\n+                if (lhs.local == src && other == dest) || (lhs.local == dest && other == src) {\n+                    return false;\n+                }\n+                // Otherwise, do the \"standard\" thing\n+                self.live.contains(other)\n+            },\n+            self.at,\n+        )\n     }\n+}\n \n-    /// Records locals that must not overlap during the evaluation of `stmt`. These locals conflict\n-    /// and must not be merged.\n-    fn record_statement_conflicts(&mut self, stmt: &Statement<'_>) {\n-        match &stmt.kind {\n-            // While the left and right sides of an assignment must not overlap, we do not mark\n-            // conflicts here as that would make this optimization useless. When we optimize, we\n-            // eliminate the resulting self-assignments automatically.\n-            StatementKind::Assign(_) => {}\n-\n-            StatementKind::SetDiscriminant { .. }\n-            | StatementKind::Deinit(..)\n-            | StatementKind::StorageLive(..)\n-            | StatementKind::StorageDead(..)\n-            | StatementKind::Retag(..)\n-            | StatementKind::FakeRead(..)\n-            | StatementKind::AscribeUserType(..)\n-            | StatementKind::Coverage(..)\n-            | StatementKind::Intrinsic(..)\n-            | StatementKind::Nop => {}\n+/// Describes where a statement/terminator writes to\n+#[derive(Default, Debug)]\n+struct WriteInfo {\n+    writes: Vec<Local>,\n+}\n+\n+impl WriteInfo {\n+    fn for_statement<'tcx>(&mut self, statement: &StatementKind<'tcx>) {\n+        match statement {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n+                self.add_place(*lhs);\n+                match rhs {\n+                    Rvalue::Use(op) | Rvalue::Repeat(op, _) => {\n+                        self.add_operand(op);\n+                    }\n+                    Rvalue::Cast(_, op, _)\n+                    | Rvalue::UnaryOp(_, op)\n+                    | Rvalue::ShallowInitBox(op, _) => {\n+                        self.add_operand(op);\n+                    }\n+                    Rvalue::BinaryOp(_, ops) | Rvalue::CheckedBinaryOp(_, ops) => {\n+                        for op in [&ops.0, &ops.1] {\n+                            self.add_operand(op);\n+                        }\n+                    }\n+                    Rvalue::Aggregate(_, ops) => {\n+                        for op in ops {\n+                            self.add_operand(op);\n+                        }\n+                    }\n+                    Rvalue::ThreadLocalRef(_)\n+                    | Rvalue::NullaryOp(_, _)\n+                    | Rvalue::Ref(_, _, _)\n+                    | Rvalue::AddressOf(_, _)\n+                    | Rvalue::Len(_)\n+                    | Rvalue::Discriminant(_)\n+                    | Rvalue::CopyForDeref(_) => (),\n+                }\n+            }\n+            // Retags are technically also reads, but reporting them as a write suffices\n+            StatementKind::SetDiscriminant { place, .. }\n+            | StatementKind::Deinit(place)\n+            | StatementKind::Retag(_, place) => {\n+                self.add_place(**place);\n+            }\n+            StatementKind::Intrinsic(_)\n+            | StatementKind::Nop\n+            | StatementKind::Coverage(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_) => (),\n+            StatementKind::FakeRead(_) | StatementKind::AscribeUserType(_, _) => {\n+                bug!(\"{:?} not found in this MIR phase\", statement)\n+            }\n         }\n     }\n \n-    fn record_terminator_conflicts(&mut self, term: &Terminator<'_>) {\n-        match &term.kind {\n-            TerminatorKind::DropAndReplace {\n-                place: dropped_place,\n-                value,\n-                target: _,\n-                unwind: _,\n-            } => {\n-                if let Some(place) = value.place()\n-                    && !place.is_indirect()\n-                    && !dropped_place.is_indirect()\n-                {\n-                    self.record_local_conflict(\n-                        place.local,\n-                        dropped_place.local,\n-                        \"DropAndReplace operand overlap\",\n-                    );\n-                }\n+    fn for_terminator<'tcx>(&mut self, terminator: &TerminatorKind<'tcx>) {\n+        self.writes.clear();\n+        match terminator {\n+            TerminatorKind::SwitchInt { discr: op, .. }\n+            | TerminatorKind::Assert { cond: op, .. } => {\n+                self.add_operand(op);\n             }\n-            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n-                if let Some(place) = value.place() {\n-                    if !place.is_indirect() && !resume_arg.is_indirect() {\n-                        self.record_local_conflict(\n-                            place.local,\n-                            resume_arg.local,\n-                            \"Yield operand overlap\",\n-                        );\n-                    }\n+            TerminatorKind::Call { destination, func, args, .. } => {\n+                self.add_place(*destination);\n+                self.add_operand(func);\n+                for arg in args {\n+                    self.add_operand(arg);\n                 }\n             }\n-            TerminatorKind::Call {\n-                func,\n-                args,\n-                destination,\n-                target: _,\n-                cleanup: _,\n-                from_hir_call: _,\n-                fn_span: _,\n-            } => {\n-                // No arguments may overlap with the destination.\n-                for arg in args.iter().chain(Some(func)) {\n-                    if let Some(place) = arg.place() {\n-                        if !place.is_indirect() && !destination.is_indirect() {\n-                            self.record_local_conflict(\n-                                destination.local,\n-                                place.local,\n-                                \"call dest/arg overlap\",\n-                            );\n+            TerminatorKind::InlineAsm { operands, .. } => {\n+                for asm_operand in operands {\n+                    match asm_operand {\n+                        InlineAsmOperand::In { value, .. } => {\n+                            self.add_operand(value);\n                         }\n-                    }\n-                }\n-            }\n-            TerminatorKind::InlineAsm {\n-                template: _,\n-                operands,\n-                options: _,\n-                line_spans: _,\n-                destination: _,\n-                cleanup: _,\n-            } => {\n-                // The intended semantics here aren't documented, we just assume that nothing that\n-                // could be written to by the assembly may overlap with any other operands.\n-                for op in operands {\n-                    match op {\n-                        InlineAsmOperand::Out { reg: _, late: _, place: Some(dest_place) }\n-                        | InlineAsmOperand::InOut {\n-                            reg: _,\n-                            late: _,\n-                            in_value: _,\n-                            out_place: Some(dest_place),\n-                        } => {\n-                            // For output place `place`, add all places accessed by the inline asm.\n-                            for op in operands {\n-                                match op {\n-                                    InlineAsmOperand::In { reg: _, value } => {\n-                                        if let Some(p) = value.place()\n-                                            && !p.is_indirect()\n-                                            && !dest_place.is_indirect()\n-                                        {\n-                                            self.record_local_conflict(\n-                                                p.local,\n-                                                dest_place.local,\n-                                                \"asm! operand overlap\",\n-                                            );\n-                                        }\n-                                    }\n-                                    InlineAsmOperand::Out {\n-                                        reg: _,\n-                                        late: _,\n-                                        place: Some(place),\n-                                    } => {\n-                                        if !place.is_indirect() && !dest_place.is_indirect() {\n-                                            self.record_local_conflict(\n-                                                place.local,\n-                                                dest_place.local,\n-                                                \"asm! operand overlap\",\n-                                            );\n-                                        }\n-                                    }\n-                                    InlineAsmOperand::InOut {\n-                                        reg: _,\n-                                        late: _,\n-                                        in_value,\n-                                        out_place,\n-                                    } => {\n-                                        if let Some(place) = in_value.place()\n-                                            && !place.is_indirect()\n-                                            && !dest_place.is_indirect()\n-                                        {\n-                                            self.record_local_conflict(\n-                                                place.local,\n-                                                dest_place.local,\n-                                                \"asm! operand overlap\",\n-                                            );\n-                                        }\n-\n-                                        if let Some(place) = out_place\n-                                            && !place.is_indirect()\n-                                            && !dest_place.is_indirect()\n-                                        {\n-                                            self.record_local_conflict(\n-                                                place.local,\n-                                                dest_place.local,\n-                                                \"asm! operand overlap\",\n-                                            );\n-                                        }\n-                                    }\n-                                    InlineAsmOperand::Out { reg: _, late: _, place: None }\n-                                    | InlineAsmOperand::Const { value: _ }\n-                                    | InlineAsmOperand::SymFn { value: _ }\n-                                    | InlineAsmOperand::SymStatic { def_id: _ } => {}\n-                                }\n+                        InlineAsmOperand::Out { place, .. } => {\n+                            if let Some(place) = place {\n+                                self.add_place(*place);\n                             }\n                         }\n-                        InlineAsmOperand::InOut {\n-                            reg: _,\n-                            late: _,\n-                            in_value: _,\n-                            out_place: None,\n+                        // Note that the `late` field in `InOut` is about whether the registers used\n+                        // for these things overlap, and is of absolutely no interest to us.\n+                        InlineAsmOperand::InOut { in_value, out_place, .. } => {\n+                            if let Some(place) = out_place {\n+                                self.add_place(*place);\n+                            }\n+                            self.add_operand(in_value);\n                         }\n-                        | InlineAsmOperand::In { reg: _, value: _ }\n-                        | InlineAsmOperand::Out { reg: _, late: _, place: None }\n-                        | InlineAsmOperand::Const { value: _ }\n-                        | InlineAsmOperand::SymFn { value: _ }\n-                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n+                        InlineAsmOperand::Const { .. }\n+                        | InlineAsmOperand::SymFn { .. }\n+                        | InlineAsmOperand::SymStatic { .. } => (),\n                     }\n                 }\n             }\n-\n             TerminatorKind::Goto { .. }\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Abort\n+            | TerminatorKind::Resume { .. }\n+            | TerminatorKind::Abort { .. }\n             | TerminatorKind::Return\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::Drop { .. }\n-            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Unreachable { .. } => (),\n+            TerminatorKind::Drop { .. } => {\n+                // `Drop`s create a `&mut` and so are not considered\n+            }\n+            TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Yield { .. }\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n-            | TerminatorKind::FalseUnwind { .. } => {}\n+            | TerminatorKind::FalseUnwind { .. } => {\n+                bug!(\"{:?} not found in this MIR phase\", terminator)\n+            }\n         }\n     }\n \n-    /// Checks whether `a` and `b` may be merged. Returns `false` if there's a conflict.\n-    fn can_unify(&mut self, a: Local, b: Local) -> bool {\n-        // After some locals have been unified, their conflicts are only tracked in the root key,\n-        // so look that up.\n-        let a = self.unified_locals.find(a).0;\n-        let b = self.unified_locals.find(b).0;\n-\n-        if a == b {\n-            // Already merged (part of the same connected component).\n-            return false;\n-        }\n+    fn add_place<'tcx>(&mut self, place: Place<'tcx>) {\n+        self.writes.push(place.local);\n+    }\n \n-        if self.matrix.contains(a, b) {\n-            // Conflict (derived via dataflow, intra-statement conflicts, or inherited from another\n-            // local during unification).\n-            return false;\n+    fn add_operand<'tcx>(&mut self, op: &Operand<'tcx>) {\n+        match op {\n+            // FIXME(JakobDegen): In a previous version, the `Move` case was incorrectly treated as\n+            // being a read only. This was unsound, however we cannot add a regression test because\n+            // it is not possible to set this off with current MIR. Once we have that ability, a\n+            // regression test should be added.\n+            Operand::Move(p) => self.add_place(*p),\n+            Operand::Copy(_) | Operand::Constant(_) => (),\n         }\n-\n-        true\n     }\n+}\n \n-    /// Merges the conflicts of `a` and `b`, so that each one inherits all conflicts of the other.\n-    ///\n-    /// `can_unify` must have returned `true` for the same locals, or this may panic or lead to\n-    /// miscompiles.\n-    ///\n-    /// This is called when the pass makes the decision to unify `a` and `b` (or parts of `a` and\n-    /// `b`) and is needed to ensure that future unification decisions take potentially newly\n-    /// introduced conflicts into account.\n-    ///\n-    /// For an example, assume we have locals `_0`, `_1`, `_2`, and `_3`. There are these conflicts:\n-    ///\n-    /// * `_0` <-> `_1`\n-    /// * `_1` <-> `_2`\n-    /// * `_3` <-> `_0`\n-    ///\n-    /// We then decide to merge `_2` with `_3` since they don't conflict. Then we decide to merge\n-    /// `_2` with `_0`, which also doesn't have a conflict in the above list. However `_2` is now\n-    /// `_3`, which does conflict with `_0`.\n-    fn unify(&mut self, a: Local, b: Local) {\n-        trace!(\"unify({:?}, {:?})\", a, b);\n-\n-        // Get the root local of the connected components. The root local stores the conflicts of\n-        // all locals in the connected component (and *is stored* as the conflicting local of other\n-        // locals).\n-        let a = self.unified_locals.find(a).0;\n-        let b = self.unified_locals.find(b).0;\n-        assert_ne!(a, b);\n-\n-        trace!(\"roots: a={:?}, b={:?}\", a, b);\n-        trace!(\"{:?} conflicts: {:?}\", a, self.matrix.iter(a).format(\", \"));\n-        trace!(\"{:?} conflicts: {:?}\", b, self.matrix.iter(b).format(\", \"));\n-\n-        self.unified_locals.union(a, b);\n-\n-        let root = self.unified_locals.find(a).0;\n-        assert!(root == a || root == b);\n-\n-        // Make all locals that conflict with `a` also conflict with `b`, and vice versa.\n-        self.unify_cache.clear();\n-        for conflicts_with_a in self.matrix.iter(a) {\n-            self.unify_cache.insert(conflicts_with_a);\n-        }\n-        for conflicts_with_b in self.matrix.iter(b) {\n-            self.unify_cache.insert(conflicts_with_b);\n-        }\n-        for conflicts_with_a_or_b in self.unify_cache.iter() {\n-            // Set both `a` and `b` for this local's row.\n-            self.matrix.insert(conflicts_with_a_or_b, a);\n-            self.matrix.insert(conflicts_with_a_or_b, b);\n-        }\n+/////////////////////////////////////////////////////\n+// Candidate accumulation\n \n-        // Write the locals `a` conflicts with to `b`'s row.\n-        self.matrix.union_rows(a, b);\n-        // Write the locals `b` conflicts with to `a`'s row.\n-        self.matrix.union_rows(b, a);\n-    }\n+fn is_constant<'tcx>(place: Place<'tcx>) -> bool {\n+    place.projection.iter().all(|p| !matches!(p, ProjectionElem::Deref | ProjectionElem::Index(_)))\n }\n \n-/// A `dest = {move} src;` statement at `loc`.\n+/// If the pair of places is being considered for merging, returns the candidate which would be\n+/// merged in order to accomplish this.\n+///\n+/// The contract here is in one direction - there is a guarantee that merging the locals that are\n+/// outputted by this function would result in an assignment between the inputs becoming a\n+/// self-assignment. However, there is no guarantee that the returned pair is actually suitable for\n+/// merging - candidate collection must still check this independently.\n ///\n-/// We want to consider merging `dest` and `src` due to this assignment.\n-#[derive(Debug, Copy, Clone)]\n-struct CandidateAssignment<'tcx> {\n-    /// Does not contain indirection or indexing (so the only local it contains is the place base).\n-    dest: Place<'tcx>,\n-    src: Local,\n-    loc: Location,\n+/// This output is unique for each unordered pair of input places.\n+fn places_to_candidate_pair<'tcx>(\n+    a: Place<'tcx>,\n+    b: Place<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<(Local, Local)> {\n+    let (mut a, mut b) = if a.projection.len() == 0 && b.projection.len() == 0 {\n+        (a.local, b.local)\n+    } else {\n+        return None;\n+    };\n+\n+    // By sorting, we make sure we're input order independent\n+    if a > b {\n+        std::mem::swap(&mut a, &mut b);\n+    }\n+\n+    // We could now return `(a, b)`, but then we miss some candidates in the case where `a` can't be\n+    // used as a `src`.\n+    if is_local_required(a, body) {\n+        std::mem::swap(&mut a, &mut b);\n+    }\n+    // We could check `is_local_required` again here, but there's no need - after all, we make no\n+    // promise that the candidate pair is actually valid\n+    Some((a, b))\n }\n \n-/// Scans the MIR for assignments between locals that we might want to consider merging.\n+/// Collects the candidates for merging\n ///\n-/// This will filter out assignments that do not match the right form (as described in the top-level\n-/// comment) and also throw out assignments that involve a local that has its address taken or is\n-/// otherwise ineligible (eg. locals used as array indices are ignored because we cannot propagate\n-/// arbitrary places into array indices).\n-fn find_candidates<'tcx>(body: &Body<'tcx>) -> Vec<CandidateAssignment<'tcx>> {\n-    let mut visitor = FindAssignments {\n-        body,\n-        candidates: Vec::new(),\n-        ever_borrowed_locals: borrowed_locals(body),\n-        locals_used_as_array_index: locals_used_as_array_index(body),\n-    };\n+/// This is responsible for enforcing the first and third bullet point.\n+fn find_candidates<'alloc, 'tcx>(\n+    body: &Body<'tcx>,\n+    borrowed: &BitSet<Local>,\n+    candidates: &'alloc mut FxHashMap<Local, Vec<Local>>,\n+    candidates_reverse: &'alloc mut FxHashMap<Local, Vec<Local>>,\n+) -> Candidates<'alloc> {\n+    candidates.clear();\n+    candidates_reverse.clear();\n+    let mut visitor = FindAssignments { body, candidates, borrowed };\n     visitor.visit_body(body);\n-    visitor.candidates\n+    // Deduplicate candidates\n+    for (_, cands) in candidates.iter_mut() {\n+        cands.sort();\n+        cands.dedup();\n+    }\n+    // Generate the reverse map\n+    for (src, cands) in candidates.iter() {\n+        for dest in cands.iter().copied() {\n+            candidates_reverse.entry(dest).or_default().push(*src);\n+        }\n+    }\n+    Candidates { c: candidates, reverse: candidates_reverse }\n }\n \n-struct FindAssignments<'a, 'tcx> {\n+struct FindAssignments<'a, 'alloc, 'tcx> {\n     body: &'a Body<'tcx>,\n-    candidates: Vec<CandidateAssignment<'tcx>>,\n-    ever_borrowed_locals: BitSet<Local>,\n-    locals_used_as_array_index: BitSet<Local>,\n+    candidates: &'alloc mut FxHashMap<Local, Vec<Local>>,\n+    borrowed: &'a BitSet<Local>,\n }\n \n-impl<'tcx> Visitor<'tcx> for FindAssignments<'_, 'tcx> {\n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+impl<'tcx> Visitor<'tcx> for FindAssignments<'_, '_, 'tcx> {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n         if let StatementKind::Assign(box (\n-            dest,\n-            Rvalue::Use(Operand::Copy(src) | Operand::Move(src)),\n+            lhs,\n+            Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n         )) = &statement.kind\n         {\n-            // `dest` must not have pointer indirection.\n-            if dest.is_indirect() {\n-                return;\n-            }\n-\n-            // `src` must be a plain local.\n-            if !src.projection.is_empty() {\n+            if !is_constant(*lhs) || !is_constant(*rhs) {\n                 return;\n             }\n \n-            // Since we want to replace `src` with `dest`, `src` must not be required.\n-            if is_local_required(src.local, self.body) {\n+            let Some((src, dest)) = places_to_candidate_pair(*lhs, *rhs, self.body) else {\n                 return;\n-            }\n+            };\n \n-            // Can't optimize if either local ever has their address taken. This optimization does\n-            // liveness analysis only based on assignments, and a local can be live even if its\n-            // never assigned to again, because a reference to it might be live.\n-            // FIXME: This can be smarter and take `StorageDead` into  account (which invalidates\n-            // borrows).\n-            if self.ever_borrowed_locals.contains(dest.local)\n-                || self.ever_borrowed_locals.contains(src.local)\n-            {\n+            // As described at the top of the file, we do not go near things that have their address\n+            // taken.\n+            if self.borrowed.contains(src) || self.borrowed.contains(dest) {\n                 return;\n             }\n \n-            assert_ne!(dest.local, src.local, \"self-assignments are UB\");\n-\n-            // We can't replace locals occurring in `PlaceElem::Index` for now.\n-            if self.locals_used_as_array_index.contains(src.local) {\n+            // Also, we need to make sure that MIR actually allows the `src` to be removed\n+            if is_local_required(src, self.body) {\n                 return;\n             }\n \n-            for elem in dest.projection {\n-                if let PlaceElem::Index(_) = elem {\n-                    // `dest` contains an indexing projection.\n-                    return;\n-                }\n-            }\n-\n-            self.candidates.push(CandidateAssignment {\n-                dest: *dest,\n-                src: src.local,\n-                loc: location,\n-            });\n+            // We may insert duplicates here, but that's fine\n+            self.candidates.entry(src).or_default().push(dest);\n         }\n     }\n }\n@@ -886,32 +777,46 @@ fn is_local_required(local: Local, body: &Body<'_>) -> bool {\n     }\n }\n \n-/// `PlaceElem::Index` only stores a `Local`, so we can't replace that with a full `Place`.\n-///\n-/// Collect locals used as indices so we don't generate candidates that are impossible to apply\n-/// later.\n-fn locals_used_as_array_index(body: &Body<'_>) -> BitSet<Local> {\n-    let mut visitor = IndexCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n-    visitor.visit_body(body);\n-    visitor.locals\n-}\n+/////////////////////////////////////////////////////////\n+// MIR Dump\n \n-struct IndexCollector {\n-    locals: BitSet<Local>,\n-}\n+fn dest_prop_mir_dump<'body, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'body Body<'tcx>,\n+    live: &mut ResultsCursor<'body, 'tcx, MaybeLiveLocals>,\n+    round: usize,\n+) {\n+    let mut reachable = None;\n+    dump_mir(tcx, None, \"DestinationPropagation-dataflow\", &round, body, |pass_where, w| {\n+        let reachable = reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n+\n+        match pass_where {\n+            PassWhere::BeforeLocation(loc) if reachable.contains(loc.block) => {\n+                live.seek_after_primary_effect(loc);\n+                writeln!(w, \"        // live: {:?}\", live.get())?;\n+            }\n+            PassWhere::AfterTerminator(bb) if reachable.contains(bb) => {\n+                let loc = body.terminator_loc(bb);\n+                live.seek_before_primary_effect(loc);\n+                writeln!(w, \"        // live: {:?}\", live.get())?;\n+            }\n \n-impl<'tcx> Visitor<'tcx> for IndexCollector {\n-    fn visit_projection_elem(\n-        &mut self,\n-        local: Local,\n-        proj_base: &[PlaceElem<'tcx>],\n-        elem: PlaceElem<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n-        if let PlaceElem::Index(i) = elem {\n-            self.locals.insert(i);\n+            PassWhere::BeforeBlock(bb) if reachable.contains(bb) => {\n+                live.seek_to_block_start(bb);\n+                writeln!(w, \"    // live: {:?}\", live.get())?;\n+            }\n+\n+            PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n+\n+            PassWhere::BeforeLocation(_) | PassWhere::AfterTerminator(_) => {\n+                writeln!(w, \"        // live: <unreachable>\")?;\n+            }\n+\n+            PassWhere::BeforeBlock(_) => {\n+                writeln!(w, \"    // live: <unreachable>\")?;\n+            }\n         }\n-        self.super_projection_elem(local, proj_base, elem, context, location);\n-    }\n+\n+        Ok(())\n+    });\n }"}, {"sha": "61d24c3b517fbfd84eb5f0977c7986ff81b839ff", "filename": "src/test/mir-opt/dead-store-elimination/cycle.cycle.DeadStoreElimination.diff", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -6,69 +6,78 @@\n       debug y => _2;                       // in scope 0 at $DIR/cycle.rs:+0:22: +0:27\n       debug z => _3;                       // in scope 0 at $DIR/cycle.rs:+0:34: +0:39\n       let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:+0:46: +0:46\n-      let mut _4: ();                      // in scope 0 at $DIR/cycle.rs:+0:1: +9:2\n-      let mut _5: bool;                    // in scope 0 at $DIR/cycle.rs:+3:11: +3:17\n-      let _6: i32;                         // in scope 0 at $DIR/cycle.rs:+4:13: +4:17\n-      let mut _7: i32;                     // in scope 0 at $DIR/cycle.rs:+5:13: +5:14\n-      let mut _8: i32;                     // in scope 0 at $DIR/cycle.rs:+6:13: +6:14\n-      let mut _9: i32;                     // in scope 0 at $DIR/cycle.rs:+7:13: +7:17\n-      let mut _10: !;                      // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n-      let _11: ();                         // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n-      let mut _12: !;                      // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n+-     let mut _4: ();                      // in scope 0 at $DIR/cycle.rs:+0:1: +9:2\n+-     let mut _5: bool;                    // in scope 0 at $DIR/cycle.rs:+3:11: +3:17\n+-     let _6: i32;                         // in scope 0 at $DIR/cycle.rs:+4:13: +4:17\n+-     let mut _7: i32;                     // in scope 0 at $DIR/cycle.rs:+5:13: +5:14\n+-     let mut _8: i32;                     // in scope 0 at $DIR/cycle.rs:+6:13: +6:14\n+-     let mut _9: i32;                     // in scope 0 at $DIR/cycle.rs:+7:13: +7:17\n+-     let mut _10: !;                      // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n+-     let _11: ();                         // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n+-     let mut _12: !;                      // in scope 0 at $DIR/cycle.rs:+3:5: +8:6\n++     let mut _4: bool;                    // in scope 0 at $DIR/cycle.rs:+3:11: +3:17\n++     let _5: i32;                         // in scope 0 at $DIR/cycle.rs:+4:13: +4:17\n       scope 1 {\n-          debug temp => _6;                // in scope 1 at $DIR/cycle.rs:+4:13: +4:17\n+-         debug temp => _6;                // in scope 1 at $DIR/cycle.rs:+4:13: +4:17\n++         debug temp => _5;                // in scope 1 at $DIR/cycle.rs:+4:13: +4:17\n       }\n   \n       bb0: {\n           goto -> bb1;                     // scope 0 at $DIR/cycle.rs:+3:5: +8:6\n       }\n   \n       bb1: {\n-          StorageLive(_5);                 // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n-          _5 = cond() -> bb2;              // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n+-         StorageLive(_5);                 // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n+-         _5 = cond() -> bb2;              // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n++         StorageLive(_4);                 // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n++         _4 = cond() -> bb2;              // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n                                            // mir::Constant\n                                            // + span: $DIR/cycle.rs:12:11: 12:15\n                                            // + literal: Const { ty: fn() -> bool {cond}, val: Value(<ZST>) }\n       }\n   \n       bb2: {\n-          switchInt(move _5) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n+-         switchInt(move _5) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n++         switchInt(move _4) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n       }\n   \n       bb3: {\n-          StorageLive(_6);                 // scope 0 at $DIR/cycle.rs:+4:13: +4:17\n+-         StorageLive(_6);                 // scope 0 at $DIR/cycle.rs:+4:13: +4:17\n -         _6 = _3;                         // scope 0 at $DIR/cycle.rs:+4:20: +4:21\n-+         nop;                             // scope 0 at $DIR/cycle.rs:+4:20: +4:21\n-          StorageLive(_7);                 // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n+-         StorageLive(_7);                 // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n -         _7 = _2;                         // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n -         _3 = move _7;                    // scope 1 at $DIR/cycle.rs:+5:9: +5:14\n-+         nop;                             // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n-+         nop;                             // scope 1 at $DIR/cycle.rs:+5:9: +5:14\n-          StorageDead(_7);                 // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n-          StorageLive(_8);                 // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n+-         StorageDead(_7);                 // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n+-         StorageLive(_8);                 // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n -         _8 = _1;                         // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n -         _2 = move _8;                    // scope 1 at $DIR/cycle.rs:+6:9: +6:14\n-+         nop;                             // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n-+         nop;                             // scope 1 at $DIR/cycle.rs:+6:9: +6:14\n-          StorageDead(_8);                 // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n-          StorageLive(_9);                 // scope 1 at $DIR/cycle.rs:+7:13: +7:17\n+-         StorageDead(_8);                 // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n+-         StorageLive(_9);                 // scope 1 at $DIR/cycle.rs:+7:13: +7:17\n -         _9 = _6;                         // scope 1 at $DIR/cycle.rs:+7:13: +7:17\n -         _1 = move _9;                    // scope 1 at $DIR/cycle.rs:+7:9: +7:17\n+-         StorageDead(_9);                 // scope 1 at $DIR/cycle.rs:+7:16: +7:17\n+-         _4 = const ();                   // scope 0 at $DIR/cycle.rs:+3:18: +8:6\n+-         StorageDead(_6);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n++         StorageLive(_5);                 // scope 0 at $DIR/cycle.rs:+4:13: +4:17\n++         nop;                             // scope 0 at $DIR/cycle.rs:+4:20: +4:21\n++         nop;                             // scope 1 at $DIR/cycle.rs:+5:13: +5:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:+5:9: +5:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:+6:13: +6:14\n++         nop;                             // scope 1 at $DIR/cycle.rs:+6:9: +6:14\n +         nop;                             // scope 1 at $DIR/cycle.rs:+7:13: +7:17\n +         nop;                             // scope 1 at $DIR/cycle.rs:+7:9: +7:17\n-          StorageDead(_9);                 // scope 1 at $DIR/cycle.rs:+7:16: +7:17\n--         _4 = const ();                   // scope 0 at $DIR/cycle.rs:+3:18: +8:6\n +         nop;                             // scope 0 at $DIR/cycle.rs:+3:18: +8:6\n-          StorageDead(_6);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n           StorageDead(_5);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n++         StorageDead(_4);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n           goto -> bb1;                     // scope 0 at $DIR/cycle.rs:+3:5: +8:6\n       }\n   \n       bb4: {\n-          StorageLive(_11);                // scope 0 at $DIR/cycle.rs:+3:5: +8:6\n+-         StorageLive(_11);                // scope 0 at $DIR/cycle.rs:+3:5: +8:6\n           _0 = const ();                   // scope 0 at $DIR/cycle.rs:+3:5: +8:6\n-          StorageDead(_11);                // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n-          StorageDead(_5);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n+-         StorageDead(_11);                // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n+-         StorageDead(_5);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n++         StorageDead(_4);                 // scope 0 at $DIR/cycle.rs:+8:5: +8:6\n           return;                          // scope 0 at $DIR/cycle.rs:+9:2: +9:2\n       }\n   }"}, {"sha": "5fa7013d5ca762daba0f0a1ce1933be91a4b6497", "filename": "src/test/mir-opt/dest-prop/branch.foo.DestinationPropagation.diff", "status": "renamed", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,29 +1,34 @@\n-- // MIR for `main` before DestinationPropagation\n-+ // MIR for `main` after DestinationPropagation\n+- // MIR for `foo` before DestinationPropagation\n++ // MIR for `foo` after DestinationPropagation\n   \n-  fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/branch.rs:+0:11: +0:11\n+  fn foo() -> i32 {\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/branch.rs:+0:13: +0:16\n       let _1: i32;                         // in scope 0 at $DIR/branch.rs:+1:9: +1:10\n       let mut _3: bool;                    // in scope 0 at $DIR/branch.rs:+3:16: +3:22\n       let _4: i32;                         // in scope 0 at $DIR/branch.rs:+6:9: +6:14\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/branch.rs:+1:9: +1:10\n+-         debug x => _1;                   // in scope 1 at $DIR/branch.rs:+1:9: +1:10\n++         debug x => _0;                   // in scope 1 at $DIR/branch.rs:+1:9: +1:10\n           let _2: i32;                     // in scope 1 at $DIR/branch.rs:+3:9: +3:10\n           scope 2 {\n-              debug y => _2;               // in scope 2 at $DIR/branch.rs:+3:9: +3:10\n+-             debug y => _2;               // in scope 2 at $DIR/branch.rs:+3:9: +3:10\n++             debug y => _0;               // in scope 2 at $DIR/branch.rs:+3:9: +3:10\n           }\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/branch.rs:+1:9: +1:10\n-          _1 = val() -> bb1;               // scope 0 at $DIR/branch.rs:+1:13: +1:18\n+-         StorageLive(_1);                 // scope 0 at $DIR/branch.rs:+1:9: +1:10\n+-         _1 = val() -> bb1;               // scope 0 at $DIR/branch.rs:+1:13: +1:18\n++         nop;                             // scope 0 at $DIR/branch.rs:+1:9: +1:10\n++         _0 = val() -> bb1;               // scope 0 at $DIR/branch.rs:+1:13: +1:18\n                                            // mir::Constant\n                                            // + span: $DIR/branch.rs:13:13: 13:16\n                                            // + literal: Const { ty: fn() -> i32 {val}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 1 at $DIR/branch.rs:+3:9: +3:10\n+-         StorageLive(_2);                 // scope 1 at $DIR/branch.rs:+3:9: +3:10\n++         nop;                             // scope 1 at $DIR/branch.rs:+3:9: +3:10\n           StorageLive(_3);                 // scope 1 at $DIR/branch.rs:+3:16: +3:22\n           _3 = cond() -> bb2;              // scope 1 at $DIR/branch.rs:+3:16: +3:22\n                                            // mir::Constant\n@@ -36,7 +41,8 @@\n       }\n   \n       bb3: {\n-          nop;                             // scope 1 at $DIR/branch.rs:+4:9: +4:10\n+-         _2 = _1;                         // scope 1 at $DIR/branch.rs:+4:9: +4:10\n++         nop;                             // scope 1 at $DIR/branch.rs:+4:9: +4:10\n           goto -> bb6;                     // scope 1 at $DIR/branch.rs:+3:13: +8:6\n       }\n   \n@@ -50,16 +56,20 @@\n   \n       bb5: {\n           StorageDead(_4);                 // scope 1 at $DIR/branch.rs:+6:14: +6:15\n-          nop;                             // scope 1 at $DIR/branch.rs:+7:9: +7:10\n+-         _2 = _1;                         // scope 1 at $DIR/branch.rs:+7:9: +7:10\n++         nop;                             // scope 1 at $DIR/branch.rs:+7:9: +7:10\n           goto -> bb6;                     // scope 1 at $DIR/branch.rs:+3:13: +8:6\n       }\n   \n       bb6: {\n           StorageDead(_3);                 // scope 1 at $DIR/branch.rs:+8:5: +8:6\n-          nop;                             // scope 0 at $DIR/branch.rs:+0:11: +9:2\n-          StorageDead(_2);                 // scope 1 at $DIR/branch.rs:+9:1: +9:2\n-          StorageDead(_1);                 // scope 0 at $DIR/branch.rs:+9:1: +9:2\n-          return;                          // scope 0 at $DIR/branch.rs:+9:2: +9:2\n+-         _0 = _2;                         // scope 2 at $DIR/branch.rs:+10:5: +10:6\n+-         StorageDead(_2);                 // scope 1 at $DIR/branch.rs:+11:1: +11:2\n+-         StorageDead(_1);                 // scope 0 at $DIR/branch.rs:+11:1: +11:2\n++         nop;                             // scope 2 at $DIR/branch.rs:+10:5: +10:6\n++         nop;                             // scope 1 at $DIR/branch.rs:+11:1: +11:2\n++         nop;                             // scope 0 at $DIR/branch.rs:+11:1: +11:2\n+          return;                          // scope 0 at $DIR/branch.rs:+11:2: +11:2\n       }\n   }\n   ", "previous_filename": "src/test/mir-opt/dest-prop/branch.main.DestinationPropagation.diff"}, {"sha": "898c908b18c706bff82e31c3937bcf7b69a10ab9", "filename": "src/test/mir-opt/dest-prop/branch.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,5 +1,5 @@\n //! Tests that assignment in both branches of an `if` are eliminated.\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DestinationPropagation\n fn val() -> i32 {\n     1\n }\n@@ -8,8 +8,8 @@ fn cond() -> bool {\n     true\n }\n \n-// EMIT_MIR branch.main.DestinationPropagation.diff\n-fn main() {\n+// EMIT_MIR branch.foo.DestinationPropagation.diff\n+fn foo() -> i32 {\n     let x = val();\n \n     let y = if cond() {\n@@ -18,4 +18,10 @@ fn main() {\n         val();\n         x\n     };\n+\n+    y\n+}\n+\n+fn main() {\n+    foo();\n }"}, {"sha": "4343a593542ba6647b3be73e5fa82e497373fbcb", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.arg_src.DestinationPropagation.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.arg_src.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -2,7 +2,7 @@\n + // MIR for `arg_src` after DestinationPropagation\n   \n   fn arg_src(_1: i32) -> i32 {\n-      debug x => const 123_i32;            // in scope 0 at $DIR/copy_propagation_arg.rs:+0:12: +0:17\n+      debug x => _1;                       // in scope 0 at $DIR/copy_propagation_arg.rs:+0:12: +0:17\n       let mut _0: i32;                     // return place in scope 0 at $DIR/copy_propagation_arg.rs:+0:27: +0:30\n       let _2: i32;                         // in scope 0 at $DIR/copy_propagation_arg.rs:+1:9: +1:10\n       scope 1 {\n@@ -15,7 +15,7 @@\n -         _2 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+1:13: +1:14\n +         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+1:9: +1:10\n +         _0 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+1:13: +1:14\n-          nop;                             // scope 1 at $DIR/copy_propagation_arg.rs:+2:5: +2:12\n+          _1 = const 123_i32;              // scope 1 at $DIR/copy_propagation_arg.rs:+2:5: +2:12\n -         _0 = _2;                         // scope 1 at $DIR/copy_propagation_arg.rs:+3:5: +3:6\n -         StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+4:1: +4:2\n +         nop;                             // scope 1 at $DIR/copy_propagation_arg.rs:+3:5: +3:6"}, {"sha": "298991b5ad1cb357c2b9be1beaa140757d16c748", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.bar.DestinationPropagation.diff", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.bar.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -2,26 +2,30 @@\n + // MIR for `bar` after DestinationPropagation\n   \n   fn bar(_1: u8) -> () {\n-      debug x => const 5_u8;               // in scope 0 at $DIR/copy_propagation_arg.rs:+0:8: +0:13\n+      debug x => _1;                       // in scope 0 at $DIR/copy_propagation_arg.rs:+0:8: +0:13\n       let mut _0: ();                      // return place in scope 0 at $DIR/copy_propagation_arg.rs:+0:19: +0:19\n       let _2: u8;                          // in scope 0 at $DIR/copy_propagation_arg.rs:+1:5: +1:13\n       let mut _3: u8;                      // in scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:5: +1:13\n-          StorageLive(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n-          _3 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n-          _2 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+1:5: +1:13\n+-         StorageLive(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n+-         _3 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n+-         _2 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+1:5: +1:13\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+1:11: +1:12\n++         _2 = dummy(move _1) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+1:5: +1:13\n                                            // mir::Constant\n                                            // + span: $DIR/copy_propagation_arg.rs:16:5: 16:10\n                                            // + literal: Const { ty: fn(u8) -> u8 {dummy}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageDead(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:12: +1:13\n+-         StorageDead(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:12: +1:13\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+1:12: +1:13\n           StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+1:13: +1:14\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:10\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+0:19: +3:2\n+          _1 = const 5_u8;                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:10\n+          _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:+0:19: +3:2\n           return;                          // scope 0 at $DIR/copy_propagation_arg.rs:+3:2: +3:2\n       }\n   }"}, {"sha": "bc88787e64b2d543cbdaa5c1075f0ba16b13ba1c", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.baz.DestinationPropagation.diff", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.baz.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.baz.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.baz.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,18 +1,22 @@\n - // MIR for `baz` before DestinationPropagation\n + // MIR for `baz` after DestinationPropagation\n   \n-  fn baz(_1: i32) -> () {\n+  fn baz(_1: i32) -> i32 {\n       debug x => _1;                       // in scope 0 at $DIR/copy_propagation_arg.rs:+0:8: +0:13\n-      let mut _0: ();                      // return place in scope 0 at $DIR/copy_propagation_arg.rs:+0:20: +0:20\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/copy_propagation_arg.rs:+0:23: +0:26\n       let mut _2: i32;                     // in scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:10\n-          StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+0:20: +3:2\n-          return;                          // scope 0 at $DIR/copy_propagation_arg.rs:+3:2: +3:2\n+-         StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n+-         _2 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n+-         _1 = move _2;                    // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:10\n+-         StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:10\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:10\n+          _0 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+3:5: +3:6\n+          return;                          // scope 0 at $DIR/copy_propagation_arg.rs:+4:2: +4:2\n       }\n   }\n   "}, {"sha": "d37a9f71d3ebd89df2684ae1c1efd878538f11f3", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.foo.DestinationPropagation.diff", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.foo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.foo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.foo.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -8,20 +8,24 @@\n       let mut _3: u8;                      // in scope 0 at $DIR/copy_propagation_arg.rs:+2:15: +2:16\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n+-         StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n           StorageLive(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:15: +2:16\n           _3 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:+2:15: +2:16\n-          _2 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n+-         _2 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n++         _1 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:+2:9: +2:17\n                                            // mir::Constant\n                                            // + span: $DIR/copy_propagation_arg.rs:11:9: 11:14\n                                            // + literal: Const { ty: fn(u8) -> u8 {dummy}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n           StorageDead(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:16: +2:17\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:17\n-          StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:16: +2:17\n-          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+0:19: +3:2\n+-         _1 = move _2;                    // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:17\n+-         StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:+2:16: +2:17\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:5: +2:17\n++         nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:+2:16: +2:17\n+          _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:+0:19: +3:2\n           return;                          // scope 0 at $DIR/copy_propagation_arg.rs:+3:2: +3:2\n       }\n   }"}, {"sha": "31be6c931393db19261c67abd63a73e41675cbc1", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,6 +1,6 @@\n // Check that DestinationPropagation does not propagate an assignment to a function argument\n // (doing so can break usages of the original argument value)\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DestinationPropagation\n fn dummy(x: u8) -> u8 {\n     x\n }\n@@ -18,9 +18,10 @@ fn bar(mut x: u8) {\n }\n \n // EMIT_MIR copy_propagation_arg.baz.DestinationPropagation.diff\n-fn baz(mut x: i32) {\n+fn baz(mut x: i32) -> i32 {\n     // self-assignment to a function argument should be eliminated\n     x = x;\n+    x\n }\n \n // EMIT_MIR copy_propagation_arg.arg_src.DestinationPropagation.diff"}, {"sha": "cfc203c5f89a1afe22aed47ac9ba9d11fabd1156", "filename": "src/test/mir-opt/dest-prop/cycle.main.DestinationPropagation.diff", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -8,45 +8,69 @@\n       let _5: ();                          // in scope 0 at $DIR/cycle.rs:+6:5: +6:12\n       let mut _6: i32;                     // in scope 0 at $DIR/cycle.rs:+6:10: +6:11\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/cycle.rs:+1:9: +1:14\n+-         debug x => _1;                   // in scope 1 at $DIR/cycle.rs:+1:9: +1:14\n++         debug x => _6;                   // in scope 1 at $DIR/cycle.rs:+1:9: +1:14\n           let _2: i32;                     // in scope 1 at $DIR/cycle.rs:+2:9: +2:10\n           scope 2 {\n-              debug y => _2;               // in scope 2 at $DIR/cycle.rs:+2:9: +2:10\n+-             debug y => _2;               // in scope 2 at $DIR/cycle.rs:+2:9: +2:10\n++             debug y => _6;               // in scope 2 at $DIR/cycle.rs:+2:9: +2:10\n               let _3: i32;                 // in scope 2 at $DIR/cycle.rs:+3:9: +3:10\n               scope 3 {\n-                  debug z => _3;           // in scope 3 at $DIR/cycle.rs:+3:9: +3:10\n-                  scope 4 (inlined std::mem::drop::<i32>) { // at $DIR/cycle.rs:14:5: 14:12\n-                      debug _x => _6;      // in scope 4 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-                  }\n+-                 debug z => _3;           // in scope 3 at $DIR/cycle.rs:+3:9: +3:10\n++                 debug z => _6;           // in scope 3 at $DIR/cycle.rs:+3:9: +3:10\n               }\n           }\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/cycle.rs:+1:9: +1:14\n-          _1 = val() -> bb1;               // scope 0 at $DIR/cycle.rs:+1:17: +1:22\n+-         StorageLive(_1);                 // scope 0 at $DIR/cycle.rs:+1:9: +1:14\n+-         _1 = val() -> bb1;               // scope 0 at $DIR/cycle.rs:+1:17: +1:22\n++         nop;                             // scope 0 at $DIR/cycle.rs:+1:9: +1:14\n++         _6 = val() -> bb1;               // scope 0 at $DIR/cycle.rs:+1:17: +1:22\n                                            // mir::Constant\n                                            // + span: $DIR/cycle.rs:9:17: 9:20\n                                            // + literal: Const { ty: fn() -> i32 {val}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 1 at $DIR/cycle.rs:+2:9: +2:10\n-          nop;                             // scope 1 at $DIR/cycle.rs:+2:13: +2:14\n-          StorageLive(_3);                 // scope 2 at $DIR/cycle.rs:+3:9: +3:10\n-          nop;                             // scope 2 at $DIR/cycle.rs:+3:13: +3:14\n-          StorageLive(_4);                 // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n-          nop;                             // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n-          nop;                             // scope 3 at $DIR/cycle.rs:+4:5: +4:10\n-          StorageDead(_4);                 // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n+-         StorageLive(_2);                 // scope 1 at $DIR/cycle.rs:+2:9: +2:10\n+-         _2 = _1;                         // scope 1 at $DIR/cycle.rs:+2:13: +2:14\n+-         StorageLive(_3);                 // scope 2 at $DIR/cycle.rs:+3:9: +3:10\n+-         _3 = _2;                         // scope 2 at $DIR/cycle.rs:+3:13: +3:14\n+-         StorageLive(_4);                 // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n+-         _4 = _3;                         // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n+-         _1 = move _4;                    // scope 3 at $DIR/cycle.rs:+4:5: +4:10\n+-         StorageDead(_4);                 // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n++         nop;                             // scope 1 at $DIR/cycle.rs:+2:9: +2:10\n++         nop;                             // scope 1 at $DIR/cycle.rs:+2:13: +2:14\n++         nop;                             // scope 2 at $DIR/cycle.rs:+3:9: +3:10\n++         nop;                             // scope 2 at $DIR/cycle.rs:+3:13: +3:14\n++         nop;                             // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:+4:5: +4:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:+4:9: +4:10\n           StorageLive(_5);                 // scope 3 at $DIR/cycle.rs:+6:5: +6:12\n-          StorageLive(_6);                 // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n-          nop;                             // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n-          StorageDead(_6);                 // scope 3 at $DIR/cycle.rs:+6:11: +6:12\n+-         StorageLive(_6);                 // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n+-         _6 = _1;                         // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n++         nop;                             // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n++         nop;                             // scope 3 at $DIR/cycle.rs:+6:10: +6:11\n+          _5 = std::mem::drop::<i32>(move _6) -> bb2; // scope 3 at $DIR/cycle.rs:+6:5: +6:12\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:14:5: 14:9\n+                                           // + literal: Const { ty: fn(i32) {std::mem::drop::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+-         StorageDead(_6);                 // scope 3 at $DIR/cycle.rs:+6:11: +6:12\n++         nop;                             // scope 3 at $DIR/cycle.rs:+6:11: +6:12\n           StorageDead(_5);                 // scope 3 at $DIR/cycle.rs:+6:12: +6:13\n-          StorageDead(_3);                 // scope 2 at $DIR/cycle.rs:+7:1: +7:2\n-          StorageDead(_2);                 // scope 1 at $DIR/cycle.rs:+7:1: +7:2\n-          StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+7:1: +7:2\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:+0:11: +7:2\n+-         StorageDead(_3);                 // scope 2 at $DIR/cycle.rs:+7:1: +7:2\n+-         StorageDead(_2);                 // scope 1 at $DIR/cycle.rs:+7:1: +7:2\n+-         StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+7:1: +7:2\n++         nop;                             // scope 2 at $DIR/cycle.rs:+7:1: +7:2\n++         nop;                             // scope 1 at $DIR/cycle.rs:+7:1: +7:2\n++         nop;                             // scope 0 at $DIR/cycle.rs:+7:1: +7:2\n           return;                          // scope 0 at $DIR/cycle.rs:+7:2: +7:2\n       }\n   }"}, {"sha": "6182878f3413d59b37ee9049d6f3e0644f193202", "filename": "src/test/mir-opt/dest-prop/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,5 +1,5 @@\n //! Tests that cyclic assignments don't hang DestinationPropagation, and result in reasonable code.\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DestinationPropagation\n fn val() -> i32 {\n     1\n }"}, {"sha": "63cac133b73bf3d498fa63c6dd5698bc560698ce", "filename": "src/test/mir-opt/dest-prop/dead_stores_79191.f.DestinationPropagation.after.mir", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.f.DestinationPropagation.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.f.DestinationPropagation.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.f.DestinationPropagation.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -0,0 +1,34 @@\n+// MIR for `f` after DestinationPropagation\n+\n+fn f(_1: usize) -> usize {\n+    debug a => _1;                       // in scope 0 at $DIR/dead_stores_79191.rs:+0:6: +0:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/dead_stores_79191.rs:+0:23: +0:28\n+    let _2: usize;                       // in scope 0 at $DIR/dead_stores_79191.rs:+1:9: +1:10\n+    let mut _3: usize;                   // in scope 0 at $DIR/dead_stores_79191.rs:+3:9: +3:10\n+    let mut _4: usize;                   // in scope 0 at $DIR/dead_stores_79191.rs:+4:8: +4:9\n+    scope 1 {\n+        debug b => _3;                   // in scope 1 at $DIR/dead_stores_79191.rs:+1:9: +1:10\n+    }\n+\n+    bb0: {\n+        nop;                             // scope 0 at $DIR/dead_stores_79191.rs:+1:9: +1:10\n+        _3 = _1;                         // scope 0 at $DIR/dead_stores_79191.rs:+1:13: +1:14\n+        _1 = const 5_usize;              // scope 1 at $DIR/dead_stores_79191.rs:+2:5: +2:10\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+3:9: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+3:9: +3:10\n+        _1 = move _3;                    // scope 1 at $DIR/dead_stores_79191.rs:+3:5: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+3:9: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+4:8: +4:9\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+4:8: +4:9\n+        _0 = id::<usize>(move _1) -> bb1; // scope 1 at $DIR/dead_stores_79191.rs:+4:5: +4:10\n+                                         // mir::Constant\n+                                         // + span: $DIR/dead_stores_79191.rs:12:5: 12:7\n+                                         // + literal: Const { ty: fn(usize) -> usize {id::<usize>}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        nop;                             // scope 1 at $DIR/dead_stores_79191.rs:+4:9: +4:10\n+        nop;                             // scope 0 at $DIR/dead_stores_79191.rs:+5:1: +5:2\n+        return;                          // scope 0 at $DIR/dead_stores_79191.rs:+5:2: +5:2\n+    }\n+}"}, {"sha": "43e0bf66418aa5b3f34f71919f160ed37f00777a", "filename": "src/test/mir-opt/dest-prop/dead_stores_79191.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_79191.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -0,0 +1,17 @@\n+// unit-test: DestinationPropagation\n+\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+// EMIT_MIR dead_stores_79191.f.DestinationPropagation.after.mir\n+fn f(mut a: usize) -> usize {\n+    let b = a;\n+    a = 5;\n+    a = b;\n+    id(a)\n+}\n+\n+fn main() {\n+    f(0);\n+}"}, {"sha": "ba7f76d2841f3465cc4133af4a82a44d2874785f", "filename": "src/test/mir-opt/dest-prop/dead_stores_better.f.DestinationPropagation.after.mir", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.f.DestinationPropagation.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.f.DestinationPropagation.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.f.DestinationPropagation.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -0,0 +1,34 @@\n+// MIR for `f` after DestinationPropagation\n+\n+fn f(_1: usize) -> usize {\n+    debug a => _1;                       // in scope 0 at $DIR/dead_stores_better.rs:+0:10: +0:15\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/dead_stores_better.rs:+0:27: +0:32\n+    let _2: usize;                       // in scope 0 at $DIR/dead_stores_better.rs:+1:9: +1:10\n+    let mut _3: usize;                   // in scope 0 at $DIR/dead_stores_better.rs:+3:9: +3:10\n+    let mut _4: usize;                   // in scope 0 at $DIR/dead_stores_better.rs:+4:8: +4:9\n+    scope 1 {\n+        debug b => _1;                   // in scope 1 at $DIR/dead_stores_better.rs:+1:9: +1:10\n+    }\n+\n+    bb0: {\n+        nop;                             // scope 0 at $DIR/dead_stores_better.rs:+1:9: +1:10\n+        nop;                             // scope 0 at $DIR/dead_stores_better.rs:+1:13: +1:14\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+2:5: +2:10\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+3:9: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+3:9: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+3:5: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+3:9: +3:10\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+4:8: +4:9\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+4:8: +4:9\n+        _0 = id::<usize>(move _1) -> bb1; // scope 1 at $DIR/dead_stores_better.rs:+4:5: +4:10\n+                                         // mir::Constant\n+                                         // + span: $DIR/dead_stores_better.rs:16:5: 16:7\n+                                         // + literal: Const { ty: fn(usize) -> usize {id::<usize>}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        nop;                             // scope 1 at $DIR/dead_stores_better.rs:+4:9: +4:10\n+        nop;                             // scope 0 at $DIR/dead_stores_better.rs:+5:1: +5:2\n+        return;                          // scope 0 at $DIR/dead_stores_better.rs:+5:2: +5:2\n+    }\n+}"}, {"sha": "003ad57d83ea77fa4f5f888a7d66e6314f22539d", "filename": "src/test/mir-opt/dest-prop/dead_stores_better.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fdead_stores_better.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -0,0 +1,21 @@\n+// This is a copy of the `dead_stores_79191` test, except that we turn on DSE. This demonstrates\n+// that that pass enables this one to do more optimizations.\n+\n+// unit-test: DestinationPropagation\n+// compile-flags: -Zmir-enable-passes=+DeadStoreElimination\n+\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+// EMIT_MIR dead_stores_better.f.DestinationPropagation.after.mir\n+pub fn f(mut a: usize) -> usize {\n+    let b = a;\n+    a = 5;\n+    a = b;\n+    id(a)\n+}\n+\n+fn main() {\n+    f(0);\n+}"}, {"sha": "c2a3a0025840ab8090a9f0d7f98cd12f50096fb8", "filename": "src/test/mir-opt/dest-prop/simple.nrvo.DestinationPropagation.diff", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -17,18 +17,22 @@\n           StorageLive(_2);                 // scope 0 at $DIR/simple.rs:+1:9: +1:16\n           _2 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:+1:19: +1:28\n           StorageLive(_3);                 // scope 1 at $DIR/simple.rs:+2:5: +2:19\n-          StorageLive(_4);                 // scope 1 at $DIR/simple.rs:+2:5: +2:9\n-          _4 = _1;                         // scope 1 at $DIR/simple.rs:+2:5: +2:9\n+-         StorageLive(_4);                 // scope 1 at $DIR/simple.rs:+2:5: +2:9\n+-         _4 = _1;                         // scope 1 at $DIR/simple.rs:+2:5: +2:9\n++         nop;                             // scope 1 at $DIR/simple.rs:+2:5: +2:9\n++         nop;                             // scope 1 at $DIR/simple.rs:+2:5: +2:9\n           StorageLive(_5);                 // scope 1 at $DIR/simple.rs:+2:10: +2:18\n           StorageLive(_6);                 // scope 1 at $DIR/simple.rs:+2:10: +2:18\n           _6 = &mut _2;                    // scope 1 at $DIR/simple.rs:+2:10: +2:18\n           _5 = &mut (*_6);                 // scope 1 at $DIR/simple.rs:+2:10: +2:18\n-          _3 = move _4(move _5) -> bb1;    // scope 1 at $DIR/simple.rs:+2:5: +2:19\n+-         _3 = move _4(move _5) -> bb1;    // scope 1 at $DIR/simple.rs:+2:5: +2:19\n++         _3 = move _1(move _5) -> bb1;    // scope 1 at $DIR/simple.rs:+2:5: +2:19\n       }\n   \n       bb1: {\n           StorageDead(_5);                 // scope 1 at $DIR/simple.rs:+2:18: +2:19\n-          StorageDead(_4);                 // scope 1 at $DIR/simple.rs:+2:18: +2:19\n+-         StorageDead(_4);                 // scope 1 at $DIR/simple.rs:+2:18: +2:19\n++         nop;                             // scope 1 at $DIR/simple.rs:+2:18: +2:19\n           StorageDead(_6);                 // scope 1 at $DIR/simple.rs:+2:19: +2:20\n           StorageDead(_3);                 // scope 1 at $DIR/simple.rs:+2:19: +2:20\n           _0 = _2;                         // scope 1 at $DIR/simple.rs:+3:5: +3:8"}, {"sha": "d4c27228fe425bb18e0531d3d771f02cb51eb50b", "filename": "src/test/mir-opt/dest-prop/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,5 +1,5 @@\n //! Copy of `nrvo-simple.rs`, to ensure that full dest-prop handles it too.\n-// compile-flags: -Zunsound-mir-opts\n+// unit-test: DestinationPropagation\n // EMIT_MIR simple.nrvo.DestinationPropagation.diff\n fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n     let mut buf = [0; 1024];"}, {"sha": "85d994bc8b973442db7d3fbd54d87e559b34fa52", "filename": "src/test/mir-opt/dest-prop/union.main.DestinationPropagation.diff", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -5,14 +5,13 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/union.rs:+0:11: +0:11\n       let _1: main::Un;                    // in scope 0 at $DIR/union.rs:+5:9: +5:11\n       let mut _2: u32;                     // in scope 0 at $DIR/union.rs:+5:23: +5:28\n-      let _3: ();                          // in scope 0 at $DIR/union.rs:+7:5: +7:27\n-      let mut _4: u32;                     // in scope 0 at $DIR/union.rs:+7:10: +7:26\n+      let mut _3: u32;                     // in scope 0 at $DIR/union.rs:+7:10: +7:26\n       scope 1 {\n           debug un => _1;                  // in scope 1 at $DIR/union.rs:+5:9: +5:11\n           scope 2 {\n           }\n           scope 3 (inlined std::mem::drop::<u32>) { // at $DIR/union.rs:15:5: 15:27\n-              debug _x => _4;              // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+              debug _x => _3;              // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           }\n       }\n   \n@@ -29,11 +28,9 @@\n           nop;                             // scope 0 at $DIR/union.rs:+5:14: +5:30\n           nop;                             // scope 0 at $DIR/union.rs:+5:14: +5:30\n           StorageDead(_2);                 // scope 0 at $DIR/union.rs:+5:29: +5:30\n-          StorageLive(_3);                 // scope 1 at $DIR/union.rs:+7:5: +7:27\n-          StorageLive(_4);                 // scope 1 at $DIR/union.rs:+7:10: +7:26\n+          StorageLive(_3);                 // scope 1 at $DIR/union.rs:+7:10: +7:26\n           nop;                             // scope 2 at $DIR/union.rs:+7:19: +7:24\n-          StorageDead(_4);                 // scope 1 at $DIR/union.rs:+7:26: +7:27\n-          StorageDead(_3);                 // scope 1 at $DIR/union.rs:+7:27: +7:28\n+          StorageDead(_3);                 // scope 1 at $DIR/union.rs:+7:26: +7:27\n           StorageDead(_1);                 // scope 0 at $DIR/union.rs:+8:1: +8:2\n           return;                          // scope 0 at $DIR/union.rs:+8:2: +8:2\n       }"}, {"sha": "8ea1a0757f2f028ee79cb76c8ddd08f4f29dc5d2", "filename": "src/test/mir-opt/inline/dyn_trait.get_query.Inline.diff", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.get_query.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.get_query.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.get_query.Inline.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -12,10 +12,8 @@\n +         scope 2 (inlined try_execute_query::<<Q as Query>::C>) { // at $DIR/dyn_trait.rs:34:5: 34:25\n +             debug c => _4;               // in scope 2 at $DIR/dyn_trait.rs:26:36: 26:37\n +             let mut _5: &dyn Cache<V = <Q as Query>::V>; // in scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+             let mut _6: &<Q as Query>::C; // in scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n +             scope 3 (inlined mk_cycle::<<Q as Query>::V>) { // at $DIR/dyn_trait.rs:27:5: 27:16\n +                 debug c => _5;           // in scope 3 at $DIR/dyn_trait.rs:20:27: 20:28\n-+                 let mut _7: &dyn Cache<V = <Q as Query>::V>; // in scope 3 at $DIR/dyn_trait.rs:21:5: 21:22\n +             }\n +         }\n       }\n@@ -37,13 +35,8 @@\n           _4 = &(*_2);                     // scope 1 at $DIR/dyn_trait.rs:+2:23: +2:24\n -         _0 = try_execute_query::<<Q as Query>::C>(move _4) -> bb2; // scope 1 at $DIR/dyn_trait.rs:+2:5: +2:25\n +         StorageLive(_5);                 // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+         StorageLive(_6);                 // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+         _6 = _4;                         // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+         _5 = move _6 as &dyn Cache<V = <Q as Query>::V> (Pointer(Unsize)); // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+         StorageDead(_6);                 // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n-+         StorageLive(_7);                 // scope 3 at $DIR/dyn_trait.rs:21:5: 21:22\n-+         _7 = _5;                         // scope 3 at $DIR/dyn_trait.rs:21:5: 21:22\n-+         _0 = <dyn Cache<V = <Q as Query>::V> as Cache>::store_nocache(move _7) -> bb2; // scope 3 at $DIR/dyn_trait.rs:21:5: 21:22\n++         _5 = move _4 as &dyn Cache<V = <Q as Query>::V> (Pointer(Unsize)); // scope 2 at $DIR/dyn_trait.rs:27:14: 27:15\n++         _0 = <dyn Cache<V = <Q as Query>::V> as Cache>::store_nocache(move _5) -> bb2; // scope 3 at $DIR/dyn_trait.rs:21:5: 21:22\n                                            // mir::Constant\n -                                          // + span: $DIR/dyn_trait.rs:34:5: 34:22\n -                                          // + literal: Const { ty: for<'a> fn(&'a <Q as Query>::C) {try_execute_query::<<Q as Query>::C>}, val: Value(<ZST>) }\n@@ -52,7 +45,6 @@\n       }\n   \n       bb2: {\n-+         StorageDead(_7);                 // scope 3 at $DIR/dyn_trait.rs:21:21: 21:22\n +         StorageDead(_5);                 // scope 2 at $DIR/dyn_trait.rs:27:15: 27:16\n           StorageDead(_4);                 // scope 1 at $DIR/dyn_trait.rs:+2:24: +2:25\n           StorageDead(_2);                 // scope 0 at $DIR/dyn_trait.rs:+3:1: +3:2"}, {"sha": "a71d73b7453544464922e3434b41b858aa18836b", "filename": "src/test/mir-opt/inline/dyn_trait.try_execute_query.Inline.diff", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.try_execute_query.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.try_execute_query.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fdyn_trait.try_execute_query.Inline.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -8,7 +8,6 @@\n       let mut _3: &C;                      // in scope 0 at $DIR/dyn_trait.rs:+1:14: +1:15\n +     scope 1 (inlined mk_cycle::<<C as Cache>::V>) { // at $DIR/dyn_trait.rs:27:5: 27:16\n +         debug c => _2;                   // in scope 1 at $DIR/dyn_trait.rs:20:27: 20:28\n-+         let mut _4: &dyn Cache<V = <C as Cache>::V>; // in scope 1 at $DIR/dyn_trait.rs:21:5: 21:22\n +     }\n   \n       bb0: {\n@@ -18,9 +17,7 @@\n           _2 = move _3 as &dyn Cache<V = <C as Cache>::V> (Pointer(Unsize)); // scope 0 at $DIR/dyn_trait.rs:+1:14: +1:15\n           StorageDead(_3);                 // scope 0 at $DIR/dyn_trait.rs:+1:14: +1:15\n -         _0 = mk_cycle::<<C as Cache>::V>(move _2) -> bb1; // scope 0 at $DIR/dyn_trait.rs:+1:5: +1:16\n-+         StorageLive(_4);                 // scope 1 at $DIR/dyn_trait.rs:21:5: 21:22\n-+         _4 = _2;                         // scope 1 at $DIR/dyn_trait.rs:21:5: 21:22\n-+         _0 = <dyn Cache<V = <C as Cache>::V> as Cache>::store_nocache(move _4) -> bb1; // scope 1 at $DIR/dyn_trait.rs:21:5: 21:22\n++         _0 = <dyn Cache<V = <C as Cache>::V> as Cache>::store_nocache(move _2) -> bb1; // scope 1 at $DIR/dyn_trait.rs:21:5: 21:22\n                                            // mir::Constant\n -                                          // + span: $DIR/dyn_trait.rs:27:5: 27:13\n -                                          // + literal: Const { ty: for<'a> fn(&'a (dyn Cache<V = <C as Cache>::V> + 'a)) {mk_cycle::<<C as Cache>::V>}, val: Value(<ZST>) }\n@@ -29,7 +26,6 @@\n       }\n   \n       bb1: {\n-+         StorageDead(_4);                 // scope 1 at $DIR/dyn_trait.rs:21:21: 21:22\n           StorageDead(_2);                 // scope 0 at $DIR/dyn_trait.rs:+1:15: +1:16\n           return;                          // scope 0 at $DIR/dyn_trait.rs:+2:2: +2:2\n       }"}, {"sha": "3502c25864bf9fffe84742a443c7876e4a770b95", "filename": "src/test/mir-opt/inline/inline_any_operand.bar.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -11,8 +11,6 @@ fn bar() -> bool {\n         scope 2 (inlined foo) {          // at $DIR/inline_any_operand.rs:12:5: 12:13\n             debug x => _3;               // in scope 2 at $DIR/inline_any_operand.rs:16:8: 16:9\n             debug y => _4;               // in scope 2 at $DIR/inline_any_operand.rs:16:16: 16:17\n-            let mut _5: i32;             // in scope 2 at $DIR/inline_any_operand.rs:17:5: 17:6\n-            let mut _6: i32;             // in scope 2 at $DIR/inline_any_operand.rs:17:10: 17:11\n         }\n     }\n \n@@ -28,13 +26,7 @@ fn bar() -> bool {\n         _3 = const 1_i32;                // scope 1 at $DIR/inline_any_operand.rs:+2:5: +2:13\n         StorageLive(_4);                 // scope 1 at $DIR/inline_any_operand.rs:+2:5: +2:13\n         _4 = const -1_i32;               // scope 1 at $DIR/inline_any_operand.rs:+2:5: +2:13\n-        StorageLive(_5);                 // scope 2 at $DIR/inline_any_operand.rs:17:5: 17:6\n-        _5 = _3;                         // scope 2 at $DIR/inline_any_operand.rs:17:5: 17:6\n-        StorageLive(_6);                 // scope 2 at $DIR/inline_any_operand.rs:17:10: 17:11\n-        _6 = _4;                         // scope 2 at $DIR/inline_any_operand.rs:17:10: 17:11\n-        _0 = Eq(move _5, move _6);       // scope 2 at $DIR/inline_any_operand.rs:17:5: 17:11\n-        StorageDead(_6);                 // scope 2 at $DIR/inline_any_operand.rs:17:10: 17:11\n-        StorageDead(_5);                 // scope 2 at $DIR/inline_any_operand.rs:17:10: 17:11\n+        _0 = Eq(move _3, move _4);       // scope 2 at $DIR/inline_any_operand.rs:17:5: 17:11\n         StorageDead(_4);                 // scope 1 at $DIR/inline_any_operand.rs:+2:5: +2:13\n         StorageDead(_3);                 // scope 1 at $DIR/inline_any_operand.rs:+2:5: +2:13\n         StorageDead(_2);                 // scope 1 at $DIR/inline_any_operand.rs:+2:12: +2:13"}, {"sha": "dd32eb2d8d1f7fcb68646b2a27cb1e6382f3bf51", "filename": "src/test/mir-opt/inline/inline_closure_borrows_arg.foo.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -16,9 +16,8 @@ fn foo(_1: T, _2: &i32) -> i32 {\n         scope 2 (inlined foo::<T>::{closure#0}) { // at $DIR/inline_closure_borrows_arg.rs:16:5: 16:12\n             debug r => _8;               // in scope 2 at $DIR/inline_closure_borrows_arg.rs:+1:14: +1:15\n             debug _s => _9;              // in scope 2 at $DIR/inline_closure_borrows_arg.rs:+1:23: +1:25\n-            let _10: &i32;               // in scope 2 at $DIR/inline_closure_borrows_arg.rs:+2:13: +2:21\n             scope 3 {\n-                debug variable => _10;   // in scope 3 at $DIR/inline_closure_borrows_arg.rs:+2:13: +2:21\n+                debug variable => _8;    // in scope 3 at $DIR/inline_closure_borrows_arg.rs:+2:13: +2:21\n             }\n         }\n     }\n@@ -40,10 +39,7 @@ fn foo(_1: T, _2: &i32) -> i32 {\n         _8 = move (_5.0: &i32);          // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageLive(_9);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         _9 = move (_5.1: &i32);          // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n-        StorageLive(_10);                // scope 2 at $DIR/inline_closure_borrows_arg.rs:+2:13: +2:21\n-        _10 = _8;                        // scope 2 at $DIR/inline_closure_borrows_arg.rs:+2:24: +2:27\n-        _0 = (*_10);                     // scope 3 at $DIR/inline_closure_borrows_arg.rs:+3:9: +3:18\n-        StorageDead(_10);                // scope 2 at $DIR/inline_closure_borrows_arg.rs:+4:5: +4:6\n+        _0 = (*_8);                      // scope 3 at $DIR/inline_closure_borrows_arg.rs:+3:9: +3:18\n         StorageDead(_9);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageDead(_8);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageDead(_7);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:11: +5:12"}, {"sha": "ab1ea0e3b2c24d91b667c8ddbc06c96de2e088e0", "filename": "src/test/mir-opt/inline/inline_cycle.two.Inline.diff", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -8,11 +8,10 @@\n +     scope 1 (inlined call::<fn() {f}>) { // at $DIR/inline_cycle.rs:49:5: 49:12\n +         debug f => _2;                   // in scope 1 at $DIR/inline_cycle.rs:53:22: 53:23\n +         let _3: ();                      // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         let mut _4: fn() {f};            // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:6\n-+         let mut _5: ();                  // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n++         let mut _4: ();                  // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +         scope 2 (inlined <fn() {f} as FnOnce<()>>::call_once - shim(fn() {f})) { // at $DIR/inline_cycle.rs:54:5: 54:8\n +             scope 3 (inlined f) {        // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-+                 let _6: ();              // in scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n++                 let _5: ();              // in scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n +             }\n +         }\n +     }\n@@ -27,11 +26,9 @@\n +                                          // + span: $DIR/inline_cycle.rs:49:10: 49:11\n +                                          // + literal: Const { ty: fn() {f}, val: Value(<ZST>) }\n +         StorageLive(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         StorageLive(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:6\n-+         _4 = move _2;                    // scope 1 at $DIR/inline_cycle.rs:54:5: 54:6\n-+         StorageLive(_5);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         StorageLive(_6);                 // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n-+         _6 = call::<fn() {f}>(f) -> bb1; // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n++         StorageLive(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n++         StorageLive(_5);                 // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n++         _5 = call::<fn() {f}>(f) -> bb1; // scope 3 at $DIR/inline_cycle.rs:59:5: 59:12\n +                                          // mir::Constant\n +                                          // + span: $DIR/inline_cycle.rs:59:5: 59:9\n                                            // + literal: Const { ty: fn(fn() {f}) {call::<fn() {f}>}, val: Value(<ZST>) }\n@@ -42,8 +39,7 @@\n       }\n   \n       bb1: {\n-+         StorageDead(_6);                 // scope 3 at $DIR/inline_cycle.rs:59:12: 59:13\n-+         StorageDead(_5);                 // scope 1 at $DIR/inline_cycle.rs:54:7: 54:8\n++         StorageDead(_5);                 // scope 3 at $DIR/inline_cycle.rs:59:12: 59:13\n +         StorageDead(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:7: 54:8\n +         StorageDead(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:8: 54:9\n +         StorageDead(_2);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12"}, {"sha": "75a6ab3700898e2a05ab3cbf1e3c1e0829af9058", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -10,15 +10,14 @@\n +         let _3: !;                       // in scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n +         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         let mut _5: ();                  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n-+         let mut _7: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         let mut _8: ();                  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:16\n-+         let mut _9: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         let mut _10: !;                  // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n++         let mut _6: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:14\n++         let mut _7: ();                  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:16\n++         let mut _8: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n++         let mut _9: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n +         scope 2 {\n +             debug a => _3;               // in scope 2 at $DIR/inline_diverging.rs:27:9: 27:10\n-+             let _6: !;                   // in scope 2 at $DIR/inline_diverging.rs:28:9: 28:10\n +             scope 3 {\n-+                 debug b => _6;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n++                 debug b => _9;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n +             }\n +             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline_diverging.rs:28:13: 28:16\n +                 scope 7 (inlined sleep) { // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n@@ -42,6 +41,7 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline_diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(<ZST>) }\n++         StorageLive(_9);                 // scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n +         StorageLive(_3);                 // scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n +         StorageLive(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         _4 = &_2;                        // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14"}, {"sha": "91bff3d3234db25ab9dbcccf089da7d0e3492e54", "filename": "src/test/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -24,15 +24,12 @@\n +         }\n +     }\n +     scope 6 (inlined g::{closure#0}) {   // at $DIR/inline_generator.rs:9:14: 9:46\n-+         debug a => _11;                  // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n++         debug a => _7;                   // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n +         let mut _8: i32;                 // in scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         let mut _9: bool;                // in scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n-+         let mut _10: bool;               // in scope 6 at $DIR/inline_generator.rs:15:9: 15:9\n-+         let _11: bool;                   // in scope 6 at $DIR/inline_generator.rs:15:6: 15:7\n-+         let mut _12: u32;                // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _13: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _14: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         let mut _15: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _9: u32;                 // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _10: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _11: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         let mut _12: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]; // in scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +     }\n   \n       bb0: {\n@@ -73,17 +70,13 @@\n -                                          // + literal: Const { ty: for<'a> fn(Pin<&'a mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>, bool) -> GeneratorState<<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Yield, <[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::Return> {<[generator@$DIR/inline_generator.rs:15:5: 15:8] as Generator<bool>>::resume}, val: Value(<ZST>) }\n +         StorageLive(_7);                 // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n +         _7 = const false;                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n-+         StorageLive(_10);                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n-+         StorageLive(_11);                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n-+         _13 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         _12 = discriminant((*_13));      // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         switchInt(move _12) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         _10 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         _9 = discriminant((*_10));       // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         switchInt(move _9) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n       }\n   \n -     bb3: {\n +     bb1: {\n-+         StorageDead(_11);                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n-+         StorageDead(_10);                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n +         StorageDead(_7);                 // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n           StorageDead(_2);                 // scope 0 at $DIR/inline_generator.rs:+1:45: +1:46\n           StorageDead(_4);                 // scope 0 at $DIR/inline_generator.rs:+1:46: +1:47\n@@ -98,11 +91,8 @@\n +     }\n + \n +     bb3: {\n-+         _11 = move _7;                   // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         StorageLive(_9);                 // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n-+         _9 = _11;                        // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n-+         switchInt(move _9) -> [false: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n++         switchInt(move _7) -> [false: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n +     }\n + \n +     bb4: {\n@@ -116,24 +106,22 @@\n +     }\n + \n +     bb6: {\n-+         StorageDead(_9);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n +         Deinit(_1);                      // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         ((_1 as Yielded).0: i32) = move _8; // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         discriminant(_1) = 0;            // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         _14 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         discriminant((*_14)) = 3;        // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         _11 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         discriminant((*_11)) = 3;        // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:11: 15:39\n +     }\n + \n +     bb7: {\n +         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         _10 = move _7;                   // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         StorageDead(_8);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n +         Deinit(_1);                      // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         ((_1 as Complete).0: bool) = move _10; // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         ((_1 as Complete).0: bool) = move _7; // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         discriminant(_1) = 1;            // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         _15 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         discriminant((*_15)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         _12 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         discriminant((*_12)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:41: 15:41\n +     }\n + "}, {"sha": "73aea719eed51956d3996950160b124a2217a360", "filename": "src/test/mir-opt/inline/inline_trait_method_2.test2.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -7,7 +7,6 @@ fn test2(_1: &dyn X) -> bool {\n     let mut _3: &dyn X;                  // in scope 0 at $DIR/inline_trait_method_2.rs:+1:10: +1:11\n     scope 1 (inlined test) {             // at $DIR/inline_trait_method_2.rs:5:5: 5:12\n         debug x => _2;                   // in scope 1 at $DIR/inline_trait_method_2.rs:9:9: 9:10\n-        let mut _4: &dyn X;              // in scope 1 at $DIR/inline_trait_method_2.rs:10:5: 10:10\n     }\n \n     bb0: {\n@@ -16,16 +15,13 @@ fn test2(_1: &dyn X) -> bool {\n         _3 = &(*_1);                     // scope 0 at $DIR/inline_trait_method_2.rs:+1:10: +1:11\n         _2 = move _3 as &dyn X (Pointer(Unsize)); // scope 0 at $DIR/inline_trait_method_2.rs:+1:10: +1:11\n         StorageDead(_3);                 // scope 0 at $DIR/inline_trait_method_2.rs:+1:10: +1:11\n-        StorageLive(_4);                 // scope 1 at $DIR/inline_trait_method_2.rs:10:5: 10:10\n-        _4 = _2;                         // scope 1 at $DIR/inline_trait_method_2.rs:10:5: 10:10\n-        _0 = <dyn X as X>::y(move _4) -> bb1; // scope 1 at $DIR/inline_trait_method_2.rs:10:5: 10:10\n+        _0 = <dyn X as X>::y(move _2) -> bb1; // scope 1 at $DIR/inline_trait_method_2.rs:10:5: 10:10\n                                          // mir::Constant\n                                          // + span: $DIR/inline_trait_method_2.rs:10:7: 10:8\n                                          // + literal: Const { ty: for<'a> fn(&'a dyn X) -> bool {<dyn X as X>::y}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_4);                 // scope 1 at $DIR/inline_trait_method_2.rs:10:9: 10:10\n         StorageDead(_2);                 // scope 0 at $DIR/inline_trait_method_2.rs:+1:11: +1:12\n         return;                          // scope 0 at $DIR/inline_trait_method_2.rs:+2:2: +2:2\n     }"}, {"sha": "8fe60a0245d7dcdf86c69fc37ad2a1e763c9d24d", "filename": "src/test/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -18,17 +18,16 @@\n           debug x => _5;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n           let mut _12: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n           let mut _13: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n-          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:7:13: 7:14\n-          let mut _15: (u32, bool);        // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n+          let mut _14: (u32, bool);        // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n           scope 2 {\n               debug out => _4;             // in scope 2 at $DIR/issue_101973.rs:6:9: 6:16\n           }\n       }\n       scope 3 (inlined core::num::<impl u32>::rotate_right) { // at $DIR/issue_101973.rs:14:5: 14:58\n           debug self => _4;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           debug n => _6;                   // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          let mut _15: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           let mut _16: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          let mut _17: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n       }\n   \n       bb0: {\n@@ -39,10 +38,8 @@\n           _5 = _1;                         // scope 0 at $DIR/issue_101973.rs:+1:10: +1:16\n           StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:7:13: 7:14\n-          _14 = _5;                        // scope 2 at $DIR/issue_101973.rs:7:13: 7:14\n-          _15 = CheckedShr(_14, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          assert(!move (_15.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _14 = CheckedShr(_5, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          assert(!move (_14.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n       }\n   \n       bb1: {\n@@ -57,19 +54,18 @@\n       bb2: {\n           _6 = move (_11.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageDead(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:56: +1:57\n+          StorageLive(_15);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _15 = _4;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           StorageLive(_16);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          _16 = _4;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          StorageLive(_17);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          _17 = _6;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-          _3 = rotate_right::<u32>(move _16, move _17) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _16 = _6;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _3 = rotate_right::<u32>(move _15, move _16) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn(u32, u32) -> u32 {rotate_right::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          _13 = move (_15.0: u32);         // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:7:19: 7:20\n+          _13 = move (_14.0: u32);         // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n           _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n           _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n@@ -85,8 +81,8 @@\n       }\n   \n       bb4: {\n-          StorageDead(_17);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           StorageDead(_16);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          StorageDead(_15);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n           StorageDead(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           StorageDead(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           _2 = move _3 as i32 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65"}, {"sha": "5a2f4feff355263fa2db23b1d4e01977aee90145", "filename": "src/test/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -3,64 +3,54 @@\n fn num_to_digit(_1: char) -> u32 {\n     debug num => _1;                     // in scope 0 at $DIR/issue_59352.rs:+0:21: +0:24\n     let mut _0: u32;                     // return place in scope 0 at $DIR/issue_59352.rs:+0:35: +0:38\n-    let mut _2: char;                    // in scope 0 at $DIR/issue_59352.rs:+2:8: +2:11\n-    let mut _3: std::option::Option<u32>; // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n-    let mut _4: char;                    // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:29\n-    let mut _5: u32;                     // in scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n-    let mut _12: isize;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+    let mut _2: std::option::Option<u32>; // in scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+    let mut _3: u32;                     // in scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+    let mut _9: isize;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n     scope 1 (inlined char::methods::<impl char>::is_digit) { // at $DIR/issue_59352.rs:14:8: 14:23\n-        debug self => _2;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        debug radix => _5;               // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        let mut _6: &std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        let _7: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        let mut _8: char;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        debug self => _1;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        debug radix => _3;               // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        let mut _4: &std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        let _5: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        let mut _6: char;                // in scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         scope 2 (inlined Option::<u32>::is_some) { // at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-            debug self => _6;            // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n-            let mut _9: isize;           // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+            debug self => _4;            // in scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n     }\n     scope 3 (inlined #[track_caller] Option::<u32>::unwrap) { // at $DIR/issue_59352.rs:14:26: 14:50\n-        debug self => _3;                // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        let mut _10: isize;              // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        let mut _11: !;                  // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        debug self => _2;                // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        let mut _7: isize;               // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        let mut _8: !;                   // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n         scope 4 {\n             debug val => _0;             // in scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n         }\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:11\n-        _2 = _1;                         // scope 0 at $DIR/issue_59352.rs:+2:8: +2:11\n-        StorageLive(_5);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        StorageLive(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        StorageLive(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        StorageLive(_5);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageLive(_6);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageLive(_7);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageLive(_8);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _8 = _2;                         // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _7 = char::methods::<impl char>::to_digit(move _8, const 8_u32) -> bb5; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        _6 = _1;                         // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        _5 = char::methods::<impl char>::to_digit(move _6, const 8_u32) -> bb5; // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/char/methods.rs:LL:COL\n                                          // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_12);                // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n-        StorageLive(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n-        StorageLive(_4);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:29\n-        _4 = _1;                         // scope 0 at $DIR/issue_59352.rs:+2:26: +2:29\n-        _3 = char::methods::<impl char>::to_digit(move _4, const 8_u32) -> bb2; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+        StorageLive(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n+        _2 = char::methods::<impl char>::to_digit(move _1, const 8_u32) -> bb2; // scope 0 at $DIR/issue_59352.rs:+2:26: +2:41\n                                          // mir::Constant\n                                          // + span: $DIR/issue_59352.rs:14:30: 14:38\n                                          // + literal: Const { ty: fn(char, u32) -> Option<u32> {char::methods::<impl char>::to_digit}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n-        StorageDead(_4);                 // scope 0 at $DIR/issue_59352.rs:+2:40: +2:41\n-        _10 = discriminant(_3);          // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _10) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        _7 = discriminant(_2);           // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _7) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageDead(_12);                // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n         _0 = const 0_u32;                // scope 0 at $DIR/issue_59352.rs:+2:60: +2:61\n         goto -> bb4;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n     }\n@@ -70,21 +60,18 @@ fn num_to_digit(_1: char) -> u32 {\n     }\n \n     bb5: {\n-        _6 = &_7;                        // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageDead(_8);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        _9 = discriminant((*_6));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageLive(_12);                // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        _12 = move _9;                   // scope 2 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _4 = &_5;                        // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageDead(_6);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageDead(_7);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n-        StorageDead(_5);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n-        StorageDead(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:22: +2:23\n-        switchInt(move _12) -> [1_isize: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        _9 = discriminant((*_4));        // scope 2 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        StorageDead(_5);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n+        StorageDead(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        switchInt(move _9) -> [1_isize: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n     }\n \n     bb6: {\n-        StorageLive(_11);                // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        _11 = core::panicking::panic(const \"called `Option::unwrap()` on a `None` value\"); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        _8 = core::panicking::panic(const \"called `Option::unwrap()` on a `None` value\"); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/option.rs:LL:COL\n                                          // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }\n@@ -98,8 +85,8 @@ fn num_to_digit(_1: char) -> u32 {\n     }\n \n     bb8: {\n-        _0 = move ((_3 as Some).0: u32); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:49: +2:50\n+        _0 = move ((_2 as Some).0: u32); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_2);                 // scope 0 at $DIR/issue_59352.rs:+2:49: +2:50\n         goto -> bb4;                     // scope 0 at $DIR/issue_59352.rs:+2:5: +2:63\n     }\n }"}, {"sha": "9b1b07f38fcd3307627ad291a64371f8331df376", "filename": "src/test/mir-opt/lower_array_len_e2e.array_bound.PreCodegen.after.mir", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -7,9 +7,8 @@ fn array_bound(_1: usize, _2: &[u8; N]) -> u8 {\n     let mut _3: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n     let mut _4: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:13\n     let mut _5: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-    let _6: usize;                       // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-    let mut _7: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let mut _8: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+    let mut _6: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+    let mut _7: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n@@ -24,16 +23,13 @@ fn array_bound(_1: usize, _2: &[u8; N]) -> u8 {\n     }\n \n     bb1: {\n-        StorageLive(_6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-        _6 = _1;                         // scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-        _7 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        _8 = Lt(_6, _7);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        assert(move _8, \"index out of bounds: the length is {} but the index is {}\", move _7, _6) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        _6 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        _7 = Lt(_1, _6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, _1) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n     }\n \n     bb2: {\n-        _0 = (*_2)[_6];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        StorageDead(_6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+3:5: +3:6\n+        _0 = (*_2)[_1];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n         goto -> bb4;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +5:6\n     }\n "}, {"sha": "29e379777b05894b824527199ce3f90e331c1938", "filename": "src/test/mir-opt/lower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -7,12 +7,11 @@ fn array_bound_mut(_1: usize, _2: &mut [u8; N]) -> u8 {\n     let mut _3: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n     let mut _4: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:13\n     let mut _5: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-    let _6: usize;                       // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-    let mut _7: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let mut _8: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let _9: usize;                       // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-    let mut _10: usize;                  // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-    let mut _11: bool;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n+    let mut _6: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+    let mut _7: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+    let _8: usize;                       // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n+    let mut _9: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n+    let mut _10: bool;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n@@ -27,30 +26,27 @@ fn array_bound_mut(_1: usize, _2: &mut [u8; N]) -> u8 {\n     }\n \n     bb1: {\n-        StorageLive(_6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-        _6 = _1;                         // scope 0 at $DIR/lower_array_len_e2e.rs:+2:15: +2:20\n-        _7 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        _8 = Lt(_6, _7);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        assert(move _8, \"index out of bounds: the length is {} but the index is {}\", move _7, _6) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        _6 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        _7 = Lt(_1, _6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n+        assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, _1) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n     }\n \n     bb2: {\n-        _0 = (*_2)[_6];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        StorageDead(_6);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+3:5: +3:6\n+        _0 = (*_2)[_1];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n         goto -> bb5;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +7:6\n     }\n \n     bb3: {\n-        StorageLive(_9);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-        _9 = const 0_usize;              // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-        _10 = const N;                   // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-        _11 = Lt(const 0_usize, _10);    // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-        assert(move _11, \"index out of bounds: the length is {} but the index is {}\", move _10, const 0_usize) -> bb4; // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n+        StorageLive(_8);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n+        _8 = const 0_usize;              // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n+        _9 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n+        _10 = Lt(const 0_usize, _9);     // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n+        assert(move _10, \"index out of bounds: the length is {} but the index is {}\", move _9, const 0_usize) -> bb4; // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n     }\n \n     bb4: {\n-        (*_2)[_9] = const 42_u8;         // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:22\n-        StorageDead(_9);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:22: +4:23\n+        (*_2)[_8] = const 42_u8;         // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:22\n+        StorageDead(_8);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:22: +4:23\n         _0 = const 42_u8;                // scope 0 at $DIR/lower_array_len_e2e.rs:+6:9: +6:11\n         goto -> bb5;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +7:6\n     }"}, {"sha": "b672e1a6e63973928c236b93de24a733c0dd13d4", "filename": "src/test/mir-opt/lower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -6,23 +6,20 @@ fn f_unit() -> () {\n     scope 1 (inlined f_dispatch::<()>) { // at $DIR/lower_intrinsics_e2e.rs:9:5: 9:19\n         debug t => _1;                   // in scope 1 at $DIR/lower_intrinsics_e2e.rs:19:22: 19:23\n         let _2: ();                      // in scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n-        let mut _3: ();                  // in scope 1 at $DIR/lower_intrinsics_e2e.rs:21:15: 21:16\n         scope 2 (inlined std::mem::size_of::<()>) { // at $DIR/lower_intrinsics_e2e.rs:20:8: 20:32\n         }\n     }\n \n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:16: +1:18\n         StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n-        StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:15: 21:16\n-        _2 = f_zst::<()>(move _3) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n+        _2 = f_zst::<()>(move _1) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n                                          // mir::Constant\n                                          // + span: $DIR/lower_intrinsics_e2e.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(()) {f_zst::<()>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:16: 21:17\n         StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:17: 21:18\n         StorageDead(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:18: +1:19\n         return;                          // scope 0 at $DIR/lower_intrinsics_e2e.rs:+2:2: +2:2"}, {"sha": "30185f3ffab29ab55a634ce5eaec34e5ace56b52", "filename": "src/test/mir-opt/try_identity_e2e.new.PreCodegen.after.mir", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -3,77 +3,56 @@\n fn new(_1: Result<T, E>) -> Result<T, E> {\n     debug x => _1;                       // in scope 0 at $DIR/try_identity_e2e.rs:+0:14: +0:15\n     let mut _0: std::result::Result<T, E>; // return place in scope 0 at $DIR/try_identity_e2e.rs:+0:34: +0:46\n-    let mut _2: T;                       // in scope 0 at $DIR/try_identity_e2e.rs:+2:9: +10:10\n-    let mut _3: std::ops::ControlFlow<E, T>; // in scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-    let mut _4: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:22\n-    let _5: T;                           // in scope 0 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n-    let mut _6: T;                       // in scope 0 at $DIR/try_identity_e2e.rs:+4:48: +4:49\n-    let _7: E;                           // in scope 0 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n-    let mut _8: E;                       // in scope 0 at $DIR/try_identity_e2e.rs:+5:46: +5:47\n-    let mut _9: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+8:13: +8:37\n-    let _10: T;                          // in scope 0 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n-    let _11: E;                          // in scope 0 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n-    let mut _12: E;                      // in scope 0 at $DIR/try_identity_e2e.rs:+9:49: +9:50\n+    let mut _2: std::ops::ControlFlow<E, T>; // in scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n+    let mut _3: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:22\n+    let mut _4: T;                       // in scope 0 at $DIR/try_identity_e2e.rs:+4:48: +4:49\n+    let mut _5: E;                       // in scope 0 at $DIR/try_identity_e2e.rs:+5:46: +5:47\n+    let mut _6: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+8:13: +8:37\n+    let _7: T;                           // in scope 0 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n+    let mut _8: E;                       // in scope 0 at $DIR/try_identity_e2e.rs:+9:49: +9:50\n     scope 1 {\n-        debug v => _5;                   // in scope 1 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n+        debug v => _4;                   // in scope 1 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n     }\n     scope 2 {\n-        debug e => _7;                   // in scope 2 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n+        debug e => _5;                   // in scope 2 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n     }\n     scope 3 {\n-        debug v => _10;                  // in scope 3 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n+        debug v => _7;                   // in scope 3 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n     }\n     scope 4 {\n-        debug e => _11;                  // in scope 4 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n+        debug e => _8;                   // in scope 4 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +10:10\n-        StorageLive(_3);                 // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-        _4 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+3:19: +3:20\n-        switchInt(move _4) -> [0_isize: bb2, 1_isize: bb1, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:20\n+        StorageLive(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n+        _3 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+3:19: +3:20\n+        switchInt(move _3) -> [0_isize: bb2, 1_isize: bb1, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:20\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 0 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n-        _7 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n-        StorageLive(_8);                 // scope 2 at $DIR/try_identity_e2e.rs:+5:46: +5:47\n-        _8 = move _7;                    // scope 2 at $DIR/try_identity_e2e.rs:+5:46: +5:47\n-        Deinit(_3);                      // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n-        ((_3 as Break).0: E) = move _8;  // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n-        discriminant(_3) = 1;            // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n-        StorageDead(_8);                 // scope 2 at $DIR/try_identity_e2e.rs:+5:47: +5:48\n-        StorageDead(_7);                 // scope 0 at $DIR/try_identity_e2e.rs:+5:47: +5:48\n-        _9 = discriminant(_3);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-        switchInt(move _9) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n+        _5 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity_e2e.rs:+5:21: +5:22\n+        Deinit(_2);                      // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n+        ((_2 as Break).0: E) = move _5;  // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n+        discriminant(_2) = 1;            // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n+        _6 = discriminant(_2);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n+        switchInt(move _6) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n     }\n \n     bb2: {\n-        StorageLive(_5);                 // scope 0 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n-        _5 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n-        StorageLive(_6);                 // scope 1 at $DIR/try_identity_e2e.rs:+4:48: +4:49\n-        _6 = move _5;                    // scope 1 at $DIR/try_identity_e2e.rs:+4:48: +4:49\n-        Deinit(_3);                      // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n-        ((_3 as Continue).0: T) = move _6; // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n-        discriminant(_3) = 0;            // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n-        StorageDead(_6);                 // scope 1 at $DIR/try_identity_e2e.rs:+4:49: +4:50\n-        StorageDead(_5);                 // scope 0 at $DIR/try_identity_e2e.rs:+4:49: +4:50\n-        _9 = discriminant(_3);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-        switchInt(move _9) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n+        _4 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity_e2e.rs:+4:20: +4:21\n+        Deinit(_2);                      // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n+        ((_2 as Continue).0: T) = move _4; // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n+        discriminant(_2) = 0;            // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n+        _6 = discriminant(_2);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n+        switchInt(move _6) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n     }\n \n     bb3: {\n-        StorageLive(_11);                // scope 0 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n-        _11 = move ((_3 as Break).0: E); // scope 0 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n-        StorageLive(_12);                // scope 4 at $DIR/try_identity_e2e.rs:+9:49: +9:50\n-        _12 = move _11;                  // scope 4 at $DIR/try_identity_e2e.rs:+9:49: +9:50\n+        _8 = move ((_2 as Break).0: E);  // scope 0 at $DIR/try_identity_e2e.rs:+9:32: +9:33\n         Deinit(_0);                      // scope 4 at $DIR/try_identity_e2e.rs:+9:45: +9:51\n-        ((_0 as Err).0: E) = move _12;   // scope 4 at $DIR/try_identity_e2e.rs:+9:45: +9:51\n+        ((_0 as Err).0: E) = move _8;    // scope 4 at $DIR/try_identity_e2e.rs:+9:45: +9:51\n         discriminant(_0) = 1;            // scope 4 at $DIR/try_identity_e2e.rs:+9:45: +9:51\n-        StorageDead(_12);                // scope 4 at $DIR/try_identity_e2e.rs:+9:50: +9:51\n-        StorageDead(_11);                // scope 0 at $DIR/try_identity_e2e.rs:+9:50: +9:51\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+11:5: +11:6\n-        StorageDead(_3);                 // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n+        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n         return;                          // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n     }\n \n@@ -82,15 +61,11 @@ fn new(_1: Result<T, E>) -> Result<T, E> {\n     }\n \n     bb5: {\n-        StorageLive(_10);                // scope 0 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n-        _10 = move ((_3 as Continue).0: T); // scope 0 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n-        _2 = move _10;                   // scope 3 at $DIR/try_identity_e2e.rs:+8:41: +8:42\n-        StorageDead(_10);                // scope 0 at $DIR/try_identity_e2e.rs:+8:41: +8:42\n+        _7 = move ((_2 as Continue).0: T); // scope 0 at $DIR/try_identity_e2e.rs:+8:35: +8:36\n         Deinit(_0);                      // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +11:6\n-        ((_0 as Ok).0: T) = move _2;     // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +11:6\n+        ((_0 as Ok).0: T) = move _7;     // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +11:6\n         discriminant(_0) = 0;            // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +11:6\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+11:5: +11:6\n-        StorageDead(_3);                 // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n+        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n         return;                          // scope 0 at $DIR/try_identity_e2e.rs:+12:1: +12:2\n     }\n }"}, {"sha": "2a9c7408c66eb4a36bb7181df80d4cf8d01000f8", "filename": "src/test/mir-opt/try_identity_e2e.old.PreCodegen.after.mir", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -3,35 +3,26 @@\n fn old(_1: Result<T, E>) -> Result<T, E> {\n     debug x => _1;                       // in scope 0 at $DIR/try_identity_e2e.rs:+0:14: +0:15\n     let mut _0: std::result::Result<T, E>; // return place in scope 0 at $DIR/try_identity_e2e.rs:+0:34: +0:46\n-    let mut _2: T;                       // in scope 0 at $DIR/try_identity_e2e.rs:+2:9: +5:10\n-    let mut _3: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:18\n-    let _4: T;                           // in scope 0 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n-    let _5: E;                           // in scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n-    let mut _6: E;                       // in scope 0 at $DIR/try_identity_e2e.rs:+4:34: +4:35\n+    let mut _2: isize;                   // in scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:18\n+    let _3: T;                           // in scope 0 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n+    let mut _4: E;                       // in scope 0 at $DIR/try_identity_e2e.rs:+4:34: +4:35\n     scope 1 {\n-        debug v => _4;                   // in scope 1 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n+        debug v => _3;                   // in scope 1 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n     }\n     scope 2 {\n-        debug e => _5;                   // in scope 2 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n+        debug e => _4;                   // in scope 2 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +5:10\n-        _3 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +2:16\n-        switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +2:16\n+        _2 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +2:16\n+        switchInt(move _2) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +2:16\n     }\n \n     bb1: {\n-        StorageLive(_5);                 // scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n-        _5 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n-        StorageLive(_6);                 // scope 2 at $DIR/try_identity_e2e.rs:+4:34: +4:35\n-        _6 = move _5;                    // scope 2 at $DIR/try_identity_e2e.rs:+4:34: +4:35\n+        _4 = move ((_1 as Err).0: E);    // scope 0 at $DIR/try_identity_e2e.rs:+4:17: +4:18\n         Deinit(_0);                      // scope 2 at $DIR/try_identity_e2e.rs:+4:30: +4:36\n-        ((_0 as Err).0: E) = move _6;    // scope 2 at $DIR/try_identity_e2e.rs:+4:30: +4:36\n+        ((_0 as Err).0: E) = move _4;    // scope 2 at $DIR/try_identity_e2e.rs:+4:30: +4:36\n         discriminant(_0) = 1;            // scope 2 at $DIR/try_identity_e2e.rs:+4:30: +4:36\n-        StorageDead(_6);                 // scope 2 at $DIR/try_identity_e2e.rs:+4:35: +4:36\n-        StorageDead(_5);                 // scope 0 at $DIR/try_identity_e2e.rs:+4:35: +4:36\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+6:5: +6:6\n         return;                          // scope 0 at $DIR/try_identity_e2e.rs:+7:1: +7:2\n     }\n \n@@ -40,14 +31,10 @@ fn old(_1: Result<T, E>) -> Result<T, E> {\n     }\n \n     bb3: {\n-        StorageLive(_4);                 // scope 0 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n-        _4 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n-        _2 = move _4;                    // scope 1 at $DIR/try_identity_e2e.rs:+3:22: +3:23\n-        StorageDead(_4);                 // scope 0 at $DIR/try_identity_e2e.rs:+3:22: +3:23\n+        _3 = move ((_1 as Ok).0: T);     // scope 0 at $DIR/try_identity_e2e.rs:+3:16: +3:17\n         Deinit(_0);                      // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +6:6\n-        ((_0 as Ok).0: T) = move _2;     // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +6:6\n+        ((_0 as Ok).0: T) = move _3;     // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +6:6\n         discriminant(_0) = 0;            // scope 0 at $DIR/try_identity_e2e.rs:+1:5: +6:6\n-        StorageDead(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+6:5: +6:6\n         return;                          // scope 0 at $DIR/try_identity_e2e.rs:+7:1: +7:2\n     }\n }"}, {"sha": "0c5452475a6575a7c89ffd41949a8f6d6f9588fd", "filename": "src/test/ui/async-await/large_moves.attribute.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.attribute.stderr?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,5 +1,5 @@\n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:12:13\n+  --> $DIR/large_moves.rs:13:13\n    |\n LL |       let x = async {\n    |  _____________^\n@@ -18,23 +18,23 @@ LL | #![deny(large_assignments)]\n    |         ^^^^^^^^^^^^^^^^^\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:18:14\n+  --> $DIR/large_moves.rs:19:14\n    |\n LL |     let z = (x, 42);\n    |              ^ value moved from here\n    |\n    = note: The current maximum size is 1000, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:18:13\n+  --> $DIR/large_moves.rs:19:13\n    |\n LL |     let z = (x, 42);\n    |             ^^^^^^^ value moved from here\n    |\n    = note: The current maximum size is 1000, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:20:13\n+  --> $DIR/large_moves.rs:21:13\n    |\n LL |     let a = z.0;\n    |             ^^^ value moved from here"}, {"sha": "0c5452475a6575a7c89ffd41949a8f6d6f9588fd", "filename": "src/test/ui/async-await/large_moves.option.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.option.stderr?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -1,5 +1,5 @@\n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:12:13\n+  --> $DIR/large_moves.rs:13:13\n    |\n LL |       let x = async {\n    |  _____________^\n@@ -18,23 +18,23 @@ LL | #![deny(large_assignments)]\n    |         ^^^^^^^^^^^^^^^^^\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:18:14\n+  --> $DIR/large_moves.rs:19:14\n    |\n LL |     let z = (x, 42);\n    |              ^ value moved from here\n    |\n    = note: The current maximum size is 1000, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:18:13\n+  --> $DIR/large_moves.rs:19:13\n    |\n LL |     let z = (x, 42);\n    |             ^^^^^^^ value moved from here\n    |\n    = note: The current maximum size is 1000, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n error: moving 10024 bytes\n-  --> $DIR/large_moves.rs:20:13\n+  --> $DIR/large_moves.rs:21:13\n    |\n LL |     let a = z.0;\n    |             ^^^ value moved from here"}, {"sha": "d43d0eec0cabca1ae3c2361439ede47baf67b59c", "filename": "src/test/ui/async-await/large_moves.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9eee68111ec742c3d60bb96078994c494a59fb/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Flarge_moves.rs?ref=0e9eee68111ec742c3d60bb96078994c494a59fb", "patch": "@@ -7,6 +7,7 @@\n // [option]compile-flags: -Zmove-size-limit=1000\n \n // edition:2018\n+// compile-flags: -Zmir-opt-level=0\n \n fn main() {\n     let x = async { //~ ERROR large_assignments"}]}