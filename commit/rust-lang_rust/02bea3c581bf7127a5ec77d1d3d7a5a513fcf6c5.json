{"sha": "02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYmVhM2M1ODFiZjcxMjdhNWVjNzdkMWQzZDdhNWE1MTNmY2Y2YzU=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-08-07T15:10:05Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-09-20T10:42:20Z"}, "message": "rustdoc: collect trait impls as an early pass", "tree": {"sha": "6b1c899db0ea604db26cea4da42be4627db22c1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b1c899db0ea604db26cea4da42be4627db22c1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "html_url": "https://github.com/rust-lang/rust/commit/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "992d1e4d3de364c895963167b70934599574d9a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/992d1e4d3de364c895963167b70934599574d9a7", "html_url": "https://github.com/rust-lang/rust/commit/992d1e4d3de364c895963167b70934599574d9a7"}], "stats": {"total": 219, "additions": 137, "deletions": 82}, "files": [{"sha": "684063beac30e61ed93a3bbb6727521278e1dbd4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 73, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -291,78 +291,12 @@ pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean:\n         impls.extend(get_blanket_impls_with_def_id(cx, did));\n     }\n \n-    // If this is the first time we've inlined something from another crate, then\n-    // we inline *all* impls from all the crates into this crate. Note that there's\n-    // currently no way for us to filter this based on type, and we likely need\n-    // many impls for a variety of reasons.\n-    //\n-    // Primarily, the impls will be used to populate the documentation for this\n-    // type being inlined, but impls can also be used when generating\n-    // documentation for primitives (no way to find those specifically).\n-    if cx.populated_all_crate_impls.get() {\n-        return impls;\n-    }\n-\n-    cx.populated_all_crate_impls.set(true);\n-\n-    for &cnum in tcx.crates().iter() {\n-        for did in tcx.all_trait_implementations(cnum).iter() {\n-            build_impl(cx, *did, &mut impls);\n-        }\n-    }\n-\n-    // Also try to inline primitive impls from other crates.\n-    let lang_items = tcx.lang_items();\n-    let primitive_impls = [\n-        lang_items.isize_impl(),\n-        lang_items.i8_impl(),\n-        lang_items.i16_impl(),\n-        lang_items.i32_impl(),\n-        lang_items.i64_impl(),\n-        lang_items.i128_impl(),\n-        lang_items.usize_impl(),\n-        lang_items.u8_impl(),\n-        lang_items.u16_impl(),\n-        lang_items.u32_impl(),\n-        lang_items.u64_impl(),\n-        lang_items.u128_impl(),\n-        lang_items.f32_impl(),\n-        lang_items.f64_impl(),\n-        lang_items.f32_runtime_impl(),\n-        lang_items.f64_runtime_impl(),\n-        lang_items.char_impl(),\n-        lang_items.str_impl(),\n-        lang_items.slice_impl(),\n-        lang_items.slice_u8_impl(),\n-        lang_items.str_alloc_impl(),\n-        lang_items.slice_alloc_impl(),\n-        lang_items.slice_u8_alloc_impl(),\n-        lang_items.const_ptr_impl(),\n-        lang_items.mut_ptr_impl(),\n-    ];\n-\n-    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n-        if !def_id.is_local() {\n-            build_impl(cx, def_id, &mut impls);\n-\n-            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n-            let mut renderinfo = cx.renderinfo.borrow_mut();\n-\n-            let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-                .chain(blanket_impls.into_iter())\n-                .filter(|i| renderinfo.inlined.insert(i.def_id))\n-                .collect();\n-\n-            impls.extend(new_impls);\n-        }\n-    }\n-\n     impls\n }\n \n pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n+        debug!(\"already inlined, bailing: {:?}\", did);\n         return\n     }\n \n@@ -372,19 +306,25 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation\n-    if let Some(traitref) = associated_trait {\n-        if !cx.access_levels.borrow().is_doc_reachable(traitref.def_id) {\n-            return\n+    if !did.is_local() {\n+        if let Some(traitref) = associated_trait {\n+            if !cx.access_levels.borrow().is_doc_reachable(traitref.def_id) {\n+                debug!(\"trait {:?} not reachable, bailing: {:?}\", traitref.def_id, did);\n+                return\n+            }\n         }\n     }\n \n     let for_ = tcx.type_of(did).clean(cx);\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n-    if let Some(did) = for_.def_id() {\n-        if !cx.access_levels.borrow().is_doc_reachable(did) {\n-            return\n+    if !did.is_local() {\n+        if let Some(did) = for_.def_id() {\n+            if !cx.access_levels.borrow().is_doc_reachable(did) {\n+                debug!(\"impl type {:?} not accessible, bailing\", did);\n+                return\n+            }\n         }\n     }\n "}, {"sha": "d7e087fd624590f7e08066408ede5335f602e7f8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -37,7 +37,7 @@ use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::RefCell;\n use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n use std::rc::Rc;\n@@ -60,7 +60,6 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     /// The stack of module NodeIds up till this point\n     pub crate_name: Option<String>,\n     pub cstore: Rc<CStore>,\n-    pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -514,7 +513,6 @@ pub fn run_core(search_paths: SearchPaths,\n                 resolver: &resolver,\n                 crate_name,\n                 cstore: cstore.clone(),\n-                populated_all_crate_impls: Cell::new(false),\n                 access_levels: RefCell::new(access_levels),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),"}, {"sha": "0be5ab07dea76ccfa891b4ab7360ef5619318567", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean::*;\n+\n+use super::Pass;\n+use core::DocContext;\n+\n+pub const COLLECT_TRAIT_IMPLS: Pass =\n+    Pass::early(\"collect-trait-impls\", collect_trait_impls,\n+                \"retrieves trait impls for items in the crate\");\n+\n+pub fn collect_trait_impls(mut krate: Crate, cx: &DocContext) -> Crate {\n+    if let Some(ref mut it) = krate.module {\n+        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n+            for &cnum in cx.tcx.crates().iter() {\n+                for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n+                    inline::build_impl(cx, did, items);\n+                }\n+            }\n+\n+            // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n+            // doesn't work with it anyway, so pull them from the HIR map instead\n+            for &trait_did in cx.all_traits.iter() {\n+                for &impl_node in cx.tcx.hir.trait_impls(trait_did) {\n+                    let impl_did = cx.tcx.hir.local_def_id(impl_node);\n+                    inline::build_impl(cx, impl_did, items);\n+                }\n+            }\n+\n+            // Also try to inline primitive impls from other crates.\n+            let lang_items = cx.tcx.lang_items();\n+            let primitive_impls = [\n+                lang_items.isize_impl(),\n+                lang_items.i8_impl(),\n+                lang_items.i16_impl(),\n+                lang_items.i32_impl(),\n+                lang_items.i64_impl(),\n+                lang_items.i128_impl(),\n+                lang_items.usize_impl(),\n+                lang_items.u8_impl(),\n+                lang_items.u16_impl(),\n+                lang_items.u32_impl(),\n+                lang_items.u64_impl(),\n+                lang_items.u128_impl(),\n+                lang_items.f32_impl(),\n+                lang_items.f64_impl(),\n+                lang_items.f32_runtime_impl(),\n+                lang_items.f64_runtime_impl(),\n+                lang_items.char_impl(),\n+                lang_items.str_impl(),\n+                lang_items.slice_impl(),\n+                lang_items.slice_u8_impl(),\n+                lang_items.str_alloc_impl(),\n+                lang_items.slice_alloc_impl(),\n+                lang_items.slice_u8_alloc_impl(),\n+                lang_items.const_ptr_impl(),\n+                lang_items.mut_ptr_impl(),\n+            ];\n+\n+            for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+                if !def_id.is_local() {\n+                    inline::build_impl(cx, def_id, items);\n+\n+                    let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+                    let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n+                    let mut renderinfo = cx.renderinfo.borrow_mut();\n+\n+                    let new_impls: Vec<Item> = auto_impls.into_iter()\n+                        .chain(blanket_impls.into_iter())\n+                        .filter(|i| renderinfo.inlined.insert(i.def_id))\n+                        .collect();\n+\n+                    items.extend(new_impls);\n+                }\n+            }\n+        } else {\n+            panic!(\"collect-trait-impls can't run\");\n+        }\n+    } else {\n+        panic!(\"collect-trait-impls can't run\");\n+    }\n+\n+    // pulling in the impls puts their trait info into the DocContext, but that's already been\n+    // drained by now, so stuff that info into the Crate so the rendering can pick it up\n+    let mut external_traits = cx.external_traits.borrow_mut();\n+    for (did, trait_) in external_traits.drain() {\n+        krate.external_traits.entry(did).or_insert(trait_);\n+    }\n+\n+    krate\n+}"}, {"sha": "09281aa7cfaf46864234ca7ed13504cc5981c1b0", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -43,6 +43,9 @@ pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n mod collect_intra_doc_links;\n pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n+mod collect_trait_impls;\n+pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+\n /// Represents a single pass.\n #[derive(Copy, Clone)]\n pub enum Pass {\n@@ -132,10 +135,12 @@ pub const PASSES: &'static [Pass] = &[\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n     COLLECT_INTRA_DOC_LINKS,\n+    COLLECT_TRAIT_IMPLS,\n ];\n \n /// The list of passes run by default.\n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collect-intra-doc-links\",\n@@ -146,6 +151,7 @@ pub const DEFAULT_PASSES: &'static [&'static str] = &[\n \n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n     \"strip-priv-imports\",\n     \"collect-intra-doc-links\",\n     \"collapse-docs\","}, {"sha": "a1942a966b117aa2ee96f580841b35611da32886", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -510,9 +510,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                           ref tr,\n                           ref ty,\n                           ref item_ids) => {\n-                // Don't duplicate impls when inlining, we'll pick them up\n-                // regardless of where they're located.\n-                if !self.inlining {\n+                // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n+                // them up regardless of where they're located.\n+                if !self.inlining && tr.is_none() {\n                     let items = item_ids.iter()\n                                         .map(|ii| self.cx.tcx.hir.impl_item(ii.id).clone())\n                                         .collect();"}, {"sha": "26ed5444122753709b90b1aac6441f6f46554d75", "filename": "src/test/rustdoc/traits-in-bodies.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs?ref=02bea3c581bf7127a5ec77d1d3d7a5a513fcf6c5", "patch": "@@ -11,11 +11,10 @@\n //prior to fixing `everybody_loops` to preserve items, rustdoc would crash on this file, as it\n //didn't see that `SomeStruct` implemented `Clone`\n \n-//FIXME(misdreavus): whenever rustdoc shows traits impl'd inside bodies, make sure this test\n-//reflects that\n-\n pub struct Bounded<T: Clone>(T);\n \n+// @has traits_in_bodies/struct.SomeStruct.html\n+// @has - '//code' 'impl Clone for SomeStruct'\n pub struct SomeStruct;\n \n fn asdf() -> Bounded<SomeStruct> {\n@@ -27,3 +26,16 @@ fn asdf() -> Bounded<SomeStruct> {\n \n     Bounded(SomeStruct)\n }\n+\n+// @has traits_in_bodies/struct.Point.html\n+// @has - '//code' 'impl Copy for Point'\n+#[derive(Clone)]\n+pub struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+const _FOO: () = {\n+    impl Copy for Point {}\n+    ()\n+};"}]}