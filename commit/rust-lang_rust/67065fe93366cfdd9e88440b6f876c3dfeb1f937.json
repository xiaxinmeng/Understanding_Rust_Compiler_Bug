{"sha": "67065fe93366cfdd9e88440b6f876c3dfeb1f937", "node_id": "C_kwDOAAsO6NoAKDY3MDY1ZmU5MzM2NmNmZGQ5ZTg4NDQwYjZmODc2YzNkZmViMWY5Mzc", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-08-25T09:45:08Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-09-25T18:04:35Z"}, "message": "Apply 16 commits (squashed)\n\n----------\n\nFix spacing for links inside code blocks, and improve link tooltips in alloc::fmt\n\n----------\n\nFix spacing for links inside code blocks, and improve link tooltips in alloc::{rc, sync}\n\n----------\n\nFix spacing for links inside code blocks, and improve link tooltips in alloc::string\n\n----------\n\nFix spacing for links inside code blocks in alloc::vec\n\n----------\n\nFix spacing for links inside code blocks in core::option\n\n----------\n\nFix spacing for links inside code blocks, and improve a few link tooltips in core::result\n\n----------\n\nFix spacing for links inside code blocks in core::{iter::{self, iterator}, stream::stream, poll}\n\n----------\n\nFix spacing for links inside code blocks, and improve a few link tooltips in std::{fs, path}\n\n----------\n\nFix spacing for links inside code blocks in std::{collections, time}\n\n----------\n\nFix spacing for links inside code blocks in and make formatting of `&str`-like types consistent in std::ffi::{c_str, os_str}\n\n----------\n\nFix spacing for links inside code blocks, and improve link tooltips in std::ffi\n\n----------\n\nFix spacing for links inside code blocks, and improve a few link tooltips\nin std::{io::{self, buffered::{bufreader, bufwriter}, cursor, util}, net::{self, addr}}\n\n----------\n\nFix typo in link to `into` for `OsString` docs\n\n----------\n\nRemove tooltips that will probably become redundant in the future\n\n----------\n\nApply suggestions from code review\n\nReplacing `\u2026std/primitive.reference.html` paths with just `reference`\n\nCo-authored-by: Joshua Nelson <github@jyn.dev>\n\n----------\n\nAlso replace `\u2026std/primitive.reference.html` paths with just `reference` in `core::pin`", "tree": {"sha": "fb8460edb7dcc220b5ea267e4d5e6f4b8b8c1450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb8460edb7dcc220b5ea267e4d5e6f4b8b8c1450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67065fe93366cfdd9e88440b6f876c3dfeb1f937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67065fe93366cfdd9e88440b6f876c3dfeb1f937", "html_url": "https://github.com/rust-lang/rust/commit/67065fe93366cfdd9e88440b6f876c3dfeb1f937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67065fe93366cfdd9e88440b6f876c3dfeb1f937/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b0e554ee2c94e9b3865a8c2d24d720224512dec", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0e554ee2c94e9b3865a8c2d24d720224512dec", "html_url": "https://github.com/rust-lang/rust/commit/7b0e554ee2c94e9b3865a8c2d24d720224512dec"}], "stats": {"total": 461, "additions": 226, "deletions": 235}, "files": [{"sha": "878d8dc5502df8d552dc4bed84165ad592876d33", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -348,7 +348,7 @@\n //! provides some helper methods.\n //!\n //! Additionally, the return value of this function is [`fmt::Result`] which is a\n-//! type alias of [`Result`]`<(), `[`std::fmt::Error`]`>`. Formatting implementations\n+//! type alias of <code>[Result]<(), [std::fmt::Error]></code>. Formatting implementations\n //! should ensure that they propagate errors from the [`Formatter`] (e.g., when\n //! calling [`write!`]). However, they should never return errors spuriously. That\n //! is, a formatting implementation must and may only return an error if the\n@@ -505,23 +505,19 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! [`fmt::Result`]: Result\n-//! [`Result`]: core::result::Result\n-//! [`std::fmt::Error`]: Error\n-//! [`write!`]: core::write\n-//! [`write`]: core::write\n-//! [`format!`]: crate::format\n-//! [`to_string`]: crate::string::ToString\n-//! [`writeln!`]: core::writeln\n+//! [`fmt::Result`]: Result \"fmt::Result\"\n+//! [Result]: core::result::Result \"std::result::Result\"\n+//! [std::fmt::Error]: Error \"fmt::Error\"\n+//! [`write`]: write() \"fmt::write\"\n+//! [`to_string`]: crate::string::ToString::to_string \"ToString::to_string\"\n //! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n //! [`std::io::Write`]: ../../std/io/trait.Write.html\n-//! [`print!`]: ../../std/macro.print.html\n-//! [`println!`]: ../../std/macro.println.html\n-//! [`eprint!`]: ../../std/macro.eprint.html\n-//! [`eprintln!`]: ../../std/macro.eprintln.html\n-//! [`format_args!`]: core::format_args\n-//! [`fmt::Arguments`]: Arguments\n-//! [`format`]: crate::format\n+//! [`print!`]: ../../std/macro.print.html \"print!\"\n+//! [`println!`]: ../../std/macro.println.html \"println!\"\n+//! [`eprint!`]: ../../std/macro.eprint.html \"eprint!\"\n+//! [`eprintln!`]: ../../std/macro.eprintln.html \"eprintln!\"\n+//! [`fmt::Arguments`]: Arguments \"fmt::Arguments\"\n+//! [`format`]: format() \"fmt::format\"\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "3648271c6205b6832259fb47ae636f008c9bc2bc", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -781,9 +781,7 @@ impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n-    /// [`Rc::from_raw`][from_raw].\n-    ///\n-    /// [from_raw]: Rc::from_raw\n+    /// [`Rc::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -834,7 +832,7 @@ impl<T: ?Sized> Rc<T> {\n     /// and alignment as `T`. This is trivially true if `U` is `T`.\n     /// Note that if `U` is not `T` but has the same size and alignment, this is\n     /// basically like transmuting references of different types. See\n-    /// [`mem::transmute`][transmute] for more information on what\n+    /// [`mem::transmute`] for more information on what\n     /// restrictions apply in this case.\n     ///\n     /// The user of `from_raw` has to make sure a specific value of `T` is only\n@@ -844,7 +842,6 @@ impl<T: ?Sized> Rc<T> {\n     /// even if the returned `Rc<T>` is never accessed.\n     ///\n     /// [into_raw]: Rc::into_raw\n-    /// [transmute]: core::mem::transmute\n     ///\n     /// # Examples\n     ///\n@@ -1086,8 +1083,6 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n-    ///\n-    /// [`ptr::eq`]: core::ptr::eq\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1993,7 +1988,7 @@ impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n-/// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n+/// pointer, which returns an <code>[Option]<[Rc]\\<T>></code>.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n /// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n@@ -2090,7 +2085,7 @@ impl<T: ?Sized> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: core::ptr::null\n+    /// [`null`]: ptr::null\n     #[stable(feature = \"rc_as_ptr\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n@@ -2317,8 +2312,6 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n-    ///\n-    /// [`ptr::eq`]: core::ptr::eq\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -2400,7 +2393,6 @@ impl<T> Default for Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`None`]: Option\n     /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples"}, {"sha": "57c38f2c0a9c5ef0eb153ce32b48ae94c67b95cb", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -79,7 +79,7 @@ use crate::vec::Vec;\n ///\n /// # Examples\n ///\n-/// You can create a `String` from [a literal string][`str`] with [`String::from`]:\n+/// You can create a `String` from [a literal string][`&str`] with [`String::from`]:\n ///\n /// [`String::from`]: From::from\n ///\n@@ -128,7 +128,7 @@ use crate::vec::Vec;\n /// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n /// ```\n ///\n-/// [`OsString`]: ../../std/ffi/struct.OsString.html\n+/// [`OsString`]: ../../std/ffi/struct.OsString.html \"ffi::OsString\"\n ///\n /// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n /// does not allow us to do this. Furthermore, it's not clear what sort of\n@@ -141,7 +141,7 @@ use crate::vec::Vec;\n ///\n /// # Deref\n ///\n-/// `String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\n+/// `String` implements <code>[Deref]<Target = [str]></code>, and so inherits all of [`str`]'s\n /// methods. In addition, this means that you can pass a `String` to a\n /// function which takes a [`&str`] by using an ampersand (`&`):\n ///\n@@ -182,7 +182,7 @@ use crate::vec::Vec;\n /// to explicitly extract the string slice containing the string. The second\n /// way changes `example_func(&example_string);` to\n /// `example_func(&*example_string);`. In this case we are dereferencing a\n-/// `String` to a [`str`][`&str`], then referencing the [`str`][`&str`] back to\n+/// `String` to a [`str`], then referencing the [`str`] back to\n /// [`&str`]. The second way is more idiomatic, however both work to do the\n /// conversion explicitly rather than relying on the implicit conversion.\n ///\n@@ -282,9 +282,11 @@ use crate::vec::Vec;\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n ///\n-/// [`str`]: prim@str\n-/// [`&str`]: prim@str\n-/// [`Deref`]: core::ops::Deref\n+/// [str]: prim@str \"str\"\n+/// [`str`]: prim@str \"str\"\n+/// [`&str`]: prim@str \"&str\"\n+/// [Deref]: core::ops::Deref \"ops::Deref\"\n+/// [`Deref`]: core::ops::Deref \"ops::Deref\"\n /// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"string_type\")]\n@@ -308,10 +310,10 @@ pub struct String {\n /// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n /// through the [`utf8_error`] method.\n ///\n-/// [`Utf8Error`]: core::str::Utf8Error\n-/// [`std::str`]: core::str\n-/// [`&str`]: prim@str\n-/// [`utf8_error`]: Self::utf8_error\n+/// [`Utf8Error`]: str::Utf8Error \"std::str::Utf8Error\"\n+/// [`std::str`]: core::str \"std::str\"\n+/// [`&str`]: prim@str \"&str\"\n+/// [`utf8_error`]: FromUtf8Error::utf8_error\n ///\n /// # Examples\n ///\n@@ -487,8 +489,8 @@ impl String {\n     /// with this error.\n     ///\n     /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n-    /// [`Vec<u8>`]: crate::vec::Vec\n-    /// [`&str`]: prim@str\n+    /// [`Vec<u8>`]: crate::vec::Vec \"Vec\"\n+    /// [`&str`]: prim@str \"&str\"\n     /// [`into_bytes`]: String::into_bytes\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -524,7 +526,7 @@ impl String {\n     /// it's already valid UTF-8, we don't need a new allocation. This return\n     /// type allows us to handle both cases.\n     ///\n-    /// [`Cow<'a, str>`]: crate::borrow::Cow\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow \"borrow::Cow\"\n     ///\n     /// # Examples\n     ///\n@@ -625,7 +627,7 @@ impl String {\n     /// conversion requires a memory allocation.\n     ///\n     /// [`from_utf8_lossy`]: String::from_utf8_lossy\n-    /// [`Cow<'a, str>`]: crate::borrow::Cow\n+    /// [`Cow<'a, str>`]: crate::borrow::Cow \"borrow::Cow\"\n     /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n@@ -1721,11 +1723,11 @@ impl String {\n         unsafe { self.as_mut_vec() }.splice((start, end), replace_with.bytes());\n     }\n \n-    /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n+    /// Converts this `String` into a <code>[Box]<[str]></code>.\n     ///\n     /// This will drop any excess capacity.\n     ///\n-    /// [`str`]: prim@str\n+    /// [str]: prim@str \"str\"\n     ///\n     /// # Examples\n     ///\n@@ -1795,8 +1797,8 @@ impl FromUtf8Error {\n     /// an analogue to `FromUtf8Error`. See its documentation for more details\n     /// on using it.\n     ///\n-    /// [`std::str`]: core::str\n-    /// [`&str`]: prim@str\n+    /// [`std::str`]: core::str \"std::str\"\n+    /// [`&str`]: prim@str \"&str\"\n     ///\n     /// # Examples\n     ///\n@@ -2319,7 +2321,7 @@ impl ops::DerefMut for String {\n ///\n /// This alias exists for backwards compatibility, and may be eventually deprecated.\n ///\n-/// [`Infallible`]: core::convert::Infallible\n+/// [`Infallible`]: core::convert::Infallible \"convert::Infallible\"\n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n pub type ParseError = core::convert::Infallible;\n \n@@ -2606,7 +2608,7 @@ impl<'a> From<&'a str> for Cow<'a, str> {\n     /// assert_eq!(Cow::from(\"eggplant\"), Cow::Borrowed(\"eggplant\"));\n     /// ```\n     ///\n-    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed \"borrow::Cow::Borrowed\"\n     #[inline]\n     fn from(s: &'a str) -> Cow<'a, str> {\n         Cow::Borrowed(s)\n@@ -2629,7 +2631,7 @@ impl<'a> From<String> for Cow<'a, str> {\n     /// assert_eq!(Cow::from(s), Cow::<'static, str>::Owned(s2));\n     /// ```\n     ///\n-    /// [`Owned`]: crate::borrow::Cow::Owned\n+    /// [`Owned`]: crate::borrow::Cow::Owned \"borrow::Cow::Owned\"\n     #[inline]\n     fn from(s: String) -> Cow<'a, str> {\n         Cow::Owned(s)\n@@ -2651,7 +2653,7 @@ impl<'a> From<&'a String> for Cow<'a, str> {\n     /// assert_eq!(Cow::from(&s), Cow::Borrowed(\"eggplant\"));\n     /// ```\n     ///\n-    /// [`Borrowed`]: crate::borrow::Cow::Borrowed\n+    /// [`Borrowed`]: crate::borrow::Cow::Borrowed \"borrow::Cow::Borrowed\"\n     #[inline]\n     fn from(s: &'a String) -> Cow<'a, str> {\n         Cow::Borrowed(s.as_str())"}, {"sha": "6e8da849e64cd464baf02714dc9d9f95a9fbaf6f", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -99,8 +99,8 @@ macro_rules! acquire {\n /// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n /// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n /// data, but it  doesn't add thread safety to its data. Consider\n-/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n-/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n+/// <code>Arc<[RefCell\\<T>]></code>. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n+/// [`Send`], <code>Arc<[RefCell\\<T>]></code> would be as well. But then we'd have a problem:\n /// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n /// non-atomic operations.\n ///\n@@ -176,6 +176,7 @@ macro_rules! acquire {\n /// [deref]: core::ops::Deref\n /// [downgrade]: Arc::downgrade\n /// [upgrade]: Weak::upgrade\n+/// [RefCell\\<T>]: core::cell::RefCell\n /// [`RefCell<T>`]: core::cell::RefCell\n /// [`std::sync`]: ../../std/sync/index.html\n /// [`Arc::clone(&from)`]: Arc::clone\n@@ -206,7 +207,7 @@ macro_rules! acquire {\n ///\n /// Sharing a mutable [`AtomicUsize`]:\n ///\n-/// [`AtomicUsize`]: core::sync::atomic::AtomicUsize\n+/// [`AtomicUsize`]: core::sync::atomic::AtomicUsize \"sync::atomic::AtomicUsize\"\n ///\n /// ```no_run\n /// use std::sync::Arc;\n@@ -262,7 +263,7 @@ impl<T: ?Sized> Arc<T> {\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n-/// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n+/// pointer, which returns an <code>[Option]<[Arc]\\<T>></code>.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n /// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n@@ -476,7 +477,7 @@ impl<T> Arc<T> {\n     /// assert_eq!(*zero, 0)\n     /// ```\n     ///\n-    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n@@ -684,7 +685,7 @@ impl<T> Arc<[T]> {\n     /// assert_eq!(*values, [0, 0, 0])\n     /// ```\n     ///\n-    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n@@ -712,7 +713,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n     ///\n-    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    /// [`MaybeUninit::assume_init`]: mem::MaybeUninit::assume_init\n     ///\n     /// # Examples\n     ///\n@@ -751,7 +752,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n     ///\n-    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    /// [`MaybeUninit::assume_init`]: mem::MaybeUninit::assume_init\n     ///\n     /// # Examples\n     ///\n@@ -1086,7 +1087,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: core::ptr::eq\n+    /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1714,7 +1715,7 @@ impl<T: ?Sized> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: core::ptr::null\n+    /// [`null`]: core::ptr::null \"ptr::null\"\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n@@ -1806,7 +1807,6 @@ impl<T: ?Sized> Weak<T> {\n     /// [`new`]: Weak::new\n     /// [`into_raw`]: Weak::into_raw\n     /// [`upgrade`]: Weak::upgrade\n-    /// [`forget`]: std::mem::forget\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         // See Weak::as_ptr for context on how the input pointer is derived.\n@@ -1982,7 +1982,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: core::ptr::eq\n+    /// [`ptr::eq`]: core::ptr::eq \"ptr::eq\"\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {"}, {"sha": "347750cc1645d433f7c2ebc04c1e9ce5c51d36f6", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -296,17 +296,17 @@ mod spec_extend;\n /// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n /// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n /// the `Vec` might not report a [`capacity`] of 0*. `Vec` will allocate if and only\n-/// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n-/// details are very subtle &mdash; if you intend to allocate memory using a `Vec`\n+/// if <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code>. In general, `Vec`'s allocation\n+/// details are very subtle --- if you intend to allocate memory using a `Vec`\n /// and use it for something else (either to pass to unsafe code, or to build your\n /// own memory-backed collection), be sure to deallocate this memory by using\n /// `from_raw_parts` to recover the `Vec` and then dropping it.\n ///\n /// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n /// pointer points to [`len`] initialized, contiguous elements in order (what\n-/// you would see if you coerced it to a slice), followed by [`capacity`]` -\n-/// `[`len`] logically uninitialized, contiguous elements.\n+/// you would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code>\n+/// logically uninitialized, contiguous elements.\n ///\n /// A vector containing the elements `'a'` and `'b'` with capacity 4 can be\n /// visualized as below. The top part is the `Vec` struct, it contains a\n@@ -348,7 +348,7 @@ mod spec_extend;\n ///\n /// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n /// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n-/// [`len`]` == `[`capacity`]. That is, the reported capacity is completely\n+/// <code>[len] == [capacity]</code>. That is, the reported capacity is completely\n /// accurate, and can be relied on. It can even be used to manually free the memory\n /// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n /// when not necessary.\n@@ -360,7 +360,7 @@ mod spec_extend;\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n /// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n-/// with exactly the requested capacity. If [`len`]` == `[`capacity`],\n+/// with exactly the requested capacity. If <code>[len] == [capacity]</code>,\n /// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n /// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n ///\n@@ -384,8 +384,10 @@ mod spec_extend;\n /// [`&str`]: type@str\n /// [`shrink_to_fit`]: Vec::shrink_to_fit\n /// [`shrink_to`]: Vec::shrink_to\n+/// [capacity]: Vec::capacity\n /// [`capacity`]: Vec::capacity\n-/// [`mem::size_of::<T>`]: core::mem::size_of\n+/// [mem::size_of::\\<T>]: core::mem::size_of\n+/// [len]: Vec::len\n /// [`len`]: Vec::len\n /// [`push`]: Vec::push\n /// [`insert`]: Vec::insert"}, {"sha": "19fb1825689032c92b57da83fad391b4d99dc5c9", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -39,7 +39,7 @@\n //! ```\n //!\n //! An iterator has a method, [`next`], which when called, returns an\n-//! [`Option`]`<Item>`. [`next`] will return [`Some(Item)`] as long as there\n+//! <code>[Option]\\<Item></code>. Calling [`next`] will return [`Some(Item)`] as long as there\n //! are elements, and once they've all been exhausted, will return `None` to\n //! indicate that iteration is finished. Individual iterators may choose to\n //! resume iteration, and so calling [`next`] again may or may not eventually"}, {"sha": "d1f4b9b194279dcdd6e2e03c904cefc466f2a121", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -96,7 +96,7 @@ pub trait Iterator {\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n     /// A [`None`] here means that either there is no known upper bound, or the\n     /// upper bound is larger than [`usize`].\n     ///\n@@ -115,11 +115,9 @@ pub trait Iterator {\n     /// That said, the implementation should provide a correct estimation,\n     /// because otherwise it would be a violation of the trait's protocol.\n     ///\n-    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n+    /// The default implementation returns <code>(0, [None])</code> which is correct for any\n     /// iterator.\n     ///\n-    /// [`usize`]: type@usize\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -870,7 +868,6 @@ pub trait Iterator {\n     /// The returned iterator might panic if the to-be-returned index would\n     /// overflow a [`usize`].\n     ///\n-    /// [`usize`]: type@usize\n     /// [`zip`]: Iterator::zip\n     ///\n     /// # Examples"}, {"sha": "b7dae02d6233a40e0e31bc711c13e942e3bc4acf", "filename": "library/core/src/option.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -47,9 +47,9 @@\n //!\n //! Rust's pointer types must always point to a valid location; there are\n //! no \"null\" references. Instead, Rust has *optional* pointers, like\n-//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n+//! the optional owned box, <code>[Option]<[Box\\<T>]></code>.\n //!\n-//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [Box\\<T>]: ../../std/boxed/struct.Box.html\n //!\n //! The following example uses [`Option`] to create an optional box of\n //! [`i32`]. Notice that in order to use the inner [`i32`] value, the\n@@ -111,16 +111,20 @@\n //!\n //! ## Adapters for working with references\n //!\n-//! * [`as_ref`] converts from `&Option<T>` to `Option<&T>`\n-//! * [`as_mut`] converts from `&mut Option<T>` to `Option<&mut T>`\n-//! * [`as_deref`] converts from `&Option<T>` to `Option<&T::Target>`\n-//! * [`as_deref_mut`] converts from `&mut Option<T>` to\n-//!   `Option<&mut T::Target>`\n-//! * [`as_pin_ref`] converts from [`Pin`]`<&Option<T>>` to\n-//!   `Option<`[`Pin`]`<&T>>`\n-//! * [`as_pin_mut`] converts from [`Pin`]`<&mut Option<T>>` to\n-//!   `Option<`[`Pin`]`<&mut T>>`\n-//!\n+//! * [`as_ref`] converts from <code>[&][][Option]\\<T></code> to <code>[Option]<[&]T></code>\n+//! * [`as_mut`] converts from <code>[&mut] [Option]\\<T></code> to <code>[Option]<[&mut] T></code>\n+//! * [`as_deref`] converts from <code>[&][][Option]\\<T></code> to\n+//!   <code>[Option]<[&]T::[Target]></code>\n+//! * [`as_deref_mut`] converts from <code>[&mut] [Option]\\<T></code> to\n+//!   <code>[Option]<[&mut] T::[Target]></code>\n+//! * [`as_pin_ref`] converts from <code>[Pin]<[&][][Option]\\<T>></code> to\n+//!   <code>[Option]<[Pin]<[&]T>></code>\n+//! * [`as_pin_mut`] converts from <code>[Pin]<[&mut] [Option]\\<T>></code> to\n+//!   <code>[Option]<[Pin]<[&mut] T>></code>\n+//!\n+//! [&]: reference \"shared reference\"\n+//! [&mut]: reference \"mutable reference\"\n+//! [Target]: Deref::Target \"ops::Deref::Target\"\n //! [`as_deref`]: Option::as_deref\n //! [`as_deref_mut`]: Option::as_deref_mut\n //! [`as_mut`]: Option::as_mut\n@@ -603,13 +607,13 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n-    /// The [`map`] method takes the `self` argument by value, consuming the original,\n+    /// Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, preserving\n+    /// the original. The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n     /// [`map`]: Option::map\n-    /// [`String`]: ../../std/string/struct.String.html\n+    /// [String]: ../../std/string/struct.String.html \"String\"\n     ///\n     /// ```\n     /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n@@ -649,7 +653,9 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n+    /// Converts from <code>[Pin]<[&]Option\\<T>></code> to <code>Option<[Pin]<[&]T>></code>.\n+    ///\n+    /// [&]: reference \"shared reference\"\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n@@ -658,7 +664,9 @@ impl<T> Option<T> {\n         unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n     }\n \n-    /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n+    /// Converts from <code>[Pin]<[&mut] Option\\<T>></code> to <code>Option<[Pin]<[&mut] T>></code>.\n+    ///\n+    /// [&mut]: reference \"mutable reference\"\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n@@ -819,9 +827,10 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n+    /// Converts an <code>Option<[String]></code> into an <code>Option<[usize]></code>, consuming\n+    /// the original:\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n+    /// [String]: ../../std/string/struct.String.html \"String\"\n     /// ```\n     /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n     /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n@@ -1584,9 +1593,9 @@ impl<T: DerefMut> Option<T> {\n impl<T, E> Option<Result<T, E>> {\n     /// Transposes an `Option` of a [`Result`] into a [`Result`] of an `Option`.\n     ///\n-    /// [`None`] will be mapped to [`Ok`]`(`[`None`]`)`.\n-    /// [`Some`]`(`[`Ok`]`(_))` and [`Some`]`(`[`Err`]`(_))` will be mapped to\n-    /// [`Ok`]`(`[`Some`]`(_))` and [`Err`]`(_)`.\n+    /// [`None`] will be mapped to <code>[Ok]\\([None])</code>.\n+    /// <code>[Some]\\([Ok]\\(\\_))</code> and <code>[Some]\\([Err]\\(\\_))</code> will be mapped to\n+    /// <code>[Ok]\\([Some]\\(\\_))</code> and <code>[Err]\\(\\_)</code>.\n     ///\n     /// # Examples\n     ///\n@@ -1724,13 +1733,13 @@ impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n-    /// The [`map`] method takes the `self` argument by value, consuming the original,\n-    /// so this technique uses `from` to first take an `Option` to a reference\n+    /// Converts an <code>[Option]<[String]></code> into an <code>[Option]<[usize]></code>, preserving\n+    /// the original. The [`map`] method takes the `self` argument by value, consuming the original,\n+    /// so this technique uses `from` to first take an [`Option`] to a reference\n     /// to the value inside the original.\n     ///\n     /// [`map`]: Option::map\n-    /// [`String`]: ../../std/string/struct.String.html\n+    /// [String]: ../../std/string/struct.String.html \"String\"\n     ///\n     /// ```\n     /// let s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));"}, {"sha": "8b645792169155aba160c46382db7721b776265c", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -368,15 +368,15 @@\n //! [Vec::push]: ../../std/vec/struct.Vec.html#method.push \"Vec::push\"\n //! [Rc]: ../../std/rc/struct.Rc.html \"rc::Rc\"\n //! [RefCell]: crate::cell::RefCell \"cell::RefCell\"\n-//! [`drop`]: Drop::drop \"Drop::drop\"\n+//! [`drop`]: Drop::drop\n //! [VecDeque]: ../../std/collections/struct.VecDeque.html \"collections::VecDeque\"\n //! [`ptr::write`]: crate::ptr::write \"ptr::write\"\n //! [`Future`]: crate::future::Future \"future::Future\"\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n //! [`poll`]: crate::future::Future::poll \"future::Future::poll\"\n-//! [&]: ../../std/primitive.reference.html \"shared reference\"\n-//! [&mut]: ../../std/primitive.reference.html \"mutable reference\"\n+//! [&]: reference \"shared reference\"\n+//! [&mut]: reference \"mutable reference\"\n //! [`unsafe`]: ../../std/keyword.unsafe.html \"keyword unsafe\"\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]"}, {"sha": "4a300f857e9ed9dd4623ca07c983dc6f0f5b6cb5", "filename": "library/core/src/result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -88,7 +88,7 @@\n //! ```\n //!\n //! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n-//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n+//! is just a synonym for <code>[Result]<T, [io::Error]></code>.*\n //!\n //! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n@@ -217,13 +217,13 @@\n //! early return of [`Err`] that it provides.\n //!\n //! [`expect`]: Result::expect\n-//! [`Write`]: ../../std/io/trait.Write.html\n-//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n-//! [`io::Result`]: ../../std/io/type.Result.html\n+//! [`Write`]: ../../std/io/trait.Write.html \"io::Write\"\n+//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all \"io::Write::write_all\"\n+//! [`io::Result`]: ../../std/io/type.Result.html \"io::Result\"\n //! [`?`]: crate::ops::Try\n //! [`Ok(T)`]: Ok\n //! [`Err(E)`]: Err\n-//! [`io::Error`]: ../../std/io/struct.Error.html\n+//! [io::Error]: ../../std/io/struct.Error.html \"io::Error\"\n //!\n //! # Method overview\n //!"}, {"sha": "d102619b8e5ec135f09090ae7b1e08e5413c3a87", "filename": "library/core/src/stream/stream/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -52,7 +52,7 @@ pub trait Stream {\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n     /// A [`None`] here means that either there is no known upper bound, or the\n     /// upper bound is larger than [`usize`].\n     ///\n@@ -71,7 +71,7 @@ pub trait Stream {\n     /// That said, the implementation should provide a correct estimation,\n     /// because otherwise it would be a violation of the trait's protocol.\n     ///\n-    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n+    /// The default implementation returns <code>(0, [None])</code> which is correct for any\n     /// stream.\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {"}, {"sha": "57416aeb7018fe5712b958018a17cf32a0d0fca4", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -30,9 +30,10 @@ impl<T> Poll<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Converts a `Poll<`[`String`]`>` into an `Poll<`[`usize`]`>`, consuming the original:\n+    /// Converts a <code>Poll<[String]></code> into a <code>Poll<[usize]></code>, consuming\n+    /// the original:\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n+    /// [String]: ../../std/string/struct.String.html \"String\"\n     /// ```\n     /// # use core::task::Poll;\n     /// let poll_some_string = Poll::Ready(String::from(\"Hello, World!\"));"}, {"sha": "71ee0af28d4263e7df35c2d830052788f1ce41cb", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -217,7 +217,7 @@\n //! contents by-value. This is great when the collection itself is no longer\n //! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n //! is the main way that contents of one collection are moved into another.\n-//! `extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\n+//! `extend` automatically calls `into_iter`, and takes any <code>T: [IntoIterator]</code>.\n //! Calling `collect` on an iterator itself is also a great way to convert one\n //! collection into another. Both of these methods should internally use the\n //! capacity management tools discussed in the previous section to do this as\n@@ -396,7 +396,7 @@\n //! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n //! ```\n //!\n-//! [`IntoIterator`]: crate::iter::IntoIterator\n+//! [IntoIterator]: crate::iter::IntoIterator \"iter::IntoIterator\"\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "4c5965e2666c3694077606ff5849d8cd4078be88", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -29,18 +29,18 @@ use crate::sys_common::memchr;\n /// type is a static guarantee that the underlying bytes contain no interior 0\n /// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// `CString` is to [`&CStr`] as [`String`] is to [`&str`]: the former\n+/// `CString` is to <code>&[CStr]</code> as [`String`] is to <code>&[str]</code>: the former\n /// in each pair are owned strings; the latter are borrowed\n /// references.\n ///\n /// # Creating a `CString`\n ///\n /// A `CString` is created from either a byte slice or a byte vector,\n-/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n+/// or anything that implements <code>[Into]<[Vec]<[u8]>></code> (for\n /// example, you can build a `CString` straight out of a [`String`] or\n-/// a [`&str`], since both implement that trait).\n+/// a <code>&[str]</code>, since both implement that trait).\n ///\n-/// The [`CString::new`] method will actually check that the provided `&[u8]`\n+/// The [`CString::new`] method will actually check that the provided <code>&[[u8]]</code>\n /// does not have 0 bytes in the middle, and return an error if it\n /// finds one.\n ///\n@@ -55,7 +55,7 @@ use crate::sys_common::memchr;\n ///\n /// # Extracting a slice of the whole C string\n ///\n-/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n+/// Alternatively, you can obtain a <code>&[[u8]]</code> slice from a\n /// `CString` with the [`CString::as_bytes`] method. Slices produced in this\n /// way do *not* contain the trailing nul terminator. This is useful\n /// when you will be calling an extern function that takes a `*const\n@@ -64,7 +64,7 @@ use crate::sys_common::memchr;\n /// You can of course get the slice's length with its\n /// [`len`][slice::len] method.\n ///\n-/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n+/// If you need a <code>&[[u8]]</code> slice *with* the nul terminator, you\n /// can use [`CString::as_bytes_with_nul`] instead.\n ///\n /// Once you have the kind of slice you need (with or without a nul\n@@ -73,9 +73,8 @@ use crate::sys_common::memchr;\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n-/// [`&str`]: prim@str\n+/// [str]: prim@str \"str\"\n /// [`Deref`]: ops::Deref\n-/// [`&CStr`]: CStr\n ///\n /// # Examples\n ///\n@@ -120,12 +119,12 @@ pub struct CString {\n /// Representation of a borrowed C string.\n ///\n /// This type represents a borrowed reference to a nul-terminated\n-/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n+/// array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n /// slice, or unsafely from a raw `*const c_char`. It can then be\n-/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n+/// converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or\n /// into an owned [`CString`].\n ///\n-/// `&CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n+/// `&CStr` is to [`CString`] as <code>&[str]</code> is to [`String`]: the former\n /// in each pair are borrowed references; the latter are owned\n /// strings.\n ///\n@@ -183,7 +182,7 @@ pub struct CString {\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n ///\n-/// [`&str`]: prim@str\n+/// [str]: prim@str \"str\"\n #[derive(Hash)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -682,7 +681,7 @@ impl CString {\n         unsafe { ptr::read(&this.inner) }\n     }\n \n-    /// Converts a [`Vec`]`<u8>` to a [`CString`] without checking the\n+    /// Converts a <code>[Vec]<[u8]></code> to a [`CString`] without checking the\n     /// invariants on the given [`Vec`].\n     ///\n     /// # Safety\n@@ -705,7 +704,7 @@ impl CString {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n-    /// Attempts to converts a [`Vec`]`<u8>` to a [`CString`].\n+    /// Attempts to converts a <code>[Vec]<[u8]></code> to a [`CString`].\n     ///\n     /// Runtime checks are present to ensure there is only one nul byte in the\n     /// [`Vec`], its last element.\n@@ -793,7 +792,7 @@ impl fmt::Debug for CString {\n \n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n impl From<CString> for Vec<u8> {\n-    /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n+    /// Converts a [`CString`] into a <code>[Vec]<[u8]></code>.\n     ///\n     /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n     #[inline]\n@@ -867,7 +866,7 @@ impl From<Cow<'_, CStr>> for Box<CStr> {\n \n #[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\n impl From<Box<CStr>> for CString {\n-    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n+    /// Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n         s.into_c_string()\n@@ -876,7 +875,7 @@ impl From<Box<CStr>> for CString {\n \n #[stable(feature = \"cstring_from_vec_of_nonzerou8\", since = \"1.43.0\")]\n impl From<Vec<NonZeroU8>> for CString {\n-    /// Converts a [`Vec`]`<`[`NonZeroU8`]`>` into a [`CString`] without\n+    /// Converts a <code>[Vec]<[NonZeroU8]></code> into a [`CString`] without\n     /// copying nor checking for inner null bytes.\n     #[inline]\n     fn from(v: Vec<NonZeroU8>) -> CString {\n@@ -906,7 +905,7 @@ impl Clone for Box<CStr> {\n \n #[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n impl From<CString> for Box<CStr> {\n-    /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n+    /// Converts a [`CString`] into a <code>[Box]<[CStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: CString) -> Box<CStr> {\n         s.into_boxed_c_str()\n@@ -939,7 +938,7 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n-    /// Converts a [`CString`] into an [`Arc`]`<CStr>` without copying or allocating.\n+    /// Converts a [`CString`] into an <code>[Arc]<[CStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());\n@@ -958,7 +957,7 @@ impl From<&CStr> for Arc<CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n-    /// Converts a [`CString`] into an [`Rc`]`<CStr>` without copying or allocating.\n+    /// Converts a [`CString`] into an <code>[Rc]<[CStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());\n@@ -1352,13 +1351,13 @@ impl CStr {\n         unsafe { &*(&self.inner as *const [c_char] as *const [u8]) }\n     }\n \n-    /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n+    /// Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n-    /// function will return the corresponding [`&str`] slice. Otherwise,\n+    /// function will return the corresponding <code>&[str]</code> slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// [`&str`]: prim@str\n+    /// [str]: prim@str \"str\"\n     ///\n     /// # Examples\n     ///\n@@ -1377,20 +1376,19 @@ impl CStr {\n         str::from_utf8(self.to_bytes())\n     }\n \n-    /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n+    /// Converts a `CStr` into a <code>[Cow]<[str]></code>.\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n-    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n-    /// with the corresponding [`&str`] slice. Otherwise, it will\n+    /// function will return a <code>[Cow]::[Borrowed]\\(&[str])</code>\n+    /// with the corresponding <code>&[str]</code> slice. Otherwise, it will\n     /// replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n-    /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n+    /// <code>[Cow]::[Owned]\\(&[str])</code> with the result.\n     ///\n-    /// [`str`]: primitive@str\n-    /// [`&str`]: primitive@str\n-    /// [`Borrowed`]: Cow::Borrowed\n-    /// [`Owned`]: Cow::Owned\n-    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER\n+    /// [str]: prim@str \"str\"\n+    /// [Borrowed]: Cow::Borrowed\n+    /// [Owned]: Cow::Owned\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER \"std::char::REPLACEMENT_CHARACTER\"\n     ///\n     /// # Examples\n     ///\n@@ -1423,7 +1421,7 @@ impl CStr {\n         String::from_utf8_lossy(self.to_bytes())\n     }\n \n-    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n+    /// Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.\n     ///\n     /// # Examples\n     ///"}, {"sha": "50708c1f5fbafd6b81759efb86401fbc55c99965", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -64,15 +64,15 @@\n //! string: it is nul-terminated, and has no internal nul characters.\n //! Rust code can create a [`CString`] out of a normal string (provided\n //! that the string doesn't have nul characters in the middle), and\n-//! then use a variety of methods to obtain a raw `*mut `[`u8`] that can\n+//! then use a variety of methods to obtain a raw <code>\\*mut [u8]</code> that can\n //! then be passed as an argument to functions which use the C\n //! conventions for strings.\n //!\n //! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n-//! is what you would use to wrap a raw `*const `[`u8`] that you got from\n+//! is what you would use to wrap a raw <code>\\*const [u8]</code> that you got from\n //! a C function. A [`CStr`] is guaranteed to be a nul-terminated array\n //! of bytes. Once you have a [`CStr`], you can convert it to a Rust\n-//! [`&str`][`str`] if it's valid UTF-8, or lossily convert it by adding\n+//! <code>&[str]</code> if it's valid UTF-8, or lossily convert it by adding\n //! replacement characters.\n //!\n //! [`OsString`] and [`OsStr`] are useful when you need to transfer\n@@ -86,9 +86,9 @@\n //! library, various APIs that transfer strings to/from the operating\n //! system use [`OsString`] instead of plain strings. For example,\n //! [`env::var_os()`] is used to query environment variables; it\n-//! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n-//! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n-//! convert to a Rust string. This yields a [`Result`], so that\n+//! returns an <code>[Option]<[OsString]></code>. If the environment variable\n+//! exists you will get a <code>[Some]\\(os_string)</code>, which you can\n+//! *then* try to convert to a Rust string. This yields a [`Result`], so that\n //! your code can detect errors in case the environment variable did\n //! not in fact contain valid Unicode data.\n //!\n@@ -102,44 +102,44 @@\n //! ## On Unix\n //!\n //! On Unix, [`OsStr`] implements the\n-//! `std::os::unix::ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n+//! <code>std::os::unix::ffi::[OsStrExt][unix.OsStrExt]</code> trait, which\n //! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n //! These do inexpensive conversions from and to UTF-8 byte slices.\n //!\n //! Additionally, on Unix [`OsString`] implements the\n-//! `std::os::unix::ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n+//! <code>std::os::unix::ffi::[OsStringExt][unix.OsStringExt]</code> trait,\n //! which provides [`from_vec`] and [`into_vec`] methods that consume\n //! their arguments, and take or produce vectors of [`u8`].\n //!\n //! ## On Windows\n //!\n //! On Windows, [`OsStr`] implements the\n-//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n+//! <code>std::os::windows::ffi::[OsStrExt][windows.OsStrExt]</code> trait,\n //! which provides an [`encode_wide`] method. This provides an\n //! iterator that can be [`collect`]ed into a vector of [`u16`].\n //!\n //! Additionally, on Windows [`OsString`] implements the\n-//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n+//! <code>std::os::windows:ffi::[OsStringExt][windows.OsStringExt]</code>\n //! trait, which provides a [`from_wide`] method. The result of this\n //! method is an [`OsString`] which can be round-tripped to a Windows\n //! string losslessly.\n //!\n //! [Unicode scalar value]: https://www.unicode.org/glossary/#unicode_scalar_value\n //! [Unicode code point]: https://www.unicode.org/glossary/#code_point\n-//! [`env::set_var()`]: crate::env::set_var\n-//! [`env::var_os()`]: crate::env::var_os\n-//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt\n-//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec\n-//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec\n-//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt\n-//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes\n-//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes\n-//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt\n-//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt\n-//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide\n-//! [`collect`]: crate::iter::Iterator::collect\n-//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt\n-//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide\n+//! [`env::set_var()`]: crate::env::set_var \"env::set_var\"\n+//! [`env::var_os()`]: crate::env::var_os \"env::var_os\"\n+//! [unix.OsStringExt]: crate::os::unix::ffi::OsStringExt \"os::unix::ffi::OsStringExt\"\n+//! [`from_vec`]: crate::os::unix::ffi::OsStringExt::from_vec \"os::unix::ffi::OsStringExt::from_vec\"\n+//! [`into_vec`]: crate::os::unix::ffi::OsStringExt::into_vec \"os::unix::ffi::OsStringExt::into_vec\"\n+//! [unix.OsStrExt]: crate::os::unix::ffi::OsStrExt \"os::unix::ffi::OsStrExt\"\n+//! [`from_bytes`]: crate::os::unix::ffi::OsStrExt::from_bytes \"os::unix::ffi::OsStrExt::from_bytes\"\n+//! [`as_bytes`]: crate::os::unix::ffi::OsStrExt::as_bytes \"os::unix::ffi::OsStrExt::as_bytes\"\n+//! [`OsStrExt`]: crate::os::unix::ffi::OsStrExt \"os::unix::ffi::OsStrExt\"\n+//! [windows.OsStrExt]: crate::os::windows::ffi::OsStrExt \"os::windows::ffi::OsStrExt\"\n+//! [`encode_wide`]: crate::os::windows::ffi::OsStrExt::encode_wide \"os::windows::ffi::OsStrExt::encode_wide\"\n+//! [`collect`]: crate::iter::Iterator::collect \"iter::Iterator::collect\"\n+//! [windows.OsStringExt]: crate::os::windows::ffi::OsStringExt \"os::windows::ffi::OsStringExt\"\n+//! [`from_wide`]: crate::os::windows::ffi::OsStringExt::from_wide \"os::windows::ffi::OsStringExt::from_wide\"\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "7e70901076cdadc96c8855cda6958f786989f9ef", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -33,7 +33,7 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// of this is that `OsString` instances are *not* `NUL` terminated; in order\n /// to pass to e.g., Unix system call, you should create a [`CStr`].\n ///\n-/// `OsString` is to [`&OsStr`] as [`String`] is to [`&str`]: the former\n+/// `OsString` is to <code>&[OsStr]</code> as [`String`] is to <code>&[str]</code>: the former\n /// in each pair are owned strings; the latter are borrowed\n /// references.\n ///\n@@ -47,18 +47,18 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// # Creating an `OsString`\n ///\n /// **From a Rust string**: `OsString` implements\n-/// [`From`]`<`[`String`]`>`, so you can use `my_string.from` to\n+/// <code>[From]<[String]></code>, so you can use <code>my_string.[into]\\()</code> to\n /// create an `OsString` from a normal Rust string.\n ///\n /// **From slices:** Just like you can start with an empty Rust\n-/// [`String`] and then [`String::push_str`] `&str`\n+/// [`String`] and then [`String::push_str`] some <code>&[str]</code>\n /// sub-string slices into it, you can create an empty `OsString` with\n /// the [`OsString::new`] method and then push string slices into it with the\n /// [`OsString::push`] method.\n ///\n /// # Extracting a borrowed reference to the whole OS string\n ///\n-/// You can use the [`OsString::as_os_str`] method to get an `&`[`OsStr`] from\n+/// You can use the [`OsString::as_os_str`] method to get an <code>&[OsStr]</code> from\n /// an `OsString`; this is effectively a borrowed reference to the\n /// whole string.\n ///\n@@ -67,10 +67,9 @@ use crate::sys_common::{AsInner, FromInner, IntoInner};\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsString` implements for [conversions] from/to native representations.\n ///\n-/// [`&OsStr`]: OsStr\n-/// [`&str`]: str\n /// [`CStr`]: crate::ffi::CStr\n /// [conversions]: super#conversions\n+/// [into]: Into::into\n #[cfg_attr(not(test), rustc_diagnostic_item = \"OsString\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsString {\n@@ -86,13 +85,12 @@ impl crate::sealed::Sealed for OsString {}\n /// This type represents a borrowed reference to a string in the operating system's preferred\n /// representation.\n ///\n-/// `&OsStr` is to [`OsString`] as [`&str`] is to [`String`]: the former in each pair are borrowed\n-/// references; the latter are owned strings.\n+/// `&OsStr` is to [`OsString`] as <code>&[str]</code> is to [`String`]: the\n+/// former in each pair are borrowed references; the latter are owned strings.\n ///\n /// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n /// the traits which `OsStr` implements for [conversions] from/to native representations.\n ///\n-/// [`&str`]: str\n /// [conversions]: super#conversions\n #[cfg_attr(not(test), rustc_diagnostic_item = \"OsStr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -162,9 +160,7 @@ impl OsString {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf })\n     }\n \n-    /// Extends the string with the given [`&OsStr`] slice.\n-    ///\n-    /// [`&OsStr`]: OsStr\n+    /// Extends the string with the given <code>&[OsStr]</code> slice.\n     ///\n     /// # Examples\n     ///\n@@ -563,12 +559,10 @@ impl OsStr {\n         unsafe { &mut *(inner as *mut Slice as *mut OsStr) }\n     }\n \n-    /// Yields a [`&str`] slice if the `OsStr` is valid Unicode.\n+    /// Yields a <code>&[str]</code> slice if the `OsStr` is valid Unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     ///\n-    /// [`&str`]: str\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -583,7 +577,7 @@ impl OsStr {\n         self.inner.to_str()\n     }\n \n-    /// Converts an `OsStr` to a [`Cow`]`<`[`str`]`>`.\n+    /// Converts an `OsStr` to a <code>[Cow]<[str]></code>.\n     ///\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n@@ -701,7 +695,7 @@ impl OsStr {\n         self.inner.inner.len()\n     }\n \n-    /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n+    /// Converts a <code>[Box]<[OsStr]></code> into an [`OsString`] without copying or allocating.\n     #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n     pub fn into_os_string(self: Box<OsStr>) -> OsString {\n         let boxed = unsafe { Box::from_raw(Box::into_raw(self) as *mut Slice) };\n@@ -870,7 +864,7 @@ impl From<Cow<'_, OsStr>> for Box<OsStr> {\n \n #[stable(feature = \"os_string_from_box\", since = \"1.18.0\")]\n impl From<Box<OsStr>> for OsString {\n-    /// Converts a [`Box`]`<`[`OsStr`]`>` into an [`OsString`] without copying or\n+    /// Converts a <code>[Box]<[OsStr]></code> into an [`OsString`] without copying or\n     /// allocating.\n     #[inline]\n     fn from(boxed: Box<OsStr>) -> OsString {\n@@ -880,7 +874,7 @@ impl From<Box<OsStr>> for OsString {\n \n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n-    /// Converts an [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into a <code>[Box]<[OsStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n@@ -897,7 +891,7 @@ impl Clone for Box<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n-    /// Converts an [`OsString`] into an [`Arc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into an <code>[Arc]<[OsStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -916,7 +910,7 @@ impl From<&OsStr> for Arc<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n-    /// Converts an [`OsString`] into an [`Rc`]`<OsStr>` without copying or allocating.\n+    /// Converts an [`OsString`] into an <code>[Rc]<[OsStr]></code> without copying or allocating.\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "e4b44c0489807bca10e7b279d395925c37b7ad3f", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -106,7 +106,7 @@ pub struct Metadata(fs_imp::FileAttr);\n /// Iterator over the entries in a directory.\n ///\n /// This iterator is returned from the [`read_dir`] function of this module and\n-/// will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. Through a [`DirEntry`]\n+/// will yield instances of <code>[io::Result]<[DirEntry]></code>. Through a [`DirEntry`]\n /// information like the entry's path and possibly other metadata can be\n /// learned.\n ///\n@@ -786,17 +786,17 @@ impl OpenOptions {\n     /// If a file is opened with both read and append access, beware that after\n     /// opening, and after every write, the position for reading may be set at the\n     /// end of the file. So, before writing, save the current position (using\n-    /// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.\n+    /// <code>[seek]\\([SeekFrom]::[Current]\\(0))</code>), and restore it before the next read.\n     ///\n     /// ## Note\n     ///\n     /// This function doesn't create the file if it doesn't exist. Use the\n     /// [`OpenOptions::create`] method to do so.\n     ///\n-    /// [`write()`]: Write::write\n-    /// [`flush()`]: Write::flush\n-    /// [`seek`]: Seek::seek\n-    /// [`Current`]: SeekFrom::Current\n+    /// [`write()`]: Write::write \"io::Write::write\"\n+    /// [`flush()`]: Write::flush \"io::Write::flush\"\n+    /// [seek]: Seek::seek \"io::Seek::seek\"\n+    /// [Current]: SeekFrom::Current \"io::SeekFrom::Current\"\n     ///\n     /// # Examples\n     ///\n@@ -2043,7 +2043,7 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n \n /// Returns an iterator over the entries within a directory.\n ///\n-/// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.\n+/// The iterator will yield instances of <code>[io::Result]<[DirEntry]></code>.\n /// New errors may be encountered after an iterator is initially constructed.\n /// Entries for the current and parent directories (typically `.` and `..`) are\n /// skipped."}, {"sha": "869ac1ec8596c1324b915b9479a46f7649e9b9b5", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -15,7 +15,7 @@ use crate::io::{\n /// *repeated* read calls to the same file or network socket. It does not\n /// help when reading very large amounts at once, or reading just one or a few\n /// times. It also provides no advantage when reading from a source that is\n-/// already in memory, like a [`Vec`]`<u8>`.\n+/// already in memory, like a <code>[Vec]\\<u8></code>.\n ///\n /// When the `BufReader<R>` is dropped, the contents of its buffer will be\n /// discarded. Creating multiple instances of a `BufReader<R>` on the same\n@@ -347,7 +347,7 @@ where\n impl<R: Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n-    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n+    /// The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the\n     /// position the underlying reader would be at if the `BufReader<R>` had no\n     /// internal buffer.\n     ///\n@@ -360,11 +360,11 @@ impl<R: Seek> Seek for BufReader<R> {\n     ///\n     /// See [`std::io::Seek`] for more details.\n     ///\n-    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n+    /// Note: In the edge case where you're seeking with <code>[SeekFrom::Current]\\(n)</code>\n     /// where `n` minus the internal buffer length overflows an `i64`, two\n     /// seeks will be performed instead of one. If the second seek returns\n     /// [`Err`], the underlying reader will be left at the same position it would\n-    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n+    /// have if you called `seek` with <code>[SeekFrom::Current]\\(0)</code>.\n     ///\n     /// [`std::io::Seek`]: Seek\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {"}, {"sha": "ebbda7c1bf2a0b6fa8a45e563fa0db4f373bc4d2", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -18,7 +18,7 @@ use crate::ptr;\n /// *repeated* write calls to the same file or network socket. It does not\n /// help when writing very large amounts at once, or writing just one or a few\n /// times. It also provides no advantage when writing to a destination that is\n-/// in memory, like a [`Vec`]`<u8>`.\n+/// in memory, like a <code>[Vec]\\<u8></code>.\n ///\n /// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n /// dropping will attempt to flush the contents of the buffer, any errors"}, {"sha": "25cc5e67ad14e37ddfd6ed337edadef5f39dd006", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -12,21 +12,21 @@ use core::convert::TryInto;\n /// [`Seek`] implementation.\n ///\n /// `Cursor`s are used with in-memory buffers, anything implementing\n-/// [`AsRef`]`<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n+/// <code>[AsRef]<\\[u8]></code>, to allow them to implement [`Read`] and/or [`Write`],\n /// allowing these buffers to be used anywhere you might use a reader or writer\n /// that does actual I/O.\n ///\n /// The standard library implements some I/O traits on various types which\n-/// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n-/// `Cursor<`[`&[u8]`][bytes]`>`.\n+/// are commonly used as a buffer, like <code>Cursor<[Vec]\\<u8>></code> and\n+/// <code>Cursor<[&\\[u8\\]][bytes]></code>.\n ///\n /// # Examples\n ///\n /// We may want to write bytes to a [`File`] in our production\n /// code, but use an in-memory buffer in our tests. We can do this with\n /// `Cursor`:\n ///\n-/// [bytes]: crate::slice\n+/// [bytes]: crate::slice \"slice\"\n /// [`File`]: crate::fs::File\n ///\n /// ```no_run"}, {"sha": "324b9c87318f1b9b49647d967f067e3f4be2ff65", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -854,18 +854,19 @@ pub trait Read {\n \n     /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n     ///\n-    /// The returned type implements [`Iterator`] where the `Item` is\n-    /// [`Result`]`<`[`u8`]`, `[`io::Error`]`>`.\n+    /// The returned type implements [`Iterator`] where the [`Item`] is\n+    /// <code>[Result]<[u8], [io::Error]></code>.\n     /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n     /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n     ///\n     /// # Examples\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: crate::fs::File\n-    /// [`Result`]: crate::result::Result\n-    /// [`io::Error`]: self::Error\n+    /// [`Item`]: Iterator::Item\n+    /// [`File`]: crate::fs::File \"fs::File\"\n+    /// [Result]: crate::result::Result \"Result\"\n+    /// [io::Error]: self::Error \"io::Error\"\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -2191,13 +2192,13 @@ pub trait BufRead: Read {\n     /// `byte`.\n     ///\n     /// The iterator returned from this function will return instances of\n-    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n+    /// <code>[io::Result]<[Vec]\\<u8>></code>. Each vector returned will *not* have\n     /// the delimiter byte at the end.\n     ///\n     /// This function will yield errors whenever [`read_until`] would have\n     /// also yielded an error.\n     ///\n-    /// [`io::Result`]: self::Result\n+    /// [io::Result]: self::Result \"io::Result\"\n     /// [`read_until`]: BufRead::read_until\n     ///\n     /// # Examples\n@@ -2228,10 +2229,10 @@ pub trait BufRead: Read {\n     /// Returns an iterator over the lines of this reader.\n     ///\n     /// The iterator returned from this function will yield instances of\n-    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n+    /// <code>[io::Result]<[String]></code>. Each string returned will *not* have a newline\n     /// byte (the `0xA` byte) or `CRLF` (`0xD`, `0xA` bytes) at the end.\n     ///\n-    /// [`io::Result`]: self::Result\n+    /// [io::Result]: self::Result \"io::Result\"\n     ///\n     /// # Examples\n     ///"}, {"sha": "2f3520ae7a5a5fb4c9aab4c4364b64fe334b5d70", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -19,7 +19,7 @@ pub struct Empty;\n \n /// Constructs a new handle to an empty reader.\n ///\n-/// All reads from the returned reader will return [`Ok`]`(0)`.\n+/// All reads from the returned reader will return <code>[Ok]\\(0)</code>.\n ///\n /// # Examples\n ///"}, {"sha": "f4ebcd53a25f7482c3f6736de8d045828c8193b8", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -765,15 +765,15 @@ impl hash::Hash for SocketAddrV6 {\n ///\n ///  * [`SocketAddr`]: [`to_socket_addrs`] is the identity function.\n ///\n-///  * [`SocketAddrV4`], [`SocketAddrV6`], `(`[`IpAddr`]`, `[`u16`]`)`,\n-///    `(`[`Ipv4Addr`]`, `[`u16`]`)`, `(`[`Ipv6Addr`]`, `[`u16`]`)`:\n+///  * [`SocketAddrV4`], [`SocketAddrV6`], <code>([IpAddr], [u16])</code>,\n+///    <code>([Ipv4Addr], [u16])</code>, <code>([Ipv6Addr], [u16])</code>:\n ///    [`to_socket_addrs`] constructs a [`SocketAddr`] trivially.\n ///\n-///  * `(`[`&str`]`, `[`u16`]`)`: [`&str`] should be either a string representation\n+///  * <code>(&[str], [u16])</code>: <code>&[str]</code> should be either a string representation\n ///    of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host\n ///    name. [`u16`] is the port number.\n ///\n-///  * [`&str`]: the string should be either a string representation of a\n+///  * <code>&[str]</code>: the string should be either a string representation of a\n ///    [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like\n ///    `<host_name>:<port>` pair where `<port>` is a [`u16`] value.\n ///\n@@ -789,11 +789,10 @@ impl hash::Hash for SocketAddrV6 {\n /// Addresses returned by the operating system that are not IP addresses are\n /// silently ignored.\n ///\n-/// [`FromStr`]: crate::str::FromStr\n-/// [`&str`]: str\n-/// [`TcpStream`]: crate::net::TcpStream\n+/// [`FromStr`]: crate::str::FromStr \"std::str::FromStr\"\n+/// [`TcpStream`]: crate::net::TcpStream \"net::TcpStream\"\n /// [`to_socket_addrs`]: ToSocketAddrs::to_socket_addrs\n-/// [`UdpSocket`]: crate::net::UdpSocket\n+/// [`UdpSocket`]: crate::net::UdpSocket \"net::UdpSocket\"\n ///\n /// # Examples\n ///\n@@ -872,7 +871,7 @@ pub trait ToSocketAddrs {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Iter: Iterator<Item = SocketAddr>;\n \n-    /// Converts this object to an iterator of resolved `SocketAddr`s.\n+    /// Converts this object to an iterator of resolved [`SocketAddr`]s.\n     ///\n     /// The returned iterator might not actually yield any values depending on the\n     /// outcome of any resolution performed."}, {"sha": "a0c77b648fe0511a8c56cabbf14e3a09707a9977", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -44,16 +44,16 @@ mod udp;\n pub enum Shutdown {\n     /// The reading portion of the [`TcpStream`] should be shut down.\n     ///\n-    /// All currently blocked and future [reads] will return [`Ok`]`(0)`.\n+    /// All currently blocked and future [reads] will return <code>[Ok]\\(0)</code>.\n     ///\n-    /// [reads]: crate::io::Read\n+    /// [reads]: crate::io::Read \"io::Read\"\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Read,\n     /// The writing portion of the [`TcpStream`] should be shut down.\n     ///\n     /// All currently blocked and future [writes] will return an error.\n     ///\n-    /// [writes]: crate::io::Write\n+    /// [writes]: crate::io::Write \"io::Write\"\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Write,\n     /// Both the reading and the writing portions of the [`TcpStream`] should be shut down."}, {"sha": "9d5778ed48cfe5803660f5502b4911d83c1bd70a", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -2552,7 +2552,7 @@ impl Path {\n \n     /// Returns an iterator over the entries within a directory.\n     ///\n-    /// The iterator will yield instances of [`io::Result`]`<`[`fs::DirEntry`]`>`. New\n+    /// The iterator will yield instances of <code>[io::Result]<[fs::DirEntry]></code>. New\n     /// errors may be encountered after an iterator is initially constructed.\n     ///\n     /// This is an alias to [`fs::read_dir`]."}, {"sha": "efcc56b7de0b5d403084d6375e3111897df4f81b", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67065fe93366cfdd9e88440b6f876c3dfeb1f937/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=67065fe93366cfdd9e88440b6f876c3dfeb1f937", "patch": "@@ -450,7 +450,7 @@ impl SystemTime {\n     /// as the system clock being adjusted either forwards or backwards).\n     /// [`Instant`] can be used to measure elapsed time without this risk of failure.\n     ///\n-    /// If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents\n+    /// If successful, <code>[Ok]\\([Duration])</code> is returned where the duration represents\n     /// the amount of time elapsed from the specified measurement to this one.\n     ///\n     /// Returns an [`Err`] if `earlier` is later than `self`, and the error\n@@ -477,7 +477,7 @@ impl SystemTime {\n     ///\n     /// This function may fail as the underlying system clock is susceptible to\n     /// drift and updates (e.g., the system clock could go backwards), so this\n-    /// function might not always succeed. If successful, [`Ok`]`(`[`Duration`]`)` is\n+    /// function might not always succeed. If successful, <code>[Ok]\\([Duration])</code> is\n     /// returned where the duration represents the amount of time elapsed from\n     /// this time measurement to the current time.\n     ///"}]}