{"sha": "7a253eabce740bfa9e558d41adda784642617b6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjUzZWFiY2U3NDBiZmE5ZTU1OGQ0MWFkZGE3ODQ2NDI2MTdiNmQ=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-15T19:25:13Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-15T19:54:44Z"}, "message": "Add an intermediate level of type/region variable resolution forcing\n\nAnd change structurally_resolved_type() to force resolution of\nnon-region variables.", "tree": {"sha": "91ce413f8c59566452db3f5bfc4cf4b5d8b6a828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91ce413f8c59566452db3f5bfc4cf4b5d8b6a828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a253eabce740bfa9e558d41adda784642617b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a253eabce740bfa9e558d41adda784642617b6d", "html_url": "https://github.com/rust-lang/rust/commit/7a253eabce740bfa9e558d41adda784642617b6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a253eabce740bfa9e558d41adda784642617b6d/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "047e3c45b3b502c63e4323343897cc777d698b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/047e3c45b3b502c63e4323343897cc777d698b6d", "html_url": "https://github.com/rust-lang/rust/commit/047e3c45b3b502c63e4323343897cc777d698b6d"}], "stats": {"total": 73, "additions": 49, "deletions": 24}, "files": [{"sha": "1658a2b5e5ac6704767c28c889f8789ea118d156", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7a253eabce740bfa9e558d41adda784642617b6d", "patch": "@@ -76,6 +76,8 @@ import rscope::{in_binding_rscope, region_scope, type_rscope};\n import syntax::ast::{ty_char, ty_i};\n import typeck::infer::{root, to_str};\n import typeck::infer::{unify_methods}; // infcx.set()\n+import typeck::infer::{force_level, force_none, force_non_region_vars_only,\n+                       force_all};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -1040,7 +1042,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> option<O> {\n         alt expected {\n           some(t) {\n-            alt infer::resolve_shallow(fcx.infcx, t, false) {\n+            alt infer::resolve_shallow(fcx.infcx, t, force_none) {\n               result::ok(t) { unpack(ty::get(t).struct) }\n               _ { none }\n             }\n@@ -2184,7 +2186,8 @@ fn instantiate_path(fcx: @fn_ctxt,\n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_shallow(fcx.infcx, tp, false) {\n+    alt infer::resolve_shallow(fcx.infcx, tp,\n+                               force_non_region_vars_only) {\n       result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal\n@@ -2357,5 +2360,3 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n                      ty_to_str(ccx.tcx, fty)]});\n     }\n }\n-\n-"}, {"sha": "48166f099630d7e41473a802669fe4ea7b953143", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7a253eabce740bfa9e558d41adda784642617b6d", "patch": "@@ -115,7 +115,7 @@ fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = fcx.node_ty(id);\n-    let ty = alt infer::resolve_deep(fcx.infcx, ty0, false) {\n+    let ty = alt infer::resolve_deep(fcx.infcx, ty0, force_none) {\n       result::err(_) { ret true; }\n       result::ok(ty) { ty }\n     };"}, {"sha": "1182adfb811672f4139e32336083035ac53a65a4", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=7a253eabce740bfa9e558d41adda784642617b6d", "patch": "@@ -168,7 +168,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n \n fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n-    alt infer::resolve_deep(fcx.infcx, ty, true) {\n+    alt infer::resolve_deep(fcx.infcx, ty, force_all) {\n       result::ok(new_type) { new_type }\n       result::err(e) {\n         tcx.sess.span_fatal("}, {"sha": "418391c8a386a3c8ef9937118dc903ded07276a2", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=7a253eabce740bfa9e558d41adda784642617b6d", "patch": "@@ -10,7 +10,7 @@ export resolve_type_vars_in_expr;\n fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n     option<ty::t> {\n     if !ty::type_needs_infer(typ) { ret some(typ); }\n-    alt infer::resolve_deep(fcx.infcx, typ, true) {\n+    alt infer::resolve_deep(fcx.infcx, typ, force_all) {\n       result::ok(new_type) { ret some(new_type); }\n       result::err(e) {\n         if !fcx.ccx.tcx.sess.has_errors() {\n@@ -131,7 +131,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { ret; }\n     let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n-    alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, true) {\n+    alt infer::resolve_deep_var(wbcx.fcx.infcx, var_id, force_all) {\n       result::ok(lty) {\n         #debug[\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat), l.node.id,"}, {"sha": "c120848775bb86601198c8ba14e2fe04d77af3f1", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a253eabce740bfa9e558d41adda784642617b6d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=7a253eabce740bfa9e558d41adda784642617b6d", "patch": "@@ -176,6 +176,7 @@ export fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n export int_ty_set_all;\n+export force_level, force_none, force_non_region_vars_only, force_all;\n \n // Bitvector to represent sets of integral types\n enum int_ty_set = uint;\n@@ -380,18 +381,19 @@ fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n \n // See comment on the type `resolve_state` below\n fn resolve_shallow(cx: infer_ctxt, a: ty::t,\n-                   force_vars: bool) -> fres<ty::t> {\n+                   force_vars: force_level) -> fres<ty::t> {\n     resolver(cx, false, force_vars).resolve(a)\n }\n \n // See comment on the type `resolve_state` below\n fn resolve_deep_var(cx: infer_ctxt, vid: tv_vid,\n-                    force_vars: bool) -> fres<ty::t> {\n+                    force_vars: force_level) -> fres<ty::t> {\n     resolver(cx, true, force_vars).resolve(ty::mk_var(cx.tcx, vid))\n }\n \n // See comment on the type `resolve_state` below\n-fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: bool) -> fres<ty::t> {\n+fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: force_level)\n+    -> fres<ty::t> {\n     resolver(cx, true, force_vars).resolve(a)\n }\n \n@@ -618,7 +620,7 @@ impl methods for infer_ctxt {\n     }\n \n     fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n-        alt infer::resolve_deep(self, typ, false) {\n+        alt infer::resolve_deep(self, typ, force_none) {\n           result::ok(new_type) { ret new_type; }\n           result::err(_) { ret typ; }\n         }\n@@ -995,20 +997,34 @@ impl unify_methods for infer_ctxt {\n // A <: [B] and B <: int, then shallow resolution on A would yield\n // [B].  Deep resolution, on the other hand, would yield [int].\n //\n-// But there is one more knob: the force_vars variable controls the\n-// behavior in the face of unconstrained variables.  If it is true,\n-// then unconstrained variables result in an error.\n+// But there is one more knob: the `force_level` variable controls\n+// the behavior in the face of unconstrained type and region\n+// variables.\n+\n+enum force_level {\n+    // Any unconstrained variables are OK.\n+    force_none,\n+\n+    // Unconstrained region vars are OK; unconstrained ty vars and\n+    // integral ty vars result in an error.\n+    force_non_region_vars_only,\n+\n+    // Any unconstrained variables result in an error.\n+    force_all,\n+}\n+\n \n type resolve_state = @{\n     infcx: infer_ctxt,\n     deep: bool,\n-    force_vars: bool,\n+    force_vars: force_level,\n     mut err: option<fixup_err>,\n     mut r_seen: [region_vid],\n     mut v_seen: [tv_vid]\n };\n \n-fn resolver(infcx: infer_ctxt, deep: bool, fvars: bool) -> resolve_state {\n+fn resolver(infcx: infer_ctxt, deep: bool, fvars: force_level)\n+    -> resolve_state {\n     @{infcx: infcx,\n       deep: deep,\n       force_vars: fvars,\n@@ -1021,7 +1037,7 @@ impl methods for resolve_state {\n     fn resolve(typ: ty::t) -> fres<ty::t> {\n         self.err = none;\n \n-        #debug[\"Resolving %s (deep=%b, force_vars=%b)\",\n+        #debug[\"Resolving %s (deep=%b, force_vars=%?)\",\n                ty_to_str(self.infcx.tcx, typ),\n                self.deep,\n                self.force_vars];\n@@ -1034,7 +1050,7 @@ impl methods for resolve_state {\n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n         alt self.err {\n           none {\n-            #debug[\"Resolved to %s (deep=%b, force_vars=%b)\",\n+            #debug[\"Resolved to %s (deep=%b, force_vars=%?)\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.deep,\n                    self.force_vars];\n@@ -1095,8 +1111,11 @@ impl methods for resolve_state {\n               { ub:_, lb:some(t) } { self.resolve_region(t) }\n               { ub:some(t), lb:_ } { self.resolve_region(t) }\n               { ub:none, lb:none } {\n-                if self.force_vars {\n+                alt self.force_vars {\n+                  force_all {\n                     self.err = some(unresolved_region(rid));\n+                  }\n+                  _ { /* ok */ }\n                 }\n                 ty::re_var(rid)\n               }\n@@ -1127,8 +1146,11 @@ impl methods for resolve_state {\n               { ub:some(t), lb:_ } { self.resolve1(t) }\n               { ub:_, lb:some(t) } { self.resolve1(t) }\n               { ub:none, lb:none } {\n-                if self.force_vars {\n+                alt self.force_vars {\n+                  force_non_region_vars_only | force_all {\n                     self.err = some(unresolved_ty(vid));\n+                  }\n+                  force_none { /* ok */ }\n                 }\n                 ty::mk_var(tcx, vid)\n               }\n@@ -1146,21 +1168,23 @@ impl methods for resolve_state {\n         alt single_type_contained_in(self.infcx.tcx, pt) {\n           some(t) { t }\n           none {\n-            if self.force_vars {\n+            alt self.force_vars {\n+              force_non_region_vars_only | force_all {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n                     self.infcx.tvib, vid,\n                     root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n                                                            ty)));\n                 ty\n-            } else {\n+              }\n+              force_none {\n                 ty::mk_var_integral(self.infcx.tcx, vid)\n+              }\n             }\n           }\n         }\n     }\n-\n }\n \n // ______________________________________________________________________"}]}