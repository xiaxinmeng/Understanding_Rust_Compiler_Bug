{"sha": "6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNjRmNjhkNGEyMzVlNGVhN2NjOTc0NzExZGNkMTgxZDEwYzU1ZGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-03T06:02:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-03T06:02:57Z"}, "message": "Merge #1753\n\n1753: clearer ignore r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4186099009b716c736ec8820823eb3be6b008c45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4186099009b716c736ec8820823eb3be6b008c45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdbgIRCRBK7hj4Ov3rIwAAdHIIAB4QCw4twry3+nF4I6ny5lM5\nRLwOBt7Ktk7zE4NsdCKkjyeix3jFrDqJ7BZ2Awbz3uz7qspQ4qxxg3kDv9SQ6OWV\n49oOfhtQpJDn+ElVJCPw6gMGFiSnoeeG9zu1Pvha5WdgQU8yEjdt0o6r1Dg2U4/l\nfRlCzvRVq0fgBi6VSNfPd7soju+IfGXjaDnZ/waFxlBLj9MJFhHUB2lxCKcrkm27\nK+OEj5PCxnSIcmkK+i9ZB2/vnHsCvTziwRKBXvkkmzuznMVrpN264VRqW04/jCnX\nQvGBrPGGWJ9krO1fSuE7b49cPYp7fkQt0ltfS+ylAQtlxZrhKbvEwyfC/aau4zw=\n=CnMk\n-----END PGP SIGNATURE-----\n", "payload": "tree 4186099009b716c736ec8820823eb3be6b008c45\nparent 7faec1c30046769d4ae490e15cf5405bcfbdeef8\nparent da850361ba22c78ed3579c33d6748735dcd2885c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567490577 +0000\ncommitter GitHub <noreply@github.com> 1567490577 +0000\n\nMerge #1753\n\n1753: clearer ignore r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "html_url": "https://github.com/rust-lang/rust/commit/6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7faec1c30046769d4ae490e15cf5405bcfbdeef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7faec1c30046769d4ae490e15cf5405bcfbdeef8", "html_url": "https://github.com/rust-lang/rust/commit/7faec1c30046769d4ae490e15cf5405bcfbdeef8"}, {"sha": "da850361ba22c78ed3579c33d6748735dcd2885c", "url": "https://api.github.com/repos/rust-lang/rust/commits/da850361ba22c78ed3579c33d6748735dcd2885c", "html_url": "https://github.com/rust-lang/rust/commit/da850361ba22c78ed3579c33d6748735dcd2885c"}], "stats": {"total": 1331, "additions": 672, "deletions": 659}, "files": [{"sha": "f669ab96952d44efffcbf9bfb2b80499149e7b60", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "patch": "@@ -169,13 +169,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDef) -> Substs;\n \n-    #[salsa::invoke(crate::expr::body_with_source_map_query)]\n+    #[salsa::invoke(crate::expr::lower::body_with_source_map_query)]\n     fn body_with_source_map(\n         &self,\n         def: DefWithBody,\n     ) -> (Arc<crate::expr::Body>, Arc<crate::expr::BodySourceMap>);\n \n-    #[salsa::invoke(crate::expr::body_hir_query)]\n+    #[salsa::invoke(crate::expr::lower::body_hir_query)]\n     fn body_hir(&self, def: DefWithBody) -> Arc<crate::expr::Body>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]"}, {"sha": "bfd250f3815eafdf8d80eec514627bbc35dc3ac8", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 14, "deletions": 653, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "patch": "@@ -1,36 +1,30 @@\n-use std::ops::Index;\n-use std::sync::Arc;\n+pub(crate) mod lower;\n+pub(crate) mod scope;\n+pub(crate) mod validation;\n \n-use rustc_hash::FxHashMap;\n+use std::{ops::Index, sync::Arc};\n \n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n-use ra_syntax::{\n-    ast::{\n-        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n-        TypeAscriptionOwner,\n-    },\n-    AstNode, AstPtr,\n-};\n-use test_utils::tested_by;\n+use ra_syntax::{ast, AstPtr};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n-    name::{AsName, SELF_PARAM},\n     path::GenericArgs,\n-    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n+    ty::primitive::{UncertainFloatTy, UncertainIntTy},\n     type_ref::{Mutability, TypeRef},\n-    DefWithBody, Either, HasSource, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind, Name,\n-    Path, Resolver,\n+    DefWithBody, Either, HirDatabase, Name, Path, Resolver,\n };\n \n pub use self::scope::ExprScopes;\n \n-pub(crate) mod scope;\n-pub(crate) mod validation;\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n impl_arena_id!(ExprId);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PatId(RawId);\n+impl_arena_id!(PatId);\n+\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n@@ -433,10 +427,6 @@ impl Expr {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct PatId(RawId);\n-impl_arena_id!(PatId);\n-\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n@@ -482,7 +472,7 @@ pub enum Pat {\n     Missing,\n     Wild,\n     Tuple(Vec<PatId>),\n-    Struct {\n+    Record {\n         path: Option<Path>,\n         args: Vec<RecordFieldPat>,\n         // FIXME: 'ellipsis' option\n@@ -528,638 +518,9 @@ impl Pat {\n                 let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n                 total_iter.copied().for_each(f);\n             }\n-            Pat::Struct { args, .. } => {\n+            Pat::Record { args, .. } => {\n                 args.iter().map(|f| f.pat).for_each(f);\n             }\n         }\n     }\n }\n-\n-// Queries\n-\n-pub(crate) struct ExprCollector<DB> {\n-    db: DB,\n-    owner: DefWithBody,\n-    exprs: Arena<ExprId, Expr>,\n-    pats: Arena<PatId, Pat>,\n-    source_map: BodySourceMap,\n-    params: Vec<PatId>,\n-    body_expr: Option<ExprId>,\n-    resolver: Resolver,\n-    // Expr collector expands macros along the way. original points to the file\n-    // we started with, current points to the current macro expansion. source\n-    // maps don't support macros yet, so we only record info into source map if\n-    // current == original (see #1196)\n-    original_file_id: HirFileId,\n-    current_file_id: HirFileId,\n-}\n-\n-impl<'a, DB> ExprCollector<&'a DB>\n-where\n-    DB: HirDatabase,\n-{\n-    fn new(owner: DefWithBody, file_id: HirFileId, resolver: Resolver, db: &'a DB) -> Self {\n-        ExprCollector {\n-            owner,\n-            resolver,\n-            db,\n-            exprs: Arena::default(),\n-            pats: Arena::default(),\n-            source_map: BodySourceMap::default(),\n-            params: Vec::new(),\n-            body_expr: None,\n-            original_file_id: file_id,\n-            current_file_id: file_id,\n-        }\n-    }\n-    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n-        let ptr = Either::A(ptr);\n-        let id = self.exprs.alloc(expr);\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.expr_map.insert(ptr, id);\n-            self.source_map.expr_map_back.insert(id, ptr);\n-        }\n-        id\n-    }\n-\n-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let id = self.pats.alloc(pat);\n-\n-        if self.current_file_id == self.original_file_id {\n-            self.source_map.pat_map.insert(ptr, id);\n-            self.source_map.pat_map_back.insert(id, ptr);\n-        }\n-\n-        id\n-    }\n-\n-    fn empty_block(&mut self) -> ExprId {\n-        let block = Expr::Block { statements: Vec::new(), tail: None };\n-        self.exprs.alloc(block)\n-    }\n-\n-    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n-        let syntax_ptr = AstPtr::new(&expr);\n-        match expr {\n-            ast::Expr::IfExpr(e) => {\n-                let then_branch = self.collect_block_opt(e.then_branch());\n-\n-                let else_branch = e.else_branch().map(|b| match b {\n-                    ast::ElseBranch::Block(it) => self.collect_block(it),\n-                    ast::ElseBranch::IfExpr(elif) => {\n-                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n-                        self.collect_expr(expr)\n-                    }\n-                });\n-\n-                let condition = match e.condition() {\n-                    None => self.exprs.alloc(Expr::Missing),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n-                            let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n-                                MatchArm {\n-                                    pats: vec![placeholder_pat],\n-                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n-                                    guard: None,\n-                                },\n-                            ];\n-                            return self\n-                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n-                        }\n-                    },\n-                };\n-\n-                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n-            }\n-            ast::Expr::TryBlockExpr(e) => {\n-                let body = self.collect_block_opt(e.body());\n-                self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n-            }\n-            ast::Expr::BlockExpr(e) => self.collect_block(e),\n-            ast::Expr::LoopExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n-            }\n-            ast::Expr::WhileExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body());\n-\n-                let condition = match e.condition() {\n-                    None => self.exprs.alloc(Expr::Missing),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            tested_by!(infer_while_let);\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n-                            let break_ = self.exprs.alloc(Expr::Break { expr: None });\n-                            let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: body, guard: None },\n-                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n-                            ];\n-                            let match_expr =\n-                                self.exprs.alloc(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n-                        }\n-                    },\n-                };\n-\n-                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n-            }\n-            ast::Expr::ForExpr(e) => {\n-                let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n-            }\n-            ast::Expr::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n-            }\n-            ast::Expr::MethodCallExpr(e) => {\n-                let receiver = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n-                self.alloc_expr(\n-                    Expr::MethodCall { receiver, method_name, args, generic_args },\n-                    syntax_ptr,\n-                )\n-            }\n-            ast::Expr::MatchExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n-                    match_arm_list\n-                        .arms()\n-                        .map(|arm| MatchArm {\n-                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n-                            expr: self.collect_expr_opt(arm.expr()),\n-                            guard: arm\n-                                .guard()\n-                                .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e)),\n-                        })\n-                        .collect()\n-                } else {\n-                    Vec::new()\n-                };\n-                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n-            }\n-            ast::Expr::PathExpr(e) => {\n-                let path =\n-                    e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n-                self.alloc_expr(path, syntax_ptr)\n-            }\n-            ast::Expr::ContinueExpr(_e) => {\n-                // FIXME: labels\n-                self.alloc_expr(Expr::Continue, syntax_ptr)\n-            }\n-            ast::Expr::BreakExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n-            }\n-            ast::Expr::ParenExpr(e) => {\n-                let inner = self.collect_expr_opt(e.expr());\n-                // make the paren expr point to the inner expression as well\n-                self.source_map.expr_map.insert(Either::A(syntax_ptr), inner);\n-                inner\n-            }\n-            ast::Expr::ReturnExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n-            }\n-            ast::Expr::RecordLit(e) => {\n-                let path = e.path().and_then(Path::from_ast);\n-                let mut field_ptrs = Vec::new();\n-                let record_lit = if let Some(nfl) = e.record_field_list() {\n-                    let fields = nfl\n-                        .fields()\n-                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n-                        .map(|field| RecordLitField {\n-                            name: field\n-                                .name_ref()\n-                                .map(|nr| nr.as_name())\n-                                .unwrap_or_else(Name::missing),\n-                            expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e)\n-                            } else if let Some(nr) = field.name_ref() {\n-                                // field shorthand\n-                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(&nr)));\n-                                let ptr = Either::B(AstPtr::new(&field));\n-                                self.source_map.expr_map.insert(ptr, id);\n-                                self.source_map.expr_map_back.insert(id, ptr);\n-                                id\n-                            } else {\n-                                self.exprs.alloc(Expr::Missing)\n-                            },\n-                        })\n-                        .collect();\n-                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    Expr::RecordLit { path, fields, spread }\n-                } else {\n-                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n-                };\n-\n-                let res = self.alloc_expr(record_lit, syntax_ptr);\n-                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n-                    self.source_map.field_map.insert((res, i), ptr);\n-                }\n-                res\n-            }\n-            ast::Expr::FieldExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let name = match e.field_access() {\n-                    Some(kind) => kind.as_name(),\n-                    _ => Name::missing(),\n-                };\n-                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n-            }\n-            ast::Expr::AwaitExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n-            }\n-            ast::Expr::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n-            }\n-            ast::Expr::CastExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n-                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n-            }\n-            ast::Expr::RefExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                let mutability = Mutability::from_mutable(e.is_mut());\n-                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n-            }\n-            ast::Expr::PrefixExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                if let Some(op) = e.op_kind() {\n-                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n-                } else {\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                }\n-            }\n-            ast::Expr::LambdaExpr(e) => {\n-                let mut args = Vec::new();\n-                let mut arg_types = Vec::new();\n-                if let Some(pl) = e.param_list() {\n-                    for param in pl.params() {\n-                        let pat = self.collect_pat_opt(param.pat());\n-                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n-                        args.push(pat);\n-                        arg_types.push(type_ref);\n-                    }\n-                }\n-                let body = self.collect_expr_opt(e.body());\n-                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n-            }\n-            ast::Expr::BinExpr(e) => {\n-                let lhs = self.collect_expr_opt(e.lhs());\n-                let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind().map(BinaryOp::from);\n-                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n-            }\n-            ast::Expr::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n-            }\n-\n-            ast::Expr::ArrayExpr(e) => {\n-                let kind = e.kind();\n-\n-                match kind {\n-                    ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n-                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n-                    }\n-                    ArrayExprKind::Repeat { initializer, repeat } => {\n-                        let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n-                        self.alloc_expr(\n-                            Expr::Array(Array::Repeat { initializer, repeat }),\n-                            syntax_ptr,\n-                        )\n-                    }\n-                }\n-            }\n-\n-            ast::Expr::Literal(e) => {\n-                let lit = match e.kind() {\n-                    LiteralKind::IntNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| IntTy::from_suffix(&it).map(UncertainIntTy::Known));\n-\n-                        Literal::Int(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainIntTy::Unknown),\n-                        )\n-                    }\n-                    LiteralKind::FloatNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| FloatTy::from_suffix(&it).map(UncertainFloatTy::Known));\n-\n-                        Literal::Float(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainFloatTy::Unknown),\n-                        )\n-                    }\n-                    LiteralKind::ByteString => Literal::ByteString(Default::default()),\n-                    LiteralKind::String => Literal::String(Default::default()),\n-                    LiteralKind::Byte => {\n-                        Literal::Int(Default::default(), UncertainIntTy::Known(IntTy::u8()))\n-                    }\n-                    LiteralKind::Bool => Literal::Bool(Default::default()),\n-                    LiteralKind::Char => Literal::Char(Default::default()),\n-                };\n-                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n-            }\n-            ast::Expr::IndexExpr(e) => {\n-                let base = self.collect_expr_opt(e.base());\n-                let index = self.collect_expr_opt(e.index());\n-                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n-            }\n-\n-            // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::MacroCall(e) => {\n-                let ast_id = self\n-                    .db\n-                    .ast_id_map(self.current_file_id)\n-                    .ast_id(&e)\n-                    .with_file_id(self.current_file_id);\n-\n-                if let Some(path) = e.path().and_then(Path::from_ast) {\n-                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n-                        let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n-                        let file_id = call_id.as_file(MacroFileKind::Expr);\n-                        if let Some(node) = self.db.parse_or_expand(file_id) {\n-                            if let Some(expr) = ast::Expr::cast(node) {\n-                                log::debug!(\"macro expansion {:#?}\", expr.syntax());\n-                                let old_file_id =\n-                                    std::mem::replace(&mut self.current_file_id, file_id);\n-                                let id = self.collect_expr(expr);\n-                                self.current_file_id = old_file_id;\n-                                return id;\n-                            }\n-                        }\n-                    }\n-                }\n-                // FIXME: Instead of just dropping the error from expansion\n-                // report it\n-                self.alloc_expr(Expr::Missing, syntax_ptr)\n-            }\n-        }\n-    }\n-\n-    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n-        if let Some(expr) = expr {\n-            self.collect_expr(expr)\n-        } else {\n-            self.exprs.alloc(Expr::Missing)\n-        }\n-    }\n-\n-    fn collect_block(&mut self, expr: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&expr.clone().into());\n-        let block = match expr.block() {\n-            Some(block) => block,\n-            None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n-        };\n-        let statements = block\n-            .statements()\n-            .map(|s| match s {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n-                }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n-            })\n-            .collect();\n-        let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n-    }\n-\n-    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n-        if let Some(block) = expr {\n-            self.collect_block(block)\n-        } else {\n-            self.exprs.alloc(Expr::Missing)\n-        }\n-    }\n-\n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pattern = match &pat {\n-            ast::Pat::BindPat(bp) => {\n-                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n-                Pat::Bind { name, mode: annotation, subpat }\n-            }\n-            ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::TupleStruct { path, args }\n-            }\n-            ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt(p.pat());\n-                let mutability = Mutability::from_mutable(p.is_mut());\n-                Pat::Ref { pat, mutability }\n-            }\n-            ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n-                path.map(Pat::Path).unwrap_or(Pat::Missing)\n-            }\n-            ast::Pat::TuplePat(p) => {\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::Tuple(args)\n-            }\n-            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n-            ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n-                let record_field_pat_list =\n-                    p.record_field_pat_list().expect(\"every struct should have a field list\");\n-                let mut fields: Vec<_> = record_field_pat_list\n-                    .bind_pats()\n-                    .filter_map(|bind_pat| {\n-                        let ast_pat =\n-                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n-                        let pat = self.collect_pat(ast_pat);\n-                        let name = bind_pat.name()?.as_name();\n-                        Some(RecordFieldPat { name, pat })\n-                    })\n-                    .collect();\n-                let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n-                    let ast_pat = f.pat()?;\n-                    let pat = self.collect_pat(ast_pat);\n-                    let name = f.name()?.as_name();\n-                    Some(RecordFieldPat { name, pat })\n-                });\n-                fields.extend(iter);\n-\n-                Pat::Struct { path, args: fields }\n-            }\n-\n-            // FIXME: implement\n-            ast::Pat::BoxPat(_) => Pat::Missing,\n-            ast::Pat::LiteralPat(_) => Pat::Missing,\n-            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n-        };\n-        let ptr = AstPtr::new(&pat);\n-        self.alloc_pat(pattern, Either::A(ptr))\n-    }\n-\n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n-        if let Some(pat) = pat {\n-            self.collect_pat(pat)\n-        } else {\n-            self.pats.alloc(Pat::Missing)\n-        }\n-    }\n-\n-    fn collect_const_body(&mut self, node: ast::ConstDef) {\n-        let body = self.collect_expr_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn collect_static_body(&mut self, node: ast::StaticDef) {\n-        let body = self.collect_expr_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn collect_fn_body(&mut self, node: ast::FnDef) {\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: SELF_PARAM,\n-                        mode: BindingAnnotation::Unannotated,\n-                        subpat: None,\n-                    },\n-                    Either::B(ptr),\n-                );\n-                self.params.push(param_pat);\n-            }\n-\n-            for param in param_list.params() {\n-                let pat = if let Some(pat) = param.pat() {\n-                    pat\n-                } else {\n-                    continue;\n-                };\n-                let param_pat = self.collect_pat(pat);\n-                self.params.push(param_pat);\n-            }\n-        };\n-\n-        let body = self.collect_block_opt(node.body());\n-        self.body_expr = Some(body);\n-    }\n-\n-    fn finish(self) -> (Body, BodySourceMap) {\n-        let body = Body {\n-            owner: self.owner,\n-            exprs: self.exprs,\n-            pats: self.pats,\n-            params: self.params,\n-            body_expr: self.body_expr.expect(\"A body should have been collected\"),\n-        };\n-        (body, self.source_map)\n-    }\n-}\n-\n-impl From<ast::BinOp> for BinaryOp {\n-    fn from(ast_op: ast::BinOp) -> Self {\n-        match ast_op {\n-            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n-            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n-            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n-            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n-            ast::BinOp::LesserEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n-            }\n-            ast::BinOp::GreaterEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n-            }\n-            ast::BinOp::LesserTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n-            }\n-            ast::BinOp::GreaterTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n-            }\n-            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n-            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n-            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n-            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n-            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n-            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n-            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n-            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n-            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n-            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n-            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n-            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n-            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n-            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n-            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n-            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n-            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n-            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n-            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n-            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n-            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n-        }\n-    }\n-}\n-\n-pub(crate) fn body_with_source_map_query(\n-    db: &impl HirDatabase,\n-    def: DefWithBody,\n-) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector;\n-\n-    match def {\n-        DefWithBody::Const(ref c) => {\n-            let src = c.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_const_body(src.ast)\n-        }\n-        DefWithBody::Function(ref f) => {\n-            let src = f.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_fn_body(src.ast)\n-        }\n-        DefWithBody::Static(ref s) => {\n-            let src = s.source(db);\n-            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n-            collector.collect_static_body(src.ast)\n-        }\n-    }\n-\n-    let (body, source_map) = collector.finish();\n-    (Arc::new(body), Arc::new(source_map))\n-}\n-\n-pub(crate) fn body_hir_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n-    db.body_with_source_map(def).0\n-}"}, {"sha": "f6a75a379f809cc17c9dbffb4993ab3e555f0d5e", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "added", "additions": 652, "deletions": 0, "changes": 652, "blob_url": "https://github.com/rust-lang/rust/blob/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "patch": "@@ -0,0 +1,652 @@\n+use std::sync::Arc;\n+\n+use ra_arena::Arena;\n+use ra_syntax::{\n+    ast::{\n+        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n+        TypeAscriptionOwner,\n+    },\n+    AstNode, AstPtr,\n+};\n+use test_utils::tested_by;\n+\n+use crate::{\n+    name::{AsName, Name, SELF_PARAM},\n+    path::GenericArgs,\n+    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n+    type_ref::TypeRef,\n+    DefWithBody, Either, HasSource, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind,\n+    Mutability, Path, Resolver,\n+};\n+\n+use super::{\n+    ArithOp, Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, CmpOp, Expr, ExprId, Literal,\n+    LogicOp, MatchArm, Ordering, Pat, PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n+};\n+\n+pub(crate) struct ExprCollector<DB> {\n+    db: DB,\n+    owner: DefWithBody,\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    source_map: BodySourceMap,\n+    params: Vec<PatId>,\n+    body_expr: Option<ExprId>,\n+    resolver: Resolver,\n+    // Expr collector expands macros along the way. original points to the file\n+    // we started with, current points to the current macro expansion. source\n+    // maps don't support macros yet, so we only record info into source map if\n+    // current == original (see #1196)\n+    original_file_id: HirFileId,\n+    current_file_id: HirFileId,\n+}\n+\n+impl<'a, DB> ExprCollector<&'a DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn new(owner: DefWithBody, file_id: HirFileId, resolver: Resolver, db: &'a DB) -> Self {\n+        ExprCollector {\n+            owner,\n+            resolver,\n+            db,\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            source_map: BodySourceMap::default(),\n+            params: Vec::new(),\n+            body_expr: None,\n+            original_file_id: file_id,\n+            current_file_id: file_id,\n+        }\n+    }\n+    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n+        let ptr = Either::A(ptr);\n+        let id = self.exprs.alloc(expr);\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.expr_map.insert(ptr, id);\n+            self.source_map.expr_map_back.insert(id, ptr);\n+        }\n+        id\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let id = self.pats.alloc(pat);\n+\n+        if self.current_file_id == self.original_file_id {\n+            self.source_map.pat_map.insert(ptr, id);\n+            self.source_map.pat_map_back.insert(id, ptr);\n+        }\n+\n+        id\n+    }\n+\n+    fn empty_block(&mut self) -> ExprId {\n+        let block = Expr::Block { statements: Vec::new(), tail: None };\n+        self.exprs.alloc(block)\n+    }\n+\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        let syntax_ptr = AstPtr::new(&expr);\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+\n+                let else_branch = e.else_branch().map(|b| match b {\n+                    ast::ElseBranch::Block(it) => self.collect_block(it),\n+                    ast::ElseBranch::IfExpr(elif) => {\n+                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n+                        self.collect_expr(expr)\n+                    }\n+                });\n+\n+                let condition = match e.condition() {\n+                    None => self.exprs.alloc(Expr::Missing),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                                MatchArm {\n+                                    pats: vec![placeholder_pat],\n+                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                                    guard: None,\n+                                },\n+                            ];\n+                            return self\n+                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n+            }\n+            ast::Expr::TryBlockExpr(e) => {\n+                let body = self.collect_block_opt(e.body());\n+                self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+            }\n+            ast::Expr::BlockExpr(e) => self.collect_block(e),\n+            ast::Expr::LoopExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+\n+                let condition = match e.condition() {\n+                    None => self.exprs.alloc(Expr::Missing),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            tested_by!(infer_while_let);\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let break_ = self.exprs.alloc(Expr::Break { expr: None });\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: body, guard: None },\n+                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n+                            ];\n+                            let match_expr =\n+                                self.exprs.alloc(Expr::Match { expr: match_expr, arms });\n+                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                let iterable = self.collect_expr_opt(e.iterable());\n+                let pat = self.collect_pat_opt(e.pat());\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let receiver = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n+                self.alloc_expr(\n+                    Expr::MethodCall { receiver, method_name, args, generic_args },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .map(|arm| MatchArm {\n+                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n+                            expr: self.collect_expr_opt(arm.expr()),\n+                            guard: arm\n+                                .guard()\n+                                .and_then(|guard| guard.expr())\n+                                .map(|e| self.collect_expr(e)),\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                let path =\n+                    e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n+                self.alloc_expr(path, syntax_ptr)\n+            }\n+            ast::Expr::ContinueExpr(_e) => {\n+                // FIXME: labels\n+                self.alloc_expr(Expr::Continue, syntax_ptr)\n+            }\n+            ast::Expr::BreakExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                let inner = self.collect_expr_opt(e.expr());\n+                // make the paren expr point to the inner expression as well\n+                self.source_map.expr_map.insert(Either::A(syntax_ptr), inner);\n+                inner\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+            }\n+            ast::Expr::RecordLit(e) => {\n+                let path = e.path().and_then(Path::from_ast);\n+                let mut field_ptrs = Vec::new();\n+                let record_lit = if let Some(nfl) = e.record_field_list() {\n+                    let fields = nfl\n+                        .fields()\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n+                        .map(|field| RecordLitField {\n+                            name: field\n+                                .name_ref()\n+                                .map(|nr| nr.as_name())\n+                                .unwrap_or_else(Name::missing),\n+                            expr: if let Some(e) = field.expr() {\n+                                self.collect_expr(e)\n+                            } else if let Some(nr) = field.name_ref() {\n+                                // field shorthand\n+                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(&nr)));\n+                                let ptr = Either::B(AstPtr::new(&field));\n+                                self.source_map.expr_map.insert(ptr, id);\n+                                self.source_map.expr_map_back.insert(id, ptr);\n+                                id\n+                            } else {\n+                                self.exprs.alloc(Expr::Missing)\n+                            },\n+                        })\n+                        .collect();\n+                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n+                    Expr::RecordLit { path, fields, spread }\n+                } else {\n+                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n+                };\n+\n+                let res = self.alloc_expr(record_lit, syntax_ptr);\n+                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n+                    self.source_map.field_map.insert((res, i), ptr);\n+                }\n+                res\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let name = match e.field_access() {\n+                    Some(kind) => kind.as_name(),\n+                    _ => Name::missing(),\n+                };\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+            }\n+            ast::Expr::AwaitExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let mutability = Mutability::from_mutable(e.is_mut());\n+                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                if let Some(op) = e.op_kind() {\n+                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n+            ast::Expr::LambdaExpr(e) => {\n+                let mut args = Vec::new();\n+                let mut arg_types = Vec::new();\n+                if let Some(pl) = e.param_list() {\n+                    for param in pl.params() {\n+                        let pat = self.collect_pat_opt(param.pat());\n+                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n+                        args.push(pat);\n+                        arg_types.push(type_ref);\n+                    }\n+                }\n+                let body = self.collect_expr_opt(e.body());\n+                self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n+            }\n+            ast::Expr::BinExpr(e) => {\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n+                let op = e.op_kind().map(BinaryOp::from);\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+            }\n+            ast::Expr::TupleExpr(e) => {\n+                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n+                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+            }\n+\n+            ast::Expr::ArrayExpr(e) => {\n+                let kind = e.kind();\n+\n+                match kind {\n+                    ArrayExprKind::ElementList(e) => {\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                    }\n+                    ArrayExprKind::Repeat { initializer, repeat } => {\n+                        let initializer = self.collect_expr_opt(initializer);\n+                        let repeat = self.collect_expr_opt(repeat);\n+                        self.alloc_expr(\n+                            Expr::Array(Array::Repeat { initializer, repeat }),\n+                            syntax_ptr,\n+                        )\n+                    }\n+                }\n+            }\n+\n+            ast::Expr::Literal(e) => {\n+                let lit = match e.kind() {\n+                    LiteralKind::IntNumber { suffix } => {\n+                        let known_name = suffix\n+                            .and_then(|it| IntTy::from_suffix(&it).map(UncertainIntTy::Known));\n+\n+                        Literal::Int(\n+                            Default::default(),\n+                            known_name.unwrap_or(UncertainIntTy::Unknown),\n+                        )\n+                    }\n+                    LiteralKind::FloatNumber { suffix } => {\n+                        let known_name = suffix\n+                            .and_then(|it| FloatTy::from_suffix(&it).map(UncertainFloatTy::Known));\n+\n+                        Literal::Float(\n+                            Default::default(),\n+                            known_name.unwrap_or(UncertainFloatTy::Unknown),\n+                        )\n+                    }\n+                    LiteralKind::ByteString => Literal::ByteString(Default::default()),\n+                    LiteralKind::String => Literal::String(Default::default()),\n+                    LiteralKind::Byte => {\n+                        Literal::Int(Default::default(), UncertainIntTy::Known(IntTy::u8()))\n+                    }\n+                    LiteralKind::Bool => Literal::Bool(Default::default()),\n+                    LiteralKind::Char => Literal::Char(Default::default()),\n+                };\n+                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n+            }\n+            ast::Expr::IndexExpr(e) => {\n+                let base = self.collect_expr_opt(e.base());\n+                let index = self.collect_expr_opt(e.index());\n+                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n+            }\n+\n+            // FIXME implement HIR for these:\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::MacroCall(e) => {\n+                let ast_id = self\n+                    .db\n+                    .ast_id_map(self.current_file_id)\n+                    .ast_id(&e)\n+                    .with_file_id(self.current_file_id);\n+\n+                if let Some(path) = e.path().and_then(Path::from_ast) {\n+                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n+                        let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n+                        let file_id = call_id.as_file(MacroFileKind::Expr);\n+                        if let Some(node) = self.db.parse_or_expand(file_id) {\n+                            if let Some(expr) = ast::Expr::cast(node) {\n+                                log::debug!(\"macro expansion {:#?}\", expr.syntax());\n+                                let old_file_id =\n+                                    std::mem::replace(&mut self.current_file_id, file_id);\n+                                let id = self.collect_expr(expr);\n+                                self.current_file_id = old_file_id;\n+                                return id;\n+                            }\n+                        }\n+                    }\n+                }\n+                // FIXME: Instead of just dropping the error from expansion\n+                // report it\n+                self.alloc_expr(Expr::Missing, syntax_ptr)\n+            }\n+        }\n+    }\n+\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+        if let Some(expr) = expr {\n+            self.collect_expr(expr)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_block(&mut self, expr: ast::BlockExpr) -> ExprId {\n+        let syntax_node_ptr = AstPtr::new(&expr.clone().into());\n+        let block = match expr.block() {\n+            Some(block) => block,\n+            None => return self.alloc_expr(Expr::Missing, syntax_node_ptr),\n+        };\n+        let statements = block\n+            .statements()\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    Statement::Let { pat, type_ref, initializer }\n+                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+            })\n+            .collect();\n+        let tail = block.expr().map(|e| self.collect_expr(e));\n+        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n+    }\n+\n+    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n+        if let Some(block) = expr {\n+            self.collect_block(block)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let pattern = match &pat {\n+            ast::Pat::BindPat(bp) => {\n+                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n+                Pat::Bind { name, mode: annotation, subpat }\n+            }\n+            ast::Pat::TupleStructPat(p) => {\n+                let path = p.path().and_then(Path::from_ast);\n+                let args = p.args().map(|p| self.collect_pat(p)).collect();\n+                Pat::TupleStruct { path, args }\n+            }\n+            ast::Pat::RefPat(p) => {\n+                let pat = self.collect_pat_opt(p.pat());\n+                let mutability = Mutability::from_mutable(p.is_mut());\n+                Pat::Ref { pat, mutability }\n+            }\n+            ast::Pat::PathPat(p) => {\n+                let path = p.path().and_then(Path::from_ast);\n+                path.map(Pat::Path).unwrap_or(Pat::Missing)\n+            }\n+            ast::Pat::TuplePat(p) => {\n+                let args = p.args().map(|p| self.collect_pat(p)).collect();\n+                Pat::Tuple(args)\n+            }\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n+            ast::Pat::RecordPat(p) => {\n+                let path = p.path().and_then(Path::from_ast);\n+                let record_field_pat_list =\n+                    p.record_field_pat_list().expect(\"every struct should have a field list\");\n+                let mut fields: Vec<_> = record_field_pat_list\n+                    .bind_pats()\n+                    .filter_map(|bind_pat| {\n+                        let ast_pat =\n+                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n+                        let pat = self.collect_pat(ast_pat);\n+                        let name = bind_pat.name()?.as_name();\n+                        Some(RecordFieldPat { name, pat })\n+                    })\n+                    .collect();\n+                let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n+                    let ast_pat = f.pat()?;\n+                    let pat = self.collect_pat(ast_pat);\n+                    let name = f.name()?.as_name();\n+                    Some(RecordFieldPat { name, pat })\n+                });\n+                fields.extend(iter);\n+\n+                Pat::Record { path, args: fields }\n+            }\n+\n+            // FIXME: implement\n+            ast::Pat::BoxPat(_) => Pat::Missing,\n+            ast::Pat::LiteralPat(_) => Pat::Missing,\n+            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n+        };\n+        let ptr = AstPtr::new(&pat);\n+        self.alloc_pat(pattern, Either::A(ptr))\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        if let Some(pat) = pat {\n+            self.collect_pat(pat)\n+        } else {\n+            self.pats.alloc(Pat::Missing)\n+        }\n+    }\n+\n+    fn collect_const_body(&mut self, node: ast::ConstDef) {\n+        let body = self.collect_expr_opt(node.body());\n+        self.body_expr = Some(body);\n+    }\n+\n+    fn collect_static_body(&mut self, node: ast::StaticDef) {\n+        let body = self.collect_expr_opt(node.body());\n+        self.body_expr = Some(body);\n+    }\n+\n+    fn collect_fn_body(&mut self, node: ast::FnDef) {\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let ptr = AstPtr::new(&self_param);\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: SELF_PARAM,\n+                        mode: BindingAnnotation::Unannotated,\n+                        subpat: None,\n+                    },\n+                    Either::B(ptr),\n+                );\n+                self.params.push(param_pat);\n+            }\n+\n+            for param in param_list.params() {\n+                let pat = if let Some(pat) = param.pat() {\n+                    pat\n+                } else {\n+                    continue;\n+                };\n+                let param_pat = self.collect_pat(pat);\n+                self.params.push(param_pat);\n+            }\n+        };\n+\n+        let body = self.collect_block_opt(node.body());\n+        self.body_expr = Some(body);\n+    }\n+\n+    fn finish(self) -> (Body, BodySourceMap) {\n+        let body = Body {\n+            owner: self.owner,\n+            exprs: self.exprs,\n+            pats: self.pats,\n+            params: self.params,\n+            body_expr: self.body_expr.expect(\"A body should have been collected\"),\n+        };\n+        (body, self.source_map)\n+    }\n+}\n+\n+impl From<ast::BinOp> for BinaryOp {\n+    fn from(ast_op: ast::BinOp) -> Self {\n+        match ast_op {\n+            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n+            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n+            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n+            ast::BinOp::LesserEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n+            }\n+            ast::BinOp::GreaterEqualTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n+            }\n+            ast::BinOp::LesserTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n+            }\n+            ast::BinOp::GreaterTest => {\n+                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n+            }\n+            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n+            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n+            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n+            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n+            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n+            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n+            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n+            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n+            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n+            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n+            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n+            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n+            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n+            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n+            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n+            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n+            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n+            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n+            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n+            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n+            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n+        }\n+    }\n+}\n+\n+pub(crate) fn body_with_source_map_query(\n+    db: &impl HirDatabase,\n+    def: DefWithBody,\n+) -> (Arc<Body>, Arc<BodySourceMap>) {\n+    let mut collector;\n+\n+    match def {\n+        DefWithBody::Const(ref c) => {\n+            let src = c.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_const_body(src.ast)\n+        }\n+        DefWithBody::Function(ref f) => {\n+            let src = f.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_fn_body(src.ast)\n+        }\n+        DefWithBody::Static(ref s) => {\n+            let src = s.source(db);\n+            collector = ExprCollector::new(def, src.file_id, def.resolver(db), db);\n+            collector.collect_static_body(src.ast)\n+        }\n+    }\n+\n+    let (body, source_map) = collector.finish();\n+    (Arc::new(body), Arc::new(source_map))\n+}\n+\n+pub(crate) fn body_hir_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n+    db.body_with_source_map(def).0\n+}"}, {"sha": "b89a40b4b2f6eb0b25bc1f928f89a3c14370ef18", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c64f68d4a235e4ea7cc974711dcd181d10c55dc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=6c64f68d4a235e4ea7cc974711dcd181d10c55dc", "patch": "@@ -749,7 +749,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let is_non_ref_pat = match &body[pat] {\n             Pat::Tuple(..)\n             | Pat::TupleStruct { .. }\n-            | Pat::Struct { .. }\n+            | Pat::Record { .. }\n             | Pat::Range { .. }\n             | Pat::Slice { .. } => true,\n             // FIXME: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n@@ -806,18 +806,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n-            Pat::TupleStruct { path: ref p, args: ref subpats } => {\n+            Pat::TupleStruct { path: p, args: subpats } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n             }\n-            Pat::Struct { path: ref p, args: ref fields } => {\n+            Pat::Record { path: p, args: fields } => {\n                 self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n                 self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n-            Pat::Bind { mode, name: _name, subpat } => {\n+            Pat::Bind { mode, name: _, subpat } => {\n                 let mode = if mode == &BindingAnnotation::Unannotated {\n                     default_bm\n                 } else {"}]}