{"sha": "b25fe99331a114b92131ecd4bd37abefb2508ff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWZlOTkzMzFhMTE0YjkyMTMxZWNkNGJkMzdhYmVmYjI1MDhmZjA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-04-11T09:28:43Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-04-17T09:42:30Z"}, "message": "Extended `syntax::{fold, ast_map}` to include lifetimes.\n\nPart of this required added an override of `fold_type_method` in the\nFolder for Ctx impl; it follows the same pattern as `fold_method`.\n\nAlso, as a drive-by fix, I moved all of the calls to `folder.new_id`\nin syntax::fold's no-op default traversal to really be the first\nstatement in each function.\n\n  * This is to uphold the invariant that `folder.new_id` is always\n    called first (an unfortunate requirement of the current `ast_map`\n    code), an invariant that we seemingly were breaking in e.g. the\n    previous `noop_fold_block`.\n\n  * Now it should be easier to see when adding new code that this\n    invariant must be upheld.\n\n  * (note that the breakage in `noop_fold_block` may not have mattered\n    so much previously, since the only thing that blocks can bind are\n    lifetimes, which I am only adding support for now.)", "tree": {"sha": "940fd3c9b8a0b4ef3a2cef514f8192754235683c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/940fd3c9b8a0b4ef3a2cef514f8192754235683c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25fe99331a114b92131ecd4bd37abefb2508ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25fe99331a114b92131ecd4bd37abefb2508ff0", "html_url": "https://github.com/rust-lang/rust/commit/b25fe99331a114b92131ecd4bd37abefb2508ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25fe99331a114b92131ecd4bd37abefb2508ff0/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e30f07abc76587f676e91770b7630ac9727b2cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e30f07abc76587f676e91770b7630ac9727b2cb", "html_url": "https://github.com/rust-lang/rust/commit/0e30f07abc76587f676e91770b7630ac9727b2cb"}], "stats": {"total": 119, "additions": 86, "deletions": 33}, "files": [{"sha": "f7b444e439f406d378f1fc052359cad43db2cc77", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b25fe99331a114b92131ecd4bd37abefb2508ff0", "patch": "@@ -272,6 +272,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n \n         // Ugh -- but this ensures any new variants won't be forgotten\n+        ast_map::NodeLifetime(..) |\n         ast_map::NodeExpr(..) |\n         ast_map::NodeStmt(..) |\n         ast_map::NodeArg(..) |"}, {"sha": "45954800e7e9a0fdc619eb2d162dd5a42481f1f6", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b25fe99331a114b92131ecd4bd37abefb2508ff0", "patch": "@@ -107,6 +107,8 @@ pub enum Node {\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(@StructDef),\n+\n+    NodeLifetime(@Lifetime),\n }\n \n // The odd layout is to bring down the total size.\n@@ -127,6 +129,7 @@ enum MapEntry {\n     EntryLocal(NodeId, @Pat),\n     EntryBlock(NodeId, P<Block>),\n     EntryStructCtor(NodeId, @StructDef),\n+    EntryLifetime(NodeId, @Lifetime),\n \n     // Roots for node trees.\n     RootCrate,\n@@ -153,6 +156,7 @@ impl MapEntry {\n             EntryLocal(id, _) => id,\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n+            EntryLifetime(id, _) => id,\n             _ => return None\n         })\n     }\n@@ -170,6 +174,7 @@ impl MapEntry {\n             EntryLocal(_, p) => NodeLocal(p),\n             EntryBlock(_, p) => NodeBlock(p),\n             EntryStructCtor(_, p) => NodeStructCtor(p),\n+            EntryLifetime(_, p) => NodeLifetime(p),\n             _ => return None\n         })\n     }\n@@ -213,6 +218,8 @@ impl Map {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n+    /// Retrieve the parent NodeId for `id`, or `id` itself if no\n+    /// parent is registered in this map.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n     }\n@@ -500,6 +507,15 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         SmallVector::one(stmt)\n     }\n \n+    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+        let parent = self.parent;\n+        self.parent = DUMMY_NODE_ID;\n+        let m = fold::noop_fold_type_method(m, self);\n+        assert_eq!(self.parent, m.id);\n+        self.parent = parent;\n+        m\n+    }\n+\n     fn fold_method(&mut self, m: @Method) -> @Method {\n         let parent = self.parent;\n         self.parent = DUMMY_NODE_ID;\n@@ -522,6 +538,12 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.insert(block.id, EntryBlock(self.parent, block));\n         block\n     }\n+\n+    fn fold_lifetime(&mut self, lifetime: &Lifetime) -> Lifetime {\n+        let lifetime = fold::noop_fold_lifetime(lifetime, self);\n+        self.insert(lifetime.id, EntryLifetime(self.parent, @lifetime));\n+        lifetime\n+    }\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {\n@@ -658,6 +680,9 @@ fn node_id_to_str(map: &Map, id: NodeId) -> ~str {\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {} (id={})\", map.path_to_str(id), id)\n         }\n+        Some(NodeLifetime(ref l)) => {\n+            format!(\"lifetime {} (id={})\", pprust::lifetime_to_str(*l), id)\n+        }\n         None => {\n             format!(\"unknown node (id={})\", id)\n         }"}, {"sha": "cc3ae025263d196e03b8ce298f9a55d6a0860df5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25fe99331a114b92131ecd4bd37abefb2508ff0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b25fe99331a114b92131ecd4bd37abefb2508ff0", "patch": "@@ -32,14 +32,17 @@ pub trait Folder {\n         view_paths.iter().map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 ViewPathSimple(ref ident, ref path, node_id) => {\n+                    let id = self.new_id(node_id);\n                     ViewPathSimple(ident.clone(),\n                                    self.fold_path(path),\n-                                   self.new_id(node_id))\n+                                   id)\n                 }\n                 ViewPathGlob(ref path, node_id) => {\n-                    ViewPathGlob(self.fold_path(path), self.new_id(node_id))\n+                    let id = self.new_id(node_id);\n+                    ViewPathGlob(self.fold_path(path), id)\n                 }\n                 ViewPathList(ref path, ref path_list_idents, node_id) => {\n+                    let id = self.new_id(node_id);\n                     ViewPathList(self.fold_path(path),\n                                  path_list_idents.iter().map(|path_list_ident| {\n                                     let id = self.new_id(path_list_ident.node\n@@ -55,7 +58,7 @@ pub trait Folder {\n                                             path_list_ident.span)\n                                     }\n                                  }).collect(),\n-                                 self.new_id(node_id))\n+                                 id)\n                 }\n             };\n             @Spanned {\n@@ -78,10 +81,11 @@ pub trait Folder {\n     }\n \n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n+        let id = self.new_id(sf.node.id);\n         Spanned {\n             node: ast::StructField_ {\n                 kind: sf.node.kind,\n-                id: self.new_id(sf.node.id),\n+                id: id,\n                 ty: self.fold_ty(sf.node.ty),\n                 attrs: sf.node.attrs.iter().map(|e| fold_attribute_(*e, self)).collect()\n             },\n@@ -146,6 +150,7 @@ pub trait Folder {\n     }\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n+        let id = self.new_id(t.id);\n         let node = match t.node {\n             TyNil | TyBot | TyInfer => t.node.clone(),\n             TyBox(ty) => TyBox(self.fold_ty(ty)),\n@@ -161,7 +166,7 @@ pub trait Folder {\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 }, fold_opt_lifetime(region, self))\n             }\n             TyProc(ref f) => {\n@@ -170,30 +175,31 @@ pub trait Folder {\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: self.fold_fn_decl(f.decl),\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 })\n             }\n             TyBareFn(ref f) => {\n                 TyBareFn(@BareFnTy {\n-                    lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                    lifetimes: f.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                     fn_style: f.fn_style,\n                     abi: f.abi,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n             TyPath(ref path, ref bounds, id) => {\n+                let id = self.new_id(id);\n                 TyPath(self.fold_path(path),\n                        fold_opt_bounds(bounds, self),\n-                       self.new_id(id))\n+                       id)\n             }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(self.fold_ty(ty), self.fold_expr(e))\n             }\n             TyTypeof(expr) => TyTypeof(self.fold_expr(expr)),\n         };\n         P(Ty {\n-            id: self.new_id(t.id),\n+            id: id,\n             span: self.new_span(t.span),\n             node: node,\n         })\n@@ -218,6 +224,7 @@ pub trait Folder {\n     }\n \n     fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n+        let id = self.new_id(v.node.id);\n         let kind;\n         match v.node.kind {\n             TupleVariantKind(ref variant_args) => {\n@@ -243,7 +250,7 @@ pub trait Folder {\n             name: v.node.name,\n             attrs: attrs,\n             kind: kind,\n-            id: self.new_id(v.node.id),\n+            id: id,\n             disr_expr: de,\n             vis: v.node.vis,\n         };\n@@ -263,15 +270,16 @@ pub trait Folder {\n             global: p.global,\n             segments: p.segments.iter().map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n-                lifetimes: segment.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n+                lifetimes: segment.lifetimes.iter().map(|l| self.fold_lifetime(l)).collect(),\n                 types: segment.types.iter().map(|&typ| self.fold_ty(typ)).collect(),\n             }).collect()\n         }\n     }\n \n     fn fold_local(&mut self, l: @Local) -> @Local {\n+        let id = self.new_id(l.id); // Needs to be first, for ast_map.\n         @Local {\n-            id: self.new_id(l.id), // Needs to be first, for ast_map.\n+            id: id,\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n             init: l.init.map(|e| self.fold_expr(e)),\n@@ -319,6 +327,10 @@ pub trait Folder {\n             }\n         }\n     }\n+\n+    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n+        noop_fold_lifetime(l, self)\n+    }\n }\n \n /* some little folds that probably aren't useful to have in Folder itself*/\n@@ -353,8 +365,9 @@ fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n+    let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n     Arg {\n-        id: fld.new_id(a.id), // Needs to be first, for ast_map.\n+        id: id,\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n     }\n@@ -425,9 +438,10 @@ fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n }\n \n pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n+    let id = fld.new_id(tp.id);\n     TyParam {\n         ident: tp.ident,\n-        id: fld.new_id(tp.id),\n+        id: id,\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n         default: tp.default.map(|x| fld.fold_ty(x))\n     }\n@@ -438,22 +452,23 @@ pub fn fold_ty_params<T: Folder>(tps: &OwnedSlice<TyParam>, fld: &mut T)\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+    let id = fld.new_id(l.id);\n     Lifetime {\n-        id: fld.new_id(l.id),\n+        id: id,\n         span: fld.new_span(l.span),\n         name: l.name\n     }\n }\n \n pub fn fold_lifetimes<T: Folder>(lts: &Vec<Lifetime>, fld: &mut T)\n                                    -> Vec<Lifetime> {\n-    lts.iter().map(|l| fold_lifetime(l, fld)).collect()\n+    lts.iter().map(|l| fld.fold_lifetime(l)).collect()\n }\n \n pub fn fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                       -> Option<Lifetime> {\n-    o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n+    o_lt.as_ref().map(|lt| fld.fold_lifetime(lt))\n }\n \n pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n@@ -469,17 +484,19 @@ fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef\n }\n \n fn fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n+    let id = fld.new_id(p.ref_id);\n     ast::TraitRef {\n         path: fld.fold_path(&p.path),\n-        ref_id: fld.new_id(p.ref_id),\n+        ref_id: id,\n     }\n }\n \n fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n+    let id = fld.new_id(f.node.id);\n     Spanned {\n         node: ast::StructField_ {\n             kind: f.node.kind,\n-            id: fld.new_id(f.node.id),\n+            id: id,\n             ty: fld.fold_ty(f.node.ty),\n             attrs: f.node.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         },\n@@ -512,9 +529,10 @@ fn fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut\n }\n \n fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n+    let id = folder.new_id(va.id);\n     ast::VariantArg {\n         ty: folder.fold_ty(va.ty),\n-        id: folder.new_id(va.id)\n+        id: id,\n     }\n }\n \n@@ -539,10 +557,11 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n+    let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n-        id: folder.new_id(b.id), // Needs to be first, for ast_map.\n+        id: id,\n         view_items: view_items,\n         stmts: stmts,\n         expr: b.expr.map(|x| folder.fold_expr(x)),\n@@ -606,8 +625,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n }\n \n pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n+    let id = fld.new_id(m.id); // Needs to be first, for ast_map.\n     TypeMethod {\n-        id: fld.new_id(m.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, fld)).collect(),\n         fn_style: m.fn_style,\n@@ -658,8 +678,9 @@ pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item>\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n+    let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n     @ForeignItem {\n-        id: folder.new_id(ni.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.iter().map(|x| fold_attribute_(*x, folder)).collect(),\n         node: match ni.node {\n@@ -681,8 +702,9 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @F\n }\n \n pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n+    let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n     @Method {\n-        id: folder.new_id(m.id), // Needs to be first, for ast_map.\n+        id: id,\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fold_attribute_(*a, folder)).collect(),\n         generics: fold_generics(&m.generics, folder),\n@@ -696,6 +718,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n }\n \n pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n+    let id = folder.new_id(p.id);\n     let node = match p.node {\n         PatWild => PatWild,\n         PatWildMulti => PatWildMulti,\n@@ -733,13 +756,14 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n     };\n \n     @Pat {\n-        id: folder.new_id(p.id),\n+        id: id,\n         span: folder.new_span(p.span),\n         node: node,\n     }\n }\n \n pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n+    let id = folder.new_id(e.id);\n     let node = match e.node {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n@@ -849,24 +873,27 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n     };\n \n     @Expr {\n-        id: folder.new_id(e.id),\n+        id: id,\n         node: node,\n         span: folder.new_span(e.span),\n     }\n }\n \n pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n-        StmtDecl(d, nid) => {\n+        StmtDecl(d, id) => {\n+            let id = folder.new_id(id);\n             folder.fold_decl(d).move_iter()\n-                    .map(|d| StmtDecl(d, folder.new_id(nid)))\n+                    .map(|d| StmtDecl(d, id))\n                     .collect()\n         }\n-        StmtExpr(e, nid) => {\n-            SmallVector::one(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n+        StmtExpr(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(StmtExpr(folder.fold_expr(e), id))\n         }\n-        StmtSemi(e, nid) => {\n-            SmallVector::one(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n+        StmtSemi(e, id) => {\n+            let id = folder.new_id(id);\n+            SmallVector::one(StmtSemi(folder.fold_expr(e), id))\n         }\n         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n     };"}]}