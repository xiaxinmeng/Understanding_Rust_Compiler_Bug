{"sha": "553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2I5MGIwYjdiYmViN2NhNDIzNmRiNTNjZjJmMmIzMWNmMDlhZWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-05-12T09:12:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-12T09:12:23Z"}, "message": "Merge pull request #2747 from rust-lang-nursery/author\n\nPatterns, locals and matches for author lint", "tree": {"sha": "b1cca2c27f60af5874581b87cfa0659d700132e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1cca2c27f60af5874581b87cfa0659d700132e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa9q/3CRBK7hj4Ov3rIwAAdHIIAIRmoSgKh4NhzZ/MN8V1zPB/\n/8sua25G5IxfVuHdJGLl02yBR5ejhLvtYy3HN6Oki429nL6tydjCxIEo7plNmLV2\nR1P41k4KTbNYr56KQiW8nSGVxdJzkBqCTjDb9Y0EaV+QSmcCEd0riZAS4BQvOPEX\n+hEJSrO9B/wqdwCe64egRnv8/VswViJnxB/f5NuP1xLpiJlcu++uxb8GlBOoCxol\nt588W5WSp8iChCc7v8BHxQ1/JSKmtw50GObDc+C28SHrCuWL/NCanIfLl98NAVuL\nr4L171Q+2gCN+39Ue0r4QBMQHZcoV30Wlh5Q1w5JqfHVokt0aQ7AJpDZNRfAJfA=\n=pokg\n-----END PGP SIGNATURE-----\n", "payload": "tree b1cca2c27f60af5874581b87cfa0659d700132e7\nparent cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f\nparent 22bef4ce28d7fcf24bd3637cf241bad18c623909\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1526116343 +0200\ncommitter GitHub <noreply@github.com> 1526116343 +0200\n\nMerge pull request #2747 from rust-lang-nursery/author\n\nPatterns, locals and matches for author lint"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "html_url": "https://github.com/rust-lang/rust/commit/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f", "html_url": "https://github.com/rust-lang/rust/commit/cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f"}, {"sha": "22bef4ce28d7fcf24bd3637cf241bad18c623909", "url": "https://api.github.com/repos/rust-lang/rust/commits/22bef4ce28d7fcf24bd3637cf241bad18c623909", "html_url": "https://github.com/rust-lang/rust/commit/22bef4ce28d7fcf24bd3637cf241bad18c623909"}], "stats": {"total": 352, "additions": 323, "deletions": 29}, "files": [{"sha": "5ca1e06a5e5a9d22a5e0f75dc1c9838aec516a41", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -4,10 +4,12 @@ out\n \n # Compiled files\n *.o\n+*.d\n *.so\n *.rlib\n *.dll\n *.pyc\n+*.rmeta\n \n # Executables\n *.exe"}, {"sha": "2f53b7a579e480a959172b613d82aaf89c847256", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 177, "deletions": 4, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -5,7 +5,7 @@\n \n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::{Expr, Expr_, QPath, Ty_};\n+use rustc::hir::{Expr, Expr_, QPath, Ty_, Pat, PatKind, BindingAnnotation, StmtSemi, StmtExpr, StmtDecl, Decl_, Stmt};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use syntax::ast::{self, Attribute, LitKind, DUMMY_NODE_ID};\n use std::collections::HashMap;\n@@ -322,10 +322,29 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprMatch(ref _expr, ref _arms, desugaring) => {\n+            Expr_::ExprMatch(ref expr, ref arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n-                println!(\"Match(ref expr, ref arms, {}) = {};\", des, current);\n-                println!(\"    // unimplemented: `ExprMatch` is not further destructured at the moment\");\n+                let expr_pat = self.next(\"expr\");\n+                let arms_pat = self.next(\"arms\");\n+                println!(\"Match(ref {}, ref {}, {}) = {};\", expr_pat, arms_pat, des, current);\n+                self.current = expr_pat;\n+                self.visit_expr(expr);\n+                println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n+                for (i, arm) in arms.iter().enumerate() {\n+                    self.current = format!(\"{}[{}].body\", arms_pat, i);\n+                    self.visit_expr(&arm.body);\n+                    if let Some(ref guard) = arm.guard {\n+                        let guard_pat = self.next(\"guard\");\n+                        println!(\"    if let Some(ref {}) = {}[{}].guard\", guard_pat, arms_pat, i);\n+                        self.current = guard_pat;\n+                        self.visit_expr(guard);\n+                    }\n+                    println!(\"    if {}[{}].pats.len() == {};\", arms_pat, i, arm.pats.len());\n+                    for (j, pat) in arm.pats.iter().enumerate() {\n+                        self.current = format!(\"{}[{}].pats[{}]\", arms_pat, i, j);\n+                        self.visit_pat(pat);\n+                    }\n+                }\n             },\n             Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n@@ -454,6 +473,160 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         }\n     }\n \n+    fn visit_pat(&mut self, pat: &Pat) {\n+        print!(\"    if let PatKind::\");\n+        let current = format!(\"{}.node\", self.current);\n+        match pat.node {\n+            PatKind::Wild => println!(\"Wild = {};\", current),\n+            PatKind::Binding(anno, _, name, ref sub) => {\n+                let anno_pat = match anno {\n+                    BindingAnnotation::Unannotated => \"BindingAnnotation::Unannotated\",\n+                    BindingAnnotation::Mutable => \"BindingAnnotation::Mutable\",\n+                    BindingAnnotation::Ref => \"BindingAnnotation::Ref\",\n+                    BindingAnnotation::RefMut => \"BindingAnnotation::RefMut\",\n+                };\n+                let name_pat = self.next(\"name\");\n+                if let Some(ref sub) = *sub {\n+                    let sub_pat = self.next(\"sub\");\n+                    println!(\"Binding({}, _, {}, Some(ref {})) = {};\", anno_pat, name_pat, sub_pat, current);\n+                    self.current = sub_pat;\n+                    self.visit_pat(sub);\n+                } else {\n+                    println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n+                }\n+                println!(\"    if {}.node.as_str() == \\\"{}\\\";\", name_pat, name.node.as_str());\n+            }\n+            PatKind::Struct(ref path, ref fields, ignore) => {\n+                let path_pat = self.next(\"path\");\n+                let fields_pat = self.next(\"fields\");\n+                println!(\"Struct(ref {}, ref {}, {}) = {};\", path_pat, fields_pat, ignore, current);\n+                self.current = path_pat;\n+                self.print_qpath(path);\n+                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n+                println!(\"    // unimplemented: field checks\");\n+            }\n+            PatKind::TupleStruct(ref path, ref fields, skip_pos) => {\n+                let path_pat = self.next(\"path\");\n+                let fields_pat = self.next(\"fields\");\n+                println!(\"TupleStruct(ref {}, ref {}, {:?}) = {};\", path_pat, fields_pat, skip_pos, current);\n+                self.current = path_pat;\n+                self.print_qpath(path);\n+                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n+                println!(\"    // unimplemented: field checks\");\n+            },\n+            PatKind::Path(ref path) => {\n+                let path_pat = self.next(\"path\");\n+                println!(\"Path(ref {}) = {};\", path_pat, current);\n+                self.current = path_pat;\n+                self.print_qpath(path);\n+            }\n+            PatKind::Tuple(ref fields, skip_pos) => {\n+                let fields_pat = self.next(\"fields\");\n+                println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n+                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n+                println!(\"    // unimplemented: field checks\");\n+            }\n+            PatKind::Box(ref pat) => {\n+                let pat_pat = self.next(\"pat\");\n+                println!(\"Box(ref {}) = {};\", pat_pat, current);\n+                self.current = pat_pat;\n+                self.visit_pat(pat);\n+            },\n+            PatKind::Ref(ref pat, muta) => {\n+                let pat_pat = self.next(\"pat\");\n+                println!(\"Ref(ref {}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n+                self.current = pat_pat;\n+                self.visit_pat(pat);\n+            },\n+            PatKind::Lit(ref lit_expr) => {\n+                let lit_expr_pat = self.next(\"lit_expr\");\n+                println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n+                self.current = lit_expr_pat;\n+                self.visit_expr(lit_expr);\n+            }\n+            PatKind::Range(ref start, ref end, end_kind) => {\n+                let start_pat = self.next(\"start\");\n+                let end_pat = self.next(\"end\");\n+                println!(\"Range(ref {}, ref {}, RangeEnd::{:?}) = {};\", start_pat, end_pat, end_kind, current);\n+                self.current = start_pat;\n+                self.visit_expr(start);\n+                self.current = end_pat;\n+                self.visit_expr(end);\n+            }\n+            PatKind::Slice(ref start, ref middle, ref end) => {\n+                let start_pat = self.next(\"start\");\n+                let end_pat = self.next(\"end\");\n+                if let Some(ref middle) = middle {\n+                    let middle_pat = self.next(\"middle\");\n+                    println!(\"Slice(ref {}, Some(ref {}), ref {}) = {};\", start_pat, middle_pat, end_pat, current);\n+                    self.current = middle_pat;\n+                    self.visit_pat(middle);\n+                } else {\n+                    println!(\"Slice(ref {}, None, ref {}) = {};\", start_pat, end_pat, current);\n+                }\n+                println!(\"    if {}.len() == {};\", start_pat, start.len());\n+                for (i, pat) in start.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", start_pat, i);\n+                    self.visit_pat(pat);\n+                }\n+                println!(\"    if {}.len() == {};\", end_pat, end.len());\n+                for (i, pat) in end.iter().enumerate() {\n+                    self.current = format!(\"{}[{}]\", end_pat, i);\n+                    self.visit_pat(pat);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &Stmt) {\n+        print!(\"    if let Stmt_::\");\n+        let current = format!(\"{}.node\", self.current);\n+        match s.node {\n+            // Could be an item or a local (let) binding:\n+            StmtDecl(ref decl, _) => {\n+                let decl_pat = self.next(\"decl\");\n+                println!(\"StmtDecl(ref {}, _) = {}\", decl_pat, current);\n+                print!(\"    if let Decl_::\");\n+                let current = format!(\"{}.node\", decl_pat);\n+                match decl.node {\n+                    // A local (let) binding:\n+                    Decl_::DeclLocal(ref local) => {\n+                        let local_pat = self.next(\"local\");\n+                        println!(\"DeclLocal(ref {}) = {};\", local_pat, current);\n+                        if let Some(ref init) = local.init {\n+                            let init_pat = self.next(\"init\");\n+                            println!(\"    if let Some(ref {}) = {}.init\", init_pat, local_pat);\n+                            self.current = init_pat;\n+                            self.visit_expr(init);\n+                        }\n+                        self.current = format!(\"{}.pat\", local_pat);\n+                        self.visit_pat(&local.pat);\n+                    },\n+                    // An item binding:\n+                    Decl_::DeclItem(_) => {\n+                        println!(\"DeclItem(item_id) = {};\", current);\n+                    },\n+                }\n+            }\n+\n+            // Expr without trailing semi-colon (must have unit type):\n+            StmtExpr(ref e, _) => {\n+                let e_pat = self.next(\"e\");\n+                println!(\"StmtExpr(ref {}, _) = {}\", e_pat, current);\n+                self.current = e_pat;\n+                self.visit_expr(e);\n+            },\n+\n+            // Expr with trailing semi-colon (may have any type):\n+            StmtSemi(ref e, _) => {\n+                let e_pat = self.next(\"e\");\n+                println!(\"StmtSemi(ref {}, _) = {}\", e_pat, current);\n+                self.current = e_pat;\n+                self.visit_expr(e);\n+            },\n+        }\n+    }\n+\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }"}, {"sha": "a55b48985ad9c31322de154e6ac5a95df6a8eda4", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -1,9 +1,14 @@\n if_chain! {\n-    if let Expr_::ExprCast(ref expr, ref cast_ty) = stmt.node;\n+    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n+    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let Some(ref init) = local.init\n+    if let Expr_::ExprCast(ref expr, ref cast_ty) = init.node;\n     if let Ty_::TyPath(ref qp) = cast_ty.node;\n     if match_qpath(qp, &[\"char\"]);\n     if let Expr_::ExprLit(ref lit) = expr.node;\n     if let LitKind::Int(69, _) = lit.node;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;\n+    if name.node.as_str() == \"x\";\n     then {\n         // report your lint here\n     }"}, {"sha": "657bf51bf807baaca83f19eabf08c581c9ad89b2", "filename": "tests/ui/author/for_loop.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.rs?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -0,0 +1,8 @@\n+#![feature(custom_attribute)]\n+\n+fn main() {\n+    #[clippy(author)]\n+    for y in 0..10 {\n+        let z = y;\n+    }\n+}"}, {"sha": "af6b5a4ec336b62ab011990078188091293bf508", "filename": "tests/ui/author/for_loop.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -0,0 +1,60 @@\n+if_chain! {\n+    if let Expr_::ExprBlock(ref block) = expr.node;\n+    if let Stmt_::StmtDecl(ref decl, _) = block.node\n+    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let Some(ref init) = local.init\n+    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n+    if let Expr_::ExprCall(ref func, ref args) = expr.node;\n+    // unimplemented: `ExprCall` is not further destructured at the moment\n+    if arms.len() == 1;\n+    if let Expr_::ExprLoop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n+    if let Stmt_::StmtDecl(ref decl1, _) = body.node\n+    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local1.pat.node;\n+    if name.node.as_str() == \"__next\";\n+    if let Stmt_::StmtExpr(ref e, _) = local1.pat.node\n+    if let Expr_::ExprMatch(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n+    if let Expr_::ExprCall(ref func, ref args) = expr1.node;\n+    // unimplemented: `ExprCall` is not further destructured at the moment\n+    if arms1.len() == 2;\n+    if let Expr_::ExprAssign(ref target, ref value) = arms1[0].body.node;\n+    if let Expr_::ExprPath(ref path) = target.node;\n+    if match_qpath(path, &[\"__next\"]);\n+    if let Expr_::ExprPath(ref path1) = value.node;\n+    if match_qpath(path1, &[\"val\"]);\n+    if arms1[0].pats.len() == 1;\n+    if let PatKind::TupleStruct(ref path2, ref fields, None) = arms1[0].pats[0].node;\n+    if match_qpath(path2, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n+    if fields.len() == 1;\n+    // unimplemented: field checks\n+    if let Expr_::ExprBreak(ref destination, None) = arms1[1].body.node;\n+    if arms1[1].pats.len() == 1;\n+    if let PatKind::Path(ref path3) = arms1[1].pats[0].node;\n+    if match_qpath(path3, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n+    if let Stmt_::StmtDecl(ref decl2, _) = path3.node\n+    if let Decl_::DeclLocal(ref local2) = decl2.node;\n+    if let Some(ref init1) = local2.init\n+    if let Expr_::ExprPath(ref path4) = init1.node;\n+    if match_qpath(path4, &[\"__next\"]);\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local2.pat.node;\n+    if name1.node.as_str() == \"y\";\n+    if let Stmt_::StmtExpr(ref e1, _) = local2.pat.node\n+    if let Expr_::ExprBlock(ref block1) = e1.node;\n+    if let Stmt_::StmtDecl(ref decl3, _) = block1.node\n+    if let Decl_::DeclLocal(ref local3) = decl3.node;\n+    if let Some(ref init2) = local3.init\n+    if let Expr_::ExprPath(ref path5) = init2.node;\n+    if match_qpath(path5, &[\"y\"]);\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local3.pat.node;\n+    if name2.node.as_str() == \"z\";\n+    if arms[0].pats.len() == 1;\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pats[0].node;\n+    if name3.node.as_str() == \"iter\";\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name4, None) = local.pat.node;\n+    if name4.node.as_str() == \"_result\";\n+    if let Expr_::ExprPath(ref path6) = local.pat.node;\n+    if match_qpath(path6, &[\"_result\"]);\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "f426302da09dfd602354d7f69c69e9f2232abc5f", "filename": "tests/ui/author/matches.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.rs?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -0,0 +1,13 @@\n+#![feature(custom_attribute)]\n+\n+fn main() {\n+    #[clippy(author)]\n+    let a = match 42 {\n+        16 => 5,\n+        17 => {\n+            let x = 3;\n+            x\n+        },\n+        _ => 1,\n+    };\n+}"}, {"sha": "c4f69b10df7e6d75ecc751d464b8d944eb2bab36", "filename": "tests/ui/author/matches.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stderr?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -0,0 +1,15 @@\n+error: returning the result of a let binding from a block. Consider returning the expression directly.\n+ --> $DIR/matches.rs:9:13\n+  |\n+9 |             x\n+  |             ^\n+  |\n+  = note: `-D let-and-return` implied by `-D warnings`\n+note: this expression can be directly returned\n+ --> $DIR/matches.rs:8:21\n+  |\n+8 |             let x = 3;\n+  |                     ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "db7de5a2ca5c35bca6291dafd16d0f3b07d3abc0", "filename": "tests/ui/author/matches.stout", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -0,0 +1,38 @@\n+if_chain! {\n+    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n+    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let Some(ref init) = local.init\n+    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::Normal) = init.node;\n+    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let LitKind::Int(42, _) = lit.node;\n+    if arms.len() == 3;\n+    if let Expr_::ExprLit(ref lit1) = arms[0].body.node;\n+    if let LitKind::Int(5, _) = lit1.node;\n+    if arms[0].pats.len() == 1;\n+    if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].node\n+    if let Expr_::ExprLit(ref lit2) = lit_expr.node;\n+    if let LitKind::Int(16, _) = lit2.node;\n+    if let Expr_::ExprBlock(ref block) = arms[1].body.node;\n+    if let Stmt_::StmtDecl(ref decl1, _) = block.node\n+    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let Some(ref init1) = local1.init\n+    if let Expr_::ExprLit(ref lit3) = init1.node;\n+    if let LitKind::Int(3, _) = lit3.node;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.node;\n+    if name.node.as_str() == \"x\";\n+    if let Expr_::ExprPath(ref path) = local1.pat.node;\n+    if match_qpath(path, &[\"x\"]);\n+    if arms[1].pats.len() == 1;\n+    if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].node\n+    if let Expr_::ExprLit(ref lit4) = lit_expr1.node;\n+    if let LitKind::Int(17, _) = lit4.node;\n+    if let Expr_::ExprLit(ref lit5) = arms[2].body.node;\n+    if let LitKind::Int(1, _) = lit5.node;\n+    if arms[2].pats.len() == 1;\n+    if let PatKind::Wild = arms[2].pats[0].node;\n+    if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local.pat.node;\n+    if name1.node.as_str() == \"a\";\n+    then {\n+        // report your lint here\n+    }\n+}"}, {"sha": "99ac7e4c0197793f2d29ddc487bfe48694dfef6a", "filename": "tests/ui/for_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.rs?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -14,7 +14,7 @@ fn for_loop_over_option_and_result() {\n     let v = vec![0, 1, 2];\n \n     // check FOR_LOOP_OVER_OPTION lint\n-    #[clippy(author)]for x in option {\n+    for x in option {\n         println!(\"{}\", x);\n     }\n "}, {"sha": "34b3527fbaef610726928d4c1040ff279dc993dd", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=553b90b0b7bbeb7ca4236db53cf2f2b31cf09aeb", "patch": "@@ -1,8 +1,8 @@\n error: for loop over `option`, which is an `Option`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop.rs:17:31\n+  --> $DIR/for_loop.rs:17:14\n    |\n-17 |     #[clippy(author)]for x in option {\n-   |                               ^^^^^^\n+17 |     for x in option {\n+   |              ^^^^^^\n    |\n    = note: `-D for-loop-over-option` implied by `-D warnings`\n    = help: consider replacing `for x in option` with `if let Some(x) = option`"}, {"sha": "ce4186fa6a1a952359634f3a43dcb3463fac6f2d", "filename": "tests/ui/for_loop.stdout", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f/tests%2Fui%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f/tests%2Fui%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stdout?ref=cd3d22d287e0b4a9bb5a31d0832a369a8fb8320f", "patch": "@@ -1,20 +0,0 @@\n-if_chain! {\n-    if let Expr_::ExprBlock(ref block) = stmt.node;\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = block.node;\n-    // unimplemented: `ExprMatch` is not further destructured at the moment\n-    if let Expr_::ExprPath(ref path) = block.node;\n-    if match_qpath(path, &[\"_result\"]);\n-    then {\n-        // report your lint here\n-    }\n-}\n-if_chain! {\n-    if let Expr_::ExprBlock(ref block) = expr.node;\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = block.node;\n-    // unimplemented: `ExprMatch` is not further destructured at the moment\n-    if let Expr_::ExprPath(ref path) = block.node;\n-    if match_qpath(path, &[\"_result\"]);\n-    then {\n-        // report your lint here\n-    }\n-}"}]}