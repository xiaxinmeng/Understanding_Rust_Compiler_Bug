{"sha": "7ab66a46b77561f753be0423afef85504b081e5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYjY2YTQ2Yjc3NTYxZjc1M2JlMDQyM2FmZWY4NTUwNGIwODFlNWY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-18T00:08:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-18T00:55:40Z"}, "message": "core: remove old repr system, enable newer one. Close #3109.", "tree": {"sha": "176273426d66b65427da79d56e89a90f6c2b852d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/176273426d66b65427da79d56e89a90f6c2b852d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ab66a46b77561f753be0423afef85504b081e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab66a46b77561f753be0423afef85504b081e5f", "html_url": "https://github.com/rust-lang/rust/commit/7ab66a46b77561f753be0423afef85504b081e5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ab66a46b77561f753be0423afef85504b081e5f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c83fe4c24b7c0e6c6ff6916c8b4a9d9973e46a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c83fe4c24b7c0e6c6ff6916c8b4a9d9973e46a9", "html_url": "https://github.com/rust-lang/rust/commit/6c83fe4c24b7c0e6c6ff6916c8b4a9d9973e46a9"}], "stats": {"total": 603, "additions": 53, "deletions": 550}, "files": [{"sha": "28c6031263ba61e7b72f8925b360e02d07ec7788", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ab66a46b77561f753be0423afef85504b081e5f/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab66a46b77561f753be0423afef85504b081e5f/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=7ab66a46b77561f753be0423afef85504b081e5f", "patch": "@@ -32,12 +32,12 @@ pub trait MovePtr {\n \n /// Helper function for alignment calculation.\n #[inline(always)]\n-fn align(size: uint, align: uint) -> uint {\n+pub fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1u) & !(align - 1u)\n }\n \n /// Adaptor to wrap around visitors implementing MovePtr.\n-struct MovePtrAdaptor<V: TyVisitor MovePtr> {\n+pub struct MovePtrAdaptor<V: TyVisitor MovePtr> {\n     inner: V\n }\n pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {"}, {"sha": "d3ed4f31515f55d5f564d5604c062212fc154434", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 51, "deletions": 548, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/7ab66a46b77561f753be0423afef85504b081e5f/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab66a46b77561f753be0423afef85504b081e5f/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=7ab66a46b77561f753be0423afef85504b081e5f", "patch": "@@ -17,27 +17,18 @@ More runtime type reflection\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-use dvec::DVec;\n use io::{Writer, WriterUtil};\n use libc::c_void;\n-use sys::TypeDesc;\n use to_str::ToStr;\n use cast::transmute;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n-use reflect::{MovePtr, MovePtrAdaptor};\n+use reflect::{MovePtr, MovePtrAdaptor, align};\n use vec::UnboxedVecRepr;\n use vec::raw::{VecRepr, SliceRepr};\n pub use managed::raw::BoxRepr;\n-use managed::raw::BoxHeaderRepr;\n \n /// Helpers\n \n-/// Helper function for alignment calculation.\n-#[inline(always)]\n-fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1) & !(align - 1)\n-}\n-\n trait EscapedCharWriter {\n     fn write_escaped_char(ch: char);\n }\n@@ -130,11 +121,11 @@ impl char : Repr {\n \n // New implementation using reflect::MovePtr\n \n-struct ReprVisitor {\n+pub struct ReprVisitor {\n     mut ptr: *c_void,\n     writer: @Writer\n }\n-fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n+pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n     ReprVisitor { ptr: ptr, writer: writer }\n }\n \n@@ -458,7 +449,7 @@ impl ReprVisitor : TyVisitor {\n     fn visit_closure_ptr(_ck: uint) -> bool { true }\n }\n \n-pub fn write_repr2<T>(writer: @Writer, object: &T) {\n+pub fn write_repr<T>(writer: @Writer, object: &T) {\n     let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n     let tydesc = intrinsic::get_tydesc::<T>();\n     let mut u = ReprVisitor(ptr, writer);\n@@ -467,545 +458,57 @@ pub fn write_repr2<T>(writer: @Writer, object: &T) {\n }\n \n #[test]\n-fn test_repr2() {\n-    repr::write_repr2(io::stdout(), &10);\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &true);\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &false);\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &1.234);\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(&\"hello\"));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@\"hello\"));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(~\"he\\u10f3llo\"));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@10));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@mut 10));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(~10));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(~mut 10));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(&10));\n-    io::println(\"\");\n-    let mut x = 10;\n-    repr::write_repr2(io::stdout(), &(&mut x));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(ptr::to_unsafe_ptr(&10) as *int));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@[1,2,3,4,5,6,7,8]));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@[1u8,2u8,3u8,4u8]));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@[\"hi\", \"there\"]));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(~[\"hi\", \"there\"]));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(&[\"hi\", \"there\"]));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &({a:10, b:1.234}));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(@{a:10, b:1.234}));\n-    io::println(\"\");\n-    repr::write_repr2(io::stdout(), &(~{a:10, b:1.234}));\n-    io::println(\"\");\n-}\n-\n-\n-// Old non-factored implementation, transitional...\n-\n-#[deriving_eq]\n-enum EnumVisitState {\n-    PreVariant,     // We're before the variant we're interested in.\n-    InVariant,      // We're inside the variant we're interested in.\n-    PostVariant,    // We're after the variant we're interested in.\n-    Degenerate      // This is a degenerate enum (exactly 1 variant)\n-}\n-\n-struct EnumState {\n-    end_ptr: *c_void,\n-    state: EnumVisitState\n-}\n-\n-/// XXX: This should not use a boxed writer!\n-struct ReprPrinter {\n-    mut ptr: *c_void,\n-    writer: @Writer,    // XXX: This should not use a boxed trait.\n-    enum_stack: DVec<EnumState>\n-}\n-\n-/// FIXME (issue #3462): This is horrible.\n-struct ReprPrinterWrapper {\n-    printer: @ReprPrinter\n-}\n+fn test_repr() {\n \n-impl ReprPrinter {\n-    #[inline(always)]\n-    fn align(n: uint) {\n-        unsafe {\n-            self.ptr = transmute(align(self.ptr as uint, n));\n+    fn exact_test<T>(t: &T, e:&str) {\n+        let s : &str = io::with_str_writer(|w| repr::write_repr(w, t));\n+        if s != e {\n+            error!(\"expected '%s', got '%s'\",\n+                   e, s);\n         }\n+        assert s == e;\n     }\n \n-    #[inline(always)]\n-    fn bump(n: uint) {\n-        unsafe {\n-            self.ptr = transmute(self.ptr as uint + n);\n-        }\n-    }\n \n-    #[inline(always)]\n-    fn log_simple<T:Repr>() -> bool {\n-        unsafe {\n-            self.align(sys::min_align_of::<T>());\n-            let value_addr: &T = transmute(copy self.ptr);\n-            value_addr.write_repr(self.writer);\n-            self.bump(sys::size_of::<T>());\n-            true\n-        }\n-    }\n-}\n-\n-impl ReprPrinterWrapper {\n-    fn visit_estr() -> bool {\n-        unsafe {\n-            self.printer.writer.write_char('\"');\n-            let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n-            let vec_repr = *vec_repr_ptr;\n-            let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).unboxed.data);\n-            let slice: &str = transmute((data_ptr, (*vec_repr).unboxed.fill));\n-            for str::chars_each(slice) |ch| {\n-                self.printer.writer.write_escaped_char(ch);\n-            }\n-            self.printer.writer.write_char('\"');\n-            let ptr_size = sys::size_of::<*c_void>();\n-            self.printer.ptr = transmute(self.printer.ptr as uint + ptr_size);\n-            true\n-        }\n-    }\n-\n-    fn visit_self_describing_heap_alloc(mtbl: uint) -> bool {\n-        unsafe {\n-            if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-            let box_ptr: **BoxRepr = transmute(copy self.printer.ptr);\n-            let box = *box_ptr;\n-            self.printer.ptr = transmute(&(*box).data);\n-            intrinsic::visit_tydesc((*box).header.type_desc,\n-                                    self as @TyVisitor);\n-            let box_size = sys::size_of::<*BoxRepr>();\n-            self.printer.ptr = transmute(box_ptr as uint + box_size);\n-            true\n-        }\n-    }\n+    exact_test(&10, \"10\");\n+    exact_test(&true, \"true\");\n+    exact_test(&false, \"false\");\n+    exact_test(&1.234, \"1.2340\");\n+    exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n+    exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n+    exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n \n-    fn visit_ptr_contents(mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe {\n-            if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-            let data_ptr: **c_void = transmute(copy self.printer.ptr);\n-            if *data_ptr == ptr::null() {\n-                self.printer.writer.write_str(\"null\");\n-            } else {\n-                self.printer.ptr = *data_ptr;\n-                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-            }\n-            let ptr_size = sys::size_of::<*c_void>();\n-            self.printer.ptr = transmute(data_ptr as uint + ptr_size);\n-            true\n-        }\n-    }\n-\n-    fn visit_evec(mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe {\n-            self.printer.writer.write_char('[');\n-            self.printer.align(sys::min_align_of::<*c_void>());\n-            let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n-            let old_ptr = self.printer.ptr as uint;\n-            let vec_repr: *VecRepr = *vec_repr_ptr;\n-            self.printer.ptr = transmute(&(*vec_repr).unboxed.data);\n-            let end_ptr: *c_void = transmute(self.printer.ptr as uint +\n-                                             (*vec_repr).unboxed.fill);\n-            let sys_tydesc: *TypeDesc = transmute(copy inner);\n-            let alignment = (*sys_tydesc).align;\n-            let mut first = true;\n-            loop {\n-                self.printer.align(alignment);\n-                if self.printer.ptr >= end_ptr { break; }\n-                if first {\n-                    self.printer.writer.write_char(' ');\n-                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-                } else {\n-                    self.printer.writer.write_str(\", \");\n-                }\n-                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-                first = false;\n-            }\n-            if !first {\n-                self.printer.writer.write_char(' ');\n-            } else if mtbl != 1 {\n-                self.printer.writer.write_str(\"mut\");\n-            }\n-            self.printer.writer.write_char(']');\n-            self.printer.ptr = transmute(old_ptr + sys::size_of::<int>());\n-            true\n-        }\n-    }\n-}\n-\n-impl ReprPrinterWrapper : TyVisitor {\n-    fn visit_bot() -> bool {\n-        self.printer.bump(1);\n-        self.printer.writer.write_str(\"fail\");\n-        true\n-    }\n-\n-    fn visit_nil() -> bool { self.printer.log_simple::<()>() }\n-    fn visit_bool() -> bool { self.printer.log_simple::<bool>() }\n-\n-    // Numbers\n-\n-    fn visit_int() -> bool { self.printer.log_simple::<int>() }\n-    fn visit_i8() -> bool { self.printer.log_simple::<i8>() }\n-    fn visit_i16() -> bool { self.printer.log_simple::<i16>() }\n-    fn visit_i32() -> bool { self.printer.log_simple::<i32>() }\n-    fn visit_i64() -> bool { self.printer.log_simple::<i64>() }\n-\n-    fn visit_uint() -> bool { self.printer.log_simple::<uint>() }\n-    fn visit_u8() -> bool { self.printer.log_simple::<u8>() }\n-    fn visit_u16() -> bool { self.printer.log_simple::<u16>() }\n-    fn visit_u32() -> bool { self.printer.log_simple::<u32>() }\n-    fn visit_u64() -> bool { self.printer.log_simple::<u64>() }\n-\n-    fn visit_float() -> bool { self.printer.log_simple::<float>() }\n-    fn visit_f32() -> bool { self.printer.log_simple::<f32>() }\n-    fn visit_f64() -> bool { self.printer.log_simple::<f64>() }\n-\n-    fn visit_char() -> bool { self.printer.log_simple::<char>() }\n-    fn visit_str() -> bool { true }\n-\n-    // Strings\n-\n-    fn visit_estr_box() -> bool {\n-        self.printer.writer.write_char('@');\n-        self.visit_estr()\n-    }\n-    fn visit_estr_uniq() -> bool {\n-        self.printer.writer.write_char('~');\n-        self.visit_estr()\n-    }\n-    fn visit_estr_slice() -> bool {\n-        unsafe {\n-            self.printer.writer.write_char('\"');\n-            let slice_ptr: *&str = transmute(copy self.printer.ptr);\n-            let slice = *slice_ptr;\n-            for str::chars_each(slice) |ch| {\n-                self.printer.writer.write_escaped_char(ch);\n-            }\n-            self.printer.writer.write_char('\"');\n-            let slice_sz = sys::size_of::<(*char,uint)>();\n-            self.printer.ptr = transmute(self.printer.ptr as uint + slice_sz);\n-            true\n-        }\n-    }\n-    fn visit_estr_fixed(_n: uint, _sz: uint, _align: uint) -> bool { true }\n-\n-    // Pointers\n-\n-    fn visit_box(mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('@');\n-        self.visit_self_describing_heap_alloc(mtbl)\n-    }\n-    fn visit_uniq(mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('~');\n-        self.visit_self_describing_heap_alloc(mtbl)\n-    }\n-    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('*');\n-        self.visit_ptr_contents(mtbl, inner)\n-    }\n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('&');\n-        self.visit_ptr_contents(mtbl, inner)\n-    }\n-\n-    // Vectors\n-\n-    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('@');\n-        self.visit_evec(mtbl, inner)\n-    }\n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.printer.writer.write_char('~');\n-        self.visit_evec(mtbl, inner)\n-    }\n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe {\n-            self.printer.writer.write_str(\"&[\");\n-            self.printer.align(sys::min_align_of::<(*c_void,uint)>());\n-            let slice_ptr: *(*c_void,uint) = transmute(copy self.printer.ptr);\n-            let (data, fill) = *slice_ptr;\n-            self.printer.ptr = data;\n-            let end_ptr: *c_void = transmute(self.printer.ptr as uint + fill);\n-            let sys_tydesc: *TypeDesc = transmute(copy inner);\n-            let alignment = (*sys_tydesc).align;\n-            let mut first = true;\n-            loop {\n-                self.printer.align(alignment);\n-                if self.printer.ptr >= end_ptr { break; }\n-                if first {\n-                    self.printer.writer.write_char(' ');\n-                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-                } else {\n-                    self.printer.writer.write_str(\", \");\n-                }\n-                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-                first = false;\n-            }\n-            if !first {\n-                self.printer.writer.write_char(' ');\n-            } else if mtbl != 1 {\n-                self.printer.writer.write_str(\"mut\");\n-            }\n-            self.printer.writer.write_char(']');\n-            let slice_size = sys::size_of::<(uint, *c_void)>();\n-            self.printer.ptr = transmute(slice_ptr as uint + slice_size);\n-            true\n-        }\n-    }\n-    fn visit_evec_fixed(n: uint, sz: uint, align: uint, mtbl: uint,\n-                        inner: *TyDesc) -> bool {\n-        unsafe {\n-            self.printer.writer.write_char('[');\n-            self.printer.align(align);\n-            let end_ptr: *c_void = transmute(self.printer.ptr as uint + sz);\n-            for uint::range(0, n) |i| {\n-                self.printer.align(align);\n-                if i == 0 {\n-                    self.printer.writer.write_char(' ');\n-                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-                } else {\n-                    self.printer.writer.write_str(\", \");\n-                }\n-                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-            }\n-            if n > 0 {\n-                self.printer.writer.write_char(' ');\n-            } else if mtbl != 1 {\n-                self.printer.writer.write_str(\"mut\");\n-            }\n-            self.printer.writer.write_char(']');\n-            self.printer.ptr = end_ptr;\n-            true\n-        }\n-    }\n-\n-    // Records\n-\n-    fn visit_enter_rec(_n_fields: uint, _sz: uint, align: uint) -> bool {\n-        self.printer.writer.write_char('{');\n-        self.printer.align(align);\n-        true\n-    }\n-    fn visit_rec_field(i: uint, name: &str, mtbl: uint, inner: *TyDesc) ->\n-                       bool {\n-        if i != 0 {\n-            self.printer.writer.write_str(\", \");\n-        } else {\n-            self.printer.writer.write_char(' ');\n-        }\n-        if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-        self.printer.writer.write_str(name);\n-        self.printer.writer.write_str(\": \");\n-        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-        true\n-    }\n-    fn visit_leave_rec(n_fields: uint, _sz: uint, _align: uint) -> bool {\n-        if n_fields > 0 { self.printer.writer.write_char(' '); }\n-        self.printer.writer.write_char('}');\n-        true\n-    }\n-\n-    // Structs\n-\n-    fn visit_enter_class(_n_fields: uint, _sz: uint, align: uint) -> bool {\n-        self.printer.writer.write_char('{');\n-        self.printer.align(align);\n-        true\n-    }\n-    fn visit_class_field(i: uint, name: &str, mtbl: uint, inner: *TyDesc) ->\n-                         bool {\n-        if i != 0 {\n-            self.printer.writer.write_str(\", \");\n-        } else {\n-            self.printer.writer.write_char(' ');\n-        }\n-        if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n-        self.printer.writer.write_str(name);\n-        self.printer.writer.write_str(\": \");\n-        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-        true\n-    }\n-    fn visit_leave_class(n_fields: uint, _sz: uint, _align: uint) -> bool {\n-        if n_fields > 0 { self.printer.writer.write_char(' '); }\n-        self.printer.writer.write_char('}');\n-        true\n-    }\n-\n-    // Tuples\n-\n-    fn visit_enter_tup(_n_fields: uint, _sz: uint, align: uint) -> bool {\n-        self.printer.writer.write_char('(');\n-        self.printer.align(align);\n-        true\n-    }\n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 { self.printer.writer.write_str(\", \"); }\n-        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-        true\n-    }\n-    fn visit_leave_tup(_n_fields: uint, _sz: uint, _align: uint) -> bool {\n-        self.printer.writer.write_char(')');\n-        true\n-    }\n-\n-    // Enums\n-\n-    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n-        unsafe {\n-            self.printer.align(align);\n-\n-            // Write in the location of the end of this enum.\n-            let end_ptr = transmute(self.printer.ptr as uint + sz);\n-            let state = if n_variants == 1 { Degenerate } else { PreVariant };\n-            let new_state = EnumState { end_ptr: end_ptr, state: state };\n-            self.printer.enum_stack.push(new_state);\n-\n-            true\n-        }\n-    }\n-\n-    fn visit_enter_enum_variant(_variant: uint,\n-                                disr_val: int,\n-                                _n_fields: uint,\n-                                name: &str) -> bool {\n-        unsafe {\n-            let stack = &self.printer.enum_stack;\n-            let mut enum_state = stack.last();\n-            match enum_state.state {\n-                PreVariant => {\n-                    let disr_ptr = self.printer.ptr as *int;\n-                    if *disr_ptr == disr_val {\n-                        enum_state.state = InVariant;\n-                        self.printer.writer.write_str(name);\n-                        self.printer.bump(sys::size_of::<int>());\n-                        stack.set_elt(stack.len() - 1, enum_state);\n-                    }\n-                }\n-                Degenerate => {\n-                    self.printer.writer.write_str(name);\n-                }\n-                InVariant | PostVariant => {}\n-            }\n-            true\n-        }\n-    }\n-\n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n-        match self.printer.enum_stack.last().state {\n-            InVariant | Degenerate => {\n-                if i == 0 {\n-                    self.printer.writer.write_char('(');\n-                } else {\n-                    self.printer.writer.write_str(\", \");\n-                }\n-\n-                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n-            }\n-            PreVariant | PostVariant => {}\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(_variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        let stack = &self.printer.enum_stack;\n-        let mut enum_state = stack.last();\n-        match enum_state.state {\n-            InVariant => {\n-                if n_fields >= 1 { self.printer.writer.write_char(')'); }\n-                enum_state.state = PostVariant;\n-                stack.set_elt(stack.len() - 1, enum_state);\n-            }\n-            Degenerate => {\n-                if n_fields >= 1 { self.printer.writer.write_char(')'); }\n-            }\n-            PreVariant | PostVariant => {}\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(_n_variants: uint, _sz: uint, _align: uint) -> bool {\n-        self.printer.ptr = self.printer.enum_stack.pop().end_ptr;\n-        true\n-    }\n-\n-    // Functions\n-\n-    fn visit_enter_fn(_purity: uint, proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool {\n-        self.printer.align(sys::min_align_of::<(uint,uint)>());\n-        match proto {\n-            2u => self.printer.writer.write_char('~'),\n-            3u => self.printer.writer.write_char('@'),\n-            4u => self.printer.writer.write_char('&'),\n-            _ => {}\n-        }\n-        self.printer.writer.write_str(\"fn\");\n-        true\n-    }\n-\n-    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-    // Others\n-\n-    fn visit_trait() -> bool { self.printer.writer.write_str(\"@trait\"); true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-    fn visit_opaque_box() -> bool {\n-        self.printer.writer.write_char('@');\n-        self.visit_self_describing_heap_alloc(1)\n-    }\n-    fn visit_constr(_inner: *TyDesc) -> bool { true }\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n-}\n-\n-pub fn write_repr<T>(writer: @Writer, object: &T) {\n-    unsafe {\n-        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n-        let tydesc = sys::get_type_desc::<T>();\n-        let tydesc = cast::transmute(move tydesc);\n-\n-        let repr_printer = @ReprPrinter {\n-            ptr: ptr,\n-            writer: writer,\n-            enum_stack: DVec()\n-        };\n-\n-        let wrapper = ReprPrinterWrapper { printer: repr_printer };\n-        intrinsic::visit_tydesc(tydesc, wrapper as @TyVisitor);\n-    }\n+    // FIXME #4210: the mut fields are a bit off here.\n+    exact_test(&(@10), \"@10\");\n+    exact_test(&(@mut 10), \"@10\");\n+    exact_test(&(~10), \"~10\");\n+    exact_test(&(~mut 10), \"~mut 10\");\n+    exact_test(&(&10), \"&10\");\n+    let mut x = 10;\n+    exact_test(&(&mut x), \"&mut 10\");\n+\n+    exact_test(&(@[1,2,3,4,5,6,7,8]),\n+               \"@[1, 2, 3, 4, 5, 6, 7, 8]\");\n+    exact_test(&(@[1u8,2u8,3u8,4u8]),\n+               \"@[1, 2, 3, 4]\");\n+    exact_test(&(@[\"hi\", \"there\"]),\n+               \"@[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&(~[\"hi\", \"there\"]),\n+               \"~[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&(&[\"hi\", \"there\"]),\n+               \"&[\\\"hi\\\", \\\"there\\\"]\");\n+    exact_test(&({a:10, b:1.234}),\n+               \"{a: 10, b: 1.2340}\");\n+    exact_test(&(@{a:10, b:1.234}),\n+               \"@{a: 10, b: 1.2340}\");\n+    exact_test(&(~{a:10, b:1.234}),\n+               \"~{a: 10, b: 1.2340}\");\n+    exact_test(&(10_u8, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u16, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u32, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n+    exact_test(&(10_u64, ~\"hello\"),\n+               \"(10, ~\\\"hello\\\")\");\n }\n-"}]}