{"sha": "e712a47a812b4605adeea6ec56ba06550c060c78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MTJhNDdhODEyYjQ2MDVhZGVlYTZlYzU2YmEwNjU1MGMwNjBjNzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-11T00:38:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-11T04:48:29Z"}, "message": "create serialization lib and update serializer to use it", "tree": {"sha": "a123d3db9086bf56dd48c3556bf22d14c5ebb571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a123d3db9086bf56dd48c3556bf22d14c5ebb571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e712a47a812b4605adeea6ec56ba06550c060c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e712a47a812b4605adeea6ec56ba06550c060c78", "html_url": "https://github.com/rust-lang/rust/commit/e712a47a812b4605adeea6ec56ba06550c060c78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e712a47a812b4605adeea6ec56ba06550c060c78/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0263039ca0350eb67ce11e985bd7e698de48ca0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0263039ca0350eb67ce11e985bd7e698de48ca0f", "html_url": "https://github.com/rust-lang/rust/commit/0263039ca0350eb67ce11e985bd7e698de48ca0f"}], "stats": {"total": 343, "additions": 304, "deletions": 39}, "files": [{"sha": "2b3ea15db61ce98fc05c5441493bfb5fd2b22fa3", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=e712a47a812b4605adeea6ec56ba06550c060c78", "patch": "@@ -43,15 +43,15 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n-    let bucket = ebml::doc_at(d.data, pos);\n+    let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n     let result: [ebml::doc] = [];\n     let belt = tag_index_buckets_bucket_elt;\n     ebml::tagged_docs(bucket, belt) {|elt|\n         let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n-            result += [ebml::doc_at(d.data, pos)];\n+            result += [ebml::doc_at(d.data, pos).doc];\n         }\n     };\n     ret result;\n@@ -500,7 +500,7 @@ fn iter_crate_items(bytes: @[u8], proc: fn(str, ast::def_id)) {\n         let et = tag_index_buckets_bucket_elt;\n         ebml::tagged_docs(bucket, et) {|elt|\n             let data = read_path(elt);\n-            let def = ebml::doc_at(bytes, data.pos);\n+            let {tag:_, doc:def} = ebml::doc_at(bytes, data.pos);\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n             proc(data.path, did);"}, {"sha": "8d0740b6728a0878c66f5397f366bf59b7c45d15", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e712a47a812b4605adeea6ec56ba06550c060c78", "patch": "@@ -2395,7 +2395,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             *path + [ast_map::path_name(nitem.ident)]\n           }\n \n-          ast_map::node_method(method, path) {\n+          ast_map::node_method(method, _, path) {\n             *path + [ast_map::path_name(method.ident)]\n           }\n "}, {"sha": "41cec77851d4b1e951983b076ebaada30bd4c0f6", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=e712a47a812b4605adeea6ec56ba06550c060c78", "patch": "@@ -17,6 +17,8 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n // ebml reading\n type doc = {data: @[u8], start: uint, end: uint};\n \n+type tagged_doc = {tag: uint, doc: doc};\n+\n fn vint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {\n@@ -43,11 +45,12 @@ fn new_doc(data: @[u8]) -> doc {\n     ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n-fn doc_at(data: @[u8], start: uint) -> doc {\n+fn doc_at(data: @[u8], start: uint) -> tagged_doc {\n     let elt_tag = vint_at(*data, start);\n     let elt_size = vint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n-    ret {data: data, start: elt_size.next, end: end};\n+    ret {tag: elt_tag.val,\n+         doc: {data: data, start: elt_size.next, end: end}};\n }\n \n fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n@@ -120,18 +123,18 @@ fn doc_as_uint(d: doc) -> uint {\n // ebml writing\n type writer = {writer: io::writer, mutable size_positions: [uint]};\n \n-fn write_sized_vint(w: io::writer, n: uint, size: uint) {\n+fn write_sized_vint(w: io::writer, n: u64, size: uint) {\n     let buf: [u8];\n     alt size {\n       1u { buf = [0x80u8 | (n as u8)]; }\n-      2u { buf = [0x40u8 | ((n >> 8u) as u8), (n & 0xffu) as u8]; }\n+      2u { buf = [0x40u8 | ((n >> 8_u64) as u8), n as u8]; }\n       3u {\n-        buf = [0x20u8 | ((n >> 16u) as u8), (n >> 8u & 0xffu) as u8,\n-               (n & 0xffu) as u8];\n+        buf = [0x20u8 | ((n >> 16_u64) as u8), (n >> 8_u64) as u8,\n+               n as u8];\n       }\n       4u {\n-        buf = [0x10u8 | ((n >> 24u) as u8), (n >> 16u & 0xffu) as u8,\n-               (n >> 8u & 0xffu) as u8, (n & 0xffu) as u8];\n+        buf = [0x10u8 | ((n >> 24_u64) as u8), (n >> 16_u64) as u8,\n+               (n >> 8_u64) as u8, n as u8];\n       }\n       _ { #error(\"vint to write too big\"); fail; }\n     }\n@@ -156,7 +159,7 @@ fn create_writer(w: io::writer) -> writer {\n // TODO: Provide a function to write the standard ebml header.\n fn start_tag(w: writer, tag_id: uint) {\n     // Write the enum ID:\n-    write_vint(w.writer, tag_id);\n+    write_vint(w.writer, tag_id as u64);\n \n     // Write a placeholder four-byte size.\n     w.size_positions += [w.writer.tell()];\n@@ -168,7 +171,7 @@ fn end_tag(w: writer) {\n     let last_size_pos = vec::pop::<uint>(w.size_positions);\n     let cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);\n-    write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n+    write_sized_vint(w.writer, (cur_pos - last_size_pos - 4u) as u64, 4u);\n     w.writer.seek(cur_pos as int, io::seek_set);\n }\n \n@@ -179,12 +182,12 @@ impl writer_util for writer {\n         end_tag(self);\n     }\n \n-    fn wr_uint(id: u64) {\n+    fn wr_u64(id: u64) {\n         write_vint(self.writer, id);\n     }\n \n-    fn wr_int(id: uint) {\n-        write_vint(self.writer, id);\n+    fn wr_uint(id: uint) {\n+        self.wr_u64(id as u64);\n     }\n \n     fn wr_bytes(b: [u8]) {"}, {"sha": "b71e057a5adbd42769a128cc163127ab4fe68fac", "filename": "src/libstd/serialization.rs", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=e712a47a812b4605adeea6ec56ba06550c060c78", "patch": "@@ -0,0 +1,252 @@\n+/*\n+Module: serialization\n+\n+Support code for serialization.\n+*/\n+\n+import list::list;\n+\n+iface serializer {\n+    // Primitive types:\n+    fn emit_nil();\n+    fn emit_u64(v: u64);\n+    fn emit_i64(v: u64);\n+    fn emit_bool(v: bool);\n+    fn emit_f64(v: f64);\n+    fn emit_str(v: str);\n+\n+    // Compound types:\n+    fn emit_enum(name: str, f: fn());\n+    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(idx: uint, f: fn());\n+    fn emit_vec(len: uint, f: fn());\n+    fn emit_vec_elt(idx: uint, f: fn());\n+    fn emit_box(f: fn());\n+    fn emit_uniq(f: fn());\n+    fn emit_rec(f: fn());\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n+    fn emit_tup(sz: uint, f: fn());\n+    fn emit_tup_elt(idx: uint, f: fn());\n+}\n+\n+iface deserializer {\n+    // Primitive types:\n+    fn read_nil() -> ();\n+    fn read_u64() -> u64;\n+    fn read_i64() -> i64;\n+    fn read_bool() -> bool;\n+    fn read_f64() -> f64;\n+    fn read_str() -> str;\n+\n+    // Compound types:\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+    fn read_box<T:copy>(f: fn() -> T) -> T;\n+    fn read_uniq<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec<T:copy>(f: fn() -> T) -> T;\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n+}\n+\n+/*\n+type ppserializer = {\n+    writer: io::writer\n+};\n+\n+impl serializer for ppserializer {\n+    fn emit_nil() { self.writer.write_str(\"()\") }\n+\n+    fn emit_u64(v: u64) { self.writer.write_str(#fmt[\"%lu\", v]); }\n+    fn emit_i64(v: u64) { ebml::write_vint(self, v as uint) }\n+    fn emit_bool(v: bool) { ebml::write_vint(self, v as uint) }\n+    fn emit_f64(v: f64) { fail \"float serialization not impl\"; }\n+    fn emit_str(v: str) {\n+        self.wr_tag(es_str as uint) {|| self.wr_str(v) }\n+    }\n+\n+    fn emit_enum(name: str, f: fn()) {\n+        self.wr_tag(es_enum as uint) {|| f() }\n+    }\n+    fn emit_enum_variant(v_name: str, v_id: uint, f: fn()) {\n+        self.wr_tag(es_enum_vid as uint) {|| self.write_vint(v_id) }\n+        self.wr_tag(es_enum_body as uint) {|| f() }\n+    }\n+\n+    fn emit_vec(len: uint, f: fn()) {\n+        self.wr_tag(es_vec as uint) {||\n+            self.wr_tag(es_vec_len as uint) {|| self.write_vint(len) }\n+            f()\n+        }\n+    }\n+\n+    fn emit_vec_elt(idx: uint, f: fn()) {\n+        self.wr_tag(es_vec_elt as uint) {|| f() }\n+    }\n+\n+    fn emit_vec_elt(idx: uint, f: fn()) {\n+        self.wr_tag(es_vec_elt as uint) {|| f() }\n+    }\n+\n+    fn emit_box(f: fn()) { f() }\n+    fn emit_uniq(f: fn()) { f() }\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) { f() }\n+    fn emit_tup(sz: uint, f: fn()) { f() }\n+    fn emit_tup_elt(idx: uint, f: fn()) { f() }\n+}\n+*/\n+\n+enum ebml_serializer_tags {\n+    es_str,\n+    es_enum, es_enum_vid, es_enum_body,\n+    es_vec, es_vec_len, es_vec_elt\n+}\n+\n+impl of serializer for ebml::writer {\n+    fn emit_nil() {}\n+\n+    fn emit_u64(v: u64) { ebml::write_vint(self, v) }\n+    fn emit_i64(v: u64) { ebml::write_vint(self, v as uint) }\n+    fn emit_bool(v: bool) { ebml::write_vint(self, v as uint) }\n+    fn emit_f64(v: f64) { fail \"float serialization not impl\"; }\n+    fn emit_str(v: str) {\n+        self.wr_tag(es_str as uint) {|| self.wr_str(v) }\n+    }\n+\n+    fn emit_enum(name: str, f: fn()) {\n+        self.wr_tag(es_enum as uint) {|| f() }\n+    }\n+    fn emit_enum_variant(v_name: str, v_id: uint, f: fn()) {\n+        self.wr_tag(es_enum_vid as uint) {|| self.write_vint(v_id) }\n+        self.wr_tag(es_enum_body as uint) {|| f() }\n+    }\n+    fn emit_enum_variant_arg(idx: uint, f: fn()) { f() }\n+\n+    fn emit_vec(len: uint, f: fn()) {\n+        self.wr_tag(es_vec as uint) {||\n+            self.wr_tag(es_vec_len as uint) {|| self.write_vint(len) }\n+            f()\n+        }\n+    }\n+\n+    fn emit_vec_elt(idx: uint, f: fn()) {\n+        self.wr_tag(es_vec_elt as uint) {|| f() }\n+    }\n+\n+    fn emit_vec_elt(idx: uint, f: fn()) {\n+        self.wr_tag(es_vec_elt as uint) {|| f() }\n+    }\n+\n+    fn emit_box(f: fn()) { f() }\n+    fn emit_uniq(f: fn()) { f() }\n+    fn emit_rec(f: fn()) { f() }\n+    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) { f() }\n+    fn emit_tup(sz: uint, f: fn()) { f() }\n+    fn emit_tup_elt(idx: uint, f: fn()) { f() }\n+}\n+\n+type ebml_deserializer = {mutable parent: ebml::doc,\n+                          mutable pos: uint};\n+\n+fn mk_ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n+    {mutable parent: d, mutable pos: 0u}\n+}\n+\n+impl of deserializer for ebml_deserializer {\n+    fn next_doc(exp_tag: uint) -> ebml::doc {\n+        if self.pos >= self.parent.end {\n+            fail \"no more documents in current node!\";\n+        }\n+        let (r_tag, r_doc) = ebml::doc_at(self.parent.data, self.pos);\n+        if r_tag != exp_tag {\n+            fail #fmt[\"expected EMBL doc with tag %u but found tag %u\",\n+                      exp_tag, r_tag];\n+        }\n+        if r_doc.end >= self.parent.end {\n+            fail #fmt[\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                      r_doc.end, self.parent.end];\n+        }\n+        self.pos = result.end;\n+        ret result;\n+    }\n+\n+    fn push_doc<T: copy>(d: ebml::doc, f: fn() -> T) -> T{\n+        let old_parent = self.parent;\n+        let old_pos = self.pos;\n+        self.parent = d;\n+        self.pos = 0u;\n+        let r = f();\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        ret r;\n+    }\n+\n+    fn next_u64(exp_tag: uint) {\n+        ebml::doc_as_uint(self.next_doc(exp_tag))\n+    }\n+\n+    fn read_nil() -> () { () }\n+    fn read_u64() -> u64 { next_u64(es_u64) }\n+    fn read_i64() -> i64 { next_u64(es_u64) as i64 }\n+    fn read_bool() -> bool { next_u64(es_u64) as bool }\n+    fn read_f64() -> f64 { fail \"Float\"; }\n+    fn read_str() -> str { ebml::doc_str(self.next_doc(es_str)) }\n+\n+    // Compound types:\n+    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n+        self.push_doc(self.next_doc(es_enum), f)\n+    }\n+\n+    fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n+        let idx = self.next_u64(es_enum_vid);\n+        self.push_doc(self.next_doc(es_enum_body)) {||\n+            f(idx)\n+        }\n+    }\n+\n+    fn read_enum_variant_arg<T:copy>(_idx: uint, f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n+        self.push_doc(self.next_doc(es_vec)) {||\n+            let len = self.next_u64(es_vec_len) as uint;\n+            f(len)\n+        }\n+    }\n+\n+    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        self.push_doc(self.next_doc(es_vec_elt), f)\n+    }\n+\n+    fn read_box<T:copy>(f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_uniq<T:copy>(f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_rec<T:copy>(f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n+        f()\n+    }\n+\n+    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+        f()\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Testing\n+"}, {"sha": "2c4b558f96f6ebc559a01f474fd2cc89961efd4d", "filename": "src/serializer/serializer.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712a47a812b4605adeea6ec56ba06550c060c78/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=e712a47a812b4605adeea6ec56ba06550c060c78", "patch": "@@ -166,42 +166,49 @@ impl serialize_ctx for serialize_ctx {\n \n         let body_node = alt ty::get(ty0).struct {\n           ty::ty_nil | ty::ty_bot { \"()\" }\n-          ty::ty_int(_) { #fmt[\"serialize_i64(cx, %s as i64)\", v] }\n-          ty::ty_uint(_) { #fmt[\"serialize_u64(cx, %s as u64)\", v] }\n-          ty::ty_float(_) { #fmt[\"serialize_float(cx, %s as float)\", v] }\n-          ty::ty_bool { #fmt[\"serialize_bool(cx, %s)\", v] }\n-          ty::ty_str { #fmt[\"serialize_str(cx, %s)\", v] }\n+          ty::ty_int(_) { #fmt[\"s.emit_i64(%s as i64)\", v] }\n+          ty::ty_uint(_) { #fmt[\"s.emit_u64(%s as u64)\", v] }\n+          ty::ty_float(_) { #fmt[\"s.emit_f64(%s as f64)\", v] }\n+          ty::ty_bool { #fmt[\"s.emit_bool(%s)\", v] }\n+          ty::ty_str { #fmt[\"s.emit_str(%s)\", v] }\n           ty::ty_enum(def_id, tps) { self.serialize_enum(v, def_id, tps) }\n-          ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_ptr(mt) {\n-            self.serialize_ty(mt.ty, #fmt[\"*%s\", v])\n+          ty::ty_box(mt) {\n+            let s = self.serialize_ty(mt.ty, #fmt[\"*%s\", v]);\n+            #fmt[\"s.emit_box({||%s})\", s]\n+          }\n+          ty::ty_uniq(mt) {\n+            let s = self.serialize_ty(mt.ty, #fmt[\"*%s\", v]);\n+            #fmt[\"s.emit_uniq({||%s})\", s]\n           }\n           ty::ty_vec(mt) {\n             let selem = self.serialize_ty(mt.ty, \"i\");\n-            #fmt[\"start_vec(cx); \\\n-                  vec::iter(v) {|i| \\\n-                  start_vec_item(cx); \\\n-                  %s; \\\n-                  end_vec_item(cx); \\\n-                  } \\\n-                  end_vec(cx);\", selem]\n+            #fmt[\"s.emit_vec(vec::len(v), {|| \\\n+                  uint::range(0, vec::len(v), {|i| \\\n+                  s.emit_vec_elt(i, {||\\\n+                  %s;\\\n+                  })})})\", selem]\n+          }\n+          ty::ty_class(_, _) {\n+            fail \"TODO--implement class\";\n           }\n           ty::ty_rec(fields) {\n             let stmts = vec::map(fields) {|field|\n                 let f_name = field.ident;\n                 let f_ty = field.mt.ty;\n                 self.serialize_ty(f_ty, #fmt[\"%s.%s\", v, f_name])\n             };\n-            self.blk_expr(stmts)\n+            #fmt[\"s.emit_rec({||%s})\", self.blk_expr(stmts)]\n           }\n           ty::ty_tup(tys) {\n-            let (pat, stmts) = self.serialize_arm(\"\", tys);\n-            #fmt[\"alt %s { \\\n+            let (pat, stmts) = self.serialize_arm(\"\", \"emit_tup_elt\", tys);\n+            #fmt[\"s.emit_tup(%uu, {|| alt %s { \\\n                     %s %s \\\n-                  }\", v, pat, self.blk_expr(stmts)]\n+                  }})\", vec::len(tys), v, pat, self.blk_expr(stmts)]\n           }\n           ty::ty_constr(t, _) {\n             self.serialize_ty(t, v)\n           }\n+          ty::ty_ptr(_) |\n           ty::ty_fn(_) |\n           ty::ty_iface(_, _) |\n           ty::ty_res(_, _, _) |\n@@ -212,7 +219,8 @@ impl serialize_ctx for serialize_ctx {\n           }\n         };\n \n-        let item = #fmt[\"fn %s(cx: ctxt, v: %s) {\\\n+        let item = #fmt[\"fn %s<S:std::serialization::serializer>\\\n+                            (s: S, v: %s) {\\\n                              %s;\\\n                          }\", name, ty0_str, body_node];\n         self.add_item(item);\n@@ -232,7 +240,8 @@ impl serialize_ctx for serialize_ctx {\n                 if n_args == 0u {\n                     (v_path, [])\n                 } else {\n-                    self.serialize_arm(v_path, variant.args)\n+                    self.serialize_arm(v_path, \"emit_enum_variant_arg\",\n+                                       variant.args)\n                 }\n             };\n \n@@ -251,7 +260,8 @@ impl serialize_ctx for serialize_ctx {\n               }\", v, str::connect(arms, \"\\n\")]\n     }\n \n-    fn serialize_arm(v_path: str, args: [ty::t]) -> (ast_pat, [ast_stmt]) {\n+    fn serialize_arm(v_path: str, emit_fn: str, args: [ty::t])\n+        -> (ast_pat, [ast_stmt]) {\n         let n_args = vec::len(args);\n         let arg_nms = vec::init_fn(n_args) {|i| #fmt[\"v%u\", i] };\n         let v_pat =\n@@ -260,7 +270,7 @@ impl serialize_ctx for serialize_ctx {\n             let arg_ty = args[i];\n             let serialize_expr =\n                 self.serialize_ty(arg_ty, arg_nms[i]);\n-            #fmt[\"%s;\", serialize_expr]\n+            #fmt[\"s.%s(%uu, {|| %s })\", emit_fn, i, serialize_expr]\n         };\n         (v_pat, stmts)\n     }"}]}