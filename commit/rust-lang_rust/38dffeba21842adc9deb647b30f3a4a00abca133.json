{"sha": "38dffeba21842adc9deb647b30f3a4a00abca133", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZGZmZWJhMjE4NDJhZGM5ZGViNjQ3YjMwZjNhNGEwMGFiY2ExMzM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-04-30T05:53:30Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-01T07:17:13Z"}, "message": "Move metadata writing earlier.\n\nThe commit moves metadata writing from `link_binary` to\n`encode_metadata` (and renames the latter as\n`encode_and_write_metadata`). This is at the very start of code\ngeneration.", "tree": {"sha": "c268cb996b85b68e4519d7aea48f8f7322b1f53d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c268cb996b85b68e4519d7aea48f8f7322b1f53d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38dffeba21842adc9deb647b30f3a4a00abca133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38dffeba21842adc9deb647b30f3a4a00abca133", "html_url": "https://github.com/rust-lang/rust/commit/38dffeba21842adc9deb647b30f3a4a00abca133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38dffeba21842adc9deb647b30f3a4a00abca133/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "html_url": "https://github.com/rust-lang/rust/commit/3da5d4a87e4fd3a96cf7e962211c875fe50650d4"}], "stats": {"total": 82, "additions": 48, "deletions": 34}, "files": [{"sha": "a7b8447ef356ae8817a0ebd8f925586e8bee9d2e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38dffeba21842adc9deb647b30f3a4a00abca133/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38dffeba21842adc9deb647b30f3a4a00abca133/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=38dffeba21842adc9deb647b30f3a4a00abca133", "patch": "@@ -2802,6 +2802,7 @@ dependencies = [\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n+ \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -2821,6 +2822,7 @@ dependencies = [\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "f25891d77ce5353b6b4564ee96beb44537e46ca2", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=38dffeba21842adc9deb647b30f3a4a00abca133", "patch": "@@ -7,7 +7,7 @@ use rustc::session::config::{\n };\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n-use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n+use rustc::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n use rustc::util::common::{time, time_ext};\n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::fx::FxHashSet;\n@@ -50,9 +50,9 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                                               outputs: &OutputFilenames,\n                                               crate_name: &str,\n                                               target_cpu: &str) {\n+    let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n-        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n            !output_metadata &&\n            crate_type == config::CrateType::Executable {\n@@ -68,29 +68,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             check_file_is_writeable(obj, sess);\n         }\n \n-        if outputs.outputs.contains_key(&OutputType::Metadata) {\n-            let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-            // To avoid races with another rustc process scanning the output directory,\n-            // we need to write the file somewhere else and atomically move it to its\n-            // final destination, with a `fs::rename` call. In order for the rename to\n-            // always succeed, the temporary file needs to be on the same filesystem,\n-            // which is why we create it inside the output directory specifically.\n-            let metadata_tmpdir = TempFileBuilder::new()\n-                .prefix(\"rmeta\")\n-                .tempdir_in(out_filename.parent().unwrap())\n-                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-            let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-            match fs::rename(&metadata, &out_filename) {\n-                Ok(_) => {\n-                    if sess.opts.debugging_opts.emit_directives {\n-                        sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n-                            format!(\"metadata file written: {}\", out_filename.display()));\n-                    }\n-                }\n-                Err(e) => sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n-            }\n-        }\n-\n         let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n             sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n \n@@ -248,13 +225,13 @@ pub fn each_linked_rlib(sess: &Session,\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(\n+pub fn emit_metadata<'a>(\n     sess: &'a Session,\n-    codegen_results: &CodegenResults,\n+    metadata: &EncodedMetadata,\n     tmpdir: &TempDir\n ) -> PathBuf {\n     let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n+    let result = fs::write(&out_filename, &metadata.raw_data);\n \n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n@@ -338,7 +315,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n         RlibFlavor::Normal => {\n             // Instead of putting the metadata in an object file section, rlibs\n             // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n+            ab.add_file(&emit_metadata(sess, &codegen_results.metadata, tmpdir));\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive."}, {"sha": "bcaa4216109aa7c839301286d4bae000ba6b7e2e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=38dffeba21842adc9deb647b30f3a4a00abca133", "patch": "@@ -24,6 +24,7 @@ rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n@@ -34,3 +35,4 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+tempfile = \"3.0.5\""}, {"sha": "6d3115c621343ad1eb131caa65d70a5e61fb26c1", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38dffeba21842adc9deb647b30f3a4a00abca133/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=38dffeba21842adc9deb647b30f3a4a00abca133", "patch": "@@ -20,7 +20,9 @@ use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType\n use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n+use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -50,6 +52,7 @@ use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n use serialize::json;\n+use tempfile::Builder as TempFileBuilder;\n \n use std::any::Any;\n use std::env;\n@@ -999,7 +1002,10 @@ fn analysis<'tcx>(\n     Ok(())\n }\n \n-fn encode_metadata<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> (middle::cstore::EncodedMetadata, bool) {\n+fn encode_and_write_metadata<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    outputs: &OutputFilenames,\n+) -> (middle::cstore::EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n@@ -1020,14 +1026,41 @@ fn encode_metadata<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> (middle::cstore::Encode\n         }\n     }).max().unwrap_or(MetadataKind::None);\n \n-    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n-\n     let metadata = match metadata_kind {\n         MetadataKind::None => middle::cstore::EncodedMetadata::new(),\n         MetadataKind::Uncompressed |\n         MetadataKind::Compressed => tcx.encode_metadata(),\n     };\n \n+    let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n+    if need_metadata_file {\n+        let crate_name = &tcx.crate_name(LOCAL_CRATE).as_str();\n+        let out_filename = filename_for_metadata(tcx.sess, crate_name, outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with an `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| {\n+                tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err))\n+            });\n+        let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n+        match std::fs::rename(&metadata_filename, &out_filename) {\n+            Ok(_) => {\n+                if tcx.sess.opts.debugging_opts.emit_directives {\n+                    tcx.sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n+                        format!(\"metadata file written: {}\", out_filename.display()));\n+                }\n+            }\n+            Err(e) => tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n+        }\n+    }\n+\n+    let need_metadata_module = metadata_kind == MetadataKind::Compressed;\n+\n     (metadata, need_metadata_module)\n }\n \n@@ -1048,8 +1081,8 @@ pub fn start_codegen<'tcx>(\n         middle::dependency_format::calculate(tcx)\n     });\n \n-    let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding\", || {\n-        encode_metadata(tcx)\n+    let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n+        encode_and_write_metadata(tcx, outputs)\n     });\n \n     tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));"}]}