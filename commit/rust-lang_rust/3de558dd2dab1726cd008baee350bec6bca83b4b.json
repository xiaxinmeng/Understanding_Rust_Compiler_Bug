{"sha": "3de558dd2dab1726cd008baee350bec6bca83b4b", "node_id": "C_kwDOAAsO6NoAKDNkZTU1OGRkMmRhYjE3MjZjZDAwOGJhZWUzNTBiZWM2YmNhODNiNGI", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-08-30T23:47:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T23:47:17Z"}, "message": "Rollup merge of #100927 - andrewpollack:fuchsia-docs-rustup, r=tmandry\n\nAdding new Fuchsia rustup docs... reworking walkthrough\n\nDocs improvements:\n* Adding new `rustup` target add for Fuchsia targets\n* Reworking walkthrough to show directory building as it happens\n* Reworking walkthrough to use `hello_fuchsia_pkg/` directory\n\ncc. `@djkoloski`", "tree": {"sha": "40e16d74909ec39f4da94b2072974d1732459144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40e16d74909ec39f4da94b2072974d1732459144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3de558dd2dab1726cd008baee350bec6bca83b4b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDqGFCRBK7hj4Ov3rIwAAnJkIAC8L2mhqWleZI4qZ20SKvF7j\nT7IzRR7lnLTKF3stIK1sp2Cs2Xrs17Knjxke5Lnohz8L1bKERl5TjBS0wxruKaZz\nrPOoKGsWpmi9JLWZ2QtKDNVmjWIQZkWx434lzvOpl1wZxvQPeeAq3+I3dxT1L18S\nSsSesf0YMm/Zh3SntgQAf9ItWO5N5HMuqP5bab6zclfkBoGvczDXx9kg6v5/xxc+\nCOjd6TFQ4cRD1wrkqRNTNqpwDC+CjBHJufdozO2Ny9njigEL2kg79JQU4bi1OQ40\nzNQF3lIUWJbbpR+eUKI5LFlmrXjIxl8MtR8fmh4roIhUWOaYZdawLnRlJkbOuKI=\n=3gpJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 40e16d74909ec39f4da94b2072974d1732459144\nparent 3a764e9396d24bdc840cf41efdab86c984b2d3b8\nparent c52d99f6e2174c5af74098884bcfeaf04e64b8a8\nauthor Yuki Okushi <jtitor@2k36.org> 1661903237 +0900\ncommitter GitHub <noreply@github.com> 1661903237 +0900\n\nRollup merge of #100927 - andrewpollack:fuchsia-docs-rustup, r=tmandry\n\nAdding new Fuchsia rustup docs... reworking walkthrough\n\nDocs improvements:\n* Adding new `rustup` target add for Fuchsia targets\n* Reworking walkthrough to show directory building as it happens\n* Reworking walkthrough to use `hello_fuchsia_pkg/` directory\n\ncc. `@djkoloski`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3de558dd2dab1726cd008baee350bec6bca83b4b", "html_url": "https://github.com/rust-lang/rust/commit/3de558dd2dab1726cd008baee350bec6bca83b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3de558dd2dab1726cd008baee350bec6bca83b4b/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a764e9396d24bdc840cf41efdab86c984b2d3b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a764e9396d24bdc840cf41efdab86c984b2d3b8", "html_url": "https://github.com/rust-lang/rust/commit/3a764e9396d24bdc840cf41efdab86c984b2d3b8"}, {"sha": "c52d99f6e2174c5af74098884bcfeaf04e64b8a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c52d99f6e2174c5af74098884bcfeaf04e64b8a8", "html_url": "https://github.com/rust-lang/rust/commit/c52d99f6e2174c5af74098884bcfeaf04e64b8a8"}], "stats": {"total": 523, "additions": 426, "deletions": 97}, "files": [{"sha": "c2a1613f288c5c8a7db18addef22bb474d17209b", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 426, "deletions": 97, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/3de558dd2dab1726cd008baee350bec6bca83b4b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/3de558dd2dab1726cd008baee350bec6bca83b4b/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=3de558dd2dab1726cd008baee350bec6bca83b4b", "patch": "@@ -5,14 +5,10 @@\n [Fuchsia] is a modern open source operating system that's simple, secure,\n updatable, and performant.\n \n-[Fuchsia]: https://fuchsia.dev/\n-\n ## Target maintainers\n \n The [Fuchsia team]:\n \n-[Fuchsia team]: https://team-api.infra.rust-lang.org/v1/teams/fuchsia.json\n-\n - Tyler Mandry ([@tmandry](https://github.com/tmandry))\n - Dan Johnson ([@computerdruid](https://github.com/computerdruid))\n - David Koloski ([@djkoloski](https://github.com/djkoloski))\n@@ -24,27 +20,162 @@ the members reported by the API. The API should be considered to be\n authoritative if this occurs. Instead of pinging individual members, use\n `@rustbot ping fuchsia` to contact the team on GitHub.\n \n+## Table of contents\n+\n+1. [Requirements](#requirements)\n+1. [Walkthrough structure](#walkthrough-structure)\n+1. [Compiling a Rust binary targeting Fuchsia](#compiling-a-rust-binary-targeting-fuchsia)\n+    1. [Targeting Fuchsia with rustup and cargo](#targeting-fuchsia-with-rustup-and-cargo)\n+    1. [Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\n+1. [Creating a Fuchsia package](#creating-a-fuchsia-package)\n+    1. [Creating a Fuchsia component](#creating-a-fuchsia-component)\n+    1. [Building a Fuchsia package](#building-a-fuchsia-package)\n+1. [Publishing a Fuchsia package](#publishing-a-fuchsia-package)\n+    1. [Creating a Fuchsia package repository](#creating-a-fuchsia-package-repository)\n+    1. [Publishing Fuchsia package to repository](#publishing-fuchsia-package-to-repository)\n+1. [Running a Fuchsia component on an emulator](#running-a-fuchsia-component-on-an-emulator)\n+    1. [Starting the Fuchsia emulator](#starting-the-fuchsia-emulator)\n+    1. [Watching emulator logs](#watching-emulator-logs)\n+    1. [Serving a Fuchsia package](#serving-a-fuchsia-package)\n+    1. [Running a Fuchsia component](#running-a-fuchsia-component)\n+1. [`.gitignore` extensions](#gitignore-extensions)\n+1. [Testing](#testing)\n+    1. [Running unit tests](#running-unit-tests)\n+    1. [Running the compiler test suite](#running-the-compiler-test-suite)\n+\n ## Requirements\n \n-This target is cross-compiled from a host environment. Development may be done\n-from the [source tree] or using the Fuchsia SDK.\n+This target is cross-compiled from a host environment. You will need a recent\n+copy of the [Fuchsia SDK], which provides the tools, libraries, and binaries\n+required to build and link programs for Fuchsia.\n \n-[source tree]: https://fuchsia.dev/fuchsia-src/get-started/learn/build\n+Development may also be done from the [source tree].\n \n-Fuchsia targets support std and follow the `sysv64` calling convention on\n+Fuchsia targets support `std` and follow the `sysv64` calling convention on\n x86_64. Fuchsia binaries use the ELF file format.\n \n-## Building the target\n+## Walkthrough structure\n+\n+This walkthrough will cover:\n+\n+1. Compiling a Rust binary targeting Fuchsia.\n+1. Building a Fuchsia package.\n+1. Publishing and running a Fuchsia package to a Fuchsia emulator.\n+\n+For the purposes of this walkthrough, we will only target `x86_64-fuchsia`.\n+\n+## Compiling a Rust binary targeting Fuchsia\n+\n+Today, there are two main ways to build a Rust binary targeting Fuchsia\n+using the Fuchsia SDK:\n+1. Allow [rustup] to handle the installation of Fuchsia targets for you.\n+1. Build a toolchain locally that can target Fuchsia.\n+\n+### Targeting Fuchsia with rustup and cargo\n+\n+The easiest way to build a Rust binary targeting Fuchsia is by allowing [rustup]\n+to handle the installation of Fuchsia targets for you. This can be done by issuing\n+the following commands:\n+\n+```sh\n+rustup target add x86_64-fuchsia\n+rustup target add aarch_64-fuchsia\n+```\n+\n+After installing our Fuchsia targets, we can now compile a Rust binary that targets\n+Fuchsia.\n+\n+To create our Rust project, we can issue a standard `cargo` command as follows:\n+\n+**From base working directory**\n+```sh\n+cargo new hello_fuchsia\n+```\n+\n+The rest of this walkthrough will take place from `hello_fuchsia`, so we can\n+change into that directory now:\n+\n+```sh\n+cd hello_fuchsia\n+```\n+\n+*Note: From this point onwards, all commands will be issued from the `hello_fuchsia/`\n+directory, and all `hello_fuchsia/` prefixes will be removed from references for sake of brevity.*\n+\n+We can edit our `src/main.rs` to include a test as follows:\n+\n+**`src/main.rs`**\n+```rust\n+fn main() {\n+    println!(\"Hello Fuchsia!\");\n+}\n+\n+#[test]\n+fn it_works() {\n+    assert_eq!(2 + 2, 4);\n+}\n+```\n+\n+In addition to the standard workspace created, we will want to create a\n+`.cargo/config.toml` file to link necessary libraries\n+during compilation:\n+\n+**`.cargo/config.toml`**\n+```txt\n+[target.x86_64-fuchsia]\n+\n+rustflags = [\n+    \"-Lnative\", \"<SDK_PATH>/arch/x64/sysroot/lib\",\n+    \"-Lnative\", \"<SDK_PATH>/arch/x64/lib\"\n+]\n+```\n+\n+*Note: Make sure to fill out `<SDK_PATH>` with the path to the downloaded [Fuchsia SDK].*\n+\n+In total, our new project will look like:\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503  \u2517\u2501 main.rs\n+\u2523\u2501 Cargo.toml\n+\u2517\u2501 .cargo/\n+   \u2517\u2501 config.toml\n+```\n+\n+Finally, we can build our rust binary as:\n+\n+```sh\n+cargo build --target x86_64-fuchsia\n+```\n+\n+Now we have a Rust binary at `target/x86_64-fuchsia/debug/hello_fuchsia`,\n+targeting our desired Fuchsia target.\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503  \u2517\u2501 main.rs\n+\u2523\u2501 target/\n+\u2503  \u2517\u2501 x86_64-fuchsia/\n+\u2503     \u2517\u2501 debug/\n+\u2503        \u2517\u2501 hello_fuchsia\n+\u2523\u2501 Cargo.toml\n+\u2517\u2501 .cargo/\n+   \u2517\u2501 config.toml\n+```\n+\n+### Targeting Fuchsia with a compiler built from source\n+\n+An alternative to the first workflow is to target Fuchsia by using\n+`rustc` built from source.\n \n Before building Rust for Fuchsia, you'll need a clang toolchain that supports\n Fuchsia as well. A recent version (14+) of clang should be sufficient to compile\n Rust for Fuchsia.\n \n-You'll also need a recent copy of the [Fuchsia SDK], which provides the tools\n-and binaries required to build and link programs for Fuchsia.\n-\n-[Fuchsia SDK]: https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core\n-\n x86-64 and AArch64 Fuchsia targets can be enabled using the following\n configuration.\n \n@@ -75,15 +206,21 @@ export CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/\n These can be run together in a shell environment by executing\n `(source config-env.sh && ./x.py install)`.\n \n-## Building Rust programs\n+Once `rustc` is installed, we can create a new working directory to work from,\n+`hello_fuchsia` along with `hello_fuchsia/src`:\n \n-After compiling Rust binaries, you'll need to build a component, package it, and\n-serve it to a Fuchsia device or emulator. All of this can be done using the\n-Fuchsia SDK.\n+```sh\n+mkdir hello_fuchsia\n+cd hello_fuchsia\n+mkdir src\n+```\n \n-As an example, we'll compile and run this simple program on a Fuchsia emulator:\n+*Note: From this point onwards, all commands will be issued from the `hello_fuchsia/`\n+directory, and all `hello_fuchsia/` prefixes will be removed from references for sake of brevity.*\n \n-**`hello_fuchsia.rs`**\n+There, we can create a new file named `src/hello_fuchsia.rs`:\n+\n+**`src/hello_fuchsia.rs`**\n ```rust\n fn main() {\n     println!(\"Hello Fuchsia!\");\n@@ -95,31 +232,87 @@ fn it_works() {\n }\n ```\n \n-Create a new file named `hello_fuchsia.rs` and fill out its contents with that\n-code.\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 src/\n+    \u2517\u2501 hello_fuchsia.rs\n+```\n+\n+Using your freshly installed `rustc`, you can compile a binary for Fuchsia using\n+the following options:\n+\n+* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n+  platform of your choice\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n+  the SDK\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib`: Link against Fuchsia kernel\n+  libraries from the SDK\n+\n+Putting it all together:\n+\n+```sh\n+# Configure these for the Fuchsia target of your choice\n+TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n+ARCH=\"<x64|aarch64>\"\n+\n+rustc \\\n+    --target ${TARGET_ARCH} \\\n+    -Lnative=${SDK_PATH}/arch/${ARCH}/lib \\\n+    -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib \\\n+    --out-dir bin src/hello_fuchsia.rs\n+```\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/\n+\u2503   \u2517\u2501 hello_fuchsia.rs\n+\u2517\u2501 bin/\n+   \u2517\u2501 hello_fuchsia\n+```\n+\n+## Creating a Fuchsia package\n \n-### Create a package\n+Before moving on, double check your directory structure:\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/                     (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n+\u2523\u2501 bin/                     ...\n+\u2503  \u2517\u2501 hello_fuchsia         ...\n+\u2523\u2501 src/                     (if using cargo)\n+\u2503  \u2517\u2501 main.rs               ...\n+\u2517\u2501 target/                  ...\n+   \u2517\u2501 x86_64-fuchsia/       ...\n+      \u2517\u2501 debug/             ...\n+         \u2517\u2501 hello_fuchsia   ...\n+```\n \n+With our Rust binary built, we can move to creating a Fuchsia package.\n On Fuchsia, a package is the unit of distribution for software. We'll need to\n create a new package directory where we will place files like our finished\n-binary and any data it may need. The working directory will have this layout:\n+binary and any data it may need.\n+\n+To start, make the `pkg`, and `pkg/meta` directories:\n+\n+```sh\n+mkdir pkg\n+mkdir pkg/meta\n+```\n \n+**Current directory structure**\n ```txt\n-hello_fuchsia.rs\n-hello_fuchsia.cml\n-package\n-\u2523\u2501 bin\n-\u2503  \u2517\u2501 hello_fuchsia\n-\u2523\u2501 meta\n-\u2503  \u2523\u2501 package\n-\u2503  \u2517\u2501 hello_fuchsia.cm\n-\u2517\u2501 hello_fuchsia.manifest\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2517\u2501 meta/\n ```\n \n-Make the `package`, `package/bin`, and `package/meta` directories and create the\n-following files inside:\n+Now, create the following files inside:\n \n-**`package/meta/package`**\n+**`pkg/meta/package`**\n ```json\n {\n   \"name\": \"hello_fuchsia\",\n@@ -130,56 +323,41 @@ following files inside:\n The `package` file describes our package's name and version number. Every\n package must contain one.\n \n-**`package/hello_fuchsia.manifest`**\n+**`pkg/hello_fuchsia.manifest`**\n ```txt\n-bin/hello_fuchsia=package/bin/hello_fuchsia\n+bin/hello_fuchsia=target/x86_64-fuchsia/debug/hello_fuchsia     # If using cargo...\n+bin/hello_fuchsia=bin/hello_fuchsia                             # If using rustc...\n lib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\n lib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\n-meta/package=package/meta/package\n-meta/hello_fuchsia.cm=package/meta/hello_fuchsia.cm\n+meta/package=pkg/meta/package\n+meta/hello_fuchsia.cm=pkg/meta/hello_fuchsia.cm\n ```\n \n *Note: Relative manifest paths are resolved starting from the working directory\n of `pm`. Make sure to fill out `<SDK_PATH>` with the path to the downloaded\n SDK.*\n \n The `.manifest` file will be used to describe the contents of the package by\n-relating their location when installed to their location on the file system. You\n-can use this to make a package pull files from other places, but for this\n-example we'll just be placing everything in the `package` directory.\n-\n-### Compiling a binary\n-\n-Using your freshly compiled `rustc`, you can compile a binary for Fuchsia using\n-the following options:\n-\n-* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n-  platform of your choice\n-* `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n-  the SDK\n-* `-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib`: Link against Fuchsia kernel\n-  libraries from the SDK\n-\n-Putting it all together:\n-\n-```sh\n-# Configure these for the Fuchsia target of your choice\n-TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n-ARCH=\"<x64|aarch64>\"\n+relating their location when installed to their location on the file system. The\n+`bin/hello_fuchsia=` entry will be different depending on how your Rust binary\n+was built, so choose accordingly.\n \n-rustc --target ${TARGET_ARCH} -Lnative=${SDK_PATH}/arch/${ARCH}/lib -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib -o package/bin/hello_fuchsia hello_fuchsia.rs\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2517\u2501 package\n+   \u2517\u2501 hello_fuchsia.manifest\n ```\n \n-### Bulding a component\n+### Creating a Fuchsia component\n \n-On Fuchsia, components require a component manifest written in Fuchia's markup\n+On Fuchsia, components require a component manifest written in Fuchsia's markup\n language called CML. The Fuchsia devsite contains an [overview of CML] and a\n [reference for the file format]. Here's a basic one that can run our single binary:\n \n-[overview of CML]: https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests\n-[reference for the file format]: https://fuchsia.dev/reference/cml\n-\n-**`hello_fuchsia.cml`**\n+**`pkg/hello_fuchsia.cml`**\n ```txt\n {\n     include: [ \"syslog/client.shard.cml\" ],\n@@ -190,43 +368,152 @@ language called CML. The Fuchsia devsite contains an [overview of CML] and a\n }\n ```\n \n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2517\u2501 package\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2517\u2501 hello_fuchsia.cml\n+```\n+\n Now we can compile that CML into a component manifest:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/cmc compile hello_fuchsia.cml --includepath ${SDK_PATH}/pkg -o package/meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/cmc compile \\\n+    pkg/hello_fuchsia.cml \\\n+    --includepath ${SDK_PATH}/pkg \\\n+    -o pkg/meta/hello_fuchsia.cm\n+```\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2517\u2501 hello_fuchsia.cml\n ```\n \n-`--includepath` tells the compiler where to look for `include`s from our CML.\n-In our case, we're only using `syslog/client.shard.cml`.\n+*Note: `--includepath` tells the compiler where to look for `include`s from our CML.\n+In our case, we're only using `syslog/client.shard.cml`.*\n \n-### Building and publishing a package\n+### Building a Fuchsia package\n \n-Next, we'll build our package as defined by our manifest:\n+Next, we'll build a package manifest as defined by our manifest:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm -o hello_fuchsia -m package/hello_fuchsia.manifest build -output-package-manifest hello_fuchsia_manifest\n+${SDK_PATH}/tools/${ARCH}/pm \\\n+    -o hello_fuchsia_manifest \\\n+    -m pkg/hello_fuchsia.manifest \\\n+    build \\\n+    -output-package-manifest hello_fuchsia_package_manifest\n+```\n+\n+This will produce `pkg/hello_fuchsia_manifest/` which is a package manifest we can\n+publish directly to a repository.\n+\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n ```\n \n-This will produce `hello_fuchsia_manifest` which is a package manifest we can\n-publish directly to a repository. We can set up that repository with:\n+We are now ready to publish the package.\n+\n+## Publishing a Fuchsia package\n+\n+With our package and component manifests setup,\n+we can now publish our package. The first step will\n+be to create a Fuchsia package repository to publish\n+to.\n+\n+### Creating a Fuchsia package repository\n+\n+We can set up our repository with:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm newrepo -repo repo\n+${SDK_PATH}/tools/${ARCH}/pm newrepo \\\n+    -repo pkg/repo\n ```\n \n-And then publish our new package to that repository with:\n+**Current directory structure**\n+```txt\n+hello_fuchsia/\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 repo/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n+```\n+\n+## Publishing Fuchsia package to repository\n+\n+We can publish our new package to that repository with:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/pm publish -repo repo -lp -f <(echo \"hello_fuchsia_manifest\")\n+${SDK_PATH}/tools/${ARCH}/pm publish \\\n+    -repo repo \\\n+    -lp -f <(echo \"hello_fuchsia_package_manifest\")\n ```\n \n-Then we can add it to `ffx`'s package server as `hello-fuchsia` using:\n+Then we can add the repository to `ffx`'s package server as `hello-fuchsia` using:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx repository add-from-pm repo -r hello-fuchsia\n+${SDK_PATH}/tools/${ARCH}/ffx repository add-from-pm \\\n+    repo \\\n+    -r hello-fuchsia\n+```\n+\n+## Running a Fuchsia component on an emulator\n+\n+At this point, we are ready to run our Fuchsia\n+component. For reference, our final directory\n+structure will look like:\n+\n+**Final directory structure**\n+```txt\n+hello_fuchsia/\n+\u2523\u2501 src/                     (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n+\u2523\u2501 bin/                     ...\n+\u2503  \u2517\u2501 hello_fuchsia         ...\n+\u2523\u2501 src/                     (if using cargo)\n+\u2503  \u2517\u2501 main.rs               ...\n+\u2523\u2501 target/                  ...\n+\u2503  \u2517\u2501 x86_64-fuchsia/       ...\n+\u2503     \u2517\u2501 debug/             ...\n+\u2503        \u2517\u2501 hello_fuchsia   ...\n+\u2517\u2501 pkg/\n+   \u2523\u2501 meta/\n+   \u2503  \u2523\u2501 package\n+   \u2503  \u2517\u2501 hello_fuchsia.cm\n+   \u2523\u2501 hello_fuchsia_manifest/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 repo/\n+   \u2503  \u2517\u2501 ...\n+   \u2523\u2501 hello_fuchsia.manifest\n+   \u2523\u2501 hello_fuchsia.cml\n+   \u2517\u2501 hello_fuchsia_package_manifest\n ```\n \n-### Starting the emulator\n+### Starting the Fuchsia emulator\n \n Start a Fuchsia emulator in a new terminal using:\n \n@@ -235,50 +522,83 @@ ${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}\n ${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless\n ```\n \n-Once the emulator is running, start a package repository server to serve our\n-package to the emulator:\n+### Watching emulator logs\n \n+Once the emulator is running, open a separate terminal to watch the emulator logs:\n+\n+**In separate terminal**\n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx repository server start\n+${SDK_PATH}/tools/${ARCH}/ffx log \\\n+    --since now\n ```\n \n-Once the repository server is up and running, register our repository:\n+### Serving a Fuchsia package\n+\n+Now, start a package repository server to serve our\n+package to the emulator:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx target repository register --repository hello-fuchsia\n+${SDK_PATH}/tools/${ARCH}/ffx repository server start\n ```\n \n-And watch the logs from the emulator in a separate terminal:\n+Once the repository server is up and running, register it with the target Fuchsia system running in the emulator:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx log --since now\n+${SDK_PATH}/tools/${ARCH}/ffx target repository register \\\n+    --repository hello-fuchsia\n ```\n \n+### Running a Fuchsia component\n+\n Finally, run the component:\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx component run fuchsia-pkg://hello-fuchsia/hello_fuchsia#meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/ffx component run \\\n+    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm\n ```\n \n On reruns of the component, the `--recreate` argument may also need to be\n passed.\n \n ```sh\n-${SDK_PATH}/tools/${ARCH}/ffx component run --recreate fuchsia-pkg://hello-fuchsia/hello_fuchsia#meta/hello_fuchsia.cm\n+${SDK_PATH}/tools/${ARCH}/ffx component run \\\n+    --recreate \\\n+    fuchsia-pkg://hello-fuchsia/hello_fuchsia_manifest#meta/hello_fuchsia.cm\n+```\n+\n+## `.gitignore` extensions\n+\n+Optionally, we can create/extend our `.gitignore` file to ignore files and\n+directories that are not helpful to track:\n+\n+```txt\n+pkg/repo\n+pkg/meta/hello_fuchsia.cm\n+pkg/hello_fuchsia_manifest\n+pkg/hello_fuchsia_package_manifest\n ```\n \n ## Testing\n \n ### Running unit tests\n \n-Tests can be run in the same way as a regular binary, simply by passing `--test`\n-to the `rustc` invocation and then repackaging and rerunning. The test harness\n-will run the applicable unit tests.\n+Tests can be run in the same way as a regular binary.\n+\n+* If using `cargo`, you can simply pass `test --no-run`\n+to the `cargo` invocation and then repackage and rerun the Fuchsia package. From our previous example,\n+this would look like `cargo test --target x86_64-fuchsia --no-run`, and moving the executable\n+binary path found from the line `Executable unittests src/main.rs (target/x86_64-fuchsia/debug/deps/hello_fuchsia-<HASH>)`\n+into `pkg/hello_fuchsia.manifest`.\n+\n+* If using the compiled `rustc`, you can simply pass `--test`\n+to the `rustc` invocation and then repackage and rerun the Fuchsia package.\n+\n+The test harness will run the applicable unit tests.\n \n Often when testing, you may want to pass additional command line arguments to\n your binary. Additional arguments can be set in the component manifest:\n \n-**`hello_fuchsia.cml`**\n+**`pkg/hello_fuchsia.cml`**\n ```txt\n {\n     include: [ \"syslog/client.shard.cml\" ],\n@@ -293,11 +613,20 @@ your binary. Additional arguments can be set in the component manifest:\n This will pass the argument `it_works` to the binary, filtering the tests to\n only those tests that match the pattern. There are many more configuration\n options available in CML including environment variables. More documentation is\n-available on the [Fuchsia devsite](https://fuchsia.dev/reference/cml).\n+available on the [Fuchsia devsite].\n \n ### Running the compiler test suite\n \n Running the Rust test suite on Fuchsia is [not currently supported], but work is\n underway to enable it.\n \n+[Fuchsia team]: https://team-api.infra.rust-lang.org/v1/teams/fuchsia.json\n+[Fuchsia]: https://fuchsia.dev/\n+[source tree]: https://fuchsia.dev/fuchsia-src/get-started/learn/build\n+[rustup]: https://rustup.rs/\n+[cargo]: https://doc.rust-lang.org/cargo/\n+[Fuchsia SDK]: https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core\n+[overview of CML]: https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests\n+[reference for the file format]: https://fuchsia.dev/reference/cml\n+[Fuchsia devsite]: https://fuchsia.dev/reference/cml\n [not currently supported]: https://fxbug.dev/105393"}]}