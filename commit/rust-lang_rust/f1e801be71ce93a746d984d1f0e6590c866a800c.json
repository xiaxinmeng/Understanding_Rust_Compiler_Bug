{"sha": "f1e801be71ce93a746d984d1f0e6590c866a800c", "node_id": "C_kwDOAAsO6NoAKGYxZTgwMWJlNzFjZTkzYTc0NmQ5ODRkMWYwZTY1OTBjODY2YTgwMGM", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-09T04:23:57Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-09T04:23:57Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "6a68700ade9f14c28b279aa170ca2b4edb26bacd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a68700ade9f14c28b279aa170ca2b4edb26bacd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1e801be71ce93a746d984d1f0e6590c866a800c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e801be71ce93a746d984d1f0e6590c866a800c", "html_url": "https://github.com/rust-lang/rust/commit/f1e801be71ce93a746d984d1f0e6590c866a800c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1e801be71ce93a746d984d1f0e6590c866a800c/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f03ce30962cf1b2a5158667eabae8bf6e8d1cb03", "url": "https://api.github.com/repos/rust-lang/rust/commits/f03ce30962cf1b2a5158667eabae8bf6e8d1cb03", "html_url": "https://github.com/rust-lang/rust/commit/f03ce30962cf1b2a5158667eabae8bf6e8d1cb03"}, {"sha": "634cfe3d72e785c843ca5d412b12be137b2e14fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/634cfe3d72e785c843ca5d412b12be137b2e14fb", "html_url": "https://github.com/rust-lang/rust/commit/634cfe3d72e785c843ca5d412b12be137b2e14fb"}], "stats": {"total": 1917, "additions": 1636, "deletions": 281}, "files": [{"sha": "a038dce3248aa41fb5ede1be651a3cf7fce1c078", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -19,7 +19,7 @@ Before submitting, please make sure that you're not running into one of these kn\n Otherwise please try to provide information which will help us to fix the issue faster. Minimal reproducible examples with few dependencies are especially lovely <3.\n -->\n \n-**rust-analyzer version**: (eg. output of \"Rust Analyzer: Show RA Version\" command)\n+**rust-analyzer version**: (eg. output of \"rust-analyzer: Show RA Version\" command, accessible in VSCode via <kbd>Ctrl/\u2318</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>)\n \n **rustc version**: (eg. output of `rustc -V`)\n "}, {"sha": "ca8eb1309de3dce3d92aa96a3e03a14ded9c781a", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -18,6 +18,7 @@ env:\n   FETCH_DEPTH: 0 # pull in the tags for the version string\n   MACOSX_DEPLOYMENT_TARGET: 10.15\n   CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc\n+  CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER: arm-linux-gnueabihf-gcc\n \n jobs:\n   dist:\n@@ -36,6 +37,9 @@ jobs:\n           - os: ubuntu-18.04\n             target: aarch64-unknown-linux-gnu\n             code-target: linux-arm64\n+          - os: ubuntu-18.04\n+            target: arm-unknown-linux-gnueabihf\n+            code-target: linux-armhf\n           - os: macos-11\n             target: x86_64-apple-darwin\n             code-target: darwin-x64\n@@ -67,13 +71,17 @@ jobs:\n           node-version: 14.x\n \n       - name: Update apt repositories\n-        if: matrix.target == 'aarch64-unknown-linux-gnu'\n+        if: matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'arm-unknown-linux-gnueabihf'\n         run: sudo apt-get update\n \n-      - name: Install target toolchain\n+      - name: Install AArch64 target toolchain\n         if: matrix.target == 'aarch64-unknown-linux-gnu'\n         run: sudo apt-get install gcc-aarch64-linux-gnu\n \n+      - name: Install ARM target toolchain\n+        if: matrix.target == 'arm-unknown-linux-gnueabihf'\n+        run: sudo apt-get install gcc-arm-linux-gnueabihf\n+\n       - name: Dist\n         run: cargo xtask dist --client-patch-version ${{ github.run_number }}\n \n@@ -204,6 +212,10 @@ jobs:\n         with:\n           name: dist-aarch64-unknown-linux-gnu\n           path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-arm-unknown-linux-gnueabihf\n+          path: dist\n       - uses: actions/download-artifact@v1\n         with:\n           name: dist-x86_64-pc-windows-msvc"}, {"sha": "8c3f6f8468bf6f64a1872b1c637fd774c844cbdc", "filename": "src/tools/rust-analyzer/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FREADME.md?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -43,7 +43,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer\n \n ## License\n \n-Rust analyzer is primarily distributed under the terms of both the MIT\n+rust-analyzer is primarily distributed under the terms of both the MIT\n license and the Apache License (Version 2.0).\n \n See LICENSE-APACHE and LICENSE-MIT for details."}, {"sha": "3347940ec6d639015304407bdd708dcff184c2bb", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -57,6 +57,7 @@ pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<Restart>,\n     _thread: jod_thread::JoinHandle,\n+    id: usize,\n }\n \n impl FlycheckHandle {\n@@ -72,18 +73,22 @@ impl FlycheckHandle {\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n-        FlycheckHandle { sender, _thread: thread }\n+        FlycheckHandle { id, sender, _thread: thread }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn update(&self) {\n         self.sender.send(Restart).unwrap();\n     }\n+\n+    pub fn id(&self) -> usize {\n+        self.id\n+    }\n }\n \n pub enum Message {\n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n+    AddDiagnostic { id: usize, workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n     Progress {\n@@ -96,8 +101,9 @@ pub enum Message {\n impl fmt::Debug for Message {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Message::AddDiagnostic { workspace_root, diagnostic } => f\n+            Message::AddDiagnostic { id, workspace_root, diagnostic } => f\n                 .debug_struct(\"AddDiagnostic\")\n+                .field(\"id\", id)\n                 .field(\"workspace_root\", workspace_root)\n                 .field(\"diagnostic_code\", &diagnostic.code.as_ref().map(|it| &it.code))\n                 .finish(),\n@@ -183,7 +189,7 @@ impl FlycheckActor {\n                     }\n                 }\n                 Event::CheckEvent(None) => {\n-                    tracing::debug!(\"flycheck finished\");\n+                    tracing::debug!(flycheck_id = self.id, \"flycheck finished\");\n \n                     // Watcher finished\n                     let cargo_handle = self.cargo_handle.take().unwrap();\n@@ -203,6 +209,7 @@ impl FlycheckActor {\n \n                     CargoMessage::Diagnostic(msg) => {\n                         self.send(Message::AddDiagnostic {\n+                            id: self.id,\n                             workspace_root: self.workspace_root.clone(),\n                             diagnostic: msg,\n                         });"}, {"sha": "469b28c2d9ede6a8edc9904792215579df6285af", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -451,7 +451,7 @@ impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n         if let GenericDefId::TraitId(id) = *self {\n             let trait_ref = id.lookup(db).source(db).value;\n             let idx = idx_iter.next().unwrap();\n-            params.insert(idx, Either::Right(trait_ref))\n+            params.insert(idx, Either::Right(trait_ref));\n         }\n \n         if let Some(generic_params_list) = generic_params_list {"}, {"sha": "3342d4db4aa64812d88c5c40e1cbd4a53a644165", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -14,7 +14,7 @@\n //! unaffected, so we don't have to recompute name resolution results or item data (see `data.rs`).\n //!\n //! The `ItemTree` for the currently open file can be displayed by using the VS Code command\n-//! \"Rust Analyzer: Debug ItemTree\".\n+//! \"rust-analyzer: Debug ItemTree\".\n //!\n //! Compared to rustc's architecture, `ItemTree` has properties from both rustc's AST and HIR: many\n //! syntax-level Rust features are already desugared to simpler forms in the `ItemTree`, but name"}, {"sha": "087268a9ecee4f2c3cac07835bb92b13277d7b0e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -224,7 +224,7 @@ pub(crate) fn field_visibilities_query(\n     let resolver = variant_id.module(db).resolver(db);\n     let mut res = ArenaMap::default();\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, field_data.visibility.resolve(db, &resolver))\n+        res.insert(field_id, field_data.visibility.resolve(db, &resolver));\n     }\n     Arc::new(res)\n }"}, {"sha": "e46f43a878fe13c7597b2d0a23e456d35a537587", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -5,7 +5,7 @@ use std::mem;\n use mbe::{SyntheticToken, SyntheticTokenId, TokenMap};\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n use tt::Subtree;\n@@ -142,8 +142,59 @@ pub(crate) fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n                         ]);\n                     }\n                 },\n+                ast::WhileExpr(it) => {\n+                    if it.condition().is_none() {\n+                        // insert placeholder token after the while token\n+                        let while_token = match it.while_token() {\n+                            Some(t) => t,\n+                            None => continue,\n+                        };\n+                        append.insert(while_token.into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::IDENT,\n+                                text: \"__ra_fixup\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                    if it.loop_body().is_none() {\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n+                ast::LoopExpr(it) => {\n+                    if it.loop_body().is_none() {\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n                 // FIXME: foo::\n-                // FIXME: for, loop, match etc.\n+                // FIXME: for, match etc.\n                 _ => (),\n             }\n         }\n@@ -376,6 +427,61 @@ fn foo() {\n             // the {} gets parsed as the condition, I think?\n             expect![[r#\"\n fn foo () {if {} {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_while_1() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_while_2() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while foo\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while foo {}}\n+\"#]],\n+        )\n+    }\n+    #[test]\n+    fn fixup_while_3() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while {}\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {loop {}}\n \"#]],\n         )\n     }"}, {"sha": "47d191822d841af60e5ae81977cabc7b45747e56", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -381,6 +381,7 @@ pub mod known {\n         bitor,\n         bitxor_assign,\n         bitxor,\n+        branch,\n         deref_mut,\n         deref,\n         div_assign,\n@@ -396,6 +397,7 @@ pub mod known {\n         not,\n         owned_box,\n         partial_ord,\n+        poll,\n         r#fn,\n         rem_assign,\n         rem,"}, {"sha": "2a13106390d9f7f90773d1377bdc8b24351ca393", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -10,13 +10,13 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Ordering, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    ConstParamId, FieldId, FunctionId, ItemContainerId, Lookup,\n+    ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use stdx::always;\n use syntax::ast::RangeOp;\n \n@@ -28,7 +28,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, VisibleFromModule},\n+    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -947,7 +947,9 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = self.resolve_binop_method(op);\n+        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        });\n         let func = match func {\n             Some(func) => func,\n             None => {\n@@ -1473,55 +1475,4 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n-\n-    fn resolve_binop_method(&self, op: BinaryOp) -> Option<FunctionId> {\n-        let (name, lang_item) = match op {\n-            BinaryOp::LogicOp(_) => return None,\n-            BinaryOp::ArithOp(aop) => match aop {\n-                ArithOp::Add => (name!(add), name!(add)),\n-                ArithOp::Mul => (name!(mul), name!(mul)),\n-                ArithOp::Sub => (name!(sub), name!(sub)),\n-                ArithOp::Div => (name!(div), name!(div)),\n-                ArithOp::Rem => (name!(rem), name!(rem)),\n-                ArithOp::Shl => (name!(shl), name!(shl)),\n-                ArithOp::Shr => (name!(shr), name!(shr)),\n-                ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-                ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-                ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n-            },\n-            BinaryOp::Assignment { op: Some(aop) } => match aop {\n-                ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-                ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-                ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-                ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-                ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-                ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-                ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-                ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-                ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-                ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n-            },\n-            BinaryOp::CmpOp(cop) => match cop {\n-                CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-                CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n-                CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                    (name!(le), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                    (name!(lt), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                    (name!(ge), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                    (name!(gt), name!(partial_ord))\n-                }\n-            },\n-            BinaryOp::Assignment { op: None } => return None,\n-        };\n-\n-        let trait_ = self.resolve_lang_item(lang_item)?.as_trait()?;\n-\n-        self.db.trait_data(trait_).method_by_name(&name)\n-    }\n }"}, {"sha": "239f66bcb7e798f813a0e2d9206f78897a1d0c95", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -1126,7 +1126,7 @@ pub(crate) fn field_types_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, make_binders(db, &generics, ctx.lower_ty(&field_data.type_ref)))\n+        res.insert(field_id, make_binders(db, &generics, ctx.lower_ty(&field_data.type_ref)));\n     }\n     Arc::new(res)\n }"}, {"sha": "64622545f8408b190cec4f87e906a0627d515a6a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -336,7 +336,7 @@ impl InherentImpls {\n     }\n }\n \n-pub fn inherent_impl_crates_query(\n+pub(crate) fn inherent_impl_crates_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     fp: TyFingerprint,\n@@ -419,6 +419,55 @@ pub fn def_crates(\n     }\n }\n \n+pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+    use hir_expand::name;\n+    use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n+    Some(match op {\n+        BinaryOp::LogicOp(_) => return None,\n+        BinaryOp::ArithOp(aop) => match aop {\n+            ArithOp::Add => (name!(add), name!(add)),\n+            ArithOp::Mul => (name!(mul), name!(mul)),\n+            ArithOp::Sub => (name!(sub), name!(sub)),\n+            ArithOp::Div => (name!(div), name!(div)),\n+            ArithOp::Rem => (name!(rem), name!(rem)),\n+            ArithOp::Shl => (name!(shl), name!(shl)),\n+            ArithOp::Shr => (name!(shr), name!(shr)),\n+            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n+            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n+            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+        },\n+        BinaryOp::Assignment { op: Some(aop) } => match aop {\n+            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n+            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n+            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n+            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n+            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n+            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n+            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n+            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n+            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n+            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+        },\n+        BinaryOp::CmpOp(cop) => match cop {\n+            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n+            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n+                (name!(le), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n+                (name!(lt), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n+                (name!(ge), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n+                (name!(gt), name!(partial_ord))\n+            }\n+        },\n+        BinaryOp::Assignment { op: None } => return None,\n+    })\n+}\n+\n /// Look up the method with the given name.\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,"}, {"sha": "416b6f58061da344580f4d9b672c6006e4749852", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -357,6 +357,26 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n+    pub fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<Function> {\n+        self.imp.resolve_await_to_poll(await_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<Function> {\n+        self.imp.resolve_prefix_expr(prefix_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<Function> {\n+        self.imp.resolve_index_expr(index_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<Function> {\n+        self.imp.resolve_bin_expr(bin_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<Function> {\n+        self.imp.resolve_try_expr(try_expr).map(Function::from)\n+    }\n+\n     pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.imp.resolve_method_call_as_callable(call)\n     }\n@@ -1066,6 +1086,26 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<FunctionId> {\n+        self.analyze(await_expr.syntax())?.resolve_await_to_poll(self.db, await_expr)\n+    }\n+\n+    fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<FunctionId> {\n+        self.analyze(prefix_expr.syntax())?.resolve_prefix_expr(self.db, prefix_expr)\n+    }\n+\n+    fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<FunctionId> {\n+        self.analyze(index_expr.syntax())?.resolve_index_expr(self.db, index_expr)\n+    }\n+\n+    fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<FunctionId> {\n+        self.analyze(bin_expr.syntax())?.resolve_bin_expr(self.db, bin_expr)\n+    }\n+\n+    fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<FunctionId> {\n+        self.analyze(try_expr.syntax())?.resolve_try_expr(self.db, try_expr)\n+    }\n+\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.analyze(call.syntax())?.resolve_method_call_as_callable(self.db, call)\n     }"}, {"sha": "f5e2e44307090151c24908cd5cf11a5896b0e709", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -25,15 +25,20 @@ use hir_def::{\n     Lookup, ModuleDefId, VariantId,\n };\n use hir_expand::{\n-    builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n+    builtin_fn_macro::BuiltinFnLikeExpander,\n+    hygiene::Hygiene,\n+    name,\n+    name::{AsName, Name},\n+    HirFileId, InFile,\n };\n use hir_ty::{\n     diagnostics::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution, Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution,\n-    TyExt, TyKind, TyLoweringContext,\n+    method_resolution::{self, lang_names_for_bin_op},\n+    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n+    TyLoweringContext,\n };\n use itertools::Itertools;\n use smallvec::SmallVec;\n@@ -255,8 +260,90 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n-        let f_in_impl = self.resolve_impl_method(db, f_in_trait, &substs);\n-        f_in_impl.or(Some(f_in_trait))\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+    }\n+\n+    pub(crate) fn resolve_await_to_poll(\n+        &self,\n+        db: &dyn HirDatabase,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &await_expr.expr()?.into())?;\n+\n+        let op_fn = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n+            .as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_prefix_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<FunctionId> {\n+        let lang_item_name = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => name![deref],\n+            ast::UnaryOp::Not => name![not],\n+            ast::UnaryOp::Neg => name![neg],\n+        };\n+        let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_index_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<FunctionId> {\n+        let base_ty = self.ty_of_expr(db, &index_expr.base()?.into())?;\n+        let index_ty = self.ty_of_expr(db, &index_expr.index()?.into())?;\n+\n+        let lang_item_name = name![index];\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+            .push(base_ty.clone())\n+            .push(index_ty.clone())\n+            .build();\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_bin_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        binop_expr: &ast::BinExpr,\n+    ) -> Option<FunctionId> {\n+        let op = binop_expr.op_kind()?;\n+        let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n+        let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n+\n+        let op_fn = lang_names_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let substs =\n+            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_try_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &try_expr.expr()?.into())?;\n+\n+        let op_fn =\n+            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -666,6 +753,29 @@ impl SourceAnalyzer {\n         let fun_data = db.function_data(func);\n         method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n     }\n+\n+    fn resolve_impl_method_or_trait_def(\n+        &self,\n+        db: &dyn HirDatabase,\n+        func: FunctionId,\n+        substs: &Substitution,\n+    ) -> FunctionId {\n+        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+    }\n+\n+    fn lang_trait_fn(\n+        &self,\n+        db: &dyn HirDatabase,\n+        lang_trait: &Name,\n+        method_name: &Name,\n+    ) -> Option<FunctionId> {\n+        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n+            .method_by_name(method_name)\n+    }\n+\n+    fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {\n+        self.infer.as_ref()?.type_of_expr.get(self.expr_id(db, &expr)?)\n+    }\n }\n \n fn scope_for("}, {"sha": "35cd42908af2c0d225d3fa5d0fb3336fb3629d96", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 356, "deletions": 19, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -1,8 +1,8 @@\n-use hir::{HasSource, InFile};\n+use hir::{HasSource, HirDisplay, InFile};\n use ide_db::assists::{AssistId, AssistKind};\n use syntax::{\n-    ast::{self, edit::IndentLevel},\n-    AstNode, TextSize,\n+    ast::{self, make, HasArgList},\n+    match_ast, AstNode, SyntaxNode,\n };\n \n use crate::assist_context::{AssistContext, Assists};\n@@ -32,8 +32,8 @@ use crate::assist_context::{AssistContext, Assists};\n // }\n // ```\n pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let path = path_expr.path()?;\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let parent = path_parent(&path)?;\n \n     if ctx.sema.resolve_path(&path).is_some() {\n         // No need to generate anything if the path resolves\n@@ -50,45 +50,152 @@ pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>)\n         ctx.sema.resolve_path(&path.qualifier()?)\n     {\n         let target = path.syntax().text_range();\n-        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref);\n+        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, parent);\n     }\n \n     None\n }\n \n+#[derive(Debug)]\n+enum PathParent {\n+    PathExpr(ast::PathExpr),\n+    RecordExpr(ast::RecordExpr),\n+    PathPat(ast::PathPat),\n+    UseTree(ast::UseTree),\n+}\n+\n+impl PathParent {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            PathParent::PathExpr(it) => it.syntax(),\n+            PathParent::RecordExpr(it) => it.syntax(),\n+            PathParent::PathPat(it) => it.syntax(),\n+            PathParent::UseTree(it) => it.syntax(),\n+        }\n+    }\n+\n+    fn make_field_list(&self, ctx: &AssistContext<'_>) -> Option<ast::FieldList> {\n+        let scope = ctx.sema.scope(self.syntax())?;\n+\n+        match self {\n+            PathParent::PathExpr(it) => {\n+                if let Some(call_expr) = it.syntax().parent().and_then(ast::CallExpr::cast) {\n+                    make_tuple_field_list(call_expr, ctx, &scope)\n+                } else {\n+                    None\n+                }\n+            }\n+            PathParent::RecordExpr(it) => make_record_field_list(it, ctx, &scope),\n+            PathParent::UseTree(_) | PathParent::PathPat(_) => None,\n+        }\n+    }\n+}\n+\n+fn path_parent(path: &ast::Path) -> Option<PathParent> {\n+    let parent = path.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::PathExpr(it) => Some(PathParent::PathExpr(it)),\n+            ast::RecordExpr(it) => Some(PathParent::RecordExpr(it)),\n+            ast::PathPat(it) => Some(PathParent::PathPat(it)),\n+            ast::UseTree(it) => Some(PathParent::UseTree(it)),\n+            _ => None\n+        }\n+    }\n+}\n+\n fn add_variant_to_accumulator(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n     target: syntax::TextRange,\n     adt: hir::Enum,\n     name_ref: &ast::NameRef,\n+    parent: PathParent,\n ) -> Option<()> {\n     let db = ctx.db();\n     let InFile { file_id, value: enum_node } = adt.source(db)?.original_ast_node(db)?;\n-    let enum_indent = IndentLevel::from_node(&enum_node.syntax());\n-\n-    let variant_list = enum_node.variant_list()?;\n-    let offset = variant_list.syntax().text_range().end() - TextSize::of('}');\n-    let empty_enum = variant_list.variants().next().is_none();\n \n     acc.add(\n         AssistId(\"generate_enum_variant\", AssistKind::Generate),\n         \"Generate variant\",\n         target,\n         |builder| {\n             builder.edit_file(file_id.original_file(db));\n-            let text = format!(\n-                \"{maybe_newline}{indent_1}{name},\\n{enum_indent}\",\n-                maybe_newline = if empty_enum { \"\\n\" } else { \"\" },\n-                indent_1 = IndentLevel(1),\n-                name = name_ref,\n-                enum_indent = enum_indent\n-            );\n-            builder.insert(offset, text)\n+            let node = builder.make_mut(enum_node);\n+            let variant = make_variant(ctx, name_ref, parent);\n+            node.variant_list().map(|it| it.add_variant(variant.clone_for_update()));\n         },\n     )\n }\n \n+fn make_variant(\n+    ctx: &AssistContext<'_>,\n+    name_ref: &ast::NameRef,\n+    parent: PathParent,\n+) -> ast::Variant {\n+    let field_list = parent.make_field_list(ctx);\n+    make::variant(make::name(&name_ref.text()), field_list)\n+}\n+\n+fn make_record_field_list(\n+    record: &ast::RecordExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let fields = record.record_expr_field_list()?.fields();\n+    let record_fields = fields.map(|field| {\n+        let name = name_from_field(&field);\n+\n+        let ty = field\n+            .expr()\n+            .and_then(|it| expr_ty(ctx, it, scope))\n+            .unwrap_or_else(make::ty_placeholder);\n+\n+        make::record_field(None, name, ty)\n+    });\n+    Some(make::record_field_list(record_fields).into())\n+}\n+\n+fn name_from_field(field: &ast::RecordExprField) -> ast::Name {\n+    let text = match field.name_ref() {\n+        Some(it) => it.to_string(),\n+        None => name_from_field_shorthand(field).unwrap_or(\"unknown\".to_string()),\n+    };\n+    make::name(&text)\n+}\n+\n+fn name_from_field_shorthand(field: &ast::RecordExprField) -> Option<String> {\n+    let path = match field.expr()? {\n+        ast::Expr::PathExpr(path_expr) => path_expr.path(),\n+        _ => None,\n+    }?;\n+    Some(path.as_single_name_ref()?.to_string())\n+}\n+\n+fn make_tuple_field_list(\n+    call_expr: ast::CallExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let args = call_expr.arg_list()?.args();\n+    let tuple_fields = args.map(|arg| {\n+        let ty = expr_ty(ctx, arg, &scope).unwrap_or_else(make::ty_placeholder);\n+        make::tuple_field(None, ty)\n+    });\n+    Some(make::tuple_field_list(tuple_fields).into())\n+}\n+\n+fn expr_ty(\n+    ctx: &AssistContext<'_>,\n+    arg: ast::Expr,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::Type> {\n+    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted())?;\n+    let text = ty.display_source_code(ctx.db(), scope.module().into()).ok()?;\n+    Some(make::ty(&text))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -221,6 +328,236 @@ mod m {\n fn main() {\n     m::Foo::Baz\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(bool),\n+}\n+fn main() {\n+    Foo::Bar(true)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(x)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(_),\n+}\n+fn main() {\n+    Foo::Bar(x)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_multi_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true, x, Struct {})\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar(bool, _, Struct),\n+}\n+fn main() {\n+    Foo::Bar(true, x, Struct {})\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: true }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    Foo::Bar { x: true }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: y }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x: y }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    let x = true;\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    let x = true;\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_multiple_fields() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar { x: _, y: _, s: Struct },\n+}\n+fn main() {\n+    Foo::Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn use_tree() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+//- /main.rs\n+mod foo;\n+use foo::Foo::Bar$0;\n+\n+//- /foo.rs\n+enum Foo {}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_path_type() {\n+        check_assist_not_applicable(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+impl Foo::Bar$0 {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn path_pat() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar$0 =>\n+    }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar =>\n+    }\n+}\n \",\n         )\n     }"}, {"sha": "f8134c552f7563295d264cc0681bbc8af49e47f7", "filename": "src/tools/rust-analyzer/crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -45,7 +45,7 @@ impl RootDatabase {\n     // |===\n     // | Editor  | Action Name\n     //\n-    // | VS Code | **Rust Analyzer: Memory Usage (Clears Database)**\n+    // | VS Code | **rust-analyzer: Memory Usage (Clears Database)**\n     // |===\n     // image::https://user-images.githubusercontent.com/48062697/113065592-08559f00-91b1-11eb-8c96-64b88068ec02.gif[]\n     pub fn per_query_memory_usage(&mut self) -> Vec<(String, Bytes)> {"}, {"sha": "6c13c039723b297a2a5b22645893b2c4c4e09590", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -127,10 +127,12 @@ impl Definition {\n     }\n }\n \n+// FIXME: IdentClass as a name no longer fits\n #[derive(Debug)]\n pub enum IdentClass {\n     NameClass(NameClass),\n     NameRefClass(NameRefClass),\n+    Operator(OperatorClass),\n }\n \n impl IdentClass {\n@@ -147,6 +149,11 @@ impl IdentClass {\n                         .map(IdentClass::NameClass)\n                         .or_else(|| NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass))\n                 },\n+                ast::AwaitExpr(await_expr) => OperatorClass::classify_await(sema, &await_expr).map(IdentClass::Operator),\n+                ast::BinExpr(bin_expr) => OperatorClass::classify_bin(sema, &bin_expr).map(IdentClass::Operator),\n+                ast::IndexExpr(index_expr) => OperatorClass::classify_index(sema, &index_expr).map(IdentClass::Operator),\n+                ast::PrefixExpr(prefix_expr) => OperatorClass::classify_prefix(sema,&prefix_expr).map(IdentClass::Operator),\n+                ast::TryExpr(try_expr) => OperatorClass::classify_try(sema,&try_expr).map(IdentClass::Operator),\n                 _ => None,\n             }\n         }\n@@ -184,6 +191,33 @@ impl IdentClass {\n                 res.push(Definition::Local(local_ref));\n                 res.push(Definition::Field(field_ref));\n             }\n+            IdentClass::Operator(\n+                OperatorClass::Await(func)\n+                | OperatorClass::Prefix(func)\n+                | OperatorClass::Bin(func)\n+                | OperatorClass::Index(func)\n+                | OperatorClass::Try(func),\n+            ) => res.push(Definition::Function(func)),\n+        }\n+        res\n+    }\n+\n+    pub fn definitions_no_ops(self) -> ArrayVec<Definition, 2> {\n+        let mut res = ArrayVec::new();\n+        match self {\n+            IdentClass::NameClass(NameClass::Definition(it) | NameClass::ConstReference(it)) => {\n+                res.push(it)\n+            }\n+            IdentClass::NameClass(NameClass::PatFieldShorthand { local_def, field_ref }) => {\n+                res.push(Definition::Local(local_def));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::NameRefClass(NameRefClass::Definition(it)) => res.push(it),\n+            IdentClass::NameRefClass(NameRefClass::FieldShorthand { local_ref, field_ref }) => {\n+                res.push(Definition::Local(local_ref));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::Operator(_) => (),\n         }\n         res\n     }\n@@ -332,6 +366,52 @@ impl NameClass {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum OperatorClass {\n+    Await(Function),\n+    Prefix(Function),\n+    Index(Function),\n+    Try(Function),\n+    Bin(Function),\n+}\n+\n+impl OperatorClass {\n+    pub fn classify_await(\n+        sema: &Semantics<'_, RootDatabase>,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_await_to_poll(await_expr).map(OperatorClass::Await)\n+    }\n+\n+    pub fn classify_prefix(\n+        sema: &Semantics<'_, RootDatabase>,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_prefix_expr(prefix_expr).map(OperatorClass::Prefix)\n+    }\n+\n+    pub fn classify_try(\n+        sema: &Semantics<'_, RootDatabase>,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_try_expr(try_expr).map(OperatorClass::Try)\n+    }\n+\n+    pub fn classify_index(\n+        sema: &Semantics<'_, RootDatabase>,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_index_expr(index_expr).map(OperatorClass::Index)\n+    }\n+\n+    pub fn classify_bin(\n+        sema: &Semantics<'_, RootDatabase>,\n+        bin_expr: &ast::BinExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_bin_expr(bin_expr).map(OperatorClass::Bin)\n+    }\n+}\n+\n /// This is similar to [`NameClass`], but works for [`ast::NameRef`] rather than\n /// for [`ast::Name`]. Similarly, what looks like a reference in syntax is a\n /// reference most of the time, but there are a couple of annoying exceptions."}, {"sha": "739e0ccb436dbeebad6112430c610ca79a93688e", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -57,7 +57,7 @@\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Structural Search Replace**\n+// | VS Code | **rust-analyzer: Structural Search Replace**\n // |===\n //\n // Also available as an assist, by writing a comment containing the structural"}, {"sha": "5a8cda8fb3dda19e0c4ea6c5c0f4b0fbc72073f9", "filename": "src/tools/rust-analyzer/crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -7,7 +7,7 @@ use ide_db::{\n     search::FileReference,\n     FxIndexMap, RootDatabase,\n };\n-use syntax::{ast, AstNode, SyntaxKind::NAME, TextRange};\n+use syntax::{ast, AstNode, SyntaxKind::IDENT, TextRange};\n \n use crate::{goto_definition, FilePosition, NavigationTarget, RangeInfo, TryToNav};\n \n@@ -79,7 +79,7 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     let file = sema.parse(file_id);\n     let file = file.syntax();\n     let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n-        NAME => 1,\n+        IDENT => 1,\n         _ => 0,\n     })?;\n     let mut calls = CallLocations::default();"}, {"sha": "93252339cd4a83885f6b26a54b30b3f0ecf65cb4", "filename": "src/tools/rust-analyzer/crates/ide/src/expand_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -19,7 +19,7 @@ pub struct ExpandedMacro {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Expand macro recursively**\n+// | VS Code | **rust-analyzer: Expand macro recursively**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif[]\n@@ -32,7 +32,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         _ => 0,\n     })?;\n \n-    // due to how Rust Analyzer works internally, we need to special case derive attributes,\n+    // due to how rust-analyzer works internally, we need to special case derive attributes,\n     // otherwise they might not get found, e.g. here with the cursor at $0 `#[attr]` would expand:\n     // ```\n     // #[attr]"}, {"sha": "b2123b9a87938545f4e9609e4e586289b8634aa9", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -39,7 +39,11 @@ pub(crate) fn goto_definition(\n             | T![super]\n             | T![crate]\n             | T![Self]\n-            | COMMENT => 2,\n+            | COMMENT => 4,\n+            // index and prefix ops\n+            T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+            kind if kind.is_keyword() => 2,\n+            T!['('] | T![')'] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         })?;\n@@ -1628,6 +1632,122 @@ macro_rules! foo {\n }\n \n foo!(bar$0);\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_await_poll() {\n+        check(\n+            r#\"\n+//- minicore: future\n+\n+struct MyFut;\n+\n+impl core::future::Future for MyFut {\n+    type Output = ();\n+\n+    fn poll(\n+     //^^^^\n+        self: std::pin::Pin<&mut Self>,\n+        cx: &mut std::task::Context<'_>\n+    ) -> std::task::Poll<Self::Output>\n+    {\n+        ()\n+    }\n+}\n+\n+fn f() {\n+    MyFut.await$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_try_op() {\n+        check(\n+            r#\"\n+//- minicore: try\n+\n+struct Struct;\n+\n+impl core::ops::Try for Struct {\n+    fn branch(\n+     //^^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct?$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_index_op() {\n+        check(\n+            r#\"\n+//- minicore: index\n+\n+struct Struct;\n+\n+impl core::ops::Index<usize> for Struct {\n+    fn index(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct[0]$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_prefix_op() {\n+        check(\n+            r#\"\n+//- minicore: deref\n+\n+struct Struct;\n+\n+impl core::ops::Deref for Struct {\n+    fn deref(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    $0*Struct;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_bin_op() {\n+        check(\n+            r#\"\n+//- minicore: add\n+\n+struct Struct;\n+\n+impl core::ops::Add for Struct {\n+    fn add(\n+     //^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct +$0 Struct;\n+}\n \"#,\n         );\n     }"}, {"sha": "b3f711b6b88c4edd0b97403d85fc99b0857317a9", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn goto_implementation(\n \n     let original_token =\n         pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n-            IDENT | T![self] => 1,\n+            IDENT | T![self] | INT_NUMBER => 1,\n             _ => 0,\n         })?;\n     let range = original_token.text_range();"}, {"sha": "f190da326e455fd8a6563df8ad19fd73d1aff90d", "filename": "src/tools/rust-analyzer/crates/ide/src/highlight_related.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -333,7 +333,8 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n fn find_defs(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n     sema.descend_into_macros(token)\n         .into_iter()\n-        .filter_map(|token| IdentClass::classify_token(sema, &token).map(IdentClass::definitions))\n+        .filter_map(|token| IdentClass::classify_token(sema, &token))\n+        .map(IdentClass::definitions_no_ops)\n         .flatten()\n         .collect()\n }"}, {"sha": "3ada181f1ed2ba63a3e69d775af8a9bc3c35ab25", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -9,7 +9,7 @@ use either::Either;\n use hir::{HasSource, Semantics};\n use ide_db::{\n     base_db::FileRange,\n-    defs::{Definition, IdentClass},\n+    defs::{Definition, IdentClass, OperatorClass},\n     famous_defs::FamousDefs,\n     helpers::pick_best_token,\n     FxIndexSet, RootDatabase,\n@@ -101,7 +101,10 @@ pub(crate) fn hover(\n     let offset = range.start();\n \n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 3,\n+        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        // index and prefix ops\n+        T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+        kind if kind.is_keyword() => 2,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n@@ -136,6 +139,11 @@ pub(crate) fn hover(\n         .filter_map(|token| {\n             let node = token.parent()?;\n             let class = IdentClass::classify_token(sema, token)?;\n+            if let IdentClass::Operator(OperatorClass::Await(_)) = class {\n+                // It's better for us to fall back to the keyword hover here,\n+                // rendering poll is very confusing\n+                return None;\n+            }\n             Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n         })\n         .flatten()\n@@ -232,10 +240,12 @@ fn hover_type_fallback(\n     token: &SyntaxToken,\n     original_token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let node = token\n-        .parent_ancestors()\n-        .take_while(|it| !ast::Item::can_cast(it.kind()))\n-        .find(|n| ast::Expr::can_cast(n.kind()) || ast::Pat::can_cast(n.kind()))?;\n+    let node =\n+        token.parent_ancestors().take_while(|it| !ast::Item::can_cast(it.kind())).find(|n| {\n+            ast::Expr::can_cast(n.kind())\n+                || ast::Pat::can_cast(n.kind())\n+                || ast::Type::can_cast(n.kind())\n+        })?;\n \n     let expr_or_pat = match_ast! {\n         match node {"}, {"sha": "c6274264b8f1a55770cd1a478bc8559a5c7ff9c3", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -5051,3 +5051,37 @@ fn f() {\n             ```\"#]],\n     );\n }\n+\n+#[test]\n+fn hover_deref() {\n+    check(\n+        r#\"\n+//- minicore: deref\n+\n+struct Struct(usize);\n+\n+impl core::ops::Deref for Struct {\n+    type Target = usize;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn f() {\n+    $0*Struct(0);\n+}\n+\"#,\n+        expect![[r#\"\n+            ***\n+\n+            ```rust\n+            test::Struct\n+            ```\n+\n+            ```rust\n+            fn deref(&self) -> &Self::Target\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "ed19784d1fa49d11355835d94be8b83983f75792", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -100,7 +100,7 @@ pub enum InlayTooltip {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Toggle inlay hints*\n+// | VS Code | **rust-analyzer: Toggle inlay hints*\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png[]"}, {"sha": "edc48e84d72528f7ce14d6db2b8f5dc533c9b8ff", "filename": "src/tools/rust-analyzer/crates/ide/src/join_lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -28,7 +28,7 @@ pub struct JoinLinesConfig {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Join lines**\n+// | VS Code | **rust-analyzer: Join lines**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020661-b6922200-917a-11eb-87c4-b75acc028f11.gif[]"}, {"sha": "6e8a6d020cc7888db3ede65c8e2c5b91fc165b58", "filename": "src/tools/rust-analyzer/crates/ide/src/matching_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -12,7 +12,7 @@ use syntax::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Find matching brace**\n+// | VS Code | **rust-analyzer: Find matching brace**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065573-04298180-91b1-11eb-8dec-d4e2a202f304.gif[]"}, {"sha": "4f758967b46194538d41c753da10372f997ba7de", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn moniker(\n         .descend_into_macros(original_token.clone())\n         .into_iter()\n         .filter_map(|token| {\n-            IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+            IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops).map(|it| {\n                 it.into_iter().flat_map(|def| def_to_moniker(sema.db, def, current_crate))\n             })\n         })"}, {"sha": "ffc4bdd7da33f9453e232518170c2000e06f7e0a", "filename": "src/tools/rust-analyzer/crates/ide/src/move_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -19,8 +19,8 @@ pub enum Direction {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Move item up**\n-// | VS Code | **Rust Analyzer: Move item down**\n+// | VS Code | **rust-analyzer: Move item up**\n+// | VS Code | **rust-analyzer: Move item down**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif[]"}, {"sha": "8f3cc86873f5ed06d5325274079e69bfa22f4fca", "filename": "src/tools/rust-analyzer/crates/ide/src/parent_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -18,7 +18,7 @@ use crate::NavigationTarget;\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Locate parent module**\n+// | VS Code | **rust-analyzer: Locate parent module**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065580-04c21800-91b1-11eb-9a32-00086161c0bd.gif[]"}, {"sha": "b0853b10fde2f818d66f0c97d7c83e01ba2e906b", "filename": "src/tools/rust-analyzer/crates/ide/src/runnables.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -116,7 +116,7 @@ impl Runnable {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Run**\n+// | VS Code | **rust-analyzer: Run**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif[]\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n@@ -202,7 +202,7 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Peek related tests**\n+// | VS Code | **rust-analyzer: Peek related tests**\n // |===\n pub(crate) fn related_tests(\n     db: &RootDatabase,\n@@ -373,11 +373,13 @@ pub(crate) fn runnable_impl(\n     let adt_name = ty.as_adt()?.name(sema.db);\n     let mut ty_args = ty.type_arguments().peekable();\n     let params = if ty_args.peek().is_some() {\n-        format!(\"<{}>\", ty_args.format_with(\", \", |ty, cb| cb(&ty.display(sema.db))))\n+        format!(\"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty.display(sema.db))))\n     } else {\n         String::new()\n     };\n-    let test_id = TestId::Path(format!(\"{}{}\", adt_name, params));\n+    let mut test_id = format!(\"{}{}\", adt_name, params);\n+    test_id.retain(|c| c != ' ');\n+    let test_id = TestId::Path(test_id);\n \n     Some(Runnable { use_name_in_title: false, nav, kind: RunnableKind::DocTest { test_id }, cfg })\n }\n@@ -441,10 +443,11 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n                         format_to!(\n                             path,\n                             \"<{}>\",\n-                            ty_args.format_with(\", \", |ty, cb| cb(&ty.display(db)))\n+                            ty_args.format_with(\",\", |ty, cb| cb(&ty.display(db)))\n                         );\n                     }\n                     format_to!(path, \"::{}\", def_name);\n+                    path.retain(|c| c != ' ');\n                     return Some(path);\n                 }\n             }\n@@ -2067,13 +2070,23 @@ mod tests {\n $0\n struct Foo<T, U>;\n \n+/// ```\n+/// ```\n impl<T, U> Foo<T, U> {\n     /// ```rust\n     /// ````\n     fn t() {}\n }\n+\n+/// ```\n+/// ```\n+impl Foo<Foo<(), ()>, ()> {\n+    /// ```\n+    /// ```\n+    fn t() {}\n+}\n \"#,\n-            &[DocTest],\n+            &[DocTest, DocTest, DocTest, DocTest],\n             expect![[r#\"\n                 [\n                     Runnable {\n@@ -2082,12 +2095,64 @@ impl<T, U> Foo<T, U> {\n                             file_id: FileId(\n                                 0,\n                             ),\n-                            full_range: 47..85,\n+                            full_range: 20..103,\n+                            focus_range: 47..56,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<T,U>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 63..101,\n+                            name: \"t\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<T,U>::t\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 105..188,\n+                            focus_range: 126..146,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<Foo<(),()>,()>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 153..186,\n                             name: \"t\",\n                         },\n                         kind: DocTest {\n                             test_id: Path(\n-                                \"Foo<T, U>::t\",\n+                                \"Foo<Foo<(),()>,()>::t\",\n                             ),\n                         },\n                         cfg: None,"}, {"sha": "2d86627643d7c8d66c2c84adbc133d0a9c01d813", "filename": "src/tools/rust-analyzer/crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Shuffle Crate Graph**\n+// | VS Code | **rust-analyzer: Shuffle Crate Graph**\n // |===\n pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n     let crate_graph = db.crate_graph();"}, {"sha": "cc79ee55b7dac2be43bf41ae084af390ae198b0e", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -204,7 +204,7 @@ impl StaticIndex<'_> {\n \n fn get_definition(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n     for token in sema.descend_into_macros(token) {\n-        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions);\n+        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops);\n         if let Some(&[x]) = def.as_deref() {\n             return Some(x);\n         } else {"}, {"sha": "32e39f82a0e9f2b6ef870bca1371db19cf319d02", "filename": "src/tools/rust-analyzer/crates/ide/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -29,7 +29,7 @@ fn macro_syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Status**\n+// | VS Code | **rust-analyzer: Status**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065584-05f34500-91b1-11eb-98cc-5c196f76be7f.gif[]\n pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {"}, {"sha": "382735cb368df3cac89ca0bb72559896b944f28c", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -958,7 +958,7 @@ pub struct Struct;\n \n #[test]\n #[cfg_attr(\n-    all(unix, not(target_pointer_width = \"64\")),\n+    not(all(unix, target_pointer_width = \"64\")),\n     ignore = \"depends on `DefaultHasher` outputs\"\n )]\n fn test_rainbow_highlighting() {"}, {"sha": "4256fea0f81e45679ff6567fda769c93c92578eb", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -12,7 +12,7 @@ use syntax::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Show Syntax Tree**\n+// | VS Code | **rust-analyzer: Show Syntax Tree**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065586-068bdb80-91b1-11eb-9507-fee67f9f45a0.gif[]\n pub(crate) fn syntax_tree("}, {"sha": "bf7b7efe28228885712908e998c30b31135573d5", "filename": "src/tools/rust-analyzer/crates/ide/src/view_crate_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -16,7 +16,7 @@ use ide_db::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: View Crate Graph**\n+// | VS Code | **rust-analyzer: View Crate Graph**\n // |===\n pub(crate) fn view_crate_graph(db: &RootDatabase, full: bool) -> Result<String, String> {\n     let crate_graph = db.crate_graph();"}, {"sha": "bf0835ed7e0d3a1f2a5f675e2f67754483e6d5ab", "filename": "src/tools/rust-analyzer/crates/ide/src/view_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -8,7 +8,7 @@ use syntax::{algo::find_node_at_offset, ast, AstNode};\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: View Hir**\n+// | VS Code | **rust-analyzer: View Hir**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065588-068bdb80-91b1-11eb-9a78-0b4ef1e972fb.gif[]\n pub(crate) fn view_hir(db: &RootDatabase, position: FilePosition) -> String {"}, {"sha": "9c1f93356ee2d0637733ae7f035f230313b0fa76", "filename": "src/tools/rust-analyzer/crates/ide/src/view_item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -9,7 +9,7 @@ use ide_db::RootDatabase;\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Debug ItemTree**\n+// | VS Code | **rust-analyzer: Debug ItemTree**\n // |===\n pub(crate) fn view_item_tree(db: &RootDatabase, file_id: FileId) -> String {\n     db.file_item_tree(file_id.into()).pretty_print()"}, {"sha": "6ae23ac841adaa6a7f97d8841c57aec96f2d2439", "filename": "src/tools/rust-analyzer/crates/paths/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -106,6 +106,14 @@ impl AsRef<Path> for AbsPath {\n     }\n }\n \n+impl ToOwned for AbsPath {\n+    type Owned = AbsPathBuf;\n+\n+    fn to_owned(&self) -> Self::Owned {\n+        AbsPathBuf(self.0.to_owned())\n+    }\n+}\n+\n impl<'a> TryFrom<&'a Path> for &'a AbsPath {\n     type Error = &'a Path;\n     fn try_from(path: &'a Path) -> Result<&'a AbsPath, &'a Path> {"}, {"sha": "a3ea05f4aff8e9ca60cc2ca53e4858e0f5e1fe9c", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -60,7 +60,7 @@ impl MacroDylib {\n \n         let info = version::read_dylib_info(&path)?;\n         if info.version.0 < 1 || info.version.1 < 47 {\n-            let msg = format!(\"proc-macro {} built by {:#?} is not supported by Rust Analyzer, please update your rust version.\", path.display(), info);\n+            let msg = format!(\"proc-macro {} built by {:#?} is not supported by rust-analyzer, please update your Rust version.\", path.display(), info);\n             return Err(io::Error::new(io::ErrorKind::InvalidData, msg));\n         }\n "}, {"sha": "705d09ea9458bdad7cb17e87e0a366a17aa2fdae", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -5,7 +5,7 @@\n //! compiler into submodules of this module (e.g proc_macro_srv::abis::abi_1_47).\n //!\n //! All of these ABIs are subsumed in the `Abi` enum, which exposes a simple\n-//! interface the rest of rust analyzer can use to talk to the macro\n+//! interface the rest of rust-analyzer can use to talk to the macro\n //! provider.\n //!\n //! # Adding a new ABI"}, {"sha": "eed955b42daae9816c97951a8250571257cd68cd", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -19,7 +19,7 @@ use crate::{utf8_stdout, ManifestPath};\n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n ///\n-/// Note that internally, rust analyzer uses a different structure:\n+/// Note that internally, rust-analyzer uses a different structure:\n /// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n /// while this knows about `Packages` & `Targets`: purely cargo-related\n /// concepts."}, {"sha": "09150c77d7dd1d9de53adaff2a67382132e32711", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<FxHashMap<FileId, Vec<Fix>>>;\n+pub(crate) type CheckFixes = Arc<FxHashMap<usize, FxHashMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -22,7 +22,7 @@ pub(crate) struct DiagnosticCollection {\n     // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>\n     pub(crate) native: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    pub(crate) check: FxHashMap<usize, FxHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n     changes: FxHashSet<FileId>,\n }\n@@ -35,9 +35,19 @@ pub(crate) struct Fix {\n }\n \n impl DiagnosticCollection {\n-    pub(crate) fn clear_check(&mut self) {\n+    pub(crate) fn clear_check(&mut self, flycheck_id: usize) {\n+        if let Some(it) = Arc::make_mut(&mut self.check_fixes).get_mut(&flycheck_id) {\n+            it.clear();\n+        }\n+        if let Some(it) = self.check.get_mut(&flycheck_id) {\n+            self.changes.extend(it.drain().map(|(key, _value)| key));\n+        }\n+    }\n+\n+    pub(crate) fn clear_check_all(&mut self) {\n         Arc::make_mut(&mut self.check_fixes).clear();\n-        self.changes.extend(self.check.drain().map(|(key, _value)| key))\n+        self.changes\n+            .extend(self.check.values_mut().flat_map(|it| it.drain().map(|(key, _value)| key)))\n     }\n \n     pub(crate) fn clear_native_for(&mut self, file_id: FileId) {\n@@ -47,19 +57,20 @@ impl DiagnosticCollection {\n \n     pub(crate) fn add_check_diagnostic(\n         &mut self,\n+        flycheck_id: usize,\n         file_id: FileId,\n         diagnostic: lsp_types::Diagnostic,\n         fix: Option<Fix>,\n     ) {\n-        let diagnostics = self.check.entry(file_id).or_default();\n+        let diagnostics = self.check.entry(flycheck_id).or_default().entry(file_id).or_default();\n         for existing_diagnostic in diagnostics.iter() {\n             if are_diagnostics_equal(existing_diagnostic, &diagnostic) {\n                 return;\n             }\n         }\n \n         let check_fixes = Arc::make_mut(&mut self.check_fixes);\n-        check_fixes.entry(file_id).or_default().extend(fix);\n+        check_fixes.entry(flycheck_id).or_default().entry(file_id).or_default().extend(fix);\n         diagnostics.push(diagnostic);\n         self.changes.insert(file_id);\n     }\n@@ -89,7 +100,8 @@ impl DiagnosticCollection {\n         file_id: FileId,\n     ) -> impl Iterator<Item = &lsp_types::Diagnostic> {\n         let native = self.native.get(&file_id).into_iter().flatten();\n-        let check = self.check.get(&file_id).into_iter().flatten();\n+        let check =\n+            self.check.values().filter_map(move |it| it.get(&file_id)).into_iter().flatten();\n         native.chain(check)\n     }\n "}, {"sha": "b5f6aef2e1a84e60abb268aeebf86bd6be85301c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{CrateId, FileLoader, SourceDatabase};\n+use ide_db::base_db::{CrateId, FileLoader, SourceDatabase, SourceDatabaseExt};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n@@ -176,7 +176,7 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        let mut fs_changes = Vec::new();\n+        let mut fs_refresh_changes = Vec::new();\n         // A file was added or deleted\n         let mut has_structure_changes = false;\n \n@@ -192,15 +192,14 @@ impl GlobalState {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n                     if reload::should_refresh_for_change(&path, file.change_kind) {\n-                        self.fetch_workspaces_queue\n-                            .request_op(format!(\"vfs file change: {}\", path.display()));\n+                        fs_refresh_changes.push((path, file.file_id));\n                     }\n-                    fs_changes.push((path, file.change_kind));\n                     if file.is_created_or_deleted() {\n                         has_structure_changes = true;\n                     }\n                 }\n \n+                // Clear native diagnostics when their file gets deleted\n                 if !file.exists() {\n                     self.diagnostics.clear_native_for(file.file_id);\n                 }\n@@ -226,14 +225,25 @@ impl GlobalState {\n \n         self.analysis_host.apply_change(change);\n \n-        let raw_database = &self.analysis_host.raw_database();\n-        self.proc_macro_changed =\n-            changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n-                let crates = raw_database.relevant_crates(file.file_id);\n-                let crate_graph = raw_database.crate_graph();\n+        {\n+            let raw_database = self.analysis_host.raw_database();\n+            let workspace_structure_change =\n+                fs_refresh_changes.into_iter().find(|&(_, file_id)| {\n+                    !raw_database.source_root(raw_database.file_source_root(file_id)).is_library\n+                });\n+            if let Some((path, _)) = workspace_structure_change {\n+                self.fetch_workspaces_queue\n+                    .request_op(format!(\"workspace vfs file change: {}\", path.display()));\n+            }\n+            self.proc_macro_changed =\n+                changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n+                    let crates = raw_database.relevant_crates(file.file_id);\n+                    let crate_graph = raw_database.crate_graph();\n+\n+                    crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n+                });\n+        }\n \n-                crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n-            });\n         true\n     }\n "}, {"sha": "47daa732d5d3254ab779a9af4ae2091697c0bd13", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -1094,7 +1094,9 @@ pub(crate) fn handle_code_action(\n     }\n \n     // Fixes from `cargo check`.\n-    for fix in snap.check_fixes.get(&frange.file_id).into_iter().flatten() {\n+    for fix in\n+        snap.check_fixes.values().filter_map(|it| it.get(&frange.file_id)).into_iter().flatten()\n+    {\n         // FIXME: this mapping is awkward and shouldn't exist. Refactor\n         // `snap.check_fixes` to not convert to LSP prematurely.\n         let intersect_fix_range = fix"}, {"sha": "e49a98685a7f11302fbaff40afe55d36c3719355", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -6,8 +6,8 @@\n //! code here exercise this specific completion, and thus have a fast\n //! edit/compile/test cycle.\n //!\n-//! Note that \"Rust Analyzer: Run\" action does not allow running a single test\n-//! in release mode in VS Code. There's however \"Rust Analyzer: Copy Run Command Line\"\n+//! Note that \"rust-analyzer: Run\" action does not allow running a single test\n+//! in release mode in VS Code. There's however \"rust-analyzer: Copy Run Command Line\"\n //! which you can use to paste the command in terminal and add `--release` manually.\n \n use std::sync::Arc;"}, {"sha": "b504c248782667752c8adfb5f10d8cbe1ecef11a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -2,13 +2,15 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     fmt,\n+    ops::Deref,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n-use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n+use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n+use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n use vfs::{ChangeKind, FileId};\n@@ -371,7 +373,7 @@ impl GlobalState {\n                 let _p = profile::span(\"GlobalState::handle_event/flycheck\");\n                 loop {\n                     match task {\n-                        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n+                        flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n                             let snap = self.snapshot();\n                             let diagnostics =\n                                 crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n@@ -383,6 +385,7 @@ impl GlobalState {\n                             for diag in diagnostics {\n                                 match url_to_file_id(&self.vfs.read().0, &diag.url) {\n                                     Ok(file_id) => self.diagnostics.add_check_diagnostic(\n+                                        id,\n                                         file_id,\n                                         diag.diagnostic,\n                                         diag.fix,\n@@ -400,7 +403,7 @@ impl GlobalState {\n                         flycheck::Message::Progress { id, progress } => {\n                             let (state, message) = match progress {\n                                 flycheck::Progress::DidStart => {\n-                                    self.diagnostics.clear_check();\n+                                    self.diagnostics.clear_check(id);\n                                     (Progress::Begin, None)\n                                 }\n                                 flycheck::Progress::DidCheckCrate(target) => {\n@@ -444,7 +447,10 @@ impl GlobalState {\n         let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n         if self.is_quiescent() {\n-            if !was_quiescent {\n+            if !was_quiescent\n+                && !self.fetch_workspaces_queue.op_requested()\n+                && !self.fetch_build_data_queue.op_requested()\n+            {\n                 for flycheck in &self.flycheck {\n                     flycheck.update();\n                 }\n@@ -734,13 +740,76 @@ impl GlobalState {\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                for flycheck in &this.flycheck {\n-                    flycheck.update();\n+                let mut updated = false;\n+                if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    let (vfs, _) = &*this.vfs.read();\n+                    if let Some(file_id) = vfs.file_id(&vfs_path) {\n+                        let analysis = this.analysis_host.analysis();\n+                        // Crates containing or depending on the saved file\n+                        let crate_ids: Vec<_> = analysis\n+                            .crate_for(file_id)?\n+                            .into_iter()\n+                            .flat_map(|id| {\n+                                this.analysis_host\n+                                    .raw_database()\n+                                    .crate_graph()\n+                                    .transitive_rev_deps(id)\n+                            })\n+                            .sorted()\n+                            .unique()\n+                            .collect();\n+\n+                        let crate_root_paths: Vec<_> = crate_ids\n+                            .iter()\n+                            .filter_map(|&crate_id| {\n+                                analysis\n+                                    .crate_root(crate_id)\n+                                    .map(|file_id| {\n+                                        vfs.file_path(file_id).as_path().map(ToOwned::to_owned)\n+                                    })\n+                                    .transpose()\n+                            })\n+                            .collect::<ide::Cancellable<_>>()?;\n+                        let crate_root_paths: Vec<_> =\n+                            crate_root_paths.iter().map(Deref::deref).collect();\n+\n+                        // Find all workspaces that have at least one target containing the saved file\n+                        let workspace_ids =\n+                            this.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                                    cargo.packages().any(|pkg| {\n+                                        cargo[pkg].targets.iter().any(|&it| {\n+                                            crate_root_paths.contains(&cargo[it].root.as_path())\n+                                        })\n+                                    })\n+                                }\n+                                project_model::ProjectWorkspace::Json { project, .. } => project\n+                                    .crates()\n+                                    .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n+                                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+                            });\n+\n+                        // Find and trigger corresponding flychecks\n+                        for flycheck in &this.flycheck {\n+                            for (id, _) in workspace_ids.clone() {\n+                                if id == flycheck.id() {\n+                                    updated = true;\n+                                    flycheck.update();\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if let Some(abs_path) = vfs_path.as_path() {\n+                        if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n+                            this.fetch_workspaces_queue\n+                                .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                        }\n+                    }\n                 }\n-                if let Ok(abs_path) = from_proto::abs_path(&params.text_document.uri) {\n-                    if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n-                        this.fetch_workspaces_queue\n-                            .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                if !updated {\n+                    for flycheck in &this.flycheck {\n+                        flycheck.update();\n                     }\n                 }\n                 Ok(())"}, {"sha": "49ccad71a10e851e0cdcac2aeadab773f2171f7b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -196,10 +196,7 @@ impl GlobalState {\n         }\n \n         if let Err(error) = self.fetch_build_data_error() {\n-            self.show_and_log_error(\n-                \"rust-analyzer failed to run build scripts\".to_string(),\n-                Some(error),\n-            );\n+            self.show_and_log_error(\"failed to run build scripts\".to_string(), Some(error));\n         }\n \n         let workspaces = self\n@@ -308,6 +305,7 @@ impl GlobalState {\n \n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n+                tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n@@ -316,35 +314,31 @@ impl GlobalState {\n                         let mut path = path.clone();\n \n                         if let ProjectWorkspace::Cargo { sysroot, .. } = ws {\n-                            tracing::info!(\"Found a cargo workspace...\");\n+                            tracing::debug!(\"Found a cargo workspace...\");\n                             if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::info!(\"Found a cargo workspace with a sysroot...\");\n+                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n                                 let server_path =\n                                     sysroot.root().join(\"libexec\").join(&standalone_server_name);\n                                 if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server exists at {}\",\n                                         server_path.display()\n                                     );\n                                     path = server_path;\n                                     args = vec![];\n                                 } else {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server does not exist at {}\",\n                                         server_path.display()\n                                     );\n                                 }\n                             }\n                         }\n \n-                        tracing::info!(\n-                            \"Using proc-macro server at {} with args {:?}\",\n-                            path.display(),\n-                            args\n-                        );\n+                        tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n                         ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n                             let error = format!(\n-                                \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n+                                \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),\n                                 err\n                             );\n@@ -458,7 +452,7 @@ impl GlobalState {\n             Some(it) => it,\n             None => {\n                 self.flycheck = Vec::new();\n-                self.diagnostics.clear_check();\n+                self.diagnostics.clear_check_all();\n                 return;\n             }\n         };\n@@ -621,7 +615,10 @@ pub(crate) fn load_proc_macro(\n         };\n         let expander: Arc<dyn ProcMacroExpander> =\n             if dummy_replace.iter().any(|replace| &**replace == name) {\n-                Arc::new(DummyExpander)\n+                match kind {\n+                    ProcMacroKind::Attr => Arc::new(IdentityExpander),\n+                    _ => Arc::new(EmptyExpander),\n+                }\n             } else {\n                 Arc::new(Expander(expander))\n             };\n@@ -647,11 +644,11 @@ pub(crate) fn load_proc_macro(\n         }\n     }\n \n-    /// Dummy identity expander, used for proc-macros that are deliberately ignored by the user.\n+    /// Dummy identity expander, used for attribute proc-macros that are deliberately ignored by the user.\n     #[derive(Debug)]\n-    struct DummyExpander;\n+    struct IdentityExpander;\n \n-    impl ProcMacroExpander for DummyExpander {\n+    impl ProcMacroExpander for IdentityExpander {\n         fn expand(\n             &self,\n             subtree: &tt::Subtree,\n@@ -661,27 +658,46 @@ pub(crate) fn load_proc_macro(\n             Ok(subtree.clone())\n         }\n     }\n+\n+    /// Empty expander, used for proc-macros that are deliberately ignored by the user.\n+    #[derive(Debug)]\n+    struct EmptyExpander;\n+\n+    impl ProcMacroExpander for EmptyExpander {\n+        fn expand(\n+            &self,\n+            _: &tt::Subtree,\n+            _: Option<&tt::Subtree>,\n+            _: &Env,\n+        ) -> Result<tt::Subtree, ProcMacroExpansionError> {\n+            Ok(tt::Subtree::default())\n+        }\n+    }\n }\n \n pub(crate) fn should_refresh_for_change(path: &AbsPath, change_kind: ChangeKind) -> bool {\n     const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n     const IMPLICIT_TARGET_DIRS: &[&str] = &[\"src/bin\", \"examples\", \"tests\", \"benches\"];\n-    let file_name = path.file_name().unwrap_or_default();\n \n-    if file_name == \"Cargo.toml\" || file_name == \"Cargo.lock\" {\n+    let file_name = match path.file_name().unwrap_or_default().to_str() {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+\n+    if let \"Cargo.toml\" | \"Cargo.lock\" = file_name {\n         return true;\n     }\n     if change_kind == ChangeKind::Modify {\n         return false;\n     }\n+\n+    // .cargo/config{.toml}\n     if path.extension().unwrap_or_default() != \"rs\" {\n-        if (file_name == \"config.toml\" || file_name == \"config\")\n-            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")) == Some(true)\n-        {\n-            return true;\n-        }\n-        return false;\n+        let is_cargo_config = matches!(file_name, \"config.toml\" | \"config\")\n+            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")).unwrap_or(false);\n+        return is_cargo_config;\n     }\n+\n     if IMPLICIT_TARGET_FILES.iter().any(|it| path.as_ref().ends_with(it)) {\n         return true;\n     }"}, {"sha": "58099a58de053acb0506bfc61a77b264a987e6dd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -13,19 +13,18 @@ use xshell::cmd;\n fn check_code_formatting() {\n     let sh = &Shell::new().unwrap();\n     sh.change_dir(sourcegen::project_root());\n-    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n \n-    let out = cmd!(sh, \"rustfmt --version\").read().unwrap();\n+    let out = cmd!(sh, \"rustup run stable rustfmt --version\").read().unwrap();\n     if !out.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n                  Please run `rustup component add rustfmt --toolchain stable` to install it.\",\n         )\n     }\n \n-    let res = cmd!(sh, \"cargo fmt -- --check\").run();\n+    let res = cmd!(sh, \"rustup run stable cargo fmt -- --check\").run();\n     if res.is_err() {\n-        let _ = cmd!(sh, \"cargo fmt\").run();\n+        let _ = cmd!(sh, \"rustup run stable cargo fmt\").run();\n     }\n     res.unwrap()\n }"}, {"sha": "4e0ee63f32f26a2e7ce56b832325e223bb0233b7", "filename": "src/tools/rust-analyzer/crates/sourcegen/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -136,7 +136,7 @@ impl fmt::Display for Location {\n }\n \n fn ensure_rustfmt(sh: &Shell) {\n-    let version = cmd!(sh, \"rustfmt --version\").read().unwrap_or_default();\n+    let version = cmd!(sh, \"rustup run stable rustfmt --version\").read().unwrap_or_default();\n     if !version.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n@@ -147,13 +147,15 @@ fn ensure_rustfmt(sh: &Shell) {\n \n pub fn reformat(text: String) -> String {\n     let sh = Shell::new().unwrap();\n-    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt(&sh);\n     let rustfmt_toml = project_root().join(\"rustfmt.toml\");\n-    let mut stdout = cmd!(sh, \"rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\")\n-        .stdin(text)\n-        .read()\n-        .unwrap();\n+    let mut stdout = cmd!(\n+        sh,\n+        \"rustup run stable rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\"\n+    )\n+    .stdin(text)\n+    .read()\n+    .unwrap();\n     if !stdout.ends_with('\\n') {\n         stdout.push('\\n');\n     }"}, {"sha": "8efd58e2c39aa48c098844ad853a30993d314f42", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 144, "deletions": 27, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n-    SyntaxNode,\n+    SyntaxNode, SyntaxToken,\n };\n \n use super::HasName;\n@@ -506,19 +506,7 @@ impl ast::RecordExprFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let comma = get_or_insert_comma_after(last_field.syntax());\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -579,19 +567,8 @@ impl ast::RecordPatFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let syntax = last_field.syntax();\n+                let comma = get_or_insert_comma_after(syntax);\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -606,12 +583,53 @@ impl ast::RecordPatFieldList {\n         }\n     }\n }\n+\n+fn get_or_insert_comma_after(syntax: &SyntaxNode) -> SyntaxToken {\n+    let comma = match syntax\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == T![,])\n+    {\n+        Some(it) => it,\n+        None => {\n+            let comma = ast::make::token(T![,]);\n+            ted::insert(Position::after(syntax), &comma);\n+            comma\n+        }\n+    };\n+    comma\n+}\n+\n impl ast::StmtList {\n     pub fn push_front(&self, statement: ast::Stmt) {\n         ted::insert(Position::after(self.l_curly_token().unwrap()), statement.syntax());\n     }\n }\n \n+impl ast::VariantList {\n+    pub fn add_variant(&self, variant: ast::Variant) {\n+        let (indent, position) = match self.variants().last() {\n+            Some(last_item) => (\n+                IndentLevel::from_node(last_item.syntax()),\n+                Position::after(get_or_insert_comma_after(last_item.syntax())),\n+            ),\n+            None => match self.l_curly_token() {\n+                Some(l_curly) => {\n+                    normalize_ws_between_braces(self.syntax());\n+                    (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly))\n+                }\n+                None => (IndentLevel::single(), Position::last_child_of(self.syntax())),\n+            },\n+        };\n+        let elements: Vec<SyntaxElement<_>> = vec![\n+            make::tokens::whitespace(&format!(\"{}{}\", \"\\n\", indent)).into(),\n+            variant.syntax().clone().into(),\n+            ast::make::token(T![,]).into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+}\n+\n fn normalize_ws_between_braces(node: &SyntaxNode) -> Option<()> {\n     let l = node\n         .children_with_tokens()\n@@ -661,6 +679,9 @@ impl<N: AstNode + Clone> Indent for N {}\n mod tests {\n     use std::fmt;\n \n+    use stdx::trim_indent;\n+    use test_utils::assert_eq_text;\n+\n     use crate::SourceFile;\n \n     use super::*;\n@@ -714,4 +735,100 @@ mod tests {\n         }\",\n         );\n     }\n+\n+    #[test]\n+    fn add_variant_to_empty_enum() {\n+        let variant = make::variant(make::name(\"Bar\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_to_non_empty_enum() {\n+        let variant = make::variant(make::name(\"Baz\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_tuple_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::TupleFieldList(make::tuple_field_list(std::iter::once(\n+                make::tuple_field(None, make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz(bool),\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_record_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::RecordFieldList(make::record_field_list(std::iter::once(\n+                make::record_field(None, make::name(\"x\"), make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz { x: bool },\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    fn check_add_variant(before: &str, expected: &str, variant: ast::Variant) {\n+        let enum_ = ast_mut_from_text::<ast::Enum>(before);\n+        enum_.variant_list().map(|it| it.add_variant(variant));\n+        let after = enum_.to_string();\n+        assert_eq_text!(&trim_indent(expected.trim()), &trim_indent(&after.trim()));\n+    }\n }"}, {"sha": "037de876d45c94f16955502621129bc2872b2b85", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -745,7 +745,10 @@ pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::T\n pub fn variant(name: ast::Name, field_list: Option<ast::FieldList>) -> ast::Variant {\n     let field_list = match field_list {\n         None => String::new(),\n-        Some(it) => format!(\"{}\", it),\n+        Some(it) => match it {\n+            ast::FieldList::RecordFieldList(record) => format!(\" {}\", record),\n+            ast::FieldList::TupleFieldList(tuple) => format!(\"{}\", tuple),\n+        },\n     };\n     ast_from_text(&format!(\"enum f {{ {}{} }}\", name, field_list))\n }"}, {"sha": "4f5e273a520a14212256f1ac7a898b354e942216", "filename": "src/tools/rust-analyzer/crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -1,4 +1,4 @@\n-//! Syntax Tree library used throughout the rust analyzer.\n+//! Syntax Tree library used throughout the rust-analyzer.\n //!\n //! Properties:\n //!   - easy and fast incremental re-parsing"}, {"sha": "d6d9c66159fe1fa624c742d69a9ecfbbd3918de2", "filename": "src/tools/rust-analyzer/crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -40,12 +40,15 @@ impl loader::Handle for NotifyHandle {\n             .expect(\"failed to spawn thread\");\n         NotifyHandle { sender, _thread: thread }\n     }\n+\n     fn set_config(&mut self, config: loader::Config) {\n         self.sender.send(Message::Config(config)).unwrap();\n     }\n+\n     fn invalidate(&mut self, path: AbsPathBuf) {\n         self.sender.send(Message::Invalidate(path)).unwrap();\n     }\n+\n     fn load_sync(&mut self, path: &AbsPath) -> Option<Vec<u8>> {\n         read(path)\n     }\n@@ -70,16 +73,18 @@ impl NotifyActor {\n     fn new(sender: loader::Sender) -> NotifyActor {\n         NotifyActor { sender, watched_entries: Vec::new(), watcher: None }\n     }\n+\n     fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n         let watcher_receiver = self.watcher.as_ref().map(|(_, receiver)| receiver);\n         select! {\n             recv(receiver) -> it => it.ok().map(Event::Message),\n             recv(watcher_receiver.unwrap_or(&never())) -> it => Some(Event::NotifyEvent(it.unwrap())),\n         }\n     }\n+\n     fn run(mut self, inbox: Receiver<Message>) {\n         while let Some(event) = self.next_event(&inbox) {\n-            tracing::debug!(\"vfs-notify event: {:?}\", event);\n+            tracing::debug!(?event, \"vfs-notify event\");\n             match event {\n                 Event::Message(msg) => match msg {\n                     Message::Config(config) => {"}, {"sha": "c7f152acc26690ecce60fdb3a9a15313e2d22ed7", "filename": "src/tools/rust-analyzer/docs/dev/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -82,7 +82,7 @@ There's **\"Run Extension (Debug Build)\"** launch configuration for this in VS Co\n In general, I use one of the following workflows for fixing bugs and implementing features:\n \n If the problem concerns only internal parts of rust-analyzer (i.e. I don't need to touch the `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n-So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and then just do printf-driven development/debugging.\n+So, I use **rust-analyzer: Run** action in VS Code to run this single test, and then just do printf-driven development/debugging.\n As a sanity check after I'm done, I use `cargo xtask install --server` and **Reload Window** action in VS Code to verify that the thing works as I expect.\n \n If the problem concerns only the VS Code extension, I use **Run Installed Extension** launch configuration from `launch.json`.\n@@ -152,11 +152,11 @@ To log all communication between the server and the client, there are two choice\n \n There are also several VS Code commands which might be of interest:\n \n-* `Rust Analyzer: Status` shows some memory-usage statistics.\n+* `rust-analyzer: Status` shows some memory-usage statistics.\n \n-* `Rust Analyzer: Syntax Tree` shows syntax tree of the current file/selection.\n+* `rust-analyzer: Syntax Tree` shows syntax tree of the current file/selection.\n \n-* `Rust Analyzer: View Hir` shows the HIR expressions within the function containing the cursor.\n+* `rust-analyzer: View Hir` shows the HIR expressions within the function containing the cursor.\n \n   You can hover over syntax nodes in the opened text file to see the appropriate\n   rust code that it refers to and the rust editor will also highlight the proper"}, {"sha": "51e26c58a9175d4c8c17efa58df77249a73860cd", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -371,7 +371,7 @@ That is, rust-analyzer requires unwinding.\n \n ### Testing\n \n-Rust Analyzer has three interesting [system boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n+rust-analyzer has three interesting [system boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n \n The outermost boundary is the `rust-analyzer` crate, which defines an LSP interface in terms of stdio.\n We do integration testing of this component, by feeding it with a stream of LSP requests and checking responses."}, {"sha": "808eb5d10bf4acb80fff8f02f7ba8c2b797b2175", "filename": "src/tools/rust-analyzer/docs/dev/guide.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -63,7 +63,7 @@ Next, let's talk about what the inputs to the `Analysis` are, precisely.\n \n ## Inputs\n \n-Rust Analyzer never does any I/O itself, all inputs get passed explicitly via\n+rust-analyzer never does any I/O itself, all inputs get passed explicitly via\n the `AnalysisHost::apply_change` method, which accepts a single argument, a\n `Change`. [`Change`] is a builder for a single change\n \"transaction\", so it suffices to study its methods to understand all of the"}, {"sha": "c482fcbed0e01ccea9ab998dad16a7649f6fb61a", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -479,7 +479,7 @@ You can follow instructions for installing <<rust-analyzer-language-server-binar\n == Troubleshooting\n \n Start with looking at the rust-analyzer version.\n-Try **Rust Analyzer: Show RA Version** in VS Code (using **Command Palette** feature typically activated by Ctrl+Shift+P) or `rust-analyzer --version` in the command line.\n+Try **rust-analyzer: Show RA Version** in VS Code (using **Command Palette** feature typically activated by Ctrl+Shift+P) or `rust-analyzer --version` in the command line.\n If the date is more than a week ago, it's better to update rust-analyzer version.\n \n The next thing to check would be panic messages in rust-analyzer's log.\n@@ -492,7 +492,7 @@ To fully capture LSP messages between the editor and the server, set `\"rust-anal\n The root cause for many \"`nothing works`\" problems is that rust-analyzer fails to understand the project structure.\n To debug that, first note the `rust-analyzer` section in the status bar.\n If it has an error icon and red, that's the problem (hover will have somewhat helpful error message).\n-**Rust Analyzer: Status** prints dependency information for the current file.\n+**rust-analyzer: Status** prints dependency information for the current file.\n Finally, `RA_LOG=project_model=debug` enables verbose logs during project loading.\n \n If rust-analyzer outright crashes, try running `rust-analyzer analysis-stats /path/to/project/directory/` on the command line."}, {"sha": "fbdc69c80137646c98187022e39030e4a791762d", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -99,142 +99,142 @@\n             {\n                 \"command\": \"rust-analyzer.syntaxTree\",\n                 \"title\": \"Show Syntax Tree\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewHir\",\n                 \"title\": \"View Hir\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewItemTree\",\n                 \"title\": \"Debug ItemTree\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewCrateGraph\",\n                 \"title\": \"View Crate Graph\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewFullCrateGraph\",\n                 \"title\": \"View Crate Graph (Full)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.expandMacro\",\n                 \"title\": \"Expand macro recursively\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.matchingBrace\",\n                 \"title\": \"Find matching brace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.parentModule\",\n                 \"title\": \"Locate parent module\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.joinLines\",\n                 \"title\": \"Join lines\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.run\",\n                 \"title\": \"Run\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.copyRunCommandLine\",\n                 \"title\": \"Copy Run Command Line\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.debug\",\n                 \"title\": \"Debug\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.newDebugConfig\",\n                 \"title\": \"Generate launch configuration\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.analyzerStatus\",\n                 \"title\": \"Status\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.memoryUsage\",\n                 \"title\": \"Memory Usage (Clears Database)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.shuffleCrateGraph\",\n                 \"title\": \"Shuffle Crate Graph\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.reloadWorkspace\",\n                 \"title\": \"Reload workspace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.reload\",\n                 \"title\": \"Restart server\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.onEnter\",\n                 \"title\": \"Enhanced enter key\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.ssr\",\n                 \"title\": \"Structural Search Replace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.serverVersion\",\n                 \"title\": \"Show RA Version\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.toggleInlayHints\",\n                 \"title\": \"Toggle inlay hints\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.openDocs\",\n                 \"title\": \"Open docs under cursor\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.openCargoToml\",\n                 \"title\": \"Open Cargo.toml\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.peekTests\",\n                 \"title\": \"Peek related tests\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.moveItemUp\",\n                 \"title\": \"Move item up\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.moveItemDown\",\n                 \"title\": \"Move item down\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             }\n         ],\n         \"keybindings\": [\n@@ -256,7 +256,7 @@\n         ],\n         \"configuration\": {\n             \"type\": \"object\",\n-            \"title\": \"Rust Analyzer\",\n+            \"title\": \"rust-analyzer\",\n             \"properties\": {\n                 \"rust-analyzer.cargoRunner\": {\n                     \"type\": [\n@@ -380,6 +380,11 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.typing.continueCommentsOnNewline\": {\n+                    \"markdownDescription\": \"Whether to prefix newlines after comments with the corresponding comment prefix.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.expressionFillDefault\": {\n                     \"markdownDescription\": \"Placeholder expression to use for missing expressions in assists.\","}, {"sha": "1c58040d58c2b4cc4d493937d8200135d4652fa7", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -16,9 +16,13 @@ export class Config {\n     readonly extensionId = \"rust-lang.rust-analyzer\";\n \n     readonly rootSection = \"rust-analyzer\";\n-    private readonly requiresWorkspaceReloadOpts = [\"serverPath\", \"server\"].map(\n-        (opt) => `${this.rootSection}.${opt}`\n-    );\n+    private readonly requiresWorkspaceReloadOpts = [\n+        \"serverPath\",\n+        \"server\",\n+        // FIXME: This shouldn't be here, changing this setting should reload\n+        // `continueCommentsOnNewline` behavior without restart\n+        \"typing\",\n+    ].map((opt) => `${this.rootSection}.${opt}`);\n     private readonly requiresReloadOpts = [\n         \"cargo\",\n         \"procMacro\",\n@@ -140,6 +144,10 @@ export class Config {\n         return this.get<boolean>(\"restartServerOnConfigChange\");\n     }\n \n+    get typingContinueCommentsOnNewline() {\n+        return this.get<boolean>(\"typing.continueCommentsOnNewline\");\n+    }\n+\n     get debug() {\n         let sourceFileMap = this.get<Record<string, string> | \"auto\">(\"debug.sourceFileMap\");\n         if (sourceFileMap !== \"auto\") {"}, {"sha": "d78b711a47a8f76628569026bcf8a961367c8ab1", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -84,7 +84,9 @@ async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyz\n \n     warnAboutExtensionConflicts();\n \n-    ctx.pushCleanup(configureLanguage());\n+    if (config.typingContinueCommentsOnNewline) {\n+        ctx.pushCleanup(configureLanguage());\n+    }\n \n     vscode.workspace.onDidChangeConfiguration(\n         (_) =>"}, {"sha": "a3fe59e946ee9be8e60789c8b016d8231c9c48b4", "filename": "src/tools/rust-analyzer/lib/la-arena/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -12,7 +12,7 @@ use std::{\n };\n \n mod map;\n-pub use map::ArenaMap;\n+pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n \n /// The raw index of a value in an arena.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -208,6 +208,16 @@ impl<T> Arena<T> {\n         Arena { data: Vec::new() }\n     }\n \n+    /// Create a new empty arena with specific capacity.\n+    ///\n+    /// ```\n+    /// let arena: la_arena::Arena<i32> = la_arena::Arena::with_capacity(42);\n+    /// assert!(arena.is_empty());\n+    /// ```\n+    pub fn with_capacity(capacity: usize) -> Arena<T> {\n+        Arena { data: Vec::with_capacity(capacity) }\n+    }\n+\n     /// Empties the arena, removing all contained values.\n     ///\n     /// ```"}, {"sha": "5f347e274500eefe7b5fcf0cda0b5d281cf8c040", "filename": "src/tools/rust-analyzer/lib/la-arena/src/map.rs", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -11,12 +11,52 @@ pub struct ArenaMap<IDX, V> {\n }\n \n impl<T, V> ArenaMap<Idx<T>, V> {\n+    /// Creates a new empty map.\n+    pub const fn new() -> Self {\n+        Self { v: Vec::new(), _ty: PhantomData }\n+    }\n+\n+    /// Create a new empty map with specific capacity.\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        Self { v: Vec::with_capacity(capacity), _ty: PhantomData }\n+    }\n+\n+    /// Reserves capacity for at least additional more elements to be inserted in the map.\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.v.reserve(additional);\n+    }\n+\n+    /// Clears the map, removing all elements.\n+    pub fn clear(&mut self) {\n+        self.v.clear();\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible.\n+    pub fn shrink_to_fit(&mut self) {\n+        let min_len = self.v.iter().rposition(|slot| slot.is_some()).map_or(0, |i| i + 1);\n+        self.v.truncate(min_len);\n+        self.v.shrink_to_fit();\n+    }\n+\n+    /// Returns whether the map contains a value for the specified index.\n+    pub fn contains_idx(&self, idx: Idx<T>) -> bool {\n+        matches!(self.v.get(Self::to_idx(idx)), Some(Some(_)))\n+    }\n+\n+    /// Removes an index from the map, returning the value at the index if the index was previously in the map.\n+    pub fn remove(&mut self, idx: Idx<T>) -> Option<V> {\n+        self.v.get_mut(Self::to_idx(idx))?.take()\n+    }\n+\n     /// Inserts a value associated with a given arena index into the map.\n-    pub fn insert(&mut self, idx: Idx<T>, t: V) {\n+    ///\n+    /// If the map did not have this index present, None is returned.\n+    /// Otherwise, the value is updated, and the old value is returned.\n+    pub fn insert(&mut self, idx: Idx<T>, t: V) -> Option<V> {\n         let idx = Self::to_idx(idx);\n \n         self.v.resize_with((idx + 1).max(self.v.len()), || None);\n-        self.v[idx] = Some(t);\n+        self.v[idx].replace(t)\n     }\n \n     /// Returns a reference to the value associated with the provided index\n@@ -46,6 +86,16 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n         self.v.iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n     }\n \n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    pub fn entry(&mut self, idx: Idx<T>) -> Entry<'_, Idx<T>, V> {\n+        let idx = Self::to_idx(idx);\n+        self.v.resize_with((idx + 1).max(self.v.len()), || None);\n+        match &mut self.v[idx] {\n+            slot @ Some(_) => Entry::Occupied(OccupiedEntry { slot, _ty: PhantomData }),\n+            slot @ None => Entry::Vacant(VacantEntry { slot, _ty: PhantomData }),\n+        }\n+    }\n+\n     fn to_idx(idx: Idx<T>) -> usize {\n         u32::from(idx.into_raw()) as usize\n     }\n@@ -70,6 +120,119 @@ impl<T, V> std::ops::IndexMut<Idx<V>> for ArenaMap<Idx<V>, T> {\n \n impl<T, V> Default for ArenaMap<Idx<V>, T> {\n     fn default() -> Self {\n-        ArenaMap { v: Vec::new(), _ty: PhantomData }\n+        Self::new()\n+    }\n+}\n+\n+impl<T, V> Extend<(Idx<V>, T)> for ArenaMap<Idx<V>, T> {\n+    fn extend<I: IntoIterator<Item = (Idx<V>, T)>>(&mut self, iter: I) {\n+        iter.into_iter().for_each(move |(k, v)| {\n+            self.insert(k, v);\n+        });\n+    }\n+}\n+\n+impl<T, V> FromIterator<(Idx<V>, T)> for ArenaMap<Idx<V>, T> {\n+    fn from_iter<I: IntoIterator<Item = (Idx<V>, T)>>(iter: I) -> Self {\n+        let mut this = Self::new();\n+        this.extend(iter);\n+        this\n+    }\n+}\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This `enum` is constructed from the [`entry`] method on [`ArenaMap`].\n+///\n+/// [`entry`]: ArenaMap::entry\n+pub enum Entry<'a, IDX, V> {\n+    /// A vacant entry.\n+    Vacant(VacantEntry<'a, IDX, V>),\n+    /// An occupied entry.\n+    Occupied(OccupiedEntry<'a, IDX, V>),\n+}\n+\n+impl<'a, IDX, V> Entry<'a, IDX, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to\n+    /// the value in the entry.\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Self::Vacant(ent) => ent.insert(default),\n+            Self::Occupied(ent) => ent.into_mut(),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Self::Vacant(ent) => ent.insert(default()),\n+            Self::Occupied(ent) => ent.into_mut(),\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.\n+    pub fn and_modify<F: FnOnce(&mut V)>(mut self, f: F) -> Self {\n+        if let Self::Occupied(ent) = &mut self {\n+            f(ent.get_mut());\n+        }\n+        self\n+    }\n+}\n+\n+impl<'a, IDX, V> Entry<'a, IDX, V>\n+where\n+    V: Default,\n+{\n+    /// Ensures a value is in the entry by inserting the default value if empty, and returns a mutable reference\n+    /// to the value in the entry.\n+    pub fn or_default(self) -> &'a mut V {\n+        self.or_insert_with(Default::default)\n+    }\n+}\n+\n+/// A view into an vacant entry in a [`ArenaMap`]. It is part of the [`Entry`] enum.\n+pub struct VacantEntry<'a, IDX, V> {\n+    slot: &'a mut Option<V>,\n+    _ty: PhantomData<IDX>,\n+}\n+\n+impl<'a, IDX, V> VacantEntry<'a, IDX, V> {\n+    /// Sets the value of the entry with the `VacantEntry`\u2019s key, and returns a mutable reference to it.\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        self.slot.insert(value)\n+    }\n+}\n+\n+/// A view into an occupied entry in a [`ArenaMap`]. It is part of the [`Entry`] enum.\n+pub struct OccupiedEntry<'a, IDX, V> {\n+    slot: &'a mut Option<V>,\n+    _ty: PhantomData<IDX>,\n+}\n+\n+impl<'a, IDX, V> OccupiedEntry<'a, IDX, V> {\n+    /// Gets a reference to the value in the entry.\n+    pub fn get(&self) -> &V {\n+        self.slot.as_ref().expect(\"Occupied\")\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.slot.as_mut().expect(\"Occupied\")\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.slot.as_mut().expect(\"Occupied\")\n+    }\n+\n+    /// Sets the value of the entry with the `OccupiedEntry`\u2019s key, and returns the entry\u2019s old value.\n+    pub fn insert(&mut self, value: V) -> V {\n+        self.slot.replace(value).expect(\"Occupied\")\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    pub fn remove(self) -> V {\n+        self.slot.take().expect(\"Occupied\")\n     }\n }"}, {"sha": "eda8fceef05ba2aa78da842a18f53be5987037bf", "filename": "src/tools/rust-analyzer/xtask/src/release.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e801be71ce93a746d984d1f0e6590c866a800c/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs?ref=f1e801be71ce93a746d984d1f0e6590c866a800c", "patch": "@@ -81,7 +81,7 @@ impl flags::Promote {\n         let date = date_iso(sh)?;\n         let branch = format!(\"rust-analyzer-{date}\");\n         cmd!(sh, \"git switch -c {branch}\").run()?;\n-        cmd!(sh, \"git subtree pull -P src/tools/rust-analyzer rust-analyzer master\").run()?;\n+        cmd!(sh, \"git subtree pull -m ':arrow_up: rust-analyzer' -P src/tools/rust-analyzer rust-analyzer release\").run()?;\n \n         if !self.dry_run {\n             cmd!(sh, \"git push -u origin {branch}\").run()?;"}]}