{"sha": "75923dff5baa8de3acdec3026aac487033fe68fe", "node_id": "C_kwDOAAsO6NoAKDc1OTIzZGZmNWJhYThkZTNhY2RlYzMwMjZhYWM0ODcwMzNmZTY4ZmU", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T21:18:05Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `wildcard_enum_match_arm` and `match_wildcard_for_single_variants`", "tree": {"sha": "7e66526954951039c51cbc93deee8b54c7a5d271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e66526954951039c51cbc93deee8b54c7a5d271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75923dff5baa8de3acdec3026aac487033fe68fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75923dff5baa8de3acdec3026aac487033fe68fe", "html_url": "https://github.com/rust-lang/rust/commit/75923dff5baa8de3acdec3026aac487033fe68fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75923dff5baa8de3acdec3026aac487033fe68fe/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc75695e973d608903e1860db45b950b1a4cd470", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc75695e973d608903e1860db45b950b1a4cd470", "html_url": "https://github.com/rust-lang/rust/commit/dc75695e973d608903e1860db45b950b1a4cd470"}], "stats": {"total": 398, "additions": 203, "deletions": 195}, "files": [{"sha": "3515286d5b4af8e45596abfc7dd98ce51a1b2521", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/75923dff5baa8de3acdec3026aac487033fe68fe/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75923dff5baa8de3acdec3026aac487033fe68fe/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=75923dff5baa8de3acdec3026aac487033fe68fe", "patch": "@@ -0,0 +1,198 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_refutable, peel_hir_pat_refs, recurse_or_patterns};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::{Arm, Expr, PatKind, PathSegment, QPath, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, VariantDef};\n+use rustc_span::sym;\n+\n+use super::{MATCH_WILDCARD_FOR_SINGLE_VARIANTS, WILDCARD_ENUM_MATCH_ARM};\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    let adt_def = match ty.kind() {\n+        ty::Adt(adt_def, _)\n+            if adt_def.is_enum()\n+                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n+        {\n+            adt_def\n+        },\n+        _ => return,\n+    };\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    let mut has_non_wild = false;\n+    for arm in arms {\n+        match peel_hir_pat_refs(arm.pat).0.kind {\n+            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n+            PatKind::Binding(_, _, ident, None) => {\n+                wildcard_span = Some(arm.pat.span);\n+                wildcard_ident = Some(ident);\n+            },\n+            _ => has_non_wild = true,\n+        }\n+    }\n+    let wildcard_span = match wildcard_span {\n+        Some(x) if has_non_wild => x,\n+        _ => return,\n+    };\n+\n+    // Accumulate the variants which should be put in place of the wildcard because they're not\n+    // already covered.\n+    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n+\n+    let mut path_prefix = CommonPrefixSearcher::None;\n+    for arm in arms {\n+        // Guards mean that this case probably isn't exhaustively covered. Technically\n+        // this is incorrect, as we should really check whether each variant is exhaustively\n+        // covered by the set of guards that cover it, but that's really hard to do.\n+        recurse_or_patterns(arm.pat, |pat| {\n+            let path = match &peel_hir_pat_refs(pat).0.kind {\n+                PatKind::Path(path) => {\n+                    #[allow(clippy::match_same_arms)]\n+                    let id = match cx.qpath_res(path, pat.hir_id) {\n+                        Res::Def(\n+                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n+                            _,\n+                        ) => return,\n+                        Res::Def(_, id) => id,\n+                        _ => return,\n+                    };\n+                    if arm.guard.is_none() {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::TupleStruct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        }\n+                    }\n+                    path\n+                },\n+                PatKind::Struct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                            missing_variants.retain(|e| e.def_id != id);\n+                        }\n+                    }\n+                    path\n+                },\n+                _ => return,\n+            };\n+            match path {\n+                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n+                QPath::TypeRelative(\n+                    Ty {\n+                        kind: TyKind::Path(QPath::Resolved(_, path)),\n+                        ..\n+                    },\n+                    _,\n+                ) => path_prefix.with_prefix(path.segments),\n+                _ => (),\n+            }\n+        });\n+    }\n+\n+    let format_suggestion = |variant: &VariantDef| {\n+        format!(\n+            \"{}{}{}{}\",\n+            if let Some(ident) = wildcard_ident {\n+                format!(\"{} @ \", ident.name)\n+            } else {\n+                String::new()\n+            },\n+            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n+                let mut s = String::new();\n+                for seg in path_prefix {\n+                    s.push_str(seg.ident.as_str());\n+                    s.push_str(\"::\");\n+                }\n+                s\n+            } else {\n+                let mut s = cx.tcx.def_path_str(adt_def.did);\n+                s.push_str(\"::\");\n+                s\n+            },\n+            variant.name,\n+            match variant.ctor_kind {\n+                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n+                CtorKind::Fn => \"(..)\",\n+                CtorKind::Const => \"\",\n+                CtorKind::Fictive => \"{ .. }\",\n+            }\n+        )\n+    };\n+\n+    match missing_variants.as_slice() {\n+        [] => (),\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n+            cx,\n+            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+            wildcard_span,\n+            \"wildcard matches only a single variant and will also match any future added variants\",\n+            \"try this\",\n+            format_suggestion(x),\n+            Applicability::MaybeIncorrect,\n+        ),\n+        variants => {\n+            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n+                suggestions.push(\"_\".into());\n+                \"wildcard matches known variants and will also match future added variants\"\n+            } else {\n+                \"wildcard match will also match any future added variants\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                WILDCARD_ENUM_MATCH_ARM,\n+                wildcard_span,\n+                message,\n+                \"try this\",\n+                suggestions.join(\" | \"),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    };\n+}\n+\n+enum CommonPrefixSearcher<'a> {\n+    None,\n+    Path(&'a [PathSegment<'a>]),\n+    Mixed,\n+}\n+impl<'a> CommonPrefixSearcher<'a> {\n+    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n+        match path {\n+            [path @ .., _] => self.with_prefix(path),\n+            [] => (),\n+        }\n+    }\n+\n+    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n+        match self {\n+            Self::None => *self = Self::Path(path),\n+            Self::Path(self_path)\n+                if path\n+                    .iter()\n+                    .map(|p| p.ident.name)\n+                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n+            Self::Path(_) => *self = Self::Mixed,\n+            Self::Mixed => (),\n+        }\n+    }\n+}\n+\n+fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n+    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n+}"}, {"sha": "8c67380ed526a378e9eb66f3888b20dc71bed93b", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 195, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/75923dff5baa8de3acdec3026aac487033fe68fe/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75923dff5baa8de3acdec3026aac487033fe68fe/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=75923dff5baa8de3acdec3026aac487033fe68fe", "patch": "@@ -1,29 +1,26 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n     get_parent_expr, is_lang_ctor, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks,\n-    peel_hir_pat_refs, recurse_or_patterns, strip_pat_refs,\n+    strip_pat_refs,\n };\n use core::iter::once;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n-    PatKind, PathSegment, QPath, TyKind,\n+    Arm, BindingAnnotation, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind, QPath,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, VariantDef};\n+use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::sym;\n \n mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n+mod match_wild_enum;\n mod match_wild_err_arm;\n mod overlapping_arms;\n mod redundant_pattern_match;\n@@ -629,7 +626,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             match_bool::check(cx, ex, arms, expr);\n             overlapping_arms::check(cx, ex, arms);\n             match_wild_err_arm::check(cx, ex, arms);\n-            check_wild_enum_match(cx, ex, arms);\n+            match_wild_enum::check(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n             check_wild_in_or_pats(cx, arms);\n \n@@ -705,193 +702,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-enum CommonPrefixSearcher<'a> {\n-    None,\n-    Path(&'a [PathSegment<'a>]),\n-    Mixed,\n-}\n-impl<'a> CommonPrefixSearcher<'a> {\n-    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n-        match path {\n-            [path @ .., _] => self.with_prefix(path),\n-            [] => (),\n-        }\n-    }\n-\n-    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n-        match self {\n-            Self::None => *self = Self::Path(path),\n-            Self::Path(self_path)\n-                if path\n-                    .iter()\n-                    .map(|p| p.ident.name)\n-                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n-            Self::Path(_) => *self = Self::Mixed,\n-            Self::Mixed => (),\n-        }\n-    }\n-}\n-\n-fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    let adt_def = match ty.kind() {\n-        ty::Adt(adt_def, _)\n-            if adt_def.is_enum()\n-                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n-        {\n-            adt_def\n-        },\n-        _ => return,\n-    };\n-\n-    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n-    // the uncommon case, and the book-keeping is slightly expensive.\n-    let mut wildcard_span = None;\n-    let mut wildcard_ident = None;\n-    let mut has_non_wild = false;\n-    for arm in arms {\n-        match peel_hir_pat_refs(arm.pat).0.kind {\n-            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n-            PatKind::Binding(_, _, ident, None) => {\n-                wildcard_span = Some(arm.pat.span);\n-                wildcard_ident = Some(ident);\n-            },\n-            _ => has_non_wild = true,\n-        }\n-    }\n-    let wildcard_span = match wildcard_span {\n-        Some(x) if has_non_wild => x,\n-        _ => return,\n-    };\n-\n-    // Accumulate the variants which should be put in place of the wildcard because they're not\n-    // already covered.\n-    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n-\n-    let mut path_prefix = CommonPrefixSearcher::None;\n-    for arm in arms {\n-        // Guards mean that this case probably isn't exhaustively covered. Technically\n-        // this is incorrect, as we should really check whether each variant is exhaustively\n-        // covered by the set of guards that cover it, but that's really hard to do.\n-        recurse_or_patterns(arm.pat, |pat| {\n-            let path = match &peel_hir_pat_refs(pat).0.kind {\n-                PatKind::Path(path) => {\n-                    #[allow(clippy::match_same_arms)]\n-                    let id = match cx.qpath_res(path, pat.hir_id) {\n-                        Res::Def(\n-                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n-                            _,\n-                        ) => return,\n-                        Res::Def(_, id) => id,\n-                        _ => return,\n-                    };\n-                    if arm.guard.is_none() {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                    }\n-                    path\n-                },\n-                PatKind::TupleStruct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                        }\n-                    }\n-                    path\n-                },\n-                PatKind::Struct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n-                            missing_variants.retain(|e| e.def_id != id);\n-                        }\n-                    }\n-                    path\n-                },\n-                _ => return,\n-            };\n-            match path {\n-                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n-                QPath::TypeRelative(\n-                    hir::Ty {\n-                        kind: TyKind::Path(QPath::Resolved(_, path)),\n-                        ..\n-                    },\n-                    _,\n-                ) => path_prefix.with_prefix(path.segments),\n-                _ => (),\n-            }\n-        });\n-    }\n-\n-    let format_suggestion = |variant: &VariantDef| {\n-        format!(\n-            \"{}{}{}{}\",\n-            if let Some(ident) = wildcard_ident {\n-                format!(\"{} @ \", ident.name)\n-            } else {\n-                String::new()\n-            },\n-            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n-                let mut s = String::new();\n-                for seg in path_prefix {\n-                    s.push_str(seg.ident.as_str());\n-                    s.push_str(\"::\");\n-                }\n-                s\n-            } else {\n-                let mut s = cx.tcx.def_path_str(adt_def.did);\n-                s.push_str(\"::\");\n-                s\n-            },\n-            variant.name,\n-            match variant.ctor_kind {\n-                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n-                CtorKind::Fn => \"(..)\",\n-                CtorKind::Const => \"\",\n-                CtorKind::Fictive => \"{ .. }\",\n-            }\n-        )\n-    };\n-\n-    match missing_variants.as_slice() {\n-        [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n-            cx,\n-            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-            wildcard_span,\n-            \"wildcard matches only a single variant and will also match any future added variants\",\n-            \"try this\",\n-            format_suggestion(x),\n-            Applicability::MaybeIncorrect,\n-        ),\n-        variants => {\n-            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n-                suggestions.push(\"_\".into());\n-                \"wildcard matches known variants and will also match future added variants\"\n-            } else {\n-                \"wildcard match will also match any future added variants\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                WILDCARD_ENUM_MATCH_ARM,\n-                wildcard_span,\n-                message,\n-                \"try this\",\n-                suggestions.join(\" | \"),\n-                Applicability::MaybeIncorrect,\n-            );\n-        },\n-    };\n-}\n-\n fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n where\n     'b: 'a,"}]}