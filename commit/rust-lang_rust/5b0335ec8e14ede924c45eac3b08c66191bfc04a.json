{"sha": "5b0335ec8e14ede924c45eac3b08c66191bfc04a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMDMzNWVjOGUxNGVkZTkyNGM0NWVhYzNiMDhjNjYxOTFiZmMwNGE=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-01-27T02:13:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-03T23:37:24Z"}, "message": "Added generic string <-> number conversion functions to core::num.\n\nThey unify the different implementations that exists in int-template.rs, uint-template.rs and float.rs into one pair of functions, which are also in principle usable for anything that implements the necessary numeric traits. Their usage is somewhat complex due to the large amount of arguments each one takes, but as they're not meant to be used directly that shouldn't be a problem.", "tree": {"sha": "5933af4229d230e2faa21c29370eaf083ce4ed6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5933af4229d230e2faa21c29370eaf083ce4ed6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b0335ec8e14ede924c45eac3b08c66191bfc04a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0335ec8e14ede924c45eac3b08c66191bfc04a", "html_url": "https://github.com/rust-lang/rust/commit/5b0335ec8e14ede924c45eac3b08c66191bfc04a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b0335ec8e14ede924c45eac3b08c66191bfc04a/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb9c3ed8764077455b6e726ba49c9845e03f4f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb9c3ed8764077455b6e726ba49c9845e03f4f0c", "html_url": "https://github.com/rust-lang/rust/commit/bb9c3ed8764077455b6e726ba49c9845e03f4f0c"}], "stats": {"total": 540, "additions": 537, "deletions": 3}, "files": [{"sha": "b466191352fd306eb300c931cd5c43d25f4d99f8", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 537, "deletions": 3, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/5b0335ec8e14ede924c45eac3b08c66191bfc04a/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0335ec8e14ede924c45eac3b08c66191bfc04a/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=5b0335ec8e14ede924c45eac3b08c66191bfc04a", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n //! An interface for numeric types\n-use cmp::Eq;\n+use core::cmp::{Ord, Eq};\n use option::{None, Option, Some};\n+use char;\n+use str;\n+use kinds::Copy;\n+use vec;\n \n pub trait Num {\n     // FIXME: Trait composition. (#2616)\n@@ -125,12 +129,12 @@ pub pure fn is_neg_zero<T: Num One Zero Eq>(num: &T) -> bool {\n  *\n  * Note:\n  * Also returns `1` for `0^0`, despite that technically being an\n- * undefined number. The Reason for this is twofold:\n+ * undefined number. The reason for this is twofold:\n  * - If code written to use this function cares about that special case, it's\n  *   probably going to catch it before making the call.\n  * - If code written to use this function doesn't care about it, it's\n  *   probably assuming that `x^0` always equals `1`.\n- */ \n+ */\n pub pure fn pow_with_uint<T: Num One Zero>(radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -148,4 +152,534 @@ pub pure fn pow_with_uint<T: Num One Zero>(radix: uint, pow: uint) -> T {\n         multiplier *= multiplier;\n     }\n     total\n+}\n+\n+pub enum ExponentFormat {\n+    ExpNone,\n+    ExpDec,\n+    ExpBin\n+}\n+\n+pub enum SignificantDigits {\n+    DigAll,\n+    DigMax(uint),\n+    DigExact(uint)\n+}\n+\n+pub enum SignFormat {\n+    SignNone,\n+    SignNeg,\n+    SignAll\n+}\n+\n+/**\n+ * Converts a number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all numeric string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `special`       - Whether to attempt to compare to special values like\n+ *                     `inf` or `NaN`. Also needed to detect negative 0.\n+ *                     Can fail if it doesn't match `num`s type\n+ *                     (see safety note).\n+ * - `negative_zero` - Whether to treat the special value `-0` as\n+ *                     `-0` or as `+0`.\n+ * - `sign`          - How to emit the sign. Options are:\n+ *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNeg`:  Only `-` on negative values.\n+ *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n+ * - `digits`        - The amount of digits to use for emitting the\n+ *                     fractional part, if any. Options are:\n+ *     - `DigAll`:         All calculatable digits. Beware of bignums or\n+ *                         fractions!\n+ *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n+ *     - `DigExact(uint)`: Exactly N digits.\n+ *\n+ * # Return value\n+ * A tuple containing the byte vector, and a boolean flag indicating\n+ * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n+ * It returns a tuple because there can be ambiguity between a special value\n+ * and a number representation at higher bases.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails on wrong value for `special` (see safety note).\n+ *\n+ * # Safety note\n+ * The function detects the special values `inf`, `-inf` and `NaN` by\n+ * dynamically comparing `num` to `1 / 0`, `-1 / 0` and `0 / 0`\n+ * (each of type T) if `special` is `true`. This will fail on integer types\n+ * with a 'divide by zero'. Likewise, it will fail if `num` **is** one of\n+ * those special values, and `special` is `false`, because then the\n+ * algorithm just does normal calculations on them.\n+ *\n+ * # Possible improvements\n+ * - Currently performs no rounding if truncating trailing digits.\n+ * - Make function handle numbers with expensive copies better.\n+ */\n+pub pure fn to_str_bytes_common<T: Num Zero One Eq Ord Round Copy>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n+    if radix as int <  2 {\n+        fail fmt!(\"to_str_bytes_common: radix %? to low, \\\n+                   must lie in the range [2, 36]\", radix);\n+    } else if radix as int > 36 {\n+        fail fmt!(\"to_str_bytes_common: radix %? to high, \\\n+                   must lie in the range [2, 36]\", radix);\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    if special {\n+        if is_NaN(num) {\n+            return (str::to_bytes(\"NaN\"), true);\n+        } else if is_infinity(num){\n+            return match sign {\n+                SignAll => (str::to_bytes(\"+inf\"), true),\n+                _       => (str::to_bytes(\"inf\"), true)\n+            }\n+        } else if is_neg_infinity(num) {\n+            return match sign {\n+                SignNone => (str::to_bytes(\"inf\"), true),\n+                _        => (str::to_bytes(\"-inf\"), true),\n+            }\n+        }\n+    }\n+\n+    let neg = *num < _0 || (negative_zero && *num == _0\n+                            && special && is_neg_zero(num));\n+    let mut buf: ~[u8] = ~[];\n+    let radix_gen      = Num::from_int::<T>(radix as int);\n+\n+    let mut deccum;\n+\n+    // First emit the non-fractional part, looping at least once to make\n+    // sure at least a `0` gets emitted.\n+    deccum = num.round(RoundToZero);\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit_signed = deccum % radix_gen;\n+        let current_digit = if current_digit_signed < _0 {\n+            -current_digit_signed\n+        } else {\n+            current_digit_signed\n+        };\n+\n+        // Decrease the deccumulator one digit at a time\n+        deccum /= radix_gen;\n+        deccum = deccum.round(RoundToZero);\n+\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+                 .unwrap() as u8);\n+        }\n+\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // If limited digits, calculate one digit more for rounding.\n+    let (limit_digits, digit_count, exact) = match digits {\n+        DigAll          => (false, 0u,      false),\n+        DigMax(count)   => (true,  count+1, false),\n+        DigExact(count) => (true,  count+1, true)\n+    };\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('-' as u8);\n+            }\n+        }\n+        SignAll => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('+' as u8);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    unsafe { // FIXME: Pureness workaround (#4568)\n+        vec::reverse(buf);\n+    }\n+\n+    // Remember start of the fractional digits.\n+    // Points one beyond end of buf if none get generated,\n+    // or at the '.' otherwise.\n+    let start_fractional_digits = buf.len();\n+\n+    // Now emit the fractional part, if any\n+    deccum = num.fract();\n+    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push('.' as u8);\n+        }\n+        let mut dig = 0u;\n+\n+        // calculate new digits while\n+        // - there is no limit and there are digits left\n+        // - or there is a limit, it's not reached yet and\n+        //   - it's exact\n+        //   - or it's a maximum, and there are still digits left\n+        while (!limit_digits && deccum != _0)\n+           || (limit_digits && dig < digit_count && (\n+                   exact\n+                || (!exact && deccum != _0)\n+              )\n+        ) {\n+            // Shift first fractional digit into the integer part\n+            deccum *= radix_gen;\n+\n+            // Calculate the absolute value of each digit.\n+            // See note in first loop.\n+            let current_digit_signed = deccum.round(RoundToZero);\n+            let current_digit = if current_digit_signed < _0 {\n+                -current_digit_signed\n+            } else {\n+                current_digit_signed\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push(char::from_digit(\n+                    current_digit.to_int() as uint, radix).unwrap() as u8);\n+            }\n+\n+            // Decrease the deccumulator one fractional digit at a time\n+            deccum = deccum.fract();\n+            dig += 1u;\n+        }\n+\n+        // If digits are limited, and that limit has been reached,\n+        // cut off the one extra digit, and depending on its value\n+        // round the remaining ones.\n+        if limit_digits && dig == digit_count {\n+            let ascii2value = |chr: u8| {\n+                char::to_digit(chr as char, radix).unwrap() as uint\n+            };\n+            let value2ascii = |val: uint| {\n+                char::from_digit(val, radix).unwrap() as u8\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                let extra_digit = ascii2value(buf.pop());\n+                if extra_digit >= radix / 2 { // -> need to round\n+                    let mut i: int = buf.len() as int - 1;\n+                    loop {\n+                        // If reached left end of number, have to\n+                        // insert additional digit:\n+                        if i < 0\n+                        || buf[i] == '-' as u8\n+                        || buf[i] == '+' as u8 {\n+                            buf.insert((i + 1) as uint, value2ascii(1));\n+                            break;\n+                        }\n+\n+                        // Skip the '.'\n+                        if buf[i] == '.' as u8 { i -= 1; loop; }\n+\n+                        // Either increment the digit,\n+                        // or set to 0 if max and carry the 1.\n+                        let current_digit = ascii2value(buf[i]);\n+                        if current_digit < (radix - 1) {\n+                            buf[i] = value2ascii(current_digit+1);\n+                            break;\n+                        } else {\n+                            buf[i] = value2ascii(0);\n+                            i -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if number of digits is not exact, remove all trailing '0's up to\n+    // and including the '.'\n+    if !exact {\n+        let buf_max_i = buf.len() - 1;\n+\n+        // index to truncate from\n+        let mut i = buf_max_i;\n+\n+        // discover trailing zeros of fractional part\n+        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+            i -= 1;\n+        }\n+\n+        // Only attempt to truncate digits if buf has fractional digits\n+        if i >= start_fractional_digits {\n+            // If buf ends with '.', cut that too.\n+            if buf[i] == '.' as u8 { i -= 1 }\n+\n+            // only resize buf if we actually remove digits\n+            if i < buf_max_i {\n+                buf = buf.slice(0, i + 1);\n+            }\n+        }\n+    }\n+\n+    (buf, false)\n+}\n+\n+/**\n+ * Converts a number to its string representation. This is a wrapper for\n+ * `to_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_common<T: Num Zero One Eq Ord Round Copy>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n+    let (bytes, special) = to_str_bytes_common(num, radix, special,\n+                               negative_zero, sign, digits);\n+    (str::from_bytes(bytes), special)\n+}\n+\n+// Some constants for from_str_bytes_common's input validation,\n+// they define minimum radix values for which the character is a valid digit.\n+priv const DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+\n+/**\n+ * Parses a byte slice as a number. This is meant to\n+ * be a common base implementation for all numeric string conversion\n+ * functions like `from_str()` or `from_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `buf`        - The byte slice to parse.\n+ * - `radix`      - Which base to parse the number as. Accepts 2-36.\n+ * - `negative`   - Whether to accept negative numbers.\n+ * - `fractional` - Whether to accept numbers with fractional parts.\n+ * - `special`    - Whether to accept special values like `inf`\n+ *                  and `NaN`. Can conflict with `radix`, see Failure.\n+ * - `exponent`   - Which exponent format to accept. Options are:\n+ *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n+ *                  `-8.2`.\n+ *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n+ *                  `8.2E-2`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n+ *                  `FFp128`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ * - `empty_zero` - Whether to accept a empty `buf` as a 0 or not.\n+ *\n+ * # Return value\n+ * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n+ * `None` otherwise, depending on the constraints set by the remaining\n+ * arguments.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n+ * - Fails if `radix` > 18 and `special == true` due to conflict\n+ *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n+ *\n+ * # Possible improvements\n+ * - Could accept option to allow ignoring underscores, allowing for numbers\n+ *   formated like `FF_AE_FF_FF`.\n+ */\n+pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n+        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    match exponent {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'e' as decimal exponent\", radix),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'p' as binary exponent\", radix),\n+        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n+          => fail fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        special values 'inf' and 'NaN'\", radix),\n+        _ if radix as int < 2\n+          => fail fmt!(\"from_str_bytes_common: radix %? to low, \\\n+                        must lie in the range [2, 36]\", radix),\n+        _ if radix as int > 36\n+          => fail fmt!(\"from_str_bytes_common: radix %? to high, \\\n+                        must lie in the range [2, 36]\", radix),\n+        _ => ()\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+    let radix_gen: T = Num::from_int(radix as int);\n+\n+    let len = buf.len();\n+\n+    if len == 0 {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    if special {\n+        if buf == str::to_bytes(\"inf\") || buf == str::to_bytes(\"+inf\") {\n+            return Some(infinity());\n+        } else if buf == str::to_bytes(\"-inf\") {\n+            if negative {\n+                return Some(neg_infinity());\n+            } else {\n+                return None;\n+            }\n+        } else if buf == str::to_bytes(\"NaN\") {\n+            return Some(NaN());\n+        }\n+    }\n+\n+    let (start, accum_positive) = match buf[0] {\n+      '-' as u8 if !negative => return None,\n+      '-' as u8 => (1u, false),\n+      '+' as u8 => (1u, true),\n+       _        => (0u, true)\n+    };\n+\n+    // Initialize accumulator with signed zero for floating point parsing to\n+    // work\n+    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n+    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut i          = start;\n+    let mut exp_found  = false;\n+\n+    // Parse integer part of number\n+    while i < len {\n+        let c = buf[i] as char;\n+\n+        match char::to_digit(c, radix) {\n+            Some(digit) => {\n+                // shift accum one digit left\n+                accum *= radix_gen;\n+\n+                // add/subtract current digit depending on sign\n+                if accum_positive {\n+                    accum += Num::from_int(digit as int);\n+                } else {\n+                    accum -= Num::from_int(digit as int);\n+                }\n+\n+                // Detect overflow by comparing to last value\n+                if accum_positive && accum < last_accum { return None; }\n+                if !accum_positive && accum > last_accum { return None; }\n+                last_accum = accum;\n+            }\n+            None => match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp_found = true;\n+                    break;                       // start of exponent\n+                }\n+                '.' if fractional => {\n+                    i += 1u;                     // skip the '.'\n+                    break;                       // start of fractional part\n+                }\n+                _ => return None                 // invalid number\n+            }\n+        }\n+\n+        i += 1u;\n+    }\n+\n+    // Parse fractional part of number\n+    // Skip if already reached start of exponent\n+    if !exp_found {\n+        let mut power = _1;\n+\n+        while i < len {\n+            let c = buf[i] as char;\n+\n+            match char::to_digit(c, radix) {\n+                Some(digit) => {\n+                    // Decrease power one order of magnitude\n+                    power /= radix_gen;\n+\n+                    // add/subtract current digit depending on sign\n+                    if accum_positive {\n+                        accum += Num::from_int::<T>(digit as int) * power;\n+                    } else {\n+                        accum -= Num::from_int::<T>(digit as int) * power;\n+                    }\n+\n+                    // Detect overflow by comparing to last value\n+                    if accum_positive && accum < last_accum { return None; }\n+                    if !accum_positive && accum > last_accum { return None; }\n+                    last_accum = accum;\n+                }\n+                None => match c {\n+                    'e' | 'E' | 'p' | 'P' => {\n+                        exp_found = true;\n+                        break;                   // start of exponent\n+                    }\n+                    _ => return None             // invalid number\n+                }\n+            }\n+\n+            i += 1u;\n+        }\n+    }\n+\n+    // Special case: buf not empty, but does not contain any digit in front\n+    // of the exponent sign -> number is empty string\n+    if i == start {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    let mut multiplier = _1;\n+\n+    if exp_found {\n+        let c = buf[i] as char;\n+        let base = match (c, exponent) {\n+            ('e', ExpDec) | ('E', ExpDec) => 10u,\n+            ('p', ExpBin) | ('P', ExpBin) => 2u,\n+            _ => return None // char doesn't fit given exponent format\n+        };\n+\n+        // parse remaining bytes as decimal integer,\n+        // skipping the exponent char\n+        let exp: Option<int> = from_str_bytes_common(\n+            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n+\n+        match exp {\n+            Some(exp_pow) => {\n+                multiplier = if exp_pow < 0 {\n+                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n+                } else {\n+                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n+                }\n+            }\n+            None => return None // invalid exponent -> invalid number\n+        }\n+    }\n+\n+    Some(accum * multiplier)\n+}\n+\n+/**\n+ * Parses a string as a number. This is a wrapper for\n+ * `from_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_common<T: Num Zero One Ord Copy>(\n+        buf: &str, radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    from_str_bytes_common(str::to_bytes(buf), radix, negative,\n+                            fractional, special, exponent, empty_zero)\n }\n\\ No newline at end of file"}]}