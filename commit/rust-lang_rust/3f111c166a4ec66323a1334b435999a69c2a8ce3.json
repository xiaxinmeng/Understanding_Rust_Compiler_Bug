{"sha": "3f111c166a4ec66323a1334b435999a69c2a8ce3", "node_id": "C_kwDOAAsO6NoAKDNmMTExYzE2NmE0ZWM2NjMyM2ExMzM0YjQzNTk5OWE2OWMyYThjZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-13T19:04:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-13T19:04:59Z"}, "message": "Auto merge of #2114 - cbeuw:shim-rmw, r=RalfJung\n\nUse atomic RMW for `{mutex, rwlock, cond, srwlock}_get_or_create_id` functions\n\nThis is required for #1963\n\n`{mutex, rwlock, cond, srwlock}_get_or_create_id()` currently checks whether an ID field is 0 using an atomic read, allocate one and get a new ID if it is, then write it in a separate atomic write. This is fine without weak memory. For instance, in `pthread_mutex_lock` which may be called by two threads concurrently, only one thread can read 0, create and then write a new ID, the later-run thread will always see the newly created ID and never 0.\n```rust\n    fn pthread_mutex_lock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n        let this = self.eval_context_mut();\n\n        let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n        let id = mutex_get_or_create_id(this, mutex_op)?;\n        let active_thread = this.get_active_thread();\n```\n\nHowever, with weak memory behaviour, both threads may read 0: the first thread has to see 0 because nothing else was written to it, and the second thread is not guaranteed to observe the latest value, causing a duplicate mutex to be created and both threads \"successfully\" acquiring the lock at the same time.\n\nThis is a pretty typical pattern requiring the use of atomic RMWs. RMW *always* reads the latest value in a location, so only one thread can create the new mutex and ID, all others scheduled later will see the new ID.", "tree": {"sha": "d3c0575124651e689835d45f22fc080aa471e45d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c0575124651e689835d45f22fc080aa471e45d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f111c166a4ec66323a1334b435999a69c2a8ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f111c166a4ec66323a1334b435999a69c2a8ce3", "html_url": "https://github.com/rust-lang/rust/commit/3f111c166a4ec66323a1334b435999a69c2a8ce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f111c166a4ec66323a1334b435999a69c2a8ce3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d33e7fc31cffcf5c461b419ed40f71d3318202a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33e7fc31cffcf5c461b419ed40f71d3318202a6", "html_url": "https://github.com/rust-lang/rust/commit/d33e7fc31cffcf5c461b419ed40f71d3318202a6"}, {"sha": "9e38dc4d499a6c405e0685d71235495699a34209", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e38dc4d499a6c405e0685d71235495699a34209", "html_url": "https://github.com/rust-lang/rust/commit/9e38dc4d499a6c405e0685d71235495699a34209"}], "stats": {"total": 233, "additions": 170, "deletions": 63}, "files": [{"sha": "b8656627e6f9751dd5e5f9ac5266f20377aa7a52", "filename": "src/data_race.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=3f111c166a4ec66323a1334b435999a69c2a8ce3", "patch": "@@ -73,9 +73,9 @@ use rustc_middle::{mir, ty::layout::TyAndLayout};\n use rustc_target::abi::Size;\n \n use crate::{\n-    AllocId, AllocRange, ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MemoryKind,\n-    MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, OpTy, Pointer, RangeMap, Scalar,\n-    ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp, VectorIdx,\n+    AllocId, AllocRange, HelpersEvalContextExt, ImmTy, Immediate, InterpResult, MPlaceTy,\n+    MemoryKind, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, OpTy, Pointer, RangeMap,\n+    Scalar, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp, VectorIdx,\n };\n \n pub type AllocExtra = VClockAlloc;\n@@ -450,12 +450,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n-        let op_place = this.deref_operand(op)?;\n-        let offset = Size::from_bytes(offset);\n-\n-        // Ensure that the following read at an offset is within bounds.\n-        assert!(op_place.layout.size >= offset + layout.size);\n-        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar_atomic(&value_place, atomic)\n     }\n \n@@ -469,12 +464,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let op_place = this.deref_operand(op)?;\n-        let offset = Size::from_bytes(offset);\n-\n-        // Ensure that the following read at an offset is within bounds.\n-        assert!(op_place.layout.size >= offset + layout.size);\n-        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.write_scalar_atomic(value.into(), &value_place, atomic)\n     }\n "}, {"sha": "6b3b787f0605064a4a23c43c693b684b5161780e", "filename": "src/helpers.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=3f111c166a4ec66323a1334b435999a69c2a8ce3", "patch": "@@ -597,18 +597,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn read_scalar_at_offset(\n+    /// Calculates the MPlaceTy given the offset and layout of an access on an operand\n+    fn deref_operand_and_offset(\n         &self,\n         op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n         let this = self.eval_context_ref();\n         let op_place = this.deref_operand(op)?;\n         let offset = Size::from_bytes(offset);\n-        // Ensure that the following read at an offset is within bounds\n+\n+        // Ensure that the access is within bounds.\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        Ok(value_place)\n+    }\n+\n+    fn read_scalar_at_offset(\n+        &self,\n+        op: &OpTy<'tcx, Tag>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        let this = self.eval_context_ref();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar(&value_place.into())\n     }\n \n@@ -620,11 +633,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ()> {\n         let this = self.eval_context_mut();\n-        let op_place = this.deref_operand(op)?;\n-        let offset = Size::from_bytes(offset);\n-        // Ensure that the following read at an offset is within bounds\n-        assert!(op_place.layout.size >= offset + layout.size);\n-        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.write_scalar(value, &value_place.into())\n     }\n "}, {"sha": "56d496984757b0475621234c2b29f03b8d2488bb", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=3f111c166a4ec66323a1334b435999a69c2a8ce3", "patch": "@@ -112,16 +112,28 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, MutexId> {\n-    let id = mutex_get_id(ecx, mutex_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid mutex id. Need to allocate\n-        // a new mutex.\n-        let id = ecx.mutex_create();\n-        mutex_set_id(ecx, mutex_op, id.to_u32_scalar())?;\n-        Ok(id)\n-    } else {\n-        Ok(MutexId::from_u32(id))\n-    }\n+    let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n+\n+    ecx.mutex_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n@@ -156,16 +168,28 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n-    let id = rwlock_get_id(ecx, rwlock_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid rwlock id. Need to allocate\n-        // a new read-write lock.\n-        let id = ecx.rwlock_create();\n-        rwlock_set_id(ecx, rwlock_op, id.to_u32_scalar())?;\n-        Ok(id)\n-    } else {\n-        Ok(RwLockId::from_u32(id))\n-    }\n+    let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n+\n+    ecx.rwlock_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n // pthread_condattr_t\n@@ -228,16 +252,28 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, CondvarId> {\n-    let id = cond_get_id(ecx, cond_op)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid conditional variable id.\n-        // Need to allocate a new id.\n-        let id = ecx.condvar_create();\n-        cond_set_id(ecx, cond_op, id.to_u32_scalar())?;\n-        Ok(id)\n-    } else {\n-        Ok(CondvarId::from_u32(id))\n-    }\n+    let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n+\n+    ecx.condvar_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>("}, {"sha": "6a6b2269e62a0f1d7bcb504c0c1e3e6d0daa1603", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=3f111c166a4ec66323a1334b435999a69c2a8ce3", "patch": "@@ -7,16 +7,28 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     lock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n-    let id = ecx.read_scalar_at_offset(lock_op, 0, ecx.machine.layouts.u32)?.to_u32()?;\n-    if id == 0 {\n-        // 0 is a default value and also not a valid rwlock id. Need to allocate\n-        // a new rwlock.\n-        let id = ecx.rwlock_create();\n-        ecx.write_scalar_at_offset(lock_op, 0, id.to_u32_scalar(), ecx.machine.layouts.u32)?;\n-        Ok(id)\n-    } else {\n-        Ok(RwLockId::from_u32(id))\n-    }\n+    let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n+\n+    ecx.rwlock_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}"}, {"sha": "0eebe4f654e4cb5ca43fadd6ff7ac448709e916b", "filename": "src/sync.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f111c166a4ec66323a1334b435999a69c2a8ce3/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=3f111c166a4ec66323a1334b435999a69c2a8ce3", "patch": "@@ -215,6 +215,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.mutexes.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next MutexId. Creates that mutex if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn mutex_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, MutexId>\n+    where\n+        F: FnOnce(&mut MiriEvalContext<'mir, 'tcx>, MutexId) -> InterpResult<'tcx, Option<MutexId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.mutexes.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.mutexes.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n     #[inline]\n     /// Get the id of the thread that currently owns this lock.\n     fn mutex_get_owner(&mut self, id: MutexId) -> ThreadId {\n@@ -297,6 +315,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.rwlocks.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n+    where\n+        F: FnOnce(\n+            &mut MiriEvalContext<'mir, 'tcx>,\n+            RwLockId,\n+        ) -> InterpResult<'tcx, Option<RwLockId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.rwlocks.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.rwlocks.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n     #[inline]\n     /// Check if locked.\n     fn rwlock_is_locked(&self, id: RwLockId) -> bool {\n@@ -445,6 +484,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.sync.condvars.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n+    where\n+        F: FnOnce(\n+            &mut MiriEvalContext<'mir, 'tcx>,\n+            CondvarId,\n+        ) -> InterpResult<'tcx, Option<CondvarId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.condvars.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.condvars.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n     #[inline]\n     /// Is the conditional variable awaited?\n     fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {"}]}