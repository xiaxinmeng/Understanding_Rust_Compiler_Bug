{"sha": "23a363821de3276747b27754bd0dd03a32991187", "node_id": "C_kwDOAAsO6NoAKDIzYTM2MzgyMWRlMzI3Njc0N2IyNzc1NGJkMGRkMDNhMzI5OTExODc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-24T22:08:37Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-24T22:08:37Z"}, "message": "Revert \"Report allocation errors as panics\"\n\nThis reverts commit c9a6e41026d7aa27d897fb83e995447719753076.", "tree": {"sha": "48b153ca8446d82f0cbd887c37161e9201612918", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b153ca8446d82f0cbd887c37161e9201612918"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23a363821de3276747b27754bd0dd03a32991187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23a363821de3276747b27754bd0dd03a32991187", "html_url": "https://github.com/rust-lang/rust/commit/23a363821de3276747b27754bd0dd03a32991187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23a363821de3276747b27754bd0dd03a32991187/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f54dbe6e3116a475f63b580884f07474239a0b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/f54dbe6e3116a475f63b580884f07474239a0b25", "html_url": "https://github.com/rust-lang/rust/commit/f54dbe6e3116a475f63b580884f07474239a0b25"}], "stats": {"total": 134, "additions": 27, "deletions": 107}, "files": [{"sha": "95c07abf73106647bc3a6c3f3909caff11cce0ed", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -35,6 +35,3 @@ compiler-builtins-mem = ['compiler_builtins/mem']\n compiler-builtins-c = [\"compiler_builtins/c\"]\n compiler-builtins-no-asm = [\"compiler_builtins/no-asm\"]\n compiler-builtins-mangled-names = [\"compiler_builtins/mangled-names\"]\n-\n-# Make panics and failed asserts immediately abort without formatting any message\n-panic_immediate_abort = [\"core/panic_immediate_abort\"]"}, {"sha": "6f2ba957bcda0995ac98952ae60666991d7df76b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 9, "deletions": 75, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -14,11 +14,6 @@ use core::ptr::{self, NonNull};\n #[doc(inline)]\n pub use core::alloc::*;\n \n-#[cfg(not(no_global_oom_handling))]\n-use core::any::Any;\n-#[cfg(not(no_global_oom_handling))]\n-use core::panic::BoxMeUp;\n-\n #[cfg(test)]\n mod tests;\n \n@@ -348,77 +343,14 @@ pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A)\n     }\n }\n \n-/// Payload passed to the panic handler when `handle_alloc_error` is called.\n-#[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n-#[derive(Debug)]\n-pub struct AllocErrorPanicPayload {\n-    layout: Layout,\n-}\n-\n-impl AllocErrorPanicPayload {\n-    /// Internal function for the standard library to clone a payload.\n-    #[unstable(feature = \"std_internals\", issue = \"none\")]\n-    #[doc(hidden)]\n-    pub fn internal_clone(&self) -> Self {\n-        AllocErrorPanicPayload { layout: self.layout }\n-    }\n-\n-    /// Returns the [`Layout`] of the allocation attempt that caused the error.\n-    #[unstable(feature = \"panic_oom_payload\", issue = \"none\")]\n-    pub fn layout(&self) -> Layout {\n-        self.layout\n-    }\n-}\n-\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-#[cfg(not(no_global_oom_handling))]\n-unsafe impl BoxMeUp for AllocErrorPanicPayload {\n-    fn take_box(&mut self) -> *mut (dyn Any + Send) {\n-        use crate::boxed::Box;\n-        Box::into_raw(Box::new(self.internal_clone()))\n-    }\n-\n-    fn get(&mut self) -> &(dyn Any + Send) {\n-        self\n-    }\n-}\n-\n // # Allocation error handler\n \n-#[cfg(all(not(no_global_oom_handling), not(test)))]\n-fn rust_oom(layout: Layout) -> ! {\n-    if cfg!(feature = \"panic_immediate_abort\") {\n-        core::intrinsics::abort()\n-    }\n-\n-    extern \"Rust\" {\n-        // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-        // that gets resolved to the `#[panic_handler]` function.\n-        #[lang = \"panic_impl\"]\n-        fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !;\n-\n-        // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n-        // Its value depends on the -Zoom={panic,abort} compiler option.\n-        static __rust_alloc_error_handler_should_panic: u8;\n-    }\n-\n-    // Hack to work around issues with the lifetime of Arguments.\n-    match format_args!(\"memory allocation of {} bytes failed\", layout.size()) {\n-        fmt => {\n-            // Create a PanicInfo with a custom payload for the panic handler.\n-            let can_unwind = unsafe { __rust_alloc_error_handler_should_panic != 0 };\n-            let mut pi = core::panic::PanicInfo::internal_constructor(\n-                Some(&fmt),\n-                core::panic::Location::caller(),\n-                can_unwind,\n-            );\n-            let payload = AllocErrorPanicPayload { layout };\n-            pi.set_payload(&payload);\n-\n-            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n-            unsafe { panic_impl(&pi) }\n-        }\n-    }\n+#[cfg(not(no_global_oom_handling))]\n+extern \"Rust\" {\n+    // This is the magic symbol to call the global alloc error handler. rustc generates\n+    // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n+    // default implementations below (`__rdl_oom`) otherwise.\n+    fn __rust_alloc_error_handler(size: usize, align: usize) -> !;\n }\n \n /// Abort on memory allocation error or failure.\n@@ -443,7 +375,9 @@ pub const fn handle_alloc_error(layout: Layout) -> ! {\n     }\n \n     fn rt_error(layout: Layout) -> ! {\n-        rust_oom(layout);\n+        unsafe {\n+            __rust_alloc_error_handler(layout.size(), layout.align());\n+        }\n     }\n \n     unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }"}, {"sha": "a002421aeef3a472d1cb2cf544b8104338518154", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -135,7 +135,6 @@\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n-#![feature(panic_internals)]\n #![feature(pattern)]\n #![feature(pointer_byte_offsets)]\n #![feature(provide_any)]"}, {"sha": "f2fda64a1ee72f7e31e5c723ada4abf1800a1976", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -67,7 +67,7 @@ llvm-libunwind = [\"unwind/llvm-libunwind\"]\n system-llvm-libunwind = [\"unwind/system-llvm-libunwind\"]\n \n # Make panics and failed asserts immediately abort without formatting any message\n-panic_immediate_abort = [\"alloc/panic_immediate_abort\"]\n+panic_immediate_abort = [\"core/panic_immediate_abort\"]\n \n # Enable std_detect default features for stdarch/crates/std_detect:\n # https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/Cargo.toml"}, {"sha": "318a46d1b637e53eddfd56779bf76853265bc814", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -320,7 +320,6 @@\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]\n #![feature(new_uninit)]\n-#![feature(panic_oom_payload)]\n #![feature(slice_concat_trait)]\n #![feature(thin_box)]\n #![feature(try_reserve_kind)]"}, {"sha": "a46a29cbad6081400329485378ea87808bbc2512", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23a363821de3276747b27754bd0dd03a32991187/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=23a363821de3276747b27754bd0dd03a32991187", "patch": "@@ -245,24 +245,19 @@ fn default_hook(info: &PanicInfo<'_>) {\n \n     // The current implementation always returns `Some`.\n     let location = info.location().unwrap();\n+\n+    let msg = match info.payload().downcast_ref::<&'static str>() {\n+        Some(s) => *s,\n+        None => match info.payload().downcast_ref::<String>() {\n+            Some(s) => &s[..],\n+            None => \"Box<dyn Any>\",\n+        },\n+    };\n     let thread = thread_info::current_thread();\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut dyn crate::io::Write| {\n-        // Use the panic message directly if available, otherwise take it from\n-        // the payload.\n-        if let Some(msg) = info.message() {\n-            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n-        } else {\n-            let msg = if let Some(s) = info.payload().downcast_ref::<&'static str>() {\n-                *s\n-            } else if let Some(s) = info.payload().downcast_ref::<String>() {\n-                &s[..]\n-            } else {\n-                \"Box<dyn Any>\"\n-            };\n-            let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n-        }\n+        let _ = writeln!(err, \"thread '{name}' panicked at '{msg}', {location}\");\n \n         static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n@@ -529,8 +524,6 @@ pub fn panicking() -> bool {\n #[cfg(not(test))]\n #[panic_handler]\n pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n-    use alloc::alloc::AllocErrorPanicPayload;\n-\n     struct PanicPayload<'a> {\n         inner: &'a fmt::Arguments<'a>,\n         string: Option<String>,\n@@ -557,7 +550,8 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             // We do two allocations here, unfortunately. But (a) they're required with the current\n-            // scheme, and (b) OOM uses its own separate payload type which doesn't allocate.\n+            // scheme, and (b) we don't handle panic + OOM properly anyway (see comment in\n+            // begin_panic below).\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -582,14 +576,7 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        if let Some(payload) = info.payload().downcast_ref::<AllocErrorPanicPayload>() {\n-            rust_panic_with_hook(\n-                &mut payload.internal_clone(),\n-                info.message(),\n-                loc,\n-                info.can_unwind(),\n-            );\n-        } else if let Some(msg) = msg.as_str() {\n+        if let Some(msg) = msg.as_str() {\n             rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc, info.can_unwind());\n         } else {\n             rust_panic_with_hook(\n@@ -636,7 +623,11 @@ pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n         fn take_box(&mut self) -> *mut (dyn Any + Send) {\n-            // Note that this should be the only allocation performed in this code path.\n+            // Note that this should be the only allocation performed in this code path. Currently\n+            // this means that panic!() on OOM will invoke this code path, but then again we're not\n+            // really ready for panic on OOM anyway. If we do start doing this, then we should\n+            // propagate this allocation to be performed in the parent of this thread instead of the\n+            // thread that's panicking.\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                 None => process::abort(),"}]}