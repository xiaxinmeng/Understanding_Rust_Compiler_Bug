{"sha": "f6d688d13070a54b288486900a30680d013c66ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDY4OGQxMzA3MGE1NGIyODg0ODY5MDBhMzA2ODBkMDEzYzY2Y2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-06T15:08:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-06T15:08:26Z"}, "message": "Merge #3842\n\n3842: Add lib-proc-macro mod in ra_proc_macro_srv r=matklad a=edwin0cheng\n\nThis PR add a module in ra_proc_macro_srv, which is just copy & paste from rustc lib_proc_macro and remove all unstable features in it. \r\n\r\nThe main idea here is by doing that, we could build the `ra_proc_macro_srv` without nightly compiler and remain ABI compatibility. \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "39262a1e6cb34897723c4c36b7503fc1483c5a9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39262a1e6cb34897723c4c36b7503fc1483c5a9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d688d13070a54b288486900a30680d013c66ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJei0XqCRBK7hj4Ov3rIwAAdHIIAGzZ2WbHANG6emwBtGzOk2Ul\njyjuyBfCwwniCFJ3XcGSR2ghlCny44usC5sfPZ24rl6/rq5mV25C3G5fN3aosQ3e\nFDW2gCMQYoVIW7Kaqqy1HbEatYMuVDLY9/rPcUnJzcwDTfsanWb0ywrW8P9YU54P\njuFZBmLWj6XsxFSshMbz3aEAe83jsMxCunoNyPpuiMg9TjMVtQwrfrLUlwiFpn4Y\nSiAxOdJcUWhsvY+JCygKzy1mu3TXVds7Pz1+wTmhNn1P2lBjIC+D5KuvCIDvjBkG\nHXiVmRZHUXJ32wgX0L/WWvOuF8AoqoDCy7epGZkMn5tgcQvse2tTO5wQ7MEPHsU=\n=7oqM\n-----END PGP SIGNATURE-----\n", "payload": "tree 39262a1e6cb34897723c4c36b7503fc1483c5a9f\nparent 2603a9e628d304c8cb8fd08979e2f9c9afeac69e\nparent 4f70162f54ceaa4ff68a5ab74e31b5dda7ac9444\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586185706 +0000\ncommitter GitHub <noreply@github.com> 1586185706 +0000\n\nMerge #3842\n\n3842: Add lib-proc-macro mod in ra_proc_macro_srv r=matklad a=edwin0cheng\n\nThis PR add a module in ra_proc_macro_srv, which is just copy & paste from rustc lib_proc_macro and remove all unstable features in it. \r\n\r\nThe main idea here is by doing that, we could build the `ra_proc_macro_srv` without nightly compiler and remain ABI compatibility. \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d688d13070a54b288486900a30680d013c66ca", "html_url": "https://github.com/rust-lang/rust/commit/f6d688d13070a54b288486900a30680d013c66ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d688d13070a54b288486900a30680d013c66ca/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2603a9e628d304c8cb8fd08979e2f9c9afeac69e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2603a9e628d304c8cb8fd08979e2f9c9afeac69e", "html_url": "https://github.com/rust-lang/rust/commit/2603a9e628d304c8cb8fd08979e2f9c9afeac69e"}, {"sha": "4f70162f54ceaa4ff68a5ab74e31b5dda7ac9444", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f70162f54ceaa4ff68a5ab74e31b5dda7ac9444", "html_url": "https://github.com/rust-lang/rust/commit/4f70162f54ceaa4ff68a5ab74e31b5dda7ac9444"}], "stats": {"total": 2959, "additions": 2950, "deletions": 9}, "files": [{"sha": "91a57bf796be5723627b402e59423aba8a3bded0", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -1082,9 +1082,7 @@ dependencies = [\n  \"difference\",\n  \"ra_proc_macro\",\n  \"ra_tt\",\n- \"serde\",\n  \"serde_derive\",\n- \"serde_json\",\n ]\n \n [[package]]\n@@ -1414,18 +1412,18 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.106\"\n+version = \"1.0.104\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"36df6ac6412072f67cf767ebbde4133a5b2e88e76dc6187fa7104cd16f783399\"\n+checksum = \"414115f25f818d7dfccec8ee535d76949ae78584fc4f79a6f45a904bf8ab4449\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.106\"\n+version = \"1.0.104\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n+checksum = \"128f9e303a5a29922045a830221b8f78ec74a5f544944f3d5984f8ec3895ef64\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "6300d668ab0627702fe90dc5317540457a5cf789", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -12,10 +12,9 @@ doctest = false\n ra_tt = { path = \"../ra_tt\" }\n ra_proc_macro = { path = \"../ra_proc_macro\" }\n \n-serde_derive = \"1.0.104\"\n-serde = \"1.0.104\"\n-serde_json = \"1.0.48\"\n \n [dev-dependencies]\n cargo_metadata = \"0.9.1\"\n difference = \"2.0.0\"\n+# used as proc macro test target\n+serde_derive = \"=1.0.104\"\n\\ No newline at end of file"}, {"sha": "80cfa1174d230cafa63f1852aa606e202b787073", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -10,6 +10,11 @@\n //! * By **copying** the whole rustc `lib_proc_macro` code, we are able to build this with `stable`\n //!   rustc rather than `unstable`. (Although in gerenal ABI compatibility is still an issue)\n \n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod proc_macro;\n+\n+use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n \n pub fn expand_task(_task: &ExpansionTask) -> Result<ExpansionResult, String> {"}, {"sha": "dae6ff1d16c38f95fd69b95683e0d5afa5166a32", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/buffer.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,149 @@\n+//! lib-proc-macro Buffer management for same-process client<->server communication.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/buffer.rs\n+//! augmented with removing unstable features\n+\n+use std::io::{self, Write};\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::slice;\n+\n+#[repr(C)]\n+struct Slice<'a, T> {\n+    data: &'a [T; 0],\n+    len: usize,\n+}\n+\n+unsafe impl<'a, T: Sync> Sync for Slice<'a, T> {}\n+unsafe impl<'a, T: Sync> Send for Slice<'a, T> {}\n+\n+impl<'a, T> Copy for Slice<'a, T> {}\n+impl<'a, T> Clone for Slice<'a, T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<'a, T> From<&'a [T]> for Slice<'a, T> {\n+    fn from(xs: &'a [T]) -> Self {\n+        Slice { data: unsafe { &*(xs.as_ptr() as *const [T; 0]) }, len: xs.len() }\n+    }\n+}\n+\n+impl<'a, T> Deref for Slice<'a, T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data.as_ptr(), self.len) }\n+    }\n+}\n+\n+#[repr(C)]\n+pub struct Buffer<T: Copy> {\n+    data: *mut T,\n+    len: usize,\n+    capacity: usize,\n+    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<'_, T>) -> Buffer<T>,\n+    drop: extern \"C\" fn(Buffer<T>),\n+}\n+\n+unsafe impl<T: Copy + Sync> Sync for Buffer<T> {}\n+unsafe impl<T: Copy + Send> Send for Buffer<T> {}\n+\n+impl<T: Copy> Default for Buffer<T> {\n+    fn default() -> Self {\n+        Self::from(vec![])\n+    }\n+}\n+\n+impl<T: Copy> Deref for Buffer<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data as *const T, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> DerefMut for Buffer<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> Buffer<T> {\n+    pub(super) fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(super) fn clear(&mut self) {\n+        self.len = 0;\n+    }\n+\n+    pub(super) fn take(&mut self) -> Self {\n+        mem::take(self)\n+    }\n+\n+    pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n+        // Fast path to avoid going through an FFI call.\n+        if let Some(final_len) = self.len.checked_add(xs.len()) {\n+            if final_len <= self.capacity {\n+                let dst = unsafe { slice::from_raw_parts_mut(self.data, self.capacity) };\n+                dst[self.len..][..xs.len()].copy_from_slice(xs);\n+                self.len = final_len;\n+                return;\n+            }\n+        }\n+        let b = self.take();\n+        *self = (b.extend_from_slice)(b, Slice::from(xs));\n+    }\n+}\n+\n+impl Write for Buffer<u8> {\n+    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n+        self.extend_from_slice(xs);\n+        Ok(xs.len())\n+    }\n+\n+    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n+        self.extend_from_slice(xs);\n+        Ok(())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Copy> Drop for Buffer<T> {\n+    fn drop(&mut self) {\n+        let b = self.take();\n+        (b.drop)(b);\n+    }\n+}\n+\n+impl<T: Copy> From<Vec<T>> for Buffer<T> {\n+    fn from(mut v: Vec<T>) -> Self {\n+        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n+        mem::forget(v);\n+\n+        // This utility function is nested in here because it can *only*\n+        // be safely called on `Buffer`s created by *this* `proc_macro`.\n+        fn to_vec<T: Copy>(b: Buffer<T>) -> Vec<T> {\n+            unsafe {\n+                let Buffer { data, len, capacity, .. } = b;\n+                mem::forget(b);\n+                Vec::from_raw_parts(data, len, capacity)\n+            }\n+        }\n+\n+        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<'_, T>) -> Buffer<T> {\n+            let mut v = to_vec(b);\n+            v.extend_from_slice(&xs);\n+            Buffer::from(v)\n+        }\n+\n+        extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n+            mem::drop(to_vec(b));\n+        }\n+\n+        Buffer { data, len, capacity, extend_from_slice, drop }\n+    }\n+}"}, {"sha": "4b5dc7fd05c6be69f19542d01510d679087c2908", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/client.rs", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,472 @@\n+//! lib-proc-macro Client-side types.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/client.rs\n+//! augmented with removing unstable features\n+\n+use super::*;\n+\n+macro_rules! define_handles {\n+    (\n+        'owned: $($oty:ident,)*\n+        'interned: $($ity:ident,)*\n+    ) => {\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub struct HandleCounters {\n+            $($oty: AtomicUsize,)*\n+            $($ity: AtomicUsize,)*\n+        }\n+\n+        impl HandleCounters {\n+            // FIXME(eddyb) use a reference to the `static COUNTERS`, intead of\n+            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n+            extern \"C\" fn get() -> &'static Self {\n+                static COUNTERS: HandleCounters = HandleCounters {\n+                    $($oty: AtomicUsize::new(1),)*\n+                    $($ity: AtomicUsize::new(1),)*\n+                };\n+                &COUNTERS\n+            }\n+        }\n+\n+        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub(super) struct HandleStore<S: server::Types> {\n+            $($oty: handle::OwnedStore<S::$oty>,)*\n+            $($ity: handle::InternedStore<S::$ity>,)*\n+        }\n+\n+        impl<S: server::Types> HandleStore<S> {\n+            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n+                HandleStore {\n+                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n+                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n+                }\n+            }\n+        }\n+\n+        $(\n+            #[repr(C)]\n+            pub struct $oty(pub(crate) handle::Handle);\n+            // impl !Send for $oty {}\n+            // impl !Sync for $oty {}\n+\n+            // Forward `Drop::drop` to the inherent `drop` method.\n+            impl Drop for $oty {\n+                fn drop(&mut self) {\n+                    $oty(self.0).drop();\n+                }\n+            }\n+\n+            impl<S> Encode<S> for $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    let handle = self.0;\n+                    mem::forget(self);\n+                    handle.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &$oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<'s, S: server::Types,> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    &s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &mut $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<'s, S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s mut Marked<S::$oty, $oty>\n+            {\n+                fn decode(\n+                    r: &mut Reader<'_>,\n+                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n+                ) -> Self {\n+                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$oty.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $oty {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                    $oty(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+\n+        $(\n+            #[repr(C)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+            pub(crate) struct $ity(handle::Handle);\n+            // impl !Send for $ity {}\n+            // impl !Sync for $ity {}\n+\n+            impl<S> Encode<S> for $ity {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$ity.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $ity {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                    $ity(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+    }\n+}\n+define_handles! {\n+    'owned:\n+    TokenStream,\n+    TokenStreamBuilder,\n+    TokenStreamIter,\n+    Group,\n+    Literal,\n+    SourceFile,\n+    MultiSpan,\n+    Diagnostic,\n+\n+    'interned:\n+    Punct,\n+    Ident,\n+    Span,\n+}\n+\n+// FIXME(eddyb) generate these impls by pattern-matching on the\n+// names of methods - also could use the presence of `fn drop`\n+// to distinguish between 'owned and 'interned, above.\n+// Alternatively, special 'modes\" could be listed of types in with_api\n+// instead of pattern matching on methods, here and in server decl.\n+\n+impl Clone for TokenStream {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for TokenStreamIter {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Group {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Literal {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.debug())\n+    }\n+}\n+\n+impl Clone for SourceFile {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.debug())\n+    }\n+}\n+\n+macro_rules! define_client_side {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)?) => {\n+        $(impl $name {\n+            #[allow(unused)]\n+            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n+                panic!(\"hello\");\n+                // Bridge::with(|bridge| {\n+                //     let mut b = bridge.cached_buffer.take();\n+\n+                //     b.clear();\n+                //     api_tags::Method::$name(api_tags::$name::$method).encode(&mut b, &mut ());\n+                //     reverse_encode!(b; $($arg),*);\n+\n+                //     b = bridge.dispatch.call(b);\n+\n+                //     let r = Result::<_, PanicMessage>::decode(&mut &b[..], &mut ());\n+\n+                //     bridge.cached_buffer = b;\n+\n+                //     r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n+                // })\n+            })*\n+        })*\n+    }\n+}\n+with_api!(self, self, define_client_side);\n+\n+enum BridgeState<'a> {\n+    /// No server is currently connected to this client.\n+    NotConnected,\n+\n+    /// A server is connected and available for requests.\n+    Connected(Bridge<'a>),\n+\n+    /// Access to the bridge is being exclusively acquired\n+    /// (e.g., during `BridgeState::with`).\n+    InUse,\n+}\n+\n+enum BridgeStateL {}\n+\n+impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n+    type Out = BridgeState<'a>;\n+}\n+\n+thread_local! {\n+    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n+        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n+}\n+\n+impl BridgeState<'_> {\n+    /// Take exclusive control of the thread-local\n+    /// `BridgeState`, and pass it to `f`, mutably.\n+    /// The state will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    ///\n+    /// N.B., while `f` is running, the thread-local state\n+    /// is `BridgeState::InUse`.\n+    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n+        BRIDGE_STATE.with(|state| {\n+            state.replace(BridgeState::InUse, |mut state| {\n+                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n+                f(&mut *state)\n+            })\n+        })\n+    }\n+}\n+\n+impl Bridge<'_> {\n+    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n+        // Hide the default panic output within `proc_macro` expansions.\n+        // NB. the server can't do this because it may use a different libstd.\n+        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n+        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n+            let prev = panic::take_hook();\n+            panic::set_hook(Box::new(move |info| {\n+                let hide = BridgeState::with(|state| match state {\n+                    BridgeState::NotConnected => false,\n+                    BridgeState::Connected(_) | BridgeState::InUse => true,\n+                });\n+                if !hide {\n+                    prev(info)\n+                }\n+            }));\n+        });\n+\n+        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n+    }\n+\n+    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n+        BridgeState::with(|state| match state {\n+            BridgeState::NotConnected => {\n+                panic!(\"procedural macro API is used outside of a procedural macro\");\n+            }\n+            BridgeState::InUse => {\n+                panic!(\"procedural macro API is used while it's already in use\");\n+            }\n+            BridgeState::Connected(bridge) => f(bridge),\n+        })\n+    }\n+}\n+\n+/// A client-side \"global object\" (usually a function pointer),\n+/// which may be using a different `proc_macro` from the one\n+/// used by the server, but can be interacted with compatibly.\n+///\n+/// N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).\n+/// The call ABI of function pointers used for `F` doesn't\n+/// need to match between server and client, since it's only\n+/// passed between them and (eventually) called by the client.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct Client<F> {\n+    // FIXME(eddyb) use a reference to the `static COUNTERS`, intead of\n+    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n+    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n+    pub(super) f: F,\n+}\n+\n+/// Client-side helper for handling client panics, entering the bridge,\n+/// deserializing input and serializing output.\n+// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n+fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n+    mut bridge: Bridge<'_>,\n+    f: impl FnOnce(A) -> R,\n+) -> Buffer<u8> {\n+    // The initial `cached_buffer` contains the input.\n+    let mut b = bridge.cached_buffer.take();\n+\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        bridge.enter(|| {\n+            let reader = &mut &b[..];\n+            let input = A::decode(reader, &mut ());\n+\n+            // Put the `cached_buffer` back in the `Bridge`, for requests.\n+            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n+\n+            let output = f(input);\n+\n+            // Take the `cached_buffer` back out, for the output value.\n+            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+            // having handles outside the `bridge.enter(|| ...)` scope, and\n+            // to catch panics that could happen while encoding the success.\n+            //\n+            // Note that panics should be impossible beyond this point, but\n+            // this is defensively trying to avoid any accidental panicking\n+            // reaching the `extern \"C\"` (which should `abort` but may not\n+            // at the moment, so this is also potentially preventing UB).\n+            b.clear();\n+            Ok::<_, ()>(output).encode(&mut b, &mut ());\n+        })\n+    }))\n+    .map_err(PanicMessage::from)\n+    .unwrap_or_else(|e| {\n+        b.clear();\n+        Err::<(), _>(e).encode(&mut b, &mut ());\n+    });\n+    b\n+}\n+\n+impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+    pub fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+        }\n+        Client { get_handle_counters: HandleCounters::get, run, f }\n+    }\n+}\n+\n+impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+    pub fn expand2(f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |(input, input2)| {\n+                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+            })\n+        }\n+        Client { get_handle_counters: HandleCounters::get, run, f }\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum ProcMacro {\n+    CustomDerive {\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+    },\n+\n+    Attr {\n+        name: &'static str,\n+        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n+    },\n+\n+    Bang {\n+        name: &'static str,\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+    },\n+}\n+\n+impl std::fmt::Debug for ProcMacro {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"ProcMacro {{ name: {} }}\", self.name())\n+    }\n+}\n+\n+impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, .. } => name,\n+        }\n+    }\n+\n+    pub fn custom_derive(\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        expand: fn(crate::TokenStream) -> crate::TokenStream,\n+    ) -> Self {\n+        ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n+    }\n+\n+    pub fn attr(\n+        name: &'static str,\n+        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+    ) -> Self {\n+        ProcMacro::Attr { name, client: Client::expand2(expand) }\n+    }\n+\n+    pub fn bang(name: &'static str, expand: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n+        ProcMacro::Bang { name, client: Client::expand1(expand) }\n+    }\n+}"}, {"sha": "b8addff4aa6e79f3348163dde592c95912656e3e", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/closure.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,27 @@\n+//! lib-proc-macro Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/closure.rs#\n+//! augmented with removing unstable features\n+\n+#[repr(C)]\n+pub struct Closure<'a, A, R> {\n+    call: unsafe extern \"C\" fn(&mut Env, A) -> R,\n+    env: &'a mut Env,\n+}\n+\n+struct Env;\n+\n+impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n+    fn from(f: &'a mut F) -> Self {\n+        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: &mut Env, arg: A) -> R {\n+            (*(env as *mut _ as *mut F))(arg)\n+        }\n+        Closure { call: call::<A, R, F>, env: unsafe { &mut *(f as *mut _ as *mut Env) } }\n+    }\n+}\n+\n+impl<'a, A, R> Closure<'a, A, R> {\n+    pub fn call(&mut self, arg: A) -> R {\n+        unsafe { (self.call)(self.env, arg) }\n+    }\n+}"}, {"sha": "a2f77b5aca7fa303b167db3956c974c53b0a7969", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/handle.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,73 @@\n+//! lib-proc-macro Server-side handles and storage for per-handle data.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/handle.rs\n+//! augmented with removing unstable features\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+use std::num::NonZeroU32;\n+use std::ops::{Index, IndexMut};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub(super) type Handle = NonZeroU32;\n+\n+pub(super) struct OwnedStore<T: 'static> {\n+    counter: &'static AtomicUsize,\n+    data: BTreeMap<Handle, T>,\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        // Ensure the handle counter isn't 0, which would panic later,\n+        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n+        assert_ne!(counter.load(Ordering::SeqCst), 0);\n+\n+        OwnedStore { counter, data: BTreeMap::new() }\n+    }\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n+        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n+        assert!(self.data.insert(handle, x).is_none());\n+        handle\n+    }\n+\n+    pub(super) fn take(&mut self, h: Handle) -> T {\n+        self.data.remove(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> Index<Handle> for OwnedStore<T> {\n+    type Output = T;\n+    fn index(&self, h: Handle) -> &T {\n+        self.data.get(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> IndexMut<Handle> for OwnedStore<T> {\n+    fn index_mut(&mut self, h: Handle) -> &mut T {\n+        self.data.get_mut(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+pub(super) struct InternedStore<T: 'static> {\n+    owned: OwnedStore<T>,\n+    interner: HashMap<T, Handle>,\n+}\n+\n+impl<T: Copy + Eq + Hash> InternedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        InternedStore { owned: OwnedStore::new(counter), interner: HashMap::new() }\n+    }\n+\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let owned = &mut self.owned;\n+        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n+    }\n+\n+    pub(super) fn copy(&mut self, h: Handle) -> T {\n+        self.owned[h]\n+    }\n+}"}, {"sha": "6ae3926b266df3ff901c86c0b943413a2314efa3", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/mod.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,404 @@\n+//! lib-proc-macro Internal interface for communicating between a `proc_macro` client\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/mod.rs\n+//! augmented with removing unstable features\n+//!\n+//! Internal interface for communicating between a `proc_macro` client\n+//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n+//!\n+//! Serialization (with C ABI buffers) and unique integer handles are employed\n+//! to allow safely interfacing between two copies of `proc_macro` built\n+//! (from the same source) by different compilers with potentially mismatching\n+//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n+\n+#![deny(unsafe_code)]\n+\n+pub use crate::proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use std::fmt;\n+use std::hash::Hash;\n+use std::marker;\n+use std::mem;\n+use std::ops::Bound;\n+use std::panic;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Once;\n+use std::thread;\n+\n+/// Higher-order macro describing the server RPC API, allowing automatic\n+/// generation of type-safe Rust APIs, both client-side and server-side.\n+///\n+/// `with_api!(MySelf, my_self, my_macro)` expands to:\n+/// ```rust,ignore (pseudo-code)\n+/// my_macro! {\n+///     // ...\n+///     Literal {\n+///         // ...\n+///         fn character(ch: char) -> MySelf::Literal;\n+///         // ...\n+///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n+///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n+///     },\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// The first two arguments serve to customize the arguments names\n+/// and argument/return types, to enable several different usecases:\n+///\n+/// If `my_self` is just `self`, then each `fn` signature can be used\n+/// as-is for a method. If it's anything else (`self_` in practice),\n+/// then the signatures don't have a special `self` argument, and\n+/// can, therefore, have a different one introduced.\n+///\n+/// If `MySelf` is just `Self`, then the types are only valid inside\n+/// a trait or a trait impl, where the trait has associated types\n+/// for each of the API types. If non-associated types are desired,\n+/// a module name (`self` in practice) can be used instead of `Self`.\n+macro_rules! with_api {\n+    ($S:ident, $self:ident, $m:ident) => {\n+        $m! {\n+            TokenStream {\n+                fn drop($self: $S::TokenStream);\n+                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n+                fn new() -> $S::TokenStream;\n+                fn is_empty($self: &$S::TokenStream) -> bool;\n+                fn from_str(src: &str) -> $S::TokenStream;\n+                fn to_string($self: &$S::TokenStream) -> String;\n+                fn from_token_tree(\n+                    tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n+                ) -> $S::TokenStream;\n+                fn into_iter($self: $S::TokenStream) -> $S::TokenStreamIter;\n+            },\n+            TokenStreamBuilder {\n+                fn drop($self: $S::TokenStreamBuilder);\n+                fn new() -> $S::TokenStreamBuilder;\n+                fn push($self: &mut $S::TokenStreamBuilder, stream: $S::TokenStream);\n+                fn build($self: $S::TokenStreamBuilder) -> $S::TokenStream;\n+            },\n+            TokenStreamIter {\n+                fn drop($self: $S::TokenStreamIter);\n+                fn clone($self: &$S::TokenStreamIter) -> $S::TokenStreamIter;\n+                fn next(\n+                    $self: &mut $S::TokenStreamIter,\n+                ) -> Option<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n+            },\n+            Group {\n+                fn drop($self: $S::Group);\n+                fn clone($self: &$S::Group) -> $S::Group;\n+                fn new(delimiter: Delimiter, stream: $S::TokenStream) -> $S::Group;\n+                fn delimiter($self: &$S::Group) -> Delimiter;\n+                fn stream($self: &$S::Group) -> $S::TokenStream;\n+                fn span($self: &$S::Group) -> $S::Span;\n+                fn span_open($self: &$S::Group) -> $S::Span;\n+                fn span_close($self: &$S::Group) -> $S::Span;\n+                fn set_span($self: &mut $S::Group, span: $S::Span);\n+            },\n+            Punct {\n+                fn new(ch: char, spacing: Spacing) -> $S::Punct;\n+                fn as_char($self: $S::Punct) -> char;\n+                fn spacing($self: $S::Punct) -> Spacing;\n+                fn span($self: $S::Punct) -> $S::Span;\n+                fn with_span($self: $S::Punct, span: $S::Span) -> $S::Punct;\n+            },\n+            Ident {\n+                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n+                fn span($self: $S::Ident) -> $S::Span;\n+                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n+            },\n+            Literal {\n+                fn drop($self: $S::Literal);\n+                fn clone($self: &$S::Literal) -> $S::Literal;\n+                // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+                fn debug($self: &$S::Literal) -> String;\n+                fn integer(n: &str) -> $S::Literal;\n+                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n+                fn float(n: &str) -> $S::Literal;\n+                fn f32(n: &str) -> $S::Literal;\n+                fn f64(n: &str) -> $S::Literal;\n+                fn string(string: &str) -> $S::Literal;\n+                fn character(ch: char) -> $S::Literal;\n+                fn byte_string(bytes: &[u8]) -> $S::Literal;\n+                fn span($self: &$S::Literal) -> $S::Span;\n+                fn set_span($self: &mut $S::Literal, span: $S::Span);\n+                fn subspan(\n+                    $self: &$S::Literal,\n+                    start: Bound<usize>,\n+                    end: Bound<usize>,\n+                ) -> Option<$S::Span>;\n+            },\n+            SourceFile {\n+                fn drop($self: $S::SourceFile);\n+                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n+                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n+                fn path($self: &$S::SourceFile) -> String;\n+                fn is_real($self: &$S::SourceFile) -> bool;\n+            },\n+            MultiSpan {\n+                fn drop($self: $S::MultiSpan);\n+                fn new() -> $S::MultiSpan;\n+                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n+            },\n+            Diagnostic {\n+                fn drop($self: $S::Diagnostic);\n+                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n+                fn sub(\n+                    $self: &mut $S::Diagnostic,\n+                    level: Level,\n+                    msg: &str,\n+                    span: $S::MultiSpan,\n+                );\n+                fn emit($self: $S::Diagnostic);\n+            },\n+            Span {\n+                fn debug($self: $S::Span) -> String;\n+                fn def_site() -> $S::Span;\n+                fn call_site() -> $S::Span;\n+                fn mixed_site() -> $S::Span;\n+                fn source_file($self: $S::Span) -> $S::SourceFile;\n+                fn parent($self: $S::Span) -> Option<$S::Span>;\n+                fn source($self: $S::Span) -> $S::Span;\n+                fn start($self: $S::Span) -> LineColumn;\n+                fn end($self: $S::Span) -> LineColumn;\n+                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n+                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n+                fn source_text($self: $S::Span) -> Option<String>;\n+            },\n+        }\n+    };\n+}\n+\n+// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_encode {\n+    ($writer:ident;) => {};\n+    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n+        reverse_encode!($writer; $($rest),*);\n+        $first.encode(&mut $writer, &mut ());\n+    }\n+}\n+\n+// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_decode {\n+    ($reader:ident, $s:ident;) => {};\n+    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n+        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n+        let $first = <$first_ty>::decode(&mut $reader, $s);\n+    }\n+}\n+\n+#[allow(unsafe_code)]\n+mod buffer;\n+#[forbid(unsafe_code)]\n+pub mod client;\n+#[allow(unsafe_code)]\n+mod closure;\n+#[forbid(unsafe_code)]\n+mod handle;\n+#[macro_use]\n+#[forbid(unsafe_code)]\n+mod rpc;\n+#[allow(unsafe_code)]\n+mod scoped_cell;\n+#[forbid(unsafe_code)]\n+pub mod server;\n+\n+use buffer::Buffer;\n+pub use rpc::PanicMessage;\n+use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n+\n+/// An active connection between a server and a client.\n+/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n+/// then passes it to the client through the function pointer in the `run`\n+/// field of `client::Client`. The client holds its copy of the `Bridge`\n+/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n+#[repr(C)]\n+pub struct Bridge<'a> {\n+    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n+    /// used for making requests, but also for passing input to client.\n+    cached_buffer: Buffer<u8>,\n+\n+    /// Server-side function that the client uses to make requests.\n+    dispatch: closure::Closure<'a, Buffer<u8>, Buffer<u8>>,\n+}\n+\n+#[forbid(unsafe_code)]\n+#[allow(non_camel_case_types)]\n+mod api_tags {\n+    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n+\n+    macro_rules! declare_tags {\n+        ($($name:ident {\n+            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+        }),* $(,)?) => {\n+            $(\n+                pub(super) enum $name {\n+                    $($method),*\n+                }\n+                rpc_encode_decode!(enum $name { $($method),* });\n+            )*\n+\n+\n+            pub(super) enum Method {\n+                $($name($name)),*\n+            }\n+            rpc_encode_decode!(enum Method { $($name(m)),* });\n+        }\n+    }\n+    with_api!(self, self, declare_tags);\n+}\n+\n+/// Helper to wrap associated types to allow trait impl dispatch.\n+/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n+/// can overlap, but if the impls are, instead, on types like\n+/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n+trait Mark {\n+    type Unmarked;\n+    fn mark(unmarked: Self::Unmarked) -> Self;\n+}\n+\n+/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n+trait Unmark {\n+    type Unmarked;\n+    fn unmark(self) -> Self::Unmarked;\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct Marked<T, M> {\n+    value: T,\n+    _marker: marker::PhantomData<M>,\n+}\n+\n+impl<T, M> Mark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        Marked { value: unmarked, _marker: marker::PhantomData }\n+    }\n+}\n+impl<T, M> Unmark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.value\n+    }\n+}\n+impl<'a, T, M> Unmark for &'a Marked<T, M> {\n+    type Unmarked = &'a T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &self.value\n+    }\n+}\n+impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n+    type Unmarked = &'a mut T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &mut self.value\n+    }\n+}\n+\n+impl<T: Mark> Mark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark)\n+    }\n+}\n+impl<T: Unmark> Unmark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark)\n+    }\n+}\n+\n+macro_rules! mark_noop {\n+    ($($ty:ty),* $(,)?) => {\n+        $(\n+            impl Mark for $ty {\n+                type Unmarked = Self;\n+                fn mark(unmarked: Self::Unmarked) -> Self {\n+                    unmarked\n+                }\n+            }\n+            impl Unmark for $ty {\n+                type Unmarked = Self;\n+                fn unmark(self) -> Self::Unmarked {\n+                    self\n+                }\n+            }\n+        )*\n+    }\n+}\n+mark_noop! {\n+    (),\n+    bool,\n+    char,\n+    &'_ [u8],\n+    &'_ str,\n+    String,\n+    Delimiter,\n+    Level,\n+    LineColumn,\n+    Spacing,\n+    Bound<usize>,\n+}\n+\n+rpc_encode_decode!(\n+    enum Delimiter {\n+        Parenthesis,\n+        Brace,\n+        Bracket,\n+        None,\n+    }\n+);\n+rpc_encode_decode!(\n+    enum Level {\n+        Error,\n+        Warning,\n+        Note,\n+        Help,\n+    }\n+);\n+rpc_encode_decode!(struct LineColumn { line, column });\n+rpc_encode_decode!(\n+    enum Spacing {\n+        Alone,\n+        Joint,\n+    }\n+);\n+\n+#[derive(Clone)]\n+pub enum TokenTree<G, P, I, L> {\n+    Group(G),\n+    Punct(P),\n+    Ident(I),\n+    Literal(L),\n+}\n+\n+impl<G: Mark, P: Mark, I: Mark, L: Mark> Mark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        match unmarked {\n+            TokenTree::Group(tt) => TokenTree::Group(G::mark(tt)),\n+            TokenTree::Punct(tt) => TokenTree::Punct(P::mark(tt)),\n+            TokenTree::Ident(tt) => TokenTree::Ident(I::mark(tt)),\n+            TokenTree::Literal(tt) => TokenTree::Literal(L::mark(tt)),\n+        }\n+    }\n+}\n+impl<G: Unmark, P: Unmark, I: Unmark, L: Unmark> Unmark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        match self {\n+            TokenTree::Group(tt) => TokenTree::Group(tt.unmark()),\n+            TokenTree::Punct(tt) => TokenTree::Punct(tt.unmark()),\n+            TokenTree::Ident(tt) => TokenTree::Ident(tt.unmark()),\n+            TokenTree::Literal(tt) => TokenTree::Literal(tt.unmark()),\n+        }\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum TokenTree<G, P, I, L> {\n+        Group(tt),\n+        Punct(tt),\n+        Ident(tt),\n+        Literal(tt),\n+    }\n+);"}, {"sha": "3528d5c99661bde135a0a4a88f06fd221fc38b6e", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/rpc.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,311 @@\n+//! lib-proc-macro Serialization for client-server communication.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/rpc.rs\n+//! augmented with removing unstable features\n+//!\n+//! Serialization for client-server communication.\n+\n+use std::any::Any;\n+use std::char;\n+use std::io::Write;\n+use std::num::NonZeroU32;\n+use std::ops::Bound;\n+use std::str;\n+\n+pub(super) type Writer = super::buffer::Buffer<u8>;\n+\n+pub(super) trait Encode<S>: Sized {\n+    fn encode(self, w: &mut Writer, s: &mut S);\n+}\n+\n+pub(super) type Reader<'a> = &'a [u8];\n+\n+pub(super) trait Decode<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n+}\n+\n+pub(super) trait DecodeMut<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n+}\n+\n+macro_rules! rpc_encode_decode {\n+    (le $ty:ty) => {\n+        impl<S> Encode<S> for $ty {\n+            fn encode(self, w: &mut Writer, _: &mut S) {\n+                w.write_all(&self.to_le_bytes()).unwrap();\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $ty {\n+            fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n+                const N: usize = ::std::mem::size_of::<$ty>();\n+\n+                let mut bytes = [0; N];\n+                bytes.copy_from_slice(&r[..N]);\n+                *r = &r[N..];\n+\n+                Self::from_le_bytes(bytes)\n+            }\n+        }\n+    };\n+    (struct $name:ident { $($field:ident),* $(,)? }) => {\n+        impl<S> Encode<S> for $name {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                $(self.$field.encode(w, s);)*\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $name {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                $name {\n+                    $($field: DecodeMut::decode(r, s)),*\n+                }\n+            }\n+        }\n+    };\n+    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n+        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                // HACK(eddyb): `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[allow(non_upper_case_globals)]\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n+\n+                match self {\n+                    $($name::$variant $(($field))* => {\n+                        tag::$variant.encode(w, s);\n+                        $($field.encode(w, s);)*\n+                    })*\n+                }\n+            }\n+        }\n+\n+        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n+            for $name $(<$($T),+>)?\n+        {\n+            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+                // HACK(eddyb): `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[allow(non_upper_case_globals)]\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n+\n+                match u8::decode(r, s) {\n+                    $(tag::$variant => {\n+                        $(let $field = DecodeMut::decode(r, s);)*\n+                        $name::$variant $(($field))*\n+                    })*\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for () {\n+    fn encode(self, _: &mut Writer, _: &mut S) {}\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for () {\n+    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n+}\n+\n+impl<S> Encode<S> for u8 {\n+    fn encode(self, w: &mut Writer, _: &mut S) {\n+        w.write_all(&[self]).unwrap();\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for u8 {\n+    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n+        let x = r[0];\n+        *r = &r[1..];\n+        x\n+    }\n+}\n+\n+rpc_encode_decode!(le u32);\n+rpc_encode_decode!(le usize);\n+\n+impl<S> Encode<S> for bool {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u8).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for bool {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        match u8::decode(r, s) {\n+            0 => false,\n+            1 => true,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for char {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u32).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for char {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        char::from_u32(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for NonZeroU32 {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.get().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        Self::new(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.0.encode(w, s);\n+        self.1.encode(w, s);\n+    }\n+}\n+\n+impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n+    for (A, B)\n+{\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum Bound<T> {\n+        Included(x),\n+        Excluded(x),\n+        Unbounded,\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Option<T> {\n+        None,\n+        Some(x),\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Result<T, E> {\n+        Ok(x),\n+        Err(e),\n+    }\n+);\n+\n+impl<S> Encode<S> for &[u8] {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.len().encode(w, s);\n+        w.write_all(self).unwrap();\n+    }\n+}\n+\n+impl<'a, S> DecodeMut<'a, '_, S> for &'a [u8] {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        let len = usize::decode(r, s);\n+        let xs = &r[..len];\n+        *r = &r[len..];\n+        xs\n+    }\n+}\n+\n+impl<S> Encode<S> for &str {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_bytes().encode(w, s);\n+    }\n+}\n+\n+impl<'a, S> DecodeMut<'a, '_, S> for &'a str {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for String {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self[..].encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for String {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        <&str>::decode(r, s).to_string()\n+    }\n+}\n+\n+/// Simplied version of panic payloads, ignoring\n+/// types other than `&'static str` and `String`.\n+#[derive(Debug)]\n+pub enum PanicMessage {\n+    StaticStr(&'static str),\n+    String(String),\n+    Unknown,\n+}\n+\n+impl From<Box<dyn Any + Send>> for PanicMessage {\n+    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n+        if let Some(s) = payload.downcast_ref::<&'static str>() {\n+            return PanicMessage::StaticStr(s);\n+        }\n+        if let Ok(s) = payload.downcast::<String>() {\n+            return PanicMessage::String(*s);\n+        }\n+        PanicMessage::Unknown\n+    }\n+}\n+\n+impl Into<Box<dyn Any + Send>> for PanicMessage {\n+    fn into(self) -> Box<dyn Any + Send> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Box::new(s),\n+            PanicMessage::String(s) => Box::new(s),\n+            PanicMessage::Unknown => {\n+                struct UnknownPanicMessage;\n+                Box::new(UnknownPanicMessage)\n+            }\n+        }\n+    }\n+}\n+\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<&str> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Some(s),\n+            PanicMessage::String(s) => Some(s),\n+            PanicMessage::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for PanicMessage {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_str().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        match Option::<String>::decode(r, s) {\n+            Some(s) => PanicMessage::String(s),\n+            None => PanicMessage::Unknown,\n+        }\n+    }\n+}"}, {"sha": "6ef7ea43c856dd62480f89f94b991f73bd123f65", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/scoped_cell.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,84 @@\n+//! lib-proc-macro `Cell` variant for (scoped) existential lifetimes.\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/scoped_cell.rs#L1\n+//! augmented with removing unstable features\n+\n+use std::cell::Cell;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+\n+/// Type lambda application, with a lifetime.\n+#[allow(unused_lifetimes)]\n+pub trait ApplyL<'a> {\n+    type Out;\n+}\n+\n+/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n+pub trait LambdaL: for<'a> ApplyL<'a> {}\n+\n+impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n+\n+// HACK(eddyb) work around projection limitations with a newtype\n+// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n+pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n+\n+impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n+    type Target = <T as ApplyL<'b>>::Out;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+\n+impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.0\n+    }\n+}\n+\n+pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n+\n+impl<T: LambdaL> ScopedCell<T> {\n+    pub fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n+        ScopedCell(Cell::new(value))\n+    }\n+\n+    /// Sets the value in `self` to `replacement` while\n+    /// running `f`, which gets the old value, mutably.\n+    /// The old value will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    pub fn replace<'a, R>(\n+        &self,\n+        replacement: <T as ApplyL<'a>>::Out,\n+        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n+    ) -> R {\n+        /// Wrapper that ensures that the cell always gets filled\n+        /// (with the original state, optionally changed by `f`),\n+        /// even if `f` had panicked.\n+        struct PutBackOnDrop<'a, T: LambdaL> {\n+            cell: &'a ScopedCell<T>,\n+            value: Option<<T as ApplyL<'static>>::Out>,\n+        }\n+\n+        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n+            fn drop(&mut self) {\n+                self.cell.0.set(self.value.take().unwrap());\n+            }\n+        }\n+\n+        let mut put_back_on_drop = PutBackOnDrop {\n+            cell: self,\n+            value: Some(self.0.replace(unsafe {\n+                let erased = mem::transmute_copy(&replacement);\n+                mem::forget(replacement);\n+                erased\n+            })),\n+        };\n+\n+        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n+    }\n+\n+    /// Sets the value in `self` to `value` while running `f`.\n+    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n+        self.replace(value, |_| f())\n+    }\n+}"}, {"sha": "45d41ac02b805ac346cc0fff39b8c43572cfb66d", "filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/server.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,323 @@\n+//! lib-proc-macro server-side traits\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/bridge/server.rs\n+//! augmented with removing unstable features\n+\n+use super::*;\n+\n+// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+use super::client::HandleStore;\n+\n+/// Declare an associated item of one of the traits below, optionally\n+/// adjusting it (i.e., adding bounds to types and default bodies to methods).\n+macro_rules! associated_item {\n+    (type TokenStream) =>\n+        (type TokenStream: 'static + Clone;);\n+    (type TokenStreamBuilder) =>\n+        (type TokenStreamBuilder: 'static;);\n+    (type TokenStreamIter) =>\n+        (type TokenStreamIter: 'static + Clone;);\n+    (type Group) =>\n+        (type Group: 'static + Clone;);\n+    (type Punct) =>\n+        (type Punct: 'static + Copy + Eq + Hash;);\n+    (type Ident) =>\n+        (type Ident: 'static + Copy + Eq + Hash;);\n+    (type Literal) =>\n+        (type Literal: 'static + Clone;);\n+    (type SourceFile) =>\n+        (type SourceFile: 'static + Clone;);\n+    (type MultiSpan) =>\n+        (type MultiSpan: 'static;);\n+    (type Diagnostic) =>\n+        (type Diagnostic: 'static;);\n+    (type Span) =>\n+        (type Span: 'static + Copy + Eq + Hash;);\n+    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n+        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n+    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n+        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n+    ($($item:tt)*) => ($($item)*;)\n+}\n+\n+macro_rules! declare_server_traits {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        pub trait Types {\n+            $(associated_item!(type $name);)*\n+        }\n+\n+        $(pub trait $name: Types {\n+            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+        })*\n+\n+        pub trait Server: Types $(+ $name)* {}\n+        impl<S: Types $(+ $name)*> Server for S {}\n+    }\n+}\n+with_api!(Self, self_, declare_server_traits);\n+\n+pub(super) struct MarkedTypes<S: Types>(S);\n+\n+macro_rules! define_mark_types_impls {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        impl<S: Types> Types for MarkedTypes<S> {\n+            $(type $name = Marked<S::$name, client::$name>;)*\n+        }\n+\n+        $(impl<S: $name> $name for MarkedTypes<S> {\n+            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n+                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n+            })*\n+        })*\n+    }\n+}\n+with_api!(Self, self_, define_mark_types_impls);\n+\n+struct Dispatcher<S: Types> {\n+    handle_store: HandleStore<S>,\n+    server: S,\n+}\n+\n+macro_rules! define_dispatcher_impl {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n+        pub trait DispatcherTrait {\n+            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n+            $(type $name;)*\n+            fn dispatch(&mut self, b: Buffer<u8>) -> Buffer<u8>;\n+        }\n+\n+        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n+            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n+            fn dispatch(&mut self, mut b: Buffer<u8>) -> Buffer<u8> {\n+                let Dispatcher { handle_store, server } = self;\n+\n+                let mut reader = &b[..];\n+                match api_tags::Method::decode(&mut reader, &mut ()) {\n+                    $(api_tags::Method::$name(m) => match m {\n+                        $(api_tags::$name::$method => {\n+                            let mut call_method = || {\n+                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n+                                $name::$method(server, $($arg),*)\n+                            };\n+                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n+                            // If client and server happen to use the same `libstd`,\n+                            // `catch_unwind` asserts that the panic counter was 0,\n+                            // even when the closure passed to it didn't panic.\n+                            let r = if thread::panicking() {\n+                                Ok(call_method())\n+                            } else {\n+                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n+                                    .map_err(PanicMessage::from)\n+                            };\n+\n+                            b.clear();\n+                            r.encode(&mut b, handle_store);\n+                        })*\n+                    }),*\n+                }\n+                b\n+            }\n+        }\n+    }\n+}\n+with_api!(Self, self_, define_dispatcher_impl);\n+\n+pub trait ExecutionStrategy {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8>;\n+}\n+\n+pub struct SameThread;\n+\n+impl ExecutionStrategy for SameThread {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        let mut dispatch = |b| dispatcher.dispatch(b);\n+\n+        run_client(Bridge { cached_buffer: input, dispatch: (&mut dispatch).into() }, client_data)\n+    }\n+}\n+\n+// NOTE(eddyb) Two implementations are provided, the second one is a bit\n+// faster but neither is anywhere near as fast as same-thread execution.\n+\n+pub struct CrossThread1;\n+\n+impl ExecutionStrategy for CrossThread1 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        use std::sync::mpsc::channel;\n+\n+        let (req_tx, req_rx) = channel();\n+        let (res_tx, res_rx) = channel();\n+\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                req_tx.send(b).unwrap();\n+                res_rx.recv().unwrap()\n+            };\n+\n+            run_client(\n+                Bridge { cached_buffer: input, dispatch: (&mut dispatch).into() },\n+                client_data,\n+            )\n+        });\n+\n+        for b in req_rx {\n+            res_tx.send(dispatcher.dispatch(b)).unwrap();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+pub struct CrossThread2;\n+\n+impl ExecutionStrategy for CrossThread2 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+    ) -> Buffer<u8> {\n+        use std::sync::{Arc, Mutex};\n+\n+        enum State<T> {\n+            Req(T),\n+            Res(T),\n+        }\n+\n+        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n+\n+        let server_thread = thread::current();\n+        let state2 = state.clone();\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                *state2.lock().unwrap() = State::Req(b);\n+                server_thread.unpark();\n+                loop {\n+                    thread::park();\n+                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n+                        break b.take();\n+                    }\n+                }\n+            };\n+\n+            let r = run_client(\n+                Bridge { cached_buffer: input, dispatch: (&mut dispatch).into() },\n+                client_data,\n+            );\n+\n+            // Wake up the server so it can exit the dispatch loop.\n+            drop(state2);\n+            server_thread.unpark();\n+\n+            r\n+        });\n+\n+        // Check whether `state2` was dropped, to know when to stop.\n+        while Arc::get_mut(&mut state).is_none() {\n+            thread::park();\n+            let mut b = match &mut *state.lock().unwrap() {\n+                State::Req(b) => b.take(),\n+                _ => continue,\n+            };\n+            b = dispatcher.dispatch(b.take());\n+            *state.lock().unwrap() = State::Res(b);\n+            join_handle.thread().unpark();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+fn run_server<\n+    S: Server,\n+    I: Encode<HandleStore<MarkedTypes<S>>>,\n+    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n+    D: Copy + Send + 'static,\n+>(\n+    strategy: &impl ExecutionStrategy,\n+    handle_counters: &'static client::HandleCounters,\n+    server: S,\n+    input: I,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+    client_data: D,\n+) -> Result<O, PanicMessage> {\n+    let mut dispatcher =\n+        Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n+\n+    let mut b = Buffer::new();\n+    input.encode(&mut b, &mut dispatcher.handle_store);\n+\n+    b = strategy.run_bridge_and_client(&mut dispatcher, b, run_client, client_data);\n+\n+    Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n+}\n+\n+impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client { get_handle_counters, run, f } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+            run,\n+            f,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}\n+\n+impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+        input2: S::TokenStream,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client { get_handle_counters, run, f } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            (\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n+            ),\n+            run,\n+            f,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}"}, {"sha": "9029f88157979ad68e688c962b1fb8e39f43d5bc", "filename": "crates/ra_proc_macro_srv/src/proc_macro/diagnostic.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fdiagnostic.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,170 @@\n+//! lib-proc-macro diagnostic\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/diagnostic.rs\n+//! augmented with removing unstable features\n+\n+use crate::proc_macro::Span;\n+\n+/// An enum representing a diagnostic level.\n+#[derive(Copy, Clone, Debug)]\n+#[non_exhaustive]\n+pub enum Level {\n+    /// An error.\n+    Error,\n+    /// A warning.\n+    Warning,\n+    /// A note.\n+    Note,\n+    /// A help message.\n+    Help,\n+}\n+\n+/// Trait implemented by types that can be converted into a set of `Span`s.\n+pub trait MultiSpan {\n+    /// Converts `self` into a `Vec<Span>`.\n+    fn into_spans(self) -> Vec<Span>;\n+}\n+\n+impl MultiSpan for Span {\n+    fn into_spans(self) -> Vec<Span> {\n+        vec![self]\n+    }\n+}\n+\n+impl MultiSpan for Vec<Span> {\n+    fn into_spans(self) -> Vec<Span> {\n+        self\n+    }\n+}\n+\n+impl<'a> MultiSpan for &'a [Span] {\n+    fn into_spans(self) -> Vec<Span> {\n+        self.to_vec()\n+    }\n+}\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    spans: Vec<Span>,\n+    children: Vec<Diagnostic>,\n+}\n+\n+macro_rules! diagnostic_child_methods {\n+    ($spanned:ident, $regular:ident, $level:expr) => (\n+        /// Adds a new child diagnostic message to `self` with the level\n+        /// identified by this method's name with the given `spans` and\n+        /// `message`.\n+        pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n+            where S: MultiSpan, T: Into<String>\n+        {\n+            self.children.push(Diagnostic::spanned(spans, $level, message));\n+            self\n+        }\n+\n+        /// Adds a new child diagnostic message to `self` with the level\n+        /// identified by this method's name with the given `message`.\n+        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n+            self.children.push(Diagnostic::new($level, message));\n+            self\n+        }\n+    )\n+}\n+\n+/// Iterator over the children diagnostics of a `Diagnostic`.\n+#[derive(Debug, Clone)]\n+pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n+\n+impl<'a> Iterator for Children<'a> {\n+    type Item = &'a Diagnostic;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+impl Diagnostic {\n+    /// Creates a new diagnostic with the given `level` and `message`.\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic { level: level, message: message.into(), spans: vec![], children: vec![] }\n+    }\n+\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n+    /// the given set of `spans`.\n+    pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n+    where\n+        S: MultiSpan,\n+        T: Into<String>,\n+    {\n+        Diagnostic {\n+            level: level,\n+            message: message.into(),\n+            spans: spans.into_spans(),\n+            children: vec![],\n+        }\n+    }\n+\n+    diagnostic_child_methods!(span_error, error, Level::Error);\n+    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n+    diagnostic_child_methods!(span_note, note, Level::Note);\n+    diagnostic_child_methods!(span_help, help, Level::Help);\n+\n+    /// Returns the diagnostic `level` for `self`.\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Sets the level in `self` to `level`.\n+    pub fn set_level(&mut self, level: Level) {\n+        self.level = level;\n+    }\n+\n+    /// Returns the message in `self`.\n+    pub fn message(&self) -> &str {\n+        &self.message\n+    }\n+\n+    /// Sets the message in `self` to `message`.\n+    pub fn set_message<T: Into<String>>(&mut self, message: T) {\n+        self.message = message.into();\n+    }\n+\n+    /// Returns the `Span`s in `self`.\n+    pub fn spans(&self) -> &[Span] {\n+        &self.spans\n+    }\n+\n+    /// Sets the `Span`s in `self` to `spans`.\n+    pub fn set_spans<S: MultiSpan>(&mut self, spans: S) {\n+        self.spans = spans.into_spans();\n+    }\n+\n+    /// Returns an iterator over the children diagnostics of `self`.\n+    pub fn children(&self) -> Children<'_> {\n+        Children(self.children.iter())\n+    }\n+\n+    /// Emit the diagnostic.\n+    pub fn emit(self) {\n+        fn to_internal(spans: Vec<Span>) -> crate::proc_macro::bridge::client::MultiSpan {\n+            let mut multi_span = crate::proc_macro::bridge::client::MultiSpan::new();\n+            for span in spans {\n+                multi_span.push(span.0);\n+            }\n+            multi_span\n+        }\n+\n+        let mut diag = crate::proc_macro::bridge::client::Diagnostic::new(\n+            self.level,\n+            &self.message[..],\n+            to_internal(self.spans),\n+        );\n+        for c in self.children {\n+            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n+        }\n+        diag.emit();\n+    }\n+}"}, {"sha": "e35a6ff8bec8597fd8147b0e40d4e9f66a04f1d5", "filename": "crates/ra_proc_macro_srv/src/proc_macro/mod.rs", "status": "added", "additions": 926, "deletions": 0, "changes": 926, "blob_url": "https://github.com/rust-lang/rust/blob/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d688d13070a54b288486900a30680d013c66ca/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fproc_macro%2Fmod.rs?ref=f6d688d13070a54b288486900a30680d013c66ca", "patch": "@@ -0,0 +1,926 @@\n+//! lib-proc-macro main module\n+//!\n+//! Copy from https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/lib.rs\n+//! augmented with removing unstable features\n+\n+// NOTE(@edwin0cheng):\n+// Because we just copy the bridge module from rustc for ABI compatible\n+// There are some unused stuffs inside it.\n+// We suppress these warning here.\n+#[doc(hidden)]\n+#[allow(unused_macros)]\n+#[allow(unused_variables)]\n+pub mod bridge;\n+\n+mod diagnostic;\n+\n+pub use diagnostic::{Diagnostic, Level, MultiSpan};\n+\n+use std::ops::{Bound, RangeBounds};\n+use std::path::PathBuf;\n+use std::str::FromStr;\n+use std::{fmt, iter, mem};\n+\n+/// The main type provided by this crate, representing an abstract stream of\n+/// tokens, or, more specifically, a sequence of token trees.\n+/// The type provide interfaces for iterating over those token trees and, conversely,\n+/// collecting a number of token trees into one stream.\n+///\n+/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n+/// and `#[proc_macro_derive]` definitions.\n+#[derive(Clone)]\n+pub struct TokenStream(bridge::client::TokenStream);\n+\n+/// Error returned from `TokenStream::from_str`\n+#[derive(Debug)]\n+pub struct LexError {\n+    _inner: (),\n+}\n+\n+impl TokenStream {\n+    /// Returns an empty `TokenStream` containing no token trees.\n+    pub fn new() -> TokenStream {\n+        TokenStream(bridge::client::TokenStream::new())\n+    }\n+\n+    /// Checks if this `TokenStream` is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n+/// Attempts to break the string into tokens and parse those tokens into a token stream.\n+/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+/// or characters not existing in the language.\n+/// All tokens in the parsed stream get `Span::call_site()` spans.\n+///\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// change these errors into `LexError`s later.\n+impl FromStr for TokenStream {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+        Ok(TokenStream(bridge::client::TokenStream::from_str(src)))\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for TokenStream {\n+//     fn to_string(&self) -> String {\n+//         self.0.to_string()\n+//     }\n+// }\n+\n+/// Prints the token stream as a string that is supposed to be losslessly convertible back\n+/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+/// Prints token in a form convenient for debugging.\n+impl fmt::Debug for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"TokenStream \")?;\n+        f.debug_list().entries(self.clone()).finish()\n+    }\n+}\n+\n+/// Creates a token stream containing a single token tree.\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream(bridge::client::TokenStream::from_token_tree(match tree {\n+            TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n+            TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n+            TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n+            TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n+        }))\n+    }\n+}\n+\n+/// Collects a number of token trees into a single stream.\n+impl iter::FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n+        trees.into_iter().map(TokenStream::from).collect()\n+    }\n+}\n+\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+impl iter::FromIterator<TokenStream> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n+        let mut builder = bridge::client::TokenStreamBuilder::new();\n+        streams.into_iter().for_each(|stream| builder.push(stream.0));\n+        TokenStream(builder.build())\n+    }\n+}\n+\n+impl Extend<TokenTree> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n+        self.extend(trees.into_iter().map(TokenStream::from));\n+    }\n+}\n+\n+impl Extend<TokenStream> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n+        // FIXME(eddyb) Use an optimized implementation if/when possible.\n+        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n+    }\n+}\n+\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n+pub mod token_stream {\n+    use crate::proc_macro::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n+\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n+    #[derive(Clone)]\n+    pub struct IntoIter(bridge::client::TokenStreamIter);\n+\n+    impl Iterator for IntoIter {\n+        type Item = TokenTree;\n+\n+        fn next(&mut self) -> Option<TokenTree> {\n+            self.0.next().map(|tree| match tree {\n+                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n+                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n+                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n+                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n+            })\n+        }\n+    }\n+\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = IntoIter;\n+\n+        fn into_iter(self) -> IntoIter {\n+            IntoIter(self.0.into_iter())\n+        }\n+    }\n+}\n+\n+/// A region of source code, along with macro expansion information.\n+#[derive(Copy, Clone)]\n+pub struct Span(bridge::client::Span);\n+\n+macro_rules! diagnostic_method {\n+    ($name:ident, $level:expr) => (\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n+        /// `self`.\n+        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n+            Diagnostic::spanned(self, $level, message)\n+        }\n+    )\n+}\n+\n+impl Span {\n+    /// A span that resolves at the macro definition site.\n+    pub fn def_site() -> Span {\n+        Span(bridge::client::Span::def_site())\n+    }\n+\n+    /// The span of the invocation of the current procedural macro.\n+    /// Identifiers created with this span will be resolved as if they were written\n+    /// directly at the macro call location (call-site hygiene) and other code\n+    /// at the macro call site will be able to refer to them as well.\n+    pub fn call_site() -> Span {\n+        Span(bridge::client::Span::call_site())\n+    }\n+\n+    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n+    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n+    /// call site (everything else).\n+    /// The span location is taken from the call-site.\n+    pub fn mixed_site() -> Span {\n+        Span(bridge::client::Span::mixed_site())\n+    }\n+\n+    /// The original source file into which this span points.\n+    pub fn source_file(&self) -> SourceFile {\n+        SourceFile(self.0.source_file())\n+    }\n+\n+    /// The `Span` for the tokens in the previous macro expansion from which\n+    /// `self` was generated from, if any.\n+    pub fn parent(&self) -> Option<Span> {\n+        self.0.parent().map(Span)\n+    }\n+\n+    /// The span for the origin source code that `self` was generated from. If\n+    /// this `Span` wasn't generated from other macro expansions then the return\n+    /// value is the same as `*self`.\n+    pub fn source(&self) -> Span {\n+        Span(self.0.source())\n+    }\n+\n+    /// Gets the starting line/column in the source file for this span.\n+    pub fn start(&self) -> LineColumn {\n+        self.0.start()\n+    }\n+\n+    /// Gets the ending line/column in the source file for this span.\n+    pub fn end(&self) -> LineColumn {\n+        self.0.end()\n+    }\n+\n+    /// Creates a new span encompassing `self` and `other`.\n+    ///\n+    /// Returns `None` if `self` and `other` are from different files.\n+    pub fn join(&self, other: Span) -> Option<Span> {\n+        self.0.join(other.0).map(Span)\n+    }\n+\n+    /// Creates a new span with the same line/column information as `self` but\n+    /// that resolves symbols as though it were at `other`.\n+    pub fn resolved_at(&self, other: Span) -> Span {\n+        Span(self.0.resolved_at(other.0))\n+    }\n+\n+    /// Creates a new span with the same name resolution behavior as `self` but\n+    /// with the line/column information of `other`.\n+    pub fn located_at(&self, other: Span) -> Span {\n+        other.resolved_at(*self)\n+    }\n+\n+    /// Compares to spans to see if they're equal.\n+    pub fn eq(&self, other: &Span) -> bool {\n+        self.0 == other.0\n+    }\n+\n+    /// Returns the source text behind a span. This preserves the original source\n+    /// code, including spaces and comments. It only returns a result if the span\n+    /// corresponds to real source code.\n+    ///\n+    /// Note: The observable result of a macro should only rely on the tokens and\n+    /// not on this source text. The result of this function is a best effort to\n+    /// be used for diagnostics only.\n+    pub fn source_text(&self) -> Option<String> {\n+        self.0.source_text()\n+    }\n+\n+    diagnostic_method!(error, Level::Error);\n+    diagnostic_method!(warning, Level::Warning);\n+    diagnostic_method!(note, Level::Note);\n+    diagnostic_method!(help, Level::Help);\n+}\n+\n+/// Prints a span in a form convenient for debugging.\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+/// A line-column pair representing the start or end of a `Span`.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineColumn {\n+    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n+    pub line: usize,\n+    /// The 0-indexed column (in UTF-8 characters) in the source file on which\n+    /// the span starts or ends (inclusive).\n+    pub column: usize,\n+}\n+\n+/// The source file of a given `Span`.\n+#[derive(Clone)]\n+pub struct SourceFile(bridge::client::SourceFile);\n+\n+impl SourceFile {\n+    /// Gets the path to this source file.\n+    ///\n+    /// ### Note\n+    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n+    /// macro, this may not be an actual path on the filesystem. Use [`is_real`] to check.\n+    ///\n+    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n+    /// the command line, the path as given may not actually be valid.\n+    ///\n+    /// [`is_real`]: #method.is_real\n+    pub fn path(&self) -> PathBuf {\n+        PathBuf::from(self.0.path())\n+    }\n+\n+    /// Returns `true` if this source file is a real source file, and not generated by an external\n+    /// macro's expansion.\n+    pub fn is_real(&self) -> bool {\n+        // This is a hack until intercrate spans are implemented and we can have real source files\n+        // for spans generated in external macros.\n+        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n+        self.0.is_real()\n+    }\n+}\n+\n+impl fmt::Debug for SourceFile {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SourceFile\")\n+            .field(\"path\", &self.path())\n+            .field(\"is_real\", &self.is_real())\n+            .finish()\n+    }\n+}\n+\n+impl PartialEq for SourceFile {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl Eq for SourceFile {}\n+\n+/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n+#[derive(Clone)]\n+pub enum TokenTree {\n+    /// A token stream surrounded by bracket delimiters.\n+    Group(Group),\n+    /// An identifier.\n+    Ident(Ident),\n+    /// A single punctuation character (`+`, `,`, `$`, etc.).\n+    Punct(Punct),\n+    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n+    Literal(Literal),\n+}\n+\n+impl TokenTree {\n+    /// Returns the span of this tree, delegating to the `span` method of\n+    /// the contained token or a delimited stream.\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            TokenTree::Group(ref t) => t.span(),\n+            TokenTree::Ident(ref t) => t.span(),\n+            TokenTree::Punct(ref t) => t.span(),\n+            TokenTree::Literal(ref t) => t.span(),\n+        }\n+    }\n+\n+    /// Configures the span for *only this token*.\n+    ///\n+    /// Note that if this token is a `Group` then this method will not configure\n+    /// the span of each of the internal tokens, this will simply delegate to\n+    /// the `set_span` method of each variant.\n+    pub fn set_span(&mut self, span: Span) {\n+        match *self {\n+            TokenTree::Group(ref mut t) => t.set_span(span),\n+            TokenTree::Ident(ref mut t) => t.set_span(span),\n+            TokenTree::Punct(ref mut t) => t.set_span(span),\n+            TokenTree::Literal(ref mut t) => t.set_span(span),\n+        }\n+    }\n+}\n+\n+/// Prints token tree in a form convenient for debugging.\n+impl fmt::Debug for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Each of these has the name in the struct type in the derived debug,\n+        // so don't bother with an extra layer of indirection\n+        match *self {\n+            TokenTree::Group(ref tt) => tt.fmt(f),\n+            TokenTree::Ident(ref tt) => tt.fmt(f),\n+            TokenTree::Punct(ref tt) => tt.fmt(f),\n+            TokenTree::Literal(ref tt) => tt.fmt(f),\n+        }\n+    }\n+}\n+\n+impl From<Group> for TokenTree {\n+    fn from(g: Group) -> TokenTree {\n+        TokenTree::Group(g)\n+    }\n+}\n+\n+impl From<Ident> for TokenTree {\n+    fn from(g: Ident) -> TokenTree {\n+        TokenTree::Ident(g)\n+    }\n+}\n+\n+impl From<Punct> for TokenTree {\n+    fn from(g: Punct) -> TokenTree {\n+        TokenTree::Punct(g)\n+    }\n+}\n+\n+impl From<Literal> for TokenTree {\n+    fn from(g: Literal) -> TokenTree {\n+        TokenTree::Literal(g)\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for TokenTree {\n+//     fn to_string(&self) -> String {\n+//         match *self {\n+//             TokenTree::Group(ref t) => t.to_string(),\n+//             TokenTree::Ident(ref t) => t.to_string(),\n+//             TokenTree::Punct(ref t) => t.to_string(),\n+//             TokenTree::Literal(ref t) => t.to_string(),\n+//         }\n+//     }\n+// }\n+\n+/// Prints the token tree as a string that is supposed to be losslessly convertible back\n+/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n+impl fmt::Display for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+/// A delimited token stream.\n+///\n+/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n+#[derive(Clone)]\n+pub struct Group(bridge::client::Group);\n+\n+/// Describes how a sequence of token trees is delimited.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Delimiter {\n+    /// `( ... )`\n+    Parenthesis,\n+    /// `{ ... }`\n+    Brace,\n+    /// `[ ... ]`\n+    Bracket,\n+    /// `\u00d8 ... \u00d8`\n+    /// An implicit delimiter, that may, for example, appear around tokens coming from a\n+    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n+    /// `$var * 3` where `$var` is `1 + 2`.\n+    /// Implicit delimiters may not survive roundtrip of a token stream through a string.\n+    None,\n+}\n+\n+impl Group {\n+    /// Creates a new `Group` with the given delimiter and token stream.\n+    ///\n+    /// This constructor will set the span for this group to\n+    /// `Span::call_site()`. To change the span you can use the `set_span`\n+    /// method below.\n+    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n+        Group(bridge::client::Group::new(delimiter, stream.0))\n+    }\n+\n+    /// Returns the delimiter of this `Group`\n+    pub fn delimiter(&self) -> Delimiter {\n+        self.0.delimiter()\n+    }\n+\n+    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n+    ///\n+    /// Note that the returned token stream does not include the delimiter\n+    /// returned above.\n+    pub fn stream(&self) -> TokenStream {\n+        TokenStream(self.0.stream())\n+    }\n+\n+    /// Returns the span for the delimiters of this token stream, spanning the\n+    /// entire `Group`.\n+    ///\n+    /// ```text\n+    /// pub fn span(&self) -> Span {\n+    ///            ^^^^^^^\n+    /// ```\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Returns the span pointing to the opening delimiter of this group.\n+    ///\n+    /// ```text\n+    /// pub fn span_open(&self) -> Span {\n+    ///                 ^\n+    /// ```\n+    pub fn span_open(&self) -> Span {\n+        Span(self.0.span_open())\n+    }\n+\n+    /// Returns the span pointing to the closing delimiter of this group.\n+    ///\n+    /// ```text\n+    /// pub fn span_close(&self) -> Span {\n+    ///                        ^\n+    /// ```\n+    pub fn span_close(&self) -> Span {\n+        Span(self.0.span_close())\n+    }\n+\n+    /// Configures the span for this `Group`'s delimiters, but not its internal\n+    /// tokens.\n+    ///\n+    /// This method will **not** set the span of all the internal tokens spanned\n+    /// by this group, but rather it will only set the span of the delimiter\n+    /// tokens at the level of the `Group`.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0.set_span(span.0);\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for Group {\n+//     fn to_string(&self) -> String {\n+//         TokenStream::from(TokenTree::from(self.clone())).to_string()\n+//     }\n+// }\n+\n+/// Prints the group as a string that should be losslessly convertible back\n+/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n+impl fmt::Display for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Group\")\n+            .field(\"delimiter\", &self.delimiter())\n+            .field(\"stream\", &self.stream())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+/// An `Punct` is an single punctuation character like `+`, `-` or `#`.\n+///\n+/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n+/// forms of `Spacing` returned.\n+#[derive(Clone)]\n+pub struct Punct(bridge::client::Punct);\n+\n+/// Whether an `Punct` is followed immediately by another `Punct` or\n+/// followed by another token or whitespace.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Spacing {\n+    /// e.g., `+` is `Alone` in `+ =`, `+ident` or `+()`.\n+    Alone,\n+    /// e.g., `+` is `Joint` in `+=` or `'#`.\n+    /// Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.\n+    Joint,\n+}\n+\n+impl Punct {\n+    /// Creates a new `Punct` from the given character and spacing.\n+    /// The `ch` argument must be a valid punctuation character permitted by the language,\n+    /// otherwise the function will panic.\n+    ///\n+    /// The returned `Punct` will have the default span of `Span::call_site()`\n+    /// which can be further configured with the `set_span` method below.\n+    pub fn new(ch: char, spacing: Spacing) -> Punct {\n+        Punct(bridge::client::Punct::new(ch, spacing))\n+    }\n+\n+    /// Returns the value of this punctuation character as `char`.\n+    pub fn as_char(&self) -> char {\n+        self.0.as_char()\n+    }\n+\n+    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n+    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n+    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n+    /// (`Alone`) so the operator has certainly ended.\n+    pub fn spacing(&self) -> Spacing {\n+        self.0.spacing()\n+    }\n+\n+    /// Returns the span for this punctuation character.\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configure the span for this punctuation character.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for Punct {\n+//     fn to_string(&self) -> String {\n+//         TokenStream::from(TokenTree::from(self.clone())).to_string()\n+//     }\n+// }\n+\n+/// Prints the punctuation character as a string that should be losslessly convertible\n+/// back into the same character.\n+impl fmt::Display for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Punct\")\n+            .field(\"ch\", &self.as_char())\n+            .field(\"spacing\", &self.spacing())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+/// An identifier (`ident`).\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct Ident(bridge::client::Ident);\n+\n+impl Ident {\n+    /// Creates a new `Ident` with the given `string` as well as the specified\n+    /// `span`.\n+    /// The `string` argument must be a valid identifier permitted by the\n+    /// language, otherwise the function will panic.\n+    ///\n+    /// Note that `span`, currently in rustc, configures the hygiene information\n+    /// for this identifier.\n+    ///\n+    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved as if they were written\n+    /// directly at the location of the macro call, and other code at the macro call site will be\n+    /// able to refer to them as well.\n+    ///\n+    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved at the location of the\n+    /// macro definition and other code at the macro call site will not be able to refer to them.\n+    ///\n+    /// Due to the current importance of hygiene this constructor, unlike other\n+    /// tokens, requires a `Span` to be specified at construction.\n+    pub fn new(string: &str, span: Span) -> Ident {\n+        Ident(bridge::client::Ident::new(string, span.0, false))\n+    }\n+\n+    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n+    pub fn new_raw(string: &str, span: Span) -> Ident {\n+        Ident(bridge::client::Ident::new(string, span.0, true))\n+    }\n+\n+    /// Returns the span of this `Ident`, encompassing the entire string returned\n+    /// by `as_str`.\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for Ident {\n+//     fn to_string(&self) -> String {\n+//         TokenStream::from(TokenTree::from(self.clone())).to_string()\n+//     }\n+// }\n+\n+/// Prints the identifier as a string that should be losslessly convertible\n+/// back into the same identifier.\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Ident\")\n+            .field(\"ident\", &self.to_string())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n+/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n+/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n+/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n+#[derive(Clone)]\n+pub struct Literal(bridge::client::Literal);\n+\n+macro_rules! suffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new suffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1u32` where the integer\n+        /// value specified is the first part of the token and the integral is\n+        /// also suffixed at the end.\n+        /// Literals created from negative numbers may not survive round-trips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n+        pub fn $name(n: $kind) -> Literal {\n+            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n+        }\n+    )*)\n+}\n+\n+macro_rules! unsuffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new unsuffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1` where the integer\n+        /// value specified is the first part of the token. No suffix is\n+        /// specified on this token, meaning that invocations like\n+        /// `Literal::i8_unsuffixed(1)` are equivalent to\n+        /// `Literal::u32_unsuffixed(1)`.\n+        /// Literals created from negative numbers may not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n+        pub fn $name(n: $kind) -> Literal {\n+            Literal(bridge::client::Literal::integer(&n.to_string()))\n+        }\n+    )*)\n+}\n+\n+impl Literal {\n+    suffixed_int_literals! {\n+        u8_suffixed => u8,\n+        u16_suffixed => u16,\n+        u32_suffixed => u32,\n+        u64_suffixed => u64,\n+        u128_suffixed => u128,\n+        usize_suffixed => usize,\n+        i8_suffixed => i8,\n+        i16_suffixed => i16,\n+        i32_suffixed => i32,\n+        i64_suffixed => i64,\n+        i128_suffixed => i128,\n+        isize_suffixed => isize,\n+    }\n+\n+    unsuffixed_int_literals! {\n+        u8_unsuffixed => u8,\n+        u16_unsuffixed => u16,\n+        u32_unsuffixed => u32,\n+        u64_unsuffixed => u64,\n+        u128_unsuffixed => u128,\n+        usize_unsuffixed => usize,\n+        i8_unsuffixed => i8,\n+        i16_unsuffixed => i16,\n+        i32_unsuffixed => i32,\n+        i64_unsuffixed => i64,\n+        i128_unsuffixed => i128,\n+        isize_unsuffixed => isize,\n+    }\n+\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f32_unsuffixed(n: f32) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n+    }\n+\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This constructor will create a literal like `1.0f32` where the value\n+    /// specified is the preceding part of the token and `f32` is the suffix of\n+    /// the token. This token will always be inferred to be an `f32` in the\n+    /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f32_suffixed(n: f32) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::f32(&n.to_string()))\n+    }\n+\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f64_unsuffixed(n: f64) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n+    }\n+\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This constructor will create a literal like `1.0f64` where the value\n+    /// specified is the preceding part of the token and `f64` is the suffix of\n+    /// the token. This token will always be inferred to be an `f64` in the\n+    /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f64_suffixed(n: f64) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::f64(&n.to_string()))\n+    }\n+\n+    /// String literal.\n+    pub fn string(string: &str) -> Literal {\n+        Literal(bridge::client::Literal::string(string))\n+    }\n+\n+    /// Character literal.\n+    pub fn character(ch: char) -> Literal {\n+        Literal(bridge::client::Literal::character(ch))\n+    }\n+\n+    /// Byte string literal.\n+    pub fn byte_string(bytes: &[u8]) -> Literal {\n+        Literal(bridge::client::Literal::byte_string(bytes))\n+    }\n+\n+    /// Returns the span encompassing this literal.\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configures the span associated for this literal.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0.set_span(span.0);\n+    }\n+\n+    /// Returns a `Span` that is a subset of `self.span()` containing only the\n+    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n+    /// span is outside the bounds of `self`.\n+    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n+    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n+    // occur elsewhere when the source text is printed.\n+    // FIXME(SergioBenitez): there is no way for the user to know what\n+    // `self.span()` actually maps to, so this method can currently only be\n+    // called blindly. For example, `to_string()` for the character 'c' returns\n+    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n+    // was 'c' or whether it was '\\u{63}'.\n+    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n+        // HACK(eddyb) something akin to `Option::cloned`, but for `Bound<&T>`.\n+        fn cloned_bound<T: Clone>(bound: Bound<&T>) -> Bound<T> {\n+            match bound {\n+                Bound::Included(x) => Bound::Included(x.clone()),\n+                Bound::Excluded(x) => Bound::Excluded(x.clone()),\n+                Bound::Unbounded => Bound::Unbounded,\n+            }\n+        }\n+\n+        self.0.subspan(cloned_bound(range.start_bound()), cloned_bound(range.end_bound())).map(Span)\n+    }\n+}\n+\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n+// based on it (the reverse of the usual relationship between the two).\n+// impl ToString for Literal {\n+//     fn to_string(&self) -> String {\n+//         TokenStream::from(TokenTree::from(self.clone())).to_string()\n+//     }\n+// }\n+\n+/// Prints the literal as a string that should be losslessly convertible\n+/// back into the same literal (except for possible rounding for floating point literals).\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n+        self.0.fmt(f)\n+    }\n+}"}]}