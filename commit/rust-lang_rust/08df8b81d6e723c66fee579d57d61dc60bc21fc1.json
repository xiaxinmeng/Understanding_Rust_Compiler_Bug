{"sha": "08df8b81d6e723c66fee579d57d61dc60bc21fc1", "node_id": "C_kwDOAAsO6NoAKDA4ZGY4YjgxZDZlNzIzYzY2ZmVlNTc5ZDU3ZDYxZGM2MGJjMjFmYzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-30T20:57:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-30T20:57:34Z"}, "message": "Auto merge of #92711 - zredb:issue-90187-fix, r=notriddle\n\nrustdoc: Remove `def_id_no_primitives`\n\nFixes #90187.", "tree": {"sha": "bf52bf2194e2caf2a8049d1526956b743001acaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf52bf2194e2caf2a8049d1526956b743001acaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08df8b81d6e723c66fee579d57d61dc60bc21fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08df8b81d6e723c66fee579d57d61dc60bc21fc1", "html_url": "https://github.com/rust-lang/rust/commit/08df8b81d6e723c66fee579d57d61dc60bc21fc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08df8b81d6e723c66fee579d57d61dc60bc21fc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7f2bf44f7fafaa4546814e54add786429e5f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7f2bf44f7fafaa4546814e54add786429e5f76", "html_url": "https://github.com/rust-lang/rust/commit/8c7f2bf44f7fafaa4546814e54add786429e5f76"}, {"sha": "5cc32e7158b582324f7c7697f845b1c0cb5bbe44", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc32e7158b582324f7c7697f845b1c0cb5bbe44", "html_url": "https://github.com/rust-lang/rust/commit/5cc32e7158b582324f7c7697f845b1c0cb5bbe44"}], "stats": {"total": 100, "additions": 51, "deletions": 49}, "files": [{"sha": "02633698273608e52684b8ef846f01f939e36c2a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -338,6 +338,7 @@ impl ExternalCrate {\n }\n \n /// Indicates where an external crate can be found.\n+#[derive(Debug)]\n crate enum ExternalLocation {\n     /// Remote URL root of the external crate\n     Remote(String),\n@@ -1539,23 +1540,10 @@ impl Type {\n \n     /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n     ///\n-    /// See [`Self::def_id_no_primitives`] for more.\n-    ///\n     /// [clean]: crate::clean\n     crate fn def_id(&self, cache: &Cache) -> Option<DefId> {\n         self.inner_def_id(Some(cache))\n     }\n-\n-    /// Use this method to get the [`DefId`] of a [`clean`] AST node.\n-    /// This will return [`None`] when called on a primitive [`clean::Type`].\n-    /// Use [`Self::def_id`] if you want to include primitives.\n-    ///\n-    /// [`clean`]: crate::clean\n-    /// [`clean::Type`]: crate::clean::Type\n-    // FIXME: get rid of this function and always use `def_id`\n-    crate fn def_id_no_primitives(&self) -> Option<DefId> {\n-        self.inner_def_id(None)\n-    }\n }\n \n /// A primitive (aka, builtin) type."}, {"sha": "53159709586c6826987c39284ba1d4756ed43cc1", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_function_type_for_search(&item, self.tcx),\n+                            search_type: get_function_type_for_search(&item, self.tcx, self.cache),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }"}, {"sha": "0ee67467c383beb9ff7c9cb7f152bdae2f7e02d9", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -3,7 +3,7 @@ use std::collections::BTreeMap;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, Symbol};\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n@@ -33,7 +33,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_function_type_for_search(item, tcx),\n+                search_type: get_function_type_for_search(item, tcx, &cache),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -188,11 +188,12 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n crate fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n+    cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx),\n-        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx),\n-        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx),\n+        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, cache),\n+        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, cache),\n+        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx, cache),\n         _ => return None,\n     };\n \n@@ -219,7 +220,8 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n             let path = &bounds[0].trait_;\n             Some(path.segments.last().unwrap().name)\n         }\n-        clean::Generic(s) => Some(s),\n+        // We return an empty name because we don't care about the generic name itself.\n+        clean::Generic(_) => Some(kw::Empty),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n         clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n         clean::BareFunction(_)\n@@ -240,24 +242,27 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n ///\n /// Important note: It goes through generics recursively. So if you have\n /// `T: Option<Result<(), ()>>`, it'll go into `Option` and then into `Result`.\n-#[instrument(level = \"trace\", skip(tcx, res))]\n+#[instrument(level = \"trace\", skip(tcx, res, cache))]\n fn add_generics_and_bounds_as_types<'tcx>(\n     generics: &Generics,\n     arg: &Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n+    cache: &Cache,\n ) {\n     fn insert_ty(\n         res: &mut Vec<TypeWithKind>,\n         tcx: TyCtxt<'_>,\n         ty: Type,\n         mut generics: Vec<TypeWithKind>,\n+        cache: &Cache,\n     ) {\n         let is_full_generic = ty.is_full_generic();\n+        let generics_empty = generics.is_empty();\n \n         if is_full_generic {\n-            if generics.is_empty() {\n+            if generics_empty {\n                 // This is a type parameter with no trait bounds (for example: `T` in\n                 // `fn f<T>(p: T)`, so not useful for the rustdoc search because we would end up\n                 // with an empty type with an empty name. Let's just discard it.\n@@ -304,14 +309,14 @@ fn add_generics_and_bounds_as_types<'tcx>(\n             }\n         }\n         let mut index_ty = get_index_type(&ty, generics);\n-        if index_ty.name.as_ref().map(|s| s.is_empty()).unwrap_or(true) {\n+        if index_ty.name.as_ref().map(|s| s.is_empty() && generics_empty).unwrap_or(true) {\n             return;\n         }\n         if is_full_generic {\n             // We remove the name of the full generic because we have no use for it.\n             index_ty.name = Some(String::new());\n             res.push(TypeWithKind::from((index_ty, ItemType::Generic)));\n-        } else if let Some(kind) = ty.def_id_no_primitives().map(|did| tcx.def_kind(did).into()) {\n+        } else if let Some(kind) = ty.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n             res.push(TypeWithKind::from((index_ty, kind)));\n         } else if ty.is_primitive() {\n             // This is a primitive, let's store it as such.\n@@ -330,9 +335,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n     if let Type::Generic(arg_s) = *arg {\n         // First we check if the bounds are in a `where` predicate...\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => {\n-                ty.def_id_no_primitives() == arg.def_id_no_primitives()\n-            }\n+            WherePredicate::BoundPredicate { ty, .. } => ty.def_id(cache) == arg.def_id(cache),\n             _ => false,\n         }) {\n             let mut ty_generics = Vec::new();\n@@ -348,14 +351,15 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                                     tcx,\n                                     recurse + 1,\n                                     &mut ty_generics,\n+                                    cache,\n                                 )\n                             }\n                             _ => {}\n                         }\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics);\n+            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n         }\n         // Otherwise we check if the trait bounds are \"inlined\" like `T: Option<u32>`...\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n@@ -369,10 +373,11 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                         tcx,\n                         recurse + 1,\n                         &mut ty_generics,\n+                        cache,\n                     );\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics);\n+            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n         }\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n@@ -383,10 +388,17 @@ fn add_generics_and_bounds_as_types<'tcx>(\n         let mut ty_generics = Vec::new();\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n-                add_generics_and_bounds_as_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n+                add_generics_and_bounds_as_types(\n+                    generics,\n+                    gen,\n+                    tcx,\n+                    recurse + 1,\n+                    &mut ty_generics,\n+                    cache,\n+                );\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics);\n+        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n     }\n }\n \n@@ -397,6 +409,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n fn get_fn_inputs_and_outputs<'tcx>(\n     func: &Function,\n     tcx: TyCtxt<'tcx>,\n+    cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n     let decl = &func.decl;\n     let generics = &func.generics;\n@@ -407,12 +420,11 @@ fn get_fn_inputs_and_outputs<'tcx>(\n             continue;\n         }\n         let mut args = Vec::new();\n-        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args);\n+        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) = arg.type_.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n-            {\n+            if let Some(kind) = arg.type_.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                 all_types.push(TypeWithKind::from((get_index_type(&arg.type_, vec![]), kind)));\n             }\n         }\n@@ -421,11 +433,9 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types);\n+            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n             if ret_types.is_empty() {\n-                if let Some(kind) =\n-                    return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n-                {\n+                if let Some(kind) = return_type.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                     ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));\n                 }\n             }"}, {"sha": "53280b3df138b39a03724cd22fd00fe63938d411", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -4,6 +4,7 @@\n use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n+use crate::formats::cache::Cache;\n use crate::visit::DocVisitor;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -57,14 +58,14 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     });\n \n-    let mut cleaner = BadImplStripper { prims, items: crate_items };\n+    let mut cleaner = BadImplStripper { prims, items: crate_items, cache: &cx.cache };\n     let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n \n     // Follow all `Deref` targets of included items and recursively add them as valid\n     fn add_deref_target(\n         cx: &DocContext<'_>,\n         map: &FxHashMap<DefId, &Type>,\n-        cleaner: &mut BadImplStripper,\n+        cleaner: &mut BadImplStripper<'_>,\n         type_did: DefId,\n     ) {\n         if let Some(target) = map.get(&type_did) {\n@@ -102,7 +103,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n-                if let Some(for_did) = for_.def_id_no_primitives() {\n+                if let Some(for_did) = for_.def_id(&cx.cache) {\n                     if type_did_to_deref_target.insert(for_did, target).is_none() {\n                         // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n                         // `Deref` target type and the impl for type positions, this map of types is keyed by\n@@ -204,19 +205,20 @@ impl DocVisitor for ItemCollector {\n     }\n }\n \n-struct BadImplStripper {\n+struct BadImplStripper<'a> {\n     prims: FxHashSet<PrimitiveType>,\n     items: FxHashSet<ItemId>,\n+    cache: &'a Cache,\n }\n \n-impl BadImplStripper {\n+impl<'a> BadImplStripper<'a> {\n     fn keep_impl(&self, ty: &Type, is_deref: bool) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n-        } else if let Some(did) = ty.def_id_no_primitives() {\n+        } else if let Some(did) = ty.def_id(self.cache) {\n             is_deref || self.keep_impl_with_def_id(did.into())\n         } else {\n             false"}, {"sha": "e7a99ee7bfd840fb24f724150c13d6b6a405dd93", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -15,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = ItemIdSet::default();\n \n     // strip all #[doc(hidden)] items\n@@ -25,7 +25,7 @@ crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Cra\n     };\n \n     // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained };\n+    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n     stripper.fold_crate(krate)\n }\n "}, {"sha": "ef7e768a5114922abbd178e9560d9ec919341c33", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -29,6 +29,6 @@ crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n     }\n \n     // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained };\n+    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n     stripper.fold_crate(krate)\n }"}, {"sha": "717dc078b343cf3fd46176df79c8b54d74de2c74", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08df8b81d6e723c66fee579d57d61dc60bc21fc1/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=08df8b81d6e723c66fee579d57d61dc60bc21fc1", "patch": "@@ -5,6 +5,7 @@ use std::mem;\n \n use crate::clean::{self, Item, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n+use crate::formats::cache::Cache;\n \n crate struct Stripper<'a> {\n     crate retained: &'a mut ItemIdSet,\n@@ -118,6 +119,7 @@ impl<'a> DocFolder for Stripper<'a> {\n /// This stripper discards all impls which reference stripped items\n crate struct ImplStripper<'a> {\n     crate retained: &'a ItemIdSet,\n+    crate cache: &'a Cache,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -127,7 +129,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n             }\n-            if let Some(did) = imp.for_.def_id_no_primitives() {\n+            if let Some(did) = imp.for_.def_id(self.cache) {\n                 if did.is_local() && !imp.for_.is_assoc_ty() && !self.retained.contains(&did.into())\n                 {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n@@ -142,7 +144,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id_no_primitives() {\n+                    if let Some(did) = typaram.def_id(self.cache) {\n                         if did.is_local() && !self.retained.contains(&did.into()) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\""}]}