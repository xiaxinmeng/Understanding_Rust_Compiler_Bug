{"sha": "a151d37401b20d235eac1d862579dbbaa4ccea13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNTFkMzc0MDFiMjBkMjM1ZWFjMWQ4NjI1NzlkYmJhYTRjY2VhMTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-10-17T12:20:22Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-10-17T12:20:22Z"}, "message": "fix generator drop caching\n\nFixes #45328.", "tree": {"sha": "1db3315ae836aaeb7969176390953636a2833994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db3315ae836aaeb7969176390953636a2833994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a151d37401b20d235eac1d862579dbbaa4ccea13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a151d37401b20d235eac1d862579dbbaa4ccea13", "html_url": "https://github.com/rust-lang/rust/commit/a151d37401b20d235eac1d862579dbbaa4ccea13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a151d37401b20d235eac1d862579dbbaa4ccea13/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "html_url": "https://github.com/rust-lang/rust/commit/abe7c87eefe4a15b7e83feb6b8962ae15452c16c"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "b88b61f18184b575b32b653320b03ec6cecba782", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a151d37401b20d235eac1d862579dbbaa4ccea13/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a151d37401b20d235eac1d862579dbbaa4ccea13/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a151d37401b20d235eac1d862579dbbaa4ccea13", "patch": "@@ -154,6 +154,11 @@ struct CachedBlock {\n     unwind: Option<BasicBlock>,\n \n     /// The cached block for unwinds during cleanups-on-generator-drop path\n+    ///\n+    /// This is split from the standard unwind path here to prevent drop\n+    /// elaboration from creating drop flags that would have to be captured\n+    /// by the generator. I'm not sure how important this optimization is,\n+    /// but it is here.\n     generator_drop: Option<BasicBlock>,\n }\n \n@@ -217,13 +222,26 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     ///\n-    /// `unwind` controls whether caches for the unwind branch are also invalidated.\n-    fn invalidate_cache(&mut self, unwind: bool) {\n+    /// `storage_only` controls whether to invalidate only drop paths run `StorageDead`.\n+    /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n+    /// top-of-scope (as opposed to dependent scopes).\n+    fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n+        // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n+        // with lots of `try!`?\n+\n+        // cached exits drop storage and refer to the top-of-scope\n         self.cached_exits.clear();\n-        if !unwind { return; }\n-        for dropdata in &mut self.drops {\n-            if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n-                cached_block.invalidate();\n+\n+        if !storage_only {\n+            // the current generator drop ignores storage but refers to top-of-scope\n+            self.cached_generator_drop = None;\n+        }\n+\n+        if !storage_only && !this_scope_only {\n+            for dropdata in &mut self.drops {\n+                if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n+                    cached_block.invalidate();\n+                }\n             }\n         }\n     }\n@@ -672,8 +690,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e. if a new drop is added into the middle scope, the\n             // cache of outer scpoe stays intact.\n-            let invalidate_unwind = needs_drop && !this_scope;\n-            scope.invalidate_cache(invalidate_unwind);\n+            scope.invalidate_cache(!needs_drop, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n@@ -942,5 +959,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         target = block\n     }\n \n+    debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n+\n     target\n }"}, {"sha": "d8b6dbe48f1a54dee5a1c5a74dc2942d517c7c98", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a151d37401b20d235eac1d862579dbbaa4ccea13/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a151d37401b20d235eac1d862579dbbaa4ccea13/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=a151d37401b20d235eac1d862579dbbaa4ccea13", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(untagged_unions)]\n+#![feature(generators, generator_trait, untagged_unions)]\n \n use std::cell::{Cell, RefCell};\n+use std::ops::Generator;\n use std::panic;\n use std::usize;\n \n@@ -161,6 +162,21 @@ fn vec_simple(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n }\n \n+fn generator(a: &Allocator, run_count: usize) {\n+    assert!(run_count < 4);\n+\n+    let mut gen = || {\n+        (a.alloc(),\n+         yield a.alloc(),\n+         a.alloc(),\n+         yield a.alloc()\n+         );\n+    };\n+    for _ in 0..run_count {\n+        gen.resume();\n+    }\n+}\n+\n #[allow(unreachable_code)]\n fn vec_unreachable(a: &Allocator) {\n     let _x = vec![a.alloc(), a.alloc(), a.alloc(), return];\n@@ -228,5 +244,11 @@ fn main() {\n     run_test(|a| field_assignment(a, false));\n     run_test(|a| field_assignment(a, true));\n \n+    // FIXME: fix leaks on panics\n+    run_test_nopanic(|a| generator(a, 0));\n+    run_test_nopanic(|a| generator(a, 1));\n+    run_test_nopanic(|a| generator(a, 2));\n+    run_test_nopanic(|a| generator(a, 3));\n+\n     run_test_nopanic(|a| union1(a));\n }"}]}