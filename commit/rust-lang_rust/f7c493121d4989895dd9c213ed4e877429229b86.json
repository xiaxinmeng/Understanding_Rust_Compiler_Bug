{"sha": "f7c493121d4989895dd9c213ed4e877429229b86", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YzQ5MzEyMWQ0OTg5ODk1ZGQ5YzIxM2VkNGU4Nzc0MjkyMjliODY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-16T13:29:27Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-16T13:29:27Z"}, "message": "Reuse the `Pointer` type instead of passing reassembling it at many use sites", "tree": {"sha": "12734604f95b67cea9131fb15e8077d6cc0158f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12734604f95b67cea9131fb15e8077d6cc0158f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7c493121d4989895dd9c213ed4e877429229b86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c493121d4989895dd9c213ed4e877429229b86", "html_url": "https://github.com/rust-lang/rust/commit/f7c493121d4989895dd9c213ed4e877429229b86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7c493121d4989895dd9c213ed4e877429229b86/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2bf37aec075099a8b58c1a52ebca944f318d530", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2bf37aec075099a8b58c1a52ebca944f318d530", "html_url": "https://github.com/rust-lang/rust/commit/b2bf37aec075099a8b58c1a52ebca944f318d530"}], "stats": {"total": 43, "additions": 20, "deletions": 23}, "files": [{"sha": "04e03d0d95aa29a3a7d77ed5985243a89033280e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -307,7 +307,7 @@ impl_stable_hash_for!(\n     impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n         Scalar(val),\n         Slice(a, b),\n-        ByRef(id, alloc, offset),\n+        ByRef(ptr, alloc),\n     }\n );\n impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {"}, {"sha": "1e5ba2c176bd2fe94085fbb937d42618d3cc9372", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -31,9 +31,8 @@ pub enum ConstValue<'tcx> {\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation together with an offset into the allocation.\n-    /// Invariant: the `AllocId` matches the allocation.\n-    ByRef(AllocId, &'tcx Allocation, Size),\n+    /// An allocation together with a pointer into the allocation.\n+    ByRef(Pointer, &'tcx Allocation),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "0d1dc4ee2032f66dd2020e646fd991e8a54657e0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -499,8 +499,8 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n         match *self {\n             ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n             ConstValue::Slice(x, y) => Some(ConstValue::Slice(x, y)),\n-            ConstValue::ByRef(x, alloc, z) => Some(ConstValue::ByRef(\n-                x, alloc.lift_to_tcx(tcx)?, z,\n+            ConstValue::ByRef(ptr, alloc) => Some(ConstValue::ByRef(\n+                ptr, alloc.lift_to_tcx(tcx)?,\n             )),\n         }\n     }"}, {"sha": "26d3bd912470739fe41875ea15918d4967b8a296", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -71,7 +71,7 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "3cac1befaf4ef13b83cf918d2ec3a2ad69ed617f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -101,8 +101,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.cx().const_usize(b);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(_, alloc, offset) => {\n-                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, offset)));\n+            ConstValue::ByRef(ptr, alloc) => {\n+                return Ok(bx.load_operand(bx.cx().from_const_alloc(layout, alloc, ptr.offset)));\n             },\n         };\n "}, {"sha": "1edcbfead2c94424ca509af15fb458825214bd5d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -417,8 +417,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n-                            bx.cx().from_const_alloc(layout, alloc, offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n+                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "94b9f0eadd0e70eb04274adda5d9c951a9382580", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -96,7 +96,7 @@ pub fn op_to_const<'tcx>(\n             // FIXME shouldn't it be the case that `mark_static_initialized` has already\n             // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n-            ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n+            ConstValue::ByRef(ptr, alloc)\n         },\n         Ok(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),"}, {"sha": "bf2f0d5d81f47d452f6b37ebba189362cdfe1ee8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -172,7 +172,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Pointer, Scalar};\n+use rustc::mir::interpret::{ConstValue, Scalar};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -214,9 +214,8 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p.alloc_id,\n+                p,\n                 self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-                p.offset,\n             ),\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n@@ -1428,15 +1427,14 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n             if *t != tcx.types.u8 {\n                 // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n                 // any sort of exhaustiveness/unreachable check yet\n                 // This solely means that we don't lint about unreachable patterns, even if some\n                 // are definitely unreachable.\n                 return Ok(false);\n             }\n-            let ptr = Pointer::new(id, offset);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n         },\n@@ -1778,8 +1776,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let (opt_ptr, n, ty) = match value.ty.sty {\n                         ty::TyKind::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(id, alloc, offset) => (\n-                                    Some((Pointer::new(id, offset), alloc)),\n+                                ConstValue::ByRef(ptr, alloc) => (\n+                                    Some((ptr, alloc)),\n                                     n.unwrap_usize(cx.tcx),\n                                     t,\n                                 ),"}, {"sha": "1d6aff749c593c1221bcdf1be3704a340a8318b9", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -591,11 +591,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             self.layout_of(ty)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef(id, alloc, offset) => {\n+            ConstValue::ByRef(ptr, alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n                 Operand::Indirect(\n-                    MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)\n+                    MemPlace::from_ptr(ptr, alloc.align)\n                 ).with_default_tag()\n             },\n             ConstValue::Slice(a, b) =>"}, {"sha": "32c9d5c0c4467a66356f095e64f7dd904f603544", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -1257,7 +1257,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::Slice(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(_id, alloc, _offset) => {\n+        ConstValue::ByRef(_ptr, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "cbc8fde53a263d2702852290603829a6d14acba4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c493121d4989895dd9c213ed4e877429229b86/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f7c493121d4989895dd9c213ed4e877429229b86", "patch": "@@ -1464,7 +1464,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation, _) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")"}]}