{"sha": "40fae88fa82db350f1233b9b93df0be30e6579bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZmFlODhmYTgyZGIzNTBmMTIzM2I5YjkzZGYwYmUzMGU2NTc5YmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-25T01:48:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-25T01:48:22Z"}, "message": "Rollup merge of #64324 - alexcrichton:share-generics-again, r=michaelwoerister\n\nrustc: Fix mixing crates with different `share_generics`\n\nThis commit addresses #64319 by removing the `dylib` crate type from the\nlist of crate type that exports generic symbols. The bug in #64319\narises because a `dylib` crate type was trying to export a symbol in an\nuptream crate but it miscalculated the symbol name of the uptream\nsymbol. This isn't really necessary, though, since `dylib` crates aren't\nthat heavily used, so we can just conservatively say that the `dylib`\ncrate type never exports generic symbols, forcibly removing them from\nthe exported symbol lists if were to otherwise find them.\n\nThe fix here happens in two places:\n\n* First is in the `local_crate_exports_generics` method, indicating that\n  it's now `false` for the `Dylib` crate type. Only rlibs actually\n  export generics at this point.\n\n* Next is when we load exported symbols from upstream crate. If, for our\n  compilation session, the crate may be included from a dynamic library,\n  then its generic symbols are removed. When the crate was linked into a\n  dynamic library its symbols weren't exported, so we can't consider\n  them a candidate to link against.\n\nOverally this should avoid situations where we incorrectly calculate the\nupstream symbol names in the face of differnet `share_generics` options,\nultimately...\n\nCloses #64319", "tree": {"sha": "988ea8d7ef3a56d1cc4b191d26639ad91ad03b5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/988ea8d7ef3a56d1cc4b191d26639ad91ad03b5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40fae88fa82db350f1233b9b93df0be30e6579bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdisdnCRBK7hj4Ov3rIwAAdHIIAIAoh+g+xMLUWr7ngBAG5rer\ngV5HTCtMNtwC+P7QE1K7Nc97FQ5lbSV4T44c4pGLFHg6tt3EftTxk1sYBS7LSV5r\nvIdtMk70ShG2z4fVcXC+u2edee4HiOQBKyiMLeIV/Ejbk4N85t9WlPNo0YKRvZdI\n1JsKkDgtJwDs5qmY8j+fxzUnefx01qOGfedXtbuAa53TGtwvZRagS8SvLk2TYZax\nC5BZGfuFw2SwUlYEoGGMm/WgvQfo1rWiDh7c3TTbvI7pWnZOYqDfrTJ6IslnSalZ\nE2hCgnl+g53slSKGk5MEqQ2Wb+E2zdVxkewaPUWZmnS4/2Q2qVUpT538Aosk/i0=\n=Hezj\n-----END PGP SIGNATURE-----\n", "payload": "tree 988ea8d7ef3a56d1cc4b191d26639ad91ad03b5f\nparent dcd473d7b554a82013913244da8aba1e22a002a9\nparent f00c6346b42d2a3091752166cd86aa2d69112dcc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569376102 +0200\ncommitter GitHub <noreply@github.com> 1569376102 +0200\n\nRollup merge of #64324 - alexcrichton:share-generics-again, r=michaelwoerister\n\nrustc: Fix mixing crates with different `share_generics`\n\nThis commit addresses #64319 by removing the `dylib` crate type from the\nlist of crate type that exports generic symbols. The bug in #64319\narises because a `dylib` crate type was trying to export a symbol in an\nuptream crate but it miscalculated the symbol name of the uptream\nsymbol. This isn't really necessary, though, since `dylib` crates aren't\nthat heavily used, so we can just conservatively say that the `dylib`\ncrate type never exports generic symbols, forcibly removing them from\nthe exported symbol lists if were to otherwise find them.\n\nThe fix here happens in two places:\n\n* First is in the `local_crate_exports_generics` method, indicating that\n  it's now `false` for the `Dylib` crate type. Only rlibs actually\n  export generics at this point.\n\n* Next is when we load exported symbols from upstream crate. If, for our\n  compilation session, the crate may be included from a dynamic library,\n  then its generic symbols are removed. When the crate was linked into a\n  dynamic library its symbols weren't exported, so we can't consider\n  them a candidate to link against.\n\nOverally this should avoid situations where we incorrectly calculate the\nupstream symbol names in the face of differnet `share_generics` options,\nultimately...\n\nCloses #64319\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40fae88fa82db350f1233b9b93df0be30e6579bc", "html_url": "https://github.com/rust-lang/rust/commit/40fae88fa82db350f1233b9b93df0be30e6579bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40fae88fa82db350f1233b9b93df0be30e6579bc/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd473d7b554a82013913244da8aba1e22a002a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd473d7b554a82013913244da8aba1e22a002a9", "html_url": "https://github.com/rust-lang/rust/commit/dcd473d7b554a82013913244da8aba1e22a002a9"}, {"sha": "f00c6346b42d2a3091752166cd86aa2d69112dcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f00c6346b42d2a3091752166cd86aa2d69112dcc", "html_url": "https://github.com/rust-lang/rust/commit/f00c6346b42d2a3091752166cd86aa2d69112dcc"}], "stats": {"total": 998, "additions": 565, "deletions": 433}, "files": [{"sha": "8b2bf55ccc1208f7bdf358ce8e508603b9e05a40", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 372, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1,64 +1,10 @@\n-//! Resolution of mixing rlibs and dylibs\n+//! Type definitions for learning about the dependency formats of all upstream\n+//! crates (rlibs/dylibs/oh my).\n //!\n-//! When producing a final artifact, such as a dynamic library, the compiler has\n-//! a choice between linking an rlib or linking a dylib of all upstream\n-//! dependencies. The linking phase must guarantee, however, that a library only\n-//! show up once in the object file. For example, it is illegal for library A to\n-//! be statically linked to B and C in separate dylibs, and then link B and C\n-//! into a crate D (because library A appears twice).\n-//!\n-//! The job of this module is to calculate what format each upstream crate\n-//! should be used when linking each output type requested in this session. This\n-//! generally follows this set of rules:\n-//!\n-//!     1. Each library must appear exactly once in the output.\n-//!     2. Each rlib contains only one library (it's just an object file)\n-//!     3. Each dylib can contain more than one library (due to static linking),\n-//!        and can also bring in many dynamic dependencies.\n-//!\n-//! With these constraints in mind, it's generally a very difficult problem to\n-//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n-//! that NP-ness may come into the picture here...\n-//!\n-//! The current selection algorithm below looks mostly similar to:\n-//!\n-//!     1. If static linking is required, then require all upstream dependencies\n-//!        to be available as rlibs. If not, generate an error.\n-//!     2. If static linking is requested (generating an executable), then\n-//!        attempt to use all upstream dependencies as rlibs. If any are not\n-//!        found, bail out and continue to step 3.\n-//!     3. Static linking has failed, at least one library must be dynamically\n-//!        linked. Apply a heuristic by greedily maximizing the number of\n-//!        dynamically linked libraries.\n-//!     4. Each upstream dependency available as a dynamic library is\n-//!        registered. The dependencies all propagate, adding to a map. It is\n-//!        possible for a dylib to add a static library as a dependency, but it\n-//!        is illegal for two dylibs to add the same static library as a\n-//!        dependency. The same dylib can be added twice. Additionally, it is\n-//!        illegal to add a static dependency when it was previously found as a\n-//!        dylib (and vice versa)\n-//!     5. After all dynamic dependencies have been traversed, re-traverse the\n-//!        remaining dependencies and add them statically (if they haven't been\n-//!        added already).\n-//!\n-//! While not perfect, this algorithm should help support use-cases such as leaf\n-//! dependencies being static while the larger tree of inner dependencies are\n-//! all dynamic. This isn't currently very well battle tested, so it will likely\n-//! fall short in some use cases.\n-//!\n-//! Currently, there is no way to specify the preference of linkage with a\n-//! particular library (other than a global dynamic/static switch).\n-//! Additionally, the algorithm is geared towards finding *any* solution rather\n-//! than finding a number of solutions (there are normally quite a few).\n-\n-use crate::hir::def_id::CrateNum;\n+//! For all the gory details, see the provider of the `dependency_formats`\n+//! query.\n \n use crate::session::config;\n-use crate::ty::TyCtxt;\n-use crate::middle::cstore::{self, DepKind};\n-use crate::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use crate::util::nodemap::FxHashMap;\n-use rustc_target::spec::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -71,324 +17,12 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = Vec<(config::CrateType, DependencyList)>;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum Linkage {\n     NotLinked,\n     IncludedFromDylib,\n     Static,\n     Dynamic,\n }\n-\n-pub fn calculate(tcx: TyCtxt<'_>) {\n-    let sess = &tcx.sess;\n-    let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n-        let linkage = calculate_type(tcx, ty);\n-        verify_ok(tcx, &linkage);\n-        (ty, linkage)\n-    }).collect::<FxHashMap<_, _>>();\n-    sess.abort_if_errors();\n-    sess.dependency_formats.set(fmts);\n-}\n-\n-fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n-    let sess = &tcx.sess;\n-\n-    if !sess.opts.output_types.should_codegen() {\n-        return Vec::new();\n-    }\n-\n-    let preferred_linkage = match ty {\n-        // cdylibs must have all static dependencies.\n-        config::CrateType::Cdylib => Linkage::Static,\n-\n-        // Generating a dylib without `-C prefer-dynamic` means that we're going\n-        // to try to eagerly statically link all dependencies. This is normally\n-        // done for end-product dylibs, not intermediate products.\n-        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n-        config::CrateType::Dylib => Linkage::Dynamic,\n-\n-        // If the global prefer_dynamic switch is turned off, or the final\n-        // executable will be statically linked, prefer static crate linkage.\n-        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n-            sess.crt_static() => Linkage::Static,\n-        config::CrateType::Executable => Linkage::Dynamic,\n-\n-        // proc-macro crates are mostly cdylibs, but we also need metadata.\n-        config::CrateType::ProcMacro => Linkage::Static,\n-\n-        // No linkage happens with rlibs, we just needed the metadata (which we\n-        // got long ago), so don't bother with anything.\n-        config::CrateType::Rlib => Linkage::NotLinked,\n-\n-        // staticlibs must have all static dependencies.\n-        config::CrateType::Staticlib => Linkage::Static,\n-    };\n-\n-    if preferred_linkage == Linkage::NotLinked {\n-        // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n-\n-        // Staticlibs, cdylibs, and static executables must have all static\n-        // dependencies. If any are not found, generate some nice pretty errors.\n-        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n-                (ty == config::CrateType::Executable && sess.crt_static() &&\n-                !sess.target.target.options.crt_static_allows_dylibs) {\n-            for &cnum in tcx.crates().iter() {\n-                if tcx.dep_kind(cnum).macros_only() { continue }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() { continue }\n-                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum)));\n-            }\n-            return Vec::new();\n-        }\n-    }\n-\n-    let mut formats = FxHashMap::default();\n-\n-    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n-    // dependencies, ensuring there are no conflicts. The only valid case for a\n-    // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    for &cnum in tcx.crates().iter() {\n-        if tcx.dep_kind(cnum).macros_only() { continue }\n-        let name = tcx.crate_name(cnum);\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_some() {\n-            info!(\"adding dylib: {}\", name);\n-            add_library(tcx, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum);\n-            for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n-                add_library(tcx, depnum, style, &mut formats);\n-            }\n-        }\n-    }\n-\n-    // Collect what we've got so far in the return vector.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&CrateNum::new(cnum)) {\n-            Some(&RequireDynamic) => Linkage::Dynamic,\n-            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n-            None => Linkage::NotLinked,\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Run through the dependency list again, and add any missing libraries as\n-    // static libraries.\n-    //\n-    // If the crate hasn't been included yet and it's not actually required\n-    // (e.g., it's an allocator) then we skip it here as well.\n-    for &cnum in tcx.crates().iter() {\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_none() &&\n-           !formats.contains_key(&cnum) &&\n-           tcx.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n-            add_library(tcx, cnum, RequireStatic, &mut formats);\n-            ret[cnum.as_usize() - 1] = Linkage::Static;\n-        }\n-    }\n-\n-    // We've gotten this far because we're emitting some form of a final\n-    // artifact which means that we may need to inject dependencies of some\n-    // form.\n-    //\n-    // Things like allocators and panic runtimes may not have been activated\n-    // quite yet, so do so here.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    // When dylib B links to dylib A, then when using B we must also link to A.\n-    // It could be the case, however, that the rlib for A is present (hence we\n-    // found metadata), but the dylib for A has since been removed.\n-    //\n-    // For situations like this, we perform one last pass over the dependencies,\n-    // making sure that everything is available in the requested format.\n-    for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = CrateNum::new(cnum + 1);\n-        let src = tcx.used_crate_source(cnum);\n-        match *kind {\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static if src.rlib.is_some() => continue,\n-            Linkage::Dynamic if src.dylib.is_some() => continue,\n-            kind => {\n-                let kind = match kind {\n-                    Linkage::Static => \"rlib\",\n-                    _ => \"dylib\",\n-                };\n-                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum), kind));\n-            }\n-        }\n-    }\n-\n-    ret\n-}\n-\n-fn add_library(\n-    tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n-    link: LinkagePreference,\n-    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n-) {\n-    match m.get(&cnum) {\n-        Some(&link2) => {\n-            // If the linkages differ, then we'd have two copies of the library\n-            // if we continued linking. If the linkages are both static, then we\n-            // would also have two copies of the library (static from two\n-            // different locations).\n-            //\n-            // This error is probably a little obscure, but I imagine that it\n-            // can be refined over time.\n-            if link2 != link || link == RequireStatic {\n-                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                              shows up once\", tcx.crate_name(cnum)))\n-                    .help(\"having upstream crates all available in one format \\\n-                           will likely make this go away\")\n-                    .emit();\n-            }\n-        }\n-        None => { m.insert(cnum, link); }\n-    }\n-}\n-\n-fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n-    let sess = &tcx.sess;\n-    let crates = cstore::used_crates(tcx, RequireStatic);\n-    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n-        return None\n-    }\n-\n-    // All crates are available in an rlib format, so we're just going to link\n-    // everything in explicitly so long as it's actually required.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n-            Linkage::Static\n-        } else {\n-            Linkage::NotLinked\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Our allocator/panic runtime may not have been linked above if it wasn't\n-    // explicitly linked, which is the case for any injected dependency. Handle\n-    // that here and activate them.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    Some(ret)\n-}\n-\n-// Given a list of how to link upstream dependencies so far, ensure that an\n-// injected dependency is activated. This will not do anything if one was\n-// transitively included already (e.g., via a dylib or explicitly so).\n-//\n-// If an injected dependency was not found then we're guaranteed the\n-// metadata::creader module has injected that dependency (not listed as\n-// a required dependency) in one of the session's field. If this field is not\n-// set then this compilation doesn't actually need the dependency and we can\n-// also skip this step entirely.\n-fn activate_injected_dep(injected: Option<CrateNum>,\n-                         list: &mut DependencyList,\n-                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n-    for (i, slot) in list.iter().enumerate() {\n-        let cnum = CrateNum::new(i + 1);\n-        if !replaces_injected(cnum) {\n-            continue\n-        }\n-        if *slot != Linkage::NotLinked {\n-            return\n-        }\n-    }\n-    if let Some(injected) = injected {\n-        let idx = injected.as_usize() - 1;\n-        assert_eq!(list[idx], Linkage::NotLinked);\n-        list[idx] = Linkage::Static;\n-    }\n-}\n-\n-// After the linkage for a crate has been determined we need to verify that\n-// there's only going to be one allocator in the output.\n-fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n-    let sess = &tcx.sess;\n-    if list.len() == 0 {\n-        return\n-    }\n-    let mut panic_runtime = None;\n-    for (i, linkage) in list.iter().enumerate() {\n-        if let Linkage::NotLinked = *linkage {\n-            continue\n-        }\n-        let cnum = CrateNum::new(i + 1);\n-\n-        if tcx.is_panic_runtime(cnum) {\n-            if let Some((prev, _)) = panic_runtime {\n-                let prev_name = tcx.crate_name(prev);\n-                let cur_name = tcx.crate_name(cnum);\n-                sess.err(&format!(\"cannot link together two \\\n-                                   panic runtimes: {} and {}\",\n-                                  prev_name, cur_name));\n-            }\n-            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n-        }\n-    }\n-\n-    // If we found a panic runtime, then we know by this point that it's the\n-    // only one, but we perform validation here that all the panic strategy\n-    // compilation modes for the whole DAG are valid.\n-    if let Some((cnum, found_strategy)) = panic_runtime {\n-        let desired_strategy = sess.panic_strategy();\n-\n-        // First up, validate that our selected panic runtime is indeed exactly\n-        // our same strategy.\n-        if found_strategy != desired_strategy {\n-            sess.err(&format!(\"the linked panic runtime `{}` is \\\n-                               not compiled with this crate's \\\n-                               panic strategy `{}`\",\n-                              tcx.crate_name(cnum),\n-                              desired_strategy.desc()));\n-        }\n-\n-        // Next up, verify that all other crates are compatible with this panic\n-        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n-        // is abort then it's compatible with everything. Otherwise all crates'\n-        // panic strategy must match our own.\n-        for (i, linkage) in list.iter().enumerate() {\n-            if let Linkage::NotLinked = *linkage {\n-                continue\n-            }\n-            if desired_strategy == PanicStrategy::Abort {\n-                continue\n-            }\n-            let cnum = CrateNum::new(i + 1);\n-            let found_strategy = tcx.panic_strategy(cnum);\n-            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n-            if is_compiler_builtins || desired_strategy == found_strategy {\n-                continue\n-            }\n-\n-            sess.err(&format!(\"the crate `{}` is compiled with the \\\n-                               panic strategy `{}` which is \\\n-                               incompatible with this crate's \\\n-                               strategy of `{}`\",\n-                              tcx.crate_name(cnum),\n-                              found_strategy.desc(),\n-                              desired_strategy.desc()));\n-        }\n-    }\n-}"}, {"sha": "fd99995480a9e284774255d963d801322b8bae00", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -630,6 +630,12 @@ rustc_queries! {\n                                         -> &'tcx [(CrateNum, LinkagePreference)] {\n             desc { \"dylib dependency formats of crate\" }\n         }\n+\n+        query dependency_formats(_: CrateNum)\n+            -> Lrc<crate::middle::dependency_format::Dependencies>\n+        {\n+            desc { \"get the linkage format of all dependencies\" }\n+        }\n     }\n \n     Codegen {"}, {"sha": "a9a20a924347ca4bbd07fdc0b1b408a78fede58e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -687,7 +687,7 @@ pub enum EntryFnType {\n \n impl_stable_hash_via_hash!(EntryFnType);\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, HashStable)]\n pub enum CrateType {\n     Executable,\n     Dylib,"}, {"sha": "8e9c2735c39134138d2b39dea1a518dd3e3357d6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::middle::dependency_format;\n use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n@@ -91,7 +90,6 @@ pub struct Session {\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n-    pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n@@ -1248,7 +1246,6 @@ fn build_session_(\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n         plugin_attributes: Lock::new(Vec::new()),\n         crate_types: Once::new(),\n-        dependency_formats: Once::new(),\n         crate_disambiguator: Once::new(),\n         features: Once::new(),\n         recursion_limit: Once::new(),"}, {"sha": "c03dbb2b1ed0e6899439522c642a6bbe3ffc1d36", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1510,9 +1510,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 CrateType::Executable |\n                 CrateType::Staticlib  |\n                 CrateType::ProcMacro  |\n+                CrateType::Dylib      |\n                 CrateType::Cdylib     => false,\n-                CrateType::Rlib       |\n-                CrateType::Dylib      => true,\n+                CrateType::Rlib       => true,\n             }\n         })\n     }"}, {"sha": "3b7ae5e33d5e716e7d869d790617fa83a1ac969c", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -219,15 +219,24 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     (linker.to_path_buf(), cmd)\n }\n \n-pub fn each_linked_rlib(sess: &Session,\n-                               info: &CrateInfo,\n-                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n+pub fn each_linked_rlib(\n+    info: &CrateInfo,\n+    f: &mut dyn FnMut(CrateNum, &Path),\n+) -> Result<(), String> {\n     let crates = info.used_crates_static.iter();\n-    let fmts = sess.dependency_formats.borrow();\n-    let fmts = fmts.get(&config::CrateType::Executable)\n-                   .or_else(|| fmts.get(&config::CrateType::Staticlib))\n-                   .or_else(|| fmts.get(&config::CrateType::Cdylib))\n-                   .or_else(|| fmts.get(&config::CrateType::ProcMacro));\n+    let mut fmts = None;\n+    for (ty, list) in info.dependency_formats.iter() {\n+        match ty {\n+            config::CrateType::Executable |\n+            config::CrateType::Staticlib |\n+            config::CrateType::Cdylib |\n+            config::CrateType::ProcMacro => {\n+                fmts = Some(list);\n+                break;\n+            }\n+            _ => {}\n+        }\n+    }\n     let fmts = match fmts {\n         Some(f) => f,\n         None => return Err(\"could not find formats for rlibs\".to_string())\n@@ -406,7 +415,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+    let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n         let name = &codegen_results.crate_info.crate_name[&cnum];\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n \n@@ -1294,11 +1303,13 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                            sess: &'a Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+    tmpdir: &Path,\n+) {\n     // All of the heavy lifting has previously been accomplished by the\n     // dependency_format module of the compiler. This is just crawling the\n     // output of that module, adding crates as necessary.\n@@ -1307,8 +1318,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n \n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n@@ -1620,10 +1633,12 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n+pub fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1633,8 +1648,10 @@ pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     // This passes RequireStatic, but the actual requirement doesn't matter,\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     let crates = &codegen_results.crate_info.used_crates_static;\n     for &(cnum, _) in crates {"}, {"sha": "ff87f0b1547cec36a61cb67a2780bc0adf8057dc", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -14,6 +14,7 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, OptLevel, DebugInfo,\n                              LinkerPluginLto, Lto};\n+use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::{LinkerFlavor, LldFlavor};\n use rustc_serialize::{json, Encoder};\n@@ -1092,18 +1093,41 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n         }\n     }\n \n-    let formats = tcx.sess.dependency_formats.borrow();\n-    let deps = formats[&crate_type].iter();\n+    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let deps = formats.iter().filter_map(|(t, list)| {\n+        if *t == crate_type {\n+            Some(list)\n+        } else {\n+            None\n+        }\n+    }).next().unwrap();\n \n-    for (index, dep_format) in deps.enumerate() {\n+    for (index, dep_format) in deps.iter().enumerate() {\n         let cnum = CrateNum::new(index + 1);\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n             for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n-                if level.is_below_threshold(export_threshold) {\n-                    symbols.push(symbol.symbol_name(tcx).to_string());\n+                if !level.is_below_threshold(export_threshold) {\n+                    continue;\n                 }\n+\n+                // Do not export generic symbols from upstream crates in linked\n+                // artifact (notably the `dylib` crate type). The main reason\n+                // for this is that `symbol_name` is actually wrong for generic\n+                // symbols because it guesses the name we'd give them locally\n+                // rather than the name it has upstream (depending on\n+                // `share_generics` settings and such).\n+                //\n+                // To fix that issue we just say that linked artifacts, aka\n+                // `dylib`s, never export generic symbols and they aren't\n+                // available to downstream crates. (the not available part is\n+                // handled elsewhere).\n+                if let ExportedSymbol::Generic(..) = symbol {\n+                    continue;\n+                }\n+\n+                symbols.push(symbol.symbol_name(tcx).to_string());\n             }\n         }\n     }"}, {"sha": "3e4b7695447c8d5a132d822b47dc768295fdc52c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -298,7 +298,7 @@ fn upstream_monomorphizations_provider(\n     };\n \n     for &cnum in cnums.iter() {\n-        for &(ref exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n+        for (exported_symbol, _) in tcx.exported_symbols(cnum).iter() {\n             if let &ExportedSymbol::Generic(def_id, substs) = exported_symbol {\n                 let substs_map = instances.entry(def_id).or_default();\n "}, {"sha": "1a2c23ae0d4f7415b84ae980f59ae60524227d75", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1048,7 +1048,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+    drop(link::each_linked_rlib(crate_info, &mut |cnum, path| {\n         if link::ignored_for_lto(sess, crate_info, cnum) {\n             return\n         }"}, {"sha": "98d3022a4185d4a826494ceeeec4df38bfecec0c", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -539,7 +539,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // linkage, then it's already got an allocator shim and we'll be using that\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n-    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE)\n         .iter()\n         .any(|(_, list)| {\n             use rustc::middle::dependency_format::Linkage;\n@@ -731,6 +731,7 @@ impl CrateInfo {\n             used_crate_source: Default::default(),\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n+            dependency_formats: tcx.dependency_formats(LOCAL_CRATE),\n         };\n         let lang_items = tcx.lang_items();\n "}, {"sha": "161d3ce61f0a6f083f988b5730f331ffebb215ca", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -33,6 +33,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n+use rustc::middle::dependency_format::Dependencies;\n use syntax_pos::symbol::Symbol;\n \n mod error_codes;\n@@ -142,6 +143,7 @@ pub struct CrateInfo {\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n     pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n     pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+    pub dependency_formats: Lrc<Dependencies>,\n }\n \n "}, {"sha": "56db695f254117b8590ae17f0606b0a748ce16dc", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1075,10 +1075,6 @@ pub fn start_codegen<'tcx>(\n         tcx.print_debug_stats();\n     }\n \n-    time(tcx.sess, \"resolving dependency formats\", || {\n-        middle::dependency_format::calculate(tcx)\n-    });\n-\n     let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n         encode_and_write_metadata(tcx, outputs)\n     });"}, {"sha": "0bc53dbde5f8acc0998e200cf30d9a20c0b51351", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -10,6 +10,7 @@ use rustc::middle::cstore::{CrateStore, DepKind,\n                             EncodedMetadata, NativeLibraryKind};\n use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n+use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def;\n use rustc::hir;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -239,7 +240,30 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n-    exported_symbols => { Arc::new(cdata.exported_symbols(tcx)) }\n+    exported_symbols => {\n+        let mut syms = cdata.exported_symbols(tcx);\n+\n+        // When linked into a dylib crates don't export their generic symbols,\n+        // so if that's happening then we can't load upstream monomorphizations\n+        // from this crate.\n+        let formats = tcx.dependency_formats(LOCAL_CRATE);\n+        let remove_generics = formats.iter().any(|(_ty, list)| {\n+            match list.get(def_id.krate.as_usize() - 1) {\n+                Some(Linkage::IncludedFromDylib) | Some(Linkage::Dynamic) => true,\n+                _ => false,\n+            }\n+        });\n+        if remove_generics {\n+            syms.retain(|(sym, _threshold)| {\n+                match sym {\n+                    ExportedSymbol::Generic(..) => false,\n+                    _ => return true,\n+                }\n+            });\n+        }\n+\n+        Arc::new(syms)\n+    }\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -370,6 +394,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n             tcx.arena.alloc(visible_parent_map)\n         },\n \n+        dependency_formats: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Lrc::new(crate::dependency_format::calculate(tcx))\n+        },\n+\n         ..*providers\n     };\n }"}, {"sha": "9a30623b33d626a6f8c70f081d31888ef46baa2f", "filename": "src/librustc_metadata/dependency_format.rs", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -0,0 +1,370 @@\n+//! Resolution of mixing rlibs and dylibs\n+//!\n+//! When producing a final artifact, such as a dynamic library, the compiler has\n+//! a choice between linking an rlib or linking a dylib of all upstream\n+//! dependencies. The linking phase must guarantee, however, that a library only\n+//! show up once in the object file. For example, it is illegal for library A to\n+//! be statically linked to B and C in separate dylibs, and then link B and C\n+//! into a crate D (because library A appears twice).\n+//!\n+//! The job of this module is to calculate what format each upstream crate\n+//! should be used when linking each output type requested in this session. This\n+//! generally follows this set of rules:\n+//!\n+//!     1. Each library must appear exactly once in the output.\n+//!     2. Each rlib contains only one library (it's just an object file)\n+//!     3. Each dylib can contain more than one library (due to static linking),\n+//!        and can also bring in many dynamic dependencies.\n+//!\n+//! With these constraints in mind, it's generally a very difficult problem to\n+//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n+//! that NP-ness may come into the picture here...\n+//!\n+//! The current selection algorithm below looks mostly similar to:\n+//!\n+//!     1. If static linking is required, then require all upstream dependencies\n+//!        to be available as rlibs. If not, generate an error.\n+//!     2. If static linking is requested (generating an executable), then\n+//!        attempt to use all upstream dependencies as rlibs. If any are not\n+//!        found, bail out and continue to step 3.\n+//!     3. Static linking has failed, at least one library must be dynamically\n+//!        linked. Apply a heuristic by greedily maximizing the number of\n+//!        dynamically linked libraries.\n+//!     4. Each upstream dependency available as a dynamic library is\n+//!        registered. The dependencies all propagate, adding to a map. It is\n+//!        possible for a dylib to add a static library as a dependency, but it\n+//!        is illegal for two dylibs to add the same static library as a\n+//!        dependency. The same dylib can be added twice. Additionally, it is\n+//!        illegal to add a static dependency when it was previously found as a\n+//!        dylib (and vice versa)\n+//!     5. After all dynamic dependencies have been traversed, re-traverse the\n+//!        remaining dependencies and add them statically (if they haven't been\n+//!        added already).\n+//!\n+//! While not perfect, this algorithm should help support use-cases such as leaf\n+//! dependencies being static while the larger tree of inner dependencies are\n+//! all dynamic. This isn't currently very well battle tested, so it will likely\n+//! fall short in some use cases.\n+//!\n+//! Currently, there is no way to specify the preference of linkage with a\n+//! particular library (other than a global dynamic/static switch).\n+//! Additionally, the algorithm is geared towards finding *any* solution rather\n+//! than finding a number of solutions (there are normally quite a few).\n+\n+use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n+use rustc::middle::cstore::{self, DepKind};\n+use rustc::middle::dependency_format::{DependencyList, Dependencies, Linkage};\n+use rustc::session::config;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_target::spec::PanicStrategy;\n+\n+pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+    tcx.sess.crate_types.borrow().iter().map(|&ty| {\n+        let linkage = calculate_type(tcx, ty);\n+        verify_ok(tcx, &linkage);\n+        (ty, linkage)\n+    }).collect::<Vec<_>>()\n+}\n+\n+fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n+    let sess = &tcx.sess;\n+\n+    if !sess.opts.output_types.should_codegen() {\n+        return Vec::new();\n+    }\n+\n+    let preferred_linkage = match ty {\n+        // cdylibs must have all static dependencies.\n+        config::CrateType::Cdylib => Linkage::Static,\n+\n+        // Generating a dylib without `-C prefer-dynamic` means that we're going\n+        // to try to eagerly statically link all dependencies. This is normally\n+        // done for end-product dylibs, not intermediate products.\n+        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        config::CrateType::Dylib => Linkage::Dynamic,\n+\n+        // If the global prefer_dynamic switch is turned off, or the final\n+        // executable will be statically linked, prefer static crate linkage.\n+        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n+            sess.crt_static() => Linkage::Static,\n+        config::CrateType::Executable => Linkage::Dynamic,\n+\n+        // proc-macro crates are mostly cdylibs, but we also need metadata.\n+        config::CrateType::ProcMacro => Linkage::Static,\n+\n+        // No linkage happens with rlibs, we just needed the metadata (which we\n+        // got long ago), so don't bother with anything.\n+        config::CrateType::Rlib => Linkage::NotLinked,\n+\n+        // staticlibs must have all static dependencies.\n+        config::CrateType::Staticlib => Linkage::Static,\n+    };\n+\n+    if preferred_linkage == Linkage::NotLinked {\n+        // If the crate is not linked, there are no link-time dependencies.\n+        return Vec::new();\n+    }\n+\n+    if preferred_linkage == Linkage::Static {\n+        // Attempt static linkage first. For dylibs and executables, we may be\n+        // able to retry below with dynamic linkage.\n+        if let Some(v) = attempt_static(tcx) {\n+            return v;\n+        }\n+\n+        // Staticlibs, cdylibs, and static executables must have all static\n+        // dependencies. If any are not found, generate some nice pretty errors.\n+        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n+                (ty == config::CrateType::Executable && sess.crt_static() &&\n+                !sess.target.target.options.crt_static_allows_dylibs) {\n+            for &cnum in tcx.crates().iter() {\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n+                let src = tcx.used_crate_source(cnum);\n+                if src.rlib.is_some() { continue }\n+                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum)));\n+            }\n+            return Vec::new();\n+        }\n+    }\n+\n+    let mut formats = FxHashMap::default();\n+\n+    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n+    // dependencies, ensuring there are no conflicts. The only valid case for a\n+    // dependency to be relied upon twice is for both cases to rely on a dylib.\n+    for &cnum in tcx.crates().iter() {\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_some() {\n+            log::info!(\"adding dylib: {}\", name);\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n+            let deps = tcx.dylib_dependency_formats(cnum);\n+            for &(depnum, style) in deps.iter() {\n+                log::info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n+            }\n+        }\n+    }\n+\n+    // Collect what we've got so far in the return vector.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        match formats.get(&CrateNum::new(cnum)) {\n+            Some(&RequireDynamic) => Linkage::Dynamic,\n+            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n+            None => Linkage::NotLinked,\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Run through the dependency list again, and add any missing libraries as\n+    // static libraries.\n+    //\n+    // If the crate hasn't been included yet and it's not actually required\n+    // (e.g., it's an allocator) then we skip it here as well.\n+    for &cnum in tcx.crates().iter() {\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_none() &&\n+           !formats.contains_key(&cnum) &&\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n+            log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n+        }\n+    }\n+\n+    // We've gotten this far because we're emitting some form of a final\n+    // artifact which means that we may need to inject dependencies of some\n+    // form.\n+    //\n+    // Things like allocators and panic runtimes may not have been activated\n+    // quite yet, so do so here.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    // When dylib B links to dylib A, then when using B we must also link to A.\n+    // It could be the case, however, that the rlib for A is present (hence we\n+    // found metadata), but the dylib for A has since been removed.\n+    //\n+    // For situations like this, we perform one last pass over the dependencies,\n+    // making sure that everything is available in the requested format.\n+    for (cnum, kind) in ret.iter().enumerate() {\n+        let cnum = CrateNum::new(cnum + 1);\n+        let src = tcx.used_crate_source(cnum);\n+        match *kind {\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static if src.rlib.is_some() => continue,\n+            Linkage::Dynamic if src.dylib.is_some() => continue,\n+            kind => {\n+                let kind = match kind {\n+                    Linkage::Static => \"rlib\",\n+                    _ => \"dylib\",\n+                };\n+                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum), kind));\n+            }\n+        }\n+    }\n+\n+    ret\n+}\n+\n+fn add_library(\n+    tcx: TyCtxt<'_>,\n+    cnum: CrateNum,\n+    link: LinkagePreference,\n+    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n+) {\n+    match m.get(&cnum) {\n+        Some(&link2) => {\n+            // If the linkages differ, then we'd have two copies of the library\n+            // if we continued linking. If the linkages are both static, then we\n+            // would also have two copies of the library (static from two\n+            // different locations).\n+            //\n+            // This error is probably a little obscure, but I imagine that it\n+            // can be refined over time.\n+            if link2 != link || link == RequireStatic {\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n+                    .help(\"having upstream crates all available in one format \\\n+                           will likely make this go away\")\n+                    .emit();\n+            }\n+        }\n+        None => { m.insert(cnum, link); }\n+    }\n+}\n+\n+fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n+    let sess = &tcx.sess;\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n+    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n+        return None\n+    }\n+\n+    // All crates are available in an rlib format, so we're just going to link\n+    // everything in explicitly so long as it's actually required.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            Linkage::Static\n+        } else {\n+            Linkage::NotLinked\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Our allocator/panic runtime may not have been linked above if it wasn't\n+    // explicitly linked, which is the case for any injected dependency. Handle\n+    // that here and activate them.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    Some(ret)\n+}\n+\n+// Given a list of how to link upstream dependencies so far, ensure that an\n+// injected dependency is activated. This will not do anything if one was\n+// transitively included already (e.g., via a dylib or explicitly so).\n+//\n+// If an injected dependency was not found then we're guaranteed the\n+// metadata::creader module has injected that dependency (not listed as\n+// a required dependency) in one of the session's field. If this field is not\n+// set then this compilation doesn't actually need the dependency and we can\n+// also skip this step entirely.\n+fn activate_injected_dep(injected: Option<CrateNum>,\n+                         list: &mut DependencyList,\n+                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n+    for (i, slot) in list.iter().enumerate() {\n+        let cnum = CrateNum::new(i + 1);\n+        if !replaces_injected(cnum) {\n+            continue\n+        }\n+        if *slot != Linkage::NotLinked {\n+            return\n+        }\n+    }\n+    if let Some(injected) = injected {\n+        let idx = injected.as_usize() - 1;\n+        assert_eq!(list[idx], Linkage::NotLinked);\n+        list[idx] = Linkage::Static;\n+    }\n+}\n+\n+// After the linkage for a crate has been determined we need to verify that\n+// there's only going to be one allocator in the output.\n+fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n+    let sess = &tcx.sess;\n+    if list.len() == 0 {\n+        return\n+    }\n+    let mut panic_runtime = None;\n+    for (i, linkage) in list.iter().enumerate() {\n+        if let Linkage::NotLinked = *linkage {\n+            continue\n+        }\n+        let cnum = CrateNum::new(i + 1);\n+\n+        if tcx.is_panic_runtime(cnum) {\n+            if let Some((prev, _)) = panic_runtime {\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n+                sess.err(&format!(\"cannot link together two \\\n+                                   panic runtimes: {} and {}\",\n+                                  prev_name, cur_name));\n+            }\n+            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n+        }\n+    }\n+\n+    // If we found a panic runtime, then we know by this point that it's the\n+    // only one, but we perform validation here that all the panic strategy\n+    // compilation modes for the whole DAG are valid.\n+    if let Some((cnum, found_strategy)) = panic_runtime {\n+        let desired_strategy = sess.panic_strategy();\n+\n+        // First up, validate that our selected panic runtime is indeed exactly\n+        // our same strategy.\n+        if found_strategy != desired_strategy {\n+            sess.err(&format!(\"the linked panic runtime `{}` is \\\n+                               not compiled with this crate's \\\n+                               panic strategy `{}`\",\n+                              tcx.crate_name(cnum),\n+                              desired_strategy.desc()));\n+        }\n+\n+        // Next up, verify that all other crates are compatible with this panic\n+        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n+        // is abort then it's compatible with everything. Otherwise all crates'\n+        // panic strategy must match our own.\n+        for (i, linkage) in list.iter().enumerate() {\n+            if let Linkage::NotLinked = *linkage {\n+                continue\n+            }\n+            if desired_strategy == PanicStrategy::Abort {\n+                continue\n+            }\n+            let cnum = CrateNum::new(i + 1);\n+            let found_strategy = tcx.panic_strategy(cnum);\n+            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n+            if is_compiler_builtins || desired_strategy == found_strategy {\n+                continue\n+            }\n+\n+            sess.err(&format!(\"the crate `{}` is compiled with the \\\n+                               panic strategy `{}` which is \\\n+                               incompatible with this crate's \\\n+                               strategy of `{}`\",\n+                              tcx.crate_name(cnum),\n+                              found_strategy.desc(),\n+                              desired_strategy.desc()));\n+        }\n+    }\n+}"}, {"sha": "be083cf6020eaddf3e4d55edcc0b55f2be779e4c", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1649,20 +1649,22 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n-        match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n-            Some(arr) => {\n-                self.lazy(arr.iter().map(|slot| {\n-                    match *slot {\n-                        Linkage::NotLinked |\n-                        Linkage::IncludedFromDylib => None,\n-\n-                        Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n-                        Linkage::Static => Some(LinkagePreference::RequireStatic),\n-                    }\n-                }))\n+        let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n+        for (ty, arr) in formats.iter() {\n+            if *ty != config::CrateType::Dylib {\n+                continue;\n             }\n-            None => Lazy::empty(),\n+            return self.lazy(arr.iter().map(|slot| {\n+                match *slot {\n+                    Linkage::NotLinked |\n+                    Linkage::IncludedFromDylib => None,\n+\n+                    Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n+                    Linkage::Static => Some(LinkagePreference::RequireStatic),\n+                }\n+            }));\n         }\n+        Lazy::empty()\n     }\n \n     fn encode_info_for_foreign_item(&mut self,"}, {"sha": "9273b064ba9ceecc08821cc5adada0c484d699d7", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -32,6 +32,7 @@ mod schema;\n mod native_libs;\n mod link_args;\n mod foreign_modules;\n+mod dependency_format;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "9050e8f1671d9c790321dc72ee35a993db80f438", "filename": "src/test/codegen-units/partitioning/auxiliary/shared_generics_aux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fauxiliary%2Fshared_generics_aux.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1,4 +1,5 @@\n // compile-flags:-Zshare-generics=yes\n+// no-prefer-dynamic\n \n #![crate_type=\"rlib\"]\n "}, {"sha": "58e485be0032124577b629366771629fae44d438", "filename": "src/test/codegen-units/partitioning/shared-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fshared-generics.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -1,4 +1,5 @@\n // ignore-tidy-linelength\n+// no-prefer-dynamic\n // compile-flags:-Zprint-mono-items=eager -Zshare-generics=yes -Zincremental=tmp/partitioning-tests/shared-generics-exe\n \n #![crate_type=\"rlib\"]"}, {"sha": "671d44564e66fd3f64ea412c3852319a9a3363d5", "filename": "src/test/compile-fail/two-panic-runtimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftwo-panic-runtimes.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -5,6 +5,7 @@\n // aux-build:panic-runtime-lang-items.rs\n \n #![no_std]\n+#![no_main]\n \n extern crate panic_runtime_unwind;\n extern crate panic_runtime_unwind2;"}, {"sha": "b2c6b8b3cbbf2bf4d15e5fdc3b71681a799522ae", "filename": "src/test/run-make-fulldeps/issue-64319/Makefile", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2FMakefile?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -0,0 +1,39 @@\n+-include ../tools.mk\n+\n+# Different optimization levels imply different values for `-Zshare-generics`,\n+# so try out a whole bunch of combinations to make sure everything is compatible\n+all:\n+\t# First up, try some defaults\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\n+\t# Next try mixing up some things explicitly\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\n+\t# Now combine a whole bunch of options together\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=yes"}, {"sha": "3895c0b6cdbb3d760b7df23c8934eca5da0210e8", "filename": "src/test/run-make-fulldeps/issue-64319/bar.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Fbar.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -0,0 +1,5 @@\n+extern crate foo;\n+\n+pub fn bar() {\n+    foo::foo();\n+}"}, {"sha": "c54a238e9add7f8ae13a1602df43d48467bf2b57", "filename": "src/test/run-make-fulldeps/issue-64319/foo.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-64319%2Ffoo.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -0,0 +1,9 @@\n+pub fn foo() {\n+    bar::<usize>();\n+}\n+\n+pub fn bar<T>() {\n+    baz();\n+}\n+\n+fn baz() {}"}, {"sha": "840fe801a953c9ed4e7e35f8fd91ef5304b5ebb8", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -79,12 +79,12 @@ all:\n \t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]"}, {"sha": "5d72771c2dcff1bdff532ec1214b0acb67daa901", "filename": "src/test/ui/panic-runtime/transitive-link-a-bunch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Ftransitive-link-a-bunch.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -7,9 +7,8 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate wants_panic_runtime_unwind;\n extern crate wants_panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}, {"sha": "4c25c09d6438f3146ca04a355be849481707add5", "filename": "src/test/ui/panic-runtime/want-unwind-got-abort.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -4,8 +4,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}, {"sha": "478af451e7f657bbd73ecceb3ca5b180027019ca", "filename": "src/test/ui/panic-runtime/want-unwind-got-abort2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fae88fa82db350f1233b9b93df0be30e6579bc/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Fwant-unwind-got-abort2.rs?ref=40fae88fa82db350f1233b9b93df0be30e6579bc", "patch": "@@ -5,8 +5,7 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![no_std]\n+#![no_main]\n \n extern crate wants_panic_runtime_abort;\n extern crate panic_runtime_lang_items;\n-\n-fn main() {}"}]}