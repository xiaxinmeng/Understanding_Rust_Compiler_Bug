{"sha": "26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "node_id": "C_kwDOAAsO6NoAKDI2YjVlMGNiYjk1Y2U1YjFjYmY5MWQ0OWZiNDVkMTIyNDc5ZTMzNjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T01:23:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-06T01:23:08Z"}, "message": "Auto merge of #95469 - ChrisDenton:unsound-read-write, r=joshtriplett\n\nFix unsound `File` methods\n\nThis is a draft attempt to fix #81357. *EDIT*: this PR now tackles `read()`, `write()`, `read_at()`, `write_at()` and `read_buf`. Still needs more testing though.\n\ncc `@jstarks,` can you confirm the the Windows team is ok with the Rust stdlib using `NtReadFile` and `NtWriteFile`?\n\n~Also, I'm provisionally using `CancelIo` in a last ditch attempt to recover but I'm not sure that this is actually a good idea. Especially as getting into this state would be a programmer error so aborting the process is justified in any case.~ *EDIT*: removed, see comments.", "tree": {"sha": "905fd9705e209bfa9738bf7259f37df34e73988f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/905fd9705e209bfa9738bf7259f37df34e73988f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "html_url": "https://github.com/rust-lang/rust/commit/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbe9d27b8ff36da56638aa43d6d0cdfdf89a4e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe9d27b8ff36da56638aa43d6d0cdfdf89a4e57", "html_url": "https://github.com/rust-lang/rust/commit/bbe9d27b8ff36da56638aa43d6d0cdfdf89a4e57"}, {"sha": "d2ce150c8c28b69bf406deb0920fcb4ca0d950ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ce150c8c28b69bf406deb0920fcb4ca0d950ae", "html_url": "https://github.com/rust-lang/rust/commit/d2ce150c8c28b69bf406deb0920fcb4ca0d950ae"}], "stats": {"total": 233, "additions": 155, "deletions": 78}, "files": [{"sha": "10c424269c7d14ba556443abdc707e077287884c", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "patch": "@@ -85,6 +85,12 @@ use crate::time::SystemTime;\n /// by different processes. Avoid assuming that holding a `&File` means that the\n /// file will not change.\n ///\n+/// # Platform-specific behavior\n+///\n+/// On Windows, the implementation of [`Read`] and [`Write`] traits for `File`\n+/// perform synchronous I/O operations. Therefore the underlying file must not\n+/// have been opened for asynchronous I/O (e.g. by using `FILE_FLAG_OVERLAPPED`).\n+///\n /// [`BufReader<R>`]: io::BufReader\n /// [`sync_all`]: File::sync_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "336264d99f90030e40188d0714f234d6f40bb016", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "patch": "@@ -274,6 +274,9 @@ pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n \n+pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n+pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n+\n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n pub fn nt_success(status: NTSTATUS) -> bool {\n@@ -316,22 +319,34 @@ impl Default for OBJECT_ATTRIBUTES {\n     }\n }\n #[repr(C)]\n-pub struct IO_STATUS_BLOCK {\n-    pub Pointer: *mut c_void,\n-    pub Information: usize,\n+union IO_STATUS_BLOCK_union {\n+    Status: NTSTATUS,\n+    Pointer: *mut c_void,\n }\n-impl Default for IO_STATUS_BLOCK {\n+impl Default for IO_STATUS_BLOCK_union {\n     fn default() -> Self {\n-        Self { Pointer: ptr::null_mut(), Information: 0 }\n+        Self { Pointer: ptr::null_mut() }\n     }\n }\n+#[repr(C)]\n+#[derive(Default)]\n+pub struct IO_STATUS_BLOCK {\n+    u: IO_STATUS_BLOCK_union,\n+    pub Information: usize,\n+}\n \n pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n     dwErrorCode: DWORD,\n     dwNumberOfBytesTransfered: DWORD,\n     lpOverlapped: *mut OVERLAPPED,\n );\n \n+type IO_APC_ROUTINE = unsafe extern \"system\" fn(\n+    ApcContext: *mut c_void,\n+    IoStatusBlock: *mut IO_STATUS_BLOCK,\n+    Reserved: ULONG,\n+);\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -971,13 +986,6 @@ extern \"system\" {\n         lpOverlapped: LPOVERLAPPED,\n         lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n     ) -> BOOL;\n-    pub fn WriteFile(\n-        hFile: BorrowedHandle<'_>,\n-        lpBuffer: LPVOID,\n-        nNumberOfBytesToWrite: DWORD,\n-        lpNumberOfBytesWritten: LPDWORD,\n-        lpOverlapped: LPOVERLAPPED,\n-    ) -> BOOL;\n     pub fn WriteFileEx(\n         hFile: BorrowedHandle<'_>,\n         lpBuffer: LPVOID,\n@@ -1268,6 +1276,32 @@ compat_fn! {\n     ) -> NTSTATUS {\n         panic!(\"`NtCreateFile` not available\");\n     }\n+    pub fn NtReadFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *mut crate::mem::MaybeUninit<u8>,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>\n+    ) -> NTSTATUS {\n+        panic!(\"`NtReadFile` not available\");\n+    }\n+    pub fn NtWriteFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *const u8,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>\n+    ) -> NTSTATUS {\n+        panic!(\"`NtWriteFile` not available\");\n+    }\n     pub fn RtlNtStatusToDosError(\n         Status: NTSTATUS\n     ) -> ULONG {"}, {"sha": "ef9a8bd690031c0fbf5dda54da5d87fc6b39c858", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 103, "deletions": 66, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b5e0cbb95ce5b1cbf91d49fb45d122479e3363/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=26b5e0cbb95ce5b1cbf91d49fb45d122479e3363", "patch": "@@ -74,20 +74,10 @@ impl FromRawHandle for Handle {\n \n impl Handle {\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = cvt(unsafe {\n-            c::ReadFile(\n-                self.as_handle(),\n-                buf.as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                ptr::null_mut(),\n-            )\n-        });\n+        let res = unsafe { self.synchronous_read(buf.as_mut_ptr().cast(), buf.len(), None) };\n \n         match res {\n-            Ok(_) => Ok(read as usize),\n+            Ok(read) => Ok(read as usize),\n \n             // The special treatment of BrokenPipe is to deal with Windows\n             // pipe semantics, which yields this error when *reading* from\n@@ -109,42 +99,23 @@ impl Handle {\n     }\n \n     pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = unsafe {\n-            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n-            overlapped.Offset = offset as u32;\n-            overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::ReadFile(\n-                self.as_handle(),\n-                buf.as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                &mut overlapped,\n-            ))\n-        };\n+        let res =\n+            unsafe { self.synchronous_read(buf.as_mut_ptr().cast(), buf.len(), Some(offset)) };\n+\n         match res {\n-            Ok(_) => Ok(read as usize),\n+            Ok(read) => Ok(read as usize),\n             Err(ref e) if e.raw_os_error() == Some(c::ERROR_HANDLE_EOF as i32) => Ok(0),\n             Err(e) => Err(e),\n         }\n     }\n \n     pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let mut read = 0;\n-        let len = cmp::min(buf.remaining(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        let res = cvt(unsafe {\n-            c::ReadFile(\n-                self.as_handle(),\n-                buf.unfilled_mut().as_mut_ptr() as c::LPVOID,\n-                len,\n-                &mut read,\n-                ptr::null_mut(),\n-            )\n-        });\n+        let res = unsafe {\n+            self.synchronous_read(buf.unfilled_mut().as_mut_ptr(), buf.remaining(), None)\n+        };\n \n         match res {\n-            Ok(_) => {\n+            Ok(read) => {\n                 // Safety: `read` bytes were written to the initialized portion of the buffer\n                 unsafe {\n                     buf.assume_init(read as usize);\n@@ -221,18 +192,7 @@ impl Handle {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let mut amt = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        cvt(unsafe {\n-            c::WriteFile(\n-                self.as_handle(),\n-                buf.as_ptr() as c::LPVOID,\n-                len,\n-                &mut amt,\n-                ptr::null_mut(),\n-            )\n-        })?;\n-        Ok(amt as usize)\n+        self.synchronous_write(&buf, None)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -245,21 +205,7 @@ impl Handle {\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        let mut written = 0;\n-        let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n-        unsafe {\n-            let mut overlapped: c::OVERLAPPED = mem::zeroed();\n-            overlapped.Offset = offset as u32;\n-            overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::WriteFile(\n-                self.as_handle(),\n-                buf.as_ptr() as c::LPVOID,\n-                len,\n-                &mut written,\n-                &mut overlapped,\n-            ))?;\n-        }\n-        Ok(written as usize)\n+        self.synchronous_write(&buf, Some(offset))\n     }\n \n     pub fn try_clone(&self) -> io::Result<Self> {\n@@ -274,6 +220,97 @@ impl Handle {\n     ) -> io::Result<Self> {\n         Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n+\n+    /// Performs a synchronous read.\n+    ///\n+    /// If the handle is opened for asynchronous I/O then this abort the process.\n+    /// See #81357.\n+    ///\n+    /// If `offset` is `None` then the current file position is used.\n+    unsafe fn synchronous_read(\n+        &self,\n+        buf: *mut mem::MaybeUninit<u8>,\n+        len: usize,\n+        offset: Option<u64>,\n+    ) -> io::Result<usize> {\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+\n+        // The length is clamped at u32::MAX.\n+        let len = cmp::min(len, c::DWORD::MAX as usize) as c::DWORD;\n+        let status = c::NtReadFile(\n+            self.as_handle(),\n+            ptr::null_mut(),\n+            None,\n+            ptr::null_mut(),\n+            &mut io_status,\n+            buf,\n+            len,\n+            offset.map(|n| n as _).as_ref(),\n+            None,\n+        );\n+        match status {\n+            // If the operation has not completed then abort the process.\n+            // Doing otherwise means that the buffer and stack may be written to\n+            // after this function returns.\n+            c::STATUS_PENDING => {\n+                eprintln!(\"I/O error: operation failed to complete synchronously\");\n+                crate::process::abort();\n+            }\n+\n+            // Return `Ok(0)` when there's nothing more to read.\n+            c::STATUS_END_OF_FILE => Ok(0),\n+\n+            // Success!\n+            status if c::nt_success(status) => Ok(io_status.Information),\n+\n+            status => {\n+                let error = c::RtlNtStatusToDosError(status);\n+                Err(io::Error::from_raw_os_error(error as _))\n+            }\n+        }\n+    }\n+\n+    /// Performs a synchronous write.\n+    ///\n+    /// If the handle is opened for asynchronous I/O then this abort the process.\n+    /// See #81357.\n+    ///\n+    /// If `offset` is `None` then the current file position is used.\n+    fn synchronous_write(&self, buf: &[u8], offset: Option<u64>) -> io::Result<usize> {\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+\n+        // The length is clamped at u32::MAX.\n+        let len = cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let status = unsafe {\n+            c::NtWriteFile(\n+                self.as_handle(),\n+                ptr::null_mut(),\n+                None,\n+                ptr::null_mut(),\n+                &mut io_status,\n+                buf.as_ptr(),\n+                len,\n+                offset.map(|n| n as _).as_ref(),\n+                None,\n+            )\n+        };\n+        match status {\n+            // If the operation has not completed then abort the process.\n+            // Doing otherwise means that the buffer may be read and the stack\n+            // written to after this function returns.\n+            c::STATUS_PENDING => {\n+                rtabort!(\"I/O error: operation failed to complete synchronously\");\n+            }\n+\n+            // Success!\n+            status if c::nt_success(status) => Ok(io_status.Information),\n+\n+            status => {\n+                let error = unsafe { c::RtlNtStatusToDosError(status) };\n+                Err(io::Error::from_raw_os_error(error as _))\n+            }\n+        }\n+    }\n }\n \n impl<'a> Read for &'a Handle {"}]}