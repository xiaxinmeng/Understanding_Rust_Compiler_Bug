{"sha": "3fee48c161a48b0c142d3998fff56faee96bd56c", "node_id": "C_kwDOAAsO6NoAKDNmZWU0OGMxNjFhNDhiMGMxNDJkMzk5OGZmZjU2ZmFlZTk2YmQ1NmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T07:02:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T07:02:57Z"}, "message": "Auto merge of #104754 - nnethercote:more-ThinVec-in-ast, r=the8472\n\nUse `ThinVec` more in the AST\n\nr? `@ghost`", "tree": {"sha": "41141e3c4989dfd1b4b83a9fd25312150d45fdd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41141e3c4989dfd1b4b83a9fd25312150d45fdd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fee48c161a48b0c142d3998fff56faee96bd56c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fee48c161a48b0c142d3998fff56faee96bd56c", "html_url": "https://github.com/rust-lang/rust/commit/3fee48c161a48b0c142d3998fff56faee96bd56c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fee48c161a48b0c142d3998fff56faee96bd56c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f715e430aac0de131e2ad21804013ea405722a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/f715e430aac0de131e2ad21804013ea405722a66", "html_url": "https://github.com/rust-lang/rust/commit/f715e430aac0de131e2ad21804013ea405722a66"}, {"sha": "9c7570b4293f9eea593cdd8334d6ccba651f91c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7570b4293f9eea593cdd8334d6ccba651f91c1", "html_url": "https://github.com/rust-lang/rust/commit/9c7570b4293f9eea593cdd8334d6ccba651f91c1"}], "stats": {"total": 1067, "additions": 586, "deletions": 481}, "files": [{"sha": "1acbcb00f65d6c0dabd35d9b3e2f586b21722ad0", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -3689,6 +3689,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -3698,6 +3699,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n  \"rustc_span\",\n+ \"thin-vec\",\n ]\n \n [[package]]\n@@ -4071,6 +4073,7 @@ dependencies = [\n  \"rustc_trait_selection\",\n  \"rustc_type_ir\",\n  \"smallvec\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4127,6 +4130,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"thin-vec\",\n  \"tracing\",\n ]\n \n@@ -4826,7 +4830,6 @@ dependencies = [\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n- \"thin-vec\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -5502,9 +5505,9 @@ checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thin-vec\"\n-version = \"0.2.9\"\n+version = \"0.2.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ceb05e71730d396f960f8f3901cdb41be2d339b303e9d7d3a07c5ff0536e671b\"\n+checksum = \"aac81b6fd6beb5884b0cf3321b8117e6e5d47ecb6fc89f414cfdcca8b2fe2dd8\"\n \n [[package]]\n name = \"thiserror\""}, {"sha": "f0632ac92e96f3698dc9806a5fa70f46b1f5ae49", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -15,5 +15,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "03c375c46668ab6a12b3c19e6fd48a0e0db3569a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -209,7 +209,7 @@ pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n     /// The comma separated parts in the `<...>`.\n-    pub args: Vec<AngleBracketedArg>,\n+    pub args: ThinVec<AngleBracketedArg>,\n }\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n@@ -253,7 +253,7 @@ pub struct ParenthesizedArgs {\n     pub span: Span,\n \n     /// `(A, B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: ThinVec<P<Ty>>,\n \n     /// ```text\n     /// Foo(A, B) -> C\n@@ -384,15 +384,15 @@ impl GenericParam {\n /// a function, enum, trait, etc.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n-    pub params: Vec<GenericParam>,\n+    pub params: ThinVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() -> Generics {\n-        Generics { params: Vec::new(), where_clause: Default::default(), span: DUMMY_SP }\n+        Generics { params: ThinVec::new(), where_clause: Default::default(), span: DUMMY_SP }\n     }\n }\n \n@@ -403,13 +403,13 @@ pub struct WhereClause {\n     /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to pretty-print accurately.\n     pub has_where_token: bool,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: ThinVec<WherePredicate>,\n     pub span: Span,\n }\n \n impl Default for WhereClause {\n     fn default() -> WhereClause {\n-        WhereClause { has_where_token: false, predicates: Vec::new(), span: DUMMY_SP }\n+        WhereClause { has_where_token: false, predicates: ThinVec::new(), span: DUMMY_SP }\n     }\n }\n \n@@ -441,7 +441,7 @@ impl WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n     /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone + Send + 'static`).\n@@ -471,7 +471,7 @@ pub struct WhereEqPredicate {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n     pub attrs: AttrVec,\n-    pub items: Vec<P<Item>>,\n+    pub items: ThinVec<P<Item>>,\n     pub spans: ModSpans,\n     /// Must be equal to `CRATE_NODE_ID` after the crate root is expanded, but may hold\n     /// expansion placeholders or an unassigned value (`DUMMY_NODE_ID`) before that.\n@@ -503,7 +503,7 @@ pub enum MetaItemKind {\n     /// List meta item.\n     ///\n     /// E.g., `#[derive(..)]`, where the field represents the `..`.\n-    List(Vec<NestedMetaItem>),\n+    List(ThinVec<NestedMetaItem>),\n \n     /// Name value meta item.\n     ///\n@@ -531,7 +531,7 @@ pub enum NestedMetaItem {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: ThinVec<Stmt>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n@@ -581,7 +581,7 @@ impl Pat {\n             // A tuple pattern `(P0, .., Pn)` can be reparsed as `(T0, .., Tn)`\n             // assuming `T0` to `Tn` are all syntactically valid as types.\n             PatKind::Tuple(pats) => {\n-                let mut tys = Vec::with_capacity(pats.len());\n+                let mut tys = ThinVec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n                 for pat in pats {\n                     tys.push(pat.to_ty()?);\n@@ -722,14 +722,14 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Option<P<QSelf>>, Path, Vec<PatField>, /* recovered */ bool),\n+    Struct(Option<P<QSelf>>, Path, ThinVec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Option<P<QSelf>>, Path, Vec<P<Pat>>),\n+    TupleStruct(Option<P<QSelf>>, Path, ThinVec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(Vec<P<Pat>>),\n+    Or(ThinVec<P<Pat>>),\n \n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n@@ -738,7 +738,7 @@ pub enum PatKind {\n     Path(Option<P<QSelf>>, Path),\n \n     /// A tuple pattern (`(a, b)`).\n-    Tuple(Vec<P<Pat>>),\n+    Tuple(ThinVec<P<Pat>>),\n \n     /// A `box` pattern.\n     Box(P<Pat>),\n@@ -753,7 +753,7 @@ pub enum PatKind {\n     Range(Option<P<Expr>>, Option<P<Expr>>, Spanned<RangeEnd>),\n \n     /// A slice pattern `[a, b, c]`.\n-    Slice(Vec<P<Pat>>),\n+    Slice(ThinVec<P<Pat>>),\n \n     /// A rest pattern `..`.\n     ///\n@@ -1169,7 +1169,7 @@ impl Expr {\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n-                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                PolyTraitRef::new(ThinVec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n             )),\n             _ => None,\n@@ -1204,7 +1204,7 @@ impl Expr {\n             ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n \n             ExprKind::Tup(exprs) => {\n-                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<Vec<_>>>()?;\n+                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<ThinVec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n \n@@ -1337,7 +1337,7 @@ pub struct MethodCall {\n     /// The receiver, e.g. `x`.\n     pub receiver: P<Expr>,\n     /// The arguments, e.g. `a, b, c`.\n-    pub args: Vec<P<Expr>>,\n+    pub args: ThinVec<P<Expr>>,\n     /// The span of the function, without the dot and receiver e.g. `foo::<Bar,\n     /// Baz>(a, b, c)`.\n     pub span: Span,\n@@ -1357,7 +1357,7 @@ pub enum StructRest {\n pub struct StructExpr {\n     pub qself: Option<P<QSelf>>,\n     pub path: Path,\n-    pub fields: Vec<ExprField>,\n+    pub fields: ThinVec<ExprField>,\n     pub rest: StructRest,\n }\n \n@@ -1366,7 +1366,7 @@ pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    Array(Vec<P<Expr>>),\n+    Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n     /// A function call\n@@ -1375,11 +1375,11 @@ pub enum ExprKind {\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, Vec<P<Expr>>),\n+    Call(P<Expr>, ThinVec<P<Expr>>),\n     /// A method call (e.g. `x.foo::<Bar, Baz>(a, b, c)`).\n     MethodCall(Box<MethodCall>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(Vec<P<Expr>>),\n+    Tup(ThinVec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (e.g., `!x`, `*x`).\n@@ -1414,7 +1414,7 @@ pub enum ExprKind {\n     /// `'label: loop { block }`\n     Loop(P<Block>, Option<Label>, Span),\n     /// A `match` block.\n-    Match(P<Expr>, Vec<Arm>),\n+    Match(P<Expr>, ThinVec<Arm>),\n     /// A closure (e.g., `move |a, b, c| a + b + c`).\n     Closure(Box<Closure>),\n     /// A block (`'label: { ... }`).\n@@ -1574,7 +1574,7 @@ pub enum ClosureBinder {\n         /// for<'a, 'b> |_: &'a (), _: &'b ()| { ... }\n         ///     ^^^^^^ -- this\n         /// ```\n-        generic_params: P<[GenericParam]>,\n+        generic_params: ThinVec<GenericParam>,\n     },\n }\n \n@@ -2056,7 +2056,7 @@ impl Ty {\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: ThinVec<GenericParam>,\n     pub decl: P<FnDecl>,\n     /// Span of the `fn(...) -> ...` part.\n     pub decl_span: Span,\n@@ -2078,7 +2078,7 @@ pub enum TyKind {\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n-    Tup(Vec<P<Ty>>),\n+    Tup(ThinVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -2363,7 +2363,7 @@ impl Param {\n /// which contains metadata about function safety, asyncness, constness and ABI.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Param>,\n+    pub inputs: ThinVec<Param>,\n     pub output: FnRetTy,\n }\n \n@@ -2475,7 +2475,7 @@ pub enum ModKind {\n     /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n     /// The inner span is from the first token past `{` to the last token until `}`,\n     /// or from the first to the last token in the loaded file.\n-    Loaded(Vec<P<Item>>, Inline, ModSpans),\n+    Loaded(ThinVec<P<Item>>, Inline, ModSpans),\n     /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n     Unloaded,\n }\n@@ -2497,12 +2497,12 @@ pub struct ForeignMod {\n     /// semantically by Rust.\n     pub unsafety: Unsafe,\n     pub abi: Option<StrLit>,\n-    pub items: Vec<P<ForeignItem>>,\n+    pub items: ThinVec<P<ForeignItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: ThinVec<Variant>,\n }\n /// Enum variant.\n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2532,7 +2532,7 @@ pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     Simple(Option<Ident>),\n     /// `use prefix::{...}`\n-    Nested(Vec<(UseTree, NodeId)>),\n+    Nested(ThinVec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n     Glob,\n }\n@@ -2636,7 +2636,7 @@ pub struct TraitRef {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n@@ -2645,7 +2645,7 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n+    pub fn new(generic_params: ThinVec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n             trait_ref: TraitRef { path, ref_id: DUMMY_NODE_ID },\n@@ -2695,11 +2695,11 @@ pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<FieldDef>, bool),\n+    Struct(ThinVec<FieldDef>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(Vec<FieldDef>, NodeId),\n+    Tuple(ThinVec<FieldDef>, NodeId),\n     /// Unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n@@ -2826,7 +2826,7 @@ pub struct Trait {\n     pub is_auto: IsAuto,\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n /// The location of a where clause on a `TyAlias` (`Span`) and whether there was\n@@ -2874,7 +2874,7 @@ pub struct Impl {\n     /// The trait being implemented, if any.\n     pub of_trait: Option<TraitRef>,\n     pub self_ty: P<Ty>,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -3112,26 +3112,26 @@ mod size_asserts {\n     static_assert_size!(AssocItem, 104);\n     static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n-    static_assert_size!(Block, 48);\n+    static_assert_size!(Block, 32);\n     static_assert_size!(Expr, 72);\n     static_assert_size!(ExprKind, 40);\n-    static_assert_size!(Fn, 184);\n+    static_assert_size!(Fn, 152);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericArg, 24);\n-    static_assert_size!(GenericBound, 72);\n-    static_assert_size!(Generics, 72);\n-    static_assert_size!(Impl, 184);\n-    static_assert_size!(Item, 184);\n-    static_assert_size!(ItemKind, 112);\n+    static_assert_size!(GenericBound, 56);\n+    static_assert_size!(Generics, 40);\n+    static_assert_size!(Impl, 136);\n+    static_assert_size!(Item, 136);\n+    static_assert_size!(ItemKind, 64);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n     static_assert_size!(MetaItemLit, 40);\n     static_assert_size!(Param, 40);\n-    static_assert_size!(Pat, 88);\n+    static_assert_size!(Pat, 72);\n     static_assert_size!(Path, 24);\n     static_assert_size!(PathSegment, 24);\n-    static_assert_size!(PatKind, 64);\n+    static_assert_size!(PatKind, 48);\n     static_assert_size!(Stmt, 32);\n     static_assert_size!(StmtKind, 16);\n     static_assert_size!(Ty, 64);"}, {"sha": "2e83b3e623f075c4f3ace79abb5f2c591e9eb8aa", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -20,7 +20,7 @@ use std::iter;\n use std::ops::BitXor;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicU32, Ordering};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n@@ -135,7 +135,7 @@ impl Attribute {\n         }\n     }\n \n-    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    pub fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.kind {\n             AttrKind::Normal(normal) => normal.item.meta_item_list(),\n             AttrKind::DocComment(..) => None,\n@@ -216,7 +216,7 @@ impl AttrItem {\n         self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n     }\n \n-    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+    fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.args {\n             AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n                 MetaItemKind::list_from_tokens(args.tokens.clone())\n@@ -375,9 +375,9 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn list_from_tokens(tokens: TokenStream) -> Option<Vec<NestedMetaItem>> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<ThinVec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n-        let mut result = Vec::new();\n+        let mut result = ThinVec::new();\n         while tokens.peek().is_some() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n             result.push(item);"}, {"sha": "7dcb03b4c786cd98bf297b5e148135f7ad9e2ae6", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -17,10 +17,10 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n-\n use smallvec::{smallvec, Array, SmallVec};\n use std::ops::DerefMut;\n use std::{panic, ptr};\n+use thin_vec::ThinVec;\n \n pub trait ExpectOne<A: Array> {\n     fn expect_one(self, err: &'static str) -> A::Item;\n@@ -335,6 +335,17 @@ where\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+#[inline]\n+pub fn visit_thin_vec<T, F>(elems: &mut ThinVec<T>, mut visit_elem: F)\n+where\n+    F: FnMut(&mut T),\n+{\n+    for elem in elems {\n+        visit_elem(elem);\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n #[inline]\n pub fn visit_opt<T, F>(opt: &mut Option<T>, mut visit_elem: F)\n@@ -358,6 +369,11 @@ pub fn visit_exprs<T: MutVisitor>(exprs: &mut Vec<P<Expr>>, vis: &mut T) {\n     exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_thin_exprs<T: MutVisitor>(exprs: &mut ThinVec<P<Expr>>, vis: &mut T) {\n+    exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n     visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n@@ -474,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_fn_decl(decl);\n             vis.visit_span(decl_span);\n         }\n-        TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n+        TyKind::Tup(tys) => visit_thin_vec(tys, |ty| vis.visit_ty(ty)),\n         TyKind::Paren(ty) => vis.visit_ty(ty),\n         TyKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -561,7 +577,7 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let AngleBracketedArgs { args, span } = data;\n-    visit_vec(args, |arg| match arg {\n+    visit_thin_vec(args, |arg| match arg {\n         AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n         AngleBracketedArg::Constraint(constraint) => vis.visit_constraint(constraint),\n     });\n@@ -573,7 +589,7 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let ParenthesizedArgs { inputs, output, span, .. } = args;\n-    visit_vec(inputs, |input| vis.visit_ty(input));\n+    visit_thin_vec(inputs, |input| vis.visit_ty(input));\n     noop_visit_fn_ret_ty(output, vis);\n     vis.visit_span(span);\n }\n@@ -636,7 +652,7 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     let MetaItem { path: _, kind, span } = mi;\n     match kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n+        MetaItemKind::List(mis) => visit_thin_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n         MetaItemKind::NameValue(_s) => {}\n     }\n     vis.visit_span(span);\n@@ -839,9 +855,7 @@ pub fn noop_visit_closure_binder<T: MutVisitor>(binder: &mut ClosureBinder, vis:\n     match binder {\n         ClosureBinder::NotPresent => {}\n         ClosureBinder::For { span: _, generic_params } => {\n-            let mut vec = std::mem::take(generic_params).into_vec();\n-            vec.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n-            *generic_params = P::from_vec(vec);\n+            generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n         }\n     }\n }\n@@ -919,7 +933,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n     let WhereClause { has_where_token: _, predicates, span } = wc;\n-    visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n+    visit_thin_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }\n \n@@ -1227,7 +1241,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::TupleStruct(qself, path, elems) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n-            visit_vec(elems, |elem| vis.visit_pat(elem));\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -1246,7 +1260,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             vis.visit_span(span);\n         }\n         PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n-            visit_vec(elems, |elem| vis.visit_pat(elem))\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem))\n         }\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::MacCall(mac) => vis.visit_mac_call(mac),\n@@ -1303,18 +1317,18 @@ pub fn noop_visit_expr<T: MutVisitor>(\n ) {\n     match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n-        ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);\n         }\n         ExprKind::Repeat(expr, count) => {\n             vis.visit_expr(expr);\n             vis.visit_anon_const(count);\n         }\n-        ExprKind::Tup(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Tup(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::Call(f, args) => {\n             vis.visit_expr(f);\n-            visit_exprs(args, vis);\n+            visit_thin_exprs(args, vis);\n         }\n         ExprKind::MethodCall(box MethodCall {\n             seg: PathSegment { ident, id, args: seg_args },\n@@ -1326,7 +1340,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_id(id);\n             visit_opt(seg_args, |args| vis.visit_generic_args(args));\n             vis.visit_method_receiver_expr(receiver);\n-            visit_exprs(call_args, vis);\n+            visit_thin_exprs(call_args, vis);\n             vis.visit_span(span);\n         }\n         ExprKind::Binary(_binop, lhs, rhs) => {"}, {"sha": "eb2e82d7988c955dca73cac97523f14e89df1776", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -19,5 +19,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "dfe790b485123275e9a74b86788d90c1bd35cc1e", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -18,7 +18,7 @@ use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -367,7 +367,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_legacy_const_generics(\n         &mut self,\n         mut f: Expr,\n-        args: Vec<AstP<Expr>>,\n+        args: ThinVec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n         let ExprKind::Path(None, path) = &mut f.kind else {\n@@ -376,7 +376,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Split the arguments into const generics and normal arguments\n         let mut real_args = vec![];\n-        let mut generic_args = vec![];\n+        let mut generic_args = ThinVec::new();\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n                 let parent_def_id = self.current_hir_id_owner;"}, {"sha": "b1b9344d2535c6f17409570326cfa73b15aea1e2", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -66,9 +66,9 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n use smallvec::SmallVec;\n use std::collections::hash_map::Entry;\n+use thin_vec::ThinVec;\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => (\n@@ -1207,7 +1207,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                 let bound = this.lower_poly_trait_ref(\n                     &PolyTraitRef {\n-                        bound_generic_params: vec![],\n+                        bound_generic_params: ThinVec::new(),\n                         trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n                         span: t.span\n                     },"}, {"sha": "8bd212073a65a8ada361244ff56b47a1624eb053", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n itertools = \"0.10.1\"\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n@@ -16,4 +16,5 @@ rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "afa29a510d22ae84948aa561bdd35a8924ae78d7", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -27,6 +27,7 @@ use rustc_span::Span;\n use rustc_target::spec::abi;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n+use thin_vec::thin_vec;\n \n use crate::errors::*;\n \n@@ -1615,7 +1616,7 @@ fn deny_equality_constraints(\n                                         empty_args => {\n                                             *empty_args = AngleBracketedArgs {\n                                                 span: ident.span,\n-                                                args: vec![arg],\n+                                                args: thin_vec![arg],\n                                             }\n                                             .into();\n                                         }"}, {"sha": "6f7ba7a5ad77c5045491c5abdcef7fa3a82012de", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -10,6 +10,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n use crate::errors::ForbiddenLifetimeBound;\n \n@@ -250,7 +252,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Struct(..) => {\n                 for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n-                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,"}, {"sha": "bbcbecd81313d4a3dd3103c52d55648ae68e2631", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -11,9 +11,6 @@\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n \n-#[macro_use]\n-extern crate tracing;\n-\n pub mod ast_validation;\n mod errors;\n pub mod feature_gate;"}, {"sha": "980a8fa93a97d531c1647b902d36e21857f1bd39", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -8,3 +8,4 @@ edition = \"2021\"\n [dependencies]\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n+thin-vec = \"0.2.12\""}, {"sha": "694d688bf1fe0190f557f367c1bd2fd58d7c4065", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -4,7 +4,7 @@ mod item;\n \n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n-\n+use rustc_ast::attr::AttrIdGenerator;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, CommentKind, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -20,9 +20,8 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n-\n-use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n+use thin_vec::ThinVec;\n \n pub use self::delimited::IterDelimited;\n \n@@ -1722,10 +1721,10 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.print_formal_generic_params(generic_params);\n         let generics = ast::Generics {\n-            params: Vec::new(),\n+            params: ThinVec::new(),\n             where_clause: ast::WhereClause {\n                 has_where_token: false,\n-                predicates: Vec::new(),\n+                predicates: ThinVec::new(),\n                 span: DUMMY_SP,\n             },\n             span: DUMMY_SP,"}, {"sha": "3b2b60a86f06e8d5728a6b0539290f6c9fd3c414", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -3,6 +3,7 @@ use super::*;\n use rustc_ast as ast;\n use rustc_span::create_default_session_globals_then;\n use rustc_span::symbol::Ident;\n+use thin_vec::ThinVec;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,\n@@ -27,8 +28,10 @@ fn test_fun_to_string() {\n     create_default_session_globals_then(|| {\n         let abba_ident = Ident::from_str(\"abba\");\n \n-        let decl =\n-            ast::FnDecl { inputs: Vec::new(), output: ast::FnRetTy::Default(rustc_span::DUMMY_SP) };\n+        let decl = ast::FnDecl {\n+            inputs: ThinVec::new(),\n+            output: ast::FnRetTy::Default(rustc_span::DUMMY_SP),\n+        };\n         let generics = ast::Generics::default();\n         assert_eq!(\n             fun_to_string(&decl, ast::FnHeader::default(), abba_ident, &generics),"}, {"sha": "336e14ef966309103e09cbfcc142942a222b2318", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -23,5 +23,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "ac6697232cb827f8afe85f13c03aad3d97ed7dda", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -39,10 +39,10 @@ pub fn expand(\n     let span = ecx.with_def_site_ctxt(item.span);\n \n     // Generate item statements for the allocator methods.\n-    let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n+    let stmts = thin_vec![generate_handler(ecx, item.ident, span, sig_span)];\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -67,13 +67,16 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n \n     let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n     let layout_new = cx.expr_path(cx.path(span, layout_new));\n-    let layout =\n-        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+    let layout = cx.expr_call(\n+        span,\n+        layout_new,\n+        thin_vec![cx.expr_ident(span, size), cx.expr_ident(span, align)],\n+    );\n \n-    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+    let call = cx.expr_call_ident(sig_span, handler, thin_vec![layout]);\n \n     let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n-    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let params = thin_vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n     let decl = cx.fn_decl(params, never);\n     let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n     let sig = FnSig { decl, header, span: span };"}, {"sha": "75af5e2b1fade53652b502ecfc35601f63c65c61", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -11,6 +11,7 @@ use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n use rustc_parse::parser::Parser;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use thin_vec::thin_vec;\n \n pub fn expand_assert<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -79,7 +80,7 @@ pub fn expand_assert<'cx>(\n         let then = cx.expr_call_global(\n             call_site_span,\n             cx.std_path(&[sym::panicking, sym::panic]),\n-            vec![cx.expr_str(\n+            thin_vec![cx.expr_str(\n                 DUMMY_SP,\n                 Symbol::intern(&format!(\n                     \"assertion failed: {}\","}, {"sha": "b0b4dda16aff2c38069c3f18f5ed4b3e4860b16f", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{\n     symbol::{sym, Ident, Symbol},\n     Span,\n };\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub(super) struct Context<'cx, 'a> {\n     // An optimization.\n@@ -83,12 +83,12 @@ impl<'cx, 'a> Context<'cx, 'a> {\n \n         let Self { best_case_captures, capture_decls, cx, local_bind_decls, span, .. } = self;\n \n-        let mut assert_then_stmts = Vec::with_capacity(2);\n+        let mut assert_then_stmts = ThinVec::with_capacity(2);\n         assert_then_stmts.extend(best_case_captures);\n         assert_then_stmts.push(self.cx.stmt_expr(panic));\n         let assert_then = self.cx.block(span, assert_then_stmts);\n \n-        let mut stmts = Vec::with_capacity(4);\n+        let mut stmts = ThinVec::with_capacity(4);\n         stmts.push(initial_imports);\n         stmts.extend(capture_decls.into_iter().map(|c| c.decl));\n         stmts.extend(local_bind_decls);\n@@ -120,7 +120,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n-                    kind: UseTreeKind::Nested(vec![\n+                    kind: UseTreeKind::Nested(thin_vec![\n                         nested_tree(self, sym::TryCaptureGeneric),\n                         nested_tree(self, sym::TryCapturePrintable),\n                     ]),\n@@ -136,7 +136,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, unlikely_path)),\n-            vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n+            thin_vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n         )\n     }\n \n@@ -339,7 +339,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         let init = self.cx.expr_call(\n             self.span,\n             self.cx.expr_path(self.cx.path(self.span, init_std_path)),\n-            vec![],\n+            ThinVec::new(),\n         );\n         let capture = Capture { decl: self.cx.stmt_let(self.span, true, ident, init), ident };\n         self.capture_decls.push(capture);\n@@ -366,7 +366,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.expr_path(\n                 self.cx.path(self.span, self.cx.std_path(&[sym::asserting, sym::Wrapper])),\n             ),\n-            vec![self.cx.expr_path(Path::from_ident(local_bind))],\n+            thin_vec![self.cx.expr_path(Path::from_ident(local_bind))],\n         );\n         let try_capture_call = self\n             .cx\n@@ -378,7 +378,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     ident: Ident::new(sym::try_capture, self.span),\n                 },\n                 expr_paren(self.cx, self.span, self.cx.expr_addr_of(self.span, wrapper)),\n-                vec![expr_addr_of_mut(\n+                thin_vec![expr_addr_of_mut(\n                     self.cx,\n                     self.span,\n                     self.cx.expr_path(Path::from_ident(capture)),\n@@ -389,7 +389,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         let local_bind_path = self.cx.expr_path(Path::from_ident(local_bind));\n         let rslt = if self.is_consumed {\n             let ret = self.cx.stmt_expr(local_bind_path);\n-            self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]))\n+            self.cx.expr_block(self.cx.block(self.span, thin_vec![try_capture_call, ret]))\n         } else {\n             self.best_case_captures.push(try_capture_call);\n             local_bind_path\n@@ -441,7 +441,7 @@ fn expr_method_call(\n     cx: &ExtCtxt<'_>,\n     seg: PathSegment,\n     receiver: P<Expr>,\n-    args: Vec<P<Expr>>,\n+    args: ThinVec<P<Expr>>,\n     span: Span,\n ) -> P<Expr> {\n     cx.expr(span, ExprKind::MethodCall(Box::new(MethodCall { seg, receiver, args, span })))"}, {"sha": "dfee2d3ce77d7983245a835b213670fd93943078", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_clone(\n     cx: &mut ExtCtxt<'_>,\n@@ -100,7 +100,7 @@ fn cs_clone_simple(\n     substr: &Substructure<'_>,\n     is_union: bool,\n ) -> BlockOrExpr {\n-    let mut stmts = Vec::new();\n+    let mut stmts = ThinVec::new();\n     let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &VariantData| {\n         for field in variant.fields() {\n@@ -162,7 +162,7 @@ fn cs_clone(\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n-        let args = vec![field.self_expr.clone()];\n+        let args = thin_vec![field.self_expr.clone()];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n@@ -200,7 +200,7 @@ fn cs_clone(\n                     let call = subcall(cx, field);\n                     cx.field_imm(field.span, ident, call)\n                 })\n-                .collect::<Vec<_>>();\n+                .collect::<ThinVec<_>>();\n \n             cx.expr_struct(trait_span, ctor_path, fields)\n         }"}, {"sha": "af971958680ae486dfc935d18cda4cc83554fff3", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_eq(\n     cx: &mut ExtCtxt<'_>,\n@@ -56,7 +56,7 @@ fn cs_total_eq_assert(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> BlockOrExpr {\n-    let mut stmts = Vec::new();\n+    let mut stmts = ThinVec::new();\n     let mut seen_type_names = FxHashSet::default();\n     let mut process_variant = |variant: &ast::VariantData| {\n         for field in variant.fields() {"}, {"sha": "cfd36f030a19310c5c239ae789be61c64f29855b", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -64,14 +64,14 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, expr1, expr2) => {\n                 let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), expr1);\n                 let neq_arm =\n                     cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                cx.expr_match(span, expr2, thin_vec![eq_arm, neq_arm])\n             }\n             CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n         },"}, {"sha": "9f46247908d0df81e008d9ef010c207f92b29cb2", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -98,7 +98,7 @@ fn cs_partial_cmp(\n                 let [other_expr] = &field.other_selflike_exprs[..] else {\n                         cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n                     };\n-                let args = vec![field.self_expr.clone(), other_expr.clone()];\n+                let args = thin_vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n             CsFold::Combine(span, mut expr1, expr2) => {\n@@ -143,7 +143,7 @@ fn cs_partial_cmp(\n                         cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n                     let neq_arm =\n                         cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                    cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                    cx.expr_match(span, expr2, thin_vec![eq_arm, neq_arm])\n                 }\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),"}, {"sha": "809f9838d20becd0965c226095302737ce40d2b2", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n@@ -94,7 +95,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+        let expr = cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]);\n         BlockOrExpr::new_expr(expr)\n     } else if fields.len() <= CUTOFF {\n         // Few enough fields that we can use a specific-length method.\n@@ -105,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug = cx.std_path(&[sym::fmt, sym::Formatter, Symbol::intern(&debug)]);\n \n-        let mut args = Vec::with_capacity(2 + fields.len() * args_per_field);\n+        let mut args = ThinVec::with_capacity(2 + fields.len() * args_per_field);\n         args.extend([fmt, name]);\n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -121,8 +122,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_expr(expr)\n     } else {\n         // Enough fields that we must use the any-length method.\n-        let mut name_exprs = Vec::with_capacity(fields.len());\n-        let mut value_exprs = Vec::with_capacity(fields.len());\n+        let mut name_exprs = ThinVec::with_capacity(fields.len());\n+        let mut value_exprs = ThinVec::with_capacity(fields.len());\n \n         for i in 0..fields.len() {\n             let field = &fields[i];\n@@ -177,7 +178,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         };\n         let fn_path_debug_internal = cx.std_path(&[sym::fmt, sym::Formatter, sym_debug]);\n \n-        let mut args = Vec::with_capacity(4);\n+        let mut args = ThinVec::with_capacity(4);\n         args.push(fmt);\n         args.push(name);\n         if is_struct {\n@@ -186,7 +187,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         args.push(cx.expr_ident(span, Ident::new(sym::values, span)));\n         let expr = cx.expr_call_global(span, fn_path_debug_internal, args);\n \n-        let mut stmts = Vec::with_capacity(3);\n+        let mut stmts = ThinVec::with_capacity(2);\n         if is_struct {\n             stmts.push(names_let.unwrap());\n         }\n@@ -223,18 +224,18 @@ fn show_fieldless_enum(\n             let pat = match &v.data {\n                 ast::VariantData::Tuple(fields, _) => {\n                     debug_assert!(fields.is_empty());\n-                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                    cx.pat_tuple_struct(span, variant_path, ThinVec::new())\n                 }\n                 ast::VariantData::Struct(fields, _) => {\n                     debug_assert!(fields.is_empty());\n-                    cx.pat_struct(span, variant_path, vec![])\n+                    cx.pat_struct(span, variant_path, ThinVec::new())\n                 }\n                 ast::VariantData::Unit(_) => cx.pat_path(span, variant_path),\n             };\n             cx.arm(span, pat, cx.expr_str(span, v.ident.name))\n         })\n-        .collect::<Vec<_>>();\n+        .collect::<ThinVec<_>>();\n     let name = cx.expr_match(span, cx.expr_self(span), arms);\n     let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, thin_vec![fmt, name]))\n }"}, {"sha": "3921533c84a19562343aed2b4e70e3f07052c56b", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -3,12 +3,12 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, Expr, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_decodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -96,7 +96,7 @@ fn decodable_substructure(\n                         cx.expr_call_global(\n                             span,\n                             fn_read_struct_field_path.clone(),\n-                            vec![\n+                            thin_vec![\n                                 blkdecoder.clone(),\n                                 cx.expr_str(span, name),\n                                 cx.expr_usize(span, field),\n@@ -112,7 +112,7 @@ fn decodable_substructure(\n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_struct_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, nfields),\n@@ -123,8 +123,8 @@ fn decodable_substructure(\n         StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n-            let mut arms = Vec::with_capacity(fields.len() + 1);\n-            let mut variants = Vec::with_capacity(fields.len());\n+            let mut arms = ThinVec::with_capacity(fields.len() + 1);\n+            let mut variants = ThinVec::with_capacity(fields.len());\n \n             let fn_read_enum_variant_arg_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum_variant_arg]);\n@@ -141,7 +141,7 @@ fn decodable_substructure(\n                             cx.expr_call_global(\n                                 span,\n                                 fn_read_enum_variant_arg_path.clone(),\n-                                vec![blkdecoder.clone(), idx, exprdecode.clone()],\n+                                thin_vec![blkdecoder.clone(), idx, exprdecode.clone()],\n                             ),\n                         )\n                     });\n@@ -162,15 +162,15 @@ fn decodable_substructure(\n             let result = cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_variant_path,\n-                vec![blkdecoder, variant_array_ref, lambda],\n+                thin_vec![blkdecoder, variant_array_ref, lambda],\n             );\n             let fn_read_enum_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_enum]);\n \n             cx.expr_call_global(\n                 trait_span,\n                 fn_read_enum_path,\n-                vec![\n+                thin_vec![\n                     decoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.lambda1(trait_span, result, blkarg),"}, {"sha": "4d753a2ed805cb6aaeb03c605861bfaa5d6bfcce", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use smallvec::SmallVec;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_default(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn default_struct_substructure(\n ) -> BlockOrExpr {\n     // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n     let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ThinVec::new());\n \n     let expr = match summary {\n         Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),"}, {"sha": "a3b11309d0ce1a7eaae6ada7378ed84e559ff4ca", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -88,11 +88,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n-\n use rustc_ast::{AttrVec, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand_deriving_rustc_encodable(\n     cx: &mut ExtCtxt<'_>,\n@@ -169,19 +169,20 @@ fn encodable_substructure(\n         Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n-            let mut stmts = Vec::new();\n+            let mut stmts = ThinVec::new();\n             for (i, &FieldInfo { name, ref self_expr, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name,\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                let enc =\n+                    cx.expr_call(span, fn_path.clone(), thin_vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n                     span,\n                     fn_emit_struct_field_path.clone(),\n-                    vec![\n+                    thin_vec![\n                         blkencoder.clone(),\n                         cx.expr_str(span, name),\n                         cx.expr_usize(span, i),\n@@ -203,7 +204,7 @@ fn encodable_substructure(\n \n             // unit structs have no fields and need to return Ok()\n             let blk = if stmts.is_empty() {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 cx.lambda1(trait_span, ok, blkarg)\n             } else {\n                 cx.lambda_stmts_1(trait_span, stmts, blkarg)\n@@ -215,7 +216,7 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_struct_path,\n-                vec![\n+                thin_vec![\n                     encoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n@@ -236,19 +237,22 @@ fn encodable_substructure(\n             let fn_emit_enum_variant_arg_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_enum_variant_arg]);\n \n-            let mut stmts = Vec::new();\n+            let mut stmts = ThinVec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n                     let self_ref = cx.expr_addr_of(span, self_expr.clone());\n-                    let enc =\n-                        cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n+                    let enc = cx.expr_call(\n+                        span,\n+                        fn_path.clone(),\n+                        thin_vec![self_ref, blkencoder.clone()],\n+                    );\n                     let lambda = cx.lambda1(span, enc, blkarg);\n \n                     let call = cx.expr_call_global(\n                         span,\n                         fn_emit_enum_variant_arg_path.clone(),\n-                        vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n+                        thin_vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n                     );\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n@@ -258,7 +262,7 @@ fn encodable_substructure(\n                     stmts.push(cx.stmt_expr(call));\n                 }\n             } else {\n-                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, ThinVec::new()));\n                 let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n@@ -272,7 +276,7 @@ fn encodable_substructure(\n             let call = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_variant_path,\n-                vec![\n+                thin_vec![\n                     blkencoder,\n                     name,\n                     cx.expr_usize(trait_span, *idx),\n@@ -287,9 +291,9 @@ fn encodable_substructure(\n             let expr = cx.expr_call_global(\n                 trait_span,\n                 fn_emit_enum_path,\n-                vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n+                thin_vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n-            BlockOrExpr::new_mixed(vec![me], Some(expr))\n+            BlockOrExpr::new_mixed(thin_vec![me], Some(expr))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),"}, {"sha": "1f819beeb5d7d25643a66e717f18b670c4db7369", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -177,7 +177,7 @@ use std::cell::RefCell;\n use std::iter;\n use std::ops::Not;\n use std::vec;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n use ty::{Bounds, Path, Ref, Self_, Ty};\n \n pub mod ty;\n@@ -318,7 +318,7 @@ pub fn combine_substructure(\n }\n \n struct TypeParameter {\n-    bound_generic_params: Vec<ast::GenericParam>,\n+    bound_generic_params: ThinVec<ast::GenericParam>,\n     ty: P<ast::Ty>,\n }\n \n@@ -328,18 +328,18 @@ struct TypeParameter {\n /// avoiding the insertion of any unnecessary blocks.\n ///\n /// The statements come before the expression.\n-pub struct BlockOrExpr(Vec<ast::Stmt>, Option<P<Expr>>);\n+pub struct BlockOrExpr(ThinVec<ast::Stmt>, Option<P<Expr>>);\n \n impl BlockOrExpr {\n-    pub fn new_stmts(stmts: Vec<ast::Stmt>) -> BlockOrExpr {\n+    pub fn new_stmts(stmts: ThinVec<ast::Stmt>) -> BlockOrExpr {\n         BlockOrExpr(stmts, None)\n     }\n \n     pub fn new_expr(expr: P<Expr>) -> BlockOrExpr {\n-        BlockOrExpr(vec![], Some(expr))\n+        BlockOrExpr(ThinVec::new(), Some(expr))\n     }\n \n-    pub fn new_mixed(stmts: Vec<ast::Stmt>, expr: Option<P<Expr>>) -> BlockOrExpr {\n+    pub fn new_mixed(stmts: ThinVec<ast::Stmt>, expr: Option<P<Expr>>) -> BlockOrExpr {\n         BlockOrExpr(stmts, expr)\n     }\n \n@@ -355,7 +355,7 @@ impl BlockOrExpr {\n     fn into_expr(self, cx: &ExtCtxt<'_>, span: Span) -> P<Expr> {\n         if self.0.is_empty() {\n             match self.1 {\n-                None => cx.expr_block(cx.block(span, vec![])),\n+                None => cx.expr_block(cx.block(span, ThinVec::new())),\n                 Some(expr) => expr,\n             }\n         } else if self.0.len() == 1\n@@ -385,7 +385,7 @@ fn find_type_parameters(\n     struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n         ty_param_names: &'a [Symbol],\n-        bound_generic_params_stack: Vec<ast::GenericParam>,\n+        bound_generic_params_stack: ThinVec<ast::GenericParam>,\n         type_params: Vec<TypeParameter>,\n     }\n \n@@ -422,7 +422,7 @@ fn find_type_parameters(\n     let mut visitor = Visitor {\n         cx,\n         ty_param_names,\n-        bound_generic_params_stack: Vec::new(),\n+        bound_generic_params_stack: ThinVec::new(),\n         type_params: Vec::new(),\n     };\n     visit::Visitor::visit_ty(&mut visitor, ty);\n@@ -594,7 +594,7 @@ impl<'a> TraitDef<'a> {\n         let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n-        let params: Vec<_> = generics\n+        let params: ThinVec<_> = generics\n             .params\n             .iter()\n             .map(|param| match &param.kind {\n@@ -935,8 +935,8 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n-    ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut selflike_args = Vec::new();\n+    ) -> (Option<ast::ExplicitSelf>, ThinVec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        let mut selflike_args = ThinVec::new();\n         let mut nonselflike_args = Vec::new();\n         let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n@@ -1133,7 +1133,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        selflike_args: Vec<P<Expr>>,\n+        selflike_args: ThinVec<P<Expr>>,\n         nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n@@ -1146,7 +1146,7 @@ impl<'a> MethodDef<'a> {\n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n         if variants.is_empty() {\n-            return BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)));\n+            return BlockOrExpr(ThinVec::new(), Some(deriving::call_unreachable(cx, span)));\n         }\n \n         let prefixes = iter::once(\"__self\".to_string())\n@@ -1182,13 +1182,13 @@ impl<'a> MethodDef<'a> {\n             let other_selflike_exprs = tag_exprs;\n             let tag_field = FieldInfo { span, name: None, self_expr, other_selflike_exprs };\n \n-            let tag_let_stmts: Vec<_> = iter::zip(&tag_idents, &selflike_args)\n+            let tag_let_stmts: ThinVec<_> = iter::zip(&tag_idents, &selflike_args)\n                 .map(|(&ident, selflike_arg)| {\n                     let variant_value = deriving::call_intrinsic(\n                         cx,\n                         span,\n                         sym::discriminant_value,\n-                        vec![selflike_arg.clone()],\n+                        thin_vec![selflike_arg.clone()],\n                     );\n                     cx.stmt_let(span, false, ident, variant_value)\n                 })\n@@ -1247,7 +1247,7 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = selflike_args.len()\n-        let mut match_arms: Vec<ast::Arm> = variants\n+        let mut match_arms: ThinVec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(unify_fieldless_variants && v.data.fields().is_empty()))\n@@ -1260,7 +1260,7 @@ impl<'a> MethodDef<'a> {\n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n                 let by_ref = ByRef::No; // because enums can't be repr(packed)\n-                let mut subpats: Vec<_> = trait_.create_struct_patterns(\n+                let mut subpats = trait_.create_struct_patterns(\n                     cx,\n                     variant_path,\n                     &variant.data,\n@@ -1336,7 +1336,7 @@ impl<'a> MethodDef<'a> {\n         //          ...\n         //          _ => ::core::intrinsics::unreachable()\n         //      }\n-        let get_match_expr = |mut selflike_args: Vec<P<Expr>>| {\n+        let get_match_expr = |mut selflike_args: ThinVec<P<Expr>>| {\n             let match_arg = if selflike_args.len() == 1 {\n                 selflike_args.pop().unwrap()\n             } else {\n@@ -1362,7 +1362,7 @@ impl<'a> MethodDef<'a> {\n             tag_let_stmts.append(&mut tag_check_plus_match.0);\n             BlockOrExpr(tag_let_stmts, tag_check_plus_match.1)\n         } else {\n-            BlockOrExpr(vec![], Some(get_match_expr(selflike_args)))\n+            BlockOrExpr(ThinVec::new(), Some(get_match_expr(selflike_args)))\n         }\n     }\n \n@@ -1427,7 +1427,7 @@ impl<'a> TraitDef<'a> {\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n         by_ref: ByRef,\n-    ) -> Vec<P<ast::Pat>> {\n+    ) -> ThinVec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n@@ -1599,7 +1599,7 @@ impl<'a> TraitDef<'a> {\n                         } else {\n                             // Wrap the expression in `{...}`, causing a copy.\n                             field_expr = cx.expr_block(\n-                                cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n+                                cx.block(struct_field.span, thin_vec![cx.stmt_expr(field_expr)]),\n                             );\n                         }\n                     }"}, {"sha": "26f91b714b46836d1c577dddc91af4463bc8170f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -9,6 +9,7 @@ use rustc_expand::base::ExtCtxt;\n use rustc_span::source_map::{respan, DUMMY_SP};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::ThinVec;\n \n /// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n /// for type parameters.\n@@ -102,7 +103,7 @@ impl Ty {\n             Path(p) => p.to_ty(cx, span, self_ty, self_generics),\n             Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n             Unit => {\n-                let ty = ast::TyKind::Tup(vec![]);\n+                let ty = ast::TyKind::Tup(ThinVec::new());\n                 cx.ty(span, ty)\n             }\n         }\n@@ -185,7 +186,11 @@ impl Bounds {\n \n         Generics {\n             params,\n-            where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+            where_clause: ast::WhereClause {\n+                has_where_token: false,\n+                predicates: ThinVec::new(),\n+                span,\n+            },\n             span,\n         }\n     }"}, {"sha": "4eee573db4215849283231ca9cf00457e6c81157", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -1,11 +1,11 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-\n use rustc_ast::{AttrVec, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n pub fn expand_deriving_hash(\n     cx: &mut ExtCtxt<'_>,\n@@ -60,7 +60,7 @@ fn hash_substructure(\n \n             cx.expr_path(cx.path_global(span, strs))\n         };\n-        let expr = cx.expr_call(span, hash_path, vec![expr, state_expr.clone()]);\n+        let expr = cx.expr_call(span, hash_path, thin_vec![expr, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n \n@@ -72,7 +72,7 @@ fn hash_substructure(\n         }\n         EnumTag(tag_field, match_expr) => {\n             assert!(tag_field.other_selflike_exprs.is_empty());\n-            let stmts = vec![call_hash(tag_field.span, tag_field.self_expr.clone())];\n+            let stmts = thin_vec![call_hash(tag_field.span, tag_field.self_expr.clone())];\n             (stmts, match_expr.clone())\n         }\n         _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\"),"}, {"sha": "d34336e7679c03bf3a0cd3a1542fcfdd6054997f", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::{GenericArg, Impl, ItemKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n+use thin_vec::{thin_vec, ThinVec};\n \n macro path_local($x:ident) {\n     generic::ty::Path::new_local(sym::$x)\n@@ -92,7 +93,7 @@ fn call_intrinsic(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n     intrinsic: Symbol,\n-    args: Vec<P<ast::Expr>>,\n+    args: ThinVec<P<ast::Expr>>,\n ) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n@@ -103,10 +104,10 @@ fn call_intrinsic(\n fn call_unreachable(cx: &ExtCtxt<'_>, span: Span) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, sym::unreachable]);\n-    let call = cx.expr_call_global(span, path, vec![]);\n+    let call = cx.expr_call_global(span, path, ThinVec::new());\n \n     cx.expr_block(P(ast::Block {\n-        stmts: vec![cx.stmt_expr(call)],\n+        stmts: thin_vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span,\n@@ -202,7 +203,7 @@ fn inject_impl_of_structural_trait(\n             generics,\n             of_trait: Some(trait_ref),\n             self_ty: self_type,\n-            items: Vec::new(),\n+            items: ThinVec::new(),\n         })),\n     );\n \n@@ -211,7 +212,7 @@ fn inject_impl_of_structural_trait(\n \n fn assert_ty_bounds(\n     cx: &mut ExtCtxt<'_>,\n-    stmts: &mut Vec<ast::Stmt>,\n+    stmts: &mut ThinVec<ast::Stmt>,\n     ty: P<ast::Ty>,\n     span: Span,\n     assert_path: &[Symbol],"}, {"sha": "6aa900f020163415b5e703ea23dc342ff28dbac5", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -8,8 +8,8 @@ use rustc_ast::{self as ast, GenericArg};\n use rustc_expand::base::{self, *};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-\n use std::env;\n+use thin_vec::thin_vec;\n \n pub fn expand_option_env<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n@@ -41,7 +41,7 @@ pub fn expand_option_env<'cx>(\n         Some(value) => cx.expr_call_global(\n             sp,\n             cx.std_path(&[sym::option, sym::Option, sym::Some]),\n-            vec![cx.expr_str(sp, value)],\n+            thin_vec![cx.expr_str(sp, value)],\n         ),\n     };\n     MacEager::expr(e)"}, {"sha": "41b51bae73645bbcb6fe30a841d45e79586a18aa", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -47,7 +47,7 @@ pub fn expand(\n     let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n \n     // Generate anonymous constant serving as container for the allocator methods.\n-    let const_ty = ecx.ty(ty_span, TyKind::Tup(Vec::new()));\n+    let const_ty = ecx.ty(ty_span, TyKind::Tup(ThinVec::new()));\n     let const_body = ecx.expr_block(ecx.block(span, stmts));\n     let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n     let const_item = if is_stmt {\n@@ -70,7 +70,7 @@ struct AllocFnFactory<'a, 'b> {\n \n impl AllocFnFactory<'_, '_> {\n     fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n-        let mut abi_args = Vec::new();\n+        let mut abi_args = ThinVec::new();\n         let mut i = 0;\n         let mut mk = || {\n             let name = Ident::from_str_and_span(&format!(\"arg{}\", i), self.span);\n@@ -99,7 +99,7 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.stmt_item(self.ty_span, item)\n     }\n \n-    fn call_allocator(&self, method: Symbol, mut args: Vec<P<Expr>>) -> P<Expr> {\n+    fn call_allocator(&self, method: Symbol, mut args: ThinVec<P<Expr>>) -> P<Expr> {\n         let method = self.cx.std_path(&[sym::alloc, sym::GlobalAlloc, method]);\n         let method = self.cx.expr_path(self.cx.path(self.ty_span, method));\n         let allocator = self.cx.path_ident(self.ty_span, self.global);\n@@ -117,7 +117,7 @@ impl AllocFnFactory<'_, '_> {\n     fn arg_ty(\n         &self,\n         ty: &AllocatorTy,\n-        args: &mut Vec<Param>,\n+        args: &mut ThinVec<Param>,\n         ident: &mut dyn FnMut() -> Ident,\n     ) -> P<Expr> {\n         match *ty {\n@@ -134,7 +134,7 @@ impl AllocFnFactory<'_, '_> {\n                 let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n+                let layout = self.cx.expr_call(self.span, layout_new, thin_vec![size, align]);\n                 layout\n             }\n \n@@ -168,7 +168,7 @@ impl AllocFnFactory<'_, '_> {\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(ThinVec::new())), expr),\n \n             AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n                 panic!(\"can't convert `AllocatorTy` to an output\")"}, {"sha": "bc513607ddd1d7e435cb8d0f28620840b8048f19", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -11,6 +11,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -314,11 +315,14 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, custom_derive),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, cd.trait_name),\n                             cx.expr_array_ref(\n                                 span,\n-                                cd.attrs.iter().map(|&s| cx.expr_str(span, s)).collect::<Vec<_>>(),\n+                                cd.attrs\n+                                    .iter()\n+                                    .map(|&s| cx.expr_str(span, s))\n+                                    .collect::<ThinVec<_>>(),\n                             ),\n                             local_path(cx, cd.function_name),\n                         ],\n@@ -335,7 +339,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, ident),\n-                        vec![\n+                        thin_vec![\n                             cx.expr_str(span, ca.function_name.name),\n                             local_path(cx, ca.function_name),\n                         ],\n@@ -371,13 +375,13 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n         });\n \n     let block = cx.expr_block(\n-        cx.block(span, vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)]),\n+        cx.block(span, thin_vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)]),\n     );\n \n     let anon_constant = cx.item_const(\n         span,\n         Ident::new(kw::Underscore, span),\n-        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+        cx.ty(span, ast::TyKind::Tup(ThinVec::new())),\n         block,\n     );\n "}, {"sha": "e02c7e6c01b7e5570daea34e5b112bd4eefdf478", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::iter;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n /// #[test_case] is used by custom test authors to mark tests\n /// When building for test, it needs to make the item public and gensym the name\n@@ -179,19 +179,19 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticBenchFn\")),\n-            vec![\n+            thin_vec![\n                 // |b| self::test::assert_test_result(\n                 cx.lambda1(\n                     sp,\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // super::$test_fn(b)\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![cx.expr_ident(sp, b)],\n+                                thin_vec![cx.expr_ident(sp, b)],\n                             ),\n                         ],\n                     ),\n@@ -203,20 +203,20 @@ pub fn expand_test_or_bench(\n         cx.expr_call(\n             sp,\n             cx.expr_path(test_path(\"StaticTestFn\")),\n-            vec![\n+            thin_vec![\n                 // || {\n                 cx.lambda0(\n                     sp,\n                     // test::assert_test_result(\n                     cx.expr_call(\n                         sp,\n                         cx.expr_path(test_path(\"assert_test_result\")),\n-                        vec![\n+                        thin_vec![\n                             // $test_fn()\n                             cx.expr_call(\n                                 ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n-                                vec![],\n+                                ThinVec::new(),\n                             ), // )\n                         ],\n                     ), // }\n@@ -249,21 +249,21 @@ pub fn expand_test_or_bench(\n                 cx.expr_struct(\n                     sp,\n                     test_path(\"TestDescAndFn\"),\n-                    vec![\n+                    thin_vec![\n                         // desc: test::TestDesc {\n                         field(\n                             \"desc\",\n                             cx.expr_struct(\n                                 sp,\n                                 test_path(\"TestDesc\"),\n-                                vec![\n+                                thin_vec![\n                                     // name: \"path::to::test\"\n                                     field(\n                                         \"name\",\n                                         cx.expr_call(\n                                             sp,\n                                             cx.expr_path(test_path(\"StaticTestName\")),\n-                                            vec![cx.expr_str(sp, test_path_symbol)],\n+                                            thin_vec![cx.expr_str(sp, test_path_symbol)],\n                                         ),\n                                     ),\n                                     // ignore: true | false\n@@ -300,7 +300,7 @@ pub fn expand_test_or_bench(\n                                             ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n                                                 sp,\n                                                 cx.expr_path(should_panic_path(\"YesWithMessage\")),\n-                                                vec![cx.expr_str(sp, sym)],\n+                                                thin_vec![cx.expr_str(sp, sym)],\n                                             ),\n                                         },\n                                     ),"}, {"sha": "d8e3db9e8ee094036892a0dafb38d02adbc3dc4b", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -14,7 +14,8 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n+use tracing::debug;\n \n use std::{iter, mem};\n \n@@ -299,7 +300,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     test_runner.span = sp;\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n-    let call_test_main = ecx.expr_call(sp, test_main_path_expr, vec![mk_tests_slice(cx, sp)]);\n+    let call_test_main = ecx.expr_call(sp, test_main_path_expr, thin_vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // extern crate test\n@@ -312,16 +313,16 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n-    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n+    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(ThinVec::new()));\n \n     // If no test runner is provided we need to import the test crate\n     let main_body = if cx.test_runner.is_none() {\n-        ecx.block(sp, vec![test_extern_stmt, call_test_main])\n+        ecx.block(sp, thin_vec![test_extern_stmt, call_test_main])\n     } else {\n-        ecx.block(sp, vec![call_test_main])\n+        ecx.block(sp, thin_vec![call_test_main])\n     };\n \n-    let decl = ecx.fn_decl(vec![], ast::FnRetTy::Ty(main_ret_ty));\n+    let decl = ecx.fn_decl(ThinVec::new(), ast::FnRetTy::Ty(main_ret_ty));\n     let sig = ast::FnSig { decl, header: ast::FnHeader::default(), span: sp };\n     let defaultness = ast::Defaultness::Final;\n     let main = ast::ItemKind::Fn(Box::new(ast::Fn {"}, {"sha": "58ebfbd3124eaad640b76a15267a70c2d1f1d3e6", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -29,7 +29,7 @@ smallvec = { version = \"1.8.1\", features = [\n stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.15\"\n tempfile = \"3.2\"\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n \n [dependencies.parking_lot]"}, {"sha": "c971714e05bb3cbcafb3d17e4468da11035343ca", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -24,5 +24,5 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "22bc90f5cac2ee8e1d44d9ed19c71f30f98ad3b5", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -29,10 +29,11 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n-\n+use std::default::Default;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use thin_vec::ThinVec;\n \n pub(crate) use rustc_span::hygiene::MacroKind;\n \n@@ -554,7 +555,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span, is_error: bool) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(ThinVec::new()) },\n             span: sp,\n             attrs: ast::AttrVec::new(),\n             tokens: None,\n@@ -570,7 +571,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span, is_error: bool) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(Vec::new()) },\n+            kind: if is_error { ast::TyKind::Err } else { ast::TyKind::Tup(ThinVec::new()) },\n             span: sp,\n             tokens: None,\n         })"}, {"sha": "8a78c3296f9cfdc5e86cbf9dc97701385d9a6b78", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::{attr, token, util::literal};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<Ident>) -> ast::Path {\n@@ -125,7 +125,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {\n         ast::PolyTraitRef {\n-            bound_generic_params: Vec::new(),\n+            bound_generic_params: ThinVec::new(),\n             trait_ref: self.trait_ref(path),\n             span,\n         }\n@@ -221,14 +221,14 @@ impl<'a> ExtCtxt<'a> {\n     pub fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n         self.block(\n             expr.span,\n-            vec![ast::Stmt {\n+            thin_vec![ast::Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 span: expr.span,\n                 kind: ast::StmtKind::Expr(expr),\n             }],\n         )\n     }\n-    pub fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+    pub fn block(&self, span: Span, stmts: ThinVec<ast::Stmt>) -> P<ast::Block> {\n         P(ast::Block {\n             stmts,\n             id: ast::DUMMY_NODE_ID,\n@@ -284,18 +284,23 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         expr: P<ast::Expr>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n-    pub fn expr_call_ident(&self, span: Span, id: Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_call_ident(\n+        &self,\n+        span: Span,\n+        id: Ident,\n+        args: ThinVec<P<ast::Expr>>,\n+    ) -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     pub fn expr_call_global(\n         &self,\n         sp: Span,\n         fn_path: Vec<Ident>,\n-        args: Vec<P<ast::Expr>>,\n+        args: ThinVec<P<ast::Expr>>,\n     ) -> P<ast::Expr> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n@@ -318,7 +323,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         path: ast::Path,\n-        fields: Vec<ast::ExprField>,\n+        fields: ThinVec<ast::ExprField>,\n     ) -> P<ast::Expr> {\n         self.expr(\n             span,\n@@ -334,7 +339,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         id: Ident,\n-        fields: Vec<ast::ExprField>,\n+        fields: ThinVec<ast::ExprField>,\n     ) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n@@ -372,12 +377,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     /// `[expr1, expr2, ...]`\n-    pub fn expr_array(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n \n     /// `&[expr1, expr2, ...]`\n-    pub fn expr_array_ref(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_array_ref(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_array(sp, exprs))\n     }\n \n@@ -387,22 +392,22 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n-        self.expr_call_global(sp, some, vec![expr])\n+        self.expr_call_global(sp, some, thin_vec![expr])\n     }\n \n     pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n         let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n         self.expr_path(self.path_global(sp, none))\n     }\n-    pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+    pub fn expr_tuple(&self, sp: Span, exprs: ThinVec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n     pub fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         self.expr_call_global(\n             span,\n             [sym::std, sym::rt, sym::begin_panic].iter().map(|s| Ident::new(*s, span)).collect(),\n-            vec![self.expr_str(span, msg)],\n+            thin_vec![self.expr_str(span, msg)],\n         )\n     }\n \n@@ -412,7 +417,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n-        self.expr_call_global(sp, ok, vec![expr])\n+        self.expr_call_global(sp, ok, thin_vec![expr])\n     }\n \n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n@@ -426,12 +431,12 @@ impl<'a> ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // `Ok(__try_var)` pattern\n-        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, thin_vec![binding_pat.clone()]);\n \n         // `Err(__try_var)` (pattern and expression respectively)\n-        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), thin_vec![binding_pat]);\n         let err_inner_expr =\n-            self.expr_call(sp, self.expr_path(err_path), vec![binding_expr.clone()]);\n+            self.expr_call(sp, self.expr_path(err_path), thin_vec![binding_expr.clone()]);\n         // `return Err(__try_var)`\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n@@ -441,7 +446,7 @@ impl<'a> ExtCtxt<'a> {\n         let err_arm = self.arm(sp, err_pat, err_expr);\n \n         // `match head { Ok() => ..., Err() => ... }`\n-        self.expr_match(sp, head, vec![ok_arm, err_arm])\n+        self.expr_match(sp, head, thin_vec![ok_arm, err_arm])\n     }\n \n     pub fn pat(&self, span: Span, kind: PatKind) -> P<ast::Pat> {\n@@ -473,26 +478,26 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         path: ast::Path,\n-        subpats: Vec<P<ast::Pat>>,\n+        subpats: ThinVec<P<ast::Pat>>,\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::TupleStruct(None, path, subpats))\n     }\n     pub fn pat_struct(\n         &self,\n         span: Span,\n         path: ast::Path,\n-        field_pats: Vec<ast::PatField>,\n+        field_pats: ThinVec<ast::PatField>,\n     ) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(None, path, field_pats, false))\n     }\n-    pub fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+    pub fn pat_tuple(&self, span: Span, pats: ThinVec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats))\n     }\n \n     pub fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n+        self.pat_tuple_struct(span, path, thin_vec![pat])\n     }\n \n     pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n@@ -511,7 +516,7 @@ impl<'a> ExtCtxt<'a> {\n         self.arm(span, self.pat_wild(span), self.expr_unreachable(span))\n     }\n \n-    pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n+    pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: ThinVec<ast::Arm>) -> P<Expr> {\n         self.expr(span, ast::ExprKind::Match(arg, arms))\n     }\n \n@@ -562,7 +567,12 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>, ident: Ident) -> P<ast::Expr> {\n+    pub fn lambda_stmts_1(\n+        &self,\n+        span: Span,\n+        stmts: ThinVec<ast::Stmt>,\n+        ident: Ident,\n+    ) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n     }\n \n@@ -579,7 +589,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     // `self` is unused but keep it as method for the convenience use.\n-    pub fn fn_decl(&self, inputs: Vec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n+    pub fn fn_decl(&self, inputs: ThinVec<ast::Param>, output: ast::FnRetTy) -> P<ast::FnDecl> {\n         P(ast::FnDecl { inputs, output })\n     }\n "}, {"sha": "01500c2c77c90aac5a2ac28a6da84abdfa724461", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -24,6 +24,7 @@ use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use thin_vec::ThinVec;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n@@ -206,7 +207,7 @@ pub fn features(\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = ast::AttrVec::new();\n-            krate.items = Vec::new();\n+            krate.items = ThinVec::new();\n             Features::default()\n         }\n         Some(attrs) => {"}, {"sha": "3779af19e122f1b81cb9123b4de2c2372d22b8d8", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -12,8 +12,8 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::iter::once;\n-\n use std::path::{self, Path, PathBuf};\n+use thin_vec::ThinVec;\n \n #[derive(Copy, Clone)]\n pub enum DirOwnership {\n@@ -31,7 +31,7 @@ pub struct ModulePathSuccess {\n }\n \n pub(crate) struct ParsedExternalMod {\n-    pub items: Vec<P<Item>>,\n+    pub items: ThinVec<P<Item>>,\n     pub spans: ModSpans,\n     pub file_path: PathBuf,\n     pub dir_path: PathBuf,"}, {"sha": "fab16b80fb59ceac7f6298d616fe2d2c415a8d57", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -9,7 +9,6 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n-tracing = \"0.1\"\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -27,3 +26,5 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "ad89393956e680abf0f5333b671451c265c501e3", "filename": "compiler/rustc_incremental/Cargo.toml", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,16 +6,17 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n-tracing = \"0.1\"\n rand = \"0.8.4\"\n-rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n+rustc_span = { path = \"../rustc_span\" }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "b4b0ea00c50c0d1eaf47e870eaaafb7b369b563f", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -30,6 +30,7 @@ use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::*;\n use rustc_span::symbol::{sym, Symbol};\n+use thin_vec::ThinVec;\n \n #[allow(missing_docs)]\n pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n@@ -138,7 +139,7 @@ impl<'tcx> AssertModuleSource<'tcx> {\n     }\n \n     fn field(&self, attr: &ast::Attribute, name: Symbol) -> Symbol {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(name) {\n                 if let Some(value) = item.value_str() {\n                     return value;"}, {"sha": "b839416c9195714f5e2b7883edce8c963d7a84ad", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -31,6 +31,8 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use std::iter::FromIterator;\n+use thin_vec::ThinVec;\n \n const LOADED_FROM_DISK: Symbol = sym::loaded_from_disk;\n const EXCEPT: Symbol = sym::except;\n@@ -205,7 +207,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `loaded_from_disk=` attribute value\n     fn loaded_from_disk(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(LOADED_FROM_DISK) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -217,7 +219,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n \n     /// `except=` attribute value\n     fn except(&self, attr: &Attribute) -> Labels {\n-        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+        for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n             if item.has_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value);\n@@ -397,7 +399,7 @@ fn check_config(tcx: TyCtxt<'_>, attr: &Attribute) -> bool {\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n     let mut cfg = None;\n-    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+    for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n         if item.has_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);"}, {"sha": "a2b78cc298570d55020d64e946a5982f8b41d0d9", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -34,7 +34,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "3eb158c817cf0a40207b320c2bb2154d3e2b71a6", "filename": "compiler/rustc_parse/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -16,7 +16,7 @@ rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n unicode-normalization = \"0.1.11\"\n unicode-width = \"0.1.4\""}, {"sha": "9fa657e725cf2709b9cd367316f1665cc641cc87", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,6 +6,9 @@ use rustc_ast::attr;\n use rustc_ast::token::{self, Delimiter, Nonterminal};\n use rustc_errors::{error_code, fluent, Diagnostic, IntoDiagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n+use std::convert::TryInto;\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n // Public for rustfmt usage\n #[derive(Debug)]\n@@ -346,9 +349,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `COMMASEP(meta_item_inner)`.\n-    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, ThinVec<ast::NestedMetaItem>> {\n         // Presumably, the majority of the time there will only be one attr.\n-        let mut nmis = Vec::with_capacity(1);\n+        let mut nmis = ThinVec::with_capacity(1);\n         while self.token.kind != token::Eof {\n             nmis.push(self.parse_meta_item_inner()?);\n             if !self.eat(&token::Comma) {"}, {"sha": "46685dcc45dd88b0b43d0cfb77b6db77e57998b5", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -708,7 +708,7 @@ impl<'a> Parser<'a> {\n                     err.delay_as_bug();\n                     self.restore_snapshot(snapshot);\n                     let mut tail = self.mk_block(\n-                        vec![self.mk_stmt_err(expr.span)],\n+                        thin_vec![self.mk_stmt_err(expr.span)],\n                         s,\n                         lo.to(self.prev_token.span),\n                     );\n@@ -2175,7 +2175,7 @@ impl<'a> Parser<'a> {\n     /// the parameters are *names* (so we don't emit errors about not being able to find `b` in\n     /// the local scope), but if we find the same name multiple times, like in `fn foo(i8, i8)`,\n     /// we deduplicate them to not complain about duplicated parameter names.\n-    pub(super) fn deduplicate_recovered_params_names(&self, fn_inputs: &mut Vec<Param>) {\n+    pub(super) fn deduplicate_recovered_params_names(&self, fn_inputs: &mut ThinVec<Param>) {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) =\n@@ -2199,7 +2199,7 @@ impl<'a> Parser<'a> {\n     /// like the user has forgotten them.\n     pub fn handle_ambiguous_unbraced_const_arg(\n         &mut self,\n-        args: &mut Vec<AngleBracketedArg>,\n+        args: &mut ThinVec<AngleBracketedArg>,\n     ) -> PResult<'a, bool> {\n         // If we haven't encountered a closing `>`, then the argument is malformed.\n         // It's likely that the user has written a const expression without enclosing it"}, {"sha": "12f65a436e3be6078d2c21c1432afd23f1349b27", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -31,6 +31,7 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n+use thin_vec::{thin_vec, ThinVec};\n \n /// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n@@ -124,7 +125,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a sequence of expressions delimited by parentheses.\n-    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n+    fn parse_paren_expr_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| p.parse_expr_catch_underscore()).map(|(r, _)| r)\n     }\n \n@@ -1450,7 +1451,7 @@ impl<'a> Parser<'a> {\n         let close = &token::CloseDelim(close_delim);\n         let kind = if self.eat(close) {\n             // Empty vector\n-            ExprKind::Array(Vec::new())\n+            ExprKind::Array(ThinVec::new())\n         } else {\n             // Non-empty vector\n             let first_expr = self.parse_expr()?;\n@@ -1468,7 +1469,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 // Vector with one element\n                 self.expect(close)?;\n-                ExprKind::Array(vec![first_expr])\n+                ExprKind::Array(thin_vec![first_expr])\n             }\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n@@ -1600,7 +1601,7 @@ impl<'a> Parser<'a> {\n \n                 // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to suppress future errors about `break 'label`.\n                 let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n-                let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n+                let blk = self.mk_block(thin_vec![stmt], BlockCheckMode::Default, span);\n                 self.mk_expr(span, ExprKind::Block(blk, label))\n             });\n \n@@ -2095,7 +2096,7 @@ impl<'a> Parser<'a> {\n \n             self.sess.gated_spans.gate(sym::closure_lifetime_binder, span);\n \n-            ClosureBinder::For { span, generic_params: P::from_vec(lifetime_defs) }\n+            ClosureBinder::For { span, generic_params: lifetime_defs }\n         } else {\n             ClosureBinder::NotPresent\n         };\n@@ -2187,7 +2188,7 @@ impl<'a> Parser<'a> {\n         let arg_start = self.token.span.lo();\n \n         let inputs = if self.eat(&token::OrOr) {\n-            Vec::new()\n+            ThinVec::new()\n         } else {\n             self.expect(&token::BinOp(token::Or))?;\n             let args = self\n@@ -2480,7 +2481,7 @@ impl<'a> Parser<'a> {\n             self.sess\n                 .emit_err(errors::MissingExpressionInForLoop { span: expr.span.shrink_to_lo() });\n             let err_expr = self.mk_expr(expr.span, ExprKind::Err);\n-            let block = self.mk_block(vec![], BlockCheckMode::Default, self.prev_token.span);\n+            let block = self.mk_block(thin_vec![], BlockCheckMode::Default, self.prev_token.span);\n             return Ok(self.mk_expr(\n                 lo.to(self.prev_token.span),\n                 ExprKind::ForLoop(pat, err_expr, block, opt_label),\n@@ -2565,7 +2566,7 @@ impl<'a> Parser<'a> {\n         }\n         let attrs = self.parse_inner_attributes()?;\n \n-        let mut arms: Vec<Arm> = Vec::new();\n+        let mut arms = ThinVec::new();\n         while self.token != token::CloseDelim(Delimiter::Brace) {\n             match self.parse_arm() {\n                 Ok(arm) => arms.push(arm),\n@@ -2934,8 +2935,8 @@ impl<'a> Parser<'a> {\n         pth: ast::Path,\n         recover: bool,\n         close_delim: Delimiter,\n-    ) -> PResult<'a, (Vec<ExprField>, ast::StructRest, bool)> {\n-        let mut fields = Vec::new();\n+    ) -> PResult<'a, (ThinVec<ExprField>, ast::StructRest, bool)> {\n+        let mut fields = ThinVec::new();\n         let mut base = ast::StructRest::None;\n         let mut recover_async = false;\n \n@@ -3211,7 +3212,7 @@ impl<'a> Parser<'a> {\n         ExprKind::Index(expr, idx)\n     }\n \n-    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ExprKind {\n+    fn mk_call(&self, f: P<Expr>, args: ThinVec<P<Expr>>) -> ExprKind {\n         ExprKind::Call(f, args)\n     }\n "}, {"sha": "8d0f168e09d7efccc4339a440e40c35ffe697af4", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -14,10 +14,11 @@ use rustc_ast::{\n use rustc_errors::{Applicability, PResult};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n+use thin_vec::ThinVec;\n \n enum PredicateOrStructBody {\n     Predicate(ast::WherePredicate),\n-    StructBody(Vec<ast::FieldDef>),\n+    StructBody(ThinVec<ast::FieldDef>),\n }\n \n impl<'a> Parser<'a> {\n@@ -121,8 +122,8 @@ impl<'a> Parser<'a> {\n \n     /// Parses a (possibly empty) list of lifetime and type parameters, possibly including\n     /// a trailing comma and erroneous trailing attributes.\n-    pub(super) fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n-        let mut params = Vec::new();\n+    pub(super) fn parse_generic_params(&mut self) -> PResult<'a, ThinVec<ast::GenericParam>> {\n+        let mut params = ThinVec::new();\n         let mut done = false;\n         while !done {\n             let attrs = self.parse_outer_attributes()?;\n@@ -251,13 +252,13 @@ impl<'a> Parser<'a> {\n             self.expect_gt()?;\n             (params, span_lo.to(self.prev_token.span))\n         } else {\n-            (vec![], self.prev_token.span.shrink_to_hi())\n+            (ThinVec::new(), self.prev_token.span.shrink_to_hi())\n         };\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n                 has_where_token: false,\n-                predicates: Vec::new(),\n+                predicates: ThinVec::new(),\n                 span: self.prev_token.span.shrink_to_hi(),\n             },\n             span,\n@@ -277,17 +278,17 @@ impl<'a> Parser<'a> {\n         &mut self,\n         struct_name: Ident,\n         body_insertion_point: Span,\n-    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n+    ) -> PResult<'a, (WhereClause, Option<ThinVec<ast::FieldDef>>)> {\n         self.parse_where_clause_common(Some((struct_name, body_insertion_point)))\n     }\n \n     fn parse_where_clause_common(\n         &mut self,\n         struct_: Option<(Ident, Span)>,\n-    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n+    ) -> PResult<'a, (WhereClause, Option<ThinVec<ast::FieldDef>>)> {\n         let mut where_clause = WhereClause {\n             has_where_token: false,\n-            predicates: Vec::new(),\n+            predicates: ThinVec::new(),\n             span: self.prev_token.span.shrink_to_hi(),\n         };\n         let mut tuple_struct_body = None;"}, {"sha": "c0aed6a3789a77e0b1f2b5a889aa36332cd0b080", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use std::fmt::Write;\n use std::mem;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n@@ -56,12 +56,12 @@ impl<'a> Parser<'a> {\n     pub fn parse_mod(\n         &mut self,\n         term: &TokenKind,\n-    ) -> PResult<'a, (AttrVec, Vec<P<Item>>, ModSpans)> {\n+    ) -> PResult<'a, (AttrVec, ThinVec<P<Item>>, ModSpans)> {\n         let lo = self.token.span;\n         let attrs = self.parse_inner_attributes()?;\n \n         let post_attr_lo = self.token.span;\n-        let mut items = vec![];\n+        let mut items = ThinVec::new();\n         while let Some(item) = self.parse_item(ForceCollect::No)? {\n             items.push(item);\n             self.maybe_consume_incorrect_semicolon(&items);\n@@ -646,20 +646,20 @@ impl<'a> Parser<'a> {\n         &mut self,\n         attrs: &mut AttrVec,\n         mut parse_item: impl FnMut(&mut Parser<'a>) -> PResult<'a, Option<Option<T>>>,\n-    ) -> PResult<'a, Vec<T>> {\n+    ) -> PResult<'a, ThinVec<T>> {\n         let open_brace_span = self.token.span;\n \n         // Recover `impl Ty;` instead of `impl Ty {}`\n         if self.token == TokenKind::Semi {\n             self.sess.emit_err(errors::UseEmptyBlockNotSemi { span: self.token.span });\n             self.bump();\n-            return Ok(vec![]);\n+            return Ok(ThinVec::new());\n         }\n \n         self.expect(&token::OpenDelim(Delimiter::Brace))?;\n         attrs.extend(self.parse_inner_attributes()?);\n \n-        let mut items = Vec::new();\n+        let mut items = ThinVec::new();\n         while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n             if self.recover_doc_comment_before_brace() {\n                 continue;\n@@ -997,7 +997,7 @@ impl<'a> Parser<'a> {\n     /// ```text\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n-    fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n+    fn parse_use_tree_list(&mut self) -> PResult<'a, ThinVec<(UseTree, ast::NodeId)>> {\n         self.parse_delim_comma_seq(Delimiter::Brace, |p| {\n             p.recover_diff_marker();\n             Ok((p.parse_use_tree()?, DUMMY_NODE_ID))\n@@ -1288,7 +1288,7 @@ impl<'a> Parser<'a> {\n         let (variants, _) = if self.token == TokenKind::Semi {\n             self.sess.emit_err(errors::UseEmptyBlockNotSemi { span: self.token.span });\n             self.bump();\n-            (vec![], false)\n+            (thin_vec![], false)\n         } else {\n             self.parse_delim_comma_seq(Delimiter::Brace, |p| p.parse_enum_variant()).map_err(\n                 |mut e| {\n@@ -1457,8 +1457,8 @@ impl<'a> Parser<'a> {\n         adt_ty: &str,\n         ident_span: Span,\n         parsed_where: bool,\n-    ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n-        let mut fields = Vec::new();\n+    ) -> PResult<'a, (ThinVec<FieldDef>, /* recovered */ bool)> {\n+        let mut fields = ThinVec::new();\n         let mut recovered = false;\n         if self.eat(&token::OpenDelim(Delimiter::Brace)) {\n             while self.token != token::CloseDelim(Delimiter::Brace) {\n@@ -1498,7 +1498,7 @@ impl<'a> Parser<'a> {\n         Ok((fields, recovered))\n     }\n \n-    pub(super) fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<FieldDef>> {\n+    pub(super) fn parse_tuple_struct_body(&mut self) -> PResult<'a, ThinVec<FieldDef>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n         self.parse_paren_comma_seq(|p| {\n@@ -2374,7 +2374,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    pub(super) fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, Vec<Param>> {\n+    pub(super) fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, ThinVec<Param>> {\n         let mut first_param = true;\n         // Parse the arguments, starting out with `self` being allowed...\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {"}, {"sha": "623c82b37e07da8b0d39446089e5421477dc031a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -36,9 +36,10 @@ use rustc_errors::{\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-\n use std::ops::Range;\n use std::{cmp, mem, slice};\n+use thin_vec::ThinVec;\n+use tracing::debug;\n \n use crate::errors::{\n     DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n@@ -853,11 +854,11 @@ impl<'a> Parser<'a> {\n         sep: SeqSep,\n         expect: TokenExpectType,\n         mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool /* trailing */, bool /* recovered */)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool /* trailing */, bool /* recovered */)> {\n         let mut first = true;\n         let mut recovered = false;\n         let mut trailing = false;\n-        let mut v = vec![];\n+        let mut v = ThinVec::new();\n         let unclosed_delims = !self.unclosed_delims.is_empty();\n \n         while !self.expect_any_with_type(kets, expect) {\n@@ -1037,7 +1038,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool, bool)> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n@@ -1049,7 +1050,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool /* trailing */)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool /* trailing */)> {\n         let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n         if !recovered {\n             self.eat(ket);\n@@ -1066,7 +1067,7 @@ impl<'a> Parser<'a> {\n         ket: &TokenKind,\n         sep: SeqSep,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.expect(bra)?;\n         self.parse_seq_to_end(ket, sep, f)\n     }\n@@ -1075,7 +1076,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         delim: Delimiter,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(delim),\n             &token::CloseDelim(delim),\n@@ -1087,7 +1088,7 @@ impl<'a> Parser<'a> {\n     fn parse_paren_comma_seq<T>(\n         &mut self,\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool)> {\n+    ) -> PResult<'a, (ThinVec<T>, bool)> {\n         self.parse_delim_comma_seq(Delimiter::Parenthesis, f)\n     }\n "}, {"sha": "94f7031fad231872427fc8ffbc8b4d780ed1bf66", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -23,6 +23,7 @@ use rustc_errors::{\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::{respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n+use thin_vec::{thin_vec, ThinVec};\n \n #[derive(PartialEq, Copy, Clone)]\n pub enum Expected {\n@@ -155,15 +156,15 @@ impl<'a> Parser<'a> {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n                 // diagnostics.\n                 let span = leading_vert_span.to(self.prev_token.span);\n-                return Ok((self.mk_pat(span, PatKind::Or(vec![first_pat])), trailing_vert));\n+                return Ok((self.mk_pat(span, PatKind::Or(thin_vec![first_pat])), trailing_vert));\n             }\n \n             return Ok((first_pat, trailing_vert));\n         }\n \n         // Parse the patterns `p_1 | ... | p_n` where `n > 0`.\n         let lo = leading_vert_span.unwrap_or(first_pat.span);\n-        let mut pats = vec![first_pat];\n+        let mut pats = thin_vec![first_pat];\n         loop {\n             match self.eat_or_separator(Some(lo)) {\n                 EatOrResult::AteOr => {}\n@@ -853,7 +854,7 @@ impl<'a> Parser<'a> {\n             e.span_label(path.span, \"while parsing the fields for this pattern\");\n             e.emit();\n             self.recover_stmt();\n-            (vec![], true)\n+            (ThinVec::new(), true)\n         });\n         self.bump();\n         Ok(PatKind::Struct(qself, path, fields, etc))\n@@ -932,8 +933,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the fields of a struct-like pattern.\n-    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<PatField>, bool)> {\n-        let mut fields = Vec::new();\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (ThinVec<PatField>, bool)> {\n+        let mut fields = ThinVec::new();\n         let mut etc = false;\n         let mut ate_comma = true;\n         let mut delayed_err: Option<DiagnosticBuilder<'a, ErrorGuaranteed>> = None;"}, {"sha": "99416c3b20494baab20de66943106a3779f4d765", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -332,7 +332,7 @@ impl<'a> Parser<'a> {\n         style: PathStyle,\n         lo: Span,\n         ty_generics: Option<&Generics>,\n-    ) -> PResult<'a, Vec<AngleBracketedArg>> {\n+    ) -> PResult<'a, ThinVec<AngleBracketedArg>> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n         // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n@@ -472,8 +472,8 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_angle_args(\n         &mut self,\n         ty_generics: Option<&Generics>,\n-    ) -> PResult<'a, Vec<AngleBracketedArg>> {\n-        let mut args = Vec::new();\n+    ) -> PResult<'a, ThinVec<AngleBracketedArg>> {\n+        let mut args = ThinVec::new();\n         while let Some(arg) = self.parse_angle_arg(ty_generics)? {\n             args.push(arg);\n             if !self.eat(&token::Comma) {"}, {"sha": "8ef16ff43e131d024c5ede187eefe3664baa68d8", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -20,8 +20,8 @@ use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym};\n-\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n@@ -544,7 +544,7 @@ impl<'a> Parser<'a> {\n         s: BlockCheckMode,\n         recover: AttemptLocalParseRecovery,\n     ) -> PResult<'a, P<Block>> {\n-        let mut stmts = vec![];\n+        let mut stmts = ThinVec::new();\n         let mut snapshot = None;\n         while !self.eat(&token::CloseDelim(Delimiter::Brace)) {\n             if self.token == token::Eof {\n@@ -662,7 +662,12 @@ impl<'a> Parser<'a> {\n         Ok(Some(stmt))\n     }\n \n-    pub(super) fn mk_block(&self, stmts: Vec<Stmt>, rules: BlockCheckMode, span: Span) -> P<Block> {\n+    pub(super) fn mk_block(\n+        &self,\n+        stmts: ThinVec<Stmt>,\n+        rules: BlockCheckMode,\n+        span: Span,\n+    ) -> P<Block> {\n         P(Block {\n             stmts,\n             id: DUMMY_NODE_ID,\n@@ -682,6 +687,6 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn mk_block_err(&self, span: Span) -> P<Block> {\n-        self.mk_block(vec![self.mk_stmt_err(span)], BlockCheckMode::Default, span)\n+        self.mk_block(thin_vec![self.mk_stmt_err(span)], BlockCheckMode::Default, span)\n     }\n }"}, {"sha": "989a2bdca6d34ec385fd82954dd93bc61e442064", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -21,7 +21,7 @@ use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n /// Any `?` or `~const` modifiers that appear at the start of a bound.\n struct BoundModifiers {\n@@ -273,7 +273,7 @@ impl<'a> Parser<'a> {\n             TyKind::Infer\n         } else if self.check_fn_front_matter(false, Case::Sensitive) {\n             // Function pointer type\n-            self.parse_ty_bare_fn(lo, Vec::new(), None, recover_return_sign)?\n+            self.parse_ty_bare_fn(lo, ThinVec::new(), None, recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n@@ -352,7 +352,7 @@ impl<'a> Parser<'a> {\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                 TyKind::Path(None, path) if maybe_bounds => {\n-                    self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n+                    self.parse_remaining_bounds_path(ThinVec::new(), path, lo, true)\n                 }\n                 TyKind::TraitObject(bounds, TraitObjectSyntax::None)\n                     if maybe_bounds && bounds.len() == 1 && !trailing_plus =>\n@@ -378,7 +378,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_remaining_bounds_path(\n         &mut self,\n-        generic_params: Vec<GenericParam>,\n+        generic_params: ThinVec<GenericParam>,\n         path: ast::Path,\n         lo: Span,\n         parse_plus: bool,\n@@ -511,7 +511,7 @@ impl<'a> Parser<'a> {\n     fn parse_ty_bare_fn(\n         &mut self,\n         lo: Span,\n-        mut params: Vec<GenericParam>,\n+        mut params: ThinVec<GenericParam>,\n         param_insertion_point: Option<Span>,\n         recover_return_sign: RecoverReturnSign,\n     ) -> PResult<'a, TyKind> {\n@@ -545,13 +545,13 @@ impl<'a> Parser<'a> {\n     fn recover_fn_ptr_with_generics(\n         &mut self,\n         lo: Span,\n-        params: &mut Vec<GenericParam>,\n+        params: &mut ThinVec<GenericParam>,\n         param_insertion_point: Option<Span>,\n     ) -> PResult<'a, ()> {\n         let generics = self.parse_generics()?;\n         let arity = generics.params.len();\n \n-        let mut lifetimes: Vec<_> = generics\n+        let mut lifetimes: ThinVec<_> = generics\n             .params\n             .into_iter()\n             .filter(|param| matches!(param.kind, ast::GenericParamKind::Lifetime))\n@@ -662,7 +662,7 @@ impl<'a> Parser<'a> {\n             })))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n-            self.parse_remaining_bounds_path(Vec::new(), path, lo, true)\n+            self.parse_remaining_bounds_path(ThinVec::new(), path, lo, true)\n         } else {\n             // Just a type path.\n             Ok(TyKind::Path(None, path))\n@@ -993,7 +993,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Optionally parses `for<$generic_params>`.\n-    pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n+    pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, ThinVec<GenericParam>> {\n         if self.eat_keyword(kw::For) {\n             self.expect_lt()?;\n             let params = self.parse_generic_params()?;\n@@ -1002,7 +1002,7 @@ impl<'a> Parser<'a> {\n             // parameters, and the lifetime parameters must not have bounds.\n             Ok(params)\n         } else {\n-            Ok(Vec::new())\n+            Ok(ThinVec::new())\n         }\n     }\n \n@@ -1012,7 +1012,7 @@ impl<'a> Parser<'a> {\n     fn recover_fn_trait_with_lifetime_params(\n         &mut self,\n         fn_path: &mut ast::Path,\n-        lifetime_defs: &mut Vec<GenericParam>,\n+        lifetime_defs: &mut ThinVec<GenericParam>,\n     ) -> PResult<'a, ()> {\n         let fn_path_segment = fn_path.segments.last_mut().unwrap();\n         let generic_args = if let Some(p_args) = &fn_path_segment.args {\n@@ -1046,7 +1046,7 @@ impl<'a> Parser<'a> {\n \n         // Parse `(T, U) -> R`.\n         let inputs_lo = self.token.span;\n-        let inputs: Vec<_> =\n+        let inputs: ThinVec<_> =\n             self.parse_fn_params(|_| false)?.into_iter().map(|input| input.ty).collect();\n         let inputs_span = inputs_lo.to(self.prev_token.span);\n         let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No, RecoverReturnSign::No)?;\n@@ -1072,7 +1072,7 @@ impl<'a> Parser<'a> {\n                 kind: ast::GenericParamKind::Lifetime,\n                 colon_span: None,\n             })\n-            .collect::<Vec<GenericParam>>();\n+            .collect::<ThinVec<GenericParam>>();\n         lifetime_defs.append(&mut generic_params);\n \n         let generic_args_span = generic_args.span();"}, {"sha": "3e8a88c7e81c5b7fd676b9c39274e3149fa10d42", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -20,7 +20,7 @@ rustc-rayon-core = { version = \"0.4.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "7d8f75e256608bcf3be4ed63a9f6e0c50f109327", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -22,7 +22,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\"\n \n [features]"}, {"sha": "5c4ec44d2b874f392540e5cf99572c63b4fda533", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -25,5 +25,5 @@ rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "c0446571905c785b09a9e9d48af7306488b9e7fc", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,7 +6,7 @@ edition = \"2021\"\n [dependencies]\n indexmap = \"1.9.1\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.9\"\n+thin-vec = \"0.2.12\"\n \n [dev-dependencies]\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "3c9a154da9ab1b3c0fe4f1102af98da1f6b057e4", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -595,7 +595,7 @@ impl Step for Rustdoc {\n             features.push(\"jemalloc\".to_string());\n         }\n \n-        let cargo = prepare_tool_cargo(\n+        let mut cargo = prepare_tool_cargo(\n             builder,\n             build_compiler,\n             Mode::ToolRustc,\n@@ -606,6 +606,10 @@ impl Step for Rustdoc {\n             features.as_slice(),\n         );\n \n+        if builder.config.rustc_parallel {\n+            cargo.rustflag(\"--cfg=parallel_compiler\");\n+        }\n+\n         let msg = tooling_output(\n             Mode::ToolRustc,\n             \"rustdoc\","}, {"sha": "c48f7998c5a01b847b1656e3b6de37464a24364e", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -18,7 +18,6 @@ serde_json = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = \"1.8.1\"\n tempfile = \"3\"\n-thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n tracing-tree = \"0.2.0\"\n "}, {"sha": "bb62660e19494dc550cd8cb9f9533a3351a6c24d", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -4,6 +4,7 @@ use rustc_ast::{LitKind, MetaItemLit, Path, StrStyle};\n use rustc_span::create_default_session_globals_then;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n+use thin_vec::thin_vec;\n \n fn word_cfg(s: &str) -> Cfg {\n     Cfg::Cfg(Symbol::intern(s), None)\n@@ -34,7 +35,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:ident),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            kind: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(thin_vec![\n                 $(\n                     NestedMetaItem::MetaItem(\n                         dummy_meta_item_word(stringify!($list)),\n@@ -48,7 +49,7 @@ macro_rules! dummy_meta_item_list {\n     ($name:ident, [$($list:expr),* $(,)?]) => {\n         MetaItem {\n             path: Path::from_ident(Ident::from_str(stringify!($name))),\n-            kind: MetaItemKind::List(vec![\n+            kind: MetaItemKind::List(thin_vec![\n                 $(\n                     NestedMetaItem::MetaItem($list),\n                 )*"}, {"sha": "c9c1c2c458a1aa054d03ebb82b136589a6ce9b03", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -470,6 +470,12 @@ pub(crate) fn get_auto_trait_and_blanket_impls(\n     cx: &mut DocContext<'_>,\n     item_def_id: DefId,\n ) -> impl Iterator<Item = Item> {\n+    // FIXME: To be removed once `parallel_compiler` bugs are fixed!\n+    // More information in <https://github.com/rust-lang/rust/pull/106930>.\n+    if cfg!(parallel_compiler) {\n+        return vec![].into_iter().chain(vec![].into_iter());\n+    }\n+\n     let auto_impls = cx\n         .sess()\n         .prof"}, {"sha": "4fcf0873600ab5b4a3d623b16220fda56fc6dea7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::collapsible_if, clippy::collapsible_else_if)]\n #![allow(rustc::potential_query_instability)]\n \n+extern crate thin_vec;\n #[macro_use]\n extern crate tracing;\n "}, {"sha": "9011f0896a057579c53965f3f10a4981d2936f5b", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -42,6 +42,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n extern crate rustc_trait_selection;\n+extern crate thin_vec;\n \n #[macro_use]\n extern crate clippy_utils;"}, {"sha": "06d248204c1f4c5d26a23d4462f0eb977054c374", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -12,9 +12,9 @@ use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::DUMMY_SP;\n-\n use std::cell::Cell;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -214,7 +214,7 @@ macro_rules! always_pat {\n /// Focus on `focus_idx` in `alternatives`,\n /// attempting to extend it with elements of the same constructor `C`\n /// in `alternatives[focus_idx + 1..]`.\n-fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize) -> bool {\n+fn transform_with_focus_on_idx(alternatives: &mut ThinVec<P<Pat>>, focus_idx: usize) -> bool {\n     // Extract the kind; we'll need to make some changes in it.\n     let mut focus_kind = mem::replace(&mut alternatives[focus_idx].kind, PatKind::Wild);\n     // We'll focus on `alternatives[focus_idx]`,\n@@ -296,7 +296,7 @@ fn extend_with_struct_pat(\n     fps1: &mut [ast::PatField],\n     rest1: bool,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n ) -> bool {\n     (0..fps1.len()).any(|idx| {\n         let pos_in_2 = Cell::new(None); // The element `k`.\n@@ -336,9 +336,9 @@ fn extend_with_struct_pat(\n fn extend_with_matching_product(\n     targets: &mut [P<Pat>],\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,\n-    extract: impl Fn(PatKind) -> Vec<P<Pat>>,\n+    extract: impl Fn(PatKind) -> ThinVec<P<Pat>>,\n ) -> bool {\n     (0..targets.len()).any(|idx| {\n         let tail_or = drain_matching(\n@@ -365,14 +365,14 @@ fn take_pat(from: &mut Pat) -> Pat {\n \n /// Extend `target` as an or-pattern with the alternatives\n /// in `tail_or` if there are any and return if there were.\n-fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n-    fn extend(target: &mut Pat, mut tail_or: Vec<P<Pat>>) {\n+fn extend_with_tail_or(target: &mut Pat, tail_or: ThinVec<P<Pat>>) -> bool {\n+    fn extend(target: &mut Pat, mut tail_or: ThinVec<P<Pat>>) {\n         match target {\n             // On an existing or-pattern in the target, append to it.\n             Pat { kind: Or(ps), .. } => ps.append(&mut tail_or),\n             // Otherwise convert the target to an or-pattern.\n             target => {\n-                let mut init_or = vec![P(take_pat(target))];\n+                let mut init_or = thin_vec![P(take_pat(target))];\n                 init_or.append(&mut tail_or);\n                 target.kind = Or(init_or);\n             },\n@@ -391,26 +391,42 @@ fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n // Only elements beginning with `start` are considered for extraction.\n fn drain_matching(\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n-) -> Vec<P<Pat>> {\n-    let mut tail_or = vec![];\n+) -> ThinVec<P<Pat>> {\n+    let mut tail_or = ThinVec::new();\n     let mut idx = 0;\n-    for pat in alternatives.drain_filter(|p| {\n-        // Check if we should extract, but only if `idx >= start`.\n+\n+    // If `ThinVec` had the `drain_filter` method, this loop could be rewritten\n+    // like so:\n+    // \n+    //   for pat in alternatives.drain_filter(|p| {\n+    //       // Check if we should extract, but only if `idx >= start`.\n+    //       idx += 1;\n+    //       idx > start && predicate(&p.kind)\n+    //   }) {\n+    //       tail_or.push(extract(pat.into_inner().kind));\n+    //   }\n+    let mut i = 0;\n+    while i < alternatives.len() {\n         idx += 1;\n-        idx > start && predicate(&p.kind)\n-    }) {\n-        tail_or.push(extract(pat.into_inner().kind));\n+        // Check if we should extract, but only if `idx >= start`.\n+\tif idx > start && predicate(&alternatives[i].kind) {\n+\t    let pat = alternatives.remove(i);\n+            tail_or.push(extract(pat.into_inner().kind));\n+\t} else {\n+\t    i += 1;\n+\t}\n     }\n+\n     tail_or\n }\n \n fn extend_with_matching(\n     target: &mut Pat,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n ) -> bool {"}, {"sha": "d82098523e3bea2a967577714dc9f2929f89e892", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -144,7 +144,8 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (_, Paren(r)) => eq_expr(l, r),\n         (Err, Err) => true,\n         (Box(l), Box(r)) | (Try(l), Try(r)) | (Await(l), Await(r)) => eq_expr(l, r),\n-        (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Array(l), Array(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n         ("}, {"sha": "cbe523c6c3ca98c743bfeb858eca540d84bf6919", "filename": "src/tools/rustfmt/src/chains.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -74,6 +74,8 @@ use crate::utils::{\n     rewrite_ident, trimmed_last_line_width, wrap_str,\n };\n \n+use thin_vec::ThinVec;\n+\n /// Provides the original input contents from the span\n /// of a chain element with trailing spaces trimmed.\n fn format_overflow_style(span: Span, context: &RewriteContext<'_>) -> Option<String> {\n@@ -168,7 +170,7 @@ enum ChainItemKind {\n     MethodCall(\n         ast::PathSegment,\n         Vec<ast::GenericArg>,\n-        Vec<ptr::P<ast::Expr>>,\n+        ThinVec<ptr::P<ast::Expr>>,\n     ),\n     StructField(symbol::Ident),\n     TupleField(symbol::Ident, bool),"}, {"sha": "340113866c4e2b614ed170b4475e5a8787c4aa7c", "filename": "src/tools/rustfmt/src/closures.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -1,5 +1,6 @@\n use rustc_ast::{ast, ptr};\n use rustc_span::Span;\n+use thin_vec::thin_vec;\n \n use crate::attr::get_attrs_from_stmt;\n use crate::config::lists::*;\n@@ -150,7 +151,7 @@ fn rewrite_closure_with_block(\n     }\n \n     let block = ast::Block {\n-        stmts: vec![ast::Stmt {\n+        stmts: thin_vec![ast::Stmt {\n             id: ast::NodeId::root(),\n             kind: ast::StmtKind::Expr(ptr::P(body.clone())),\n             span: body.span,"}, {"sha": "b27405efdb700ee2342a783e996ee1c4781e9846", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -23,6 +23,7 @@ extern crate rustc_expand;\n extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n+extern crate thin_vec;\n \n // Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n // files."}, {"sha": "af9a154a6aea607c7bd834d583ce9779e691155f", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::ast;\n use rustc_ast::visit::Visitor;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::Span;\n+use thin_vec::ThinVec;\n use thiserror::Error;\n \n use crate::attr::MetaVisitor;\n@@ -25,7 +26,7 @@ type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n #[derive(Debug, Clone)]\n pub(crate) struct Module<'a> {\n     ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n-    pub(crate) items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n+    pub(crate) items: Cow<'a, ThinVec<rustc_ast::ptr::P<ast::Item>>>,\n     inner_attr: ast::AttrVec,\n     pub(crate) span: Span,\n }\n@@ -34,7 +35,7 @@ impl<'a> Module<'a> {\n     pub(crate) fn new(\n         mod_span: Span,\n         ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n-        mod_items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n+        mod_items: Cow<'a, ThinVec<rustc_ast::ptr::P<ast::Item>>>,\n         mod_attrs: Cow<'a, ast::AttrVec>,\n     ) -> Self {\n         let inner_attr = mod_attrs\n@@ -157,7 +158,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                     Module::new(\n                         module_item.item.span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ThinVec::new()),\n                         Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n@@ -169,7 +170,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     /// Visit modules defined inside macro calls.\n     fn visit_mod_outside_ast(\n         &mut self,\n-        items: Vec<rustc_ast::ptr::P<ast::Item>>,\n+        items: ThinVec<rustc_ast::ptr::P<ast::Item>>,\n     ) -> Result<(), ModuleResolutionError> {\n         for item in items {\n             if is_cfg_if(&item) {\n@@ -184,7 +185,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                     Module::new(\n                         span,\n                         Some(Cow::Owned(sub_mod_kind.clone())),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ThinVec::new()),\n                         Cow::Owned(ast::AttrVec::new()),\n                     ),\n                 )?;\n@@ -210,7 +211,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                     Module::new(\n                         span,\n                         Some(Cow::Borrowed(sub_mod_kind)),\n-                        Cow::Owned(vec![]),\n+                        Cow::Owned(ThinVec::new()),\n                         Cow::Borrowed(&item.attrs),\n                     ),\n                 )?;"}, {"sha": "7ab042506bd29e813f0872dab0c0dec9bfca5cd1", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::{ast, ptr};\n use rustc_errors::Diagnostic;\n use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n use rustc_span::{sym, Span};\n+use thin_vec::ThinVec;\n \n use crate::attr::first_attr_value_str_by_name;\n use crate::parse::session::ParseSess;\n@@ -109,7 +110,7 @@ impl<'a> Parser<'a> {\n         sess: &'a ParseSess,\n         path: &Path,\n         span: Span,\n-    ) -> Result<(ast::AttrVec, Vec<ptr::P<ast::Item>>, Span), ParserError> {\n+    ) -> Result<(ast::AttrVec, ThinVec<ptr::P<ast::Item>>, Span), ParserError> {\n         let result = catch_unwind(AssertUnwindSafe(|| {\n             let mut parser = new_parser_from_file(sess.inner(), path, Some(span));\n             match parser.parse_mod(&TokenKind::Eof) {"}, {"sha": "a4fad9d3e1ec0a190aa144908383f1501640a7fd", "filename": "tests/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -41,7 +41,7 @@ use rustc_session::parse::ParseSess;\n use rustc_span::source_map::FilePathMapping;\n use rustc_span::source_map::{FileName, Spanned, DUMMY_SP};\n use rustc_span::symbol::Ident;\n-use thin_vec::thin_vec;\n+use thin_vec::{thin_vec, ThinVec};\n \n fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n     let src_as_string = src.to_string();\n@@ -76,17 +76,17 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n     for kind in 0..=19 {\n         match kind {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n-            1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n+            1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, thin_vec![]))),\n             2 => {\n                 let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::MethodCall(Box::new(MethodCall {\n-                        seg: seg.clone(), receiver: e, args: vec![make_x()], span: DUMMY_SP\n+                        seg: seg.clone(), receiver: e, args: thin_vec![make_x()], span: DUMMY_SP\n                     }))\n                 )});\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::MethodCall(Box::new(MethodCall {\n-                        seg: seg.clone(), receiver: make_x(), args: vec![e], span: DUMMY_SP\n+                        seg: seg.clone(), receiver: make_x(), args: thin_vec![e], span: DUMMY_SP\n                     }))\n                 )});\n             }\n@@ -111,7 +111,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             }\n             10 => {\n                 let block = P(Block {\n-                    stmts: Vec::new(),\n+                    stmts: ThinVec::new(),\n                     id: DUMMY_NODE_ID,\n                     rules: BlockCheckMode::Default,\n                     span: DUMMY_SP,\n@@ -121,7 +121,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n             }\n             11 => {\n-                let decl = P(FnDecl { inputs: vec![], output: FnRetTy::Default(DUMMY_SP) });\n+                let decl = P(FnDecl { inputs: thin_vec![], output: FnRetTy::Default(DUMMY_SP) });\n                 iter_exprs(depth - 1, &mut |e| {\n                     g(ExprKind::Closure(Box::new(Closure {\n                         binder: ClosureBinder::NotPresent,\n@@ -165,7 +165,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 g(ExprKind::Struct(P(StructExpr {\n                     qself: None,\n                     path,\n-                    fields: vec![],\n+                    fields: thin_vec![],\n                     rest: StructRest::Base(make_x()),\n                 })));\n             }"}, {"sha": "ee62d8f2d25ce5c204d89253c7c8ad900ae3dfdd", "filename": "tests/ui/stats/hir-stats.stderr", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/3fee48c161a48b0c142d3998fff56faee96bd56c/tests%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fee48c161a48b0c142d3998fff56faee96bd56c/tests%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstats%2Fhir-stats.stderr?ref=3fee48c161a48b0c142d3998fff56faee96bd56c", "patch": "@@ -1,119 +1,119 @@\n ast-stats-1 PRE EXPANSION AST STATS\n ast-stats-1 Name                Accumulated Size         Count     Item Size\n ast-stats-1 ----------------------------------------------------------------\n-ast-stats-1 ExprField                 48 ( 0.6%)             1            48\n-ast-stats-1 GenericArgs               56 ( 0.8%)             1            56\n-ast-stats-1 - AngleBracketed            56 ( 0.8%)             1\n-ast-stats-1 Crate                     56 ( 0.8%)             1            56\n-ast-stats-1 Attribute                 64 ( 0.9%)             2            32\n-ast-stats-1 - Normal                    32 ( 0.4%)             1\n-ast-stats-1 - DocComment                32 ( 0.4%)             1\n-ast-stats-1 Local                     72 ( 1.0%)             1            72\n-ast-stats-1 WherePredicate            72 ( 1.0%)             1            72\n-ast-stats-1 - BoundPredicate            72 ( 1.0%)             1\n-ast-stats-1 Arm                       96 ( 1.3%)             2            48\n-ast-stats-1 ForeignItem               96 ( 1.3%)             1            96\n-ast-stats-1 - Fn                        96 ( 1.3%)             1\n-ast-stats-1 FieldDef                 160 ( 2.2%)             2            80\n-ast-stats-1 Stmt                     160 ( 2.2%)             5            32\n-ast-stats-1 - Local                     32 ( 0.4%)             1\n-ast-stats-1 - MacCall                   32 ( 0.4%)             1\n-ast-stats-1 - Expr                      96 ( 1.3%)             3\n-ast-stats-1 Param                    160 ( 2.2%)             4            40\n-ast-stats-1 FnDecl                   200 ( 2.7%)             5            40\n-ast-stats-1 Variant                  240 ( 3.2%)             2           120\n-ast-stats-1 GenericBound             288 ( 3.9%)             4            72\n-ast-stats-1 - Trait                    288 ( 3.9%)             4\n-ast-stats-1 Block                    288 ( 3.9%)             6            48\n-ast-stats-1 AssocItem                416 ( 5.6%)             4           104\n-ast-stats-1 - Type                     208 ( 2.8%)             2\n-ast-stats-1 - Fn                       208 ( 2.8%)             2\n-ast-stats-1 GenericParam             480 ( 6.5%)             5            96\n-ast-stats-1 Expr                     576 ( 7.8%)             8            72\n-ast-stats-1 - Path                      72 ( 1.0%)             1\n-ast-stats-1 - Match                     72 ( 1.0%)             1\n-ast-stats-1 - Struct                    72 ( 1.0%)             1\n-ast-stats-1 - Lit                      144 ( 1.9%)             2\n-ast-stats-1 - Block                    216 ( 2.9%)             3\n-ast-stats-1 Pat                      616 ( 8.3%)             7            88\n-ast-stats-1 - Struct                    88 ( 1.2%)             1\n-ast-stats-1 - Wild                      88 ( 1.2%)             1\n-ast-stats-1 - Ident                    440 ( 5.9%)             5\n-ast-stats-1 PathSegment              720 ( 9.7%)            30            24\n-ast-stats-1 Ty                       896 (12.1%)            14            64\n-ast-stats-1 - Ptr                       64 ( 0.9%)             1\n-ast-stats-1 - Ref                       64 ( 0.9%)             1\n-ast-stats-1 - ImplicitSelf             128 ( 1.7%)             2\n-ast-stats-1 - Path                     640 ( 8.6%)            10\n-ast-stats-1 Item                   1_656 (22.3%)             9           184\n-ast-stats-1 - Trait                    184 ( 2.5%)             1\n-ast-stats-1 - Enum                     184 ( 2.5%)             1\n-ast-stats-1 - ForeignMod               184 ( 2.5%)             1\n-ast-stats-1 - Impl                     184 ( 2.5%)             1\n-ast-stats-1 - Fn                       368 ( 5.0%)             2\n-ast-stats-1 - Use                      552 ( 7.4%)             3\n+ast-stats-1 GenericArgs               40 ( 0.6%)             1            40\n+ast-stats-1 - AngleBracketed            40 ( 0.6%)             1\n+ast-stats-1 Crate                     40 ( 0.6%)             1            40\n+ast-stats-1 ExprField                 48 ( 0.7%)             1            48\n+ast-stats-1 WherePredicate            56 ( 0.9%)             1            56\n+ast-stats-1 - BoundPredicate            56 ( 0.9%)             1\n+ast-stats-1 Attribute                 64 ( 1.0%)             2            32\n+ast-stats-1 - Normal                    32 ( 0.5%)             1\n+ast-stats-1 - DocComment                32 ( 0.5%)             1\n+ast-stats-1 Local                     72 ( 1.1%)             1            72\n+ast-stats-1 Arm                       96 ( 1.5%)             2            48\n+ast-stats-1 ForeignItem               96 ( 1.5%)             1            96\n+ast-stats-1 - Fn                        96 ( 1.5%)             1\n+ast-stats-1 FnDecl                   120 ( 1.8%)             5            24\n+ast-stats-1 FieldDef                 160 ( 2.4%)             2            80\n+ast-stats-1 Stmt                     160 ( 2.4%)             5            32\n+ast-stats-1 - Local                     32 ( 0.5%)             1\n+ast-stats-1 - MacCall                   32 ( 0.5%)             1\n+ast-stats-1 - Expr                      96 ( 1.5%)             3\n+ast-stats-1 Param                    160 ( 2.4%)             4            40\n+ast-stats-1 Block                    192 ( 2.9%)             6            32\n+ast-stats-1 Variant                  208 ( 3.2%)             2           104\n+ast-stats-1 GenericBound             224 ( 3.4%)             4            56\n+ast-stats-1 - Trait                    224 ( 3.4%)             4\n+ast-stats-1 AssocItem                416 ( 6.3%)             4           104\n+ast-stats-1 - Type                     208 ( 3.2%)             2\n+ast-stats-1 - Fn                       208 ( 3.2%)             2\n+ast-stats-1 GenericParam             480 ( 7.3%)             5            96\n+ast-stats-1 Pat                      504 ( 7.7%)             7            72\n+ast-stats-1 - Struct                    72 ( 1.1%)             1\n+ast-stats-1 - Wild                      72 ( 1.1%)             1\n+ast-stats-1 - Ident                    360 ( 5.5%)             5\n+ast-stats-1 Expr                     576 ( 8.8%)             8            72\n+ast-stats-1 - Path                      72 ( 1.1%)             1\n+ast-stats-1 - Match                     72 ( 1.1%)             1\n+ast-stats-1 - Struct                    72 ( 1.1%)             1\n+ast-stats-1 - Lit                      144 ( 2.2%)             2\n+ast-stats-1 - Block                    216 ( 3.3%)             3\n+ast-stats-1 PathSegment              720 (11.0%)            30            24\n+ast-stats-1 Ty                       896 (13.7%)            14            64\n+ast-stats-1 - Ptr                       64 ( 1.0%)             1\n+ast-stats-1 - Ref                       64 ( 1.0%)             1\n+ast-stats-1 - ImplicitSelf             128 ( 2.0%)             2\n+ast-stats-1 - Path                     640 ( 9.8%)            10\n+ast-stats-1 Item                   1_224 (18.7%)             9           136\n+ast-stats-1 - Trait                    136 ( 2.1%)             1\n+ast-stats-1 - Enum                     136 ( 2.1%)             1\n+ast-stats-1 - ForeignMod               136 ( 2.1%)             1\n+ast-stats-1 - Impl                     136 ( 2.1%)             1\n+ast-stats-1 - Fn                       272 ( 4.2%)             2\n+ast-stats-1 - Use                      408 ( 6.2%)             3\n ast-stats-1 ----------------------------------------------------------------\n-ast-stats-1 Total                  7_416\n+ast-stats-1 Total                  6_552\n ast-stats-1\n ast-stats-2 POST EXPANSION AST STATS\n ast-stats-2 Name                Accumulated Size         Count     Item Size\n ast-stats-2 ----------------------------------------------------------------\n-ast-stats-2 ExprField                 48 ( 0.6%)             1            48\n-ast-stats-2 GenericArgs               56 ( 0.7%)             1            56\n-ast-stats-2 - AngleBracketed            56 ( 0.7%)             1\n-ast-stats-2 Crate                     56 ( 0.7%)             1            56\n-ast-stats-2 Local                     72 ( 0.9%)             1            72\n-ast-stats-2 WherePredicate            72 ( 0.9%)             1            72\n-ast-stats-2 - BoundPredicate            72 ( 0.9%)             1\n-ast-stats-2 Arm                       96 ( 1.2%)             2            48\n-ast-stats-2 ForeignItem               96 ( 1.2%)             1            96\n-ast-stats-2 - Fn                        96 ( 1.2%)             1\n-ast-stats-2 InlineAsm                120 ( 1.5%)             1           120\n-ast-stats-2 Attribute                128 ( 1.6%)             4            32\n+ast-stats-2 GenericArgs               40 ( 0.6%)             1            40\n+ast-stats-2 - AngleBracketed            40 ( 0.6%)             1\n+ast-stats-2 Crate                     40 ( 0.6%)             1            40\n+ast-stats-2 ExprField                 48 ( 0.7%)             1            48\n+ast-stats-2 WherePredicate            56 ( 0.8%)             1            56\n+ast-stats-2 - BoundPredicate            56 ( 0.8%)             1\n+ast-stats-2 Local                     72 ( 1.0%)             1            72\n+ast-stats-2 Arm                       96 ( 1.3%)             2            48\n+ast-stats-2 ForeignItem               96 ( 1.3%)             1            96\n+ast-stats-2 - Fn                        96 ( 1.3%)             1\n+ast-stats-2 InlineAsm                120 ( 1.7%)             1           120\n+ast-stats-2 FnDecl                   120 ( 1.7%)             5            24\n+ast-stats-2 Attribute                128 ( 1.8%)             4            32\n ast-stats-2 - DocComment                32 ( 0.4%)             1\n-ast-stats-2 - Normal                    96 ( 1.2%)             3\n-ast-stats-2 FieldDef                 160 ( 2.0%)             2            80\n-ast-stats-2 Stmt                     160 ( 2.0%)             5            32\n+ast-stats-2 - Normal                    96 ( 1.3%)             3\n+ast-stats-2 FieldDef                 160 ( 2.2%)             2            80\n+ast-stats-2 Stmt                     160 ( 2.2%)             5            32\n ast-stats-2 - Local                     32 ( 0.4%)             1\n ast-stats-2 - Semi                      32 ( 0.4%)             1\n-ast-stats-2 - Expr                      96 ( 1.2%)             3\n-ast-stats-2 Param                    160 ( 2.0%)             4            40\n-ast-stats-2 FnDecl                   200 ( 2.5%)             5            40\n-ast-stats-2 Variant                  240 ( 3.0%)             2           120\n-ast-stats-2 GenericBound             288 ( 3.6%)             4            72\n-ast-stats-2 - Trait                    288 ( 3.6%)             4\n-ast-stats-2 Block                    288 ( 3.6%)             6            48\n-ast-stats-2 AssocItem                416 ( 5.1%)             4           104\n-ast-stats-2 - Type                     208 ( 2.6%)             2\n-ast-stats-2 - Fn                       208 ( 2.6%)             2\n-ast-stats-2 GenericParam             480 ( 5.9%)             5            96\n-ast-stats-2 Pat                      616 ( 7.6%)             7            88\n-ast-stats-2 - Struct                    88 ( 1.1%)             1\n-ast-stats-2 - Wild                      88 ( 1.1%)             1\n-ast-stats-2 - Ident                    440 ( 5.4%)             5\n-ast-stats-2 Expr                     648 ( 8.0%)             9            72\n-ast-stats-2 - Path                      72 ( 0.9%)             1\n-ast-stats-2 - Match                     72 ( 0.9%)             1\n-ast-stats-2 - Struct                    72 ( 0.9%)             1\n-ast-stats-2 - InlineAsm                 72 ( 0.9%)             1\n-ast-stats-2 - Lit                      144 ( 1.8%)             2\n-ast-stats-2 - Block                    216 ( 2.7%)             3\n-ast-stats-2 PathSegment              792 ( 9.8%)            33            24\n-ast-stats-2 Ty                       896 (11.0%)            14            64\n-ast-stats-2 - Ptr                       64 ( 0.8%)             1\n-ast-stats-2 - Ref                       64 ( 0.8%)             1\n-ast-stats-2 - ImplicitSelf             128 ( 1.6%)             2\n-ast-stats-2 - Path                     640 ( 7.9%)            10\n-ast-stats-2 Item                   2_024 (25.0%)            11           184\n-ast-stats-2 - Trait                    184 ( 2.3%)             1\n-ast-stats-2 - Enum                     184 ( 2.3%)             1\n-ast-stats-2 - ExternCrate              184 ( 2.3%)             1\n-ast-stats-2 - ForeignMod               184 ( 2.3%)             1\n-ast-stats-2 - Impl                     184 ( 2.3%)             1\n-ast-stats-2 - Fn                       368 ( 4.5%)             2\n-ast-stats-2 - Use                      736 ( 9.1%)             4\n+ast-stats-2 - Expr                      96 ( 1.3%)             3\n+ast-stats-2 Param                    160 ( 2.2%)             4            40\n+ast-stats-2 Block                    192 ( 2.7%)             6            32\n+ast-stats-2 Variant                  208 ( 2.9%)             2           104\n+ast-stats-2 GenericBound             224 ( 3.1%)             4            56\n+ast-stats-2 - Trait                    224 ( 3.1%)             4\n+ast-stats-2 AssocItem                416 ( 5.8%)             4           104\n+ast-stats-2 - Type                     208 ( 2.9%)             2\n+ast-stats-2 - Fn                       208 ( 2.9%)             2\n+ast-stats-2 GenericParam             480 ( 6.7%)             5            96\n+ast-stats-2 Pat                      504 ( 7.0%)             7            72\n+ast-stats-2 - Struct                    72 ( 1.0%)             1\n+ast-stats-2 - Wild                      72 ( 1.0%)             1\n+ast-stats-2 - Ident                    360 ( 5.0%)             5\n+ast-stats-2 Expr                     648 ( 9.1%)             9            72\n+ast-stats-2 - Path                      72 ( 1.0%)             1\n+ast-stats-2 - Match                     72 ( 1.0%)             1\n+ast-stats-2 - Struct                    72 ( 1.0%)             1\n+ast-stats-2 - InlineAsm                 72 ( 1.0%)             1\n+ast-stats-2 - Lit                      144 ( 2.0%)             2\n+ast-stats-2 - Block                    216 ( 3.0%)             3\n+ast-stats-2 PathSegment              792 (11.1%)            33            24\n+ast-stats-2 Ty                       896 (12.5%)            14            64\n+ast-stats-2 - Ptr                       64 ( 0.9%)             1\n+ast-stats-2 - Ref                       64 ( 0.9%)             1\n+ast-stats-2 - ImplicitSelf             128 ( 1.8%)             2\n+ast-stats-2 - Path                     640 ( 8.9%)            10\n+ast-stats-2 Item                   1_496 (20.9%)            11           136\n+ast-stats-2 - Trait                    136 ( 1.9%)             1\n+ast-stats-2 - Enum                     136 ( 1.9%)             1\n+ast-stats-2 - ExternCrate              136 ( 1.9%)             1\n+ast-stats-2 - ForeignMod               136 ( 1.9%)             1\n+ast-stats-2 - Impl                     136 ( 1.9%)             1\n+ast-stats-2 - Fn                       272 ( 3.8%)             2\n+ast-stats-2 - Use                      544 ( 7.6%)             4\n ast-stats-2 ----------------------------------------------------------------\n-ast-stats-2 Total                  8_112\n+ast-stats-2 Total                  7_152\n ast-stats-2\n hir-stats HIR STATS\n hir-stats Name                Accumulated Size         Count     Item Size"}]}