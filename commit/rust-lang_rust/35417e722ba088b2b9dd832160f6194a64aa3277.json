{"sha": "35417e722ba088b2b9dd832160f6194a64aa3277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDE3ZTcyMmJhMDg4YjJiOWRkODMyMTYwZjYxOTRhNjRhYTMyNzc=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T14:48:50Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T14:48:50Z"}, "message": "renaming throw_err_* to throw_*", "tree": {"sha": "a7a53dd71c5db8349c381ba75053c69b9927e936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7a53dd71c5db8349c381ba75053c69b9927e936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35417e722ba088b2b9dd832160f6194a64aa3277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35417e722ba088b2b9dd832160f6194a64aa3277", "html_url": "https://github.com/rust-lang/rust/commit/35417e722ba088b2b9dd832160f6194a64aa3277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35417e722ba088b2b9dd832160f6194a64aa3277/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb", "html_url": "https://github.com/rust-lang/rust/commit/fc5df1dfbfdd9af311e04b4841f209b0fc9aaafb"}], "stats": {"total": 238, "additions": 112, "deletions": 126}, "files": [{"sha": "a9393561bfd0960783683dc895f2d61606ec301d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -244,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => throw_err_unsup!(UnterminatedCString(ptr.erase_tag())),\n+            None => throw_unsup!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n@@ -446,7 +446,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            throw_err_unsup!(ReadPointerAsBytes)\n+            throw_unsup!(ReadPointerAsBytes)\n         }\n     }\n \n@@ -516,7 +516,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| throw_err_unsup!(ReadUndefBytes(idx)))\n+        ).or_else(|idx| throw_unsup!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "2409d22e5f0a363f4cb7bcb95594e4ff38dc2d00", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -1,45 +1,45 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n #[macro_export]\n-macro_rules! throw_err_unsup {\n+macro_rules! throw_unsup {\n     ($($tt:tt)*) => {\n-        Err($crate::mir::interpret::InterpError::Unsupported(\n+        return Err($crate::mir::interpret::InterpError::Unsupported(\n             $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n         ).into())\n     };\n }\n \n #[macro_export]\n-macro_rules! throw_err_inval {\n+macro_rules! throw_inval {\n     ($($tt:tt)*) => {\n-        Err($crate::mir::interpret::InterpError::InvalidProgram(\n+        return Err($crate::mir::interpret::InterpError::InvalidProgram(\n             $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n         ).into())\n     };\n }\n \n #[macro_export]\n-macro_rules! throw_err_ub {\n+macro_rules! throw_ub {\n     ($($tt:tt)*) => {\n-        Err($crate::mir::interpret::InterpError::UndefinedBehaviour(\n+        return Err($crate::mir::interpret::InterpError::UndefinedBehaviour(\n             $crate::mir::interpret::UndefinedBehaviourInfo::$($tt)*\n         ).into())\n     };\n }\n \n #[macro_export]\n-macro_rules! throw_err_panic {\n+macro_rules! throw_panic {\n     ($($tt:tt)*) => {\n-        Err($crate::mir::interpret::InterpError::Panic(\n+        return Err($crate::mir::interpret::InterpError::Panic(\n             $crate::mir::interpret::PanicInfo::$($tt)*\n         ).into())\n     };\n }\n \n #[macro_export]\n-macro_rules! throw_err_exhaust {\n+macro_rules! throw_exhaust {\n     ($($tt:tt)*) => {\n-        Err($crate::mir::interpret::InterpError::ResourceExhaustion(\n+        return Err($crate::mir::interpret::InterpError::ResourceExhaustion(\n             $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n         ).into())\n     };"}, {"sha": "0a9985133799498cbe6c5734e2bff8d8fa68d8dd", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -74,13 +74,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     #[inline]\n     fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { throw_err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { throw_err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n }\n \n@@ -196,7 +196,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            throw_err_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n+            throw_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n         } else {\n             Ok(())\n         }"}, {"sha": "607bcea7fe80109a224c57dd1b235d4e60f3b4f8", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -360,7 +360,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => throw_err_unsup!(ReadPointerAsBytes),\n+            Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n         }\n     }\n \n@@ -373,8 +373,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => throw_err_unsup!(InvalidNullPointerUsage),\n-            Scalar::Raw { .. } => throw_err_unsup!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => throw_unsup!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => throw_unsup!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -406,15 +406,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => throw_err_unsup!(InvalidBool),\n+            _ => throw_unsup!(InvalidBool),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => throw_err_unsup!(InvalidChar(val as u128)),\n+            None => throw_unsup!(InvalidChar(val as u128)),\n         }\n     }\n \n@@ -537,7 +537,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_err_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "75186b5fcf0626b617b84b7fdebd562004ef742d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -352,9 +352,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    throw_err_unsup!(\n-                        MachineError(format!(\"calling non-const function `{}`\", instance))\n-                    )\n+                    throw_unsup!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n                 };\n             }\n         }\n@@ -414,7 +412,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_err_unsup!(ReadForeignStatic)\n+        throw_unsup!(ReadForeignStatic)\n     }\n \n     #[inline(always)]"}, {"sha": "9e87e112892cd09418ea014cf6a6825999508009", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -199,7 +199,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => throw_err_unsup!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => throw_unsup!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n "}, {"sha": "cd057e059d50d4f778c21c81e6fa2d2211b92fef", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -135,7 +135,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => throw_err_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_unsup!(DeadLocal),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -148,7 +148,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => throw_err_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_unsup!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -305,7 +305,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 &substs,\n             )),\n             None => if substs.needs_subst() {\n-                throw_err_inval!(TooGeneric)\n+                throw_inval!(TooGeneric)\n             } else {\n                 Ok(substs)\n             },\n@@ -339,14 +339,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             && self.tcx.has_typeck_tables(did)\n             && self.tcx.typeck_tables_of(did).tainted_by_errors\n         {\n-            return throw_err_inval!(TypeckError);\n+            throw_inval!(TypeckError)\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                throw_err_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -359,7 +359,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n-                throw_err_inval!(TooGeneric).into()\n+                throw_inval!(TooGeneric)\n             } else {\n                 Ok(t)\n             },\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let substituted = t.subst(*self.tcx, substs);\n \n         if substituted.needs_subst() {\n-            return throw_err_inval!(TooGeneric);\n+            throw_inval!(TooGeneric)\n         }\n \n         Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n@@ -575,7 +575,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n-            throw_err_exhaust!(StackFrameLimitReached)\n+            throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n         }\n@@ -623,7 +623,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         } else {\n             // Uh, that shouldn't happen... the function did not intend to return\n-            return throw_err_ub!(Unreachable);\n+            throw_ub!(Unreachable)\n         }\n         // Jump to new block -- *after* validation so that the spans make more sense.\n         match frame.return_to_block {"}, {"sha": "1cc409d7a9baacab7ca6095c285e3b6d90391e92", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -328,9 +328,7 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return throw_err_unsup!(\n-                ValidationFailure(\"encountered dangling pointer in final constant\".into())\n-            )\n+            throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         }\n     }\n     Ok(())"}, {"sha": "e5af9d86cb32968deb2d4eb9e8bd254283421338", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -104,9 +104,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return throw_err_unsup!(\n-                            Intrinsic(format!(\"{} called on 0\", intrinsic_name))\n-                        );\n+                        throw_unsup!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -192,9 +190,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return throw_err_unsup!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n-                    ));\n+                    throw_unsup!(\n+                        Intrinsic(format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name))\n+                    )\n                 }\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "2e7e2ad93d44c65629292f3db51bbe2f0af21f4b", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        throw_err_unsup!(ReadPointerAsBytes)\n+        throw_unsup!(ReadPointerAsBytes)\n     }\n }"}, {"sha": "949f9194d9ea2635e34018c49dff9997481b68bf", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -66,7 +66,7 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) => throw_err_unsup!(MachineError(format!(\n+            FnVal::Other(_) => throw_unsup!(MachineError(format!(\n                 \"Expected instance function pointer, got 'other' pointer\"\n             ))),\n         }\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return throw_err_unsup!(ReallocateNonBasePtr);\n+            throw_unsup!(ReallocateNonBasePtr)\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -243,40 +243,38 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return throw_err_unsup!(DeallocateNonBasePtr);\n+            throw_unsup!(DeallocateNonBasePtr)\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n-                return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => throw_err_unsup!(DeallocatedWrongMemoryKind(\n+                match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                    Some(GlobalAlloc::Function(..)) => throw_unsup!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n                     Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => throw_err_unsup!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Memory(..)) => throw_unsup!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    None => throw_err_unsup!(DoubleFree)\n+                    None => throw_unsup!(DoubleFree)\n                 }\n             }\n         };\n \n         if alloc_kind != kind {\n-            return throw_err_unsup!(DeallocatedWrongMemoryKind(\n+            throw_unsup!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n-            ));\n+            ))\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return throw_err_unsup!(\n-                    IncorrectAllocationInformation(size, bytes, align, alloc.align)\n-                );\n+                throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n             }\n         }\n \n@@ -321,7 +319,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_err_unsup!(AlignmentCheckFailed {\n+                throw_unsup!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -343,7 +341,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return throw_err_unsup!(InvalidNullPointerUsage);\n+                    throw_unsup!(InvalidNullPointerUsage)\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -364,10 +362,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return throw_err_unsup!(AlignmentCheckFailed {\n+                    throw_unsup!(AlignmentCheckFailed {\n                         has: alloc_align,\n-                        required: align,\n-                    });\n+                        required: align\n+                    })\n                 }\n                 check_offset_align(ptr.offset.bytes(), align)?;\n \n@@ -415,9 +413,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return throw_err_unsup!(DerefFunctionPointer),\n+                throw_unsup!(DerefFunctionPointer),\n             None =>\n-                return throw_err_unsup!(DanglingPointerDeref),\n+                throw_unsup!(DanglingPointerDeref),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -507,11 +505,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return throw_err_unsup!(ModifiedConstantMemory);\n+                throw_unsup!(ModifiedConstantMemory)\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => throw_err_unsup!(ModifiedStatic),\n+                None => throw_unsup!(ModifiedStatic),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -521,7 +519,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return throw_err_unsup!(ModifiedConstantMemory);\n+                    throw_unsup!(ModifiedConstantMemory)\n                 }\n                 Ok(a)\n             }\n@@ -550,7 +548,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(_) = self.get_fn_alloc(id) {\n             return if let AllocCheck::Dereferencable = liveness {\n                 // The caller requested no function pointers.\n-                throw_err_unsup!(DerefFunctionPointer)\n+                throw_unsup!(DerefFunctionPointer)\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -581,7 +579,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     .expect(\"deallocated pointers should all be recorded in \\\n                             `dead_alloc_map`\"))\n             } else {\n-                throw_err_unsup!(DanglingPointerDeref)\n+                throw_unsup!(DanglingPointerDeref)\n             },\n         }\n     }\n@@ -593,7 +591,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         } else {\n             match self.tcx.alloc_map.lock().get(id) {\n                 Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n-                _ => throw_err_unsup!(ExecuteMemory),\n+                _ => throw_unsup!(ExecuteMemory),\n             }\n         }\n     }\n@@ -604,7 +602,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return throw_err_unsup!(InvalidFunctionPointer);\n+            throw_unsup!(InvalidFunctionPointer)\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -839,9 +837,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return throw_err_unsup!(Intrinsic(\n+                        throw_unsup!(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n-                        ));\n+                        ))\n                     }\n                 }\n "}, {"sha": "402a9a5c5ce741e83b0db65a80fc573e3effe676", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -461,7 +461,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n                 PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    return throw_err_unsup!(ReadFromReturnPointer),\n+                    throw_unsup!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -534,7 +534,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match val.val {\n             ConstValue::Param(_) =>\n                 // FIXME(oli-obk): try to monomorphize\n-                return throw_err_inval!(TooGeneric),\n+                throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n@@ -610,7 +610,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n                     Err(_) =>\n-                        return throw_err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                        throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -657,9 +657,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return throw_err_unsup!(\n-                                InvalidDiscriminant(raw_discr.erase_tag().into())\n-                            );\n+                            throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "a942da5771b00b3606d25a518c4c67aaa4289882", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return throw_err_unsup!(Unimplemented(msg));\n+            throw_unsup!(Unimplemented(msg))\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -173,8 +173,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Div if r == 0 => return throw_err_panic!(DivisionByZero),\n-                Rem if r == 0 => return throw_err_panic!(RemainderByZero),\n+                Div if r == 0 => throw_panic!(DivisionByZero),\n+                Rem if r == 0 => throw_panic!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -231,8 +231,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Div if r == 0 => return throw_err_panic!(DivisionByZero),\n-                    Rem if r == 0 => return throw_err_panic!(RemainderByZero),\n+                    Div if r == 0 => throw_panic!(DivisionByZero),\n+                    Rem if r == 0 => throw_panic!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return throw_err_unsup!(Unimplemented(msg));\n+                throw_unsup!(Unimplemented(msg))\n             }\n         };\n "}, {"sha": "f66c4adf763976a33ad969e3681b219efa6b1f01", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -356,7 +356,7 @@ where\n                     // This can be violated because this runs during promotion on code where the\n                     // type system has not yet ensured that such things don't happen.\n                     debug!(\"tried to access element {} of array/slice with length {}\", field, len);\n-                    return throw_err_panic!(BoundsCheck { len, index: field });\n+                    throw_panic!(BoundsCheck { len, index: field });\n                 }\n                 stride * field\n             }\n@@ -622,7 +622,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return throw_err_unsup!(InvalidNullPointerUsage),\n+                    None => throw_unsup!(InvalidNullPointerUsage),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "95824d0ebc16608641930c2fc5af39f4292a4301", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return throw_err_unsup!(InlineAsm),\n+            InlineAsm { .. } => throw_unsup!(InlineAsm),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "aa06922fb95f75ba0f84b21a1ffd49741dc7728b", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -19,7 +19,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n-            throw_err_ub!(Unreachable)\n+            throw_ub!(Unreachable)\n         }\n     }\n \n@@ -89,7 +89,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return throw_err_unsup!(Unimplemented(msg));\n+                        throw_unsup!(Unimplemented(msg))\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -136,28 +136,28 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 } else {\n                     // Compute error message\n                     use rustc::mir::interpret::PanicInfo::*;\n-                    return match msg {\n+                    match msg {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.read_immediate(self.eval_operand(len, None)?)\n                                 .expect(\"can't eval len\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             let index = self.read_immediate(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            throw_err_panic!(BoundsCheck { len, index })\n+                            throw_panic!(BoundsCheck { len, index })\n                         }\n                         Overflow(op) =>\n-                            throw_err_panic!(Overflow(*op)),\n+                            throw_panic!(Overflow(*op)),\n                         OverflowNeg =>\n-                            throw_err_panic!(OverflowNeg),\n+                            throw_panic!(OverflowNeg),\n                         DivisionByZero =>\n-                            throw_err_panic!(DivisionByZero),\n+                            throw_panic!(DivisionByZero),\n                         RemainderByZero =>\n-                            throw_err_panic!(RemainderByZero),\n+                            throw_panic!(RemainderByZero),\n                         GeneratorResumedAfterReturn =>\n-                            throw_err_panic!(GeneratorResumedAfterReturn),\n+                            throw_panic!(GeneratorResumedAfterReturn),\n                         GeneratorResumedAfterPanic =>\n-                            throw_err_panic!(GeneratorResumedAfterPanic),\n+                            throw_panic!(GeneratorResumedAfterPanic),\n                         Panic { .. } =>\n                             bug!(\"`Panic` variant cannot occur in MIR\"),\n                     };\n@@ -173,7 +173,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n                                        `simplify_branches` mir pass\"),\n-            Unreachable => return throw_err_ub!(Unreachable),\n+            Unreachable => throw_ub!(Unreachable),\n         }\n \n         Ok(())\n@@ -226,9 +226,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return throw_err_unsup!(\n-                FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty)\n-            );\n+            throw_unsup!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -256,13 +254,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return throw_err_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                    throw_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic))\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n-                    None => return throw_err_ub!(Unreachable)\n+                    None => throw_ub!(Unreachable)\n                 };\n                 M::call_intrinsic(self, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n@@ -297,7 +295,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return throw_err_unsup!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                        throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n                     }\n                 }\n \n@@ -392,7 +390,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return throw_err_unsup!(FunctionArgCountMismatch);\n+                        throw_unsup!(FunctionArgCountMismatch)\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -404,15 +402,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return throw_err_unsup!(\n+                            throw_unsup!(\n                                 FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n-                            );\n+                            )\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return throw_err_unsup!(FunctionRetMismatch(self.tcx.types.never, ty));\n+                            throw_unsup!(FunctionRetMismatch(self.tcx.types.never, ty))\n                         }\n                     }\n                     Ok(())"}, {"sha": "aa2461729641d4897fe423820a3326bd40fe6916", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -22,7 +22,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        throw_err_unsup!(ValidationFailure(format!(\n+        throw_unsup!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n         )))\n@@ -34,7 +34,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        throw_err_unsup!(ValidationFailure(format!(\n+        throw_unsup!(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n         )))\n@@ -45,14 +45,14 @@ macro_rules! try_validation {\n     ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => return validation_failure!($what, $where, $details),\n+            Err(_) => validation_failure!($what, $where, $details),\n         }\n     }};\n \n     ($e:expr, $what:expr, $where:expr) => {{\n         match $e {\n             Ok(x) => x,\n-            Err(_) => return validation_failure!($what, $where),\n+            Err(_) => validation_failure!($what, $where),\n         }\n     }}\n }\n@@ -408,18 +408,18 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         use super::UnsupportedOpInfo::*;\n                         match err.kind {\n                             InterpError::Unsupported(InvalidNullPointerUsage) =>\n-                                return validation_failure!(\"NULL reference\", self.path),\n+                                validation_failure!(\"NULL reference\", self.path),\n                             InterpError::Unsupported(AlignmentCheckFailed { required, has }) =>\n-                                return validation_failure!(format!(\"unaligned reference \\\n+                                validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n                             InterpError::Unsupported(ReadBytesAsPointer) =>\n-                                return validation_failure!(\n+                                validation_failure!(\n                                     \"dangling reference (created from integer)\",\n                                     self.path\n                                 ),\n                             _ =>\n-                                return validation_failure!(\n+                                validation_failure!(\n                                     \"dangling reference (not entirely in bounds)\",\n                                     self.path\n                                 ),\n@@ -512,27 +512,27 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        return validation_failure!(\n+                        validation_failure!(\n                             \"a potentially NULL pointer\",\n                             self.path,\n                             format!(\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(&layout.valid_range, max_hi)\n                             )\n-                        );\n+                        )\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    return validation_failure!(\n+                    validation_failure!(\n                         \"a pointer\",\n                         self.path,\n                         format!(\n                             \"something that cannot possibly fail to be {}\",\n                             wrapping_range_format(&layout.valid_range, max_hi)\n                         )\n-                    );\n+                    )\n                 }\n             }\n             Ok(data) =>\n@@ -616,9 +616,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 let i = (offset.bytes() / ty_size.bytes()) as usize;\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                return validation_failure!(\n-                                    \"undefined bytes\", self.path\n-                                )\n+                                validation_failure!(\"undefined bytes\", self.path)\n                             },\n                             // Other errors shouldn't be possible\n                             _ => return Err(err),"}, {"sha": "807a7e88498b8bfe092968f70cdd725ee5bf84eb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35417e722ba088b2b9dd832160f6194a64aa3277/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=35417e722ba088b2b9dd832160f6194a64aa3277", "patch": "@@ -441,7 +441,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n                             if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                return throw_err_panic!(OverflowNeg);\n+                                throw_panic!(OverflowNeg)\n                             }\n                         }\n                         UnOp::Not => {"}]}