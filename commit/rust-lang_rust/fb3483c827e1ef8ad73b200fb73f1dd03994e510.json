{"sha": "fb3483c827e1ef8ad73b200fb73f1dd03994e510", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMzQ4M2M4MjdlMWVmOGFkNzNiMjAwZmI3M2YxZGQwMzk5NGU1MTA=", "commit": {"author": {"name": "Martin Hafskjold Thoresen", "email": "martinhath@gmail.com", "date": "2017-01-14T12:58:41Z"}, "committer": {"name": "Martin Hafskjold Thoresen", "email": "martinhath@gmail.com", "date": "2017-01-14T12:58:41Z"}, "message": "Add initial impl of placement-in for `BinaryHeap`", "tree": {"sha": "4016201c6bcd189b5fd294d40687d6fc575e0486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4016201c6bcd189b5fd294d40687d6fc575e0486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb3483c827e1ef8ad73b200fb73f1dd03994e510", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEidYQpaCqAbnv2ZiVbjkx6jLvHjAFAlh6IJIACgkQbjkx6jLv\nHjBRcgf9EQZC7+D0jQJjRCTpBtTzn+hTAqqoKk1fqwSj2hGtNhZhYXyQNb19ZNYT\nIOv6vxiH4VgFaC68/7F5VkGdJ9ki94X3ym1Rn09G8KeRxGDbwMyIEHcP+JHglSic\n5E73JehUveTg9MRcVdjOGeW+59QN2dKuRl3v9tCX9sGZyowhUpTC0GNBl8pV+mtE\nuclwlTuCAm3Y46vXdBORBxnd+kK4Kgaz4Alw+HzIh5POq+rvlf4+WOcHxdMNPUbt\ntr+9THseR2xoeH0Os0C47lZJCXj2JFrFR+PKjyx4S+Bi80cGtFtFJYMTiK+zrZnK\n26uDt6+8pupASsXPHDoKD397W2m3bA==\n=E7zE\n-----END PGP SIGNATURE-----", "payload": "tree 4016201c6bcd189b5fd294d40687d6fc575e0486\nparent 7d82d95af9c54c3947f6c6e21a6d632d9ee468de\nauthor Martin Hafskjold Thoresen <martinhath@gmail.com> 1484398721 +0100\ncommitter Martin Hafskjold Thoresen <martinhath@gmail.com> 1484398721 +0100\n\nAdd initial impl of placement-in for `BinaryHeap`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3483c827e1ef8ad73b200fb73f1dd03994e510", "html_url": "https://github.com/rust-lang/rust/commit/fb3483c827e1ef8ad73b200fb73f1dd03994e510", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb3483c827e1ef8ad73b200fb73f1dd03994e510/comments", "author": null, "committer": null, "parents": [{"sha": "7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d82d95af9c54c3947f6c6e21a6d632d9ee468de", "html_url": "https://github.com/rust-lang/rust/commit/7d82d95af9c54c3947f6c6e21a6d632d9ee468de"}], "stats": {"total": 98, "additions": 97, "deletions": 1}, "files": [{"sha": "8fcc7e0d4da4a817d43a6f24f7adcbfbcab694d7", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fb3483c827e1ef8ad73b200fb73f1dd03994e510/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3483c827e1ef8ad73b200fb73f1dd03994e510/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=fb3483c827e1ef8ad73b200fb73f1dd03994e510", "patch": "@@ -151,7 +151,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut};\n+use core::ops::{Deref, DerefMut, Place, Placer, InPlace};\n use core::iter::{FromIterator, FusedIterator};\n use core::mem::{swap, size_of};\n use core::ptr;\n@@ -688,6 +688,22 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n+    fn sift_up_ind(&mut self, start: usize, pos: usize) -> usize {\n+        unsafe {\n+            // Take out the value at `pos` and create a hole.\n+            let mut hole = Hole::new(&mut self.data, pos);\n+\n+            while hole.pos() > start {\n+                let parent = (hole.pos() - 1) / 2;\n+                if hole.element() <= hole.get(parent) {\n+                    return hole.pos();\n+                }\n+                hole.move_to(parent);\n+            }\n+            hole.pos()\n+        }\n+    }\n+\n     /// Take an element at `pos` and move it down the heap,\n     /// while its children are larger.\n     fn sift_down_range(&mut self, pos: usize, end: usize) {\n@@ -889,6 +905,19 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n }\n \n+impl<T> BinaryHeap<T>\n+where T: Clone + Ord {\n+    /// kek\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place(&mut self) -> PlaceIn<T> {\n+        PlaceIn {\n+            heap: self,\n+        }\n+    }\n+}\n+\n /// Hole represents a hole in a slice i.e. an index without valid value\n /// (because it was moved from or duplicated).\n /// In drop, `Hole` will restore the slice by filling the hole\n@@ -1189,3 +1218,49 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+pub struct PlaceIn<'a, T: 'a>\n+where T: Clone + Ord {\n+    heap: &'a mut BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for PlaceIn<'a, T>\n+where T: Clone + Ord {\n+    fn pointer(&mut self) -> *mut T {\n+        self.heap.data.place_back().pointer()\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for PlaceIn<'a, T>\n+where T: Clone + Ord {\n+    type Place = PlaceIn<'a, T>;\n+\n+    fn make_place(self) -> Self {\n+        let _ = self.heap.data.place_back().make_place();\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for PlaceIn<'a, T>\n+where T: Clone + Ord {\n+    type Owner = &'a T;\n+\n+    unsafe fn finalize(self) -> &'a T {\n+        let len = self.heap.len();\n+        let _ = self.heap.data.place_back().finalize();\n+        let i = self.heap.sift_up_ind(0, len);\n+        &mut self.heap.data[i]\n+    }\n+}"}, {"sha": "a0846f570820e5ef8c96bdf85b7d9f3dc8967a63", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb3483c827e1ef8ad73b200fb73f1dd03994e510/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3483c827e1ef8ad73b200fb73f1dd03994e510/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=fb3483c827e1ef8ad73b200fb73f1dd03994e510", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::panic;\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n \n@@ -310,6 +311,26 @@ fn test_extend_specialization() {\n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n \n+#[test]\n+fn test_placement() {\n+    let mut a = BinaryHeap::new();\n+    a.place() <- 2;\n+    a.place() <- 4;\n+    a.place() <- 3;\n+    assert_eq!(a.peek(), Some(&4));\n+    assert_eq!(a.len(), 3);\n+    a.place() <- 1;\n+    assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n+}\n+\n+#[test]\n+fn test_placement_panic() {\n+    let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n+    fn mkpanic() -> usize { panic!() }\n+    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { heap.place() <- mkpanic(); }));\n+    assert_eq!(heap.len(), 3);\n+}\n+\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {"}]}