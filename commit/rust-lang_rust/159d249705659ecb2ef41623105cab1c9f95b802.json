{"sha": "159d249705659ecb2ef41623105cab1c9f95b802", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWQyNDk3MDU2NTllY2IyZWY0MTYyMzEwNWNhYjFjOWY5NWI4MDI=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-09-05T19:31:12Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2019-09-05T19:31:12Z"}, "message": "annotate-snippet emitter: Deal with multispans from macros, too\n\nThis moves the two methods from the `EmitterWriter` impl to trait\ndefault methods in the `Emitter` trait so that they can be re-used by\nthe `AnnotateSnippetEmitterWriter`.\n\nCloses #61810", "tree": {"sha": "30d3d1b9afcabf3046120b203f1920b6967d7d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30d3d1b9afcabf3046120b203f1920b6967d7d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159d249705659ecb2ef41623105cab1c9f95b802", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJEBAABCgAuFiEEj4U0bmbiMSg/mWqvgqphyqETl+YFAl1xYyUQHGRldkBwaGFu\nc2NoLm5ldAAKCRCCqmHKoROX5rwQEACsMOtKlKqrgLv6sbgSK0dqY/m1zUWRUu+3\nYUrxTa3HQQhq2++JdjjuHVjrS99rW2qAzOGcgSEKYkCSKcXkC6xojVYELss07MgG\nIICUfAr+vq0GDZpyt+X7TR/f33sGv6HuYsVYNbBjIXmLKFp/2mHcdzUfW15ZGGrx\nkyQuDT6SVb4yiqRtiIhK3rLsWlRlFXpzoZKjAoIVJBZDWT913sgpy/0H6PZZF8Hd\n0hgPCBh43EPlA0rSrChwsMVzbKY5iigdU9u7peNZxJymJpYTxZnutFzd4Op5RkS1\nELVQZtxzUbO4UWQHtes5eSa3V2GYTIRkU1bKHkmYZ7Q1eieGAKBcRDFeNB6sptBi\nP308/tA0MuRcHY48siVIMkj2uxKIGrmjOzOaETrQQiatAHQzWeg0E+BBRmv2K25k\nzAYPEurXUS0bJqlcmJxxoukrDFNQJnAYSI7n2enf/r4frB5dKmgotgIOetgwTkgy\nkvxyV+2G2zQpdEyAj4r5EDT4Ik4CXCS/vbGtuP6DLJYeDxtLAcEn/TbJZKHUiCnY\nkgmvFVfpq7mMfUEL4MsB05QyVpSYJqENv+HT2JL+SbhgYLZxwn9t8MXG5MYOnbqt\nSdjDyzPskURtkMYGICHYULDFgzs9GHda8p5Dnzi/H6HVKbnlG/CtHe0qa0MztrZw\nMFPgXRrl7Q==\n=bUAO\n-----END PGP SIGNATURE-----", "payload": "tree 30d3d1b9afcabf3046120b203f1920b6967d7d34\nparent f257c40b199198eacc65bb31f932ee04305e6d41\nauthor Philipp Hansch <dev@phansch.net> 1567711872 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1567711872 +0200\n\nannotate-snippet emitter: Deal with multispans from macros, too\n\nThis moves the two methods from the `EmitterWriter` impl to trait\ndefault methods in the `Emitter` trait so that they can be re-used by\nthe `AnnotateSnippetEmitterWriter`.\n\nCloses #61810\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159d249705659ecb2ef41623105cab1c9f95b802", "html_url": "https://github.com/rust-lang/rust/commit/159d249705659ecb2ef41623105cab1c9f95b802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159d249705659ecb2ef41623105cab1c9f95b802/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f257c40b199198eacc65bb31f932ee04305e6d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/f257c40b199198eacc65bb31f932ee04305e6d41", "html_url": "https://github.com/rust-lang/rust/commit/f257c40b199198eacc65bb31f932ee04305e6d41"}], "stats": {"total": 263, "additions": 137, "deletions": 126}, "files": [{"sha": "60ee7507223e93d670519dff79d215fe50d1dc2f", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/159d249705659ecb2ef41623105cab1c9f95b802/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159d249705659ecb2ef41623105cab1c9f95b802/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=159d249705659ecb2ef41623105cab1c9f95b802", "patch": "@@ -30,10 +30,14 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let children = db.children.clone();\n-        let (primary_span, suggestions) = self.primary_span_formatted(&db);\n-\n-        // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n+\n+        self.fix_multispans_in_std_macros(&self.source_map,\n+                                          &mut primary_span,\n+                                          &mut children,\n+                                          &db.level,\n+                                          db.handler.flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),"}, {"sha": "0ce69eecc6b1ead2068c18a7c9e6805a45282649", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 129, "deletions": 122, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/159d249705659ecb2ef41623105cab1c9f95b802/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159d249705659ecb2ef41623105cab1c9f95b802/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=159d249705659ecb2ef41623105cab1c9f95b802", "patch": "@@ -247,14 +247,142 @@ pub trait Emitter {\n             (primary_span, &db.suggestions)\n         }\n     }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_std_macros(&self,\n+                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                    span: &mut MultiSpan,\n+                                    children: &mut Vec<SubDiagnostic>,\n+                                    level: &Level,\n+                                    backtrace: bool) {\n+        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n+        for child in children.iter_mut() {\n+            spans_updated |= self.fix_multispan_in_std_macros(\n+                                 source_map,\n+                                 &mut child.span,\n+                                 backtrace\n+                             );\n+        }\n+        let msg = if level == &Error {\n+            \"this error originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        } else {\n+            \"this warning originates in a macro outside of the current crate \\\n+             (in Nightly builds, run with -Z external-macro-backtrace \\\n+              for more info)\".to_string()\n+        };\n+\n+        if spans_updated {\n+            children.push(SubDiagnostic {\n+                level: Level::Note,\n+                message: vec![\n+                    (msg,\n+                     Style::NoStyle),\n+                ],\n+                span: MultiSpan::new(),\n+                render_span: None,\n+            });\n+        }\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_std_macros(&self,\n+                                   source_map: &Option<Lrc<SourceMapperDyn>>,\n+                                   span: &mut MultiSpan,\n+                                   always_backtrace: bool) -> bool {\n+        let mut spans_updated = false;\n+\n+        if let Some(ref sm) = source_map {\n+            let mut before_after: Vec<(Span, Span)> = vec![];\n+            let mut new_labels: Vec<(Span, String)> = vec![];\n+\n+            // First, find all the spans in <*macros> and point instead at their use site\n+            for sp in span.primary_spans() {\n+                if sp.is_dummy() {\n+                    continue;\n+                }\n+                let call_sp = sm.call_span_if_macro(*sp);\n+                if call_sp != *sp && !always_backtrace {\n+                    before_after.push((*sp, call_sp));\n+                }\n+                let backtrace_len = sp.macro_backtrace().len();\n+                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                    // Only show macro locations that are local\n+                    // and display them like a span_note\n+                    if trace.def_site_span.is_dummy() {\n+                        continue;\n+                    }\n+                    if always_backtrace {\n+                        new_labels.push((trace.def_site_span,\n+                                            format!(\"in this expansion of `{}`{}\",\n+                                                    trace.macro_decl_name,\n+                                                    if backtrace_len > 2 {\n+                                                        // if backtrace_len == 1 it'll be pointed\n+                                                        // at by \"in this macro invocation\"\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                    }\n+                    // Check to make sure we're not in any <*macros>\n+                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                        !trace.macro_decl_name.starts_with(\"#[\") ||\n+                        always_backtrace {\n+                        new_labels.push((trace.call_site,\n+                                            format!(\"in this macro invocation{}\",\n+                                                    if backtrace_len > 2 && always_backtrace {\n+                                                        // only specify order when the macro\n+                                                        // backtrace is multiple levels deep\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                        if !always_backtrace {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            for (label_span, label_text) in new_labels {\n+                span.push_span_label(label_span, label_text);\n+            }\n+            for sp_label in span.span_labels() {\n+                if sp_label.span.is_dummy() {\n+                    continue;\n+                }\n+                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                    !always_backtrace\n+                {\n+                    let v = sp_label.span.macro_backtrace();\n+                    if let Some(use_site) = v.last() {\n+                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n+                    }\n+                }\n+            }\n+            // After we have them, make sure we replace these 'bad' def sites with their use sites\n+            for (before, after) in before_after {\n+                span.replace(before, after);\n+                spans_updated = true;\n+            }\n+        }\n+\n+        spans_updated\n+    }\n }\n \n impl Emitter for EmitterWriter {\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n-        self.fix_multispans_in_std_macros(&mut primary_span,\n+        self.fix_multispans_in_std_macros(&self.sm,\n+                                          &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n                                           db.handler.flags.external_macro_backtrace);\n@@ -919,127 +1047,6 @@ impl EmitterWriter {\n         max\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(&mut self,\n-                                   span: &mut MultiSpan,\n-                                   always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n-\n-        if let Some(ref sm) = self.sm {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n-\n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n-                    continue;\n-                }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n-                }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n-            }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n-                }\n-            }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n-        }\n-\n-        spans_updated\n-    }\n-\n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(&mut self,\n-                                    span: &mut MultiSpan,\n-                                    children: &mut Vec<SubDiagnostic>,\n-                                    level: &Level,\n-                                    backtrace: bool) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |= self.fix_multispan_in_std_macros(&mut child.span, backtrace);\n-        }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\".to_string()\n-        };\n-\n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![\n-                    (msg,\n-                     Style::NoStyle),\n-                ],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n-        }\n-    }\n-\n     /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n     fn msg_to_buffer(&self,"}]}