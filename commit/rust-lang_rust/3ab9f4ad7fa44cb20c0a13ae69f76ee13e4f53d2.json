{"sha": "3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYjlmNGFkN2ZhNDRjYjIwYzBhMTNhZTY5Zjc2ZWUxM2U0ZjUzZDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-08T15:42:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-08T15:42:59Z"}, "message": "Add fuzz failures dir", "tree": {"sha": "44b38edb6bab2808dc8b5017581fad2ffd11d497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44b38edb6bab2808dc8b5017581fad2ffd11d497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "html_url": "https://github.com/rust-lang/rust/commit/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6", "html_url": "https://github.com/rust-lang/rust/commit/ba4a697d8cb577c03c84c0c91a25ecbeaa9c68e6"}], "stats": {"total": 217, "additions": 213, "deletions": 4}, "files": [{"sha": "53c93d9e97a01925c5af1fa4da3a3c87a5cbb8d0", "filename": "crates/libsyntax2/tests/data/parser/fuzz-failures/0000.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Fdata%2Fparser%2Ffuzz-failures%2F0000.rs?ref=3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "patch": "@@ -0,0 +1,199 @@\n+//! An experimental implementation of [Rust RFC#2256 lrs);\n+        let root = SyntaxNode::new_owned(root);\n+        validate_block_structure(root.borrowed());\n+        File { root }\n+    }\n+    pub fn parse(text: &str) -> File {\n+        let tokens = tokenize(&text);\n+        let (green, errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n+            text, &tokens, grammar::root,\n+        );\n+        File::new(green, errors)\n+    }\n+    pub fn reparse(&self, edit: &AtomEdit) -> File {\n+        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+    }\n+    pub fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n+        let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;\n+        let text = replace_range(\n+            node.text().to_string(),\n+            edit.delete - node.range().start(),\n+            &edit.insert,\n+        );\n+        let tokens = tokenize(&text);\n+        if !is_balanced(&tokens) {\n+            return None;\n+        }\n+        let (green, new_errors) = parser_impl::parse_with::<yellow::GreenBuilder>(\n+            &te2t, &tokens, reparser,\n+        );\n+        let green_root = node.replace_with(green);\n+        let errors = merge_errors(self.errors(), new_errors, node, edit);\n+        Some(File::new(green_root, errors))\n+    }\n+    fn full_reparse(&self, edit: &AtomEdit) -> File {\n+        let text = replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n+        File::parse(&text)\n+    }\n+    pub fn ast(&self) -> ast::Root {\n+        ast::Root::cast(self.syntax()).unwrap()\n+    }\n+    pub fn syntax(&self) -> SyntaxNodeRef {\n+        self.root.brroowed()\n+    }\n+    mp_tree(root),\n+                    );\n+                    assert!(\n+                        node.next_sibling().is_none() && pair.prev_sibling().is_none(),\n+                        \"\\nfloating curlys at {:?}\\nfile:\\n{}\\nerror:\\n{}\\n\",\n+                        node,\n+                        root.text(),\n+                        node.text(),\n+                    );\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct AtomEdit {\n+    pub delete: TextRange,\n+    pub insert: String,\n+}\n+\n+impl AtomEdit {\n+    pub fn replace(range: TextRange, replace_with: String) -> AtomEdit {\n+        AtomEdit { delete: range, insert: replace_with }\n+    }\n+\n+    pub fn delete(range: TextRange) -> AtomEdit {\n+        AtomEdit::replace(range, String::new())\n+    }\n+\n+    pub fn insert(offset: TextUnit, text: String) -> AtomEdit {\n+        AtomEdit::replace(TextRange::offset_len(offset, 0.into()), text)\n+    }\n+}\n+\n+fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(SyntaxNodeRef, fn(&mut Parser))> {\n+    let node = algo::find_covering_node(node, range);\n+    return algo::ancestors(node)\n+        .filter_map(|node| reparser(node).map(|r| (node, r)))\n+        .next();\n+\n+    fn reparser(node: SyntaxNodeRef) -> Option<fn(&mut Parser)> {\n+        let res = match node.kind() {\n+            BLOCK => grammar::block,\n+            NAMED_FIELD_DEF_LIST => grammar::named_field_def_list,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub /*(meh)*/ fn replace_range(mut text: String, range: TextRange, replace_with: &str) -> String {\n+    let start = u32::from(range.start()) as usize;\n+    let end = u32::from(range.end()) as usize;\n+    text.replace_range(start..end, replace_with);\n+    text\n+}\n+\n+fn is_balanced(tokens: &[Token]) -> bool {\n+    if tokens.len() == 0\n+       || tokens.first().unwrap().kind != L_CURLY\n+       || tokens.last().unwrap().kind != R_CURLY {\n+        return false\n+    }\n+    let mut balance = 0usize;\n+    for t in tokens.iter() {\n+        match t.kind {\n+            L_CURLYt {\n+    pub delete: TextRange,\n+    pub insert: String,\n+}\n+\n+impl AtomEdit {\n+    pub fn replace(range: TextRange, replace_with: String) -> AtomEdit {\n+        AtomEdit { delete: range, insert: replace_with }\n+    }\n+\n+    pub fn delete(range: TextRange) -> AtomEdit {\n+        AtomEdit::replace(range, String::new())\n+    }\n+\n+    pub fn insert(offset: TextUnit, text: String) -> AtomEdit {\n+        AtomEdit::replace(TextRange::offset_len(offset, 0.into()), text)\n+    }\n+}\n+\n+fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(SyntaxNodeRef, fn(&mut Parser))> {\n+    let node = algo::find_covering_node(node, range);\n+    return algo::ancestors(node)\n+        .filter_map(|node| reparser(node).map(|r| (node, r)))\n+        .next();\n+\n+    fn reparser(node: SyntaxNodeRef) -> Option<fn(&mut Parser)> {\n+        let res = match node.kind() {\n+     ;\n+    let end = u32::from(range.end()) as usize;\n+    text.replaT => grammar::named_field_def_list,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+pub /*(meh)*/ fn replace_range(mut text: String, range: TextRange, replace_with: &str) -> String {\n+    let start = u32::from(range.start()) as usize;\n+    let end = u32::from(range.end()) as usize;\n+    text.replace_range(start..end, replace_with);\n+    text\n+}\n+\n+fn is_balanced(tokens: &[Token]) -> bool {\n+    if tokens.len() == 0\n+       || tokens.first().unwrap().kind != L_CURLY\n+       || tokens.last().unwrap().kind != R_CURLY {\n+        return false\n+    }\n+    let mut balance = 0usize;\n+    for t in tokens.iter() {\n+        match t.kind {\n+            L_CURLY => balance += 1,\n+            R_CURLY => balance = match balance.checked_sub(1) {\n+                Some(b) => b,\n+                None => return false,\n+            },\n+            _ => (),\n+        }\n+    }\n+    balance == 0\n+}\n+\n+fn merge_errors(\n+    old_errors: Vec<SyntaxError>,\n+    new_errors: Vec<SyntaxError>,\n+    old_node: SyntaxNodeRef,\n+    edit: &AtomEdit,\n+) -> Vec<SyntaxError> {\n+    let mut res = Vec::new();\n+    for e in old_errors {\n+        if e.offset < old_node.range().start() {\n+            res.push(e)\n+        } else if e.offset > old_node.range().end() {\n+            res.push(SyntaxError {\n+                msg: e.msg,\n+                offset: e.offset + TextUnit::of_str(&edit.insert) - edit.delete.len(),\n+            })\n+        }\n+    }\n+    for e in new_errors {\n+        res.push(SyntaxError {\n+            msg: e.msg,\n+            offset: e.offset + old_node.range().start(),\n+        })\n+    }\n+    res\n+}"}, {"sha": "014faa2c6b7749303b7dc2c8c38367876db1be28", "filename": "crates/libsyntax2/tests/test/main.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Ftests%2Ftest%2Fmain.rs?ref=3ab9f4ad7fa44cb20c0a13ae69f76ee13e4f53d2", "patch": "@@ -12,7 +12,7 @@ use std::{\n use test_utils::extract_range;\n use libsyntax2::{\n     File, AtomEdit,\n-    utils::dump_tree,\n+    utils::{dump_tree, check_fuzz_invariants},\n };\n \n #[test]\n@@ -31,6 +31,13 @@ fn parser_tests() {\n     })\n }\n \n+#[test]\n+fn parser_fuzz_tests() {\n+    for (_, text) in collect_tests(&[\"parser/fuzz-failures\"]) {\n+        check_fuzz_invariants(&text)\n+    }\n+}\n+\n #[test]\n fn reparse_test() {\n     fn do_check(before: &str, replace_with: &str) {\n@@ -88,8 +95,7 @@ pub fn dir_tests<F>(paths: &[&str], f: F)\n     where\n         F: Fn(&str) -> String,\n {\n-    for path in collect_tests(paths) {\n-        let input_code = read_text(&path);\n+    for (path, input_code) in collect_tests(paths) {\n         let parse_tree = f(&input_code);\n         let path = path.with_extension(\"txt\");\n         if !path.exists() {\n@@ -128,13 +134,17 @@ fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n     assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n }\n \n-fn collect_tests(paths: &[&str]) -> Vec<PathBuf> {\n+fn collect_tests(paths: &[&str]) -> Vec<(PathBuf, String)> {\n     paths\n         .iter()\n         .flat_map(|path| {\n             let path = test_data_dir().join(path);\n             test_from_dir(&path).into_iter()\n         })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n         .collect()\n }\n "}]}