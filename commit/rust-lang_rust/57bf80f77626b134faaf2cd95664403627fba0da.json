{"sha": "57bf80f77626b134faaf2cd95664403627fba0da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YmY4MGY3NzYyNmIxMzRmYWFmMmNkOTU2NjQ0MDM2MjdmYmEwZGE=", "commit": {"author": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-09-10T19:53:36Z"}, "committer": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-21T15:04:26Z"}, "message": "Add lint for holding RefCell Ref across an await", "tree": {"sha": "d5ca232a663621527d62aec6056124571711e329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ca232a663621527d62aec6056124571711e329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57bf80f77626b134faaf2cd95664403627fba0da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57bf80f77626b134faaf2cd95664403627fba0da", "html_url": "https://github.com/rust-lang/rust/commit/57bf80f77626b134faaf2cd95664403627fba0da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57bf80f77626b134faaf2cd95664403627fba0da/comments", "author": null, "committer": null, "parents": [{"sha": "74530adcba45edbd99bb5a96b45fe2c8e12a31aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/74530adcba45edbd99bb5a96b45fe2c8e12a31aa", "html_url": "https://github.com/rust-lang/rust/commit/74530adcba45edbd99bb5a96b45fe2c8e12a31aa"}], "stats": {"total": 237, "additions": 237, "deletions": 0}, "files": [{"sha": "9a75911acbea857f38a5bf883644d763fac884d9", "filename": "clippy_lints/src/await_holding_refcell_ref.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs?ref=57bf80f77626b134faaf2cd95664403627fba0da", "patch": "@@ -0,0 +1,83 @@\n+use crate::utils::{match_def_path, paths, span_lint_and_note};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::GeneratorInteriorTypeCause;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// `RefCell` `Ref` or `RefMut`.\n+    ///\n+    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n+    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+    /// risks panics from a mutable ref shared while other refs are outstanding.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   let b = x.borrow_mut()();\n+    ///   *ref += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let b = x.borrow_mut();\n+    ///     *ref += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_REFCELL_REF,\n+    pedantic,\n+    \"Inside an async function, holding a RefCell ref while calling await\"\n+}\n+\n+declare_lint_pass!(AwaitHoldingRefCellRef => [AWAIT_HOLDING_REFCELL_REF]);\n+\n+impl LateLintPass<'_> for AwaitHoldingRefCellRef {\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n+        use AsyncGeneratorKind::{Block, Closure, Fn};\n+        if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n+            let body_id = BodyId {\n+                hir_id: body.value.hir_id,\n+            };\n+            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+            let typeck_results = cx.tcx.typeck(def_id);\n+            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n+        }\n+    }\n+}\n+\n+fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+    for ty_cause in ty_causes {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n+            if is_refcell_ref(cx, adt.did) {\n+                span_lint_and_note(\n+                    cx,\n+                    AWAIT_HOLDING_REFCELL_REF,\n+                    ty_cause.span,\n+                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n+                    ty_cause.scope_span.or(Some(span)),\n+                    \"these are all the await points this ref is held through\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n+}"}, {"sha": "6971998610475db27d7c0ae4c692f6f905520e3c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=57bf80f77626b134faaf2cd95664403627fba0da", "patch": "@@ -161,6 +161,7 @@ mod async_yields_async;\n mod atomic_ordering;\n mod attrs;\n mod await_holding_lock;\n+mod await_holding_refcell_ref;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n@@ -510,6 +511,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n         &await_holding_lock::AWAIT_HOLDING_LOCK,\n+        &await_holding_refcell_ref::AWAIT_HOLDING_REFCELL_REF,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -906,6 +908,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n+    store.register_late_pass(|| box await_holding_refcell_ref::AwaitHoldingRefCellRef);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1189,6 +1192,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n         LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_refcell_ref::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),"}, {"sha": "cd9b92efe58373bf7996d0fdd8d9b63233289089", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bf80f77626b134faaf2cd95664403627fba0da/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=57bf80f77626b134faaf2cd95664403627fba0da", "patch": "@@ -93,6 +93,8 @@ pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n+pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n+pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];"}, {"sha": "6e330f47dfc23de5ca91cdf7cc6808db031ba8ea", "filename": "tests/ui/await_holding_refcell_ref.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/57bf80f77626b134faaf2cd95664403627fba0da/tests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57bf80f77626b134faaf2cd95664403627fba0da/tests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.rs?ref=57bf80f77626b134faaf2cd95664403627fba0da", "patch": "@@ -0,0 +1,71 @@\n+// edition:2018\n+#![warn(clippy::await_holding_refcell_ref)]\n+\n+use std::cell::RefCell;\n+\n+async fn bad(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let m = RefCell::new(100);\n+    good(&m);\n+    bad(&m);\n+    bad_mut(&m);    \n+    also_bad(&m);\n+    not_good(&m);\n+    block_bad(&m);\n+}"}, {"sha": "b114945504a291f1e7f72ce1126324c0112e5014", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/57bf80f77626b134faaf2cd95664403627fba0da/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57bf80f77626b134faaf2cd95664403627fba0da/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=57bf80f77626b134faaf2cd95664403627fba0da", "patch": "@@ -0,0 +1,77 @@\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:7:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:7:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:12:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:12:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:33:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:33:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:46:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:46:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:58:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:58:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 5 previous errors\n+"}]}