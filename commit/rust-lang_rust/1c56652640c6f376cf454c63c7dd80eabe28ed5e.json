{"sha": "1c56652640c6f376cf454c63c7dd80eabe28ed5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNTY2NTI2NDBjNmYzNzZjZjQ1NGM2M2M3ZGQ4MGVhYmUyOGVkNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-05T05:02:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-05T05:02:07Z"}, "message": "auto merge of #10064 : luqmana/rust/vvv, r=nikomatsakis\n\nFixes #2057.\r\n\r\nExample:\r\n```Rust\r\n#[no_std];\r\n\r\ntype c_char = u8;\r\ntype c_int = i32;\r\ntype size_t = uint;\r\n\r\nextern {\r\n    fn printf(format: *c_char, ...) -> c_int;\r\n}\r\n\r\n#[lang=\"fail_bounds_check\"]\r\nfn fail_bounds_check(_: *c_char, _: size_t, _: size_t, _: size_t) {}\r\n\r\n#[start]\r\n#[fixed_stack_segment]\r\nfn main(_: int, _: **u8) -> int {\r\n    unsafe {\r\n        let msg = bytes!(\"Hello World!", "tree": {"sha": "57acecc305e4962b080ab2c070b71f96f0e77a2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57acecc305e4962b080ab2c070b71f96f0e77a2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c56652640c6f376cf454c63c7dd80eabe28ed5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c56652640c6f376cf454c63c7dd80eabe28ed5e", "html_url": "https://github.com/rust-lang/rust/commit/1c56652640c6f376cf454c63c7dd80eabe28ed5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c56652640c6f376cf454c63c7dd80eabe28ed5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b04395c11eeb9fa6517a73717184881a977cee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b04395c11eeb9fa6517a73717184881a977cee4", "html_url": "https://github.com/rust-lang/rust/commit/4b04395c11eeb9fa6517a73717184881a977cee4"}, {"sha": "77e0235983ba3ad16f99123604dbbd1401ba8d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/77e0235983ba3ad16f99123604dbbd1401ba8d6c", "html_url": "https://github.com/rust-lang/rust/commit/77e0235983ba3ad16f99123604dbbd1401ba8d6c"}], "stats": {"total": 630, "additions": 527, "deletions": 103}, "files": [{"sha": "043b3dcc7aa57a078b06198a579040dcc67def28", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -29,6 +29,7 @@ pub static False: Bool = 0 as Bool;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n \n+#[deriving(Eq)]\n pub enum CallConv {\n     CCallConv = 0,\n     FastCallConv = 8,"}, {"sha": "b365e7a48795e631e6109a7cf7b4b9a5967d1e4f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -526,10 +526,17 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n+    let variadic = if peek(st) == 'A' {\n+        st.pos += 1; // eat the 'A'\n+        true\n+    } else { false };\n     let ret_ty = parse_ty(st, conv);\n-    ty::FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-               inputs: inputs,\n-               output: ret_ty}\n+    ty::FnSig {\n+        bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n+        inputs: inputs,\n+        output: ret_ty,\n+        variadic: variadic\n+    }\n }\n \n // Rust metadata parsing"}, {"sha": "5397bf0e768d8d237ea32c3e48d5d8d1c874a4ff", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -371,6 +371,9 @@ fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n+    if fsig.variadic {\n+        mywrite!(w, \"A\");\n+    }\n     enc_ty(w, cx, fsig.output);\n }\n "}, {"sha": "ecb53efbad788b29480a3d824ad236d4852c9806", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -750,8 +750,12 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             let mut llargs = ~[];\n             bcx = trans_args(bcx, args, callee_ty,\n                              autoref_arg, &mut llargs);\n+            let arg_tys = match args {\n+                ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n+                ArgVals(_) => fail!(\"expected arg exprs.\")\n+            };\n             bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                             llfn, opt_llretslot.unwrap(), llargs);\n+                                             llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n         }\n \n         // If the caller doesn't care about the result of this fn call,\n@@ -789,6 +793,7 @@ pub fn trans_args(cx: @mut Block,\n     let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n+    let variadic = ty::fn_is_variadic(fn_ty);\n \n     let mut bcx = cx;\n \n@@ -797,10 +802,17 @@ pub fn trans_args(cx: @mut Block,\n     // to cast her view of the arguments to the caller's view.\n     match args {\n       ArgExprs(arg_exprs) => {\n+        let num_formal_args = arg_tys.len();\n         for (i, arg_expr) in arg_exprs.iter().enumerate() {\n+            let arg_ty = if i >= num_formal_args {\n+                assert!(variadic);\n+                expr_ty_adjusted(cx, *arg_expr)\n+            } else {\n+                arg_tys[i]\n+            };\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n-                               arg_tys[i],\n+                               arg_ty,\n                                ty::ByCopy,\n                                *arg_expr,\n                                &mut temp_cleanups,"}, {"sha": "ef843b56f4bf0162a5e481abc0d8f4eccdea8ba2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -120,8 +120,7 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n     let cc = match llvm_calling_convention(ccx, abis) {\n         Some(cc) => cc,\n         None => {\n-            // FIXME(#8357) We really ought to report a span here\n-            ccx.sess.fatal(\n+            ccx.sess.span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable ABI \\\n                       for target architecture \\\n                       in module {}\",\n@@ -135,6 +134,12 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n     let lname = link_name(ccx, foreign_item);\n     let tys = foreign_types_for_id(ccx, foreign_item.id);\n \n+    // Make sure the calling convention is right for variadic functions\n+    // (should've been caught if not in typeck)\n+    if tys.fn_sig.variadic {\n+        assert!(cc == lib::llvm::CCallConv);\n+    }\n+\n     // Create the LLVM value for the C extern fn\n     let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n     let llfn = base::get_extern_fn(&mut ccx.externs, ccx.llmod,\n@@ -148,7 +153,8 @@ pub fn trans_native_call(bcx: @mut Block,\n                          callee_ty: ty::t,\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n-                         llargs_rust: &[ValueRef]) -> @mut Block {\n+                         llargs_rust: &[ValueRef],\n+                         passed_arg_tys: ~[ty::t]) -> @mut Block {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules.\n@@ -160,6 +166,10 @@ pub fn trans_native_call(bcx: @mut Block,\n      * - `llretptr`: where to store the return value of the function\n      * - `llargs_rust`: a list of the argument values, prepared\n      *   as they would be if calling a Rust function\n+     * - `passed_arg_tys`: Rust type for the arguments. Normally we\n+     *   can derive these from callee_ty but in the case of variadic\n+     *   functions passed_arg_tys will include the Rust type of all\n+     *   the arguments including the ones not specified in the fn's signature.\n      */\n \n     let ccx = bcx.ccx();\n@@ -176,7 +186,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n         _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig);\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys);\n     let ret_def = !ty::type_is_voidish(bcx.tcx(), fn_sig.output);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          llsig.llarg_tys,\n@@ -208,7 +218,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         let mut llarg_rust = llarg_rust;\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n+        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n@@ -219,7 +229,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n         if !rust_indirect {\n-            let scratch = base::alloca(bcx, type_of::type_of(ccx, fn_sig.inputs[i]), \"__arg\");\n+            let scratch = base::alloca(bcx, type_of::type_of(ccx, passed_arg_tys[i]), \"__arg\");\n             Store(bcx, llarg_rust, scratch);\n             llarg_rust = scratch;\n         }\n@@ -331,6 +341,20 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                          foreign_mod: &ast::foreign_mod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n+        match foreign_item.node {\n+            ast::foreign_item_fn(*) => {\n+                let (abis, mut path) = match ccx.tcx.items.get_copy(&foreign_item.id) {\n+                    ast_map::node_foreign_item(_, abis, _, path) => (abis, (*path).clone()),\n+                    _ => fail!(\"Unable to find foreign item in tcx.items table.\")\n+                };\n+                if !(abis.is_rust() || abis.is_intrinsic()) {\n+                    path.push(ast_map::path_name(foreign_item.ident));\n+                    register_foreign_item_fn(ccx, abis, &path, foreign_item);\n+                }\n+            }\n+            _ => ()\n+        }\n+\n         let lname = link_name(ccx, foreign_item);\n         ccx.item_symbols.insert(foreign_item.id, lname.to_owned());\n     }\n@@ -701,7 +725,7 @@ pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n     }\n }\n \n-fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n+fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -711,7 +735,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = fn_sig.inputs.map(|&arg| type_of(ccx, arg));\n+    let llarg_tys = arg_tys.map(|&arg| type_of(ccx, arg));\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n@@ -731,7 +755,7 @@ fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig);\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs);\n     let ret_def = !ty::type_is_voidish(ccx.tcx, fn_sig.output);\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys,\n@@ -790,7 +814,11 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n         llargument_tys.push(llarg_ty);\n     }\n \n-    Type::func(llargument_tys, &llreturn_ty)\n+    if tys.fn_sig.variadic {\n+        Type::variadic_func(llargument_tys, &llreturn_ty)\n+    } else {\n+        Type::func(llargument_tys, &llreturn_ty)\n+    }\n }\n \n pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {"}, {"sha": "c56d88355495f4f08bfc4a860a0244d2f2a3c922", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -375,6 +375,7 @@ impl Reflector {\n             self.visit(\"fn_input\", extra);\n         }\n         let extra = ~[self.c_uint(retval),\n+                      self.c_bool(sig.variadic),\n                       self.c_tydesc(sig.output)];\n         self.visit(\"fn_output\", extra);\n     }"}, {"sha": "9e95a9a6449acf8a83842ffe2cdafe80300ad0c8", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -154,6 +154,12 @@ impl Type {\n                                    args.len() as c_uint, False))\n     }\n \n+    pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n+        let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+                                   args.len() as c_uint, True))\n+    }\n+\n     pub fn func_pair(cx: &CrateContext, fn_ty: &Type) -> Type {\n         Type::struct_([fn_ty.ptr_to(), Type::opaque_cbox_ptr(cx)], false)\n     }"}, {"sha": "6c2fb2f095c2ee14be6ba6e16972ad82f078cc56", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -433,12 +433,15 @@ pub struct ClosureTy {\n  *\n  * - `lifetimes` is the list of region names bound in this fn.\n  * - `inputs` is the list of arguments and their modes.\n- * - `output` is the return type. */\n+ * - `output` is the return type.\n+ * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n+ */\n #[deriving(Clone, Eq, IterBytes)]\n pub struct FnSig {\n     bound_lifetime_names: OptVec<ast::Ident>,\n     inputs: ~[t],\n-    output: t\n+    output: t,\n+    variadic: bool\n }\n \n #[deriving(Clone, Eq, IterBytes)]\n@@ -705,6 +708,7 @@ pub enum type_err {\n     terr_float_mismatch(expected_found<ast::float_ty>),\n     terr_traits(expected_found<ast::DefId>),\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n+    terr_variadic_mismatch(expected_found<bool>)\n }\n \n #[deriving(Eq, IterBytes)]\n@@ -1251,7 +1255,8 @@ pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n                    sig: FnSig {\n                     bound_lifetime_names: opt_vec::Empty,\n                     inputs: input_args,\n-                    output: output\n+                    output: output,\n+                    variadic: false\n                    }\n                 })\n }\n@@ -1338,7 +1343,8 @@ pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     FnSig {\n         bound_lifetime_names: sig.bound_lifetime_names.clone(),\n         inputs: args,\n-        output: fldop(sig.output)\n+        output: fldop(sig.output),\n+        variadic: sig.variadic\n     }\n }\n \n@@ -2816,6 +2822,16 @@ fn node_id_has_type_params(cx: ctxt, id: ast::NodeId) -> bool {\n     cx.node_type_substs.contains_key(&id)\n }\n \n+pub fn fn_is_variadic(fty: t) -> bool {\n+    match get(fty).sty {\n+        ty_bare_fn(ref f) => f.sig.variadic,\n+        ty_closure(ref f) => f.sig.variadic,\n+        ref s => {\n+            fail!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n+        }\n+    }\n+}\n+\n pub fn ty_fn_sig(fty: t) -> FnSig {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.clone(),\n@@ -3579,6 +3595,11 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  values.expected.to_str(),\n                  values.found.to_str())\n         }\n+        terr_variadic_mismatch(ref values) => {\n+            format!(\"expected {} fn but found {} function\",\n+                    if values.expected { \"variadic\" } else { \"non-variadic\" },\n+                    if values.found { \"variadic\" } else { \"non-variadic\" })\n+        }\n     }\n }\n "}, {"sha": "45a6d709b04fb7fcac13ad26ef00608a7d1942c2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -396,6 +396,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n+          if bf.decl.variadic && !bf.abis.is_c() {\n+            tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n+          }\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(this, rscope, bf.purity,\n                                             bf.abis, &bf.lifetimes, &bf.decl))\n       }\n@@ -660,9 +663,12 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             ty::BareFnTy {\n                 purity: purity,\n                 abis: abi,\n-                sig: ty::FnSig {bound_lifetime_names: bound_lifetime_names,\n-                                inputs: input_tys,\n-                                output: output_ty}\n+                sig: ty::FnSig {\n+                    bound_lifetime_names: bound_lifetime_names,\n+                    inputs: input_tys,\n+                    output: output_ty,\n+                    variadic: decl.variadic\n+                }\n             });\n \n     fn transform_self_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n@@ -770,9 +776,12 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         onceness: onceness,\n         region: bound_region,\n         bounds: bounds,\n-        sig: ty::FnSig {bound_lifetime_names: bound_lifetime_names,\n-                        inputs: input_tys,\n-                        output: output_ty}\n+        sig: ty::FnSig {\n+            bound_lifetime_names: bound_lifetime_names,\n+            inputs: input_tys,\n+            output: output_ty,\n+            variadic: decl.variadic\n+        }\n     }\n }\n "}, {"sha": "9678331848100f8442bdf1beafe454b89746d1b8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -643,9 +643,17 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n             for item in m.items.iter() {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if tpt.generics.has_type_params() {\n-                    ccx.tcx.sess.span_err(\n-                        item.span,\n-                        format!(\"foreign items may not have type parameters\"));\n+                    ccx.tcx.sess.span_err(item.span, \"foreign items may not have type parameters\");\n+                }\n+\n+                match item.node {\n+                    ast::foreign_item_fn(ref fn_decl, _) => {\n+                        if fn_decl.variadic && !m.abis.is_c() {\n+                            ccx.tcx.sess.span_err(\n+                                item.span, \"variadic function must have C calling convention\");\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -1321,13 +1329,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         if ty::type_is_error(method_fn_ty) {\n             let err_inputs = err_args(args.len());\n             check_argument_types(fcx, sp, err_inputs, callee_expr,\n-                                 args, sugar, deref_args);\n+                                 args, sugar, deref_args, false);\n             method_fn_ty\n         } else {\n             match ty::get(method_fn_ty).sty {\n                 ty::ty_bare_fn(ref fty) => {\n                     check_argument_types(fcx, sp, fty.sig.inputs, callee_expr,\n-                                         args, sugar, deref_args);\n+                                         args, sugar, deref_args, fty.sig.variadic);\n                     fty.sig.output\n                 }\n                 _ => {\n@@ -1339,15 +1347,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n     }\n \n-    fn check_argument_types(\n-        fcx: @mut FnCtxt,\n-        sp: Span,\n-        fn_inputs: &[ty::t],\n-        callee_expr: @ast::Expr,\n-        args: &[@ast::Expr],\n-        sugar: ast::CallSugar,\n-        deref_args: DerefArgs)\n-    {\n+    fn check_argument_types(fcx: @mut FnCtxt,\n+                            sp: Span,\n+                            fn_inputs: &[ty::t],\n+                            callee_expr: @ast::Expr,\n+                            args: &[@ast::Expr],\n+                            sugar: ast::CallSugar,\n+                            deref_args: DerefArgs,\n+                            variadic: bool) {\n         /*!\n          *\n          * Generic function that factors out common logic from\n@@ -1362,6 +1369,19 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let expected_arg_count = fn_inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n             fn_inputs.map(|a| *a)\n+        } else if variadic {\n+            if supplied_arg_count >= expected_arg_count {\n+                fn_inputs.map(|a| *a)\n+            } else {\n+                let msg = format!(\n+                    \"this function takes at least {0, plural, =1{# parameter} \\\n+                    other{# parameters}} but {1, plural, =1{# parameter was} \\\n+                    other{# parameters were}} supplied\", expected_arg_count, supplied_arg_count);\n+\n+                tcx.sess.span_err(sp, msg);\n+\n+                err_args(supplied_arg_count)\n+            }\n         } else {\n             let suffix = match sugar {\n                 ast::NoSugar => \"\",\n@@ -1370,19 +1390,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 ast::ForSugar => \" (including the closure passed by \\\n                                   the `for` keyword)\"\n             };\n-            let msg = format!(\"this function takes {} parameter{} but \\\n-                            {} parameter{} supplied{}\",\n-                           expected_arg_count,\n-                           if expected_arg_count == 1 {\"\"}\n-                           else {\"s\"},\n-                           supplied_arg_count,\n-                           if supplied_arg_count == 1 {\" was\"}\n-                           else {\"s were\"},\n-                           suffix);\n+            let msg = format!(\n+                \"this function takes {0, plural, =1{# parameter} \\\n+                other{# parameters}} but {1, plural, =1{# parameter was} \\\n+                other{# parameters were}} supplied{2}\",\n+                expected_arg_count, supplied_arg_count, suffix);\n \n             tcx.sess.span_err(sp, msg);\n \n-            vec::from_elem(supplied_arg_count, ty::mk_err())\n+            err_args(supplied_arg_count)\n         };\n \n         debug!(\"check_argument_types: formal_tys={:?}\",\n@@ -1406,7 +1422,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 vtable::early_resolve_expr(callee_expr, fcx, true);\n             }\n \n-            for (i, arg) in args.iter().enumerate() {\n+            // For variadic functions, we don't have a declared type for all of\n+            // the arguments hence we only do our usual type checking with\n+            // the arguments who's types we do know.\n+            let t = if variadic {\n+                expected_arg_count\n+            } else {\n+                supplied_arg_count\n+            };\n+            for (i, arg) in args.iter().take(t).enumerate() {\n                 let is_block = match arg.node {\n                     ast::ExprFnBlock(*) |\n                     ast::ExprProc(*) |\n@@ -1431,12 +1455,41 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         DontDerefArgs => {}\n                     }\n \n-                    check_expr_coercable_to_type(\n-                        fcx, *arg, formal_ty);\n+                    check_expr_coercable_to_type(fcx, *arg, formal_ty);\n \n                 }\n             }\n         }\n+\n+        // We also need to make sure we at least write the ty of the other\n+        // arguments which we skipped above.\n+        if variadic {\n+            for arg in args.iter().skip(expected_arg_count) {\n+                check_expr(fcx, *arg);\n+\n+                // There are a few types which get autopromoted when passed via varargs\n+                // in C but we just error out instead and require explicit casts.\n+                let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n+                match ty::get(arg_ty).sty {\n+                    ty::ty_float(ast::ty_f32) => {\n+                        fcx.type_error_message(arg.span,\n+                                |t| format!(\"can't pass an {} to variadic function, \\\n+                                             cast to c_double\", t), arg_ty, None);\n+                    }\n+                    ty::ty_int(ast::ty_i8) | ty::ty_int(ast::ty_i16) | ty::ty_bool => {\n+                        fcx.type_error_message(arg.span,\n+                                |t| format!(\"can't pass {} to variadic function, cast to c_int\",\n+                                            t), arg_ty, None);\n+                    }\n+                    ty::ty_uint(ast::ty_u8) | ty::ty_uint(ast::ty_u16) => {\n+                        fcx.type_error_message(arg.span,\n+                                |t| format!(\"can't pass {} to variadic function, cast to c_uint\",\n+                                            t), arg_ty, None);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n     }\n \n     fn err_args(len: uint) -> ~[ty::t] {\n@@ -1505,7 +1558,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let error_fn_sig = FnSig {\n             bound_lifetime_names: opt_vec::Empty,\n             inputs: err_args(args.len()),\n-            output: ty::mk_err()\n+            output: ty::mk_err(),\n+            variadic: false\n         };\n \n         let fn_sig = match *fn_sty {\n@@ -1532,7 +1586,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n-                             args, sugar, DontDerefArgs);\n+                             args, sugar, DontDerefArgs, fn_sig.variadic);\n \n         write_call(fcx, call_expr, fn_sig.output, sugar);\n     }\n@@ -1914,7 +1968,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fty_sig = FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n                 inputs: fn_ty.sig.inputs.map(|_| ty::mk_err()),\n-                output: ty::mk_err()\n+                output: ty::mk_err(),\n+                variadic: false\n             };\n             ty::mk_err()\n         } else {\n@@ -3898,9 +3953,12 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,\n         abis: AbiSet::Intrinsic(),\n-        sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n-                    inputs: inputs,\n-                    output: output}\n+        sig: FnSig {\n+            bound_lifetime_names: opt_vec::Empty,\n+            inputs: inputs,\n+            output: output,\n+            variadic: false\n+        }\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs.len();"}, {"sha": "353639051097a966b80ba764b6a32ee8fc3c28eb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -605,7 +605,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                                            .bound_lifetime_names\n                                            .clone(),\n                                 inputs: trait_fn_args,\n-                                output: trait_m.fty.sig.output\n+                                output: trait_m.fty.sig.output,\n+                                variadic: false\n                             }\n                         });\n     let impl_fty =\n@@ -620,7 +621,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                                           .bound_lifetime_names\n                                           .clone(),\n                                     inputs: impl_fn_args,\n-                                    output: impl_m.fty.sig.output\n+                                    output: impl_m.fty.sig.output,\n+                                    variadic: false\n                             }\n                         });\n \n@@ -1291,9 +1293,12 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty::BareFnTy {\n             abis: abis,\n             purity: ast::unsafe_fn,\n-            sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: input_tys,\n-                            output: output_ty}\n+            sig: ty::FnSig {\n+                bound_lifetime_names: opt_vec::Empty,\n+                inputs: input_tys,\n+                output: output_ty,\n+                variadic: decl.variadic\n+            }\n         });\n     let tpt = ty_param_bounds_and_ty {\n         generics: ty_generics,"}, {"sha": "5d0f44ae7e3563fef8d0ec92583d2d81f1d14ce2", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -414,8 +414,7 @@ pub fn eq_opt_regions<C:Combine>(\n     }\n }\n \n-pub fn super_fn_sigs<C:Combine>(\n-    this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n         if a_args.len() == b_args.len() {\n@@ -426,12 +425,19 @@ pub fn super_fn_sigs<C:Combine>(\n         }\n     }\n \n+    if a.variadic != b.variadic {\n+        return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n+    }\n+\n     do argvecs(this, a.inputs, b.inputs)\n             .and_then |inputs| {\n         do this.tys(a.output, b.output).and_then |output| {\n-            Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-                      inputs: inputs.clone(),\n-                      output: output})\n+            Ok(FnSig {\n+                bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n+                inputs: inputs.clone(),\n+                output: output,\n+                variadic: a.variadic\n+            })\n         }\n     }\n }"}, {"sha": "d7a00ebf0e940ad8f5437b48741a891dafa98a2c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -190,8 +190,11 @@ impl Env {\n                           onceness: ast::Many,\n                           region: ty::re_static,\n                           bounds: @~[]},\n-            sig: FnSig {inputs: inputs,\n-                        output: output_ty}\n+            sig: FnSig {\n+                inputs: inputs,\n+                output: output_ty,\n+                variadic: false\n+            }\n         })\n     }\n "}, {"sha": "75c7adfb03e405e764d2f9eae5368995e637d023", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -356,7 +356,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 sig: ty::FnSig {\n                     bound_lifetime_names: opt_vec::Empty,\n                     inputs: ~[],\n-                    output: ty::mk_nil()\n+                    output: ty::mk_nil(),\n+                    variadic: false\n                 }\n             });\n \n@@ -404,7 +405,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n                     ],\n-                    output: ty::mk_int()\n+                    output: ty::mk_int(),\n+                    variadic: false\n                 }\n             });\n "}, {"sha": "006e14232f368e65fdf1c1d7f2bce5ac4eedb3ab", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -410,7 +410,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         s.push_char(bra);\n         let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n         s.push_str(strs.connect(\", \"));\n+        if sig.variadic {\n+            s.push_str(\", ...\");\n+        }\n         s.push_char(ket);\n+\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {"}, {"sha": "c841750d7ce7a093231a2ee274b9adf37a74c4b0", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -382,11 +382,18 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n+        true\n+    }\n+\n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {"}, {"sha": "97b42a1ebc1ca36094bd6b85834963c2b2f359ae", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -572,6 +572,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_fn_output(&mut self, _retstyle: uint, inner: *TyDesc) -> bool {\n         self.writer.write(\")\".as_bytes());\n         let name = unsafe { (*inner).name };\n@@ -582,6 +583,20 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n         true\n     }\n \n+    #[cfg(not(stage0))]\n+    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+        if variadic {\n+            self.writer.write(\", ...\".as_bytes());\n+        }\n+        self.writer.write(\")\".as_bytes());\n+        let name = unsafe { (*inner).name };\n+        if name != \"()\" {\n+            self.writer.write(\" -> \".as_bytes());\n+            self.writer.write(name.as_bytes());\n+        }\n+        true\n+    }\n+\n     fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n "}, {"sha": "404ed85985c422dcdaea509fa0a9b38381c23712", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -160,7 +160,10 @@ pub trait TyVisitor {\n     fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n     fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n+    #[cfg(stage0)]\n     fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool;\n+    #[cfg(not(stage0))]\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool;\n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n "}, {"sha": "6aec7380f40156d4641521c81940191b0efd299d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -892,6 +892,7 @@ pub struct fn_decl {\n     inputs: ~[arg],\n     output: Ty,\n     cf: ret_style,\n+    variadic: bool\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]"}, {"sha": "0a5e20fc2b29a3eae8ab603848dc06f3c655aab4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -728,6 +728,7 @@ impl AstBuilder for @ExtCtxt {\n             inputs: inputs,\n             output: output,\n             cf: ast::return_val,\n+            variadic: false\n         }\n     }\n "}, {"sha": "388de29b45680c3fe470deeb67c9a84a695c9091", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -99,6 +99,7 @@ pub trait ast_fold {\n                                                                       self)),\n                                 output: self.fold_ty(&fdec.output),\n                                 cf: fdec.cf,\n+                                variadic: fdec.variadic\n                             },\n                             fold_generics(generics, self))\n                     }\n@@ -466,6 +467,7 @@ pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n         output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n+        variadic: decl.variadic\n     }\n }\n "}, {"sha": "49445312a12f6a7df91f1d0a7edbddca5204d2de", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -664,12 +664,18 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       ';' => { bump(rdr); return token::SEMI; }\n       ',' => { bump(rdr); return token::COMMA; }\n       '.' => {\n-        bump(rdr);\n-        if rdr.curr == '.' && nextch(rdr) != '.' {\n-            bump(rdr);\n-            return token::DOTDOT;\n-        }\n-        return token::DOT;\n+          bump(rdr);\n+          return if rdr.curr == '.' {\n+              bump(rdr);\n+              if rdr.curr == '.' {\n+                  bump(rdr);\n+                  token::DOTDOTDOT\n+              } else {\n+                  token::DOTDOT\n+              }\n+          } else {\n+              token::DOT\n+          };\n       }\n       '(' => { bump(rdr); return token::LPAREN; }\n       ')' => { bump(rdr); return token::RPAREN; }"}, {"sha": "6c81784b5dee48e09154ff74dc6049809261b853", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -701,7 +701,8 @@ mod test {\n                                 output: ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                  node: ast::ty_nil,\n                                                  span:sp(15,15)}, // not sure\n-                                cf: ast::return_val\n+                                cf: ast::return_val,\n+                                variadic: false\n                             },\n                                     ast::impure_fn,\n                                     abi::AbiSet::Rust(),"}, {"sha": "7c98d8d1c85b344db905e616f2ef218032048cad", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -863,7 +863,7 @@ impl Parser {\n         let abis = opt_abis.unwrap_or(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n-        let (decl, lifetimes) = self.parse_ty_fn_decl();\n+        let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n         return ty_bare_fn(@TyBareFn {\n             abis: abis,\n             purity: purity,\n@@ -875,7 +875,7 @@ impl Parser {\n     // Parses a procedure type (`proc`). The initial `proc` keyword must\n     // already have been parsed.\n     pub fn parse_proc_type(&self) -> ty_ {\n-        let (decl, lifetimes) = self.parse_ty_fn_decl();\n+        let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n         ty_closure(@TyClosure {\n             sigil: OwnedSigil,\n             region: None,\n@@ -919,7 +919,7 @@ impl Parser {\n                 // Old-style closure syntax (`fn(A)->B`).\n                 self.expect_keyword(keywords::Fn);\n                 let bounds = self.parse_optional_ty_param_bounds();\n-                let (decl, lifetimes) = self.parse_ty_fn_decl();\n+                let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n                 (sigil, decl, lifetimes, bounds)\n             }\n             None => {\n@@ -960,6 +960,7 @@ impl Parser {\n                     inputs: inputs,\n                     output: output,\n                     cf: return_style,\n+                    variadic: false\n                 };\n \n                 (BorrowedSigil, decl, lifetimes, bounds)\n@@ -994,7 +995,7 @@ impl Parser {\n     }\n \n     // parse a function type (following the 'fn')\n-    pub fn parse_ty_fn_decl(&self) -> (fn_decl, OptVec<ast::Lifetime>) {\n+    pub fn parse_ty_fn_decl(&self, allow_variadic: bool) -> (fn_decl, OptVec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -1013,17 +1014,13 @@ impl Parser {\n             opt_vec::Empty\n         };\n \n-        let inputs = self.parse_unspanned_seq(\n-            &token::LPAREN,\n-            &token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_arg_general(false)\n-        );\n+        let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         let decl = ast::fn_decl {\n             inputs: inputs,\n             output: ret_ty,\n-            cf: ret_style\n+            cf: ret_style,\n+            variadic: variadic\n         };\n         (decl, lifetimes)\n     }\n@@ -2475,7 +2472,8 @@ impl Parser {\n                               node: ty_infer,\n                               span: *self.span\n                           },\n-                          cf: return_val\n+                          cf: return_val,\n+                          variadic: false\n                       }\n                   }\n                 }\n@@ -3526,21 +3524,63 @@ impl Parser {\n         (lifetimes, opt_vec::take_vec(result))\n     }\n \n-    // parse the argument list and result type of a function declaration\n-    pub fn parse_fn_decl(&self) -> fn_decl {\n-        let args: ~[arg] =\n+    fn parse_fn_args(&self, named_args: bool, allow_variadic: bool) -> (~[arg], bool) {\n+        let sp = *self.span;\n+        let mut args: ~[Option<arg>] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA),\n-                |p| p.parse_arg()\n+                |p| {\n+                    if *p.token == token::DOTDOTDOT {\n+                        p.bump();\n+                        if allow_variadic {\n+                            if *p.token != token::RPAREN {\n+                                p.span_fatal(*p.span,\n+                                    \"`...` must be last in argument list for variadic function\");\n+                            }\n+                        } else {\n+                            p.span_fatal(*p.span,\n+                                         \"only foreign functions are allowed to be variadic\");\n+                        }\n+                        None\n+                    } else {\n+                        Some(p.parse_arg_general(named_args))\n+                    }\n+                }\n             );\n \n+        let variadic = match args.pop_opt() {\n+            Some(None) => true,\n+            Some(x) => {\n+                // Need to put back that last arg\n+                args.push(x);\n+                false\n+            }\n+            None => false\n+        };\n+\n+        if variadic && args.is_empty() {\n+            self.span_err(sp,\n+                          \"variadic function must be declared with at least one named argument\");\n+        }\n+\n+        let args = args.move_iter().map(|x| x.unwrap()).collect();\n+\n+        (args, variadic)\n+    }\n+\n+    // parse the argument list and result type of a function declaration\n+    pub fn parse_fn_decl(&self, allow_variadic: bool) -> fn_decl {\n+\n+        let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n+\n         ast::fn_decl {\n             inputs: args,\n             output: ret_ty,\n             cf: ret_style,\n+            variadic: variadic\n         }\n     }\n \n@@ -3729,7 +3769,8 @@ impl Parser {\n         let fn_decl = ast::fn_decl {\n             inputs: fn_inputs,\n             output: ret_ty,\n-            cf: ret_style\n+            cf: ret_style,\n+            variadic: false\n         };\n \n         (spanned(lo, hi, explicit_self), fn_decl)\n@@ -3759,6 +3800,7 @@ impl Parser {\n             inputs: inputs_captures,\n             output: output,\n             cf: return_val,\n+            variadic: false\n         }\n     }\n \n@@ -3784,6 +3826,7 @@ impl Parser {\n             inputs: inputs,\n             output: output,\n             cf: return_val,\n+            variadic: false\n         }\n     }\n \n@@ -3808,7 +3851,7 @@ impl Parser {\n     // parse an item-position function declaration.\n     fn parse_item_fn(&self, purity: purity, abis: AbiSet) -> item_info {\n         let (ident, generics) = self.parse_fn_header();\n-        let decl = self.parse_fn_decl();\n+        let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         (ident,\n          item_fn(decl, purity, abis, generics, body),\n@@ -4239,7 +4282,7 @@ impl Parser {\n         }\n \n         let (ident, generics) = self.parse_fn_header();\n-        let decl = self.parse_fn_decl();\n+        let decl = self.parse_fn_decl(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,"}, {"sha": "63f4f97889c6dfd82ef6ed011222c0cf4f68cafc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -54,6 +54,7 @@ pub enum Token {\n     AT,\n     DOT,\n     DOTDOT,\n+    DOTDOTDOT,\n     COMMA,\n     SEMI,\n     COLON,\n@@ -147,6 +148,7 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       AT => ~\"@\",\n       DOT => ~\".\",\n       DOTDOT => ~\"..\",\n+      DOTDOTDOT => ~\"...\",\n       COMMA => ~\",\",\n       SEMI => ~\";\",\n       COLON => ~\":\","}, {"sha": "08c2ae88e4fabbf14966ff947bd6423bea63b150", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -1774,6 +1774,9 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n                              opt_explicit_self: Option<ast::explicit_self_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_explicit_self);\n+    if decl.variadic {\n+        word(s.s, \", ...\");\n+    }\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n@@ -2066,6 +2069,9 @@ pub fn print_ty_fn(s: @ps,\n \n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     } else {\n+        if decl.variadic {\n+            word(s.s, \", ...\");\n+        }\n         pclose(s);\n     }\n \n@@ -2408,7 +2414,8 @@ mod test {\n             output: ast::Ty {id: 0,\n                               node: ast::ty_nil,\n                               span: codemap::dummy_sp()},\n-            cf: ast::return_val\n+            cf: ast::return_val,\n+            variadic: false\n         };\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::impure_fn, abba_ident,"}, {"sha": "93f702d8052de88f263d36419f296201ef7ac0d8", "filename": "src/test/compile-fail/variadic-ffi-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-1.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    fn printf(...); //~ ERROR: variadic function must be declared with at least one named argument\n+    fn printf(..., foo: int); //~ ERROR: `...` must be last in argument list for variadic function\n+}\n+\n+fn main() {}"}, {"sha": "9e2b015f33d96e4c91c2dcda4314a0ca9ee139e8", "filename": "src/test/compile-fail/variadic-ffi-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn baz(f: extern \"stdcall\" fn(uint, ...)) {\n+    //~^ ERROR: variadic function must have C calling convention\n+    f(22, 44);\n+}\n+\n+fn main() {}"}, {"sha": "f143e715450ff33e152c859830540b0dc3fa3afb", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(x: int, ...) {\n+    //~^ ERROR: only foreign functions are allowed to be variadic\n+}\n+\n+fn main() {}"}, {"sha": "d4c54dfffe0a36221544ca38114737f429c7c063", "filename": "src/test/compile-fail/variadic-ffi-4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-4.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"C\" fn foo(x: int, ...) {\n+    //~^ ERROR: only foreign functions are allowed to be variadic\n+}\n+\n+fn main() {}"}, {"sha": "4133f008cbfbab617ee792946bad394686aead10", "filename": "src/test/compile-fail/variadic-ffi.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"stdcall\" {\n+    fn printf(_: *u8, ...); //~ ERROR: variadic function must have C calling convention\n+}\n+\n+extern {\n+    fn foo(f: int, x: u8, ...);\n+}\n+\n+extern \"C\" fn bar(f: int, x: u8) {}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    unsafe {\n+        foo(); //~ ERROR: this function takes at least 2 parameters but 0 parameters were supplied\n+        foo(1); //~ ERROR: this function takes at least 2 parameters but 1 parameter was supplied\n+\n+        let x: extern \"C\" unsafe fn(f: int, x: u8) = foo;\n+        //~^ ERROR: mismatched types: expected `extern \"C\" unsafe fn(int, u8)` but found `extern \"C\" unsafe fn(int, u8, ...)` (expected non-variadic fn but found variadic function)\n+\n+        let y: extern \"C\" unsafe fn(f: int, x: u8, ...) = bar;\n+        //~^ ERROR: mismatched types: expected `extern \"C\" unsafe fn(int, u8, ...)` but found `extern \"C\" extern fn(int, u8)` (expected variadic fn but found non-variadic function)\n+\n+        foo(1, 2, 3f32); //~ ERROR: can't pass an f32 to variadic function, cast to c_double\n+        foo(1, 2, true); //~ ERROR: can't pass bool to variadic function, cast to c_int\n+        foo(1, 2, 1i8); //~ ERROR: can't pass i8 to variadic function, cast to c_int\n+        foo(1, 2, 1u8); //~ ERROR: can't pass u8 to variadic function, cast to c_uint\n+        foo(1, 2, 1i16); //~ ERROR: can't pass i16 to variadic function, cast to c_int\n+        foo(1, 2, 1u16); //~ ERROR: can't pass u16 to variadic function, cast to c_uint\n+    }\n+}"}, {"sha": "42614f76539283df7ee882252f948d3f2b17e592", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -366,8 +366,8 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         true\n     }\n \n-    fn visit_fn_output(&mut self, retstyle: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n         true\n     }\n \n@@ -603,7 +603,7 @@ impl TyVisitor for my_visitor {\n     fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *TyDesc) -> bool {\n         true\n     }\n     fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,"}, {"sha": "03722cd0fbf2c268645cc583f6effbbe7208ec42", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -135,7 +135,7 @@ impl TyVisitor for MyVisitor {\n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n     fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *TyDesc) -> bool { true }\n     fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n "}, {"sha": "6f8867afef324f079222c568ac3a2a1f1ccd9ca2", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c56652640c6f376cf454c63c7dd80eabe28ed5e/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=1c56652640c6f376cf454c63c7dd80eabe28ed5e", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::c_str::CString;\n+use std::libc::{c_char, c_int};\n+\n+extern {\n+    fn sprintf(s: *mut c_char, format: *c_char, ...) -> c_int;\n+}\n+\n+unsafe fn check<T>(expected: &str, f: &fn(*mut c_char) -> T) {\n+    let mut x = [0i8, ..50];\n+    f(&mut x[0] as *mut c_char);\n+    let res = CString::new(&x[0], false);\n+    assert_eq!(expected, res.as_str().unwrap());\n+}\n+\n+#[fixed_stack_segment]\n+pub fn main() {\n+\n+    unsafe {\n+        // Call with just the named parameter\n+        do \"Hello World\\n\".with_c_str |c| {\n+            check(\"Hello World\\n\", |s| sprintf(s, c));\n+        }\n+\n+        // Call with variable number of arguments\n+        do \"%d %f %c %s\\n\".with_c_str |c| {\n+            do check(\"42 42.500000 a %d %f %c %s\\n\\n\") |s| {\n+                sprintf(s, c, 42i, 42.5f64, 'a' as c_int, c);\n+            }\n+        }\n+\n+        // Make a function pointer\n+        let x: extern \"C\" unsafe fn(*mut c_char, *c_char, ...) -> c_int = sprintf;\n+\n+        // A function that takes a function pointer\n+        unsafe fn call(p: extern \"C\" unsafe fn(*mut c_char, *c_char, ...) -> c_int) {\n+            #[fixed_stack_segment];\n+\n+            // Call with just the named parameter via fn pointer\n+            do \"Hello World\\n\".with_c_str |c| {\n+                check(\"Hello World\\n\", |s| p(s, c));\n+            }\n+\n+            // Call with variable number of arguments\n+            do \"%d %f %c %s\\n\".with_c_str |c| {\n+                do check(\"42 42.500000 a %d %f %c %s\\n\\n\") |s| {\n+                    p(s, c, 42i, 42.5f64, 'a' as c_int, c);\n+                }\n+            }\n+        }\n+\n+        // Pass sprintf directly\n+        call(sprintf);\n+\n+        // Pass sprintf indirectly\n+        call(x);\n+    }\n+\n+}"}]}