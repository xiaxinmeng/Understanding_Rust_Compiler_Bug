{"sha": "c177da6675e5e0c471101cd98d6a7d9040b0150e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzdkYTY2NzVlNWUwYzQ3MTEwMWNkOThkNmE3ZDkwNDBiMDE1MGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:41:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:41:41Z"}, "message": "rollup merge of #22012: pnkfelix/propagate-container-across-object-cast\n\nGiven `<expr> as Box<Trait>`, infer that `Box<_>` is expected type for `<expr>`.\n\nThis is useful for addressing fallout from newly proposed box protocol; see #22006 for examples of such fallout, much of which will be unnecessary with this fix.", "tree": {"sha": "0a6e7d14cd3848dbafd96df33418b19a920b7fb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6e7d14cd3848dbafd96df33418b19a920b7fb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c177da6675e5e0c471101cd98d6a7d9040b0150e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c177da6675e5e0c471101cd98d6a7d9040b0150e", "html_url": "https://github.com/rust-lang/rust/commit/c177da6675e5e0c471101cd98d6a7d9040b0150e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c177da6675e5e0c471101cd98d6a7d9040b0150e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fcc330ea3a5cbe9b861edf05b74d332b53a64b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fcc330ea3a5cbe9b861edf05b74d332b53a64b0", "html_url": "https://github.com/rust-lang/rust/commit/7fcc330ea3a5cbe9b861edf05b74d332b53a64b0"}, {"sha": "a1b3189f4864f1ada755e9ebc2e0ce1ac5bf2e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b3189f4864f1ada755e9ebc2e0ce1ac5bf2e06", "html_url": "https://github.com/rust-lang/rust/commit/a1b3189f4864f1ada755e9ebc2e0ce1ac5bf2e06"}], "stats": {"total": 168, "additions": 106, "deletions": 62}, "files": [{"sha": "00f6c6109faeff664728612ccd04a309d3de1fd6", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 47, "deletions": 62, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c177da6675e5e0c471101cd98d6a7d9040b0150e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c177da6675e5e0c471101cd98d6a7d9040b0150e/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=c177da6675e5e0c471101cd98d6a7d9040b0150e", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n+use check::demand;\n use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{self, Ty, AsPredicate};\n-use middle::infer;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::nodemap::FnvHashSet;\n@@ -24,71 +24,63 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    source_expr: &ast::Expr,\n                                    target_object_ty: Ty<'tcx>)\n {\n+    let tcx = fcx.tcx();\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n-           cast_expr.repr(fcx.tcx()),\n-           target_object_ty.repr(fcx.tcx()));\n+           cast_expr.repr(tcx),\n+           target_object_ty.repr(tcx));\n \n     // Look up vtables for the type we're casting to,\n     // passing in the source and target type.  The source\n     // must be a pointer type suitable to the object sigil,\n     // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-    let source_ty = fcx.expr_ty(source_expr);\n-    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n-    debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n-    match (&source_ty.sty, &target_object_ty.sty) {\n-        (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n-            let object_trait = object_trait(&object_trait_ty);\n-\n-            // Ensure that if ~T is cast to ~Trait, then T : Trait\n-            push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n-            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-        }\n-\n-        (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n-                                                mutbl: referent_mutbl }),\n-         &ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n-                                              mutbl: target_mutbl })) =>\n-        {\n-            let object_trait = object_trait(&object_trait_ty);\n-            if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n-                                        \"types differ in mutability\");\n-            } else {\n-                // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n-                push_cast_obligation(fcx, cast_expr,\n-                                     object_trait,\n-                                     referent_ty);\n-\n-                // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n-                infer::mk_subr(fcx.infcx(),\n-                               infer::RelateObjectBound(source_expr.span),\n-                               *target_region,\n-                               *referent_region);\n-\n-                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n-            }\n-        }\n \n-        (_, &ty::ty_uniq(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n-                \"can only cast a boxed pointer \\\n-                         to a boxed object, not a {}\",\n-                      ty::ty_sort_string(fcx.tcx(), source_ty));\n+    // First, construct a fresh type that we can feed into `<expr>`\n+    // within `<expr> as <type>` to inform type inference (e.g. to\n+    // tell it that we are expecting a `Box<_>` or an `&_`).\n+    let fresh_ty = fcx.infcx().next_ty_var();\n+    let (object_trait_ty, source_expected_ty) = match target_object_ty.sty {\n+        ty::ty_uniq(object_trait_ty) => {\n+            (object_trait_ty, ty::mk_uniq(fcx.tcx(), fresh_ty))\n         }\n-\n-        (_, &ty::ty_rptr(..)) => {\n-            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n-                \"can only cast a &-pointer \\\n-                         to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty));\n+        ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n+                                            mutbl: target_mutbl }) => {\n+            (object_trait_ty,\n+             ty::mk_rptr(fcx.tcx(),\n+                         target_region, ty::mt { ty: fresh_ty,\n+                                                 mutbl: target_mutbl }))\n         }\n-\n         _ => {\n-            fcx.tcx().sess.span_bug(\n-                source_expr.span,\n-                \"expected object type\");\n+            fcx.tcx().sess.span_bug(source_expr.span, \"expected object type\");\n         }\n-    }\n+    };\n+\n+    let source_ty = fcx.expr_ty(source_expr);\n+    debug!(\"check_object_cast pre unify source_ty={}\", source_ty.repr(tcx));\n+\n+    // This ensures that the source_ty <: source_expected_ty, which\n+    // will ensure e.g. that &'a T <: &'b T when doing `&'a T as &'b Trait`\n+    //\n+    // FIXME (pnkfelix): do we need to use suptype_with_fn in order to\n+    // override the error message emitted when the types do not work\n+    // out in the manner desired?\n+    demand::suptype(fcx, source_expr.span, source_expected_ty, source_ty);\n+\n+    debug!(\"check_object_cast postunify source_ty={}\", source_ty.repr(tcx));\n+    let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n+    debug!(\"check_object_cast resolveto source_ty={}\", source_ty.repr(tcx));\n+\n+    let object_trait = object_trait(&object_trait_ty);\n+\n+    let referent_ty = match source_ty.sty {\n+        ty::ty_uniq(ty) => ty,\n+        ty::ty_rptr(_, ty::mt { ty, mutbl: _ }) => ty,\n+        _ => fcx.tcx().sess.span_bug(source_expr.span,\n+                                     \"expected appropriate reference type\"),\n+    };\n+\n+    // Ensure that if Ptr<T> is cast to Ptr<Trait>, then T : Trait.\n+    push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+    check_object_safety(tcx, object_trait, source_expr.span);\n \n     fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n         match t.sty {\n@@ -97,13 +89,6 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn mutability_allowed(a_mutbl: ast::Mutability,\n-                          b_mutbl: ast::Mutability)\n-                          -> bool {\n-        a_mutbl == b_mutbl ||\n-            (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n-    }\n-\n     fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       cast_expr: &ast::Expr,\n                                       object_trait: &ty::TyTrait<'tcx>,"}, {"sha": "979e76b1ff994a4dd4d62a2cc8f4040e5afb3ee0", "filename": "src/test/run-pass/infer-container-across-object-cast.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c177da6675e5e0c471101cd98d6a7d9040b0150e/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c177da6675e5e0c471101cd98d6a7d9040b0150e/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs?ref=c177da6675e5e0c471101cd98d6a7d9040b0150e", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Given `<expr> as Box<Trait>`, we should be able to infer that a\n+// `Box<_>` is the expected type.\n+\n+trait Foo { fn foo(&self) -> u32; }\n+impl Foo for u32 { fn foo(&self) -> u32 { *self } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl Foo for  () { fn foo(&self) -> u32 { -176 } }\n+\n+trait Boxed { fn make() -> Self; }\n+impl Boxed for Box<u32> { fn make() -> Self { Box::new(7) } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl Boxed for () { fn make() -> Self { () } }\n+\n+fn boxed_foo() {\n+    let b7 = Boxed::make() as Box<Foo>;\n+    assert_eq!(b7.foo(), 7);\n+}\n+\n+trait Refed<'a,T> { fn make(&'a T) -> Self; }\n+impl<'a> Refed<'a, u32> for &'a u32 { fn make(x: &'a u32) -> Self { x } }\n+\n+// (another impl to ensure trait-matching cannot just choose from a singleton set)\n+impl<'a,'b> Refed<'a, ()> for &'b () { fn make(_: &'a ()) -> Self { static U: () = (); &U } }\n+\n+fn refed_foo() {\n+    let a = 8;\n+    let b7 = Refed::make(&a) as &Foo;\n+    assert_eq!(b7.foo(), 8);\n+}\n+\n+fn check_subtyping_works() {\n+    fn inner<'short, 'long:'short>(_s: &'short u32,\n+                                   l: &'long u32) -> &'short (Foo+'short) {\n+        Refed::make(l) as &Foo\n+    }\n+\n+    let a = 9;\n+    let b = 10;\n+    let r = inner(&b, &a);\n+    assert_eq!(r.foo(), 9);\n+}\n+\n+pub fn main() {\n+    boxed_foo();\n+    refed_foo();\n+    check_subtyping_works();\n+}"}]}