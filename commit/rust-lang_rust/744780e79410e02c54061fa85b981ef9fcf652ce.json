{"sha": "744780e79410e02c54061fa85b981ef9fcf652ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NDc4MGU3OTQxMGUwMmM1NDA2MWZhODViOTgxZWY5ZmNmNjUyY2U=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-25T05:42:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-26T00:31:40Z"}, "message": "more hacks to make test cases pass", "tree": {"sha": "77becce24fa0d65f8df95821191ceb4c9dd8495b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77becce24fa0d65f8df95821191ceb4c9dd8495b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744780e79410e02c54061fa85b981ef9fcf652ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744780e79410e02c54061fa85b981ef9fcf652ce", "html_url": "https://github.com/rust-lang/rust/commit/744780e79410e02c54061fa85b981ef9fcf652ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744780e79410e02c54061fa85b981ef9fcf652ce/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2d80d04232a0ad0f2a1a3311ea4f9b519580837", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d80d04232a0ad0f2a1a3311ea4f9b519580837", "html_url": "https://github.com/rust-lang/rust/commit/e2d80d04232a0ad0f2a1a3311ea4f9b519580837"}], "stats": {"total": 83, "additions": 60, "deletions": 23}, "files": [{"sha": "be18f7affe3bb9565dd40bbdaaf4c483e6a0b82f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/744780e79410e02c54061fa85b981ef9fcf652ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744780e79410e02c54061fa85b981ef9fcf652ce/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=744780e79410e02c54061fa85b981ef9fcf652ce", "patch": "@@ -565,7 +565,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Release a write lock prematurely. If there's just read locks, do nothing.\n+    /// Release a write lock prematurely. If there's a read lock or someone else's lock, fail.\n     pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n@@ -580,18 +580,20 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                         return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n                     }\n                     if !range.contained_in(ptr.offset, len) {\n-                        return Err(EvalError::Unimplemented(format!(\"miri does not support release part of a write-locked region\")));\n+                        return Err(EvalError::Unimplemented(format!(\"miri does not support releasing part of a write-locked region\")));\n                     }\n                     // Release it later.  We cannot do this now.\n                     remove_list.push(*range);\n                 }\n                 ReadLock(_) => {\n+                    // Abort here and bubble the error outwards so that we do not even register a suspension.\n                     return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n                 },\n             }\n         }\n \n         for range in remove_list {\n+            trace!(\"Releasing {:?}\", alloc.locks[&range]);\n             alloc.locks.remove(&range);\n         }\n "}, {"sha": "7696590977d7925cb284c12ed4e2c2250c1f1077", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/744780e79410e02c54061fa85b981ef9fcf652ce/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744780e79410e02c54061fa85b981ef9fcf652ce/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=744780e79410e02c54061fa85b981ef9fcf652ce", "patch": "@@ -9,8 +9,8 @@ use rustc::middle::region::CodeExtent;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, DynamicLifetime};\n-use memory::AccessKind;\n-use value::Value;\n+use memory::{AccessKind, LockInfo};\n+use value::{PrimVal, Value};\n use lvalue::{Lvalue, LvalueExtra};\n \n pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n@@ -36,8 +36,7 @@ impl ValidationMode {\n // Validity checks\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n-        // Determine if this method is whitelisted and hence we do not perform any validation.\n-        // TODO: Do not do this.\n+        // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n         {\n             // The regexp we use for filtering\n             use regex::Regex;\n@@ -46,6 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n std::mem::swap::|\\\n std::mem::uninitialized::|\\\n std::ptr::read::|\\\n+std::panicking::try::do_call::|\\\n <std::vec::Vec<T>><[a-zA-Z0-9_]+>::into_boxed_slice$\\\n )\").unwrap();\n             }\n@@ -64,18 +64,30 @@ std::ptr::read::|\\\n         let mode = match op {\n             ValidationOp::Acquire => ValidationMode::Acquire,\n             ValidationOp::Release => ValidationMode::Release,\n+            ValidationOp::Suspend(_) => ValidationMode::Release,\n+        };\n+        match self.validate(query.clone(), mode) {\n+            Err(EvalError::InvalidMemoryLockRelease { lock: LockInfo::ReadLock(_), .. }) => {\n+                // HACK: When &x is used while x is already borrowed read-only, AddValidation still\n+                // emits suspension.  This code is legit, so just ignore the error *and*\n+                // do NOT register a suspension.\n+                // TODO: Integrate AddValidation better with borrowck so that we can/ not emit\n+                // these wrong validation statements.  This is all pretty fragile right now.\n+                return Ok(());\n+            }\n+            res => res,\n+        }?;\n+        // Now that we are here, we know things went well.  Time to register the suspension.\n+        match op {\n             ValidationOp::Suspend(ce) => {\n-                if operand.mutbl == MutImmutable {\n-                    // Nothing to do when suspending immutable things\n-                    return Ok(());\n+                if query.mutbl == MutMutable {\n+                    let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+                    trace!(\"Suspending {:?} until {:?}\", query, ce);\n+                    self.suspended.entry(lft).or_insert_with(Vec::new).push(query);\n                 }\n-                let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n-                trace!(\"Suspending {:?} until {:?}\", query, ce);\n-                self.suspended.entry(lft).or_insert_with(Vec::new).push(query.clone());\n-                ValidationMode::Release\n             }\n+            _ => {}\n         };\n-        self.validate(query, mode)?;\n         Ok(())\n     }\n \n@@ -85,6 +97,7 @@ std::ptr::read::|\\\n         let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n         if let Some(queries) = self.suspended.remove(&lft) {\n             for query in queries {\n+                trace!(\"Recovering {:?} from suspension\", query);\n                 self.validate(query, ValidationMode::Recover(ce))?;\n             }\n         }\n@@ -111,7 +124,18 @@ std::ptr::read::|\\\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&mut self.memory)?;\n-        self.memory.check_align(ptr, align)?;\n+        match self.memory.check_align(ptr, align) {\n+            // HACK: If, during releasing, we hit memory we cannot use, we just ignore that.\n+            // This can happen because releases are added before drop elaboration.\n+            // TODO: Fix the MIR so that these releases do not happen.\n+            res @ Err(EvalError::DanglingPointerDeref) | res @ Err(EvalError::ReadUndefBytes) => {\n+                if let ValidationMode::Release = mode {\n+                    return Ok(());\n+                }\n+                res\n+            }\n+            res => res,\n+        }?;\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n@@ -136,14 +160,24 @@ std::ptr::read::|\\\n             }\n         }\n \n-        // For now, bail out if we hit a dead local.\n-        // TODO: Reconsider this.  I think MIR should rather be fixed.\n+        // HACK: For now, bail out if we hit a dead local during recovery (can happen because sometimes we have\n+        // StorageDead before EndRegion).\n+        // TODO: We should rather fix the MIR.\n+        // HACK: Releasing on dead/undef local variables is a NOP.  This can happen because of releases being added\n+        // before drop elaboration.\n+        // TODO: Fix the MIR so that these releases do not happen.\n         match query.lval {\n             Lvalue::Local { frame, local } => {\n-                if let Err(EvalError::DeadLocal) = self.stack[frame].get_local(local) {\n-                    return Ok(())\n+                let res = self.stack[frame].get_local(local);\n+                match (res, mode) {\n+                    (Err(EvalError::DeadLocal), ValidationMode::Recover(_)) |\n+                    (Err(EvalError::DeadLocal), ValidationMode::Release) |\n+                    (Ok(Value::ByVal(PrimVal::Undef)), ValidationMode::Release) => {\n+                        return Ok(());\n+                    }\n+                    _ => {},\n                 }\n-            }\n+            },\n             _ => {}\n         }\n \n@@ -229,7 +263,7 @@ std::ptr::read::|\\\n                 if query.re == None {\n                     match *region {\n                         ReScope(ce) => query.re = Some(ce),\n-                        // It is possible for us to encode erased lifetimes here because the lifetimes in\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n                         // this functions' Subst will be erased.\n                         _ => {},\n                     }\n@@ -279,10 +313,10 @@ std::ptr::read::|\\\n                 };\n                 self.read_size_and_align_from_vtable(vtable)?;\n                 // TODO: Check that the vtable contains all the function pointers we expect it to have.\n-                // TODO: Is there anything we can/should validate here?  Trait objects cannot have any operations performed\n+                // Trait objects cannot have any operations performed\n                 // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n                 // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n-                // their return values.  So, it doesn't seem like there's anything to do.\n+                // their return values.  So, it doesn't seem like there's anything else to do.\n                 Ok(())\n             }\n             TyAdt(adt, subst) => {"}, {"sha": "afbd4760a3c9ba67703c00685b360cb630ec30bb", "filename": "tests/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/744780e79410e02c54061fa85b981ef9fcf652ce/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744780e79410e02c54061fa85b981ef9fcf652ce/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=744780e79410e02c54061fa85b981ef9fcf652ce", "patch": "@@ -55,4 +55,5 @@ fn main() {\n     let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n     let z : &BarS<[u32]> = unsafe{&*bar_ref};\n     assert_eq!(&z.0, &[0,1,2]);\n+    // If validation fails here, that's likely because an immutable suspension is recovered mutably.\n }"}]}