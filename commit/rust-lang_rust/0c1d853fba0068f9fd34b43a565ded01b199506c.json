{"sha": "0c1d853fba0068f9fd34b43a565ded01b199506c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMWQ4NTNmYmEwMDY4ZjlmZDM0YjQzYTU2NWRlZDAxYjE5OTUwNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-25T06:51:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-25T06:51:38Z"}, "message": "auto merge of #18966 : huonw/rust/iter2slice, r=aturon\n\nA slice iterator is isomorphic to a slice, just with a slightly\r\ndifferent form: storing start and end pointers rather than start pointer\r\nand length. This patch reflects this by making converting between them\r\nas easy as `iter.as_slice()` (or even `iter[]` if the shorter lifetime\r\nis ok). That is, `slice.iter().as_slice() == slice`.\r\n\r\nr? @aturon", "tree": {"sha": "1e52456012532a6ea65567f521bbc655c27be763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e52456012532a6ea65567f521bbc655c27be763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c1d853fba0068f9fd34b43a565ded01b199506c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c1d853fba0068f9fd34b43a565ded01b199506c", "html_url": "https://github.com/rust-lang/rust/commit/0c1d853fba0068f9fd34b43a565ded01b199506c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c1d853fba0068f9fd34b43a565ded01b199506c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f9741e62d7cfe26ca94a28716a95bc03d74e87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f9741e62d7cfe26ca94a28716a95bc03d74e87a", "html_url": "https://github.com/rust-lang/rust/commit/5f9741e62d7cfe26ca94a28716a95bc03d74e87a"}, {"sha": "b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "html_url": "https://github.com/rust-lang/rust/commit/b86a7808c74fa0da1f1fcb9b7df760314f9e4104"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "6625d19781a23d6605e0966c56f32bacc3b15a2b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0c1d853fba0068f9fd34b43a565ded01b199506c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1d853fba0068f9fd34b43a565ded01b199506c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0c1d853fba0068f9fd34b43a565ded01b199506c", "patch": "@@ -1104,6 +1104,21 @@ macro_rules! iterator {\n     }\n }\n \n+macro_rules! make_slice {\n+    ($t: ty -> $result: ty: $start: expr, $end: expr) => {{\n+        let diff = $end as uint - $start as uint;\n+        let len = if mem::size_of::<T>() == 0 {\n+            diff\n+        } else {\n+            diff / mem::size_of::<$t>()\n+        };\n+        unsafe {\n+            transmute::<_, $result>(RawSlice { data: $start as *const T, len: len })\n+        }\n+    }}\n+}\n+\n+\n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n pub struct Items<'a, T: 'a> {\n@@ -1112,6 +1127,36 @@ pub struct Items<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>\n }\n \n+#[experimental]\n+impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n+    fn as_slice_(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_from_or_fail(from)\n+    }\n+    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_to_or_fail(to)\n+    }\n+    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_or_fail(from, to)\n+    }\n+}\n+\n+impl<'a, T> Items<'a, T> {\n+    /// View the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    #[experimental]\n+    pub fn as_slice(&self) -> &'a [T] {\n+        make_slice!(T -> &'a [T]: self.ptr, self.end)\n+    }\n+}\n+\n iterator!{struct Items -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n@@ -1156,6 +1201,57 @@ pub struct MutItems<'a, T: 'a> {\n     marker2: marker::NoCopy\n }\n \n+#[experimental]\n+impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n+    fn as_slice_<'b>(&'b self) -> &'b [T] {\n+        make_slice!(T -> &'b [T]: self.ptr, self.end)\n+    }\n+    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_from_or_fail(from)\n+    }\n+    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_to_or_fail(to)\n+    }\n+    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_or_fail(from, to)\n+    }\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n+    fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n+        make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n+    }\n+    fn slice_from_or_fail_mut<'b>(&'b mut self, from: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_from_or_fail_mut(from)\n+    }\n+    fn slice_to_or_fail_mut<'b>(&'b mut self, to: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_to_or_fail_mut(to)\n+    }\n+    fn slice_or_fail_mut<'b>(&'b mut self, from: &uint, to: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_or_fail_mut(from, to)\n+    }\n+}\n+\n+impl<'a, T> MutItems<'a, T> {\n+    /// View the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut` references that alias, this is forced\n+    /// to consume the iterator. Consider using the `Slice` and\n+    /// `SliceMut` implementations for obtaining slices with more\n+    /// restricted lifetimes that do not consume the iterator.\n+    #[experimental]\n+    pub fn into_slice(self) -> &'a mut [T] {\n+        make_slice!(T -> &'a mut [T]: self.ptr, self.end)\n+    }\n+}\n+\n iterator!{struct MutItems -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]"}, {"sha": "29253c50ed0650243fb8e7c30249d09fcb7cb7af", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0c1d853fba0068f9fd34b43a565ded01b199506c/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1d853fba0068f9fd34b43a565ded01b199506c/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=0c1d853fba0068f9fd34b43a565ded01b199506c", "patch": "@@ -33,3 +33,52 @@ fn binary_search_not_found() {\n     let b = [1i, 2, 4, 5, 6, 8];\n     assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n }\n+\n+#[test]\n+fn iterator_to_slice() {\n+    macro_rules! test {\n+        ($data: expr) => {{\n+            let data: &mut [_] = &mut $data;\n+            let other_data: &mut [_] = &mut $data;\n+\n+            {\n+                let mut iter = data.iter();\n+                assert_eq!(iter[], other_data[]);\n+\n+                iter.next();\n+                assert_eq!(iter[], other_data[1..]);\n+\n+                iter.next_back();\n+                assert_eq!(iter[], other_data[1..2]);\n+\n+                let s = iter.as_slice();\n+                iter.next();\n+                assert_eq!(s, other_data[1..2]);\n+            }\n+            {\n+                let mut iter = data.iter_mut();\n+                assert_eq!(iter[], other_data[]);\n+                // mutability:\n+                assert!(iter[mut] == other_data);\n+\n+                iter.next();\n+                assert_eq!(iter[], other_data[1..]);\n+                assert!(iter[mut] == other_data[mut 1..]);\n+\n+                iter.next_back();\n+\n+                assert_eq!(iter[], other_data[1..2]);\n+                assert!(iter[mut] == other_data[mut 1..2]);\n+\n+                let s = iter.into_slice();\n+                assert!(s == other_data[mut 1..2]);\n+            }\n+        }}\n+    }\n+\n+    // try types of a variety of sizes\n+    test!([(1u64, 1u64, 1u8), (2, 2, 2), (3, 3, 3)]);\n+    test!([1u64,2,3]);\n+    test!([1u8,2,3]);\n+    test!([(),(),()]);\n+}"}]}