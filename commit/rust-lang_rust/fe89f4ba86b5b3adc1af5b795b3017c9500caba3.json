{"sha": "fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlODlmNGJhODZiNWIzYWRjMWFmNWI3OTViMzAxN2M5NTAwY2FiYTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-08T18:07:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:51Z"}, "message": "get the `DefiningTy` from the `body_owner_kind` not type\n\nThe type isn't a good idea because we want to treat constants\nuniformly, regardless of what type of value they produce.", "tree": {"sha": "bba4b634881214d77304582920feeb8688bd1617", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bba4b634881214d77304582920feeb8688bd1617"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "html_url": "https://github.com/rust-lang/rust/commit/fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e64a756f84041e7c33acb052db9df9c9576e6d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e64a756f84041e7c33acb052db9df9c9576e6d4", "html_url": "https://github.com/rust-lang/rust/commit/0e64a756f84041e7c33acb052db9df9c9576e6d4"}], "stats": {"total": 185, "additions": 112, "deletions": 73}, "files": [{"sha": "e8a23acd798de8b2df23c8a809be17ed69445893", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "patch": "@@ -15,32 +15,40 @@\n //! handle the part about dumping the inference context internal\n //! state.\n \n-use rustc::ty;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::universal_regions::DefiningTy;\n use rustc_errors::DiagnosticBuilder;\n-use super::RegionInferenceContext;\n \n impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// Write out our state into the `.mir` files.\n     pub(crate) fn annotate(&self, err: &mut DiagnosticBuilder<'_>) {\n-        match self.universal_regions.defining_ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+        match self.universal_regions.defining_ty {\n+            DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!(\n                     \"defining type: {:?} with closure substs {:#?}\",\n                     def_id,\n                     &substs.substs[..]\n                 ));\n             }\n-            ty::TyFnDef(def_id, substs) => {\n+            DefiningTy::Generator(def_id, substs, interior) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with closure substs {:#?} and interior {:?}\",\n+                    def_id,\n+                    &substs.substs[..],\n+                    interior\n+                ));\n+            }\n+            DefiningTy::FnDef(def_id, substs) => {\n                 err.note(&format!(\n                     \"defining type: {:?} with substs {:#?}\",\n                     def_id,\n                     &substs[..]\n                 ));\n             }\n-            _ => {\n+            DefiningTy::Const(ty) => {\n                 err.note(&format!(\n                     \"defining type: {:?}\",\n-                    self.universal_regions.defining_ty\n+                    ty\n                 ));\n             }\n         }"}, {"sha": "8f7616430241facd2b67e62d916f5162bd946cf8", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "patch": "@@ -22,7 +22,7 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n-use rustc::hir::HirId;\n+use rustc::hir::{BodyOwnerKind, HirId};\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::infer::region_constraints::GenericKind;\n@@ -67,7 +67,7 @@ pub struct UniversalRegions<'tcx> {\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated.  For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `TyFnDef`.\n-    pub defining_ty: Ty<'tcx>,\n+    pub defining_ty: DefiningTy<'tcx>,\n \n     /// The return type of this function, with all regions replaced by\n     /// their universal `RegionVid` equivalents. This type is **NOT\n@@ -96,6 +96,33 @@ pub struct UniversalRegions<'tcx> {\n     relations: UniversalRegionRelations,\n }\n \n+/// The \"defining type\" for this MIR. The key feature of the \"defining\n+/// type\" is that it contains the information needed to derive all the\n+/// universal regions that are in scope as well as the types of the\n+/// inputs/output from the MIR. In general, early-bound universal\n+/// regions appear free in the defining type and late-bound regions\n+/// appear bound in the signature.\n+#[derive(Copy, Clone, Debug)]\n+pub enum DefiningTy<'tcx> {\n+    /// The MIR is a closure. The signature is found via\n+    /// `ClosureSubsts::closure_sig_ty`.\n+    Closure(DefId, ty::ClosureSubsts<'tcx>),\n+\n+    /// The MIR is a generator. The signature is that generators take\n+    /// no parameters and return the result of\n+    /// `ClosureSubsts::generator_return_ty`.\n+    Generator(DefId, ty::ClosureSubsts<'tcx>, ty::GeneratorInterior<'tcx>),\n+\n+    /// The MIR is a fn item with the given def-id and substs. The signature\n+    /// of the function can be bound then with the `fn_sig` query.\n+    FnDef(DefId, &'tcx Substs<'tcx>),\n+\n+    /// The MIR represents some form of constant. The signature then\n+    /// is that it has no inputs and a single return value, which is\n+    /// the value of the constant.\n+    Const(Ty<'tcx>),\n+}\n+\n #[derive(Debug)]\n struct UniversalRegionIndices<'tcx> {\n     /// For those regions that may appear in the parameter environment\n@@ -488,23 +515,11 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the \"defining type\" of the current MIR:\n-    ///\n-    /// - for functions, this is the `TyFnDef`;\n-    /// - for closures, this is the `TyClosure`;\n-    /// - for generators, this is the `TyGenerator`;\n-    /// - for constants, this is the type of value that gets produced.\n-    ///   - FIXME. Constants are handled somewhat inelegantly; this gets\n-    ///     patched in a later PR that has already landed on nll-master.\n-    ///\n-    /// The key feature of the \"defining type\" is that it contains the\n-    /// information needed to derive all the universal regions that\n-    /// are in scope as well as the types of the inputs/output from\n-    /// the MIR. In general, early-bound universal regions appear free\n-    /// in the defining type and late-bound regions appear bound in\n-    /// the signature.\n-    fn defining_ty(&self) -> ty::Ty<'tcx> {\n+    /// Returns the \"defining type\" of the current MIR;\n+    /// see `DefiningTy` for details.\n+    fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n+\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n \n         let defining_ty = if self.mir_def_id == closure_base_def_id {\n@@ -514,8 +529,25 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             tables.node_id_to_type(self.mir_hir_id)\n         };\n \n-        self.infcx\n-            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n+        let defining_ty = self.infcx\n+            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n+\n+        match tcx.hir.body_owner_kind(self.mir_node_id) {\n+            BodyOwnerKind::Fn => match defining_ty.sty {\n+                ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n+                ty::TyGenerator(def_id, substs, interior) => {\n+                    DefiningTy::Generator(def_id, substs, interior)\n+                }\n+                ty::TyFnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n+                _ => span_bug!(\n+                    tcx.def_span(self.mir_def_id),\n+                    \"expected defining type for `{:?}`: `{:?}`\",\n+                    self.mir_def_id,\n+                    defining_ty\n+                ),\n+            },\n+            BodyOwnerKind::Const | BodyOwnerKind::Static(..) => DefiningTy::Const(defining_ty),\n+        }\n     }\n \n     /// Builds a hashmap that maps from the universal regions that are\n@@ -525,14 +557,14 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     fn compute_indices(\n         &self,\n         fr_static: RegionVid,\n-        defining_ty: Ty<'tcx>,\n+        defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n         let gcx = tcx.global_tcx();\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n         let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n-        let fr_substs = match defining_ty.sty {\n-            ty::TyClosure(_, substs) | ty::TyGenerator(_, substs, ..) => {\n+        let fr_substs = match defining_ty {\n+            DefiningTy::Closure(_, substs) | DefiningTy::Generator(_, substs, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `closure_base_def_id`.\n@@ -544,28 +576,18 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 assert_eq!(substs.substs.regions().count(), identity_substs.regions().count());\n                 substs.substs\n             }\n-            ty::TyFnDef(_, substs) => substs,\n \n-            // FIXME. When we encounter other sorts of constant\n+            DefiningTy::FnDef(_, substs) => substs,\n+\n+            // When we encounter other sorts of constant\n             // expressions, such as the `22` in `[foo; 22]`, we can\n             // get the type `usize` here. For now, just return an\n             // empty vector of substs in this case, since there are no\n             // generics in scope in such expressions right now.\n-            //\n-            // Eventually I imagine we could get a wider range of\n-            // types.  What is the best way to handle this? Should we\n-            // be checking something other than the type of the def-id\n-            // to figure out what to do (e.g. the def-key?).\n-            ty::TyUint(..) => {\n+            DefiningTy::Const(_) => {\n                 assert!(identity_substs.is_empty());\n                 identity_substs\n             }\n-\n-            _ => span_bug!(\n-                tcx.def_span(self.mir_def_id),\n-                \"unknown defining type: {:?}\",\n-                defining_ty\n-            ),\n         };\n \n         let global_mapping = iter::once((gcx.types.re_static, fr_static));\n@@ -581,11 +603,11 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     fn compute_inputs_and_output(\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n-        defining_ty: Ty<'tcx>,\n+        defining_ty: DefiningTy<'tcx>,\n     ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n-        match defining_ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+        match defining_ty {\n+            DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def_id, def_id);\n                 let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n                 let inputs_and_output = closure_sig.inputs_and_output();\n@@ -613,32 +635,24 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 )\n             }\n \n-            ty::TyGenerator(def_id, substs, ..) => {\n+            DefiningTy::Generator(def_id, substs, interior) => {\n                 assert_eq!(self.mir_def_id, def_id);\n                 let output = substs.generator_return_ty(def_id, tcx);\n-                let inputs_and_output = self.infcx.tcx.intern_type_list(&[defining_ty, output]);\n+                let generator_ty = tcx.mk_generator(def_id, substs, interior);\n+                let inputs_and_output = self.infcx.tcx.intern_type_list(&[generator_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }\n \n-            ty::TyFnDef(def_id, _) => {\n+            DefiningTy::FnDef(def_id, _) => {\n                 let sig = tcx.fn_sig(def_id);\n                 let sig = indices.fold_to_region_vids(tcx, &sig);\n                 sig.inputs_and_output()\n             }\n \n-            // FIXME: as above, this happens on things like `[foo;\n-            // 22]`. For now, no inputs, one output, but it seems like\n-            // we need a more general way to handle this category of\n-            // MIR.\n-            ty::TyUint(..) => {\n-                ty::Binder::dummy(tcx.mk_type_list(iter::once(defining_ty)))\n-            }\n-\n-            _ => span_bug!(\n-                tcx.def_span(self.mir_def_id),\n-                \"unexpected defining type: {:?}\",\n-                defining_ty\n-            ),\n+            // This happens on things like `[foo; 22]`. Hence, no\n+            // inputs, one output, but it seems like we need a more\n+            // general way to handle this category of MIR.\n+            DefiningTy::Const(ty) => ty::Binder::dummy(tcx.mk_type_list(iter::once(ty))),\n         }\n     }\n \n@@ -729,11 +743,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.fold_regions(\n-            value,\n-            &mut false,\n-            |_region, _depth| self.next_nll_region_var(origin),\n-        )\n+        self.tcx.fold_regions(value, &mut false, |_region, _depth| {\n+            self.next_nll_region_var(origin)\n+        })\n     }\n \n     fn replace_bound_regions_with_nll_infer_vars<T>(\n@@ -773,10 +785,8 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(\n-            value,\n-            &mut false,\n-            |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))),\n-        )\n+        tcx.fold_regions(value, &mut false, |region, _| {\n+            tcx.mk_region(ty::ReVar(self.to_region_vid(region)))\n+        })\n     }\n }"}, {"sha": "ced06e5ea0504bd3767f5a680daaecd65f9053c2", "filename": "src/test/ui/nll/constant.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe89f4ba86b5b3adc1af5b795b3017c9500caba3/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fconstant.rs?ref=fe89f4ba86b5b3adc1af5b795b3017c9500caba3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that MIR borrowck and NLL analysis can handle constants of\n+// arbitrary types without ICEs.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+const HI: &str = \"hi\";\n+\n+fn main() {\n+    assert_eq!(HI, \"hi\");\n+}"}]}