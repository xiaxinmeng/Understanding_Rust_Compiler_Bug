{"sha": "1751d2496d4241b2a705ed871a8ad3d4402180b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NTFkMjQ5NmQ0MjQxYjJhNzA1ZWQ4NzFhOGFkM2Q0NDAyMTgwYjU=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-27T20:14:15Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-11-27T20:14:15Z"}, "message": "Run rustfmt on clippy_lints", "tree": {"sha": "4f982e68005eae7299621c244198b4dfa09fe77b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f982e68005eae7299621c244198b4dfa09fe77b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1751d2496d4241b2a705ed871a8ad3d4402180b5", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE46kBTF5vnyuSPg0W6OiXpYcOQcIFAlv9pZcACgkQ6OiXpYcO\nQcKtVA//dwEVuE8i8OdaIkUQqYlTnumTYtp7+uyx0DLiTkacptctGs+tjkO/wF0o\nSVTR84ufSfNyZsyr/rmaSuTuDi/sQ13MJXbu/tCSreqiVvRv4fAiOp5v7vRJVyJ6\nGVemF0ZMobfUhjm3rAXMjEMrViShq+itItXf1zNQEBt63QHTntrtO5SFebETLNDa\nAWZk7OMjxMZnKdlyJwDdf1ziIjI479yqrOsq5ywZFsqHRh2fCHjxQCnMED1I3YcX\n4zgFkEf6o9XM46wkw9fUKR+S3G2zVMUBTO5yRylsuu7qmXPTIUIzeFNkMb8o+ahj\nnvWw5vdjeJJv/BItxpgNKa96wRjkPpsSdv/hkL5pMlb3LtdJ9ls5Uq7OXb2hpE/4\nbzvuNImPUacqAnTpjN2gt5uzA3kjv4oE119Tame+l4zWnGaw0/cXqtpP/qOlbM4W\ndWtSqBO6UIaJK8anZ2pV7LmzhmhikZvyKlInpOQgNrkFZn5LYf7IkLmj9JrT4PtQ\nNwrBzKAgYPiu8uiqFdTN4gOjBietiSSx7waJKMi/JJ3XRdJsngMVkrXlkkeFJ12h\nGXQzWzxCIjieShJRQQBP2gCiPg+I966OXFWQzhF9PRyixSB03tD1+rYSgQMuW+pU\n2c9GcI9gfFlsipdr3sxCLjhCpJmW2ze9U+78F0pnuDzpAvM6s+M=\n=ErmO\n-----END PGP SIGNATURE-----", "payload": "tree 4f982e68005eae7299621c244198b4dfa09fe77b\nparent 5c5e8cc942c8ef97d19f820dc8c4fb4a9397774e\nauthor flip1995 <hello@philkrones.com> 1543349655 +0100\ncommitter flip1995 <hello@philkrones.com> 1543349655 +0100\n\nRun rustfmt on clippy_lints\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1751d2496d4241b2a705ed871a8ad3d4402180b5", "html_url": "https://github.com/rust-lang/rust/commit/1751d2496d4241b2a705ed871a8ad3d4402180b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1751d2496d4241b2a705ed871a8ad3d4402180b5/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c5e8cc942c8ef97d19f820dc8c4fb4a9397774e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5e8cc942c8ef97d19f820dc8c4fb4a9397774e", "html_url": "https://github.com/rust-lang/rust/commit/5c5e8cc942c8ef97d19f820dc8c4fb4a9397774e"}], "stats": {"total": 5680, "additions": 2977, "deletions": 2703}, "files": [{"sha": "bf6355c4a419d2c1fff496f930c427e9cd5b2902", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::utils::span_lint;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use std::f64::consts as f64;\n use crate::syntax::ast::{FloatTy, Lit, LitKind};\n use crate::syntax::symbol;\n+use crate::utils::span_lint;\n+use std::f64::consts as f64;\n \n /// **What it does:** Checks for floating point literals that approximate\n /// constants which are defined in"}, {"sha": "2e24eb7122d2a1c6f519dad34e63ec4895ae2b00", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::utils::span_lint;\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::source_map::Span;\n+use crate::utils::span_lint;\n \n /// **What it does:** Checks for plain integer arithmetic.\n ///\n@@ -52,7 +51,8 @@ declare_clippy_lint! {\n #[derive(Copy, Clone, Default)]\n pub struct Arithmetic {\n     expr_span: Option<Span>,\n-    /// This field is used to check whether expressions are constants, such as in enum discriminants and consts\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants\n+    /// and consts\n     const_span: Option<Span>,\n }\n \n@@ -124,8 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n         let body_owner = cx.tcx.hir.body_owner(body.id());\n \n         match cx.tcx.hir.body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Static(_)\n-            | hir::BodyOwnerKind::Const => {\n+            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n                 let body_span = cx.tcx.hir.span(body_owner);\n \n                 if let Some(span) = self.const_span {\n@@ -134,7 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     }\n                 }\n                 self.const_span = Some(body_span);\n-            }\n+            },\n             hir::BodyOwnerKind::Fn => (),\n         }\n     }"}, {"sha": "91562ece5f5976d3f4507820c4ed585a093e0462", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::utils::{get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, SpanlessEq};\n-use crate::utils::{higher, sugg};\n use crate::rustc::hir;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::syntax::ast;\n use crate::rustc_errors::Applicability;\n+use crate::syntax::ast;\n+use crate::utils::{get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, SpanlessEq};\n+use crate::utils::{higher, sugg};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n /// patterns.\n@@ -217,7 +216,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                                && cx.tables.expr_ty(assignee).is_primitive_ty() {\n+                            && cx.tables.expr_ty(assignee).is_primitive_ty()\n+                        {\n                             match op.node {\n                                 hir::BinOpKind::Add\n                                 | hir::BinOpKind::Mul"}, {"sha": "4f9d5f2a76821d368a9035083d9437461951e5e6", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,27 +7,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! checks for attributes\n \n use crate::reexport::*;\n-use crate::utils::{\n-    in_macro, last_line_of_span, match_def_path, opt_def_id, paths, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, without_block_comments,\n-};\n-use if_chain::if_chain;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{\n     CheckLintNameResult, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintArray, LintContext, LintPass,\n };\n use crate::rustc::ty::{self, TyCtxt};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use semver::Version;\n-use crate::syntax::ast::{\n-    AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind,\n-};\n-use crate::syntax::source_map::Span;\n use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use crate::syntax::source_map::Span;\n+use crate::utils::{\n+    in_macro, last_line_of_span, match_def_path, opt_def_id, paths, snippet_opt, span_lint, span_lint_and_sugg,\n+    span_lint_and_then, without_block_comments,\n+};\n+use if_chain::if_chain;\n+use semver::Version;\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -219,8 +216,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             match &*attr.name().as_str() {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                     check_clippy_lint_names(cx, items);\n-                }\n-                _ => {}\n+                },\n+                _ => {},\n             }\n             if items.is_empty() || attr.name() != \"deprecated\" {\n                 return;\n@@ -254,19 +251,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n                                 // and `unused_imports` for `extern crate` items with `macro_use`\n                                 for lint in lint_list {\n                                     match item.node {\n-                                        ItemKind::Use(..) => if is_word(lint, \"unused_imports\")\n-                                                                || is_word(lint, \"deprecated\") {\n-                                                return\n+                                        ItemKind::Use(..) => {\n+                                            if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n+                                                return;\n+                                            }\n                                         },\n                                         ItemKind::ExternCrate(..) => {\n-                                            if is_word(lint, \"unused_imports\")\n-                                                && skip_unused_imports {\n-                                                    return\n+                                            if is_word(lint, \"unused_imports\") && skip_unused_imports {\n+                                                return;\n                                             }\n                                             if is_word(lint, \"unused_extern_crates\") {\n-                                                return\n+                                                return;\n                                             }\n-                                        }\n+                                        },\n                                         _ => {},\n                                     }\n                                 }\n@@ -396,14 +393,16 @@ fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr\n         ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n         ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n-        ExprKind::Call(ref path_expr, _) => if let ExprKind::Path(ref qpath) = path_expr.node {\n-            if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n-                !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+        ExprKind::Call(ref path_expr, _) => {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n+                if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n+                    !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+                } else {\n+                    true\n+                }\n             } else {\n                 true\n             }\n-        } else {\n-            true\n         },\n         _ => true,\n     }\n@@ -435,7 +434,8 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n                         cx,\n                         EMPTY_LINE_AFTER_OUTER_ATTR,\n                         begin_of_attr_to_item,\n-                        \"Found an empty line after an outer attribute. Perhaps you forgot to add a '!' to make it an inner attribute?\"\n+                        \"Found an empty line after an outer attribute. \\\n+                         Perhaps you forgot to add a '!' to make it an inner attribute?\",\n                     );\n                 }\n             }\n@@ -501,9 +501,7 @@ pub struct CfgAttrPass;\n \n impl LintPass for CfgAttrPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(\n-            DEPRECATED_CFG_ATTR,\n-        )\n+        lint_array!(DEPRECATED_CFG_ATTR,)\n     }\n }\n "}, {"sha": "b15ce871c3260e3851900f9e9e73c1e7eee1891c", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 91, "deletions": 84, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::consts::{constant, Constant};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Span;\n-use crate::utils::{span_lint, span_lint_and_then};\n use crate::utils::sugg::Sugg;\n-use crate::consts::{constant, Constant};\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{span_lint, span_lint_and_then};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for incompatible bit masks in comparisons.\n ///\n@@ -173,7 +172,6 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     }\n }\n \n-\n fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n     if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n@@ -185,99 +183,112 @@ fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext<'_, '_>, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n+fn check_bit_mask(\n+    cx: &LateContext<'_, '_>,\n+    bit_op: BinOpKind,\n+    cmp_op: BinOpKind,\n+    mask_value: u128,\n+    cmp_value: u128,\n+    span: Span,\n+) {\n     match cmp_op {\n         BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n-            BinOpKind::BitAnd => if mask_value & cmp_value != cmp_value {\n-                if cmp_value != 0 {\n+            BinOpKind::BitAnd => {\n+                if mask_value & cmp_value != cmp_value {\n+                    if cmp_value != 0 {\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n+                                mask_value, cmp_value\n+                            ),\n+                        );\n+                    }\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n+            },\n+            BinOpKind::BitOr => {\n+                if mask_value | cmp_value != cmp_value {\n                     span_lint(\n                         cx,\n                         BAD_BIT_MASK,\n                         span,\n                         &format!(\n-                            \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                            mask_value,\n-                            cmp_value\n+                            \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n+                            mask_value, cmp_value\n                         ),\n                     );\n                 }\n-            } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n-            },\n-            BinOpKind::BitOr => if mask_value | cmp_value != cmp_value {\n-                span_lint(\n-                    cx,\n-                    BAD_BIT_MASK,\n-                    span,\n-                    &format!(\n-                        \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                        mask_value,\n-                        cmp_value\n-                    ),\n-                );\n             },\n             _ => (),\n         },\n         BinOpKind::Lt | BinOpKind::Ge => match bit_op {\n-            BinOpKind::BitAnd => if mask_value < cmp_value {\n-                span_lint(\n-                    cx,\n-                    BAD_BIT_MASK,\n-                    span,\n-                    &format!(\n-                        \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                        mask_value,\n-                        cmp_value\n-                    ),\n-                );\n-            } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+            BinOpKind::BitAnd => {\n+                if mask_value < cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n             },\n-            BinOpKind::BitOr => if mask_value >= cmp_value {\n-                span_lint(\n-                    cx,\n-                    BAD_BIT_MASK,\n-                    span,\n-                    &format!(\n-                        \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                        mask_value,\n-                        cmp_value\n-                    ),\n-                );\n-            } else {\n-                check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n+            BinOpKind::BitOr => {\n+                if mask_value >= cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else {\n+                    check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n+                }\n             },\n             BinOpKind::BitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         BinOpKind::Le | BinOpKind::Gt => match bit_op {\n-            BinOpKind::BitAnd => if mask_value <= cmp_value {\n-                span_lint(\n-                    cx,\n-                    BAD_BIT_MASK,\n-                    span,\n-                    &format!(\n-                        \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                        mask_value,\n-                        cmp_value\n-                    ),\n-                );\n-            } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+            BinOpKind::BitAnd => {\n+                if mask_value <= cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else if mask_value == 0 {\n+                    span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n+                }\n             },\n-            BinOpKind::BitOr => if mask_value > cmp_value {\n-                span_lint(\n-                    cx,\n-                    BAD_BIT_MASK,\n-                    span,\n-                    &format!(\n-                        \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                        mask_value,\n-                        cmp_value\n-                    ),\n-                );\n-            } else {\n-                check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n+            BinOpKind::BitOr => {\n+                if mask_value > cmp_value {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n+                            mask_value, cmp_value\n+                        ),\n+                    );\n+                } else {\n+                    check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n+                }\n             },\n             BinOpKind::BitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n@@ -294,9 +305,7 @@ fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n             span,\n             &format!(\n                 \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                op,\n-                m,\n-                c\n+                op, m, c\n             ),\n         );\n     }\n@@ -310,9 +319,7 @@ fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n             span,\n             &format!(\n                 \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                op,\n-                m,\n-                c\n+                op, m, c\n             ),\n         );\n     }"}, {"sha": "bf311b3fd5692ec7edee68fb89c7422aa3244f71", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::utils::span_lint;\n \n /// **What it does:** Checks for usage of blacklisted names for variables, such\n@@ -38,9 +37,7 @@ pub struct BlackListedName {\n \n impl BlackListedName {\n     pub fn new(blacklist: Vec<String>) -> Self {\n-        Self {\n-            blacklist,\n-        }\n+        Self { blacklist }\n     }\n }\n "}, {"sha": "5597b856a8c0c808269612aef8049d4c732370bf", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use matches::matches;\n+use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n-use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::utils::*;\n+use matches::matches;\n \n /// **What it does:** Checks for `if` conditions that use blocks to contain an\n /// expression.\n@@ -112,10 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             );\n                         }\n                     } else {\n-                        let span = block\n-                            .expr\n-                            .as_ref()\n-                            .map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if in_macro(span) || differing_macro_contexts(expr.span, span) {\n                             return;\n                         }\n@@ -134,10 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor {\n-                    found_block: None,\n-                    cx,\n-                };\n+                let mut visitor = ExVisitor { found_block: None, cx };\n                 walk_expr(&mut visitor, check);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);"}, {"sha": "9f58cb6582e874caccac4a7c87a58de84f6e44a2", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::intravisit::*;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n-use crate::rustc::hir::intravisit::*;\n-use crate::syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n-use crate::syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n use crate::rustc_data_structures::thin_vec::ThinVec;\n-use crate::utils::{in_macro, paths, match_type, snippet_opt, span_lint_and_then, SpanlessEq, get_trait_def_id, implements_trait};\n use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n+use crate::syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_then, SpanlessEq,\n+};\n \n /// **What it does:** Checks for boolean expressions that can be written more\n /// concisely.\n@@ -57,10 +58,7 @@ declare_clippy_lint! {\n }\n \n // For each pairs, both orders are considered.\n-const METHODS_WITH_NEGATION: [(&str, &str); 2] = [\n-    (\"is_some\", \"is_none\"),\n-    (\"is_err\", \"is_ok\"),\n-];\n+const METHODS_WITH_NEGATION: [(&str, &str); 2] = [(\"is_some\", \"is_none\"), (\"is_err\", \"is_ok\")];\n \n #[derive(Copy, Clone)]\n pub struct NonminimalBool;\n@@ -134,19 +132,16 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n             let negated = match e.node {\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n \n-                    let mk_expr = |op| {\n-                        Expr {\n-                            id: DUMMY_NODE_ID,\n-                            hir_id: DUMMY_HIR_ID,\n-                            span: DUMMY_SP,\n-                            attrs: ThinVec::new(),\n-                            node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n-                        }\n+                    let mk_expr = |op| Expr {\n+                        id: DUMMY_NODE_ID,\n+                        hir_id: DUMMY_HIR_ID,\n+                        span: DUMMY_SP,\n+                        attrs: ThinVec::new(),\n+                        node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n                     };\n                     match binop.node {\n                         BinOpKind::Eq => mk_expr(BinOpKind::Ne),\n@@ -191,7 +186,6 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n         match expr.node {\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-\n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n                 }\n@@ -204,16 +198,19 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                     BinOpKind::Le => Some(\" > \"),\n                     BinOpKind::Ge => Some(\" < \"),\n                     _ => None,\n-                }.and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n+                }\n+                .and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n             ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n-                if !match_type(self.cx, type_of_receiver, &paths::OPTION) &&\n-                    !match_type(self.cx, type_of_receiver, &paths::RESULT) {\n-                        return None;\n+                if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n+                    && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n+                {\n+                    return None;\n                 }\n                 METHODS_WITH_NEGATION\n-                    .iter().cloned()\n+                    .iter()\n+                    .cloned()\n                     .flat_map(|(a, b)| vec![(a, b), (b, a)])\n                     .find(|&(a, _)| a == path.ident.as_str())\n                     .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", self.snip(&args[0])?, neg_method)))\n@@ -452,7 +449,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                     improvements\n                         .into_iter()\n                         .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals).0)\n-                        .collect()\n+                        .collect(),\n                 );\n             }\n         }\n@@ -465,11 +462,15 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n             return;\n         }\n         match e.node {\n-            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => self.bool_expr(e),\n-            ExprKind::Unary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n-                self.bool_expr(e);\n-            } else {\n-                walk_expr(self, e);\n+            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n+                self.bool_expr(e)\n+            },\n+            ExprKind::Unary(UnNot, ref inner) => {\n+                if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+                    self.bool_expr(e);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n             },\n             _ => walk_expr(self, e),\n         }\n@@ -479,9 +480,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     }\n }\n \n-\n fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n-    get_trait_def_id(cx, &paths::ORD)\n-        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }"}, {"sha": "31ec879d18de4019b6e910812429ed77fba3275d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty;\n@@ -118,10 +117,12 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n         ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprKind::Block(ref b, _) => if b.stmts.is_empty() {\n-            b.expr.as_ref().and_then(|p| get_path_name(p))\n-        } else {\n-            None\n+        ExprKind::Block(ref b, _) => {\n+            if b.stmts.is_empty() {\n+                b.expr.as_ref().and_then(|p| get_path_name(p))\n+            } else {\n+                None\n+            }\n         },\n         ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         _ => None,"}, {"sha": "4d15944d31736a8d60732f524db515ae8be5f610", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -56,7 +56,7 @@ fn is_empty_str(value: &Option<String>) -> bool {\n     match value {\n         None => true,\n         Some(value) if value.is_empty() => true,\n-        _ => false\n+        _ => false,\n     }\n }\n "}, {"sha": "80f0267a981a322410c27a3d879e817f73593195", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for if expressions that contain only an if expression.\n //!\n //! For example, the lint would catch:\n@@ -24,12 +23,12 @@\n \n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::syntax::ast;\n+use if_chain::if_chain;\n \n-use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n-use crate::utils::sugg::Sugg;\n use crate::rustc_errors::Applicability;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n \n /// **What it does:** Checks for nested `if` statements which can be collapsed\n /// by `&&`-combining their conditions and for `else { if ... }` expressions\n@@ -100,10 +99,12 @@ impl EarlyLintPass for CollapsibleIf {\n \n fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     match expr.node {\n-        ast::ExprKind::If(ref check, ref then, ref else_) => if let Some(ref else_) = *else_ {\n-            check_collapsible_maybe_if_let(cx, else_);\n-        } else {\n-            check_collapsible_no_if_let(cx, expr, check, then);\n+        ast::ExprKind::If(ref check, ref then, ref else_) => {\n+            if let Some(ref else_) = *else_ {\n+                check_collapsible_maybe_if_let(cx, else_);\n+            } else {\n+                check_collapsible_no_if_let(cx, expr, check, then);\n+            }\n         },\n         ast::ExprKind::IfLet(_, _, _, Some(ref else_)) => {\n             check_collapsible_maybe_if_let(cx, else_);\n@@ -114,8 +115,9 @@ fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n \n fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n     // We trim all opening braces and whitespaces and then check if the next string is a comment.\n-    let trimmed_block_text =\n-        snippet_block(cx, expr.span, \"..\").trim_left_matches(|c: char| c.is_whitespace() || c == '{').to_owned();\n+    let trimmed_block_text = snippet_block(cx, expr.span, \"..\")\n+        .trim_left_matches(|c: char| c.is_whitespace() || c == '{')\n+        .to_owned();\n     trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n }\n "}, {"sha": "ecf3bb1f96e8143065cc8597036145936a992fcc", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::syntax::ast::*;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::utils::{in_macro, snippet, span_lint_and_then};\n use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::*;\n+use crate::utils::{in_macro, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n ///\n@@ -52,16 +51,17 @@ impl StaticConst {\n             TyKind::Array(ref ty, _) => {\n                 self.visit_type(&*ty, cx);\n             },\n-            TyKind::Tup(ref tup) => for tup_ty in tup {\n-                self.visit_type(&*tup_ty, cx);\n+            TyKind::Tup(ref tup) => {\n+                for tup_ty in tup {\n+                    self.visit_type(&*tup_ty, cx);\n+                }\n             },\n             // This is what we are looking for !\n             TyKind::Rptr(ref optional_lifetime, ref borrow_type) => {\n                 // Match the 'static lifetime\n                 if let Some(lifetime) = *optional_lifetime {\n                     match borrow_type.ty.node {\n-                        TyKind::Path(..) | TyKind::Slice(..) | TyKind::Array(..) |\n-                        TyKind::Tup(..) => {\n+                        TyKind::Path(..) | TyKind::Slice(..) | TyKind::Array(..) | TyKind::Tup(..) => {\n                             if lifetime.ident.name == \"'static\" {\n                                 let snip = snippet(cx, borrow_type.ty.span, \"<type>\");\n                                 let sugg = format!(\"&{}\", snip);\n@@ -72,16 +72,16 @@ impl StaticConst {\n                                     \"Constants have by default a `'static` lifetime\",\n                                     |db| {\n                                         db.span_suggestion_with_applicability(\n-                                            ty.span, \n+                                            ty.span,\n                                             \"consider removing `'static`\",\n                                             sugg,\n                                             Applicability::MachineApplicable, //snippet\n                                         );\n                                     },\n                                 );\n                             }\n-                        }\n-                        _ => {}\n+                        },\n+                        _ => {},\n                     }\n                 }\n                 self.visit_type(&*borrow_type.ty, cx);"}, {"sha": "26a92ab8b9f3e54cc2d10c00bb02f916bcd1e61d", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 87, "deletions": 84, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -10,21 +10,21 @@\n \n #![allow(clippy::float_cmp)]\n \n-use crate::rustc::lint::LateContext;\n-use crate::rustc::{span_bug, bug};\n use crate::rustc::hir::def::Def;\n use crate::rustc::hir::*;\n-use crate::rustc::ty::{self, Ty, TyCtxt, Instance};\n+use crate::rustc::lint::LateContext;\n use crate::rustc::ty::subst::{Subst, Substs};\n+use crate::rustc::ty::{self, Instance, Ty, TyCtxt};\n+use crate::rustc::{bug, span_bug};\n+use crate::syntax::ast::{FloatTy, LitKind};\n+use crate::syntax::ptr::P;\n+use crate::utils::{clip, sext, unsext};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::convert::TryInto;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use crate::syntax::ast::{FloatTy, LitKind};\n-use crate::syntax::ptr::P;\n-use crate::utils::{sext, unsext, clip};\n \n /// A `LitKind`-like enum to fold constant `Expr`s into.\n #[derive(Debug, Clone)]\n@@ -71,7 +71,9 @@ impl PartialEq for Constant {\n                 unsafe { mem::transmute::<f64, u64>(f64::from(l)) == mem::transmute::<f64, u64>(f64::from(r)) }\n             },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n-            (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => l == r,\n+            (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n+                l == r\n+            },\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             _ => false, // TODO: Are there inter-type equalities?\n         }\n@@ -117,7 +119,12 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TyKind<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(\n+        tcx: TyCtxt<'_, '_, '_>,\n+        cmp_type: &ty::TyKind<'_>,\n+        left: &Self,\n+        right: &Self,\n+    ) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -158,8 +165,7 @@ pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n         LitKind::ByteStr(ref s) => Constant::Binary(Rc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n-        LitKind::Float(ref is, _) |\n-        LitKind::FloatUnsuffixed(ref is) => match ty.sty {\n+        LitKind::Float(ref is, _) | LitKind::FloatUnsuffixed(ref is) => match ty.sty {\n             ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n             ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n@@ -168,7 +174,11 @@ pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n     }\n }\n \n-pub fn constant<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>, e: &Expr) -> Option<(Constant, bool)> {\n+pub fn constant<'c, 'cc>(\n+    lcx: &LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+    e: &Expr,\n+) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         tcx: lcx.tcx,\n         tables,\n@@ -179,12 +189,19 @@ pub fn constant<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTable\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>, e: &Expr) -> Option<Constant> {\n+pub fn constant_simple<'c, 'cc>(\n+    lcx: &LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+    e: &Expr,\n+) -> Option<Constant> {\n     constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`\n-pub fn constant_context<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>) -> ConstEvalLateContext<'c, 'cc> {\n+pub fn constant_context<'c, 'cc>(\n+    lcx: &LateContext<'c, 'cc>,\n+    tables: &'c ty::TypeckTables<'cc>,\n+) -> ConstEvalLateContext<'c, 'cc> {\n     ConstEvalLateContext {\n         tcx: lcx.tcx,\n         tables,\n@@ -270,9 +287,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// create `Some(Vec![..])` of all constants, unless there is any\n     /// non-constant part\n     fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n-        vec.iter()\n-            .map(|elem| self.expr(elem))\n-            .collect::<Option<_>>()\n+        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n     }\n \n     /// lookup a possibly constant expression from a ExprKind::Path\n@@ -331,63 +346,51 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => {\n-                match self.tables.expr_ty(left).sty {\n-                    ty::Int(ity) => {\n-                        let l = sext(self.tcx, l, ity);\n-                        let r = sext(self.tcx, r, ity);\n-                        let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n-                        match op.node {\n-                            BinOpKind::Add => l.checked_add(r).map(zext),\n-                            BinOpKind::Sub => l.checked_sub(r).map(zext),\n-                            BinOpKind::Mul => l.checked_mul(r).map(zext),\n-                            BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n-                            BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n-                            BinOpKind::Shr => l.checked_shr(\n-                                    r.try_into().expect(\"invalid shift\")\n-                                ).map(zext),\n-                            BinOpKind::Shl => l.checked_shl(\n-                                    r.try_into().expect(\"invalid shift\")\n-                                ).map(zext),\n-                            BinOpKind::BitXor => Some(zext(l ^ r)),\n-                            BinOpKind::BitOr => Some(zext(l | r)),\n-                            BinOpKind::BitAnd => Some(zext(l & r)),\n-                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                            _ => None,\n-                        }\n+            (Constant::Int(l), Some(Constant::Int(r))) => match self.tables.expr_ty(left).sty {\n+                ty::Int(ity) => {\n+                    let l = sext(self.tcx, l, ity);\n+                    let r = sext(self.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n+                    match op.node {\n+                        BinOpKind::Add => l.checked_add(r).map(zext),\n+                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::BitXor => Some(zext(l ^ r)),\n+                        BinOpKind::BitOr => Some(zext(l | r)),\n+                        BinOpKind::BitAnd => Some(zext(l & r)),\n+                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                        _ => None,\n                     }\n-                    ty::Uint(_) => {\n-                        match op.node {\n-                            BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n-                            BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n-                            BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n-                            BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n-                            BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n-                            BinOpKind::Shr => l.checked_shr(\n-                                    r.try_into().expect(\"shift too large\")\n-                                ).map(Constant::Int),\n-                            BinOpKind::Shl => l.checked_shl(\n-                                    r.try_into().expect(\"shift too large\")\n-                                ).map(Constant::Int),\n-                            BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n-                            BinOpKind::BitOr => Some(Constant::Int(l | r)),\n-                            BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n-                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                            _ => None,\n-                        }\n-                    },\n+                },\n+                ty::Uint(_) => match op.node {\n+                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                     _ => None,\n-                }\n+                },\n+                _ => None,\n             },\n             (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n                 BinOpKind::Add => Some(Constant::F32(l + r)),\n@@ -420,7 +423,9 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             (l, r) => match (op.node, l, r) {\n                 (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n                 (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => Some(r),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n+                    Some(r)\n+                },\n                 (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n                 (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n                 (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n@@ -431,36 +436,34 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n }\n \n pub fn miri_to_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, result: &ty::Const<'tcx>) -> Option<Constant> {\n-    use crate::rustc::mir::interpret::{Scalar, ConstValue};\n+    use crate::rustc::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n-        ConstValue::Scalar(Scalar::Bits{ bits: b, ..}) => match result.ty.sty {\n+        ConstValue::Scalar(Scalar::Bits { bits: b, .. }) => match result.ty.sty {\n             ty::Bool => Some(Constant::Bool(b == 1)),\n             ty::Uint(_) | ty::Int(_) => Some(Constant::Int(b)),\n             ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                b.try_into().expect(\"invalid f32 bit representation\")\n+                b.try_into().expect(\"invalid f32 bit representation\"),\n             ))),\n             ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                b.try_into().expect(\"invalid f64 bit representation\")\n+                b.try_into().expect(\"invalid f64 bit representation\"),\n             ))),\n             // FIXME: implement other conversion\n             _ => None,\n         },\n-        ConstValue::ScalarPair(Scalar::Ptr(ptr),\n-                                Scalar::Bits { bits: n, .. }) => match result.ty.sty {\n+        ConstValue::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: n, .. }) => match result.ty.sty {\n             ty::Ref(_, tam, _) => match tam.sty {\n                 ty::Str => {\n-                    let alloc = tcx\n-                        .alloc_map\n-                        .lock()\n-                        .unwrap_memory(ptr.alloc_id);\n+                    let alloc = tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                     let offset = ptr.offset.bytes().try_into().expect(\"too-large pointer offset\");\n                     let n = n as usize;\n-                    String::from_utf8(alloc.bytes[offset..(offset + n)].to_owned()).ok().map(Constant::Str)\n+                    String::from_utf8(alloc.bytes[offset..(offset + n)].to_owned())\n+                        .ok()\n+                        .map(Constant::Str)\n                 },\n                 _ => None,\n             },\n             _ => None,\n-        }\n+        },\n         // FIXME: implement other conversions\n         _ => None,\n     }"}, {"sha": "2f7aac99acdd38b61f638a471d4ef9aa1cefb6ba", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,18 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty::Ty;\n-use crate::rustc::hir::*;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashMap;\n-use std::collections::hash_map::Entry;\n-use std::hash::BuildHasherDefault;\n use crate::syntax::symbol::LocalInternedString;\n-use smallvec::SmallVec;\n-use crate::utils::{SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, in_macro, snippet, span_lint_and_then, span_note_and_lint};\n+use crate::utils::{SpanlessEq, SpanlessHash};\n+use smallvec::SmallVec;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n \n /// **What it does:** Checks for consecutive `if`s with the same condition.\n ///\n@@ -168,7 +167,8 @@ fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+    let eq: &dyn Fn(&&Expr, &&Expr) -> bool =\n+        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n \n     if let Some((i, j)) = search_same(conds, hash, eq) {\n         span_note_and_lint(\n@@ -229,7 +229,10 @@ fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n                             // hiding all the subsequent arms, and rust won't compile\n                             db.span_note(\n                                 i.body.span,\n-                                &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\", lhs),\n+                                &format!(\n+                                    \"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n+                                    lhs\n+                                ),\n                             );\n                         } else {\n                             db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n@@ -276,11 +279,17 @@ fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>)\n \n /// Return the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<LocalInternedString, Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut FxHashMap<LocalInternedString, Ty<'tcx>>) {\n+    fn bindings_impl<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        pat: &Pat,\n+        map: &mut FxHashMap<LocalInternedString, Ty<'tcx>>,\n+    ) {\n         match pat.node {\n             PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, ref pats, _) => for pat in pats {\n-                bindings_impl(cx, pat, map);\n+            PatKind::TupleStruct(_, ref pats, _) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n             },\n             PatKind::Binding(_, _, ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.as_str()) {\n@@ -290,11 +299,15 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<LocalI\n                     bindings_impl(cx, as_pat, map);\n                 }\n             },\n-            PatKind::Struct(_, ref fields, _) => for pat in fields {\n-                bindings_impl(cx, &pat.node.pat, map);\n+            PatKind::Struct(_, ref fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.node.pat, map);\n+                }\n             },\n-            PatKind::Tuple(ref fields, _) => for pat in fields {\n-                bindings_impl(cx, pat, map);\n+            PatKind::Tuple(ref fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n             },\n             PatKind::Slice(ref lhs, ref mid, ref rhs) => {\n                 for pat in lhs {\n@@ -316,7 +329,6 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<LocalI\n     result\n }\n \n-\n fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n where\n     Eq: Fn(&T, &T) -> bool,\n@@ -345,10 +357,8 @@ where\n         };\n     }\n \n-    let mut map: FxHashMap<_, Vec<&_>> = FxHashMap::with_capacity_and_hasher(\n-        exprs.len(),\n-        BuildHasherDefault::default()\n-    );\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n \n     for expr in exprs {\n         match map.entry(hash(expr)) {"}, {"sha": "af6142c8a049accf61a5623305208626fe1b8d11", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::utils::{is_copy, match_path, paths, span_note_and_lint};\n use crate::rustc::hir::{Item, ItemKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::utils::{is_copy, match_path, paths, span_note_and_lint};\n \n /// **What it does:** Checks for types that implement `Copy` as well as\n /// `Iterator`."}, {"sha": "132440885f728fb0af41ec8a11ea25ec47eb2cbe", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! calculate cyclomatic complexity and warn about overly complex functions\n \n use crate::rustc::cfg::CFG;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty;\n-use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::{Attribute, NodeId};\n use crate::syntax::source_map::Span;\n \n@@ -138,12 +137,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     }\n \n     fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit\n-            .push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n     fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit\n-            .pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n }\n \n@@ -197,7 +194,16 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n \n #[cfg(feature = \"debugging\")]\n #[allow(clippy::too_many_arguments)]\n-fn report_cc_bug(_: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n+fn report_cc_bug(\n+    _: &LateContext<'_, '_>,\n+    cc: u64,\n+    narms: u64,\n+    div: u64,\n+    shorts: u64,\n+    returns: u64,\n+    span: Span,\n+    _: NodeId,\n+) {\n     span_bug!(\n         span,\n         \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n@@ -211,7 +217,16 @@ fn report_cc_bug(_: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts:\n }\n #[cfg(not(feature = \"debugging\"))]\n #[allow(clippy::too_many_arguments)]\n-fn report_cc_bug(cx: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n+fn report_cc_bug(\n+    cx: &LateContext<'_, '_>,\n+    cc: u64,\n+    narms: u64,\n+    div: u64,\n+    shorts: u64,\n+    returns: u64,\n+    span: Span,\n+    id: NodeId,\n+) {\n     if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,\n@@ -220,11 +235,7 @@ fn report_cc_bug(cx: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts\n                  (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n                  cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n                  Please file a bug report.\",\n-                cc,\n-                narms,\n-                div,\n-                shorts,\n-                returns\n+                cc, narms, div, shorts, returns\n             ),\n         );\n     }"}, {"sha": "bc5643a0bed00ead15034a214096dcb53b478173", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty::TyKind;\n@@ -17,7 +16,6 @@ use if_chain::if_chain;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n \n-\n /// **What it does:** Checks for literal calls to `Default::default()`.\n ///\n /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n@@ -51,44 +49,44 @@ impl LintPass for DefaultTraitAccess {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprKind::Call(ref path, ..) = expr.node;\n-            if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n-            if let ExprKind::Path(ref qpath) = path.node;\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n-            if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n-            then {\n-                match qpath {\n-                    QPath::Resolved(..) => {\n-                        if_chain! {\n-                            // Detect and ignore <Foo as Default>::default() because these calls do\n-                            // explicitly name the type.\n-                            if let ExprKind::Call(ref method, ref _args) = expr.node;\n-                            if let ExprKind::Path(ref p) = method.node;\n-                            if let QPath::Resolved(Some(_ty), _path) = p;\n-                            then {\n-                                return;\n-                            }\n-                        }\n+           if let ExprKind::Call(ref path, ..) = expr.node;\n+           if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n+           if let ExprKind::Path(ref qpath) = path.node;\n+           if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+           if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+           then {\n+               match qpath {\n+                   QPath::Resolved(..) => {\n+                       if_chain! {\n+                           // Detect and ignore <Foo as Default>::default() because these calls do\n+                           // explicitly name the type.\n+                           if let ExprKind::Call(ref method, ref _args) = expr.node;\n+                           if let ExprKind::Path(ref p) = method.node;\n+                           if let QPath::Resolved(Some(_ty), _path) = p;\n+                           then {\n+                               return;\n+                           }\n+                       }\n \n-                        // TODO: Work out a way to put \"whatever the imported way of referencing\n-                        // this type in this file\" rather than a fully-qualified type.\n-                        let expr_ty = cx.tables.expr_ty(expr);\n-                        if let TyKind::Adt(..) = expr_ty.sty {\n-                            let replacement = format!(\"{}::default()\", expr_ty);\n-                            span_lint_and_sugg(\n-                                cx,\n-                                DEFAULT_TRAIT_ACCESS,\n-                                expr.span,\n-                                &format!(\"Calling {} is more clear than this expression\", replacement),\n-                                \"try\",\n-                                replacement,\n-                                Applicability::Unspecified, // First resolve the TODO above\n-                            );\n-                         }\n-                    },\n-                    QPath::TypeRelative(..) => {},\n-                }\n-            }\n-         }\n+                       // TODO: Work out a way to put \"whatever the imported way of referencing\n+                       // this type in this file\" rather than a fully-qualified type.\n+                       let expr_ty = cx.tables.expr_ty(expr);\n+                       if let TyKind::Adt(..) = expr_ty.sty {\n+                           let replacement = format!(\"{}::default()\", expr_ty);\n+                           span_lint_and_sugg(\n+                               cx,\n+                               DEFAULT_TRAIT_ACCESS,\n+                               expr.span,\n+                               &format!(\"Calling {} is more clear than this expression\", replacement),\n+                               \"try\",\n+                               replacement,\n+                               Applicability::Unspecified, // First resolve the TODO above\n+                           );\n+                        }\n+                   },\n+                   QPath::TypeRelative(..) => {},\n+               }\n+           }\n+        }\n     }\n }"}, {"sha": "96621d366faba932f25fa9ec109082e8bc1fe3ae", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty::{self, Ty};\n-use crate::rustc::hir::*;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n use crate::utils::{is_automatically_derived, is_copy, match_path, span_lint_and_then};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly or vice versa.\n@@ -154,18 +153,20 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n             ty::Adt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            ty::Adt(def, substs) => for variant in &def.variants {\n-                for field in &variant.fields {\n-                    if let ty::FnDef(..) = field.ty(cx.tcx, substs).sty {\n-                        return;\n-                    }\n-                }\n-                for subst in substs {\n-                    if let ty::subst::UnpackedKind::Type(subst) = subst.unpack() {\n-                        if let ty::Param(_) = subst.sty {\n+            ty::Adt(def, substs) => {\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).sty {\n                             return;\n                         }\n                     }\n+                    for subst in substs {\n+                        if let ty::subst::UnpackedKind::Type(subst) = subst.unpack() {\n+                            if let ty::Param(_) = subst.sty {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n             },\n             _ => (),"}, {"sha": "a3278159ef575b0b2776056abcc5c9b184a690e9", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use itertools::Itertools;\n-use pulldown_cmark;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast;\n use crate::syntax::source_map::{BytePos, Span};\n use crate::syntax_pos::Pos;\n use crate::utils::span_lint;\n+use itertools::Itertools;\n+use pulldown_cmark;\n use url::Url;\n \n /// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n@@ -49,9 +48,7 @@ pub struct Doc {\n \n impl Doc {\n     pub fn new(valid_idents: Vec<String>) -> Self {\n-        Self {\n-            valid_idents,\n-        }\n+        Self { valid_idents }\n     }\n }\n \n@@ -107,9 +104,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n             doc.push('\\n');\n             return (\n                 doc.to_owned(),\n-                vec![\n-                    (doc.len(), span.with_lo(span.lo() + BytePos(prefix.len() as u32))),\n-                ],\n+                vec![(doc.len(), span.with_lo(span.lo() + BytePos(prefix.len() as u32)))],\n             );\n         }\n     }\n@@ -275,13 +270,10 @@ fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n             return false;\n         }\n \n-        let s = if s.ends_with('s') {\n-            &s[..s.len() - 1]\n-        } else {\n-            s\n-        };\n+        let s = if s.ends_with('s') { &s[..s.len() - 1] } else { s };\n \n-        s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1\n+        s.chars().all(char::is_alphanumeric)\n+            && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1\n             && s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n     }\n "}, {"sha": "25ce883cac8d032181c2acdfce7b958d5f400db5", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Lint on unnecessary double comparisons. Some examples:\n \n use crate::rustc::hir::*;\n@@ -51,18 +50,11 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> Pass {\n     #[allow(clippy::similar_names)]\n-    fn check_binop(\n-        &self,\n-        cx: &LateContext<'a, 'tcx>,\n-        op: BinOpKind,\n-        lhs: &'tcx Expr,\n-        rhs: &'tcx Expr,\n-        span: Span,\n-    ) {\n+    fn check_binop(&self, cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n-            }\n+            },\n             _ => return,\n         };\n         let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n@@ -84,13 +76,21 @@ impl<'a, 'tcx> Pass {\n                     sugg,\n                     applicability,\n                 );\n-            }}\n+            }};\n         }\n         match (op, lkind, rkind) {\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => lint_double_comparison!(<=),\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => lint_double_comparison!(>=),\n-            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => lint_double_comparison!(!=),\n-            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => lint_double_comparison!(==),\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n+                lint_double_comparison!(<=)\n+            },\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n+                lint_double_comparison!(>=)\n+            },\n+            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n+                lint_double_comparison!(!=)\n+            },\n+            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n+                lint_double_comparison!(==)\n+            },\n             _ => (),\n         };\n     }"}, {"sha": "d3979e660cc3abc0ef1b027c20569c3851bd5ce7", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::syntax::ast::*;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::syntax::ast::*;\n use crate::utils::{in_macro, span_lint};\n \n-\n /// **What it does:** Checks for unnecessary double parentheses.\n ///\n /// **Why is this bad?** This makes code harder to read and might indicate a\n@@ -51,20 +49,39 @@ impl EarlyLintPass for DoubleParens {\n         match expr.node {\n             ExprKind::Paren(ref in_paren) => match in_paren.node {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {\n-                    span_lint(cx, DOUBLE_PARENS, expr.span, \"Consider removing unnecessary double parentheses\");\n+                    span_lint(\n+                        cx,\n+                        DOUBLE_PARENS,\n+                        expr.span,\n+                        \"Consider removing unnecessary double parentheses\",\n+                    );\n                 },\n                 _ => {},\n             },\n-            ExprKind::Call(_, ref params) => if params.len() == 1 {\n-                let param = &params[0];\n-                if let ExprKind::Paren(_) = param.node {\n-                    span_lint(cx, DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n+            ExprKind::Call(_, ref params) => {\n+                if params.len() == 1 {\n+                    let param = &params[0];\n+                    if let ExprKind::Paren(_) = param.node {\n+                        span_lint(\n+                            cx,\n+                            DOUBLE_PARENS,\n+                            param.span,\n+                            \"Consider removing unnecessary double parentheses\",\n+                        );\n+                    }\n                 }\n             },\n-            ExprKind::MethodCall(_, ref params) => if params.len() == 2 {\n-                let param = &params[1];\n-                if let ExprKind::Paren(_) = param.node {\n-                    span_lint(cx, DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n+            ExprKind::MethodCall(_, ref params) => {\n+                if params.len() == 2 {\n+                    let param = &params[1];\n+                    if let ExprKind::Paren(_) = param.node {\n+                        span_lint(\n+                            cx,\n+                            DOUBLE_PARENS,\n+                            param.span,\n+                            \"Consider removing unnecessary double parentheses\",\n+                        );\n+                    }\n                 }\n             },\n             _ => {},"}, {"sha": "a9741c7a2ddc60abeefd74518cd5a6874171c849", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n-use crate::rustc::hir::*;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::utils::{is_copy, match_def_path, opt_def_id, paths, span_note_and_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n /// instead of an owned value.\n@@ -70,9 +69,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let x:i32 = 42;   // i32 implements Copy\n+/// let x: i32 = 42; // i32 implements Copy\n /// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n-/// // original unaffected\n+///                   // original unaffected\n /// ```\n declare_clippy_lint! {\n     pub DROP_COPY,\n@@ -97,9 +96,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let x:i32 = 42;     // i32 implements Copy\n+/// let x: i32 = 42; // i32 implements Copy\n /// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n-/// // original unaffected\n+///                     // original unaffected\n /// ```\n declare_clippy_lint! {\n     pub FORGET_COPY,"}, {"sha": "295f7532e90ffb34e2b853fd395594216f355559", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -68,7 +67,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n                     expr.span,\n                     &format!(\"Calling `{}()` is more concise than this calculation\", suggested_fn),\n                     \"try\",\n-                    format!(\"{}.{}()\", snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability), suggested_fn),\n+                    format!(\n+                        \"{}.{}()\",\n+                        snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n+                        suggested_fn\n+                    ),\n                     applicability,\n                 );\n             }"}, {"sha": "e977019fa4ebb0dac195505efa1903078b43f859", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on if expressions with an else if, but without a final else branch\n \n-use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n "}, {"sha": "b9b6b17a2dd20e80af3531cbc5c49d44321aa992", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint when there is an enum with no variants\n \n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::utils::span_lint_and_then;\n \n /// **What it does:** Checks for `enum`s with no variants.\n@@ -47,11 +46,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def()\n-                .expect(\"already checked whether this is an enum\");\n+            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants.is_empty() {\n                 span_lint_and_then(cx, EMPTY_ENUM, item.span, \"enum with no variants\", |db| {\n-                    db.span_help(item.span, \"consider using the uninhabited type `!` or a wrapper around it\");\n+                    db.span_help(\n+                        item.span,\n+                        \"consider using the uninhabited type `!` or a wrapper around it\",\n+                    );\n                 });\n             }\n         }"}, {"sha": "fad62c6825e191150283a0f6355d94a1c7b28211", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n-use crate::rustc_errors::Applicability;\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n /// or `BTreeMap`.\n@@ -26,12 +25,16 @@ use crate::rustc_errors::Applicability;\n /// **Known problems:** Some false negatives, eg.:\n /// ```rust\n /// let k = &key;\n-/// if !m.contains_key(k) { m.insert(k.clone(), v); }\n+/// if !m.contains_key(k) {\n+///     m.insert(k.clone(), v);\n+/// }\n /// ```\n ///\n /// **Example:**\n /// ```rust\n-/// if !m.contains_key(&k) { m.insert(k, v) }\n+/// if !m.contains_key(&k) {\n+///     m.insert(k, v)\n+/// }\n /// ```\n /// can be rewritten as:\n /// ```rust\n@@ -60,11 +63,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n-                        else_block.is_none() && if let ExprKind::Block(ref then_block, _) = then_block.node {\n-                            (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                        } else {\n-                            true\n-                        }\n+                        else_block.is_none()\n+                            && if let ExprKind::Block(ref then_block, _) = then_block.node {\n+                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n+                            } else {\n+                                true\n+                            }\n                     };\n \n                     let mut visitor = InsertVisitor {"}, {"sha": "cf921b6b94c2bdd6ee0e4d35326a7dda1e4f432a", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,20 +7,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on C-like enums that are `repr(isize/usize)` and have values that\n //! don't fit into an `i32`\n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::consts::{miri_to_const, Constant};\n use crate::rustc::hir::*;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::mir::interpret::GlobalId;\n use crate::rustc::ty;\n use crate::rustc::ty::subst::Substs;\n+use crate::rustc::ty::util::IntTypeExt;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::{IntTy, UintTy};\n use crate::utils::span_lint;\n-use crate::consts::{Constant, miri_to_const};\n-use crate::rustc::ty::util::IntTypeExt;\n-use crate::rustc::mir::interpret::GlobalId;\n \n /// **What it does:** Checks for C-like enumerations that are\n /// `repr(isize/usize)` and have values that don't fit into an `i32`.\n@@ -35,7 +34,7 @@ use crate::rustc::mir::interpret::GlobalId;\n /// #[repr(usize)]\n /// enum NonPortable {\n ///     X = 0x1_0000_0000,\n-///     Y = 0\n+///     Y = 0,\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -68,7 +67,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                     let instance = ty::Instance::new(def_id, substs);\n                     let c_id = GlobalId {\n                         instance,\n-                        promoted: None\n+                        promoted: None,\n                     };\n                     let constant = cx.tcx.const_eval(param_env.and(c_id)).ok();\n                     if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n@@ -84,7 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                                 if val <= i128::from(i32::max_value()) && val >= i128::from(i32::min_value()) {\n                                     continue;\n                                 }\n-                            }\n+                            },\n                             ty::Uint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n                             _ => continue,\n                         }"}, {"sha": "164b0d8dbade56061c60e941e1df770661e337fa", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on `use`ing all variants of an enum\n \n-use crate::rustc::hir::*;\n use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::NodeId;\n@@ -60,12 +59,7 @@ impl EnumGlobUse {\n         }\n         if let ItemKind::Use(ref path, UseKind::Glob) = item.node {\n             if let Def::Enum(_) = path.def {\n-                span_lint(\n-                    cx,\n-                    ENUM_GLOB_USE,\n-                    item.span,\n-                    \"don't use glob imports for enum variants\",\n-                );\n+                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }\n         }\n     }"}, {"sha": "ae87c4273e920cd3ff29b71bf3ef3005a692b4e9", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n-use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, Lint};\n+use crate::rustc::lint::{EarlyContext, EarlyLintPass, Lint, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n use crate::syntax::source_map::Span;\n use crate::syntax::symbol::LocalInternedString;\n-use crate::utils::{span_help_and_lint, span_lint};\n use crate::utils::{camel_case, in_macro};\n+use crate::utils::{span_help_and_lint, span_lint};\n \n /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n /// by the same characters.\n@@ -139,10 +138,7 @@ fn var2str(var: &Variant) -> LocalInternedString {\n fn partial_match(pre: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next_back(); // make sure the name is never fully matched\n-    pre.chars()\n-        .zip(name_iter)\n-        .take_while(|&(l, r)| l == r)\n-        .count()\n+    pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n }\n \n /// Returns the number of chars that match from the end\n@@ -171,9 +167,7 @@ fn check_variant(\n     for var in &def.variants {\n         let name = var2str(var);\n         if partial_match(item_name, &name) == item_name_chars\n-            && name.chars()\n-                .nth(item_name_chars)\n-                .map_or(false, |c| !c.is_lowercase())\n+            && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n         {\n             span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n         }\n@@ -277,19 +271,26 @@ impl EarlyLintPass for EnumVariantNames {\n                         let rmatching = partial_rmatch(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();\n \n-                        let is_word_beginning = |c: char| {\n-                            c == '_' || c.is_uppercase() || c.is_numeric()\n-                        };\n+                        let is_word_beginning = |c: char| c == '_' || c.is_uppercase() || c.is_numeric();\n \n                         if matching == nchars {\n                             match item_camel.chars().nth(nchars) {\n-                                Some(c) if is_word_beginning(c) =>\n-                                    span_lint(cx, STUTTER, item.span, \"item name starts with its containing module's name\"),\n-                                _ => ()\n+                                Some(c) if is_word_beginning(c) => span_lint(\n+                                    cx,\n+                                    STUTTER,\n+                                    item.span,\n+                                    \"item name starts with its containing module's name\",\n+                                ),\n+                                _ => (),\n                             }\n                         }\n                         if rmatching == nchars {\n-                            span_lint(cx, STUTTER, item.span, \"item name ends with its containing module's name\");\n+                            span_lint(\n+                                cx,\n+                                STUTTER,\n+                                item.span,\n+                                \"item name ends with its containing module's name\",\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "83644786e5150857b53a683165da6ca4ce8a9e12", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::utils::{in_macro, implements_trait, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq};\n use crate::rustc_errors::Applicability;\n+use crate::utils::{\n+    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+};\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n@@ -92,7 +93,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n                 BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n                 BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n-                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => (cx.tcx.lang_items().ord_trait(), true),\n+                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n+                    (cx.tcx.lang_items().ord_trait(), true)\n+                },\n             };\n             if let Some(trait_id) = trait_id {\n                 #[allow(clippy::match_same_arms)]\n@@ -122,7 +125,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                     );\n                                 },\n                             )\n-                        } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()]) {\n+                        } else if lcpy\n+                            && !rcpy\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                        {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion_with_applicability(\n@@ -132,7 +138,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                     Applicability::MachineApplicable, // snippet\n                                 );\n                             })\n-                        } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()]) {\n+                        } else if !lcpy\n+                            && rcpy\n+                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                        {\n                             span_lint_and_then(\n                                 cx,\n                                 OP_REF,\n@@ -154,7 +163,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprKind::AddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n-                        if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()]) {\n+                        if (requires_ref || lcpy)\n+                            && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()])\n+                        {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion_with_applicability(\n@@ -170,7 +181,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (_, &ExprKind::AddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n-                        if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()]) {\n+                        if (requires_ref || rcpy)\n+                            && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()])\n+                        {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion_with_applicability(\n@@ -189,10 +202,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     }\n }\n \n-\n fn is_valid_operator(op: BinOp) -> bool {\n     match op.node {\n-        BinOpKind::Sub | BinOpKind::Div | BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Gt | BinOpKind::Ge | BinOpKind::Ne | BinOpKind::And | BinOpKind::Or | BinOpKind::BitXor | BinOpKind::BitAnd | BinOpKind::BitOr => true,\n+        BinOpKind::Sub\n+        | BinOpKind::Div\n+        | BinOpKind::Eq\n+        | BinOpKind::Lt\n+        | BinOpKind::Le\n+        | BinOpKind::Gt\n+        | BinOpKind::Ge\n+        | BinOpKind::Ne\n+        | BinOpKind::And\n+        | BinOpKind::Or\n+        | BinOpKind::BitXor\n+        | BinOpKind::BitAnd\n+        | BinOpKind::BitOr => true,\n         _ => false,\n     }\n }"}, {"sha": "e2725cf59b08926a12de417a8ac417522de61d09", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::consts::{constant_simple, Constant};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -25,7 +24,9 @@ use crate::utils::{in_macro, span_lint};\n ///\n /// **Example:**\n /// ```rust\n-/// 0 / x; 0 * x; x & 0\n+/// 0 / x;\n+/// 0 * x;\n+/// x & 0\n /// ```\n declare_clippy_lint! {\n     pub ERASING_OP,"}, {"sha": "99c145b2677b1831e8a74951717b326e6ad210d2", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit as visit;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::middle::expr_use_visitor::*;\n use crate::rustc::middle::mem_categorization::{cmt_, Categorization};\n-use crate::rustc::ty::{self, Ty};\n use crate::rustc::ty::layout::LayoutOf;\n+use crate::rustc::ty::{self, Ty};\n use crate::rustc::util::nodemap::NodeSet;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::NodeId;\n use crate::syntax::source_map::Span;\n use crate::utils::span_lint;\n@@ -65,7 +64,6 @@ impl LintPass for Pass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n@@ -157,7 +155,15 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, loan_cause: LoanCause) {\n+    fn borrow(\n+        &mut self,\n+        _: NodeId,\n+        _: Span,\n+        cmt: &cmt_<'tcx>,\n+        _: ty::Region<'_>,\n+        _: ty::BorrowKind,\n+        loan_cause: LoanCause,\n+    ) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n                 // x.foo()"}, {"sha": "1e7fee9757f4fc4b2ec0a6ea0f2df0bd9a02af6d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty;\n-use crate::rustc::hir::*;\n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n+use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n \n pub struct EtaPass;\n \n-\n /// **What it does:** Checks for closures which just call another function where\n /// the function can be called directly. `unsafe` functions or calls where types\n /// get adjusted are ignored.\n@@ -52,8 +50,10 @@ impl LintPass for EtaPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => for arg in args {\n-                check_closure(cx, arg)\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n+                for arg in args {\n+                    check_closure(cx, arg)\n+                }\n             },\n             _ => (),\n         }"}, {"sha": "269a6bb6c8a1688583c051bf0805fcb1d28620eb", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n-use crate::rustc::ty;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::ty;\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::syntax::ast;\n use crate::utils::{get_parent_expr, span_lint, span_note_and_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for a read and a write to the same variable where\n /// whether the read occurs before or after the write depends on the evaluation\n@@ -30,7 +29,10 @@ use crate::utils::{get_parent_expr, span_lint, span_note_and_lint};\n /// **Example:**\n /// ```rust\n /// let mut x = 0;\n-/// let a = {x = 1; 1} + x;\n+/// let a = {\n+///     x = 1;\n+///     1\n+/// } + x;\n /// // Unclear whether a is 1 or 2.\n /// ```\n declare_clippy_lint! {\n@@ -74,17 +76,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => if let ExprKind::Path(ref qpath) = lhs.node {\n-                if let QPath::Resolved(_, ref path) = *qpath {\n-                    if path.segments.len() == 1 {\n-                        if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n-                            let mut visitor = ReadVisitor {\n-                                cx,\n-                                var,\n-                                write_expr: expr,\n-                                last_expr: expr,\n-                            };\n-                            check_for_unsequenced_reads(&mut visitor);\n+            ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => {\n+                if let ExprKind::Path(ref qpath) = lhs.node {\n+                    if let QPath::Resolved(_, ref path) = *qpath {\n+                        if path.segments.len() == 1 {\n+                            if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n+                                let mut visitor = ReadVisitor {\n+                                    cx,\n+                                    var,\n+                                    write_expr: expr,\n+                                    last_expr: expr,\n+                                };\n+                                check_for_unsequenced_reads(&mut visitor);\n+                            }\n                         }\n                     }\n                 }\n@@ -95,12 +99,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n             StmtKind::Expr(ref e, _) | StmtKind::Semi(ref e, _) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n-            StmtKind::Decl(ref d, _) => if let DeclKind::Local(ref local) = d.node {\n-                if let Local {\n-                    init: Some(ref e), ..\n-                } = **local\n-                {\n-                    DivergenceVisitor { cx }.visit_expr(e);\n+            StmtKind::Decl(ref d, _) => {\n+                if let DeclKind::Local(ref local) = d.node {\n+                    if let Local { init: Some(ref e), .. } = **local {\n+                        DivergenceVisitor { cx }.visit_expr(e);\n+                    }\n                 }\n             },\n         }\n@@ -179,12 +182,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n /// This means reads for which there is a common ancestor between the read and\n /// the write such that\n ///\n-/// * evaluating the ancestor necessarily evaluates both the read and the write\n-///   (for example, `&x` and `|| x = 1` don't necessarily evaluate `x`), and\n+/// * evaluating the ancestor necessarily evaluates both the read and the write (for example, `&x`\n+///   and `|| x = 1` don't necessarily evaluate `x`), and\n ///\n-/// * which one is evaluated first depends on the order of sub-expression\n-///   evaluation. Blocks, `if`s, loops, `match`es, and the short-circuiting\n-///   logical operators are considered to have a defined evaluation order.\n+/// * which one is evaluated first depends on the order of sub-expression evaluation. Blocks, `if`s,\n+///   loops, `match`es, and the short-circuiting logical operators are considered to have a defined\n+///   evaluation order.\n ///\n /// When such a read is found, the lint is triggered.\n fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n@@ -232,14 +235,14 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     }\n \n     match expr.node {\n-        ExprKind::Array(_) |\n-        ExprKind::Tup(_) |\n-        ExprKind::MethodCall(..) |\n-        ExprKind::Call(_, _) |\n-        ExprKind::Assign(_, _) |\n-        ExprKind::Index(_, _) |\n-        ExprKind::Repeat(_, _) |\n-        ExprKind::Struct(_, _, _) => {\n+        ExprKind::Array(_)\n+        | ExprKind::Tup(_)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Call(_, _)\n+        | ExprKind::Assign(_, _)\n+        | ExprKind::Index(_, _)\n+        | ExprKind::Repeat(_, _)\n+        | ExprKind::Struct(_, _, _) => {\n             walk_expr(vis, expr);\n         },\n         ExprKind::Binary(op, _, _) | ExprKind::AssignOp(op, _, _) => {\n@@ -253,13 +256,12 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n         ExprKind::Closure(_, _, _, _, _) => {\n             // Either\n             //\n-            // * `var` is defined in the closure body, in which case we've\n-            //   reached the top of the enclosing function and can stop, or\n+            // * `var` is defined in the closure body, in which case we've reached the top of the enclosing\n+            //   function and can stop, or\n             //\n-            // * `var` is captured by the closure, in which case, because\n-            //   evaluating a closure does not evaluate its body, we don't\n-            //   necessarily have a write, so we need to stop to avoid\n-            //   generating false positives.\n+            // * `var` is captured by the closure, in which case, because evaluating a closure does not evaluate\n+            //   its body, we don't necessarily have a write, so we need to stop to avoid generating false\n+            //   positives.\n             //\n             // This is also the only place we need to stop early (grrr).\n             return StopEarly::Stop;"}, {"sha": "cd0d5941cbe3e5367ded73be58b4cccc2920ad0c", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty::TyKind;\n@@ -32,12 +31,12 @@ use std::fmt;\n ///\n /// ```rust\n /// // Bad\n-///    let v: f32 = 0.123_456_789_9;\n-///    println!(\"{}\", v); //  0.123_456_789\n+/// let v: f32 = 0.123_456_789_9;\n+/// println!(\"{}\", v); //  0.123_456_789\n ///\n /// // Good\n-///    let v: f64 = 0.123_456_789_9;\n-///    println!(\"{}\", v); //  0.123_456_789_9\n+/// let v: f64 = 0.123_456_789_9;\n+/// println!(\"{}\", v); //  0.123_456_789_9\n /// ```\n declare_clippy_lint! {\n     pub EXCESSIVE_PRECISION,\n@@ -82,7 +81,7 @@ impl ExcessivePrecision {\n         let max = max_digits(fty);\n         let sym_str = sym.as_str();\n         if dot_zero_exclusion(&sym_str) {\n-            return None\n+            return None;\n         }\n         // Try to bail out if the float is for sure fine.\n         // If its within the 2 decimal digits of being out of precision we\n@@ -116,9 +115,7 @@ impl ExcessivePrecision {\n /// Ex 1_000_000_000.\n fn dot_zero_exclusion(s: &str) -> bool {\n     if let Some(after_dec) = s.split('.').nth(1) {\n-        let mut decpart = after_dec\n-            .chars()\n-            .take_while(|c| *c != 'e' || *c != 'E');\n+        let mut decpart = after_dec.chars().take_while(|c| *c != 'e' || *c != 'E');\n \n         match decpart.next() {\n             Some('0') => decpart.count() == 0,\n@@ -169,7 +166,9 @@ impl FloatFormat {\n             .unwrap_or(FloatFormat::Normal)\n     }\n     fn format<T>(&self, f: T) -> String\n-    where T: fmt::UpperExp + fmt::LowerExp + fmt::Display {\n+    where\n+        T: fmt::UpperExp + fmt::LowerExp + fmt::Display,\n+    {\n         match self {\n             FloatFormat::LowerExp => format!(\"{:e}\", f),\n             FloatFormat::UpperExp => format!(\"{:E}\", f),"}, {"sha": "c1f007fea0b6686f991141a0b14afb5142acb6a3", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint};\n use crate::utils::opt_def_id;\n+use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n /// replaced with `(e)print!()` / `(e)println!()`\n@@ -28,10 +27,10 @@ use crate::utils::opt_def_id;\n /// writeln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n /// ```\n declare_clippy_lint! {\n-    pub EXPLICIT_WRITE,\n-    complexity,\n-    \"using the `write!()` family of functions instead of the `print!()` family \\\n-     of functions, when using the latter would work\"\n+pub EXPLICIT_WRITE,\n+complexity,\n+\"using the `write!()` family of functions instead of the `print!()` family \\\n+ of functions, when using the latter would work\"\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "ec47c78e4951ea0d750284671b3d564be6b2c0da", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::hir;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax_pos::Span;\n-use crate::utils::{match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty, is_expn_of, opt_def_id};\n use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n+use crate::utils::{is_expn_of, match_def_path, method_chain_args, opt_def_id, span_lint_and_then, walk_ptrs_ty};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n ///\n@@ -62,8 +61,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n }\n \n fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_items: &hir::HirVec<hir::ImplItemRef>) {\n-    use crate::rustc::hir::*;\n     use crate::rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+    use crate::rustc::hir::*;\n \n     struct FindPanicUnwrap<'a, 'tcx: 'a> {\n         tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "ac80580b14820c9dc1d0b51b9aa2deeb557c5d8e", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n use crate::utils::paths;\n-use crate::utils::{in_macro, is_expn_of, last_path_segment, match_def_path, match_type, opt_def_id, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty};\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{\n+    in_macro, is_expn_of, last_path_segment, match_def_path, match_type, opt_def_id, resolve_node, snippet,\n+    span_lint_and_then, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -92,17 +94,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprKind::Match(ref matchee, _, _) => if let ExprKind::Tup(ref tup) = matchee.node {\n-                    if tup.is_empty() {\n-                        let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n-                        span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n-                            db.span_suggestion_with_applicability(\n-                                span,\n-                                \"consider using .to_string()\",\n-                                sugg,\n-                                Applicability::MachineApplicable, // snippet\n-                            );\n-                        });\n+                ExprKind::Match(ref matchee, _, _) => {\n+                    if let ExprKind::Tup(ref tup) = matchee.node {\n+                        if tup.is_empty() {\n+                            let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n+                            span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n+                                db.span_suggestion_with_applicability(\n+                                    span,\n+                                    \"consider using .to_string()\",\n+                                    sugg,\n+                                    Applicability::MachineApplicable, // snippet\n+                                );\n+                            });\n+                        }\n                     }\n                 },\n                 _ => (),"}, {"sha": "48ee383482c854f6f2f35be3a245b6f90f82f41e", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast;\n-use crate::utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use crate::syntax::ptr::P;\n+use crate::utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n \n /// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n /// operators.\n@@ -78,7 +77,6 @@ declare_clippy_lint! {\n     \"possible missing comma in array\"\n }\n \n-\n #[derive(Copy, Clone)]\n pub struct Formatting;\n \n@@ -96,8 +94,8 @@ impl EarlyLintPass for Formatting {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         for w in block.stmts.windows(2) {\n             match (&w[0].node, &w[1].node) {\n-                (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n-                (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Semi(ref second)) => {\n+                (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second))\n+                | (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Semi(ref second)) => {\n                     check_consecutive_ifs(cx, first, second);\n                 },\n                 _ => (),\n@@ -153,9 +151,7 @@ fn check_else_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n             // the snippet should look like \" else \\n    \" with maybe comments anywhere\n             // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n             if let Some(else_snippet) = snippet_opt(cx, else_span) {\n-                let else_pos = else_snippet\n-                    .find(\"else\")\n-                    .expect(\"there must be a `else` here\");\n+                let else_pos = else_snippet.find(\"else\").expect(\"there must be a `else` here\");\n \n                 if else_snippet[else_pos..].contains('\\n') {\n                     span_note_and_lint(\n@@ -175,9 +171,7 @@ fn check_else_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n \n fn has_unary_equivalent(bin_op: ast::BinOpKind) -> bool {\n     // &, *, -\n-    bin_op == ast::BinOpKind::And\n-    || bin_op == ast::BinOpKind::Mul\n-    || bin_op == ast::BinOpKind::Sub\n+    bin_op == ast::BinOpKind::And || bin_op == ast::BinOpKind::Mul || bin_op == ast::BinOpKind::Sub\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n@@ -208,7 +202,9 @@ fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Expr) {\n-    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some()\n+    if !differing_macro_contexts(first.span, second.span)\n+        && !in_macro(first.span)\n+        && unsugar_if(first).is_some()\n         && unsugar_if(second).is_some()\n     {\n         // where the else would be"}, {"sha": "5700076192295fca9bc15175e6265f3a0ab2cea6", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,19 +7,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use matches::matches;\n-use crate::rustc::hir::intravisit;\n use crate::rustc::hir;\n+use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::intravisit;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty;\n-use crate::rustc::hir::def::Def;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashSet;\n-use crate::syntax::ast;\n use crate::rustc_target::spec::abi::Abi;\n+use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n use crate::utils::{iter_input_pats, span_lint, type_is_unsafe_function};\n+use matches::matches;\n \n /// **What it does:** Checks for functions with too many parameters.\n ///\n@@ -31,8 +30,9 @@ use crate::utils::{iter_input_pats, span_lint, type_is_unsafe_function};\n ///\n /// **Example:**\n /// ```rust\n-/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b:\n-/// f32) { .. }\n+/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub TOO_MANY_ARGUMENTS,\n@@ -58,7 +58,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// pub fn foo(x: *const u8) { println!(\"{}\", unsafe { *x }); }\n+/// pub fn foo(x: *const u8) {\n+///     println!(\"{}\", unsafe { *x });\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub NOT_UNSAFE_PTR_ARG_DEREF,\n@@ -73,9 +75,7 @@ pub struct Functions {\n \n impl Functions {\n     pub fn new(threshold: u64) -> Self {\n-        Self {\n-            threshold,\n-        }\n+        Self { threshold }\n     }\n }\n \n@@ -111,8 +111,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         if !is_impl {\n             // don't lint extern functions decls, it's not their fault either\n             match kind {\n-                hir::intravisit::FnKind::Method(_, &hir::MethodSig { header: hir::FnHeader { abi: Abi::Rust, .. }, .. }, _, _) |\n-                hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => self.check_arg_number(cx, decl, span),\n+                hir::intravisit::FnKind::Method(\n+                    _,\n+                    &hir::MethodSig {\n+                        header: hir::FnHeader { abi: Abi::Rust, .. },\n+                        ..\n+                    },\n+                    _,\n+                    _,\n+                )\n+                | hir::intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _, _) => {\n+                    self.check_arg_number(cx, decl, span)\n+                },\n                 _ => {},\n             }\n         }"}, {"sha": "cea759712b84192f56aeb825e454156d931d1a82", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::NodeId;\n-use crate::utils::{in_macro, match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then};\n+use crate::utils::{\n+    in_macro, match_def_path, match_trait_method, same_tys, snippet, snippet_with_macro_callsite, span_lint_and_then,\n+};\n use crate::utils::{opt_def_id, paths, resolve_node};\n-use crate::rustc_errors::Applicability;\n \n /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n ///\n@@ -101,22 +102,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                 }\n             },\n \n-            ExprKind::Call(ref path, ref args) => if let ExprKind::Path(ref qpath) = path.node {\n-                if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n-                    if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n-                        let a = cx.tables.expr_ty(e);\n-                        let b = cx.tables.expr_ty(&args[0]);\n-                        if same_tys(cx, a, b) {\n-                            let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n-                            let sugg_msg = format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n-                            span_lint_and_then(cx, IDENTITY_CONVERSION, e.span, \"identical conversion\", |db| {\n-                                db.span_suggestion_with_applicability(\n-                                    e.span,\n-                                    &sugg_msg,\n-                                    sugg,\n-                                    Applicability::MachineApplicable, // snippet\n-                                );\n-                            });\n+            ExprKind::Call(ref path, ref args) => {\n+                if let ExprKind::Path(ref qpath) = path.node {\n+                    if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n+                        if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n+                            let a = cx.tables.expr_ty(e);\n+                            let b = cx.tables.expr_ty(&args[0]);\n+                            if same_tys(cx, a, b) {\n+                                let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();\n+                                let sugg_msg =\n+                                    format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n+                                span_lint_and_then(cx, IDENTITY_CONVERSION, e.span, \"identical conversion\", |db| {\n+                                    db.span_suggestion_with_applicability(\n+                                        e.span,\n+                                        &sugg_msg,\n+                                        sugg,\n+                                        Applicability::MachineApplicable, // snippet\n+                                    );\n+                                });\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "aab3c8c83364ee78a05a7719dff1dc3a1eb43aa1", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::consts::{constant_simple, Constant};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::ty;\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::source_map::Span;\n-use crate::utils::{in_macro, snippet, span_lint, unsext, clip};\n-use crate::rustc::ty;\n+use crate::utils::{clip, in_macro, snippet, span_lint, unsext};\n \n /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n ///"}, {"sha": "8a82b8d6c49a77ca976cb16a15b4b65dd8701d2a", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on if branches that could be swapped so no `!` operation is necessary\n //! on the condition\n \n-use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n "}, {"sha": "758b135247108d4ae188101f5d1880d52d1b2902", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,18 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on indexing and slicing operations\n \n use crate::consts::{constant, Constant};\n-use crate::utils;\n-use crate::utils::higher;\n-use crate::utils::higher::Range;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::RangeLimits;\n+use crate::utils;\n+use crate::utils::higher;\n+use crate::utils::higher::Range;\n \n /// **What it does:** Checks for out of bounds array indexing with a constant\n /// index.\n@@ -29,7 +28,7 @@ use crate::syntax::ast::RangeLimits;\n ///\n /// **Example:**\n /// ```rust\n-/// let x = [1,2,3,4];\n+/// let x = [1, 2, 3, 4];\n ///\n /// // Bad\n /// x[9];\n@@ -108,7 +107,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n         if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n-\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.sty {\n                     let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n@@ -153,13 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n                     (None, None) => return, // [..] is ok.\n                 };\n \n-                utils::span_help_and_lint(\n-                    cx,\n-                    INDEXING_SLICING,\n-                    expr.span,\n-                    \"slicing may panic.\",\n-                    help_msg,\n-                );\n+                utils::span_help_and_lint(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", help_msg);\n             } else {\n                 // Catchall non-range index, i.e. [n] or [n << m]\n                 if let ty::Array(..) = ty.sty {\n@@ -189,23 +181,21 @@ fn to_const_range<'a, 'tcx>(\n     range: Range<'_>,\n     array_size: u128,\n ) -> (Option<u128>, Option<u128>) {\n-    let s = range\n-        .start\n-        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => Some(x),\n         Some(_) => None,\n         None => Some(0),\n     };\n \n-    let e = range\n-        .end\n-        .map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n+    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let end = match e {\n-        Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n-            Some(x + 1)\n-        } else {\n-            Some(x)\n+        Some(Some(Constant::Int(x))) => {\n+            if range.limits == RangeLimits::Closed {\n+                Some(x + 1)\n+            } else {\n+                Some(x)\n+            }\n         },\n         Some(_) => None,\n         None => Some(array_size),"}, {"sha": "ddf3e8f8aaaacd99ddbbcb71cb5e8803eb0f81d0", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use super::utils::{get_arg_name, match_var, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};"}, {"sha": "3ac68096aaa2e1887a661a0c8bbc689a5cccbab9", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -160,7 +159,8 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n                         First => is_infinite(cx, &args[0]),\n                         Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n                         All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n-                    }).and(cap);\n+                    })\n+                    .and(cap);\n                 }\n             }\n             if method.ident.name == \"flat_map\" && args.len() == 2 {\n@@ -173,14 +173,14 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n         },\n         ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n-        ExprKind::Call(ref path, _) => if let ExprKind::Path(ref qpath) = path.node {\n-            match_qpath(qpath, &paths::REPEAT).into()\n-        } else {\n-            Finite\n+        ExprKind::Call(ref path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.node {\n+                match_qpath(qpath, &paths::REPEAT).into()\n+            } else {\n+                Finite\n+            }\n         },\n-        ExprKind::Struct(..) => higher::range(cx, expr)\n-            .map_or(false, |r| r.end.is_none())\n-            .into(),\n+        ExprKind::Struct(..) => higher::range(cx, expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }\n@@ -235,10 +235,10 @@ fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n                 }\n             }\n         },\n-        ExprKind::Binary(op, ref l, ref r) => if op.node.is_comparison() {\n-            return is_infinite(cx, l)\n-                .and(is_infinite(cx, r))\n-                .and(MaybeInfinite);\n+        ExprKind::Binary(op, ref l, ref r) => {\n+            if op.node.is_comparison() {\n+                return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite);\n+            }\n         }, // TODO: ExprKind::Loop + Match\n         _ => (),\n     }"}, {"sha": "256f080fdb9fd079999690dd0ffaa49ac4480267", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on inherent implementations\n \n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashMap;\n-use std::default::Default;\n use crate::syntax_pos::Span;\n use crate::utils::span_lint_and_then;\n+use std::default::Default;\n \n /// **What it does:** Checks for multiple inherent implementations of a struct\n ///\n@@ -56,7 +55,9 @@ pub struct Pass {\n \n impl Default for Pass {\n     fn default() -> Self {\n-        Self { impls: FxHashMap::default() }\n+        Self {\n+            impls: FxHashMap::default(),\n+        }\n     }\n }\n \n@@ -88,11 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let mut impl_spans = impls\n                     .iter()\n                     .filter_map(|impl_def| self.impls.get(impl_def))\n-                    .filter_map(|(span, generics)| if generics.params.len() == 0 {\n-                        Some(span)\n-                    } else {\n-                        None\n-                    });\n+                    .filter_map(|(span, generics)| if generics.params.len() == 0 { Some(span) } else { None });\n                 if let Some(initial_span) = impl_spans.nth(0) {\n                     impl_spans.for_each(|additional_span| {\n                         span_lint_and_then(\n@@ -101,10 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             *additional_span,\n                             \"Multiple implementations of this structure\",\n                             |db| {\n-                                db.span_note(\n-                                    *initial_span,\n-                                    \"First implementation here\",\n-                                );\n+                                db.span_note(*initial_span, \"First implementation here\");\n                             },\n                         )\n                     })"}, {"sha": "4b651dd0e1e2cda3d7524ee4dc4539675d26846c", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! checks for `#[inline]` on trait methods without bodies\n \n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Attribute, Name};\n use crate::utils::span_lint_and_then;\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::rustc_errors::Applicability;\n \n /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n ///"}, {"sha": "08c8012c9317bb83f154764dcd6eefbf09a8cb12", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint on blocks unnecessarily using >= with a + 1 or - 1\n \n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n@@ -162,14 +161,20 @@ impl IntPlusOne {\n     }\n \n     fn emit_warning(&self, cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n-        span_lint_and_then(cx, INT_PLUS_ONE, block.span, \"Unnecessary `>= y + 1` or `x - 1 >=`\", |db| {\n-            db.span_suggestion_with_applicability(\n-                block.span,\n-                \"change `>= y + 1` to `> y` as shown\",\n-                recommendation,\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        });\n+        span_lint_and_then(\n+            cx,\n+            INT_PLUS_ONE,\n+            block.span,\n+            \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n+            |db| {\n+                db.span_suggestion_with_applicability(\n+                    block.span,\n+                    \"change `>= y + 1` to `> y` as shown\",\n+                    recommendation,\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n     }\n }\n "}, {"sha": "5eba76bb45fe2eb98eefa522dc4367cc0c3ac8f2", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n-use crate::rustc::hir::*;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::utils::{match_def_path, opt_def_id, paths, span_help_and_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n ///"}, {"sha": "ce44b7ac97cdde2ce261ce33cc30cc4e85b94935", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint when items are used after statements\n \n-use matches::matches;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n use crate::utils::{in_macro, span_lint};\n+use matches::matches;\n \n /// **What it does:** Checks for items declared after some statement in a block.\n ///\n@@ -59,7 +58,8 @@ impl EarlyLintPass for ItemsAfterStatements {\n         }\n \n         // skip initial items\n-        let stmts = item.stmts\n+        let stmts = item\n+            .stmts\n             .iter()\n             .map(|stmt| &stmt.node)\n             .skip_while(|s| matches!(**s, StmtKind::Item(..)));"}, {"sha": "6f9ae1a93677833ce5dc361cead417bd357427a3", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! lint when there is a large size difference between variants on an enum\n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir::*;\n-use crate::utils::{snippet_opt, span_lint_and_then};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::ty::layout::LayoutOf;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n+use crate::utils::{snippet_opt, span_lint_and_then};\n \n /// **What it does:** Checks for large size differences between variants on\n /// `enum`s.\n@@ -29,8 +28,8 @@ use crate::rustc_errors::Applicability;\n /// **Example:**\n /// ```rust\n /// enum Test {\n-///    A(i32),\n-///    B([i32; 8000]),\n+///     A(i32),\n+///     B([i32; 8000]),\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -63,8 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def()\n-                .expect(\"already checked whether this is an enum\");\n+            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n \n             let mut smallest_variant: Option<(_, _)> = None;\n             let mut largest_variant: Option<(_, _)> = None;"}, {"sha": "0dc217475800dd34d5d20ec10d5251d21bfa3b15", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::def_id::DefId;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -32,19 +31,27 @@ use crate::utils::{get_item_name, in_macro, snippet_with_applicability, span_lin\n ///\n /// **Example:**\n /// ```rust\n-/// if x.len() == 0 { .. }\n-/// if y.len() != 0 { .. }\n+/// if x.len() == 0 {\n+///     ..\n+/// }\n+/// if y.len() != 0 {\n+///     ..\n+/// }\n /// ```\n /// instead use\n /// ```rust\n-/// if x.len().is_empty() { .. }\n-/// if !y.len().is_empty() { .. }\n+/// if x.len().is_empty() {\n+///     ..\n+/// }\n+/// if !y.len().is_empty() {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n-    pub LEN_ZERO,\n-    style,\n-    \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n-     could be used instead\"\n+pub LEN_ZERO,\n+style,\n+\"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n+ could be used instead\"\n }\n \n /// **What it does:** Checks for items that implement `.len()` but not\n@@ -61,7 +68,9 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// impl X {\n-///     pub fn len(&self) -> usize { .. }\n+///     pub fn len(&self) -> usize {\n+///         ..\n+///     }\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -125,14 +134,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n-        item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self && {\n-                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+        item.ident.name == name\n+            && if let AssociatedItemKind::Method { has_self } = item.kind {\n+                has_self && {\n+                    let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                }\n+            } else {\n+                false\n             }\n-        } else {\n-            false\n-        }\n     }\n \n     // fill the set with current and super traits\n@@ -153,7 +163,9 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n             .iter()\n             .flat_map(|&i| cx.tcx.associated_items(i))\n             .any(|i| {\n-                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.ident.name == \"is_empty\"\n+                i.kind == ty::AssociatedKind::Method\n+                    && i.method_has_self_argument\n+                    && i.ident.name == \"is_empty\"\n                     && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n@@ -173,14 +185,15 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n \n fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: &str) -> bool {\n-        item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self && {\n-                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+        item.ident.name == name\n+            && if let AssociatedItemKind::Method { has_self } = item.kind {\n+                has_self && {\n+                    let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                }\n+            } else {\n+                false\n             }\n-        } else {\n-            false\n-        }\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n@@ -251,7 +264,11 @@ fn check_len(\n                 span,\n                 &format!(\"length comparison to {}\", if compare_to == 0 { \"zero\" } else { \"one\" }),\n                 \"using `is_empty` is clearer and more explicit\",\n-                format!(\"{}{}.is_empty()\", op, snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)),\n+                format!(\n+                    \"{}{}.is_empty()\",\n+                    op,\n+                    snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability)\n+                ),\n                 applicability,\n             );\n         }\n@@ -277,16 +294,16 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n-        cx.tcx.inherent_impls(id).iter().any(|imp| {\n-            cx.tcx\n-                .associated_items(*imp)\n-                .any(|item| is_is_empty(cx, &item))\n-        })\n+        cx.tcx\n+            .inherent_impls(id)\n+            .iter()\n+            .any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n     }\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::Dynamic(ref tt, ..) => cx.tcx\n+        ty::Dynamic(ref tt, ..) => cx\n+            .tcx\n             .associated_items(tt.principal().def_id())\n             .any(|item| is_is_empty(cx, &item)),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),"}, {"sha": "282c4536bcabd73dec5579784baf28211d459819", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::hir;\n-use crate::rustc::hir::BindingAnnotation;\n use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::BindingAnnotation;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n use crate::utils::{snippet, span_lint_and_then};\n-use crate::rustc_errors::Applicability;\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for variable declarations immediately followed by a\n /// conditional affectation.\n@@ -207,11 +206,7 @@ fn check_assign<'a, 'tcx>(\n }\n \n fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: ast::NodeId, expr: &'tcx hir::Expr) -> bool {\n-    let mut v = UsedVisitor {\n-        cx,\n-        id,\n-        used: false,\n-    };\n+    let mut v = UsedVisitor { cx, id, used: false };\n     hir::intravisit::walk_expr(&mut v, expr);\n     v.used\n }"}, {"sha": "9eb5a94f51d6bc02e44f6fdd066749b1b685798f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // error-pattern:cargo-clippy\n \n #![feature(box_syntax)]\n@@ -18,7 +17,6 @@\n #![allow(clippy::missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n #![feature(macro_at_most_once_rep)]\n-\n #![warn(rust_2018_idioms, trivial_casts, trivial_numeric_casts)]\n #![feature(crate_visibility_modifier)]\n #![feature(try_from)]\n@@ -216,12 +214,19 @@ mod reexport {\n     crate use crate::syntax::ast::{Name, NodeId};\n }\n \n-pub fn register_pre_expansion_lints(session: &rustc::session::Session, store: &mut rustc::lint::LintStore, conf: &Conf) {\n+pub fn register_pre_expansion_lints(\n+    session: &rustc::session::Session,\n+    store: &mut rustc::lint::LintStore,\n+    conf: &Conf,\n+) {\n     store.register_pre_expansion_pass(Some(session), box write::Pass);\n     store.register_pre_expansion_pass(Some(session), box redundant_field_names::RedundantFieldNames);\n-    store.register_pre_expansion_pass(Some(session), box non_expressive_names::NonExpressiveNames {\n-        single_char_binding_names_threshold: conf.single_char_binding_names_threshold,\n-    });\n+    store.register_pre_expansion_pass(\n+        Some(session),\n+        box non_expressive_names::NonExpressiveNames {\n+            single_char_binding_names_threshold: conf.single_char_binding_names_threshold,\n+        },\n+    );\n     store.register_pre_expansion_pass(Some(session), box attrs::CfgAttrPass);\n }\n \n@@ -236,38 +241,49 @@ pub fn read_conf(reg: &rustc_plugin::Registry<'_>) -> Conf {\n                 match utils::conf::lookup_conf_file() {\n                     Ok(path) => path,\n                     Err(error) => {\n-                        reg.sess.struct_err(&format!(\"error finding Clippy's configuration file: {}\", error)).emit();\n+                        reg.sess\n+                            .struct_err(&format!(\"error finding Clippy's configuration file: {}\", error))\n+                            .emit();\n                         None\n-                    }\n+                    },\n                 }\n             };\n \n-            let file_name = file_name.map(|file_name| if file_name.is_relative() {\n-                reg.sess\n-                    .local_crate_source_file\n-                    .as_ref()\n-                    .and_then(|file| std::path::Path::new(&file).parent().map(std::path::Path::to_path_buf))\n-                    .unwrap_or_default()\n-                    .join(file_name)\n-            } else {\n-                file_name\n+            let file_name = file_name.map(|file_name| {\n+                if file_name.is_relative() {\n+                    reg.sess\n+                        .local_crate_source_file\n+                        .as_ref()\n+                        .and_then(|file| std::path::Path::new(&file).parent().map(std::path::Path::to_path_buf))\n+                        .unwrap_or_default()\n+                        .join(file_name)\n+                } else {\n+                    file_name\n+                }\n             });\n \n             let (conf, errors) = utils::conf::read(file_name.as_ref().map(|p| p.as_ref()));\n \n             // all conf errors are non-fatal, we just use the default conf in case of error\n             for error in errors {\n-                reg.sess.struct_err(&format!(\"error reading Clippy's configuration file `{}`: {}\", file_name.as_ref().and_then(|p| p.to_str()).unwrap_or(\"\"), error)).emit();\n+                reg.sess\n+                    .struct_err(&format!(\n+                        \"error reading Clippy's configuration file `{}`: {}\",\n+                        file_name.as_ref().and_then(|p| p.to_str()).unwrap_or(\"\"),\n+                        error\n+                    ))\n+                    .emit();\n             }\n \n             conf\n-        }\n+        },\n         Err((err, span)) => {\n-            reg.sess.struct_span_err(span, err)\n-                    .span_note(span, \"Clippy will use default configuration\")\n-                    .emit();\n+            reg.sess\n+                .struct_span_err(span, err)\n+                .span_note(span, \"Clippy will use default configuration\")\n+                .emit();\n             toml::from_str(\"\").expect(\"we never error on empty config files\")\n-        }\n+        },\n     }\n }\n "}, {"sha": "9b5da7bfc179f509d1f389f0a5d9f80345d1c2f1", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,18 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::reexport::*;\n-use matches::matches;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir::def::Def;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::*;\n+use crate::rustc::hir::*;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use crate::syntax::source_map::Span;\n-use crate::utils::{last_path_segment, span_lint};\n use crate::syntax::symbol::keywords;\n+use crate::utils::{last_path_segment, span_lint};\n+use matches::matches;\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n /// relying on lifetime elision.\n@@ -32,13 +31,15 @@ use crate::syntax::symbol::keywords;\n ///\n /// **Example:**\n /// ```rust\n-/// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }\n+/// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n+///     x\n+/// }\n /// ```\n declare_clippy_lint! {\n-    pub NEEDLESS_LIFETIMES,\n-    complexity,\n-    \"using explicit lifetimes for references in function arguments when elision rules \\\n-     would allow omitting them\"\n+pub NEEDLESS_LIFETIMES,\n+complexity,\n+\"using explicit lifetimes for references in function arguments when elision rules \\\n+ would allow omitting them\"\n }\n \n /// **What it does:** Checks for lifetimes in generics that are never used\n@@ -52,7 +53,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// fn unused_lifetime<'a>(x: u8) { .. }\n+/// fn unused_lifetime<'a>(x: u8) {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub EXTRA_UNUSED_LIFETIMES,\n@@ -152,7 +155,8 @@ fn check_fn_inner<'a, 'tcx>(\n             cx,\n             NEEDLESS_LIFETIMES,\n             span,\n-            \"explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\",\n+            \"explicit lifetimes given in parameter types where they could be elided \\\n+             (or replaced with `'_` if needed by type declaration)\",\n         );\n     }\n     report_extra_lifetimes(cx, decl, generics);\n@@ -220,9 +224,7 @@ fn could_use_elision<'a, 'tcx: 'a>(\n         // no output lifetimes, check distinctness of input lifetimes\n \n         // only unnamed and static, ok\n-        let unnamed_and_static = input_lts\n-            .iter()\n-            .all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n+        let unnamed_and_static = input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n         if unnamed_and_static {\n             return false;\n         }\n@@ -320,7 +322,8 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                 && !last_path_segment.args.iter().any(|arg| match arg {\n                     GenericArg::Lifetime(_) => true,\n                     GenericArg::Type(_) => false,\n-                }) {\n+                })\n+            {\n                 let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n@@ -354,9 +357,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 self.record(&None);\n             },\n             TyKind::Path(ref path) => {\n-\n                 self.collect_anonymous_lifetimes(path, ty);\n-            }\n+            },\n             TyKind::Def(item, _) => {\n                 if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir.expect_item(item.id).node {\n                     for bound in &exist_ty.bounds {\n@@ -368,7 +370,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                     unreachable!()\n                 }\n                 walk_ty(self, ty);\n-            }\n+            },\n             TyKind::TraitObject(ref bounds, ref lt) => {\n                 if !lt.is_elided() {\n                     self.abort = true;\n@@ -410,9 +412,11 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                 // and check that all lifetimes are allowed\n                 match visitor.into_vec() {\n                     None => return false,\n-                    Some(lts) => for lt in lts {\n-                        if !allowed_lts.contains(&lt) {\n-                            return true;\n+                    Some(lts) => {\n+                        for lt in lts {\n+                            if !allowed_lts.contains(&lt) {\n+                                return true;\n+                            }\n                         }\n                     },\n                 }\n@@ -456,7 +460,9 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n }\n \n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n-    let hs = generics.params.iter()\n+    let hs = generics\n+        .params\n+        .iter()\n         .filter_map(|par| match par.kind {\n             GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n             _ => None,\n@@ -468,7 +474,12 @@ fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx\n     walk_fn_decl(&mut checker, func);\n \n     for &v in checker.map.values() {\n-        span_lint(cx, EXTRA_UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n+        span_lint(\n+            cx,\n+            EXTRA_UNUSED_LIFETIMES,\n+            v,\n+            \"this lifetime isn't used in the function definition\",\n+        );\n     }\n }\n "}, {"sha": "5fc97d97426e021c10b04504850c54029b60d2d7", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -414,9 +414,11 @@ impl LiteralDigitGrouping {\n                                                                                     parts[0].len(),\n                                                                                     parts[1].len());\n                                                 if !consistent {\n-                                                    WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(),\n-                                                    cx,\n-                                                    lit.span);\n+                                                    WarningType::InconsistentDigitGrouping.display(\n+                                                        &digit_info.grouping_hint(),\n+                                                        cx,\n+                                                        lit.span,\n+                                                    );\n                                                 }\n                                         })\n                                     .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),"}, {"sha": "01b526cc63028c281144b2baa8e035e3c450d026", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 194, "deletions": 168, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,33 +7,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use itertools::Itertools;\n use crate::reexport::*;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::def::Def;\n use crate::rustc::hir::def_id;\n use crate::rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::hir::*;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use crate::rustc::middle::region;\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n-use crate::rustc::middle::region;\n+use itertools::Itertools;\n // use crate::rustc::middle::region::CodeExtent;\n+use crate::consts::{constant, Constant};\n use crate::rustc::middle::expr_use_visitor::*;\n-use crate::rustc::middle::mem_categorization::Categorization;\n use crate::rustc::middle::mem_categorization::cmt_;\n-use crate::rustc::ty::{self, Ty};\n+use crate::rustc::middle::mem_categorization::Categorization;\n use crate::rustc::ty::subst::Subst;\n-use crate::rustc_errors::Applicability;\n+use crate::rustc::ty::{self, Ty};\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::iter::{once, Iterator};\n-use std::mem;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n use crate::syntax_pos::BytePos;\n-use crate::utils::{in_macro, sugg, sext};\n use crate::utils::usage::mutated_variables;\n-use crate::consts::{constant, Constant};\n+use crate::utils::{in_macro, sext, sugg};\n+use std::iter::{once, Iterator};\n+use std::mem;\n \n use crate::utils::paths;\n use crate::utils::{\n@@ -92,11 +91,15 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// // with `y` a `Vec` or slice:\n-/// for x in y.iter() { .. }\n+/// for x in y.iter() {\n+///     ..\n+/// }\n /// ```\n /// can be rewritten to\n /// ```rust\n-/// for x in &y { .. }\n+/// for x in &y {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub EXPLICIT_ITER_LOOP,\n@@ -114,11 +117,15 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// // with `y` a `Vec` or slice:\n-/// for x in y.into_iter() { .. }\n+/// for x in y.into_iter() {\n+///     ..\n+/// }\n /// ```\n /// can be rewritten to\n /// ```rust\n-/// for x in y { .. }\n+/// for x in y {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub EXPLICIT_INTO_ITER_LOOP,\n@@ -139,7 +146,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// for x in y.next() { .. }\n+/// for x in y.next() {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub ITER_NEXT_LOOP,\n@@ -156,12 +165,16 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// for x in option { .. }\n+/// for x in option {\n+///     ..\n+/// }\n /// ```\n ///\n /// This should be\n /// ```rust\n-/// if let Some(x) = option { .. }\n+/// if let Some(x) = option {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub FOR_LOOP_OVER_OPTION,\n@@ -178,12 +191,16 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// for x in result { .. }\n+/// for x in result {\n+///     ..\n+/// }\n /// ```\n ///\n /// This should be\n /// ```rust\n-/// if let Ok(x) = result { .. }\n+/// if let Ok(x) = result {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub FOR_LOOP_OVER_RESULT,\n@@ -232,10 +249,10 @@ declare_clippy_lint! {\n /// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n /// ```\n declare_clippy_lint! {\n-    pub UNUSED_COLLECT,\n-    perf,\n-    \"`collect()`ing an iterator without using the result; this is usually better \\\n-     written as a for loop\"\n+pub UNUSED_COLLECT,\n+perf,\n+\"`collect()`ing an iterator without using the result; this is usually better \\\n+ written as a for loop\"\n }\n \n /// **What it does:** Checks for functions collecting an iterator when collect\n@@ -273,7 +290,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// for x in 5..10-5 { .. } // oops, stray `-`\n+/// for x in 5..10 - 5 {\n+///     ..\n+/// } // oops, stray `-`\n /// ```\n declare_clippy_lint! {\n     pub REVERSE_RANGE_LOOP,\n@@ -328,7 +347,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// while let Some(val) = iter() { .. }\n+/// while let Some(val) = iter() {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub WHILE_LET_ON_ITERATOR,\n@@ -346,13 +367,17 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// for (k, _) in &map { .. }\n+/// for (k, _) in &map {\n+///     ..\n+/// }\n /// ```\n ///\n /// could be replaced by\n ///\n /// ```rust\n-/// for k in map.keys() { .. }\n+/// for k in map.keys() {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub FOR_KV_MAP,\n@@ -370,7 +395,10 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// loop { ..; break; }\n+/// loop {\n+///     ..;\n+///     break;\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub NEVER_LOOP,\n@@ -412,7 +440,7 @@ declare_clippy_lint! {\n /// ```rust\n /// let i = 0;\n /// while i > 10 {\n-///    println!(\"let me loop forever!\");\n+///     println!(\"let me loop forever!\");\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -459,8 +487,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match expr.node {\n             ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n                 match never_loop_block(block, expr.id) {\n-                    NeverLoopResult::AlwaysBreak =>\n-                        span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+                    NeverLoopResult::AlwaysBreak => {\n+                        span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\")\n+                    },\n                     NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n                 }\n             },\n@@ -490,8 +519,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n-                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none()\n-                                && arms[1].pats.len() == 1 && arms[1].guard.is_none()\n+                            if arms.len() == 2\n+                                && arms[0].pats.len() == 1\n+                                && arms[0].guard.is_none()\n+                                && arms[1].pats.len() == 1\n+                                && arms[1].guard.is_none()\n                                 && is_simple_break_expr(&arms[1].body)\n                             {\n                                 if in_external_macro(cx.sess(), expr.span) {\n@@ -533,12 +565,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.ident.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR)\n-                    && lhs_constructor.ident.name == \"Some\" && (\n-                        pat_args.is_empty()\n+                if method_path.ident.name == \"next\"\n+                    && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                    && lhs_constructor.ident.name == \"Some\"\n+                    && (pat_args.is_empty()\n                         || !is_refutable(cx, &pat_args[0])\n-                        && !is_iterator_used_after_while_let(cx, iter_expr)\n-                        && !is_nested(cx, expr, &method_args[0]))\n+                            && !is_iterator_used_after_while_let(cx, iter_expr)\n+                            && !is_nested(cx, expr, &method_args[0]))\n                 {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = if pat_args.is_empty() {\n@@ -594,8 +627,7 @@ enum NeverLoopResult {\n \n fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n     match *arg {\n-        NeverLoopResult::AlwaysBreak |\n-        NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n         NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n     }\n }\n@@ -611,24 +643,22 @@ fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResu\n // Combine two results where both parts are called but not necessarily in order.\n fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n     match (left, right) {\n-        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) =>\n-            NeverLoopResult::MayContinueMainLoop,\n-        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) =>\n-            NeverLoopResult::AlwaysBreak,\n-        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) =>\n-            NeverLoopResult::Otherwise,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n     }\n }\n \n // Combine two results where only one of the part may have been executed.\n fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n     match (b1, b2) {\n-        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) =>\n-            NeverLoopResult::AlwaysBreak,\n-        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) =>\n-            NeverLoopResult::MayContinueMainLoop,\n-        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) =>\n-            NeverLoopResult::Otherwise,\n+        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n     }\n }\n \n@@ -655,26 +685,28 @@ fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n \n fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n-        ExprKind::Box(ref e) |\n-        ExprKind::Unary(_, ref e) |\n-        ExprKind::Cast(ref e, _) |\n-        ExprKind::Type(ref e, _) |\n-        ExprKind::Field(ref e, _) |\n-        ExprKind::AddrOf(_, ref e) |\n-        ExprKind::Struct(_, _, Some(ref e)) |\n-        ExprKind::Repeat(ref e, _) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Box(ref e)\n+        | ExprKind::Unary(_, ref e)\n+        | ExprKind::Cast(ref e, _)\n+        | ExprKind::Type(ref e, _)\n+        | ExprKind::Field(ref e, _)\n+        | ExprKind::AddrOf(_, ref e)\n+        | ExprKind::Struct(_, _, Some(ref e))\n+        | ExprKind::Repeat(ref e, _) => never_loop_expr(e, main_loop_id),\n         ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es) | ExprKind::Tup(ref es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n         ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprKind::Binary(_, ref e1, ref e2) |\n-        ExprKind::Assign(ref e1, ref e2) |\n-        ExprKind::AssignOp(_, ref e1, ref e2) |\n-        ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2)\n+        | ExprKind::Assign(ref e1, ref e2)\n+        | ExprKind::AssignOp(_, ref e1, ref e2)\n+        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n         ExprKind::If(ref e, ref e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n-            let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            let e3 = e3\n+                .as_ref()\n+                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n         ExprKind::Loop(ref b, _, _) => {\n@@ -698,44 +730,43 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n         },\n         ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n         ExprKind::Continue(d) => {\n-            let id = d.target_id\n+            let id = d\n+                .target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n                 NeverLoopResult::MayContinueMainLoop\n             } else {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, _) => {\n-            NeverLoopResult::AlwaysBreak\n-        },\n+        ExprKind::Break(_, _) => NeverLoopResult::AlwaysBreak,\n         ExprKind::Ret(ref e) => {\n             if let Some(ref e) = *e {\n                 combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n             } else {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Struct(_, _, None) |\n-        ExprKind::Yield(_) |\n-        ExprKind::Closure(_, _, _, _, _) |\n-        ExprKind::InlineAsm(_, _, _) |\n-        ExprKind::Path(_) |\n-        ExprKind::Lit(_) => NeverLoopResult::Otherwise,\n+        ExprKind::Struct(_, _, None)\n+        | ExprKind::Yield(_)\n+        | ExprKind::Closure(_, _, _, _, _)\n+        | ExprKind::InlineAsm(_, _, _)\n+        | ExprKind::Path(_)\n+        | ExprKind::Lit(_) => NeverLoopResult::Otherwise,\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n@@ -779,10 +810,7 @@ struct Offset {\n \n impl Offset {\n     fn negative(s: String) -> Self {\n-        Self {\n-            value: s,\n-            negate: true,\n-        }\n+        Self { value: s, negate: true }\n     }\n \n     fn positive(s: String) -> Self {\n@@ -842,19 +870,19 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n                 BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n                 _ => None,\n             },\n-            ExprKind::Path(..) => if same_var(cx, idx, var) {\n-                Some(Offset::positive(\"0\".into()))\n-            } else {\n-                None\n+            ExprKind::Path(..) => {\n+                if same_var(cx, idx, var) {\n+                    Some(Offset::positive(\"0\".into()))\n+                } else {\n+                    None\n+                }\n             },\n             _ => None,\n         };\n \n-        offset.map(|o| {\n-            FixedOffsetVar {\n-                var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n-                offset: o,\n-            }\n+        offset.map(|o| FixedOffsetVar {\n+            var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n+            offset: o,\n         })\n     } else {\n         None\n@@ -890,7 +918,10 @@ fn get_indexed_assignments<'a, 'tcx>(\n         var: ast::NodeId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n         if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n-            match (get_fixed_offset_var(cx, lhs, var), fetch_cloned_fixed_offset_var(cx, rhs, var)) {\n+            match (\n+                get_fixed_offset_var(cx, lhs, var),\n+                fetch_cloned_fixed_offset_var(cx, rhs, var),\n+            ) {\n                 (Some(offset_left), Some(offset_right)) => {\n                     // Source and destination must be different\n                     if offset_left.var_name == offset_right.var_name {\n@@ -908,9 +939,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n \n     if let ExprKind::Block(ref b, _) = body.node {\n         let Block {\n-            ref stmts,\n-            ref expr,\n-            ..\n+            ref stmts, ref expr, ..\n         } = **b;\n \n         stmts\n@@ -919,11 +948,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n                 StmtKind::Decl(..) => None,\n                 StmtKind::Expr(ref e, _node_id) | StmtKind::Semi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n             })\n-            .chain(\n-                expr.as_ref()\n-                    .into_iter()\n-                    .map(|e| Some(get_assignment(cx, &*e, var))),\n-            )\n+            .chain(expr.as_ref().into_iter().map(|e| Some(get_assignment(cx, &*e, var))))\n             .filter_map(|op| op)\n             .collect::<Option<Vec<_>>>()\n             .unwrap_or_else(|| vec![])\n@@ -973,33 +998,35 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                 }\n             };\n \n-            let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n-                if_chain! {\n-                    if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n-                    if method.ident.name == \"len\";\n-                    if len_args.len() == 1;\n-                    if let Some(arg) = len_args.get(0);\n-                    if snippet(cx, arg.span, \"??\") == var_name;\n-                    then {\n-                        return if offset.negate {\n-                            format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n-                        } else {\n-                            String::new()\n-                        };\n+            let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| {\n+                if let Some(end) = *end {\n+                    if_chain! {\n+                        if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n+                        if method.ident.name == \"len\";\n+                        if len_args.len() == 1;\n+                        if let Some(arg) = len_args.get(0);\n+                        if snippet(cx, arg.span, \"??\") == var_name;\n+                        then {\n+                            return if offset.negate {\n+                                format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n+                            } else {\n+                                String::new()\n+                            };\n+                        }\n                     }\n-                }\n \n-                let end_str = match limits {\n-                    ast::RangeLimits::Closed => {\n-                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                        format!(\"{}\", end + sugg::ONE)\n-                    },\n-                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                };\n+                    let end_str = match limits {\n+                        ast::RangeLimits::Closed => {\n+                            let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                            format!(\"{}\", end + sugg::ONE)\n+                        },\n+                        ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                    };\n \n-                print_sum(&Offset::positive(end_str), &offset)\n-            } else {\n-                \"..\".into()\n+                    print_sum(&Offset::positive(end_str), &offset)\n+                } else {\n+                    \"..\".into()\n+                }\n             };\n \n             // The only statements in the for loops can be indexed assignments from\n@@ -1020,7 +1047,10 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                         format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n                     };\n \n-                    format!(\"{}.clone_from_slice(&{}[{}..{}])\", dst, src_var.var_name, src_offset, src_limit)\n+                    format!(\n+                        \"{}.clone_from_slice(&{}[{}..{}])\",\n+                        dst, src_var.var_name, src_offset, src_limit\n+                    )\n                 })\n                 .join(\"\\n    \");\n \n@@ -1166,7 +1196,10 @@ fn check_for_loop_range<'a, 'tcx>(\n                                 \"consider using an iterator\".to_string(),\n                                 vec![\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n-                                    (arg.span, format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2)),\n+                                    (\n+                                        arg.span,\n+                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                    ),\n                                 ],\n                             );\n                         },\n@@ -1182,7 +1215,10 @@ fn check_for_loop_range<'a, 'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         expr.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.name, indexed),\n+                        &format!(\n+                            \"the loop variable `{}` is only used to index `{}`.\",\n+                            ident.name, indexed\n+                        ),\n                         |db| {\n                             multispan_sugg(\n                                 db,\n@@ -1213,12 +1249,7 @@ fn is_len_call(expr: &Expr, var: Name) -> bool {\n     false\n }\n \n-fn is_end_eq_array_len(\n-    cx: &LateContext<'_, '_>,\n-    end: &Expr,\n-    limits: ast::RangeLimits,\n-    indexed_ty: Ty<'_>,\n-) -> bool {\n+fn is_end_eq_array_len(cx: &LateContext<'_, '_>, end: &Expr, limits: ast::RangeLimits, indexed_ty: Ty<'_>) -> bool {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = end.node;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n@@ -1252,14 +1283,14 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                 // smaller value.\n                 let ty = cx.tables.expr_ty(start);\n                 let (sup, eq) = match (start_idx, end_idx) {\n-                    (\n-                        Constant::Int(start_idx),\n-                        Constant::Int(end_idx),\n-                    ) => (match ty.sty {\n-                        ty::Int(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n-                        ty::Uint(_) => start_idx > end_idx,\n-                        _ => false,\n-                    }, start_idx == end_idx),\n+                    (Constant::Int(start_idx), Constant::Int(end_idx)) => (\n+                        match ty.sty {\n+                            ty::Int(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n+                            ty::Uint(_) => start_idx > end_idx,\n+                            _ => false,\n+                        },\n+                        start_idx == end_idx,\n+                    ),\n                     _ => (false, false),\n                 };\n \n@@ -1310,11 +1341,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n     let mut applicability = Applicability::MachineApplicable;\n     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n-    let muta = if method_name == \"iter_mut\" {\n-        \"mut \"\n-    } else {\n-        \"\"\n-    };\n+    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n     span_lint_and_sugg(\n         cx,\n         EXPLICIT_ITER_LOOP,\n@@ -1439,15 +1466,12 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir;\n-    let parent_scope = map.get_enclosing_scope(expr.id)\n+    let parent_scope = map\n+        .get_enclosing_scope(expr.id)\n         .and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let Node::Block(block) = map.get(parent_id) {\n-            for (id, _) in visitor\n-                .states\n-                .iter()\n-                .filter(|&(_, v)| *v == VarState::IncrOnce)\n-            {\n+            for (id, _) in visitor.states.iter().filter(|&(_, v)| *v == VarState::IncrOnce) {\n                 let mut visitor2 = InitializeVisitor {\n                     cx,\n                     end_expr: expr,\n@@ -1586,10 +1610,7 @@ fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr, body: &Expr)\n         ..\n     }) = higher::range(cx, arg)\n     {\n-        let mut_ids = vec![\n-            check_for_mutability(cx, start),\n-            check_for_mutability(cx, end),\n-        ];\n+        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {\n             let (span_low, span_high) = check_for_mutation(cx, body, &mut_ids);\n             mut_warn_with_span(cx, span_low);\n@@ -1631,7 +1652,11 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n     None\n }\n \n-fn check_for_mutation(cx: &LateContext<'_, '_>, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n+fn check_for_mutation(\n+    cx: &LateContext<'_, '_>,\n+    body: &Expr,\n+    bound_ids: &[Option<NodeId>],\n+) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n@@ -1821,8 +1846,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         }\n         let old = self.prefer_mutable;\n         match expr.node {\n-            ExprKind::AssignOp(_, ref lhs, ref rhs) |\n-            ExprKind::Assign(ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n@@ -1910,7 +1934,6 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n     }\n }\n \n-\n /// Return true if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[rustfmt::skip]\n@@ -1998,9 +2021,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,     // context reference\n+    cx: &'a LateContext<'a, 'tcx>,       // context reference\n     states: FxHashMap<NodeId, VarState>, // incremented variables\n-    depth: u32,                        // depth of conditional expressions\n+    depth: u32,                          // depth of conditional expressions\n     done: bool,\n }\n \n@@ -2244,8 +2267,10 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n-                self.nesting = RuledOut;\n+            ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => {\n+                if match_var(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n             },\n             _ => walk_expr(self, expr),\n         }\n@@ -2299,15 +2324,16 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, e\n     let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n         used_in_condition.is_disjoint(&used_mutably)\n     } else {\n-        return\n+        return;\n     };\n     let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n     if no_cond_variable_mutated && !mutable_static_in_cond {\n         span_lint(\n             cx,\n             WHILE_IMMUTABLE_CONDITION,\n             cond.span,\n-            \"Variable in the condition are not mutated in the loop body. This either leads to an infinite or to a never running loop.\",\n+            \"Variable in the condition are not mutated in the loop body. \\\n+             This either leads to an infinite or to a never running loop.\",\n         );\n     }\n }"}, {"sha": "4ea02db1465920e0b16c3b6cae9db666d4763727", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::Ident;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::utils::{in_macro, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{\n+    in_macro, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n \n #[derive(Clone)]\n@@ -72,15 +73,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let closure_expr = remove_blocks(&closure_body.value);\n             then {\n                 match closure_body.arguments[0].pat.node {\n-                    hir::PatKind::Ref(ref inner, _) => if let hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) = inner.node {\n+                    hir::PatKind::Ref(ref inner, _) => if let hir::PatKind::Binding(\n+                        hir::BindingAnnotation::Unannotated, _, name, None\n+                    ) = inner.node {\n                         lint(cx, e.span, args[0].span, name, closure_expr);\n                     },\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => match closure_expr.node {\n-                        hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) if !cx.tables.expr_ty(inner).is_box() => lint(cx, e.span, args[0].span, name, inner),\n-                        hir::ExprKind::MethodCall(ref method, _, ref obj) => if method.ident.as_str() == \"clone\" && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n-                            lint(cx, e.span, args[0].span, name, &obj[0]);\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        match closure_expr.node {\n+                            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n+                                if !cx.tables.expr_ty(inner).is_box() => {\n+                                    lint(cx, e.span, args[0].span, name, inner);\n+                                }\n+                            },\n+                            hir::ExprKind::MethodCall(ref method, _, ref obj) => {\n+                                if method.ident.as_str() == \"clone\"\n+                                    && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n+                                    lint(cx, e.span, args[0].span, name, &obj[0]);\n+                                }\n+                            },\n+                            _ => {},\n                         }\n-                        _ => {},\n                     },\n                     _ => {},\n                 }\n@@ -99,7 +111,10 @@ fn lint(cx: &LateContext<'_, '_>, replace: Span, root: Span, name: Ident, path:\n                 replace,\n                 \"You are using an explicit closure for cloning elements\",\n                 \"Consider calling the dedicated `cloned` method\",\n-                format!(\"{}.cloned()\", snippet_with_applicability(cx, root, \"..\", &mut applicability)),\n+                format!(\n+                    \"{}.cloned()\",\n+                    snippet_with_applicability(cx, root, \"..\", &mut applicability)\n+                ),\n                 applicability,\n             )\n         }"}, {"sha": "8fb41b25c737717d8daadf236be24cacc23fc44f", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n-use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n use crate::utils::paths;\n+use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n+use if_chain::if_chain;\n \n #[derive(Clone)]\n pub struct Pass;\n@@ -87,7 +86,6 @@ declare_clippy_lint! {\n     \"using `result.map(f)`, where f is a function or closure that returns ()\"\n }\n \n-\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN)\n@@ -127,8 +125,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n     }\n \n     match expr.node {\n-        hir::ExprKind::Call(_, _) |\n-        hir::ExprKind::MethodCall(_, _, _) => {\n+        hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(_, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n@@ -155,7 +152,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n                     //\n                     // We do not attempt to build a suggestion for those right now.\n                     None\n-                }\n+                },\n             }\n         },\n         _ => None,\n@@ -189,72 +186,68 @@ fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n-        _ => \"_\".to_string()\n+        _ => \"_\".to_string(),\n     }\n }\n \n fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     format!(\n         \"called `map(f)` on an {0} value where `f` is a unit {1}\",\n-        map_type,\n-        function_type\n+        map_type, function_type\n     )\n }\n \n fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n-    let (map_type, variant, lint) =\n-        if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n-            (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-        } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n-            (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n-        } else {\n-            return\n-        };\n+    let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n+        (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n+    } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n+        (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n+    } else {\n+        return;\n+    };\n \n     if is_unit_function(cx, fn_arg) {\n         let msg = suggestion_msg(\"function\", map_type);\n-        let suggestion = format!(\"if let {0}({1}) = {2} {{ {3}(...) }}\",\n-                                 variant,\n-                                 let_binding_name(cx, var_arg),\n-                                 snippet(cx, var_arg.span, \"_\"),\n-                                 snippet(cx, fn_arg.span, \"_\"));\n+        let suggestion = format!(\n+            \"if let {0}({1}) = {2} {{ {3}(...) }}\",\n+            variant,\n+            let_binding_name(cx, var_arg),\n+            snippet(cx, var_arg.span, \"_\"),\n+            snippet(cx, fn_arg.span, \"_\")\n+        );\n \n         span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n-            db.span_suggestion_with_applicability(stmt.span,\n-                                                  \"try this\",\n-                                                  suggestion,\n-                                                  Applicability::Unspecified);\n+            db.span_suggestion_with_applicability(stmt.span, \"try this\", suggestion, Applicability::Unspecified);\n         });\n     } else if let Some((binding, closure_expr)) = unit_closure(cx, fn_arg) {\n         let msg = suggestion_msg(\"closure\", map_type);\n \n         span_lint_and_then(cx, lint, expr.span, &msg, |db| {\n             if let Some(reduced_expr_span) = reduce_unit_expression(cx, closure_expr) {\n-                let suggestion = format!(\"if let {0}({1}) = {2} {{ {3} }}\",\n-                                         variant,\n-                                         snippet(cx, binding.pat.span, \"_\"),\n-                                         snippet(cx, var_arg.span, \"_\"),\n-                                         snippet(cx, reduced_expr_span, \"_\"));\n+                let suggestion = format!(\n+                    \"if let {0}({1}) = {2} {{ {3} }}\",\n+                    variant,\n+                    snippet(cx, binding.pat.span, \"_\"),\n+                    snippet(cx, var_arg.span, \"_\"),\n+                    snippet(cx, reduced_expr_span, \"_\")\n+                );\n                 db.span_suggestion_with_applicability(\n                     stmt.span,\n                     \"try this\",\n                     suggestion,\n                     Applicability::MachineApplicable, // snippet\n                 );\n             } else {\n-                let suggestion = format!(\"if let {0}({1}) = {2} {{ ... }}\",\n-                                         variant,\n-                                         snippet(cx, binding.pat.span, \"_\"),\n-                                         snippet(cx, var_arg.span, \"_\"));\n-                db.span_suggestion_with_applicability(\n-                    stmt.span,\n-                    \"try this\",\n-                    suggestion,\n-                    Applicability::Unspecified,\n+                let suggestion = format!(\n+                    \"if let {0}({1}) = {2} {{ ... }}\",\n+                    variant,\n+                    snippet(cx, binding.pat.span, \"_\"),\n+                    snippet(cx, var_arg.span, \"_\")\n                 );\n+                db.span_suggestion_with_applicability(stmt.span, \"try this\", suggestion, Applicability::Unspecified);\n             }\n         });\n     }"}, {"sha": "1821a35cf593bedf6db4652e11e6b38fea86ef2d", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 88, "deletions": 64, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,23 +7,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::consts::{constant, Constant};\n use crate::rustc::hir::*;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty::{self, Ty};\n-use std::cmp::Ordering;\n-use std::collections::Bound;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::utils::{expr_block, in_macro, is_allowed, is_expn_of, match_qpath, match_type,\n-    multispan_sugg, remove_blocks, snippet, snippet_with_applicability, span_lint_and_sugg, span_lint_and_then,\n-    span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n-use crate::consts::{constant, Constant};\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{\n+    expr_block, in_macro, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg, remove_blocks, snippet,\n+    snippet_with_applicability, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n+use std::cmp::Ordering;\n+use std::collections::Bound;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n /// will usually suffice.\n@@ -36,14 +36,14 @@ use crate::rustc_errors::Applicability;\n /// ```rust\n /// match x {\n ///     Some(ref foo) => bar(foo),\n-///     _ => ()\n+///     _ => (),\n /// }\n /// ```\n declare_clippy_lint! {\n-    pub SINGLE_MATCH,\n-    style,\n-    \"a match statement with a single nontrivial arm (i.e. where the other arm \\\n-     is `_ => {}`) instead of `if let`\"\n+pub SINGLE_MATCH,\n+style,\n+\"a match statement with a single nontrivial arm (i.e. where the other arm \\\n+ is `_ => {}`) instead of `if let`\"\n }\n \n /// **What it does:** Checks for matches with a two arms where an `if let` will\n@@ -61,10 +61,10 @@ declare_clippy_lint! {\n /// }\n /// ```\n declare_clippy_lint! {\n-    pub SINGLE_MATCH_ELSE,\n-    pedantic,\n-    \"a match statement with a two arms where the second arm's pattern is a wildcard \\\n-     instead of `if let`\"\n+pub SINGLE_MATCH_ELSE,\n+pedantic,\n+\"a match statement with a two arms where the second arm's pattern is a wildcard \\\n+ instead of `if let`\"\n }\n \n /// **What it does:** Checks for matches where all arms match a reference,\n@@ -131,8 +131,8 @@ declare_clippy_lint! {\n /// ```rust\n /// let x = 5;\n /// match x {\n-///     1 ... 10 => println!(\"1 ... 10\"),\n-///     5 ... 15 => println!(\"5 ... 15\"),\n+///     1...10 => println!(\"1 ... 10\"),\n+///     5...15 => println!(\"5 ... 15\"),\n ///     _ => (),\n /// }\n /// ```\n@@ -152,7 +152,7 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let x : Result(i32, &str) = Ok(3);\n+/// let x: Result(i32, &str) = Ok(3);\n /// match x {\n ///     Ok(_) => println!(\"ok\"),\n ///     Err(_) => panic!(\"err\"),\n@@ -175,8 +175,8 @@ declare_clippy_lint! {\n /// ```rust\n /// let x: Option<()> = None;\n /// let r: Option<&()> = match x {\n-///   None => None,\n-///   Some(ref v) => Some(v),\n+///     None => None,\n+///     Some(ref v) => Some(v),\n /// };\n /// ```\n declare_clippy_lint! {\n@@ -243,19 +243,29 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n     }\n }\n \n-fn check_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn check_single_match_single_pattern(\n+    cx: &LateContext<'_, '_>,\n+    ex: &Expr,\n+    arms: &[Arm],\n+    expr: &Expr,\n+    els: Option<&Expr>,\n+) {\n     if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n-fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n-    let lint = if els.is_some() {\n-        SINGLE_MATCH_ELSE\n-    } else {\n-        SINGLE_MATCH\n-    };\n-    let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n+fn report_single_match_single_pattern(\n+    cx: &LateContext<'_, '_>,\n+    ex: &Expr,\n+    arms: &[Arm],\n+    expr: &Expr,\n+    els: Option<&Expr>,\n+) {\n+    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let els_str = els.map_or(String::new(), |els| {\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\"))\n+    });\n     span_lint_and_sugg(\n         cx,\n         lint,\n@@ -274,7 +284,14 @@ fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms:\n     );\n }\n \n-fn check_single_match_opt_like(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty<'_>, els: Option<&Expr>) {\n+fn check_single_match_opt_like(\n+    cx: &LateContext<'_, '_>,\n+    ex: &Expr,\n+    arms: &[Arm],\n+    expr: &Expr,\n+    ty: Ty<'_>,\n+    els: Option<&Expr>,\n+) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n@@ -466,9 +483,12 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n }\n \n fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2 &&\n-        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-        arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n+    if arms.len() == 2\n+        && arms[0].pats.len() == 1\n+        && arms[0].guard.is_none()\n+        && arms[1].pats.len() == 1\n+        && arms[1].guard.is_none()\n+    {\n         let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n             is_ref_some_arm(&arms[1])\n         } else if is_none_arm(&arms[1]) {\n@@ -477,51 +497,61 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n             None\n         };\n         if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref { \"as_ref\" } else { \"as_mut\" };\n+            let suggestion = if rb == BindingAnnotation::Ref {\n+                \"as_ref\"\n+            } else {\n+                \"as_mut\"\n+            };\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 MATCH_AS_REF,\n                 expr.span,\n                 &format!(\"use {}() instead\", suggestion),\n                 \"try this\",\n-                format!(\"{}.{}()\", snippet_with_applicability(cx, ex.span, \"_\", &mut applicability), suggestion),\n+                format!(\n+                    \"{}.{}()\",\n+                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n+                    suggestion\n+                ),\n                 applicability,\n             )\n         }\n     }\n }\n \n /// Get all arms that are unbounded `PatRange`s.\n-fn all_ranges<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    arms: &'tcx [Arm],\n-) -> Vec<SpannedRange<Constant>> {\n+fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm {\n-                ref pats,\n-                guard: None,\n-                ..\n+                ref pats, guard: None, ..\n             } = *arm\n             {\n                 pats.iter()\n             } else {\n                 [].iter()\n-            }.filter_map(|pat| {\n+            }\n+            .filter_map(|pat| {\n                 if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node {\n                     let lhs = constant(cx, cx.tables, lhs)?.0;\n                     let rhs = constant(cx, cx.tables, rhs)?.0;\n                     let rhs = match *range_end {\n                         RangeEnd::Included => Bound::Included(rhs),\n                         RangeEnd::Excluded => Bound::Excluded(rhs),\n                     };\n-                    return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (lhs, rhs),\n+                    });\n                 }\n \n                 if let PatKind::Lit(ref value) = pat.node {\n                     let value = constant(cx, cx.tables, value)?.0;\n-                    return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (value.clone(), Bound::Included(value)),\n+                    });\n                 }\n \n                 None\n@@ -545,24 +575,15 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n     ranges\n         .iter()\n         .filter_map(|range| match range.node {\n-            (\n-                Constant::Int(start),\n-                Bound::Included(Constant::Int(end)),\n-            ) => Some(SpannedRange {\n+            (Constant::Int(start), Bound::Included(Constant::Int(end))) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Included(end)),\n             }),\n-            (\n-                Constant::Int(start),\n-                Bound::Excluded(Constant::Int(end)),\n-            ) => Some(SpannedRange {\n+            (Constant::Int(start), Bound::Excluded(Constant::Int(end))) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Excluded(end)),\n             }),\n-            (\n-                Constant::Int(start),\n-                Bound::Unbounded,\n-            ) => Some(SpannedRange {\n+            (Constant::Int(start), Bound::Unbounded) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Unbounded),\n             }),\n@@ -608,7 +629,8 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n }\n \n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n-    let mapped = arms.iter()\n+    let mapped = arms\n+        .iter()\n         .flat_map(|a| &a.pats)\n         .map(|p| {\n             match p.node {\n@@ -682,8 +704,10 @@ where\n \n     for (a, b) in values.iter().zip(values.iter().skip(1)) {\n         match (a, b) {\n-            (&Kind::Start(_, ra), &Kind::End(_, rb)) => if ra.node != rb.node {\n-                return Some((ra, rb));\n+            (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n+                if ra.node != rb.node {\n+                    return Some((ra, rb));\n+                }\n             },\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != Bound::Included(b) => (),\n             _ => return Some((a.range(), b.range())),"}, {"sha": "5c58c990dc77a6d277ef455f3426b4d2512685a0", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::{Expr, ExprKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};"}, {"sha": "066eeb70fdeac1b820b49419d79abf2963eb1914", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::{Expr, ExprKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::{Expr, ExprKind};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is"}, {"sha": "91586ae152d6622d8219de7536518670621fece1", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};"}, {"sha": "9e56213931a23e018d4416a0b5f5c83ea84bf559", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 232, "deletions": 200, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray, LintContext, LintPass};\n-use crate::rustc::ty::{self, Ty, TyKind, Predicate};\n+use crate::rustc::ty::{self, Predicate, Ty, TyKind};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n@@ -23,7 +22,7 @@ use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n     match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path, snippet,\n-    snippet_with_macro_callsite, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg, span_lint_and_then,\n     span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n use if_chain::if_chain;\n@@ -95,7 +94,9 @@ declare_clippy_lint! {\n /// ```rust\n /// struct X;\n /// impl X {\n-///    fn add(&self, other: &X) -> X { .. }\n+///     fn add(&self, other: &X) -> X {\n+///         ..\n+///     }\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -124,14 +125,16 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// impl X {\n-///     fn as_str(self) -> &str { .. }\n+///     fn as_str(self) -> &str {\n+///         ..\n+///     }\n /// }\n /// ```\n declare_clippy_lint! {\n-    pub WRONG_SELF_CONVENTION,\n-    style,\n-    \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n-     `self` with the wrong convention\"\n+pub WRONG_SELF_CONVENTION,\n+style,\n+\"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n+ `self` with the wrong convention\"\n }\n \n /// **What it does:** This is the same as\n@@ -146,14 +149,16 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// impl X {\n-///     pub fn as_str(self) -> &str { .. }\n+///     pub fn as_str(self) -> &str {\n+///         ..\n+///     }\n /// }\n /// ```\n declare_clippy_lint! {\n-    pub WRONG_PUB_SELF_CONVENTION,\n-    restriction,\n-    \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n-     `self` with the wrong convention\"\n+pub WRONG_PUB_SELF_CONVENTION,\n+restriction,\n+\"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n+ `self` with the wrong convention\"\n }\n \n /// **What it does:** Checks for usage of `ok().expect(..)`.\n@@ -168,10 +173,10 @@ declare_clippy_lint! {\n /// x.ok().expect(\"why did I do this again?\")\n /// ```\n declare_clippy_lint! {\n-    pub OK_EXPECT,\n-    style,\n-    \"using `ok().expect()`, which gives worse error messages than \\\n-     calling `expect` directly on the Result\"\n+pub OK_EXPECT,\n+style,\n+\"using `ok().expect()`, which gives worse error messages than \\\n+ calling `expect` directly on the Result\"\n }\n \n /// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n@@ -186,10 +191,10 @@ declare_clippy_lint! {\n /// x.map(|a| a + 1).unwrap_or(0)\n /// ```\n declare_clippy_lint! {\n-    pub OPTION_MAP_UNWRAP_OR,\n-    pedantic,\n-    \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n-     `map_or(a, f)`\"\n+pub OPTION_MAP_UNWRAP_OR,\n+pedantic,\n+\"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n+ `map_or(a, f)`\"\n }\n \n /// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n@@ -204,10 +209,10 @@ declare_clippy_lint! {\n /// x.map(|a| a + 1).unwrap_or_else(some_function)\n /// ```\n declare_clippy_lint! {\n-    pub OPTION_MAP_UNWRAP_OR_ELSE,\n-    pedantic,\n-    \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n-     `map_or_else(g, f)`\"\n+pub OPTION_MAP_UNWRAP_OR_ELSE,\n+pedantic,\n+\"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n+ `map_or_else(g, f)`\"\n }\n \n /// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n@@ -222,10 +227,10 @@ declare_clippy_lint! {\n /// x.map(|a| a + 1).unwrap_or_else(some_function)\n /// ```\n declare_clippy_lint! {\n-    pub RESULT_MAP_UNWRAP_OR_ELSE,\n-    pedantic,\n-    \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n-     `.ok().map_or_else(g, f)`\"\n+pub RESULT_MAP_UNWRAP_OR_ELSE,\n+pedantic,\n+\"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n+ `.ok().map_or_else(g, f)`\"\n }\n \n /// **What it does:** Checks for usage of `_.map_or(None, _)`.\n@@ -240,10 +245,10 @@ declare_clippy_lint! {\n /// opt.map_or(None, |a| a + 1)\n /// ```\n declare_clippy_lint! {\n-    pub OPTION_MAP_OR_NONE,\n-    style,\n-    \"using `Option.map_or(None, f)`, which is more succinctly expressed as \\\n-     `and_then(f)`\"\n+pub OPTION_MAP_OR_NONE,\n+style,\n+\"using `Option.map_or(None, f)`, which is more succinctly expressed as \\\n+ `and_then(f)`\"\n }\n \n /// **What it does:** Checks for usage of `_.filter(_).next()`.\n@@ -275,10 +280,10 @@ declare_clippy_lint! {\n /// iter.map(|x| x.iter()).flatten()\n /// ```\n declare_clippy_lint! {\n-    pub MAP_FLATTEN,\n-    pedantic,\n-    \"using combinations of `flatten` and `map` which can usually be written as a \\\n-     single method call\"\n+pub MAP_FLATTEN,\n+pedantic,\n+\"using combinations of `flatten` and `map` which can usually be written as a \\\n+ single method call\"\n }\n \n /// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n@@ -295,10 +300,10 @@ declare_clippy_lint! {\n /// iter.filter(|x| x == 0).map(|x| x * 2)\n /// ```\n declare_clippy_lint! {\n-    pub FILTER_MAP,\n-    pedantic,\n-    \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can \\\n-     usually be written as a single method call\"\n+pub FILTER_MAP,\n+pedantic,\n+\"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can \\\n+ usually be written as a single method call\"\n }\n \n /// **What it does:** Checks for an iterator search (such as `find()`,\n@@ -314,10 +319,10 @@ declare_clippy_lint! {\n /// iter.find(|x| x == 0).is_some()\n /// ```\n declare_clippy_lint! {\n-    pub SEARCH_IS_SOME,\n-    complexity,\n-    \"using an iterator search followed by `is_some()`, which is more succinctly \\\n-     expressed as a call to `any()`\"\n+pub SEARCH_IS_SOME,\n+complexity,\n+\"using an iterator search followed by `is_some()`, which is more succinctly \\\n+ expressed as a call to `any()`\"\n }\n \n /// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n@@ -437,10 +442,10 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// fn main() {\n-///    let x = vec![1];\n-///    let y = &&x;\n-///    let z = y.clone();\n-///    println!(\"{:p} {:p}\",*y, z); // prints out the same pointer\n+///     let x = vec![1];\n+///     let y = &&x;\n+///     let z = y.clone();\n+///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -480,10 +485,10 @@ declare_clippy_lint! {\n /// **Example:**\n /// `_.split(\"x\")` could be `_.split('x')`\n declare_clippy_lint! {\n-    pub SINGLE_CHAR_PATTERN,\n-    perf,\n-    \"using a single-character str where a char could be used, e.g. \\\n-     `_.split(\\\"x\\\")`\"\n+pub SINGLE_CHAR_PATTERN,\n+perf,\n+\"using a single-character str where a char could be used, e.g. \\\n+ `_.split(\\\"x\\\")`\"\n }\n \n /// **What it does:** Checks for getting the inner pointer of a temporary\n@@ -635,13 +640,13 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let s = [1,2,3,4,5];\n-/// let s2 : Vec<isize> = s[..].iter().cloned().collect();\n+/// let s = [1, 2, 3, 4, 5];\n+/// let s2: Vec<isize> = s[..].iter().cloned().collect();\n /// ```\n /// The better use would be:\n /// ```rust\n-/// let s = [1,2,3,4,5];\n-/// let s2 : Vec<isize> = s.to_vec();\n+/// let s = [1, 2, 3, 4, 5];\n+/// let s2: Vec<isize> = s.to_vec();\n /// ```\n declare_clippy_lint! {\n     pub ITER_CLONED_COLLECT,\n@@ -676,12 +681,12 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let x: &[i32] = &[1,2,3,4,5];\n+/// let x: &[i32] = &[1, 2, 3, 4, 5];\n /// do_stuff(x.as_ref());\n /// ```\n /// The correct use would be:\n /// ```rust\n-/// let x: &[i32] = &[1,2,3,4,5];\n+/// let x: &[i32] = &[1, 2, 3, 4, 5];\n /// do_stuff(x);\n /// ```\n declare_clippy_lint! {\n@@ -690,7 +695,6 @@ declare_clippy_lint! {\n     \"using `as_ref` where the types before and after the call are the same\"\n }\n \n-\n /// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n /// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n /// `sum` or `product`.\n@@ -714,7 +718,6 @@ declare_clippy_lint! {\n     \"using `fold` when a more succinct alternative exists\"\n }\n \n-\n /// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n /// More specifically it checks if the closure provided is only performing one of the\n /// filter or map operations and suggests the appropriate option.\n@@ -870,12 +873,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             [\"as_mut\", ..] => lint_asref(cx, expr, \"as_mut\", arg_lists[0]),\n             [\"fold\", ..] => lint_unnecessary_fold(cx, expr, arg_lists[0]),\n             [\"filter_map\", ..] => unnecessary_filter_map::lint(cx, expr, arg_lists[0]),\n-            _ => {}\n+            _ => {},\n         }\n \n         match expr.node {\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n-\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n@@ -886,9 +888,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 match self_ty.sty {\n-                    ty::Ref(_, ty, _) if ty.sty == ty::Str => for &(method, pos) in &PATTERN_METHODS {\n-                        if method_call.ident.name == method && args.len() > pos {\n-                            lint_single_char_pattern(cx, expr, &args[pos]);\n+                    ty::Ref(_, ty, _) if ty.sty == ty::Str => {\n+                        for &(method, pos) in &PATTERN_METHODS {\n+                            if method_call.ident.name == method && args.len() > pos {\n+                                lint_single_char_pattern(cx, expr, &args[pos]);\n+                            }\n                         }\n                     },\n                     ty::Ref(..) if method_call.ident.name == \"into_iter\" => {\n@@ -897,15 +901,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     _ => (),\n                 }\n             },\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs)\n+                if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne =>\n+            {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n                     other: rhs,\n                     eq: op.node == hir::BinOpKind::Eq,\n                 };\n                 lint_binary_expr_with_method_call(cx, &mut info);\n-            },\n+            }\n             _ => (),\n         }\n     }\n@@ -963,7 +969,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                                           .join(\" or \")));\n                         }\n \n-                        // Only check the first convention to match (CONVENTIONS should be listed from most to least specific)\n+                        // Only check the first convention to match (CONVENTIONS should be listed from most to least\n+                        // specific)\n                         break;\n                     }\n                 }\n@@ -975,12 +982,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n             // walk the return type and check for Self (this does not check associated types)\n             for inner_type in ret_ty.walk() {\n-                if same_tys(cx, ty, inner_type) { return; }\n+                if same_tys(cx, ty, inner_type) {\n+                    return;\n+                }\n             }\n \n             // if return type is impl trait, check the associated types\n             if let TyKind::Opaque(def_id, _) = ret_ty.sty {\n-\n                 // one of the associated types must be Self\n                 for predicate in &cx.tcx.predicates_of(def_id).predicates {\n                     match predicate {\n@@ -990,18 +998,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             let associated_type_is_self_type = same_tys(cx, ty, associated_type);\n \n                             // if the associated type is self, early return and do not trigger lint\n-                            if associated_type_is_self_type { return; }\n+                            if associated_type_is_self_type {\n+                                return;\n+                            }\n                         },\n                         (_, _) => {},\n                     }\n                 }\n             }\n \n             if name == \"new\" && !same_tys(cx, ret_ty, ty) {\n-                span_lint(cx,\n-                          NEW_RET_NO_SELF,\n-                          implitem.span,\n-                          \"methods called `new` usually return `Self`\");\n+                span_lint(\n+                    cx,\n+                    NEW_RET_NO_SELF,\n+                    implitem.span,\n+                    \"methods called `new` usually return `Self`\",\n+                );\n             }\n         }\n     }\n@@ -1043,7 +1055,10 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n                             span,\n                             &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n                             \"try this\",\n-                            format!(\"{}.unwrap_or_default()\", snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)),\n+                            format!(\n+                                \"{}.unwrap_or_default()\",\n+                                snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)\n+                            ),\n                             applicability,\n                         );\n                         return true;\n@@ -1123,12 +1138,28 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n             hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n-                    check_general_case(cx, name, method_span, fun.span, &args[0], &args[1], or_has_args, expr.span);\n+                    check_general_case(\n+                        cx,\n+                        name,\n+                        method_span,\n+                        fun.span,\n+                        &args[0],\n+                        &args[1],\n+                        or_has_args,\n+                        expr.span,\n+                    );\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, span, ref or_args) => {\n-                check_general_case(cx, name, method_span, span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n-            },\n+            hir::ExprKind::MethodCall(_, span, ref or_args) => check_general_case(\n+                cx,\n+                name,\n+                method_span,\n+                span,\n+                &args[0],\n+                &args[1],\n+                !or_args.is_empty(),\n+                expr.span,\n+            ),\n             _ => {},\n         }\n     }\n@@ -1137,12 +1168,13 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n-        let arg  = match &arg.node {\n-            hir::ExprKind::AddrOf(_, expr)=> expr,\n+        let arg = match &arg.node {\n+            hir::ExprKind::AddrOf(_, expr) => expr,\n             hir::ExprKind::MethodCall(method_name, _, args)\n-                if method_name.ident.name == \"as_str\" ||\n-                   method_name.ident.name == \"as_ref\"\n-                => &args[0],\n+                if method_name.ident.name == \"as_str\" || method_name.ident.name == \"as_ref\" =>\n+            {\n+                &args[0]\n+            },\n             _ => arg,\n         };\n \n@@ -1165,7 +1197,8 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n             if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n                 if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n-                    return snippet_with_applicability(cx, format_arg_expr_tup[0].span, \"..\", applicability).into_owned();\n+                    return snippet_with_applicability(cx, format_arg_expr_tup[0].span, \"..\", applicability)\n+                        .into_owned();\n                 }\n             }\n         };\n@@ -1212,7 +1245,11 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n             return;\n         }\n \n-        let closure = if match_type(cx, self_type, &paths::OPTION) { \"||\" } else { \"|_|\" };\n+        let closure = if match_type(cx, self_type, &paths::OPTION) {\n+            \"||\"\n+        } else {\n+            \"|_|\"\n+        };\n         let span_replace_word = method_span.with_hi(span.hi());\n \n         if let Some(format_args) = extract_format_args(arg) {\n@@ -1272,28 +1309,30 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n                 expr.span,\n                 \"using `clone` on a double-reference; \\\n                  this will copy the reference instead of cloning the inner type\",\n-                |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                    let mut ty = innermost;\n-                    let mut n = 0;\n-                    while let ty::Ref(_, inner, _) = ty.sty {\n-                        ty = inner;\n-                        n += 1;\n+                |db| {\n+                    if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                        let mut ty = innermost;\n+                        let mut n = 0;\n+                        while let ty::Ref(_, inner, _) = ty.sty {\n+                            ty = inner;\n+                            n += 1;\n+                        }\n+                        let refs: String = iter::repeat('&').take(n + 1).collect();\n+                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let explicit = format!(\"{}{}::clone({})\", refs, ty, snip);\n+                        db.span_suggestion_with_applicability(\n+                            expr.span,\n+                            \"try dereferencing it\",\n+                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        db.span_suggestion_with_applicability(\n+                            expr.span,\n+                            \"or try being explicit about what type to clone\",\n+                            explicit,\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n-                    let refs: String = iter::repeat('&').take(n + 1).collect();\n-                    let derefs: String = iter::repeat('*').take(n).collect();\n-                    let explicit = format!(\"{}{}::clone({})\", refs, ty, snip);\n-                    db.span_suggestion_with_applicability(\n-                        expr.span,\n-                        \"try dereferencing it\",\n-                        format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    db.span_suggestion_with_applicability(\n-                        expr.span,\n-                        \"or try being explicit about what type to clone\",\n-                        explicit,\n-                        Applicability::MaybeIncorrect,\n-                    );\n                 },\n             );\n             return; // don't report clone_on_copy\n@@ -1312,7 +1351,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n                         // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n                         hir::ExprKind::MethodCall(..) => return,\n                         _ => {},\n-                    }\n+                    },\n                     hir::Node::Stmt(stmt) => {\n                         if let hir::StmtKind::Decl(ref decl, _) = stmt.node {\n                             if let hir::DeclKind::Local(ref loc) = decl.node {\n@@ -1334,12 +1373,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n         }\n         span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |db| {\n             if let Some((text, snip)) = snip {\n-                db.span_suggestion_with_applicability(\n-                    expr.span,\n-                    text,\n-                    snip,\n-                    Applicability::Unspecified,\n-                );\n+                db.span_suggestion_with_applicability(expr.span, text, snip, Applicability::Unspecified);\n             }\n         });\n     }\n@@ -1365,13 +1399,17 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n             expr.span,\n             \"using '.clone()' on a ref-counted pointer\",\n             \"try this\",\n-            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet(cx, arg.span, \"_\")),\n+            format!(\n+                \"{}::<{}>::clone(&{})\",\n+                caller_type,\n+                subst.type_at(0),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n             Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n         );\n     }\n }\n \n-\n fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n@@ -1451,8 +1489,8 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n         fold_args: &[hir::Expr],\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n-        replacement_has_args: bool) {\n-\n+        replacement_has_args: bool,\n+    ) {\n         if_chain! {\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n@@ -1509,29 +1547,21 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n         return;\n     }\n \n-    assert!(fold_args.len() == 3,\n-        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n+    assert!(\n+        fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n+    );\n \n     // Check if the first argument to .fold is a suitable literal\n     match fold_args[1].node {\n-        hir::ExprKind::Lit(ref lit) => {\n-            match lit.node {\n-                ast::LitKind::Bool(false) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOpKind::Or, \"any\", true\n-                ),\n-                ast::LitKind::Bool(true) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOpKind::And, \"all\", true\n-                ),\n-                ast::LitKind::Int(0, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOpKind::Add, \"sum\", false\n-                ),\n-                ast::LitKind::Int(1, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOpKind::Mul, \"product\", false\n-                ),\n-                _ => return\n-            }\n-        }\n-        _ => return\n+        hir::ExprKind::Lit(ref lit) => match lit.node {\n+            ast::LitKind::Bool(false) => check_fold_with_op(cx, fold_args, hir::BinOpKind::Or, \"any\", true),\n+            ast::LitKind::Bool(true) => check_fold_with_op(cx, fold_args, hir::BinOpKind::And, \"all\", true),\n+            ast::LitKind::Int(0, _) => check_fold_with_op(cx, fold_args, hir::BinOpKind::Add, \"sum\", false),\n+            ast::LitKind::Int(1, _) => check_fold_with_op(cx, fold_args, hir::BinOpKind::Mul, \"product\", false),\n+            _ => return,\n+        },\n+        _ => return,\n     };\n }\n \n@@ -1553,8 +1583,7 @@ fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::E\n         expr.span,\n         &format!(\n             \"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n-            mut_str,\n-            caller_type\n+            mut_str, caller_type\n         ),\n     );\n }\n@@ -1590,15 +1619,20 @@ fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::\n     };\n \n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let borrow_str = if !needs_ref { \"\" } else if is_mut { \"&mut \" } else { \"&\" };\n+    let borrow_str = if !needs_ref {\n+        \"\"\n+    } else if is_mut {\n+        \"&mut \"\n+    } else {\n+        \"&\"\n+    };\n     span_lint_and_sugg(\n         cx,\n         GET_UNWRAP,\n         expr.span,\n         &format!(\n             \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-            mut_str,\n-            caller_type\n+            mut_str, caller_type\n         ),\n         \"try this\",\n         format!(\n@@ -1645,10 +1679,12 @@ fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Op\n         match ty.sty {\n             ty::Slice(_) => sugg::Sugg::hir_opt(cx, expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::Ref(_, inner, _) => if may_slice(cx, inner) {\n-                sugg::Sugg::hir_opt(cx, expr)\n-            } else {\n-                None\n+            ty::Ref(_, inner, _) => {\n+                if may_slice(cx, inner) {\n+                    sugg::Sugg::hir_opt(cx, expr)\n+                } else {\n+                    None\n+                }\n             },\n             _ => None,\n         }\n@@ -1676,8 +1712,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::E\n                 \"used unwrap() on {} value. If you don't want to handle the {} case gracefully, consider \\\n                  using expect() to provide a better panic \\\n                  message\",\n-                kind,\n-                none_value\n+                kind, none_value\n             ),\n         );\n     }\n@@ -1711,11 +1746,7 @@ fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hi\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" {\n-            \"None\"\n-        } else {\n-            \"a\"\n-        };\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n         let suggest = if unwrap_snippet == \"None\" {\n             \"and_then(f)\"\n         } else {\n@@ -1724,8 +1755,7 @@ fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hi\n         let msg = &format!(\n             \"called `map(f).unwrap_or({})` on an Option value. \\\n              This can be done more directly by calling `{}` instead\",\n-            arg,\n-            suggest\n+            arg, suggest\n         );\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or() have the same span\n@@ -1739,9 +1769,7 @@ fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hi\n             };\n             let note = format!(\n                 \"replace `map({}).unwrap_or({})` with `{}`\",\n-                map_snippet,\n-                unwrap_snippet,\n-                suggest\n+                map_snippet, unwrap_snippet, suggest\n             );\n             span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n         } else if same_span && multiline {\n@@ -1751,11 +1779,7 @@ fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hi\n }\n \n /// lint use of `map().flatten()` for `Iterators`\n-fn lint_map_flatten<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    map_args: &'tcx [hir::Expr],\n-) {\n+fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n@@ -1971,7 +1995,10 @@ fn lint_search_is_some<'a, 'tcx>(\n                 expr.span,\n                 &msg,\n                 expr.span,\n-                &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method, search_snippet),\n+                &format!(\n+                    \"replace `{0}({1}).is_some()` with `any({1})`\",\n+                    search_method, search_snippet\n+                ),\n             );\n         } else {\n             span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);\n@@ -1998,7 +2025,7 @@ fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut Binary\n                     return;\n                 }\n             }\n-        }\n+        };\n     }\n \n     lint_with_both_lhs_and_rhs!(lint_chars_next_cmp, cx, info);\n@@ -2163,7 +2190,10 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: ty::Ty<'_>) -> Option<(&'static Lint, &'static str, &'static str)> {\n+fn ty_has_iter_method(\n+    cx: &LateContext<'_, '_>,\n+    self_ref_ty: ty::Ty<'_>,\n+) -> Option<(&'static Lint, &'static str, &'static str)> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method.\n@@ -2201,7 +2231,7 @@ fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: ty::Ty<'_>) -> Opti\n \n     for (lint, path) in &INTO_ITER_COLLECTIONS {\n         if match_def_path(cx.tcx, def_id, path) {\n-            return Some((lint, path.last().unwrap(), method_name))\n+            return Some((lint, path.last().unwrap(), method_name));\n         }\n     }\n     None\n@@ -2218,8 +2248,7 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::T\n             method_span,\n             &format!(\n                 \"this .into_iter() call is equivalent to .{}() and will not move the {}\",\n-                method_name,\n-                kind,\n+                method_name, kind,\n             ),\n             \"call directly\",\n             method_name.to_string(),\n@@ -2228,7 +2257,6 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::T\n     }\n }\n \n-\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::Adt(_, substs) = ty.sty {\n@@ -2321,7 +2349,6 @@ const PATTERN_METHODS: [(&str, usize); 17] = [\n     (\"trim_right_matches\", 1),\n ];\n \n-\n #[derive(Clone, Copy, PartialEq, Debug)]\n enum SelfKind {\n     Value,\n@@ -2397,31 +2424,36 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.params.iter().any(|param| match param.kind {\n             hir::GenericParamKind::Type { .. } => {\n-                param.name.ident().name == seg.ident.name && param.bounds.iter().any(|bound| {\n-                    if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n-                        let path = &ptr.trait_ref.path;\n-                        match_path(path, name) && path.segments.last().map_or(false, |s| {\n-                            if let Some(ref params) = s.args {\n-                                if params.parenthesized {\n-                                    false\n-                                } else {\n-                                    // FIXME(flip1995): messy, improve if there is a better option\n-                                    // in the compiler\n-                                    let types: Vec<_> = params.args.iter().filter_map(|arg| match arg {\n-                                        hir::GenericArg::Type(ty) => Some(ty),\n-                                        _ => None,\n-                                    }).collect();\n-                                    types.len() == 1\n-                                        && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n-                                }\n-                            } else {\n-                                false\n-                            }\n-                        })\n-                    } else {\n-                        false\n-                    }\n-                })\n+                param.name.ident().name == seg.ident.name\n+                    && param.bounds.iter().any(|bound| {\n+                        if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n+                            let path = &ptr.trait_ref.path;\n+                            match_path(path, name)\n+                                && path.segments.last().map_or(false, |s| {\n+                                    if let Some(ref params) = s.args {\n+                                        if params.parenthesized {\n+                                            false\n+                                        } else {\n+                                            // FIXME(flip1995): messy, improve if there is a better option\n+                                            // in the compiler\n+                                            let types: Vec<_> = params\n+                                                .args\n+                                                .iter()\n+                                                .filter_map(|arg| match arg {\n+                                                    hir::GenericArg::Type(ty) => Some(ty),\n+                                                    _ => None,\n+                                                })\n+                                                .collect();\n+                                            types.len() == 1 && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n+                                        }\n+                                    } else {\n+                                        false\n+                                    }\n+                                })\n+                        } else {\n+                            false\n+                        }\n+                    })\n             },\n             _ => false,\n         })"}, {"sha": "f8988935788355ff9a6817f6ce3a301ae3174579", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};"}, {"sha": "bddad90d1ef1ba56a95950df1d0c4e77273c7978", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n use std::cmp::Ordering;\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are"}, {"sha": "7220f1726bf7e73c13abf9c460e779f2c5694c03", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,23 +7,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::consts::{constant, Constant};\n use crate::reexport::*;\n-use matches::matches;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::ast::LitKind;\n use crate::syntax::source_map::{ExpnFormat, Span};\n-use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n-            iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n-            span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n-use crate::syntax::ast::LitKind;\n-use crate::consts::{constant, Constant};\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{\n+    get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal, iter_input_pats,\n+    last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n+    SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use matches::matches;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as\n /// `ref`.\n@@ -43,7 +44,9 @@ use crate::rustc_errors::Applicability;\n ///\n /// **Example:**\n /// ```rust\n-/// fn foo(ref x: u8) -> bool { .. }\n+/// fn foo(ref x: u8) -> bool {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub TOPLEVEL_REF_ARG,\n@@ -139,7 +142,7 @@ declare_clippy_lint! {\n /// ```rust\n /// match v {\n ///     Some(x) => (),\n-///     y @ _   => (), // easier written as `y`,\n+///     y @ _ => (), // easier written as `y`,\n /// }\n /// ```\n declare_clippy_lint! {\n@@ -182,7 +185,7 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// f() && g();  // We should write `if f() { g(); }`.\n+/// f() && g(); // We should write `if f() { g(); }`.\n /// ```\n declare_clippy_lint! {\n     pub SHORT_CIRCUIT_STATEMENT,\n@@ -266,8 +269,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         for arg in iter_input_pats(decl, body) {\n             match arg.pat.node {\n-                PatKind::Binding(BindingAnnotation::Ref, _, _, _) |\n-                PatKind::Binding(BindingAnnotation::RefMut, _, _, _) => {\n+                PatKind::Binding(BindingAnnotation::Ref, _, _, _)\n+                | PatKind::Binding(BindingAnnotation::RefMut, _, _, _) => {\n                     span_lint(\n                         cx,\n                         TOPLEVEL_REF_ARG,\n@@ -372,7 +375,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                     if let Some(name) = get_item_name(cx, expr) {\n                         let name = name.as_str();\n-                        if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\")\n+                        if name == \"eq\"\n+                            || name == \"ne\"\n+                            || name == \"is_nan\"\n+                            || name.starts_with(\"eq_\")\n                             || name.ends_with(\"_eq\")\n                         {\n                             return;\n@@ -451,7 +457,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     cx,\n                     REDUNDANT_PATTERN,\n                     pat.span,\n-                    &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.name, ident.name),\n+                    &format!(\n+                        \"the `{} @ _` pattern can be written as just `{}`\",\n+                        ident.name, ident.name\n+                    ),\n                 );\n             }\n         }\n@@ -467,7 +476,7 @@ fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n                     CMP_NAN,\n                     expr.span,\n                     \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n-                    );\n+                );\n             }\n         }\n     }\n@@ -477,7 +486,7 @@ fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) ->\n     if let Some((_, res)) = constant(cx, cx.tables, expr) {\n         res\n     } else {\n-       false\n+        false\n     }\n }\n \n@@ -502,14 +511,16 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n                 return;\n             }\n         },\n-        ExprKind::Call(ref path, ref v) if v.len() == 1 => if let ExprKind::Path(ref path) = path.node {\n-            if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+        ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n+            if let ExprKind::Path(ref path) = path.node {\n+                if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n+                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                } else {\n+                    return;\n+                }\n             } else {\n                 return;\n             }\n-        } else {\n-            return;\n         },\n         _ => return,\n     };\n@@ -520,18 +531,15 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n         None => return,\n     };\n \n-    let deref_arg_impl_partial_eq_other = arg_ty\n-        .builtin_deref(true)\n-        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty.into()]));\n-    let arg_impl_partial_eq_deref_other = other_ty\n-        .builtin_deref(true)\n-        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty.into()]));\n+    let deref_arg_impl_partial_eq_other = arg_ty.builtin_deref(true).map_or(false, |tam| {\n+        implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty.into()])\n+    });\n+    let arg_impl_partial_eq_deref_other = other_ty.builtin_deref(true).map_or(false, |tam| {\n+        implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty.into()])\n+    });\n     let arg_impl_partial_eq_other = implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty.into()]);\n \n-    if !deref_arg_impl_partial_eq_other\n-        && !arg_impl_partial_eq_deref_other\n-        && !arg_impl_partial_eq_other\n-    {\n+    if !deref_arg_impl_partial_eq_other && !arg_impl_partial_eq_deref_other && !arg_impl_partial_eq_other {\n         return;\n     }\n "}, {"sha": "53da89dfcb0bd7d73b9a6a38b98addab704e9e91", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, LintContext, in_external_macro};\n+use crate::rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashMap;\n-use if_chain::if_chain;\n-use std::char;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n use crate::syntax::source_map::Span;\n-use crate::syntax::visit::{FnKind, Visitor, walk_expr};\n+use crate::syntax::visit::{walk_expr, FnKind, Visitor};\n use crate::utils::{constants, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n-use crate::rustc_errors::Applicability;\n+use if_chain::if_chain;\n+use std::char;\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -206,9 +205,7 @@ struct ReturnVisitor {\n \n impl ReturnVisitor {\n     fn new() -> Self {\n-        Self {\n-            found_return: false,\n-        }\n+        Self { found_return: false }\n     }\n }\n \n@@ -244,7 +241,8 @@ impl EarlyLintPass for MiscEarly {\n     fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat, _: &mut bool) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n-            let type_name = npat.segments\n+            let type_name = npat\n+                .segments\n                 .last()\n                 .expect(\"A path must have at least one segment\")\n                 .ident\n@@ -271,8 +269,10 @@ impl EarlyLintPass for MiscEarly {\n                 for field in pfields {\n                     match field.node.pat.node {\n                         PatKind::Wild => {},\n-                        _ => if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n-                            normal.push(n);\n+                        _ => {\n+                            if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n+                                normal.push(n);\n+                            }\n                         },\n                     }\n                 }\n@@ -334,36 +334,42 @@ impl EarlyLintPass for MiscEarly {\n             return;\n         }\n         match expr.node {\n-            ExprKind::Call(ref paren, _) => if let ExprKind::Paren(ref closure) = paren.node {\n-                if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.node {\n-                    let mut visitor = ReturnVisitor::new();\n-                    visitor.visit_expr(block);\n-                    if !visitor.found_return {\n-                        span_lint_and_then(\n-                            cx,\n-                            REDUNDANT_CLOSURE_CALL,\n-                            expr.span,\n-                            \"Try not to call a closure in the expression where it is declared.\",\n-                            |db| if decl.inputs.is_empty() {\n-                                let hint = snippet(cx, block.span, \"..\").into_owned();\n-                                db.span_suggestion_with_applicability(\n-                                    expr.span,\n-                                    \"Try doing something like: \",\n-                                    hint,\n-                                    Applicability::MachineApplicable, // snippet\n-                                );\n-                            },\n-                        );\n+            ExprKind::Call(ref paren, _) => {\n+                if let ExprKind::Paren(ref closure) = paren.node {\n+                    if let ExprKind::Closure(_, _, _, ref decl, ref block, _) = closure.node {\n+                        let mut visitor = ReturnVisitor::new();\n+                        visitor.visit_expr(block);\n+                        if !visitor.found_return {\n+                            span_lint_and_then(\n+                                cx,\n+                                REDUNDANT_CLOSURE_CALL,\n+                                expr.span,\n+                                \"Try not to call a closure in the expression where it is declared.\",\n+                                |db| {\n+                                    if decl.inputs.is_empty() {\n+                                        let hint = snippet(cx, block.span, \"..\").into_owned();\n+                                        db.span_suggestion_with_applicability(\n+                                            expr.span,\n+                                            \"Try doing something like: \",\n+                                            hint,\n+                                            Applicability::MachineApplicable, // snippet\n+                                        );\n+                                    }\n+                                },\n+                            );\n+                        }\n                     }\n                 }\n             },\n-            ExprKind::Unary(UnOp::Neg, ref inner) => if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n-                span_lint(\n-                    cx,\n-                    DOUBLE_NEG,\n-                    expr.span,\n-                    \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n-                );\n+            ExprKind::Unary(UnOp::Neg, ref inner) => {\n+                if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n+                    span_lint(\n+                        cx,\n+                        DOUBLE_NEG,\n+                        expr.span,\n+                        \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                    );\n+                }\n             },\n             ExprKind::Lit(ref lit) => self.check_lit(cx, lit),\n             _ => (),"}, {"sha": "8eb64f7ca3784e5276ad0d82ecc5645d9711bbcc", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // This file incorporates work covered by the following copyright and\n // permission notice:\n //   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n@@ -29,13 +28,13 @@\n //\n \n use crate::rustc::hir;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast;\n use crate::syntax::attr;\n use crate::syntax::source_map::Span;\n-use crate::utils::{span_lint, in_macro};\n+use crate::utils::{in_macro, span_lint};\n \n /// **What it does:** Warns if there is missing doc for any documentable item\n /// (public or private).\n@@ -72,12 +71,16 @@ impl MissingDoc {\n     }\n \n     fn doc_hidden(&self) -> bool {\n-        *self.doc_hidden_stack\n-            .last()\n-            .expect(\"empty doc_hidden_stack\")\n+        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(\n+        &self,\n+        cx: &LateContext<'_, '_>,\n+        attrs: &[ast::Attribute],\n+        sp: Span,\n+        desc: &'static str,\n+    ) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -93,9 +96,7 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs\n-            .iter()\n-            .any(|a| a.is_value_str() && a.name() == \"doc\");\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n             span_lint(\n                 cx,\n@@ -115,12 +116,14 @@ impl LintPass for MissingDoc {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n-                None => false,\n-                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n-            }\n-        });\n+        let doc_hidden = self.doc_hidden()\n+            || attrs.iter().any(|attr| {\n+                attr.check_name(\"doc\")\n+                    && match attr.meta_item_list() {\n+                        None => false,\n+                        Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n+                    }\n+            });\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n@@ -156,10 +159,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Ty(..) => \"a type alias\",\n             hir::ItemKind::Union(..) => \"a union\",\n             hir::ItemKind::Existential(..) => \"an existential type\",\n-            hir::ItemKind::ExternCrate(..) |\n-            hir::ItemKind::ForeignMod(..) |\n-            hir::ItemKind::Impl(..) |\n-            hir::ItemKind::Use(..) => return,\n+            hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::Impl(..)\n+            | hir::ItemKind::Use(..) => return,\n         };\n \n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n@@ -180,8 +183,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n-            ty::ImplContainer(cid) => if cx.tcx.impl_trait_ref(cid).is_some() {\n-                return;\n+            ty::ImplContainer(cid) => {\n+                if cx.tcx.impl_trait_ref(cid).is_some() {\n+                    return;\n+                }\n             },\n         }\n "}, {"sha": "99477821cfa2f61d96cb9ed0ea3ddc78778945a1", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n //   file at the top-level directory of this distribution and at\n //   http://rust-lang.org/COPYRIGHT.\n@@ -33,9 +32,9 @@ use crate::utils::span_lint;\n /// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n /// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n /// might intend for most of the methods in their public API to be able to be inlined across\n-/// crates even when LTO is disabled. For these types of crates, enabling this lint might make sense.\n-/// It allows the crate to require all exported methods to be `#[inline]` by default, and then opt\n-/// out for specific methods where this might not make sense.\n+/// crates even when LTO is disabled. For these types of crates, enabling this lint might make\n+/// sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n+/// then opt out for specific methods where this might not make sense.\n ///\n /// **Known problems:** None.\n ///\n@@ -79,11 +78,8 @@ declare_clippy_lint! {\n \n pub struct MissingInline;\n \n-fn check_missing_inline_attrs(cx: &LateContext<'_, '_>,\n-                              attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs\n-        .iter()\n-        .any(|a| a.name() == \"inline\" );\n+fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    let has_inline = attrs.iter().any(|a| a.name() == \"inline\");\n     if !has_inline {\n         span_lint(\n             cx,\n@@ -97,11 +93,9 @@ fn check_missing_inline_attrs(cx: &LateContext<'_, '_>,\n fn is_executable<'a, 'tcx>(cx: &LateContext<'a, 'tcx>) -> bool {\n     use crate::rustc::session::config::CrateType;\n \n-    cx.tcx.sess.crate_types.get().iter().any(|t: &CrateType| {\n-        match t {\n-            CrateType::Executable => true,\n-            _ => false,\n-        }\n+    cx.tcx.sess.crate_types.get().iter().any(|t: &CrateType| match t {\n+        CrateType::Executable => true,\n+        _ => false,\n     })\n }\n \n@@ -125,47 +119,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                 let desc = \"a function\";\n                 check_missing_inline_attrs(cx, &it.attrs, it.span, desc);\n             },\n-            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics,\n-                           ref _bounds, ref trait_items)  => {\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, ref _bounds, ref trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {\n                     let tit_ = cx.tcx.hir.trait_item(tit.id);\n                     match tit_.node {\n-                        hir::TraitItemKind::Const(..) |\n-                        hir::TraitItemKind::Type(..) => {},\n+                        hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => {},\n                         hir::TraitItemKind::Method(..) => {\n                             if tit.defaultness.has_value() {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n                                 let item = cx.tcx.hir.expect_trait_item(tit.id.node_id);\n-                                check_missing_inline_attrs(cx, &item.attrs,\n-                                                                item.span, desc);\n+                                check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },\n                     }\n                 }\n-            }\n-            hir::ItemKind::Const(..) |\n-            hir::ItemKind::Enum(..) |\n-            hir::ItemKind::Mod(..) |\n-            hir::ItemKind::Static(..) |\n-            hir::ItemKind::Struct(..) |\n-            hir::ItemKind::TraitAlias(..) |\n-            hir::ItemKind::GlobalAsm(..) |\n-            hir::ItemKind::Ty(..) |\n-            hir::ItemKind::Union(..) |\n-            hir::ItemKind::Existential(..) |\n-            hir::ItemKind::ExternCrate(..) |\n-            hir::ItemKind::ForeignMod(..) |\n-            hir::ItemKind::Impl(..) |\n-            hir::ItemKind::Use(..) => {},\n+            },\n+            hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::TraitAlias(..)\n+            | hir::ItemKind::GlobalAsm(..)\n+            | hir::ItemKind::Ty(..)\n+            | hir::ItemKind::Union(..)\n+            | hir::ItemKind::Existential(..)\n+            | hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::Impl(..)\n+            | hir::ItemKind::Use(..) => {},\n         };\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n-        use crate::rustc::ty::{TraitContainer, ImplContainer};\n+        use crate::rustc::ty::{ImplContainer, TraitContainer};\n         if is_executable(cx) {\n             return;\n         }\n@@ -177,9 +168,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n \n         let desc = match impl_item.node {\n             hir::ImplItemKind::Method(..) => \"a method\",\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Type(_) |\n-            hir::ImplItemKind::Existential(_) => return,\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) | hir::ImplItemKind::Existential(_) => return,\n         };\n \n         let def_id = cx.tcx.hir.local_def_id(impl_item.id);"}, {"sha": "6c58f93f0d8e89379dec133efc618a58eddfe364", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::hir::intravisit;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::utils::{higher, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n@@ -81,12 +80,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(\n-                _,\n-                _,\n-                hir::MutMutable,\n-            ) = self.cx.tables.expr_ty(e).sty\n-            {\n+            } else if let ty::Ref(_, _, hir::MutMutable) = self.cx.tables.expr_ty(e).sty {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n@@ -109,8 +103,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             if let hir::TyKind::Rptr(\n                 _,\n                 hir::MutTy {\n-                    mutbl: hir::MutMutable,\n-                    ..\n+                    mutbl: hir::MutMutable, ..\n                 },\n             ) = pty.node\n             {"}, {"sha": "6729b2030a778cd196f221851b6074163c22fbcd", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::ty::{self, Ty};\n use crate::rustc::ty::subst::Subst;\n-use crate::rustc::hir::*;\n+use crate::rustc::ty::{self, Ty};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::utils::span_lint;\n \n /// **What it does:** Detects giving a mutable reference to a function that only\n@@ -28,13 +27,12 @@ use crate::utils::span_lint;\n /// my_vec.push(&mut value)\n /// ```\n declare_clippy_lint! {\n-    pub UNNECESSARY_MUT_PASSED,\n-    style,\n-    \"an argument passed as a mutable reference although the callee only demands an \\\n-     immutable reference\"\n+pub UNNECESSARY_MUT_PASSED,\n+style,\n+\"an argument passed as a mutable reference although the callee only demands an \\\n+ immutable reference\"\n }\n \n-\n #[derive(Copy, Clone)]\n pub struct UnnecessaryMutPassed;\n \n@@ -47,13 +45,15 @@ impl LintPass for UnnecessaryMutPassed {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         match e.node {\n-            ExprKind::Call(ref fn_expr, ref arguments) => if let ExprKind::Path(ref path) = fn_expr.node {\n-                check_arguments(\n-                    cx,\n-                    arguments,\n-                    cx.tables.expr_ty(fn_expr),\n-                    &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n-                );\n+            ExprKind::Call(ref fn_expr, ref arguments) => {\n+                if let ExprKind::Path(ref path) = fn_expr.node {\n+                    check_arguments(\n+                        cx,\n+                        arguments,\n+                        cx.tables.expr_ty(fn_expr),\n+                        &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n+                    );\n+                }\n             },\n             ExprKind::MethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n@@ -72,21 +72,18 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    ty::Ref(\n-                        _,\n-                        _,\n-                        MutImmutable,\n-                    ) |\n-                    ty::RawPtr(ty::TypeAndMut {\n-                        mutbl: MutImmutable,\n-                        ..\n-                    }) => if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n-                        span_lint(\n-                            cx,\n-                            UNNECESSARY_MUT_PASSED,\n-                            argument.span,\n-                            &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n-                        );\n+                    ty::Ref(_, _, MutImmutable)\n+                    | ty::RawPtr(ty::TypeAndMut {\n+                        mutbl: MutImmutable, ..\n+                    }) => {\n+                        if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n+                            span_lint(\n+                                cx,\n+                                UNNECESSARY_MUT_PASSED,\n+                                argument.span,\n+                                &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n+                            );\n+                        }\n                     },\n                     _ => (),\n                 }"}, {"sha": "34683934eca408a64bc7bbd103142cb84761ef2b", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for uses of mutex where an atomic value could be used\n //!\n //! This lint is **warn** by default\n \n+use crate::rustc::hir::Expr;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty::{self, Ty};\n-use crate::rustc::hir::Expr;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast;\n use crate::utils::{match_type, paths, span_lint};\n "}, {"sha": "fec8e2490da2add2a858c133a88b8630466ae1a0", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for needless boolean results of if-else expressions\n //!\n //! This lint is **warn** by default\n@@ -34,13 +33,17 @@ use crate::utils::{in_macro, snippet_with_applicability, span_lint, span_lint_an\n ///\n /// **Example:**\n /// ```rust\n-/// if x { false } else { true }\n+/// if x {\n+///     false\n+/// } else {\n+///     true\n+/// }\n /// ```\n declare_clippy_lint! {\n-    pub NEEDLESS_BOOL,\n-    complexity,\n-    \"if-statements with plain booleans in the then- and else-clause, e.g. \\\n-     `if p { true } else { false }`\"\n+pub NEEDLESS_BOOL,\n+complexity,\n+\"if-statements with plain booleans in the then- and else-clause, e.g. \\\n+ `if p { true } else { false }`\"\n }\n \n /// **What it does:** Checks for expressions of the form `x == true` (or vice\n@@ -52,7 +55,7 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// if x == true { }  // could be `if x { }`\n+/// if x == true {} // could be `if x { }`\n /// ```\n declare_clippy_lint! {\n     pub BOOL_COMPARISON,\n@@ -142,7 +145,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Eq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Eq, ..\n+            },\n+            ref left_side,\n+            ref right_side,\n+        ) = e.node\n+        {\n             let mut applicability = Applicability::MachineApplicable;\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n@@ -208,14 +218,16 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => if let StmtKind::Semi(ref e, _) = e.node {\n-            if let ExprKind::Ret(_) = e.node {\n-                fetch_bool_expr(&**e)\n+        (&[ref e], None) => {\n+            if let StmtKind::Semi(ref e, _) = e.node {\n+                if let ExprKind::Ret(_) = e.node {\n+                    fetch_bool_expr(&**e)\n+                } else {\n+                    Expression::Other\n+                }\n             } else {\n                 Expression::Other\n             }\n-        } else {\n-            Expression::Other\n         },\n         _ => Expression::Other,\n     }\n@@ -224,10 +236,12 @@ fn fetch_bool_block(block: &Block) -> Expression {\n fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n         ExprKind::Block(ref block, _) => fetch_bool_block(block),\n-        ExprKind::Lit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n-            Expression::Bool(value)\n-        } else {\n-            Expression::Other\n+        ExprKind::Lit(ref lit_ptr) => {\n+            if let LitKind::Bool(value) = lit_ptr.node {\n+                Expression::Bool(value)\n+            } else {\n+                Expression::Other\n+            }\n         },\n         ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),"}, {"sha": "dbee58c6a3ed068a1a3760e5cdaaf3b88e809c5b", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for needless address of operations (`&`)\n //!\n //! This lint is **warn** by default\n@@ -18,8 +17,8 @@ use crate::rustc::ty;\n use crate::rustc::ty::adjustment::{Adjust, Adjustment};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n-use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n use crate::syntax::ast::NodeId;\n+use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -60,11 +59,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             if let ty::Ref(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n-                        kind: Adjust::Deref(_),\n-                        ..\n+                        kind: Adjust::Deref(_), ..\n                     }, Adjustment {\n-                        kind: Adjust::Deref(_),\n-                        ..\n+                        kind: Adjust::Deref(_), ..\n                     }, Adjustment {\n                         kind: Adjust::Borrow(_),\n                         .."}, {"sha": "9b70d4b2e64d139d48103ccb0cf94c0a7f1c9a6f", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for useless borrowed references.\n //!\n //! This lint is **warn** by default\n \n+use crate::rustc::hir::{BindingAnnotation, MutImmutable, Pat, PatKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::{BindingAnnotation, MutImmutable, Pat, PatKind};\n-use crate::utils::{in_macro, snippet, span_lint_and_then};\n use crate::rustc_errors::Applicability;\n+use crate::utils::{in_macro, snippet, span_lint_and_then};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for useless borrowed references.\n ///\n@@ -48,8 +47,8 @@ use crate::rustc_errors::Applicability;\n ///\n /// **Example:**\n /// ```rust\n-///     let mut v = Vec::<String>::new();\n-///     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n+/// let mut v = Vec::<String>::new();\n+/// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n /// ```\n /// This closure takes a reference on something that has been matched as a\n /// reference and\n@@ -89,7 +88,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n                                    |db| {\n                                        let hint = snippet(cx, spanned_name.span, \"..\").into_owned();\n                                        db.span_suggestion_with_applicability(\n-                                           pat.span, \n+                                           pat.span,\n                                            \"try removing the `&ref` part and just keep\",\n                                            hint,\n                                            Applicability::MachineApplicable, // snippet"}, {"sha": "2f1b92544b40944517017359417b98f52e9a2f13", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for continue statements in loops that are redundant.\n //!\n //! For example, the lint would catch\n@@ -181,7 +180,6 @@ impl EarlyLintPass for NeedlessContinue {\n /// - The expression is a `continue` node.\n /// - The expression node is a block with the first statement being a\n /// `continue`.\n-///\n fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n     match else_expr.node {\n         ast::ExprKind::Block(ref else_block, _) => is_first_block_stmt_continue(else_block),\n@@ -192,10 +190,12 @@ fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n \n fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n     block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n-        ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => if let ast::ExprKind::Continue(_) = e.node {\n-            true\n-        } else {\n-            false\n+        ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => {\n+            if let ast::ExprKind::Continue(_) = e.node {\n+                true\n+            } else {\n+                false\n+            }\n         },\n         _ => false,\n     })\n@@ -208,10 +208,10 @@ where\n     F: FnMut(&ast::Block),\n {\n     match expr.node {\n-        ast::ExprKind::While(_, ref loop_block, _) |\n-        ast::ExprKind::WhileLet(_, _, ref loop_block, _) |\n-        ast::ExprKind::ForLoop(_, _, ref loop_block, _) |\n-        ast::ExprKind::Loop(ref loop_block, _) => func(loop_block),\n+        ast::ExprKind::While(_, ref loop_block, _)\n+        | ast::ExprKind::WhileLet(_, _, ref loop_block, _)\n+        | ast::ExprKind::ForLoop(_, _, ref loop_block, _)\n+        | ast::ExprKind::Loop(ref loop_block, _) => func(loop_block),\n         _ => {},\n     }\n }\n@@ -224,7 +224,6 @@ where\n /// - The `if` condition expression,\n /// - The `then` block, and\n /// - The `else` expression.\n-///\n fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n where\n     F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr),\n@@ -274,7 +273,6 @@ const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"Consider dropping the else clause a\n const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the else clause, and moving out the code in the else \\\n                                    block, like so:\\n\";\n \n-\n fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n@@ -294,7 +292,11 @@ fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(\n+    ctx: &EarlyContext<'_>,\n+    data: &'a LintData<'_>,\n+    header: &str,\n+) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n     let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n@@ -311,7 +313,11 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &\n     ret\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_else<'a>(\n+    ctx: &EarlyContext<'_>,\n+    data: &'a LintData<'_>,\n+    header: &str,\n+) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n     let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n@@ -355,7 +361,12 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n                     block_stmts: &loop_block.stmts,\n                 };\n                 if needless_continue_in_else(else_expr) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n+                    emit_warning(\n+                        ctx,\n+                        data,\n+                        DROP_ELSE_BLOCK_AND_MERGE_MSG,\n+                        LintType::ContinueInsideElseBlock,\n+                    );\n                 } else if is_first_block_stmt_continue(then_block) {\n                     emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n                 }\n@@ -369,9 +380,9 @@ fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n /// e.g., the string\n ///\n /// ```\n-///     {\n-///         let x = 5;\n-///     }\n+/// {\n+///     let x = 5;\n+/// }\n /// ```\n ///\n /// is transformed to\n@@ -413,7 +424,6 @@ pub fn erode_from_back(s: &str) -> String {\n ///             inside_a_block();\n ///         }\n /// ```\n-///\n pub fn erode_from_front(s: &str) -> String {\n     s.chars()\n         .skip_while(|c| c.is_whitespace())"}, {"sha": "251c3d73959c1a548fd71146aec6e378bb861431", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,27 +7,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use matches::matches;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::ty::{self, RegionKind, TypeFoldable};\n-use crate::rustc::traits;\n use crate::rustc::middle::expr_use_visitor as euv;\n use crate::rustc::middle::mem_categorization as mc;\n-use crate::rustc_target::spec::abi::Abi;\n+use crate::rustc::traits;\n+use crate::rustc::ty::{self, RegionKind, TypeFoldable};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::rustc_errors::Applicability;\n+use crate::rustc_target::spec::abi::Abi;\n use crate::syntax::ast::NodeId;\n-use crate::syntax_pos::Span;\n use crate::syntax::errors::DiagnosticBuilder;\n-use crate::utils::{get_trait_def_id, implements_trait, in_macro, is_copy, is_self, match_type, multispan_sugg, paths,\n-            snippet, snippet_opt, span_lint_and_then};\n+use crate::syntax_pos::Span;\n use crate::utils::ptr::get_spans;\n+use crate::utils::{\n+    get_trait_def_id, implements_trait, in_macro, is_copy, is_self, match_type, multispan_sugg, paths, snippet,\n+    snippet_opt, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use matches::matches;\n use std::borrow::Cow;\n-use crate::rustc_errors::Applicability;\n \n /// **What it does:** Checks for functions taking arguments by value, but not\n /// consuming them in its\n@@ -67,7 +68,13 @@ impl LintPass for NeedlessPassByValue {\n }\n \n macro_rules! need {\n-    ($e: expr) => { if let Some(x) = $e { x } else { return; } };\n+    ($e: expr) => {\n+        if let Some(x) = $e {\n+            x\n+        } else {\n+            return;\n+        }\n+    };\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n@@ -114,7 +121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             need!(cx.tcx.lang_items().fn_trait()),\n             need!(cx.tcx.lang_items().fn_once_trait()),\n             need!(cx.tcx.lang_items().fn_mut_trait()),\n-            need!(get_trait_def_id(cx, &paths::RANGE_ARGUMENT_TRAIT))\n+            need!(get_trait_def_id(cx, &paths::RANGE_ARGUMENT_TRAIT)),\n         ];\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n@@ -125,7 +132,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             .filter(|p| !p.is_global())\n             .filter_map(|pred| {\n                 if let ty::Predicate::Trait(poly_trait_ref) = pred {\n-                    if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars() {\n+                    if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars()\n+                    {\n                         return None;\n                     }\n                     Some(poly_trait_ref)\n@@ -152,12 +160,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n-        for (idx, ((input, &ty), arg)) in decl.inputs\n-            .iter()\n-            .zip(fn_sig.inputs())\n-            .zip(&body.arguments)\n-            .enumerate()\n-        {\n+        for (idx, ((input, &ty), arg)) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments).enumerate() {\n             // All spans generated from a proc-macro invocation are the same...\n             if span == input.span {\n                 return;\n@@ -172,9 +175,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 }\n             }\n \n+            //\n             // * Exclude a type that is specifically bounded by `Borrow`.\n-            // * Exclude a type whose reference also fulfills its bound.\n-            //   (e.g. `std::convert::AsRef`, `serde::Serialize`)\n+            // * Exclude a type whose reference also fulfills its bound. (e.g. `std::convert::AsRef`,\n+            //   `serde::Serialize`)\n             let (implements_borrow_trait, all_borrowable_trait) = {\n                 let preds = preds\n                     .iter()\n@@ -183,17 +187,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n                 (\n                     preds.iter().any(|t| t.def_id() == borrow_trait),\n-                    !preds.is_empty() && preds.iter().all(|t| {\n-                        let ty_params = &t.skip_binder().trait_ref.substs.iter().skip(1)\n-                            .cloned()\n-                            .collect::<Vec<_>>();\n-                        implements_trait(\n-                            cx,\n-                            cx.tcx.mk_imm_ref(&RegionKind::ReErased, ty),\n-                            t.def_id(),\n-                            ty_params\n-                        )\n-                    }),\n+                    !preds.is_empty()\n+                        && preds.iter().all(|t| {\n+                            let ty_params = &t\n+                                .skip_binder()\n+                                .trait_ref\n+                                .substs\n+                                .iter()\n+                                .skip(1)\n+                                .cloned()\n+                                .collect::<Vec<_>>();\n+                            implements_trait(cx, cx.tcx.mk_imm_ref(&RegionKind::ReErased, ty), t.def_id(), ty_params)\n+                        }),\n                 )\n             };\n \n@@ -415,14 +420,22 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn borrow(\n+        &mut self,\n+        _: NodeId,\n+        _: Span,\n+        _: &mc::cmt_<'tcx>,\n+        _: ty::Region<'_>,\n+        _: ty::BorrowKind,\n+        _: euv::LoanCause,\n+    ) {\n+    }\n \n     fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n \n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n \n-\n fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {\n     loop {\n         match cmt.cat {\n@@ -431,5 +444,5 @@ fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt\n             },\n             _ => return (*cmt).clone(),\n         }\n-    };\n+    }\n }"}, {"sha": "a15f7924678e5859e24247858c9e143459439022", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::{Expr, ExprKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::ty;\n-use crate::rustc::hir::{Expr, ExprKind};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::utils::span_lint;\n \n /// **What it does:** Checks for needlessly including a base struct on update\n@@ -24,7 +23,11 @@ use crate::utils::span_lint;\n ///\n /// **Example:**\n /// ```rust\n-/// Point { x: 1, y: 0, ..zero_point }\n+/// Point {\n+///     x: 1,\n+///     y: 0,\n+///     ..zero_point\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub NEEDLESS_UPDATE,"}, {"sha": "dd7d1478c236f873f188f2d1240051441776819b", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,9 +7,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n \n@@ -61,7 +60,6 @@ impl LintPass for NoNegCompOpForPartialOrd {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n-\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n "}, {"sha": "0df218613460501a2de29138516f014f6b753c38", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::syntax::source_map::{Span, Spanned};\n+use if_chain::if_chain;\n \n use crate::consts::{self, Constant};\n use crate::utils::span_lint;\n@@ -45,7 +44,14 @@ impl LintPass for NegMultiply {\n #[allow(clippy::match_same_arms)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref l, ref r) = e.node {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Mul, ..\n+            },\n+            ref l,\n+            ref r,\n+        ) = e.node\n+        {\n             match (&l.node, &r.node) {\n                 (&ExprKind::Unary(..), &ExprKind::Unary(..)) => (),\n                 (&ExprKind::Unary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),"}, {"sha": "f0a7c71856dd2861351b8bf6d13dfbef72e1f095", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,19 +7,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::hir::def_id::DefId;\n use crate::rustc::hir;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::hir::def_id::DefId;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use crate::rustc::ty::{self, Ty};\n use crate::rustc::util::nodemap::NodeSet;\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::ty::{self, Ty};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::source_map::Span;\n use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_and_then};\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_and_then};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n /// implementation of\n@@ -125,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                         }\n                         if impl_item.generics.params.iter().any(|gen| match gen.kind {\n                             hir::GenericParamKind::Type { .. } => true,\n-                            _ => false\n+                            _ => false,\n                         }) {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n@@ -134,8 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                         }\n                         if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                             let self_did = cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id));\n-                            let self_ty = cx.tcx\n-                                .type_of(self_did);\n+                            let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n@@ -171,7 +169,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                             cx,\n                                             NEW_WITHOUT_DEFAULT_DERIVE,\n                                             impl_item.span,\n-                                            &format!(\"you should consider deriving a `Default` implementation for `{}`\", self_ty),\n+                                            &format!(\n+                                                \"you should consider deriving a `Default` implementation for `{}`\",\n+                                                self_ty\n+                                            ),\n                                             |db| {\n                                                 db.suggest_item_with_attr(\n                                                     cx,\n@@ -186,7 +187,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                             cx,\n                                             NEW_WITHOUT_DEFAULT,\n                                             impl_item.span,\n-                                            &format!(\"you should consider adding a `Default` implementation for `{}`\", self_ty),\n+                                            &format!(\n+                                                \"you should consider adding a `Default` implementation for `{}`\",\n+                                                self_ty\n+                                            ),\n                                             |db| {\n                                                 db.suggest_prepend_item(\n                                                     cx,"}, {"sha": "d39c13621ffce936f767572a93bd52c949b62189", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::def::Def;\n use crate::rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -63,37 +62,42 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n         ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        ExprKind::Repeat(ref inner, _) |\n-        ExprKind::Cast(ref inner, _) |\n-        ExprKind::Type(ref inner, _) |\n-        ExprKind::Unary(_, ref inner) |\n-        ExprKind::Field(ref inner, _) |\n-        ExprKind::AddrOf(_, ref inner) |\n-        ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n+        ExprKind::Repeat(ref inner, _)\n+        | ExprKind::Cast(ref inner, _)\n+        | ExprKind::Type(ref inner, _)\n+        | ExprKind::Unary(_, ref inner)\n+        | ExprKind::Field(ref inner, _)\n+        | ExprKind::AddrOf(_, ref inner)\n+        | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n         ExprKind::Struct(_, ref fields, ref base) => {\n-            !has_drop(cx, expr) && fields.iter().all(|field| has_no_effect(cx, &field.expr)) && match *base {\n-                Some(ref base) => has_no_effect(cx, base),\n-                None => true,\n-            }\n-        },\n-        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n-            let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-            match def {\n-                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n-                    !has_drop(cx, expr) && args.iter().all(|arg| has_no_effect(cx, arg))\n-                },\n-                _ => false,\n-            }\n-        } else {\n-            false\n+            !has_drop(cx, expr)\n+                && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n+                && match *base {\n+                    Some(ref base) => has_no_effect(cx, base),\n+                    None => true,\n+                }\n         },\n-        ExprKind::Block(ref block, _) => {\n-            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n-                has_no_effect(cx, expr)\n+        ExprKind::Call(ref callee, ref args) => {\n+            if let ExprKind::Path(ref qpath) = callee.node {\n+                let def = cx.tables.qpath_def(qpath, callee.hir_id);\n+                match def {\n+                    Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n+                        !has_drop(cx, expr) && args.iter().all(|arg| has_no_effect(cx, arg))\n+                    },\n+                    _ => false,\n+                }\n             } else {\n                 false\n             }\n         },\n+        ExprKind::Block(ref block, _) => {\n+            block.stmts.is_empty()\n+                && if let Some(ref expr) = block.expr {\n+                    has_no_effect(cx, expr)\n+                } else {\n+                    false\n+                }\n+        },\n         _ => false,\n     }\n }\n@@ -139,7 +143,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-\n fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n     if in_macro(expr.span) {\n         return None;\n@@ -150,37 +153,34 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec\n             Some(vec![&**a, &**b])\n         },\n         ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n-        ExprKind::Repeat(ref inner, _) |\n-        ExprKind::Cast(ref inner, _) |\n-        ExprKind::Type(ref inner, _) |\n-        ExprKind::Unary(_, ref inner) |\n-        ExprKind::Field(ref inner, _) |\n-        ExprKind::AddrOf(_, ref inner) |\n-        ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        ExprKind::Struct(_, ref fields, ref base) => if has_drop(cx, expr) {\n-            None\n-        } else {\n-            Some(\n-                fields\n-                    .iter()\n-                    .map(|f| &f.expr)\n-                    .chain(base)\n-                    .map(Deref::deref)\n-                    .collect(),\n-            )\n+        ExprKind::Repeat(ref inner, _)\n+        | ExprKind::Cast(ref inner, _)\n+        | ExprKind::Type(ref inner, _)\n+        | ExprKind::Unary(_, ref inner)\n+        | ExprKind::Field(ref inner, _)\n+        | ExprKind::AddrOf(_, ref inner)\n+        | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, ref fields, ref base) => {\n+            if has_drop(cx, expr) {\n+                None\n+            } else {\n+                Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n+            }\n         },\n-        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n-            let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-            match def {\n-                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n-                    if !has_drop(cx, expr) =>\n-                {\n-                    Some(args.iter().collect())\n-                },\n-                _ => None,\n+        ExprKind::Call(ref callee, ref args) => {\n+            if let ExprKind::Path(ref qpath) = callee.node {\n+                let def = cx.tables.qpath_def(qpath, callee.hir_id);\n+                match def {\n+                    Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n+                        if !has_drop(cx, expr) =>\n+                    {\n+                        Some(args.iter().collect())\n+                    },\n+                    _ => None,\n+                }\n+            } else {\n+                None\n             }\n-        } else {\n-            None\n         },\n         ExprKind::Block(ref block, _) => {\n             if block.stmts.is_empty() {"}, {"sha": "bb44bd6bd06f764215ea007c4148824d579cbae7", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,22 +7,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for uses of const which the type is not Freeze (Cell-free).\n //!\n //! This lint is **deny** by default.\n \n-use crate::rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::rustc::hir::def::Def;\n-use crate::rustc::ty::{self, TypeFlags};\n+use crate::rustc::hir::*;\n+use crate::rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use crate::rustc::ty::adjustment::Adjust;\n+use crate::rustc::ty::{self, TypeFlags};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::rustc_typeck::hir_ty_to_ty;\n-use crate::syntax_pos::{DUMMY_SP, Span};\n-use std::ptr;\n+use crate::syntax_pos::{Span, DUMMY_SP};\n use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+use std::ptr;\n \n /// **What it does:** Checks for declaration of `const` items which is interior\n /// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n@@ -42,11 +41,11 @@ use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n ///\n /// **Example:**\n /// ```rust\n-/// use std::sync::atomic::{Ordering::SeqCst, AtomicUsize};\n+/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n ///\n /// // Bad.\n /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-/// CONST_ATOM.store(6, SeqCst);             // the content of the atomic is unchanged\n+/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n ///\n /// // Good.\n@@ -74,11 +73,11 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// use std::sync::atomic::{Ordering::SeqCst, AtomicUsize};\n+/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n ///\n /// // Bad.\n-/// CONST_ATOM.store(6, SeqCst);             // the content of the atomic is unchanged\n+/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n ///\n /// // Good.\n@@ -94,16 +93,9 @@ declare_clippy_lint! {\n \n #[derive(Copy, Clone)]\n enum Source {\n-    Item {\n-        item: Span,\n-    },\n-    Assoc {\n-        item: Span,\n-        ty: Span,\n-    },\n-    Expr {\n-        expr: Span,\n-    },\n+    Item { item: Span },\n+    Assoc { item: Span, ty: Span },\n+    Expr { expr: Span },\n }\n \n impl Source {\n@@ -123,11 +115,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    ty: ty::Ty<'tcx>,\n-    source: Source,\n-) {\n+fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n         // an UnsafeCell is !Copy, and an UnsafeCell is also the only type which\n         // is !Freeze, thus if our type is Copy we can be sure it must be Freeze\n@@ -149,22 +137,19 @@ fn verify_ty_bound<'a, 'tcx>(\n                     \"static\".to_string(),\n                     Applicability::MachineApplicable,\n                 );\n-            }\n+            },\n             Source::Assoc { ty: ty_span, .. } => {\n                 if ty.flags.contains(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n                     db.span_help(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n                 }\n-            }\n+            },\n             Source::Expr { .. } => {\n-                db.help(\n-                    \"assign this const to a local or static variable, and use the variable here\",\n-                );\n-            }\n+                db.help(\"assign this const to a local or static variable, and use the variable here\");\n+            },\n         }\n     });\n }\n \n-\n pub struct NonCopyConst;\n \n impl LintPass for NonCopyConst {\n@@ -184,7 +169,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx TraitItem) {\n         if let TraitItemKind::Const(hir_ty, ..) = &trait_item.node {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: trait_item.span });\n+            verify_ty_bound(\n+                cx,\n+                ty,\n+                Source::Assoc {\n+                    ty: hir_ty.span,\n+                    item: trait_item.span,\n+                },\n+            );\n         }\n     }\n \n@@ -195,7 +187,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             // ensure the impl is an inherent impl.\n             if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: impl_item.span });\n+                verify_ty_bound(\n+                    cx,\n+                    ty,\n+                    Source::Assoc {\n+                        ty: hir_ty.span,\n+                        item: impl_item.span,\n+                    },\n+                );\n             }\n         }\n     }\n@@ -227,25 +226,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                         ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced\n                             needs_check_adjustment = false;\n-                        }\n+                        },\n                         ExprKind::Field(..) => {\n                             dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n-                        }\n+                        },\n                         ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now.\n                             needs_check_adjustment = false;\n                             break;\n-                        }\n+                        },\n                         ExprKind::Unary(UnDeref, _) => {\n                             // `*e` => desugared to `*Deref::deref(&e)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now.\n                             needs_check_adjustment = false;\n                             break;\n-                        }\n+                        },\n                         _ => break,\n                     }\n                     cur_expr = parent_expr;"}, {"sha": "ad8006e92563fedfc96ad557364d933aa8445853", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{LintArray, LintPass, EarlyContext, EarlyLintPass};\n+use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::syntax::source_map::Span;\n-use crate::syntax::symbol::LocalInternedString;\n use crate::syntax::ast::*;\n use crate::syntax::attr;\n+use crate::syntax::source_map::Span;\n+use crate::syntax::symbol::LocalInternedString;\n use crate::syntax::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use crate::utils::{span_lint, span_lint_and_then};\n \n@@ -116,9 +115,11 @@ impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.node {\n             PatKind::Ident(_, ident, _) => self.check_name(ident.span, ident.name),\n-            PatKind::Struct(_, ref fields, _) => for field in fields {\n-                if !field.node.is_shorthand {\n-                    self.visit_pat(&field.node.pat);\n+            PatKind::Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    if !field.node.is_shorthand {\n+                        self.visit_pat(&field.node.pat);\n+                    }\n                 }\n             },\n             _ => walk_pat(self, pat),\n@@ -155,7 +156,10 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                 self.0.cx,\n                 MANY_SINGLE_CHAR_NAMES,\n                 span,\n-                &format!(\"{}th binding whose name is just one char\", self.0.single_char_names.len()),\n+                &format!(\n+                    \"{}th binding whose name is just one char\",\n+                    self.0.single_char_names.len()\n+                ),\n             );\n         }\n     }\n@@ -197,26 +201,19 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             } else {\n                 let mut interned_chars = interned_name.chars();\n                 let mut existing_chars = existing_name.interned.chars();\n-                let first_i = interned_chars\n-                    .next()\n-                    .expect(\"we know we have at least one char\");\n-                let first_e = existing_chars\n-                    .next()\n-                    .expect(\"we know we have at least one char\");\n+                let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n+                let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n                 let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n \n                 if eq_or_numeric((first_i, first_e)) {\n-                    let last_i = interned_chars\n-                        .next_back()\n-                        .expect(\"we know we have at least two chars\");\n-                    let last_e = existing_chars\n-                        .next_back()\n-                        .expect(\"we know we have at least two chars\");\n+                    let last_i = interned_chars.next_back().expect(\"we know we have at least two chars\");\n+                    let last_e = existing_chars.next_back().expect(\"we know we have at least two chars\");\n                     if eq_or_numeric((last_i, last_e)) {\n                         if interned_chars\n                             .zip(existing_chars)\n                             .filter(|&ie| !eq_or_numeric(ie))\n-                            .count() != 1\n+                            .count()\n+                            != 1\n                         {\n                             continue;\n                         }\n@@ -227,7 +224,8 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         let second_last_e = existing_chars\n                             .next_back()\n                             .expect(\"we know we have at least three chars\");\n-                        if !eq_or_numeric((second_last_i, second_last_e)) || second_last_i == '_'\n+                        if !eq_or_numeric((second_last_i, second_last_e))\n+                            || second_last_i == '_'\n                             || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                         {\n                             // allowed similarity foo_x, foo_y\n@@ -237,13 +235,10 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n                     }\n                 } else {\n-                    let second_i = interned_chars\n-                        .next()\n-                        .expect(\"we know we have at least two chars\");\n-                    let second_e = existing_chars\n-                        .next()\n-                        .expect(\"we know we have at least two chars\");\n-                    if !eq_or_numeric((second_i, second_e)) || second_i == '_'\n+                    let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n+                    let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n+                    if !eq_or_numeric((second_i, second_e))\n+                        || second_i == '_'\n                         || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                     {\n                         // allowed similarity x_foo, y_foo"}, {"sha": "9f6b62656650dca00966eee2e128368333fe1d73", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n use crate::utils::{match_type, method_chain_args, paths, snippet, span_help_and_lint};\n+use if_chain::if_chain;\n \n /// **What it does:*** Checks for unnecessary `ok()` in if let.\n ///"}, {"sha": "e78299bd3afecd9ffeed169bfb193a037652db1d", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::{Expr, ExprKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -200,7 +199,12 @@ fn check_open_options(cx: &LateContext<'_, '_>, options: &[(OpenOption, Argument\n     }\n \n     if read && truncate && read_arg && truncate_arg && !(write && write_arg) {\n-        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"file opened with \\\"truncate\\\" and \\\"read\\\"\");\n+        span_lint(\n+            cx,\n+            NONSENSICAL_OPEN_OPTIONS,\n+            span,\n+            \"file opened with \\\"truncate\\\" and \\\"read\\\"\",\n+        );\n     }\n     if append && truncate && append_arg && truncate_arg {\n         span_lint("}, {"sha": "7942e61c9f431ec7efd08bdf39570ddd041285e9", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n use crate::utils::{span_lint, SpanlessEq};\n+use if_chain::if_chain;\n \n /// **What it does:** Detects classic underflow/overflow checks.\n ///"}, {"sha": "39b85b12a847628924a9d9fa41f21840a5b42a08", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::syntax::ast::LitKind;\n-use crate::syntax::ptr::P;\n use crate::syntax::ext::quote::rt::Span;\n+use crate::syntax::ptr::P;\n use crate::utils::{is_direct_expn_of, is_expn_of, match_def_path, opt_def_id, paths, resolve_node, span_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///"}, {"sha": "70c93c5978b62178bacaa08bcf5f15437045c0ac", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n use crate::utils::{is_automatically_derived, span_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n ///"}, {"sha": "4f71f36528c7a42ada9e6d948fffde797e59550b", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n@@ -115,7 +114,10 @@ impl EarlyLintPass for Precedence {\n                                     expr.span,\n                                     \"unary minus has lower precedence than method call\",\n                                     \"consider adding parentheses to clarify your intent\",\n-                                    format!(\"-({})\", snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)),\n+                                    format!(\n+                                        \"-({})\",\n+                                        snippet_with_applicability(cx, rhs.span, \"..\", &mut applicability)\n+                                    ),\n                                     applicability,\n                                 );\n                             },"}, {"sha": "139b87dffe7c0ad69ddc4b6bf30a49d1541aa4e2", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,22 +7,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n-use std::borrow::Cow;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::QPath;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::NodeId;\n use crate::syntax::source_map::Span;\n use crate::syntax_pos::MultiSpan;\n-use crate::utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then, walk_ptrs_hir_ty};\n use crate::utils::ptr::get_spans;\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then, walk_ptrs_hir_ty};\n+use if_chain::if_chain;\n+use std::borrow::Cow;\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n /// or `&Vec` unless the references are mutable. It will also suggest you\n@@ -55,10 +54,10 @@ use crate::rustc_errors::Applicability;\n /// fn foo(&Vec<u32>) { .. }\n /// ```\n declare_clippy_lint! {\n-    pub PTR_ARG,\n-    style,\n-    \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` \\\n-     instead, respectively\"\n+pub PTR_ARG,\n+style,\n+\"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` \\\n+ instead, respectively\"\n }\n \n /// **What it does:** This lint checks for equality comparisons with `ptr::null`\n@@ -71,7 +70,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// if x == ptr::null { .. }\n+/// if x == ptr::null {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub CMP_NULL,\n@@ -162,12 +163,7 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n     let fn_ty = sig.skip_binder();\n \n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n-        if let ty::Ref(\n-            _,\n-            ty,\n-            MutImmutable\n-        ) = ty.sty\n-        {\n+        if let ty::Ref(_, ty, MutImmutable) = ty.sty {\n             if match_type(cx, ty, &paths::VEC) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n@@ -193,19 +189,18 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n                         |db| {\n                             if let Some(ref snippet) = ty_snippet {\n                                 db.span_suggestion_with_applicability(\n-                                            arg.span,\n-                                            \"change this to\",\n-                                            format!(\"&[{}]\", snippet),\n-                                            Applicability::Unspecified,\n-                                            );\n+                                    arg.span,\n+                                    \"change this to\",\n+                                    format!(\"&[{}]\", snippet),\n+                                    Applicability::Unspecified,\n+                                );\n                             }\n                             for (clonespan, suggestion) in spans {\n                                 db.span_suggestion_with_applicability(\n                                     clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\n-                                        \"change the call to\".into(),\n-                                        |x| Cow::Owned(format!(\"change `{}` to\", x)),\n-                                    ),\n+                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n+                                        Cow::Owned(format!(\"change `{}` to\", x))\n+                                    }),\n                                     suggestion.into(),\n                                     Applicability::Unspecified,\n                                 );\n@@ -230,10 +225,9 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n                             for (clonespan, suggestion) in spans {\n                                 db.span_suggestion_short_with_applicability(\n                                     clonespan,\n-                                    &snippet_opt(cx, clonespan).map_or(\n-                                        \"change the call to\".into(),\n-                                        |x| Cow::Owned(format!(\"change `{}` to\", x)),\n-                                    ),\n+                                    &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(), |x| {\n+                                        Cow::Owned(format!(\"change `{}` to\", x))\n+                                    }),\n                                     suggestion.into(),\n                                     Applicability::Unspecified,\n                                 );\n@@ -280,7 +274,8 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n     if let FunctionRetTy::Return(ref ty) = decl.output {\n         if let Some((out, MutMutable, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n-            for (_, ref mutbl, ref argspan) in decl.inputs\n+            for (_, ref mutbl, ref argspan) in decl\n+                .inputs\n                 .iter()\n                 .filter_map(|ty| get_rptr_lm(ty))\n                 .filter(|&(lt, _, _)| lt.name == out.name)\n@@ -293,10 +288,16 @@ fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id:\n             if immutables.is_empty() {\n                 return;\n             }\n-            span_lint_and_then(cx, MUT_FROM_REF, ty.span, \"mutable borrow from immutable input(s)\", |db| {\n-                let ms = MultiSpan::from_spans(immutables);\n-                db.span_note(ms, \"immutable borrow here\");\n-            });\n+            span_lint_and_then(\n+                cx,\n+                MUT_FROM_REF,\n+                ty.span,\n+                \"mutable borrow from immutable input(s)\",\n+                |db| {\n+                    let ms = MultiSpan::from_spans(immutables);\n+                    db.span_note(ms, \"immutable borrow here\");\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "5d2714651ed8eb4f19bd29774307316812e9a1b4", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::{declare_tool_lint, hir, lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::utils;\n@@ -27,7 +26,9 @@ use std::fmt;\n /// let ptr = vec.as_ptr();\n /// let offset = 1_usize;\n ///\n-/// unsafe { ptr.offset(offset as isize); }\n+/// unsafe {\n+///     ptr.offset(offset as isize);\n+/// }\n /// ```\n ///\n /// Could be written:\n@@ -37,7 +38,9 @@ use std::fmt;\n /// let ptr = vec.as_ptr();\n /// let offset = 1_usize;\n ///\n-/// unsafe { ptr.add(offset); }\n+/// unsafe {\n+///     ptr.add(offset);\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub PTR_OFFSET_WITH_CAST,\n@@ -82,7 +85,6 @@ impl<'a, 'tcx> lint::LateLintPass<'a, 'tcx> for Pass {\n         } else {\n             utils::span_lint(cx, PTR_OFFSET_WITH_CAST, expr.span, &msg);\n         }\n-\n     }\n }\n \n@@ -119,18 +121,12 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n }\n \n // Is the type of the expression a usize?\n-fn is_expr_ty_usize<'a, 'tcx>(\n-    cx: &lint::LateContext<'a, 'tcx>,\n-    expr: &hir::Expr,\n-) -> bool {\n+fn is_expr_ty_usize<'a, 'tcx>(cx: &lint::LateContext<'a, 'tcx>, expr: &hir::Expr) -> bool {\n     cx.tables.expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n-fn is_expr_ty_raw_ptr<'a, 'tcx>(\n-    cx: &lint::LateContext<'a, 'tcx>,\n-    expr: &hir::Expr,\n-) -> bool {\n+fn is_expr_ty_raw_ptr<'a, 'tcx>(cx: &lint::LateContext<'a, 'tcx>, expr: &hir::Expr) -> bool {\n     cx.tables.expr_ty(expr).is_unsafe_ptr()\n }\n "}, {"sha": "3a62a3a1526fcb302f24247a671e4c17ce449afb", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,18 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n-use crate::rustc::hir::def::Def;\n-use crate::utils::sugg::Sugg;\n use crate::syntax::ptr::P;\n+use crate::utils::sugg::Sugg;\n+use if_chain::if_chain;\n \n-use crate::utils::{match_def_path, match_type, span_lint_and_then};\n-use crate::utils::paths::*;\n use crate::rustc_errors::Applicability;\n+use crate::utils::paths::*;\n+use crate::utils::{match_def_path, match_type, span_lint_and_then};\n \n /// **What it does:** Checks for expressions that could be replaced by the question mark operator\n ///\n@@ -38,7 +37,7 @@ use crate::rustc_errors::Applicability;\n /// ```rust\n /// option?;\n /// ```\n-declare_clippy_lint!{\n+declare_clippy_lint! {\n     pub QUESTION_MARK,\n     style,\n     \"checks for expressions that could be replaced by the question mark operator\"\n@@ -108,17 +107,15 @@ impl Pass {\n \n                 false\n             },\n-            ExprKind::Ret(Some(ref expr)) => {\n-                Self::expression_returns_none(cx, expr)\n-            },\n+            ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Def::VariantCtor(def_id, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n-                    return match_def_path(cx.tcx, def_id,  &OPTION_NONE);\n+                    return match_def_path(cx.tcx, def_id, &OPTION_NONE);\n                 }\n \n                 false\n             },\n-            _ => false\n+            _ => false,\n         }\n     }\n "}, {"sha": "d84943f1ddcec1e1d7a34fb6e8fde671865960c9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::RangeLimits;\n use crate::syntax::source_map::Spanned;\n-use crate::utils::{is_integer_literal, paths, snippet, span_lint, span_lint_and_then, snippet_opt};\n-use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n use crate::utils::sugg::Sugg;\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n+use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n /// which never terminates.\n@@ -29,7 +28,9 @@ use crate::rustc_errors::Applicability;\n ///\n /// **Example:**\n /// ```rust\n-/// for x in (5..5).step_by(0) { .. }\n+/// for x in (5..5).step_by(0) {\n+///     ..\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub ITERATOR_STEP_BY_ZERO,\n@@ -98,7 +99,12 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ITERATOR_STEP_BY_ZERO, RANGE_ZIP_WITH_LEN, RANGE_PLUS_ONE, RANGE_MINUS_ONE)\n+        lint_array!(\n+            ITERATOR_STEP_BY_ZERO,\n+            RANGE_ZIP_WITH_LEN,\n+            RANGE_PLUS_ONE,\n+            RANGE_MINUS_ONE\n+        )\n     }\n }\n \n@@ -148,7 +154,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // exclusive range plus one: x..(y+1)\n         if_chain! {\n-            if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::HalfOpen }) = higher::range(cx, expr);\n+            if let Some(higher::Range {\n+                start,\n+                end: Some(end),\n+                limits: RangeLimits::HalfOpen\n+            }) = higher::range(cx, expr);\n             if let Some(y) = y_plus_one(end);\n             then {\n                 span_lint_and_then(\n@@ -217,20 +227,34 @@ fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n \n fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n-            Some(rhs)\n-        } else if is_integer_literal(rhs, 1) {\n-            Some(lhs)\n-        } else {\n-            None\n+        ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Add, ..\n+            },\n+            ref lhs,\n+            ref rhs,\n+        ) => {\n+            if is_integer_literal(lhs, 1) {\n+                Some(rhs)\n+            } else if is_integer_literal(rhs, 1) {\n+                Some(lhs)\n+            } else {\n+                None\n+            }\n         },\n         _ => None,\n     }\n }\n \n fn y_minus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n+        ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Sub, ..\n+            },\n+            ref lhs,\n+            ref rhs,\n+        ) if is_integer_literal(rhs, 1) => Some(lhs),\n         _ => None,\n     }\n }"}, {"sha": "77f8d7578d84709fbee78c7edb1937acb94777d8", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -279,7 +279,9 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n \n     fn visit_local(&mut self, local: &mir::Local, ctx: PlaceContext<'tcx>, _: mir::Location) {\n         match ctx {\n-            PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(NonUseContext::StorageDead) => return,\n+            PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(NonUseContext::StorageDead) => {\n+                return\n+            },\n             _ => {},\n         }\n "}, {"sha": "308f0066b69f1f3387b5170404b134035cf3af56", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,12 +7,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n use crate::syntax::ast::*;\n-use crate::utils::{span_lint_and_sugg};\n+use crate::utils::span_lint_and_sugg;\n \n /// **What it does:** Checks for fields in struct literals where shorthands\n /// could be used."}, {"sha": "4de98eb55254f2a1db21b20c3d9c778f00faf6ab", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n-use crate::syntax::ptr::P;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::LitKind;\n+use crate::syntax::ptr::P;\n use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n-use crate::rustc_errors::Applicability;\n \n /// **What it does:** Lint for redundant pattern matching over `Result` or\n /// `Option`\n@@ -46,7 +45,6 @@ use crate::rustc_errors::Applicability;\n /// if Some(42).is_some() {}\n /// Ok::<i32, i32>(42).is_ok();\n /// ```\n-///\n declare_clippy_lint! {\n     pub REDUNDANT_PATTERN_MATCHING,\n     style,\n@@ -74,12 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn find_sugg_for_if_let<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    op: &P<Expr>,\n-    arms: &HirVec<Arm>\n-) {\n+fn find_sugg_for_if_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n     if arms[0].pats.len() == 1 {\n         let good_method = match arms[0].pats[0].node {\n             PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n@@ -123,19 +116,14 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n     }\n }\n \n-fn find_sugg_for_match<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    op: &P<Expr>,\n-    arms: &HirVec<Arm>\n-) {\n+fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pats[0].node, &arms[1].pats[0].node);\n \n         let found_good_method = match node_pair {\n             (\n                 PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, ref patterns_right, _)\n+                PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n             ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n                 if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].node, &patterns_right[0].node) {\n                     find_good_method_for_match(\n@@ -145,19 +133,16 @@ fn find_sugg_for_match<'a, 'tcx>(\n                         &paths::RESULT_OK,\n                         &paths::RESULT_ERR,\n                         \"is_ok()\",\n-                        \"is_err()\"\n+                        \"is_err()\",\n                     )\n                 } else {\n                     None\n                 }\n             },\n-            (\n-                PatKind::TupleStruct(ref path_left, ref patterns, _),\n-                PatKind::Path(ref path_right)\n-            ) | (\n-                PatKind::Path(ref path_left),\n-                PatKind::TupleStruct(ref path_right, ref patterns, _)\n-            ) if patterns.len() == 1 => {\n+            (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n+            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                if patterns.len() == 1 =>\n+            {\n                 if let PatKind::Wild = patterns[0].node {\n                     find_good_method_for_match(\n                         arms,\n@@ -166,7 +151,7 @@ fn find_sugg_for_match<'a, 'tcx>(\n                         &paths::OPTION_SOME,\n                         &paths::OPTION_NONE,\n                         \"is_some()\",\n-                        \"is_none()\"\n+                        \"is_none()\",\n                     )\n                 } else {\n                     None\n@@ -204,7 +189,7 @@ fn find_good_method_for_match<'a>(\n     expected_left: &[&str],\n     expected_right: &[&str],\n     should_be_left: &'a str,\n-    should_be_right: &'a str\n+    should_be_right: &'a str,\n ) -> Option<&'a str> {\n     let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n         (&(*arms[0].body).node, &(*arms[1].body).node)\n@@ -215,12 +200,10 @@ fn find_good_method_for_match<'a>(\n     };\n \n     match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => {\n-            match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n-                _ => None,\n-            }\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n         },\n         _ => None,\n     }"}, {"sha": "2e35719d4660fd5072714316d4a9ba9a767422a7", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;"}, {"sha": "749d6068fe18e7e6acdbfde39afbd75786b706cd", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use regex_syntax;\n+use crate::consts::{constant, Constant};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashSet;\n-use if_chain::if_chain;\n use crate::syntax::ast::{LitKind, NodeId, StrStyle};\n use crate::syntax::source_map::{BytePos, Span};\n use crate::utils::{is_expn_of, match_def_path, match_type, opt_def_id, paths, span_help_and_lint, span_lint};\n-use crate::consts::{constant, Constant};\n+use if_chain::if_chain;\n+use regex_syntax;\n use std::convert::TryFrom;\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n@@ -159,28 +158,37 @@ fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<Stri\n }\n \n fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n-    use regex_syntax::hir::HirKind::*;\n     use regex_syntax::hir::Anchor::*;\n+    use regex_syntax::hir::HirKind::*;\n \n-    let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| match *e.kind() {\n-        Literal(_) => true,\n-        _ => false,\n-    });\n+    let is_literal = |e: &[regex_syntax::hir::Hir]| {\n+        e.iter().all(|e| match *e.kind() {\n+            Literal(_) => true,\n+            _ => false,\n+        })\n+    };\n \n     match *s.kind() {\n-        Empty |\n-        Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),\n+        Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),\n         Literal(_) => Some(\"consider using `str::contains`\"),\n-        Alternation(ref exprs) => if exprs.iter().all(|e| e.kind().is_empty()) {\n-            Some(\"the regex is unlikely to be useful as it is\")\n-        } else {\n-            None\n+        Alternation(ref exprs) => {\n+            if exprs.iter().all(|e| e.kind().is_empty()) {\n+                Some(\"the regex is unlikely to be useful as it is\")\n+            } else {\n+                None\n+            }\n         },\n         Concat(ref exprs) => match (exprs[0].kind(), exprs[exprs.len() - 1].kind()) {\n-            (&Anchor(StartText), &Anchor(EndText)) if exprs[1..(exprs.len() - 1)].is_empty() => Some(\"consider using `str::is_empty`\"),\n-            (&Anchor(StartText), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => Some(\"consider using `==` on `str`s\"),\n+            (&Anchor(StartText), &Anchor(EndText)) if exprs[1..(exprs.len() - 1)].is_empty() => {\n+                Some(\"consider using `str::is_empty`\")\n+            },\n+            (&Anchor(StartText), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+                Some(\"consider using `==` on `str`s\")\n+            },\n             (&Anchor(StartText), &Literal(_)) if is_literal(&exprs[1..]) => Some(\"consider using `str::starts_with`\"),\n-            (&Literal(_), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => Some(\"consider using `str::ends_with`\"),\n+            (&Literal(_), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+                Some(\"consider using `str::ends_with`\")\n+            },\n             _ if is_literal(exprs) => Some(\"consider using `str::contains`\"),\n             _ => None,\n         },\n@@ -211,14 +219,10 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n             let r = &r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };\n             match parser.parse(r) {\n-                Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n-                    span_help_and_lint(\n-                        cx,\n-                        TRIVIAL_REGEX,\n-                        expr.span,\n-                        \"trivial regex\",\n-                        repl,\n-                    );\n+                Ok(r) => {\n+                    if let Some(repl) = is_trivial_regex(&r) {\n+                        span_help_and_lint(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", repl);\n+                    }\n                 },\n                 Err(regex_syntax::Error::Parse(e)) => {\n                     span_lint(\n@@ -237,25 +241,16 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n                     );\n                 },\n                 Err(e) => {\n-                    span_lint(\n-                        cx,\n-                        INVALID_REGEX,\n-                        expr.span,\n-                        &format!(\"regex syntax error: {}\", e),\n-                    );\n+                    span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {}\", e));\n                 },\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n         match parser.parse(&r) {\n-            Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n-                span_help_and_lint(\n-                    cx,\n-                    TRIVIAL_REGEX,\n-                    expr.span,\n-                    \"trivial regex\",\n-                    repl,\n-                );\n+            Ok(r) => {\n+                if let Some(repl) = is_trivial_regex(&r) {\n+                    span_help_and_lint(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", repl);\n+                }\n             },\n             Err(regex_syntax::Error::Parse(e)) => {\n                 span_lint(\n@@ -274,12 +269,7 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n                 );\n             },\n             Err(e) => {\n-                span_lint(\n-                    cx,\n-                    INVALID_REGEX,\n-                    expr.span,\n-                    &format!(\"regex syntax error: {}\", e),\n-                );\n+                span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {}\", e));\n             },\n         }\n     }"}, {"sha": "0da44bc37a10841741f70eddae7079383dc2208c", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -74,43 +73,46 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n \n const REPLACEMENTS: &[(&[&str], &str)] = &[\n     // Once\n-    (&[\"core\", \"sync\",  \"ONCE_INIT\"], \"Once::new()\"),\n+    (&[\"core\", \"sync\", \"ONCE_INIT\"], \"Once::new()\"),\n     // Atomic\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_BOOL_INIT\"],  \"AtomicBool::new(false)\"),\n+    (\n+        &[\"core\", \"sync\", \"atomic\", \"ATOMIC_BOOL_INIT\"],\n+        \"AtomicBool::new(false)\",\n+    ),\n     (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_ISIZE_INIT\"], \"AtomicIsize::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I8_INIT\"],    \"AtomicI8::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I16_INIT\"],   \"AtomicI16::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I32_INIT\"],   \"AtomicI32::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I64_INIT\"],   \"AtomicI64::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I8_INIT\"], \"AtomicI8::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I16_INIT\"], \"AtomicI16::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I32_INIT\"], \"AtomicI32::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_I64_INIT\"], \"AtomicI64::new(0)\"),\n     (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_USIZE_INIT\"], \"AtomicUsize::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U8_INIT\"],    \"AtomicU8::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U16_INIT\"],   \"AtomicU16::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U32_INIT\"],   \"AtomicU32::new(0)\"),\n-    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U64_INIT\"],   \"AtomicU64::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U8_INIT\"], \"AtomicU8::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U16_INIT\"], \"AtomicU16::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U32_INIT\"], \"AtomicU32::new(0)\"),\n+    (&[\"core\", \"sync\", \"atomic\", \"ATOMIC_U64_INIT\"], \"AtomicU64::new(0)\"),\n     // Min\n     (&[\"core\", \"isize\", \"MIN\"], \"isize::min_value()\"),\n-    (&[\"core\", \"i8\",    \"MIN\"], \"i8::min_value()\"),\n-    (&[\"core\", \"i16\",   \"MIN\"], \"i16::min_value()\"),\n-    (&[\"core\", \"i32\",   \"MIN\"], \"i32::min_value()\"),\n-    (&[\"core\", \"i64\",   \"MIN\"], \"i64::min_value()\"),\n-    (&[\"core\", \"i128\",  \"MIN\"], \"i128::min_value()\"),\n+    (&[\"core\", \"i8\", \"MIN\"], \"i8::min_value()\"),\n+    (&[\"core\", \"i16\", \"MIN\"], \"i16::min_value()\"),\n+    (&[\"core\", \"i32\", \"MIN\"], \"i32::min_value()\"),\n+    (&[\"core\", \"i64\", \"MIN\"], \"i64::min_value()\"),\n+    (&[\"core\", \"i128\", \"MIN\"], \"i128::min_value()\"),\n     (&[\"core\", \"usize\", \"MIN\"], \"usize::min_value()\"),\n-    (&[\"core\", \"u8\",    \"MIN\"], \"u8::min_value()\"),\n-    (&[\"core\", \"u16\",   \"MIN\"], \"u16::min_value()\"),\n-    (&[\"core\", \"u32\",   \"MIN\"], \"u32::min_value()\"),\n-    (&[\"core\", \"u64\",   \"MIN\"], \"u64::min_value()\"),\n-    (&[\"core\", \"u128\",  \"MIN\"], \"u128::min_value()\"),\n+    (&[\"core\", \"u8\", \"MIN\"], \"u8::min_value()\"),\n+    (&[\"core\", \"u16\", \"MIN\"], \"u16::min_value()\"),\n+    (&[\"core\", \"u32\", \"MIN\"], \"u32::min_value()\"),\n+    (&[\"core\", \"u64\", \"MIN\"], \"u64::min_value()\"),\n+    (&[\"core\", \"u128\", \"MIN\"], \"u128::min_value()\"),\n     // Max\n     (&[\"core\", \"isize\", \"MAX\"], \"isize::max_value()\"),\n-    (&[\"core\", \"i8\",    \"MAX\"], \"i8::max_value()\"),\n-    (&[\"core\", \"i16\",   \"MAX\"], \"i16::max_value()\"),\n-    (&[\"core\", \"i32\",   \"MAX\"], \"i32::max_value()\"),\n-    (&[\"core\", \"i64\",   \"MAX\"], \"i64::max_value()\"),\n-    (&[\"core\", \"i128\",  \"MAX\"], \"i128::max_value()\"),\n+    (&[\"core\", \"i8\", \"MAX\"], \"i8::max_value()\"),\n+    (&[\"core\", \"i16\", \"MAX\"], \"i16::max_value()\"),\n+    (&[\"core\", \"i32\", \"MAX\"], \"i32::max_value()\"),\n+    (&[\"core\", \"i64\", \"MAX\"], \"i64::max_value()\"),\n+    (&[\"core\", \"i128\", \"MAX\"], \"i128::max_value()\"),\n     (&[\"core\", \"usize\", \"MAX\"], \"usize::max_value()\"),\n-    (&[\"core\", \"u8\",    \"MAX\"], \"u8::max_value()\"),\n-    (&[\"core\", \"u16\",   \"MAX\"], \"u16::max_value()\"),\n-    (&[\"core\", \"u32\",   \"MAX\"], \"u32::max_value()\"),\n-    (&[\"core\", \"u64\",   \"MAX\"], \"u64::max_value()\"),\n-    (&[\"core\", \"u128\",  \"MAX\"], \"u128::max_value()\"),\n+    (&[\"core\", \"u8\", \"MAX\"], \"u8::max_value()\"),\n+    (&[\"core\", \"u16\", \"MAX\"], \"u16::max_value()\"),\n+    (&[\"core\", \"u32\", \"MAX\"], \"u32::max_value()\"),\n+    (&[\"core\", \"u64\", \"MAX\"], \"u64::max_value()\"),\n+    (&[\"core\", \"u128\", \"MAX\"], \"u128::max_value()\"),\n ];"}, {"sha": "892f9e577525b022f0b957d068bc196c8967fc1c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass, in_external_macro, LintContext};\n+use crate::rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n use crate::syntax::visit::FnKind;\n use crate::syntax_pos::BytePos;\n-use crate::rustc_errors::Applicability;\n use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for return statements at the end of a block.\n ///\n@@ -28,11 +27,15 @@ use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, sp\n ///\n /// **Example:**\n /// ```rust\n-/// fn foo(x: usize) { return x; }\n+/// fn foo(x: usize) {\n+///     return x;\n+/// }\n /// ```\n /// simplify to\n /// ```rust\n-/// fn foo(x: usize) { x }\n+/// fn foo(x: usize) {\n+///     x\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub NEEDLESS_RETURN,\n@@ -51,21 +54,21 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// fn foo() -> String {\n-///    let x = String::new();\n-///    x\n-///}\n+///     let x = String::new();\n+///     x\n+/// }\n /// ```\n /// instead, use\n /// ```\n /// fn foo() -> String {\n-///    String::new()\n-///}\n+///     String::new()\n+/// }\n /// ```\n declare_clippy_lint! {\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n-     the end of a block\"\n+pub LET_AND_RETURN,\n+style,\n+\"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n+ the end of a block\"\n }\n \n /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n@@ -79,7 +82,9 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// fn return_unit() -> () { () }\n+/// fn return_unit() -> () {\n+///     ()\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub UNUSED_UNIT,\n@@ -125,8 +130,10 @@ impl ReturnPass {\n                 self.check_final_expr(cx, elsexpr, None);\n             },\n             // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => for arm in arms {\n-                self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n+            ast::ExprKind::Match(_, ref arms) => {\n+                for arm in arms {\n+                    self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n+                }\n             },\n             _ => (),\n         }\n@@ -254,8 +261,8 @@ impl EarlyLintPass for ReturnPass {\n                         );\n                     });\n                 }\n-            }\n-            _ => ()\n+            },\n+            _ => (),\n         }\n     }\n }"}, {"sha": "a99f1398a268613db7448c2c3a02767c1fc77ae3", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::utils::{get_trait_def_id, paths, span_lint};\n \n /// **What it does:** Checks for mis-uses of the serde API.\n@@ -28,7 +27,6 @@ declare_clippy_lint! {\n     \"various things that will negatively affect your serde experience\"\n }\n \n-\n #[derive(Copy, Clone)]\n pub struct Serde;\n "}, {"sha": "caeccf0cba2ef1d2e5a688de5beb0eb0b5f33f77", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::reexport::*;\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, in_external_macro, LintContext};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::FnKind;\n+use crate::rustc::hir::*;\n+use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use crate::rustc::ty;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::source_map::Span;\n use crate::utils::{contains_name, higher, iter_input_pats, snippet, span_lint_and_then};\n \n@@ -57,10 +56,10 @@ declare_clippy_lint! {\n /// let y = x + 1;\n /// ```\n declare_clippy_lint! {\n-    pub SHADOW_REUSE,\n-    restriction,\n-    \"rebinding a name to an expression that re-uses the original value, e.g. \\\n-     `let x = x + 1`\"\n+pub SHADOW_REUSE,\n+restriction,\n+\"rebinding a name to an expression that re-uses the original value, e.g. \\\n+ `let x = x + 1`\"\n }\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n@@ -77,7 +76,8 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// let x = y; let x = z; // shadows the earlier binding\n+/// let x = y;\n+/// let x = z; // shadows the earlier binding\n /// ```\n declare_clippy_lint! {\n     pub SHADOW_UNRELATED,\n@@ -199,49 +199,52 @@ fn check_pat<'a, 'tcx>(\n                 check_pat(cx, p, init, span, bindings);\n             }\n         },\n-        PatKind::Struct(_, ref pfields, _) => if let Some(init_struct) = init {\n-            if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n-                for field in pfields {\n-                    let name = field.node.ident.name;\n-                    let efield = efields\n-                        .iter()\n-                        .find(|f| f.ident.name == name)\n-                        .map(|f| &*f.expr);\n-                    check_pat(cx, &field.node.pat, efield, span, bindings);\n+        PatKind::Struct(_, ref pfields, _) => {\n+            if let Some(init_struct) = init {\n+                if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n+                    for field in pfields {\n+                        let name = field.node.ident.name;\n+                        let efield = efields.iter().find(|f| f.ident.name == name).map(|f| &*f.expr);\n+                        check_pat(cx, &field.node.pat, efield, span, bindings);\n+                    }\n+                } else {\n+                    for field in pfields {\n+                        check_pat(cx, &field.node.pat, init, span, bindings);\n+                    }\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.node.pat, init, span, bindings);\n+                    check_pat(cx, &field.node.pat, None, span, bindings);\n                 }\n             }\n-        } else {\n-            for field in pfields {\n-                check_pat(cx, &field.node.pat, None, span, bindings);\n-            }\n         },\n-        PatKind::Tuple(ref inner, _) => if let Some(init_tup) = init {\n-            if let ExprKind::Tup(ref tup) = init_tup.node {\n-                for (i, p) in inner.iter().enumerate() {\n-                    check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n+        PatKind::Tuple(ref inner, _) => {\n+            if let Some(init_tup) = init {\n+                if let ExprKind::Tup(ref tup) = init_tup.node {\n+                    for (i, p) in inner.iter().enumerate() {\n+                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n+                    }\n+                } else {\n+                    for p in inner {\n+                        check_pat(cx, p, init, span, bindings);\n+                    }\n                 }\n             } else {\n                 for p in inner {\n-                    check_pat(cx, p, init, span, bindings);\n+                    check_pat(cx, p, None, span, bindings);\n                 }\n             }\n-        } else {\n-            for p in inner {\n-                check_pat(cx, p, None, span, bindings);\n-            }\n         },\n-        PatKind::Box(ref inner) => if let Some(initp) = init {\n-            if let ExprKind::Box(ref inner_init) = initp.node {\n-                check_pat(cx, inner, Some(&**inner_init), span, bindings);\n+        PatKind::Box(ref inner) => {\n+            if let Some(initp) = init {\n+                if let ExprKind::Box(ref inner_init) = initp.node {\n+                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n+                } else {\n+                    check_pat(cx, inner, init, span, bindings);\n+                }\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n-        } else {\n-            check_pat(cx, inner, init, span, bindings);\n         },\n         PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n@@ -327,8 +330,10 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => for e in v {\n-            check_expr(cx, e, bindings)\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => {\n+            for e in v {\n+                check_expr(cx, e, bindings)\n+            }\n         },\n         ExprKind::If(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n@@ -369,9 +374,13 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings);\n         },\n-        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n-        TyKind::Tup(ref tup) => for t in tup {\n-            check_ty(cx, t, bindings)\n+        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => {\n+            check_ty(cx, mty, bindings)\n+        },\n+        TyKind::Tup(ref tup) => {\n+            for t in tup {\n+                check_ty(cx, t, bindings)\n+            }\n         },\n         TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n         _ => (),\n@@ -382,11 +391,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n         ExprKind::Box(ref inner) | ExprKind::AddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprKind::Block(ref block, _) => {\n-            block.stmts.is_empty()\n-                && block\n-                    .expr\n-                    .as_ref()\n-                    .map_or(false, |e| is_self_shadow(name, e))\n+            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         },\n         ExprKind::Unary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),"}, {"sha": "7bf0fea42776a74ecb8157da3ba60e70220e9069", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 43, "deletions": 54, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use crate::rustc::hir::intravisit::{walk_expr, walk_stmt, walk_block, NestedVisitorMap, Visitor};\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass, Lint};\n-use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc::hir::intravisit::{walk_block, walk_expr, walk_stmt, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n-use if_chain::if_chain;\n-use crate::syntax_pos::symbol::Symbol;\n+use crate::rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{LitKind, NodeId};\n-use crate::utils::{match_qpath, span_lint_and_then, SpanlessEq, get_enclosing_block};\n+use crate::syntax_pos::symbol::Symbol;\n use crate::utils::sugg::Sugg;\n-use crate::rustc_errors::{Applicability};\n+use crate::utils::{get_enclosing_block, match_qpath, span_lint_and_then, SpanlessEq};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks slow zero-filled vector initialization\n ///\n@@ -49,7 +49,9 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let mut vec1 = Vec::with_capacity(len);\n-/// unsafe { vec1.set_len(len); }\n+/// unsafe {\n+///     vec1.set_len(len);\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub UNSAFE_VECTOR_INITIALIZATION,\n@@ -62,10 +64,7 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(\n-            SLOW_VECTOR_INITIALIZATION,\n-            UNSAFE_VECTOR_INITIALIZATION,\n-        )\n+        lint_array!(SLOW_VECTOR_INITIALIZATION, UNSAFE_VECTOR_INITIALIZATION,)\n     }\n }\n \n@@ -162,11 +161,7 @@ impl Pass {\n     }\n \n     /// Search initialization for the given vector\n-    fn search_initialization<'tcx>(\n-        cx: &LateContext<'_, 'tcx>,\n-        vec_alloc: VecAllocation<'tcx>,\n-        parent_node: NodeId\n-    ) {\n+    fn search_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, vec_alloc: VecAllocation<'tcx>, parent_node: NodeId) {\n         let enclosing_body = get_enclosing_block(cx, parent_node);\n \n         if enclosing_body.is_none() {\n@@ -187,26 +182,27 @@ impl Pass {\n         }\n     }\n \n-    fn lint_initialization<'tcx>(cx: &LateContext<'_, 'tcx>, initialization: &InitializationType<'tcx>, vec_alloc: &VecAllocation<'_>) {\n+    fn lint_initialization<'tcx>(\n+        cx: &LateContext<'_, 'tcx>,\n+        initialization: &InitializationType<'tcx>,\n+        vec_alloc: &VecAllocation<'_>,\n+    ) {\n         match initialization {\n-            InitializationType::UnsafeSetLen(e) =>\n-                Self::emit_lint(\n-                    cx,\n-                    e,\n-                    vec_alloc,\n-                    \"unsafe vector initialization\",\n-                    UNSAFE_VECTOR_INITIALIZATION\n-                ),\n-\n-            InitializationType::Extend(e) |\n-            InitializationType::Resize(e) =>\n-                Self::emit_lint(\n-                    cx,\n-                    e,\n-                    vec_alloc,\n-                    \"slow zero-filling initialization\",\n-                    SLOW_VECTOR_INITIALIZATION\n-                )\n+            InitializationType::UnsafeSetLen(e) => Self::emit_lint(\n+                cx,\n+                e,\n+                vec_alloc,\n+                \"unsafe vector initialization\",\n+                UNSAFE_VECTOR_INITIALIZATION,\n+            ),\n+\n+            InitializationType::Extend(e) | InitializationType::Resize(e) => Self::emit_lint(\n+                cx,\n+                e,\n+                vec_alloc,\n+                \"slow zero-filling initialization\",\n+                SLOW_VECTOR_INITIALIZATION,\n+            ),\n         };\n     }\n \n@@ -215,24 +211,18 @@ impl Pass {\n         slow_fill: &Expr,\n         vec_alloc: &VecAllocation<'_>,\n         msg: &str,\n-        lint: &'static Lint\n+        lint: &'static Lint,\n     ) {\n         let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n \n-        span_lint_and_then(\n-            cx,\n-            lint,\n-            slow_fill.span,\n-            msg,\n-            |db| {\n-                db.span_suggestion_with_applicability(\n-                    vec_alloc.allocation_expr.span,\n-                    \"consider replace allocation with\",\n-                    format!(\"vec![0; {}]\", len_expr),\n-                    Applicability::Unspecified\n-                );\n-            }\n-        );\n+        span_lint_and_then(cx, lint, slow_fill.span, msg, |db| {\n+            db.span_suggestion_with_applicability(\n+                vec_alloc.allocation_expr.span,\n+                \"consider replace allocation with\",\n+                format!(\"vec![0; {}]\", len_expr),\n+                Applicability::Unspecified,\n+            );\n+        });\n     }\n }\n \n@@ -356,8 +346,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         if self.initialization_found {\n             match stmt.node {\n-                StmtKind::Expr(ref expr, _) |\n-                StmtKind::Semi(ref expr, _) => {\n+                StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => {\n                     self.search_slow_extend_filling(expr);\n                     self.search_slow_resize_filling(expr);\n                     self.search_unsafe_set_len(expr);\n@@ -374,7 +363,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_block(&mut self, block: &'tcx Block) {\n         if self.initialization_found {\n             if let Some(ref s) = block.stmts.get(0) {\n-                self.visit_stmt( s)\n+                self.visit_stmt(s)\n             }\n \n             self.initialization_found = false;"}, {"sha": "ff37488c839a5252aef1b72bb4e5b1b5128b215b", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::hir;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast;\n use crate::utils::{get_trait_def_id, span_lint};\n+use if_chain::if_chain;\n \n /// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n /// subtracting elements in an Add impl.\n@@ -73,13 +72,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Binary(binop, _, _) = expr.node {\n             match binop.node {\n-                | hir::BinOpKind::Eq\n+                hir::BinOpKind::Eq\n                 | hir::BinOpKind::Lt\n                 | hir::BinOpKind::Le\n                 | hir::BinOpKind::Ne\n                 | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt\n-                => return,\n+                | hir::BinOpKind::Gt => return,\n                 _ => {},\n             }\n             // Check if the binary expression is part of another bi/unary expression\n@@ -97,9 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 parent_expr = cx.tcx.hir.get_parent_node(parent_expr);\n             }\n             // as a parent node\n-            let mut visitor = BinaryExprVisitor {\n-                in_binary_expr: false,\n-            };\n+            let mut visitor = BinaryExprVisitor { in_binary_expr: false };\n             walk_expr(&mut visitor, expr);\n \n             if visitor.in_binary_expr {\n@@ -122,10 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                     cx,\n                     SUSPICIOUS_ARITHMETIC_IMPL,\n                     binop.span,\n-                    &format!(\n-                        r#\"Suspicious use of binary operator in `{}` impl\"#,\n-                        impl_trait\n-                    ),\n+                    &format!(r#\"Suspicious use of binary operator in `{}` impl\"#, impl_trait),\n                 );\n             }\n \n@@ -162,10 +155,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                     cx,\n                     SUSPICIOUS_OP_ASSIGN_IMPL,\n                     binop.span,\n-                    &format!(\n-                        r#\"Suspicious use of binary operator in `{}` impl\"#,\n-                        impl_trait\n-                    ),\n+                    &format!(r#\"Suspicious use of binary operator in `{}` impl\"#, impl_trait),\n                 );\n             }\n         }\n@@ -218,9 +208,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for BinaryExprVisitor {\n         match expr.node {\n             hir::ExprKind::Binary(..)\n             | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n-            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => {\n-                self.in_binary_expr = true\n-            },\n+            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => self.in_binary_expr = true,\n             _ => {},\n         }\n "}, {"sha": "a93ff12405203531e734e543fbcffaf60b8c4b24", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use matches::matches;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty;\n-use crate::utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n-use crate::utils::sugg::Sugg;\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use matches::matches;\n \n /// **What it does:** Checks for manual swapping.\n ///"}, {"sha": "c25b0cf76617a0c9faa51f2b86cb66de5c079902", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::{Expr, ExprKind};\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::{Expr, ExprKind};\n use crate::utils::is_adjusted;\n use crate::utils::span_lint;\n "}, {"sha": "65d8e33ce7b2147f36e1bbe1613d7d8e5db327e4", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 108, "deletions": 103, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n use crate::rustc::ty::{self, Ty};\n-use crate::rustc::hir::*;\n-use std::borrow::Cow;\n+use crate::rustc::{declare_tool_lint, lint_array};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast;\n use crate::utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then};\n use crate::utils::{opt_def_id, sugg};\n-use crate::rustc_errors::Applicability;\n+use if_chain::if_chain;\n+use std::borrow::Cow;\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n /// architecture.\n@@ -65,7 +64,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// core::intrinsics::transmute(t) // where the result type is the same as\n-/// // `*t` or `&t`'s\n+///                                // `*t` or `&t`'s\n /// ```\n declare_clippy_lint! {\n     pub CROSSPOINTER_TRANSMUTE,\n@@ -82,7 +81,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let _: &T = std::mem::transmute(p); // where p: *const T\n-/// // can be written:\n+///                                     // can be written:\n /// let _: &T = &*p;\n /// ```\n declare_clippy_lint! {\n@@ -109,7 +108,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let _: char = std::mem::transmute(x); // where x: u32\n-/// // should be:\n+///                                       // should be:\n /// let _ = std::char::from_u32(x).unwrap();\n /// ```\n declare_clippy_lint! {\n@@ -136,7 +135,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let _: &str = std::mem::transmute(b); // where b: &[u8]\n-/// // should be:\n+///                                       // should be:\n /// let _ = std::str::from_utf8(b).unwrap();\n /// ```\n declare_clippy_lint! {\n@@ -154,7 +153,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let _: bool = std::mem::transmute(x); // where x: u8\n-/// // should be:\n+///                                       // should be:\n /// let _: bool = x != 0;\n /// ```\n declare_clippy_lint! {\n@@ -172,7 +171,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let _: f32 = std::mem::transmute(x); // where x: u32\n-/// // should be:\n+///                                      // should be:\n /// let _: f32 = f32::from_bits(x);\n /// ```\n declare_clippy_lint! {\n@@ -248,43 +247,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 USELESS_TRANSMUTE,\n                                 e.span,\n                                 \"transmute from a reference to a pointer\",\n-                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                    let rty_and_mut = ty::TypeAndMut { ty: rty, mutbl: rty_mutbl };\n+                                |db| {\n+                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                        let rty_and_mut = ty::TypeAndMut {\n+                                            ty: rty,\n+                                            mutbl: rty_mutbl,\n+                                        };\n \n-                                    let sugg = if ptr_ty == rty_and_mut {\n-                                        arg.as_ty(to_ty)\n-                                    } else {\n-                                        arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n-                                    };\n+                                        let sugg = if ptr_ty == rty_and_mut {\n+                                            arg.as_ty(to_ty)\n+                                        } else {\n+                                            arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n+                                        };\n \n-                                    db.span_suggestion_with_applicability(\n-                                        e.span,\n-                                        \"try\",\n-                                        sugg.to_string(),\n-                                        Applicability::Unspecified,\n-                                    );\n+                                        db.span_suggestion_with_applicability(\n+                                            e.span,\n+                                            \"try\",\n+                                            sugg.to_string(),\n+                                            Applicability::Unspecified,\n+                                        );\n+                                    }\n                                 },\n                             ),\n-                            (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    USELESS_TRANSMUTE,\n-                                    e.span,\n-                                    \"transmute from an integer to a pointer\",\n-                                    |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                            (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => span_lint_and_then(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                \"transmute from an integer to a pointer\",\n+                                |db| {\n+                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                         db.span_suggestion_with_applicability(\n                                             e.span,\n                                             \"try\",\n                                             arg.as_ty(&to_ty.to_string()).to_string(),\n                                             Applicability::Unspecified,\n                                         );\n-                                    },\n-                                )\n-                            },\n-                            (&ty::Float(_), &ty::Ref(..)) |\n-                            (&ty::Float(_), &ty::RawPtr(_)) |\n-                            (&ty::Char, &ty::Ref(..)) |\n-                            (&ty::Char, &ty::RawPtr(_)) => span_lint(\n+                                    }\n+                                },\n+                            ),\n+                            (&ty::Float(_), &ty::Ref(..))\n+                            | (&ty::Float(_), &ty::RawPtr(_))\n+                            | (&ty::Char, &ty::Ref(..))\n+                            | (&ty::Char, &ty::RawPtr(_)) => span_lint(\n                                 cx,\n                                 WRONG_TRANSMUTE,\n                                 e.span,\n@@ -296,8 +300,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 e.span,\n                                 &format!(\n                                     \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                    from_ty,\n-                                    to_ty\n+                                    from_ty, to_ty\n                                 ),\n                             ),\n                             (_, &ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n@@ -306,8 +309,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 e.span,\n                                 &format!(\n                                     \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                                    from_ty,\n-                                    to_ty\n+                                    from_ty, to_ty\n                                 ),\n                             ),\n                             (&ty::RawPtr(from_pty), &ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n@@ -317,8 +319,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 &format!(\n                                     \"transmute from a pointer type (`{}`) to a reference type \\\n                                      (`{}`)\",\n-                                    from_ty,\n-                                    to_ty\n+                                    from_ty, to_ty\n                                 ),\n                                 |db| {\n                                     let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n@@ -342,27 +343,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     );\n                                 },\n                             ),\n-                            (&ty::Int(ast::IntTy::I32), &ty::Char) |\n-                            (&ty::Uint(ast::UintTy::U32), &ty::Char) => span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_INT_TO_CHAR,\n-                                e.span,\n-                                &format!(\"transmute from a `{}` to a `char`\", from_ty),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let arg = if let ty::Int(_) = from_ty.sty {\n-                                        arg.as_ty(ty::Uint(ast::UintTy::U32))\n-                                    } else {\n-                                        arg\n-                                    };\n-                                    db.span_suggestion_with_applicability(\n-                                        e.span,\n-                                        \"consider using\",\n-                                        format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n-                                        Applicability::Unspecified,\n-                                    );\n-                                },\n-                            ),\n+                            (&ty::Int(ast::IntTy::I32), &ty::Char) | (&ty::Uint(ast::UintTy::U32), &ty::Char) => {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    TRANSMUTE_INT_TO_CHAR,\n+                                    e.span,\n+                                    &format!(\"transmute from a `{}` to a `char`\", from_ty),\n+                                    |db| {\n+                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                        let arg = if let ty::Int(_) = from_ty.sty {\n+                                            arg.as_ty(ty::Uint(ast::UintTy::U32))\n+                                        } else {\n+                                            arg\n+                                        };\n+                                        db.span_suggestion_with_applicability(\n+                                            e.span,\n+                                            \"consider using\",\n+                                            format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                                            Applicability::Unspecified,\n+                                        );\n+                                    },\n+                                )\n+                            },\n                             (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n                                 if_chain! {\n                                     if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.sty, &ty_to.sty);\n@@ -401,9 +403,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                 e.span,\n                                                 \"transmute from a reference to a reference\",\n                                                 |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                                    let ty_from_and_mut = ty::TypeAndMut { ty: ty_from, mutbl: from_mutbl };\n+                                                    let ty_from_and_mut = ty::TypeAndMut {\n+                                                        ty: ty_from,\n+                                                        mutbl: from_mutbl\n+                                                    };\n                                                     let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: to_mutbl };\n-                                                    let sugg_paren = arg.as_ty(cx.tcx.mk_ptr(ty_from_and_mut)).as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n+                                                    let sugg_paren = arg\n+                                                        .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n+                                                        .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n                                                     let sugg = if to_mutbl == Mutability::MutMutable {\n                                                         sugg_paren.mut_addr_deref()\n                                                     } else {\n@@ -426,14 +433,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 TRANSMUTE_PTR_TO_PTR,\n                                 e.span,\n                                 \"transmute from a pointer to a pointer\",\n-                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                    let sugg = arg.as_ty(cx.tcx.mk_ptr(to_ty));\n-                                    db.span_suggestion_with_applicability(\n-                                        e.span,\n-                                        \"try\",\n-                                        sugg.to_string(),\n-                                        Applicability::Unspecified,\n-                                    );\n+                                |db| {\n+                                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                        let sugg = arg.as_ty(cx.tcx.mk_ptr(to_ty));\n+                                        db.span_suggestion_with_applicability(\n+                                            e.span,\n+                                            \"try\",\n+                                            sugg.to_string(),\n+                                            Applicability::Unspecified,\n+                                        );\n+                                    }\n                                 },\n                             ),\n                             (&ty::Int(ast::IntTy::I8), &ty::Bool) | (&ty::Uint(ast::UintTy::U8), &ty::Bool) => {\n@@ -454,33 +463,29 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     },\n                                 )\n                             },\n-                            (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    TRANSMUTE_INT_TO_FLOAT,\n-                                    e.span,\n-                                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                    |db| {\n-                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                        let arg = if let ty::Int(int_ty) = from_ty.sty {\n-                                            arg.as_ty(format!(\n-                                                \"u{}\",\n-                                                int_ty\n-                                                    .bit_width()\n-                                                    .map_or_else(|| \"size\".to_string(), |v| v.to_string())\n-                                            ))\n-                                        } else {\n-                                            arg\n-                                        };\n-                                        db.span_suggestion_with_applicability(\n-                                            e.span,\n-                                            \"consider using\",\n-                                            format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n-                                            Applicability::Unspecified,\n-                                        );\n-                                    },\n-                                )\n-                            },\n+                            (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => span_lint_and_then(\n+                                cx,\n+                                TRANSMUTE_INT_TO_FLOAT,\n+                                e.span,\n+                                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                                |db| {\n+                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                    let arg = if let ty::Int(int_ty) = from_ty.sty {\n+                                        arg.as_ty(format!(\n+                                            \"u{}\",\n+                                            int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n+                                        ))\n+                                    } else {\n+                                        arg\n+                                    };\n+                                    db.span_suggestion_with_applicability(\n+                                        e.span,\n+                                        \"consider using\",\n+                                        format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                                        Applicability::Unspecified,\n+                                    );\n+                                },\n+                            ),\n                             _ => return,\n                         };\n                     }"}, {"sha": "587b9b731c3f90bd59d08cf2c9d4939a89523446", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use std::cmp;\n \n use crate::rustc::hir;\n@@ -82,11 +81,7 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n         Self { limit }\n     }\n \n-    fn check_trait_method(\n-        &mut self,\n-        cx: &LateContext<'_, 'tcx>,\n-        item: &TraitItemRef\n-    ) {\n+    fn check_trait_method(&mut self, cx: &LateContext<'_, 'tcx>, item: &TraitItemRef) {\n         let method_def_id = cx.tcx.hir.local_def_id(item.id.node_id);\n         let method_sig = cx.tcx.fn_sig(method_def_id);\n         let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n@@ -99,13 +94,7 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n         self.check_poly_fn(cx, &decl, &method_sig, None);\n     }\n \n-    fn check_poly_fn(\n-        &mut self,\n-        cx: &LateContext<'_, 'tcx>,\n-        decl: &FnDecl,\n-        sig: &FnSig<'tcx>,\n-        span: Option<Span>,\n-    ) {\n+    fn check_poly_fn(&mut self, cx: &LateContext<'_, 'tcx>, decl: &FnDecl, sig: &FnSig<'tcx>, span: Option<Span>) {\n         // Use lifetimes to determine if we're returning a reference to the\n         // argument. In that case we can't switch to pass-by-value as the\n         // argument will not live long enough.\n@@ -149,13 +138,9 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n         }\n     }\n \n-    fn check_trait_items(\n-        &mut self,\n-        cx: &LateContext<'_, '_>,\n-        trait_items: &[TraitItemRef]\n-    ) {\n+    fn check_trait_items(&mut self, cx: &LateContext<'_, '_>, trait_items: &[TraitItemRef]) {\n         for item in trait_items {\n-            if let AssociatedItemKind::Method{..} = item.kind {\n+            if let AssociatedItemKind::Method { .. } = item.kind {\n                 self.check_trait_method(cx, item);\n             }\n         }"}, {"sha": "6d5dbfe07130abf75bb2ff05e89c0ad09505ec96", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 202, "deletions": 120, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -117,10 +117,10 @@ declare_clippy_lint! {\n /// let x = LinkedList::new();\n /// ```\n declare_clippy_lint! {\n-    pub LINKEDLIST,\n-    pedantic,\n-    \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n-     structure like a VecDeque\"\n+pub LINKEDLIST,\n+pedantic,\n+\"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n+ structure like a VecDeque\"\n }\n \n /// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n@@ -245,7 +245,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                             OPTION_OPTION,\n                             ast_ty.span,\n                             \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                            enum if you need to distinguish all 3 cases\",\n+                             enum if you need to distinguish all 3 cases\",\n                         );\n                         return; // don't recurse into the type\n                     }\n@@ -275,16 +275,18 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n-                QPath::Resolved(None, ref p) => for ty in p.segments.iter().flat_map(|seg| {\n-                    seg.args\n-                        .as_ref()\n-                        .map_or_else(|| [].iter(), |params| params.args.iter())\n-                        .filter_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty),\n-                            GenericArg::Lifetime(_) => None,\n-                        })\n-                }) {\n-                    check_ty(cx, ty, is_local);\n+                QPath::Resolved(None, ref p) => {\n+                    for ty in p.segments.iter().flat_map(|seg| {\n+                        seg.args\n+                            .as_ref()\n+                            .map_or_else(|| [].iter(), |params| params.args.iter())\n+                            .filter_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                GenericArg::Lifetime(_) => None,\n+                            })\n+                    }) {\n+                        check_ty(cx, ty, is_local);\n+                    }\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n                     check_ty(cx, ty, is_local);\n@@ -301,9 +303,13 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n         },\n         TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n         // recurse\n-        TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n-        TyKind::Tup(ref tys) => for ty in tys {\n-            check_ty(cx, ty, is_local);\n+        TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n+            check_ty(cx, ty, is_local)\n+        },\n+        TyKind::Tup(ref tys) => {\n+            for ty in tys {\n+                check_ty(cx, ty, is_local);\n+            }\n         },\n         _ => {},\n     }\n@@ -348,7 +354,12 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt:\n                         ast_ty.span,\n                         \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n                         \"try\",\n-                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)),\n+                        format!(\n+                            \"&{}{}{}\",\n+                            ltopt,\n+                            mutopt,\n+                            &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)\n+                        ),\n                         Applicability::Unspecified,\n                     );\n                     return; // don't recurse into the type\n@@ -387,7 +398,9 @@ pub struct LetPass;\n ///\n /// **Example:**\n /// ```rust\n-/// let x = { 1; };\n+/// let x = {\n+///     1;\n+/// };\n /// ```\n declare_clippy_lint! {\n     pub LET_UNIT_VALUE,\n@@ -439,11 +452,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetPass {\n ///\n /// **Example:**\n /// ```rust\n-/// if { foo(); } == { bar(); } { baz(); }\n+/// if {\n+///     foo();\n+/// } == {\n+///     bar();\n+/// } {\n+///     baz();\n+/// }\n /// ```\n /// is equal to\n /// ```rust\n-/// { foo(); bar(); baz(); }\n+/// {\n+///     foo();\n+///     bar();\n+///     baz();\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub UNIT_CMP,\n@@ -486,7 +509,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n     }\n }\n \n-/// **What it does:** Checks for passing a unit value as an argument to a function without using a unit literal (`()`).\n+/// **What it does:** Checks for passing a unit value as an argument to a function without using a\n+/// unit literal (`()`).\n ///\n /// **Why is this bad?** This is likely the result of an accidental semicolon.\n ///\n@@ -495,8 +519,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n /// **Example:**\n /// ```rust\n /// foo({\n-///   let a = bar();\n-///   baz(a);\n+///     let a = bar();\n+///     baz(a);\n /// })\n /// ```\n declare_clippy_lint! {\n@@ -528,7 +552,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n                         // only the calls to `Try::from_error` is marked as desugared,\n                         // so we need to check both the current Expr and its parent.\n                         if !is_questionmark_desugar_marked_call(expr) {\n-                            if_chain!{\n+                            if_chain! {\n                                 let opt_parent_node = map.find(map.get_parent_node(expr.id));\n                                 if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n                                 if is_questionmark_desugar_marked_call(parent_expr);\n@@ -597,7 +621,8 @@ pub struct CastPass;\n ///\n /// **Example:**\n /// ```rust\n-/// let x = u64::MAX; x as f64\n+/// let x = u64::MAX;\n+/// x as f64\n /// ```\n declare_clippy_lint! {\n     pub CAST_PRECISION_LOSS,\n@@ -618,7 +643,7 @@ declare_clippy_lint! {\n /// **Example:**\n /// ```rust\n /// let y: i8 = -1;\n-/// y as u128  // will return 18446744073709551615\n+/// y as u128 // will return 18446744073709551615\n /// ```\n declare_clippy_lint! {\n     pub CAST_SIGN_LOSS,\n@@ -638,13 +663,15 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// fn as_u8(x: u64) -> u8 { x as u8 }\n+/// fn as_u8(x: u64) -> u8 {\n+///     x as u8\n+/// }\n /// ```\n declare_clippy_lint! {\n-    pub CAST_POSSIBLE_TRUNCATION,\n-    pedantic,\n-    \"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, \\\n-     or `x as i32` where `x: f32`\"\n+pub CAST_POSSIBLE_TRUNCATION,\n+pedantic,\n+\"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, \\\n+ or `x as i32` where `x: f32`\"\n }\n \n /// **What it does:** Checks for casts from an unsigned type to a signed type of\n@@ -662,13 +689,13 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// u32::MAX as i32  // will yield a value of `-1`\n+/// u32::MAX as i32 // will yield a value of `-1`\n /// ```\n declare_clippy_lint! {\n-    pub CAST_POSSIBLE_WRAP,\n-    pedantic,\n-    \"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` \\\n-     and `x > i32::MAX`\"\n+pub CAST_POSSIBLE_WRAP,\n+pedantic,\n+\"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` \\\n+ and `x > i32::MAX`\"\n }\n \n /// **What it does:** Checks for on casts between numerical types that may\n@@ -685,13 +712,17 @@ declare_clippy_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// fn as_u64(x: u8) -> u64 { x as u64 }\n+/// fn as_u64(x: u8) -> u64 {\n+///     x as u64\n+/// }\n /// ```\n ///\n /// Using `::from` would look like this:\n ///\n /// ```rust\n-/// fn as_u64(x: u8) -> u64 { u64::from(x) }\n+/// fn as_u64(x: u8) -> u64 {\n+///     u64::from(x)\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub CAST_LOSSLESS,\n@@ -773,11 +804,15 @@ declare_clippy_lint! {\n ///\n /// ```rust\n /// // Bad\n-/// fn fn1() -> i16 { 1 };\n+/// fn fn1() -> i16 {\n+///     1\n+/// };\n /// let _ = fn1 as i32;\n ///\n /// // Better: Cast to usize first, then comment with the reason for the truncation\n-/// fn fn2() -> i16 { 1 };\n+/// fn fn2() -> i16 {\n+///     1\n+/// };\n /// let fn_ptr = fn2 as usize;\n /// let fn_ptr_truncated = fn_ptr as i32;\n /// ```\n@@ -838,11 +873,7 @@ fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty\n              is only {4} bits wide)\",\n             cast_from,\n             if cast_to_f64 { \"f64\" } else { \"f32\" },\n-            if arch_dependent {\n-                arch_dependent_str\n-            } else {\n-                \"\"\n-            },\n+            if arch_dependent { arch_dependent_str } else { \"\" },\n             from_nbits_str,\n             mantissa_nbits\n         ),\n@@ -860,7 +891,9 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n \n fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n-    if in_constant(cx, expr.id) { return }\n+    if in_constant(cx, expr.id) {\n+        return;\n+    }\n     // The suggestion is to use a function call, so if the original expression\n     // has parens on the outside, they are no longer needed.\n     let mut applicability = Applicability::MachineApplicable;\n@@ -880,7 +913,10 @@ fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n         cx,\n         CAST_LOSSLESS,\n         expr.span,\n-        &format!(\"casting {} to {} may become silently lossy if types change\", cast_from, cast_to),\n+        &format!(\n+            \"casting {} to {} may become silently lossy if types change\",\n+            cast_from, cast_to\n+        ),\n         \"try\",\n         format!(\"{}::from({})\", cast_to, sugg),\n         applicability,\n@@ -999,13 +1035,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 use crate::syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n-                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx.sess(), expr.span) {\n-                        span_lint(\n-                            cx,\n-                            UNNECESSARY_CAST,\n-                            expr.span,\n-                            &format!(\"casting to the same type is unnecessary (`{}` -> `{}`)\", cast_from, cast_to),\n-                        );\n+                    _ => {\n+                        if cast_from.sty == cast_to.sty && !in_external_macro(cx.sess(), expr.span) {\n+                            span_lint(\n+                                cx,\n+                                UNNECESSARY_CAST,\n+                                expr.span,\n+                                &format!(\n+                                    \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n+                                    cast_from, cast_to\n+                                ),\n+                            );\n+                        }\n                     },\n                 }\n             }\n@@ -1054,24 +1095,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                         check_lossless(cx, expr, ex, cast_from, cast_to);\n                     },\n                     (false, false) => {\n-                        if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty)\n-                        {\n+                        if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n                             span_lint(\n                                 cx,\n                                 CAST_POSSIBLE_TRUNCATION,\n                                 expr.span,\n                                 \"casting f64 to f32 may truncate the value\",\n                             );\n                         }\n-                        if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty)\n-                        {\n+                        if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty) {\n                             span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n                         }\n                     },\n                 }\n             }\n \n-            if_chain!{\n+            if_chain! {\n                 if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n                 if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n                 if let Some(from_align) = cx.layout_of(from_ptr_ty.ty).ok().map(|a| a.align.abi);\n@@ -1095,11 +1134,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     }\n }\n \n-fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn lint_fn_to_numeric_cast(\n+    cx: &LateContext<'_, '_>,\n+    expr: &Expr,\n+    cast_expr: &Expr,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) {\n     // We only want to check casts to `ty::Uint` or `ty::Int`\n     match cast_to.sty {\n         ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n-        _ => return\n+        _ => return,\n     }\n     match cast_from.sty {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n@@ -1112,12 +1157,14 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                     cx,\n                     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n                     expr.span,\n-                    &format!(\"casting function pointer `{}` to `{}`, which truncates the value\", from_snippet, cast_to),\n+                    &format!(\n+                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n+                        from_snippet, cast_to\n+                    ),\n                     \"try\",\n                     format!(\"{} as usize\", from_snippet),\n                     applicability,\n                 );\n-\n             } else if cast_to.sty != ty::Uint(UintTy::Usize) {\n                 span_lint_and_sugg(\n                     cx,\n@@ -1130,7 +1177,7 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n                 );\n             }\n         },\n-        _ => {}\n+        _ => {},\n     }\n }\n \n@@ -1144,7 +1191,9 @@ fn lint_fn_to_numeric_cast(cx: &LateContext<'_, '_>, expr: &Expr, cast_expr: &Ex\n ///\n /// **Example:**\n /// ```rust\n-/// struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }\n+/// struct Foo {\n+///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+/// }\n /// ```\n declare_clippy_lint! {\n     pub TYPE_COMPLEXITY,\n@@ -1158,9 +1207,7 @@ pub struct TypeComplexityPass {\n \n impl TypeComplexityPass {\n     pub fn new(threshold: u64) -> Self {\n-        Self {\n-            threshold,\n-        }\n+        Self { threshold }\n     }\n }\n \n@@ -1272,12 +1319,12 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n \n             TyKind::TraitObject(ref param_bounds, _) => {\n-                let has_lifetime_parameters = param_bounds\n-                    .iter()\n-                    .any(|bound| bound.bound_generic_params.iter().any(|gen| match gen.kind {\n+                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n+                    bound.bound_generic_params.iter().any(|gen| match gen.kind {\n                         GenericParamKind::Lifetime { .. } => true,\n                         _ => false,\n-                    }));\n+                    })\n+                });\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>\n                     (50 * self.nest, 1)\n@@ -1345,7 +1392,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n                         let msg = \"casting character literal to u8. `char`s \\\n                                    are 4 bytes wide in rust, so casting to u8 \\\n                                    truncates them\";\n-                        let help = format!(\"Consider using a byte literal instead:\\nb{}\", snippet(cx, e.span, \"'x'\"));\n+                        let help = format!(\n+                            \"Consider using a byte literal instead:\\nb{}\",\n+                            snippet(cx, e.span, \"'x'\")\n+                        );\n                         span_help_and_lint(cx, CHAR_LIT_AS_U8, expr.span, msg, &help);\n                     }\n                 }\n@@ -1405,17 +1455,12 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n-\n-fn is_cast_between_fixed_and_target<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr\n-) -> bool {\n-\n+fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n \n-        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty)\n+        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n     }\n \n     false\n@@ -1427,8 +1472,8 @@ fn detect_absurd_comparison<'a, 'tcx>(\n     lhs: &'tcx Expr,\n     rhs: &'tcx Expr,\n ) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n-    use crate::types::ExtremeType::*;\n     use crate::types::AbsurdComparisonResult::*;\n+    use crate::types::ExtremeType::*;\n     use crate::utils::comparisons::*;\n \n     // absurd comparison only makes sense on primitive types\n@@ -1481,26 +1526,30 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n     let cv = constant(cx, cx.tables, expr)?.0;\n \n     let which = match (&ty.sty, cv) {\n-        (&ty::Bool, Constant::Bool(false)) |\n-        (&ty::Uint(_), Constant::Int(0)) => Minimum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Minimum,\n+        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n+        (&ty::Int(ity), Constant::Int(i))\n+            if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n+        {\n+            Minimum\n+        },\n \n         (&ty::Bool, Constant::Bool(true)) => Maximum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Maximum,\n+        (&ty::Int(ity), Constant::Int(i))\n+            if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n+        {\n+            Maximum\n+        },\n         (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n \n         _ => return None,\n     };\n-    Some(ExtremeExpr {\n-        which,\n-        expr,\n-    })\n+    Some(ExtremeExpr { which, expr })\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        use crate::types::ExtremeType::*;\n         use crate::types::AbsurdComparisonResult::*;\n+        use crate::types::ExtremeType::*;\n \n         if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n@@ -1586,8 +1635,7 @@ impl FullInt {\n \n impl PartialEq for FullInt {\n     fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other)\n-            .expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n+        self.partial_cmp(other).expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n     }\n }\n \n@@ -1608,7 +1656,6 @@ impl Ord for FullInt {\n     }\n }\n \n-\n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use crate::syntax::ast::{IntTy, UintTy};\n     use std::*;\n@@ -1622,7 +1669,10 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n         }\n         match pre_cast_ty.sty {\n             ty::Int(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i128::from(i8::min_value())), FullInt::S(i128::from(i8::max_value()))),\n+                IntTy::I8 => (\n+                    FullInt::S(i128::from(i8::min_value())),\n+                    FullInt::S(i128::from(i8::max_value())),\n+                ),\n                 IntTy::I16 => (\n                     FullInt::S(i128::from(i16::min_value())),\n                     FullInt::S(i128::from(i16::max_value())),\n@@ -1636,10 +1686,16 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n                     FullInt::S(i128::from(i64::max_value())),\n                 ),\n                 IntTy::I128 => (FullInt::S(i128::min_value()), FullInt::S(i128::max_value())),\n-                IntTy::Isize => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n+                IntTy::Isize => (\n+                    FullInt::S(isize::min_value() as i128),\n+                    FullInt::S(isize::max_value() as i128),\n+                ),\n             }),\n             ty::Uint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u128::from(u8::min_value())), FullInt::U(u128::from(u8::max_value()))),\n+                UintTy::U8 => (\n+                    FullInt::U(u128::from(u8::min_value())),\n+                    FullInt::U(u128::from(u8::max_value())),\n+                ),\n                 UintTy::U16 => (\n                     FullInt::U(u128::from(u16::min_value())),\n                     FullInt::U(u128::from(u16::max_value())),\n@@ -1653,7 +1709,10 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n                     FullInt::U(u128::from(u64::max_value())),\n                 ),\n                 UintTy::U128 => (FullInt::U(u128::min_value()), FullInt::U(u128::max_value())),\n-                UintTy::Usize => (FullInt::U(usize::min_value() as u128), FullInt::U(usize::max_value() as u128)),\n+                UintTy::Usize => (\n+                    FullInt::U(usize::min_value() as u128),\n+                    FullInt::U(usize::max_value() as u128),\n+                ),\n             }),\n             _ => None,\n         }\n@@ -1708,29 +1767,37 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n                     err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n                 }\n             } else if match rel {\n-                Rel::Lt => if invert {\n-                    norm_rhs_val < lb\n-                } else {\n-                    ub < norm_rhs_val\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n                 },\n-                Rel::Le => if invert {\n-                    norm_rhs_val <= lb\n-                } else {\n-                    ub <= norm_rhs_val\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n                 },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n                 err_upcast_comparison(cx, span, lhs, true)\n             } else if match rel {\n-                Rel::Lt => if invert {\n-                    norm_rhs_val >= ub\n-                } else {\n-                    lb >= norm_rhs_val\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n                 },\n-                Rel::Le => if invert {\n-                    norm_rhs_val > ub\n-                } else {\n-                    lb > norm_rhs_val\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n                 },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n@@ -1874,7 +1941,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n                         cx,\n                         IMPLICIT_HASHER,\n                         target.span(),\n-                        &format!(\"impl for `{}` should be generalized over different hashers\", target.type_name()),\n+                        &format!(\n+                            \"impl for `{}` should be generalized over different hashers\",\n+                            target.type_name()\n+                        ),\n                         move |db| {\n                             suggestion(cx, db, generics.span, generics_suggestion_span, target, ctr_vis);\n                         },\n@@ -1931,11 +2001,19 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n         if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n-            let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?\n-                .args.iter().filter_map(|arg| match arg {\n+            let params: Vec<_> = path\n+                .segments\n+                .last()\n+                .as_ref()?\n+                .args\n+                .as_ref()?\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n                     GenericArg::Type(ty) => Some(ty),\n                     GenericArg::Lifetime(_) => None,\n-                }).collect();\n+                })\n+                .collect();\n             let params_len = params.len();\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n@@ -1948,7 +2026,11 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n                     snippet(cx, params[1].span, \"V\"),\n                 ))\n             } else if match_path(path, &paths::HASHSET) && params_len == 1 {\n-                Some(ImplicitHasherType::HashSet(hir_ty.span, ty, snippet(cx, params[0].span, \"T\")))\n+                Some(ImplicitHasherType::HashSet(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"T\"),\n+                ))\n             } else {\n                 None\n             }"}, {"sha": "bb3848919262b14151ac6d6313207476b2708dc9", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir::*;\n use crate::syntax::ast::{LitKind, NodeId};\n use crate::syntax::source_map::Span;\n-use unicode_normalization::UnicodeNormalization;\n use crate::utils::{is_allowed, snippet, span_help_and_lint};\n+use unicode_normalization::UnicodeNormalization;\n \n /// **What it does:** Checks for the Unicode zero-width space in the code.\n ///\n@@ -46,10 +45,10 @@ declare_clippy_lint! {\n /// let x = \"H\u00e4?\"\n /// ```\n declare_clippy_lint! {\n-    pub NON_ASCII_LITERAL,\n-    pedantic,\n-    \"using any literal non-ASCII chars in a string literal instead of \\\n-     using the `\\\\u` escape\"\n+pub NON_ASCII_LITERAL,\n+pedantic,\n+\"using any literal non-ASCII chars in a string literal instead of \\\n+ using the `\\\\u` escape\"\n }\n \n /// **What it does:** Checks for string literals that contain Unicode in a form\n@@ -64,13 +63,12 @@ declare_clippy_lint! {\n /// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n /// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n declare_clippy_lint! {\n-    pub UNICODE_NOT_NFC,\n-    pedantic,\n-    \"using a unicode literal not in NFC normal form (see \\\n-     [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\"\n+pub UNICODE_NOT_NFC,\n+pedantic,\n+\"using a unicode literal not in NFC normal form (see \\\n+ [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\"\n }\n \n-\n #[derive(Copy, Clone)]\n pub struct Unicode;\n \n@@ -140,7 +138,10 @@ fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n             UNICODE_NOT_NFC,\n             span,\n             \"non-nfc unicode sequence detected\",\n-            &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\", string.nfc().collect::<String>()),\n+            &format!(\n+                \"Consider replacing the string with:\\n\\\"{}\\\"\",\n+                string.nfc().collect::<String>()\n+            ),\n         );\n     }\n }"}, {"sha": "ce07e48eaf0d229ed3e83e3ada29e460d2323aaa", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::*;\n@@ -62,14 +61,13 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n                 .expect(\"use paths cannot be empty\")\n                 .ident;\n             unsafe_to_safe_check(old_name, new_name, cx, span);\n-        }\n-        UseTreeKind::Simple(None, ..) |\n-        UseTreeKind::Glob => {},\n+        },\n+        UseTreeKind::Simple(None, ..) | UseTreeKind::Glob => {},\n         UseTreeKind::Nested(ref nested_use_tree) => {\n             for &(ref use_tree, _) in nested_use_tree {\n                 check_use_tree(use_tree, cx, span);\n             }\n-        }\n+        },\n     }\n }\n \n@@ -81,7 +79,10 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>,\n             cx,\n             UNSAFE_REMOVED_FROM_NAME,\n             span,\n-            &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str),\n+            &format!(\n+                \"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\",\n+                old_str, new_str\n+            ),\n         );\n     }\n }"}, {"sha": "af2d742b2dbc310d0a3b71d228b8bb499c188311", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,10 +7,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use crate::rustc::hir;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc::hir;\n use crate::utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n \n /// **What it does:** Checks for unused written/read amount."}, {"sha": "ed4a957844008a2d72130b341bd34fee127305f6", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,11 +7,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir;\n use crate::rustc::hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashMap;\n use crate::syntax::ast;\n use crate::syntax::source_map::Span;\n@@ -80,8 +79,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => if let Some(label) = destination.label {\n-                self.labels.remove(&label.ident.as_str());\n+            hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => {\n+                if let Some(label) = destination.label {\n+                    self.labels.remove(&label.ident.as_str());\n+                }\n             },\n             hir::ExprKind::Loop(_, Some(label), _) | hir::ExprKind::While(_, _, Some(label)) => {\n                 self.labels.insert(label.ident.as_str(), expr.span);"}, {"sha": "6e9b70f30037eaf9aca0e575e8c2495fa2138422", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n \n-use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n use crate::rustc::hir::intravisit::*;\n use crate::rustc::hir::*;\n use crate::syntax::ast::NodeId;\n use crate::syntax::source_map::Span;\n+use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n \n /// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n ///"}, {"sha": "3a71a6d04afdf25b4a496e86ae936d4bd7ee2fa1", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::hir::intravisit::{walk_path, walk_ty, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -88,11 +87,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n         let impl_ty = self.impl_type_walker.next();\n \n         if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n-\n             // The implementation and trait types don't match which means that\n             // the concrete type was specified by the implementation\n             if impl_ty != trait_ty {\n-\n                 if let Some(impl_ty) = impl_ty {\n                     if self.item_type == impl_ty {\n                         let is_self_ty = if let def::Def::SelfTy(..) = path.def {\n@@ -106,7 +103,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n                         }\n                     }\n                 }\n-\n             }\n         }\n "}, {"sha": "7e09eae1e930e40768ea7df2c46d9613cb445939", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,15 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! A group of attributes that can be attached to Rust code in order\n //! to generate a clippy lint detecting said code automatically.\n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir;\n-use crate::rustc::hir::{Expr, ExprKind, QPath, TyKind, Pat, PatKind, BindingAnnotation, StmtKind, DeclKind, Stmt};\n use crate::rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n+use crate::rustc::hir::{BindingAnnotation, DeclKind, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_data_structures::fx::FxHashMap;\n use crate::syntax::ast::{Attribute, LitKind, DUMMY_NODE_ID};\n use crate::utils::get_attr;\n@@ -40,7 +39,7 @@ use crate::utils::get_attr;\n ///\n /// ```rust\n /// // ./tests/ui/new_lint.stdout\n-/// if_chain!{\n+/// if_chain! {\n ///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n ///     if let ExprKind::Path(ref path) = left.node,\n@@ -248,7 +247,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n-                println!(\"Binary(ref {}, ref {}, ref {}) = {};\", op_pat, left_pat, right_pat, current);\n+                println!(\n+                    \"Binary(ref {}, ref {}, ref {}) = {};\",\n+                    op_pat, left_pat, right_pat, current\n+                );\n                 println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = left_pat;\n                 self.visit_expr(left);\n@@ -311,7 +313,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n                     let else_pat = self.next(\"else_\");\n-                    println!(\"If(ref {}, ref {}, Some(ref {})) = {};\", cond_pat, then_pat, else_pat, current);\n+                    println!(\n+                        \"If(ref {}, ref {}, Some(ref {})) = {};\",\n+                        cond_pat, then_pat, else_pat, current\n+                    );\n                     self.current = else_pat;\n                     self.visit_expr(else_);\n                 } else {\n@@ -326,7 +331,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let cond_pat = self.next(\"cond\");\n                 let body_pat = self.next(\"body\");\n                 let label_pat = self.next(\"label\");\n-                println!(\"While(ref {}, ref {}, ref {}) = {};\", cond_pat, body_pat, label_pat, current);\n+                println!(\n+                    \"While(ref {}, ref {}, ref {}) = {};\",\n+                    cond_pat, body_pat, label_pat, current\n+                );\n                 self.current = cond_pat;\n                 self.visit_expr(cond);\n                 self.current = body_pat;\n@@ -360,7 +368,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                                 println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n                                 self.current = if_expr_pat;\n                                 self.visit_expr(if_expr);\n-                            }\n+                            },\n                         }\n                     }\n                     println!(\"    if {}[{}].pats.len() == {};\", arms_pat, i, arm.pats.len());\n@@ -399,7 +407,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n-                println!(\"AssignOp(ref {}, ref {}, ref {}) = {};\", op_pat, target_pat, value_pat, current);\n+                println!(\n+                    \"AssignOp(ref {}, ref {}, ref {}) = {};\",\n+                    op_pat, target_pat, value_pat, current\n+                );\n                 println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n@@ -452,13 +463,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n-            ExprKind::Ret(ref opt_value) => if let Some(ref value) = *opt_value {\n-                let value_pat = self.next(\"value\");\n-                println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n-                self.current = value_pat;\n-                self.visit_expr(value);\n-            } else {\n-                println!(\"Ret(None) = {};\", current);\n+            ExprKind::Ret(ref opt_value) => {\n+                if let Some(ref value) = *opt_value {\n+                    let value_pat = self.next(\"value\");\n+                    println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n+                    self.current = value_pat;\n+                    self.visit_expr(value);\n+                } else {\n+                    println!(\"Ret(None) = {};\", current);\n+                }\n             },\n             ExprKind::InlineAsm(_, ref _input, ref _output) => {\n                 println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n@@ -471,10 +484,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     let base_pat = self.next(\"base\");\n                     println!(\n                         \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n-                        path_pat,\n-                        fields_pat,\n-                        base_pat,\n-                        current\n+                        path_pat, fields_pat, base_pat, current\n                     );\n                     self.current = base_pat;\n                     self.visit_expr(base);\n@@ -512,27 +522,36 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let name_pat = self.next(\"name\");\n                 if let Some(ref sub) = *sub {\n                     let sub_pat = self.next(\"sub\");\n-                    println!(\"Binding({}, _, {}, Some(ref {})) = {};\", anno_pat, name_pat, sub_pat, current);\n+                    println!(\n+                        \"Binding({}, _, {}, Some(ref {})) = {};\",\n+                        anno_pat, name_pat, sub_pat, current\n+                    );\n                     self.current = sub_pat;\n                     self.visit_pat(sub);\n                 } else {\n                     println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n                 }\n                 println!(\"    if {}.node.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n-            }\n+            },\n             PatKind::Struct(ref path, ref fields, ignore) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n-                println!(\"Struct(ref {}, ref {}, {}) = {};\", path_pat, fields_pat, ignore, current);\n+                println!(\n+                    \"Struct(ref {}, ref {}, {}) = {};\",\n+                    path_pat, fields_pat, ignore, current\n+                );\n                 self.current = path_pat;\n                 self.print_qpath(path);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n-            }\n+            },\n             PatKind::TupleStruct(ref path, ref fields, skip_pos) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n-                println!(\"TupleStruct(ref {}, ref {}, {:?}) = {};\", path_pat, fields_pat, skip_pos, current);\n+                println!(\n+                    \"TupleStruct(ref {}, ref {}, {:?}) = {};\",\n+                    path_pat, fields_pat, skip_pos, current\n+                );\n                 self.current = path_pat;\n                 self.print_qpath(path);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n@@ -543,13 +562,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.print_qpath(path);\n-            }\n+            },\n             PatKind::Tuple(ref fields, skip_pos) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n-            }\n+            },\n             PatKind::Box(ref pat) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Box(ref {}) = {};\", pat_pat, current);\n@@ -567,22 +586,28 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n                 self.current = lit_expr_pat;\n                 self.visit_expr(lit_expr);\n-            }\n+            },\n             PatKind::Range(ref start, ref end, end_kind) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n-                println!(\"Range(ref {}, ref {}, RangeEnd::{:?}) = {};\", start_pat, end_pat, end_kind, current);\n+                println!(\n+                    \"Range(ref {}, ref {}, RangeEnd::{:?}) = {};\",\n+                    start_pat, end_pat, end_kind, current\n+                );\n                 self.current = start_pat;\n                 self.visit_expr(start);\n                 self.current = end_pat;\n                 self.visit_expr(end);\n-            }\n+            },\n             PatKind::Slice(ref start, ref middle, ref end) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n                 if let Some(ref middle) = middle {\n                     let middle_pat = self.next(\"middle\");\n-                    println!(\"Slice(ref {}, Some(ref {}), ref {}) = {};\", start_pat, middle_pat, end_pat, current);\n+                    println!(\n+                        \"Slice(ref {}, Some(ref {}), ref {}) = {};\",\n+                        start_pat, middle_pat, end_pat, current\n+                    );\n                     self.current = middle_pat;\n                     self.visit_pat(middle);\n                 } else {\n@@ -598,7 +623,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.current = format!(\"{}[{}]\", end_pat, i);\n                     self.visit_pat(pat);\n                 }\n-            }\n+            },\n         }\n     }\n \n@@ -631,7 +656,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         println!(\"Item(item_id) = {};\", current);\n                     },\n                 }\n-            }\n+            },\n \n             // Expr without trailing semi-colon (must have unit type):\n             StmtKind::Expr(ref e, _) => {\n@@ -666,7 +691,10 @@ fn desugaring_name(des: hir::MatchSource) -> String {\n         hir::MatchSource::TryDesugar => \"MatchSource::TryDesugar\".to_string(),\n         hir::MatchSource::WhileLetDesugar => \"MatchSource::WhileLetDesugar\".to_string(),\n         hir::MatchSource::Normal => \"MatchSource::Normal\".to_string(),\n-        hir::MatchSource::IfLetDesugar { contains_else_clause } => format!(\"MatchSource::IfLetDesugar {{ contains_else_clause: {} }}\", contains_else_clause),\n+        hir::MatchSource::IfLetDesugar { contains_else_clause } => format!(\n+            \"MatchSource::IfLetDesugar {{ contains_else_clause: {} }}\",\n+            contains_else_clause\n+        ),\n     }\n }\n \n@@ -680,13 +708,15 @@ fn loop_desugaring_name(des: hir::LoopSource) -> &'static str {\n \n fn print_path(path: &QPath, first: &mut bool) {\n     match *path {\n-        QPath::Resolved(_, ref path) => for segment in &path.segments {\n-            if *first {\n-                *first = false;\n-            } else {\n-                print!(\", \");\n+        QPath::Resolved(_, ref path) => {\n+            for segment in &path.segments {\n+                if *first {\n+                    *first = false;\n+                } else {\n+                    print!(\", \");\n+                }\n+                print!(\"{:?}\", segment.ident.as_str());\n             }\n-            print!(\"{:?}\", segment.ident.as_str());\n         },\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             hir::TyKind::Path(ref inner_path) => {"}, {"sha": "f58f3e3b98aff3edacca427516a93134d7b4492d", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n /// Return the index of the character after the first camel-case component of\n /// `s`.\n pub fn until(s: &str) -> usize {"}, {"sha": "05636e3234b46f9251ff13c51f8e2d6f60f508fb", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Utility functions about comparison operators.\n \n #![deny(clippy::missing_docs_in_private_items)]"}, {"sha": "aa302500abfcf1a1c17cb66b7691eb2fd14dc865", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,18 +7,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Read configurations files.\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n+use crate::syntax::{ast, source_map};\n use lazy_static::lazy_static;\n use std::default::Default;\n-use std::{env, fmt, fs, io, path};\n use std::io::Read;\n-use crate::syntax::{ast, source_map};\n-use toml;\n use std::sync::Mutex;\n+use std::{env, fmt, fs, io, path};\n+use toml;\n \n /// Get the configuration file from arguments.\n pub fn file_from_args(\n@@ -30,10 +29,12 @@ pub fn file_from_args(\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n                     Err((\"`conf_file` must be a named value\", arg.span))\n                 },\n-                ast::MetaItemKind::NameValue(ref value) => if let ast::LitKind::Str(ref file, _) = value.node {\n-                    Ok(Some(file.to_string().into()))\n-                } else {\n-                    Err((\"`conf_file` value must be a string\", value.span))\n+                ast::MetaItemKind::NameValue(ref value) => {\n+                    if let ast::LitKind::Str(ref file, _) = value.node {\n+                        Ok(Some(file.to_string().into()))\n+                    } else {\n+                        Err((\"`conf_file` value must be a string\", value.span))\n+                    }\n                 },\n             };\n         }\n@@ -179,8 +180,10 @@ pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n                 Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n                 // Return the error if it's something other than `NotFound`; otherwise we didn't\n                 // find the project file yet, and continue searching.\n-                Err(e) => if e.kind() != io::ErrorKind::NotFound {\n-                    return Err(e);\n+                Err(e) => {\n+                    if e.kind() != io::ErrorKind::NotFound {\n+                        return Err(e);\n+                    }\n                 },\n                 _ => (),\n             }\n@@ -223,25 +226,14 @@ pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n         Err(err) => return default(vec![err.into()]),\n     };\n \n-    assert!(\n-        ERRORS\n-            .lock()\n-            .expect(\"no threading -> mutex always safe\")\n-            .is_empty()\n-    );\n+    assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n     match toml::from_str(&file) {\n         Ok(toml) => (\n             toml,\n-            ERRORS\n-                .lock()\n-                .expect(\"no threading -> mutex always safe\")\n-                .split_off(0),\n+            ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0),\n         ),\n         Err(e) => {\n-            let mut errors = ERRORS\n-                .lock()\n-                .expect(\"no threading -> mutex always safe\")\n-                .split_off(0);\n+            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n             errors.push(Error::Toml(e.to_string()));\n             default(errors)\n         },"}, {"sha": "dde70d8e2ccde14b2195461a1118d925136c1b37", "filename": "clippy_lints/src/utils/constants.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! This module contains some useful constants.\n \n #![deny(clippy::missing_docs_in_private_items)]\n@@ -18,21 +17,6 @@\n ///\n /// [reference-types]: https://doc.rust-lang.org/reference/types.html\n pub const BUILTIN_TYPES: &[&str] = &[\n-    \"i8\",\n-    \"u8\",\n-    \"i16\",\n-    \"u16\",\n-    \"i32\",\n-    \"u32\",\n-    \"i64\",\n-    \"u64\",\n-    \"i128\",\n-    \"u128\",\n-    \"isize\",\n-    \"usize\",\n-    \"f32\",\n-    \"f64\",\n-    \"bool\",\n-    \"str\",\n-    \"char\",\n+    \"i8\", \"u8\", \"i16\", \"u16\", \"i32\", \"u32\", \"i64\", \"u64\", \"i128\", \"u128\", \"isize\", \"usize\", \"f32\", \"f64\", \"bool\",\n+    \"str\", \"char\",\n ];"}, {"sha": "992a3321c70079a615a255d97ebbfbf764b0adba", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,17 +7,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! This module contains functions for retrieve the original AST from lowered\n //! `hir`.\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use if_chain::if_chain;\n-use crate::rustc::{hir, ty};\n use crate::rustc::lint::LateContext;\n+use crate::rustc::{hir, ty};\n use crate::syntax::ast;\n use crate::utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, resolve_node};\n+use if_chain::if_chain;\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n@@ -64,7 +63,6 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         Some(expr)\n     }\n \n-\n     let def_path = match cx.tables.expr_ty(expr).sty {\n         ty::Adt(def, _) => cx.tcx.def_path(def.did),\n         _ => return None,\n@@ -109,47 +107,51 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n                 None\n             }\n         },\n-        hir::ExprKind::Call(ref path, ref args) => if let hir::ExprKind::Path(ref path) = path.node {\n-            if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW) {\n+        hir::ExprKind::Call(ref path, ref args) => {\n+            if let hir::ExprKind::Path(ref path) = path.node {\n+                if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW)\n+                {\n+                    Some(Range {\n+                        start: Some(&args[0]),\n+                        end: Some(&args[1]),\n+                        limits: ast::RangeLimits::Closed,\n+                    })\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            }\n+        },\n+        hir::ExprKind::Struct(ref path, ref fields, None) => {\n+            if match_qpath(path, &paths::RANGE_FROM_STD) || match_qpath(path, &paths::RANGE_FROM) {\n+                Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n+                Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n+            {\n                 Some(Range {\n-                    start: Some(&args[0]),\n-                    end: Some(&args[1]),\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n                     limits: ast::RangeLimits::Closed,\n                 })\n+            } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n+                Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n             } else {\n                 None\n             }\n-        } else {\n-            None\n-        },\n-        hir::ExprKind::Struct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n-            || match_qpath(path, &paths::RANGE_FROM)\n-        {\n-            Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            })\n-        } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n-            Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            })\n-        } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE) {\n-            Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::Closed,\n-            })\n-        } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n-            Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            })\n-        } else {\n-            None\n         },\n         _ => None,\n     }\n@@ -161,7 +163,7 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     //\n     // ```\n     // for x in some_vec {\n-    //   // do stuff\n+    //     // do stuff\n     // }\n     // ```\n     if_chain! {\n@@ -178,7 +180,7 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     //\n     // ```\n     // for _ in vec![()] {\n-    //   // anything\n+    //     // anything\n     // }\n     // ```\n     if_chain! {"}, {"sha": "27f49e72b33d104a2729e002e2155414b794f02e", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 63, "deletions": 46, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,16 +7,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::consts::{constant_simple, constant_context};\n-use crate::rustc::lint::LateContext;\n+use crate::consts::{constant_context, constant_simple};\n use crate::rustc::hir::*;\n-use crate::rustc::ty::{TypeckTables};\n-use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n+use crate::rustc::lint::LateContext;\n+use crate::rustc::ty::TypeckTables;\n use crate::syntax::ast::Name;\n use crate::syntax::ptr::P;\n use crate::utils::differing_macro_contexts;\n+use std::collections::hash_map::DefaultHasher;\n+use std::hash::{Hash, Hasher};\n \n /// Type used to check whether two ast are the same. This is different from the\n /// operator\n@@ -60,9 +59,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     false\n                 }\n             },\n-            (&StmtKind::Expr(ref l, _), &StmtKind::Expr(ref r, _)) | (&StmtKind::Semi(ref l, _), &StmtKind::Semi(ref r, _)) => {\n-                self.eq_expr(l, r)\n-            },\n+            (&StmtKind::Expr(ref l, _), &StmtKind::Expr(ref r, _))\n+            | (&StmtKind::Semi(ref l, _), &StmtKind::Semi(ref r, _)) => self.eq_expr(l, r),\n             _ => false,\n         }\n     }\n@@ -79,18 +77,25 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             return false;\n         }\n \n-        if let (Some(l), Some(r)) = (constant_simple(self.cx, self.tables, left), constant_simple(self.cx, self.tables, right)) {\n+        if let (Some(l), Some(r)) = (\n+            constant_simple(self.cx, self.tables, left),\n+            constant_simple(self.cx, self.tables, right),\n+        ) {\n             if l == r {\n                 return true;\n             }\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n+            (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => {\n+                l_mut == r_mut && self.eq_expr(le, re)\n+            },\n             (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprKind::Assign(ref ll, ref lr), &ExprKind::Assign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n+            (&ExprKind::Assign(ref ll, ref lr), &ExprKind::Assign(ref rl, ref rr)) => {\n+                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n@@ -109,12 +114,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::Call(ref l_fun, ref l_args), &ExprKind::Call(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt)) |\n-            (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n+            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n+            | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n+                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n+            },\n             (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => {\n+                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n+            },\n             (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n@@ -123,10 +132,13 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n-                ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                        && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n-                })\n+                ls == rs\n+                    && self.eq_expr(le, re)\n+                    && over(la, ra, |l, r| {\n+                        self.eq_expr(&l.body, &r.body)\n+                            && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n+                            && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                    })\n             },\n             (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n@@ -142,14 +154,17 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r))\n+                self.eq_qpath(l_path, r_path)\n+                    && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n             (&ExprKind::Tup(ref l_tup), &ExprKind::Tup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprKind::Array(ref l), &ExprKind::Array(ref r)) => self.eq_exprs(l, r),\n             (&ExprKind::While(ref lc, ref lb, ref ll), &ExprKind::While(ref rc, ref rb, ref rl)) => {\n-                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n+                self.eq_expr(lc, rc)\n+                    && self.eq_block(lb, rb)\n+                    && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             _ => false,\n         }\n@@ -201,7 +216,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n-                over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r))\n+                over(ls, rs, |l, r| self.eq_pat(l, r))\n+                    && over(le, re, |l, r| self.eq_pat(l, r))\n                     && both(li, ri, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Wild, &PatKind::Wild) => true,\n@@ -233,11 +249,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n             over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n-                && both(\n-                    &Some(&left.bindings[0].ty),\n-                    &Some(&right.bindings[0].ty),\n-                    |l, r| self.eq_ty(l, r),\n-                )\n+                && both(&Some(&left.bindings[0].ty), &Some(&right.bindings[0].ty), |l, r| {\n+                    self.eq_ty(l, r)\n+                })\n         } else {\n             false\n         }\n@@ -283,7 +297,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.tables = full_table;\n                 eq_ty && ll == rl\n             },\n-            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n+            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n+                l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n+            },\n             (&TyKind::Rptr(_, ref l_rmut), &TyKind::Rptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             },\n@@ -301,24 +317,24 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOpKind, &'a Expr, &'a Expr)> {\n     match binop {\n-        BinOpKind::Add |\n-        BinOpKind::Mul |\n-        BinOpKind::Eq |\n-        BinOpKind::Ne |\n-        BinOpKind::BitAnd |\n-        BinOpKind::BitXor |\n-        BinOpKind::BitOr => Some((binop, rhs, lhs)),\n+        BinOpKind::Add\n+        | BinOpKind::Mul\n+        | BinOpKind::Eq\n+        | BinOpKind::Ne\n+        | BinOpKind::BitAnd\n+        | BinOpKind::BitXor\n+        | BinOpKind::BitOr => Some((binop, rhs, lhs)),\n         BinOpKind::Lt => Some((BinOpKind::Gt, rhs, lhs)),\n         BinOpKind::Le => Some((BinOpKind::Ge, rhs, lhs)),\n         BinOpKind::Ge => Some((BinOpKind::Le, rhs, lhs)),\n         BinOpKind::Gt => Some((BinOpKind::Lt, rhs, lhs)),\n-        BinOpKind::Shl |\n-        BinOpKind::Shr |\n-        BinOpKind::Rem |\n-        BinOpKind::Sub |\n-        BinOpKind::Div |\n-        BinOpKind::And |\n-        BinOpKind::Or => None,\n+        BinOpKind::Shl\n+        | BinOpKind::Shr\n+        | BinOpKind::Rem\n+        | BinOpKind::Sub\n+        | BinOpKind::Div\n+        | BinOpKind::And\n+        | BinOpKind::Or => None,\n     }\n }\n \n@@ -340,7 +356,6 @@ where\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n-\n /// Type used to hash an ast element. This is different from the `Hash` trait\n /// on ast types as this\n /// trait would consider IDs and spans.\n@@ -380,7 +395,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             BlockCheckMode::UnsafeBlock(_) => 1,\n             BlockCheckMode::PushUnsafeBlock(_) => 2,\n             BlockCheckMode::PopUnsafeBlock(_) => 3,\n-        }.hash(&mut self.s);\n+        }\n+        .hash(&mut self.s);\n     }\n \n     #[allow(clippy::many_single_char_names)]\n@@ -466,7 +482,8 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 match cap {\n                     CaptureClause::CaptureByValue => 0,\n                     CaptureClause::CaptureByRef => 1,\n-                }.hash(&mut self.s);\n+                }\n+                .hash(&mut self.s);\n                 self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n@@ -661,7 +678,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = Guard::If;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n-            }\n+            },\n         }\n     }\n }"}, {"sha": "7297db4283beacc82089ed274c692e9460572c3b", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! checks for attributes\n \n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir;\n use crate::rustc::hir::print;\n+use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::Attribute;\n use crate::utils::get_attr;\n \n@@ -413,7 +412,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n         },\n         hir::ItemKind::TraitAlias(..) => {\n             println!(\"trait alias\");\n-        }\n+        },\n         hir::ItemKind::Impl(_, _, _, _, Some(ref _trait_ref), _, _) => {\n             println!(\"trait impl\");\n         },\n@@ -533,6 +532,6 @@ fn print_guard(cx: &LateContext<'_, '_>, guard: &hir::Guard, indent: usize) {\n         hir::Guard::If(expr) => {\n             println!(\"{}If\", ind);\n             print_expr(cx, expr, indent + 1);\n-        }\n+        },\n     }\n }"}, {"sha": "5855ef672c2d8d487a2ad419a6fe7fbb62a14808", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,22 +7,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use crate::utils::{\n-    match_def_path, match_type, paths, span_help_and_lint, span_lint, span_lint_and_sugg, walk_ptrs_ty,\n-};\n-use if_chain::if_chain;\n use crate::rustc::hir;\n+use crate::rustc::hir::def::Def;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::hir::*;\n-use crate::rustc::hir::def::Def;\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use crate::rustc_errors::Applicability;\n use crate::rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::rustc_errors::Applicability;\n use crate::syntax::ast::{Crate as AstCrate, Ident, ItemKind, Name};\n use crate::syntax::source_map::Span;\n use crate::syntax::symbol::LocalInternedString;\n+use crate::utils::{\n+    match_def_path, match_type, paths, span_help_and_lint, span_lint, span_lint_and_sugg, walk_ptrs_ty,\n+};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for various things we like to keep tidy in clippy.\n ///\n@@ -112,18 +111,9 @@ impl LintPass for Clippy {\n \n impl EarlyLintPass for Clippy {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &AstCrate) {\n-        if let Some(utils) = krate\n-            .module\n-            .items\n-            .iter()\n-            .find(|item| item.ident.name == \"utils\")\n-        {\n+        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name == \"utils\") {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n-                if let Some(paths) = utils_mod\n-                    .items\n-                    .iter()\n-                    .find(|item| item.ident.name == \"paths\")\n-                {\n+                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name == \"paths\") {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<LocalInternedString> = None;\n                         for item in &paths_mod.items {\n@@ -218,7 +208,8 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &Ty) -> bool {\n             ty: ref inner,\n             mutbl: MutImmutable,\n         },\n-    ) = ty.node {\n+    ) = ty.node\n+    {\n         if let TyKind::Path(ref path) = inner.node {\n             if let Def::Struct(def_id) = cx.tables.qpath_def(path, inner.hir_id) {\n                 return match_def_path(cx.tcx, def_id, &paths::LINT);\n@@ -272,9 +263,11 @@ impl EarlyLintPass for DefaultHashTypes {\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         let ident_string = ident.to_string();\n         if let Some(replace) = self.map.get(&ident_string) {\n-            let msg = format!(\"Prefer {} over {}, it has better performance \\\n-                              and we don't need any collision prevention in clippy\",\n-                              replace, ident_string);\n+            let msg = format!(\n+                \"Prefer {} over {}, it has better performance \\\n+                 and we don't need any collision prevention in clippy\",\n+                replace, ident_string\n+            );\n             span_lint_and_sugg(\n                 cx,\n                 DEFAULT_HASH_TYPES,"}, {"sha": "69a2500a1e12d02383354353f515984309dc4ebd", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! This module contains paths to types and functions Clippy needs to know\n //! about.\n "}, {"sha": "c9595ca5f5095d50f5f11a55db4ec8a98ccd08f6", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,14 +7,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use std::borrow::Cow;\n-use crate::rustc::hir::*;\n use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::hir::*;\n use crate::rustc::lint::LateContext;\n use crate::syntax::ast::Name;\n use crate::syntax::source_map::Span;\n use crate::utils::{get_pat_name, match_var, snippet};\n+use std::borrow::Cow;\n \n pub fn get_spans(\n     cx: &LateContext<'_, '_>,\n@@ -23,8 +22,10 @@ pub fn get_spans(\n     replacements: &'static [(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n-        get_binding_name(&body.arguments[idx])\n-            .map_or_else(|| Some(vec![]), |name| extract_clone_suggestions(cx, name, replacements, body))\n+        get_binding_name(&body.arguments[idx]).map_or_else(\n+            || Some(vec![]),\n+            |name| extract_clone_suggestions(cx, name, replacements, body),\n+        )\n     } else {\n         Some(vec![])\n     }"}, {"sha": "c5f4a61fe8c80cec423537b523a3e1bba969a16b", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 126, "deletions": 133, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,26 +7,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use matches::matches;\n use crate::rustc::hir;\n use crate::rustc::lint::{EarlyContext, LateContext, LintContext};\n use crate::rustc_errors;\n-use std::borrow::Cow;\n-use std::convert::TryInto;\n-use std::fmt::Display;\n-use std;\n-use crate::syntax::source_map::{CharPos, Span};\n+use crate::rustc_errors::Applicability;\n+use crate::syntax::ast;\n use crate::syntax::parse::token;\n use crate::syntax::print::pprust::token_to_string;\n+use crate::syntax::source_map::{CharPos, Span};\n use crate::syntax::util::parser::AssocOp;\n-use crate::syntax::ast;\n-use crate::utils::{higher, in_macro, snippet, snippet_opt};\n use crate::syntax_pos::{BytePos, Pos};\n-use crate::rustc_errors::Applicability;\n+use crate::utils::{higher, in_macro, snippet, snippet_opt};\n+use matches::matches;\n+use std;\n+use std::borrow::Cow;\n+use std::convert::TryInto;\n+use std::fmt::Display;\n \n /// A helper type to build suggestion correctly handling parenthesis.\n pub enum Sugg<'a> {\n@@ -57,30 +56,30 @@ impl<'a> Sugg<'a> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n-                hir::ExprKind::AddrOf(..) |\n-                hir::ExprKind::Box(..) |\n-                hir::ExprKind::Closure(.., _) |\n-                hir::ExprKind::If(..) |\n-                hir::ExprKind::Unary(..) |\n-                hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprKind::Continue(..) |\n-                hir::ExprKind::Yield(..) |\n-                hir::ExprKind::Array(..) |\n-                hir::ExprKind::Block(..) |\n-                hir::ExprKind::Break(..) |\n-                hir::ExprKind::Call(..) |\n-                hir::ExprKind::Field(..) |\n-                hir::ExprKind::Index(..) |\n-                hir::ExprKind::InlineAsm(..) |\n-                hir::ExprKind::Lit(..) |\n-                hir::ExprKind::Loop(..) |\n-                hir::ExprKind::MethodCall(..) |\n-                hir::ExprKind::Path(..) |\n-                hir::ExprKind::Repeat(..) |\n-                hir::ExprKind::Ret(..) |\n-                hir::ExprKind::Struct(..) |\n-                hir::ExprKind::Tup(..) |\n-                hir::ExprKind::While(..) => Sugg::NonParen(snippet),\n+                hir::ExprKind::AddrOf(..)\n+                | hir::ExprKind::Box(..)\n+                | hir::ExprKind::Closure(.., _)\n+                | hir::ExprKind::If(..)\n+                | hir::ExprKind::Unary(..)\n+                | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+                hir::ExprKind::Continue(..)\n+                | hir::ExprKind::Yield(..)\n+                | hir::ExprKind::Array(..)\n+                | hir::ExprKind::Block(..)\n+                | hir::ExprKind::Break(..)\n+                | hir::ExprKind::Call(..)\n+                | hir::ExprKind::Field(..)\n+                | hir::ExprKind::Index(..)\n+                | hir::ExprKind::InlineAsm(..)\n+                | hir::ExprKind::Lit(..)\n+                | hir::ExprKind::Loop(..)\n+                | hir::ExprKind::MethodCall(..)\n+                | hir::ExprKind::Path(..)\n+                | hir::ExprKind::Repeat(..)\n+                | hir::ExprKind::Ret(..)\n+                | hir::ExprKind::Struct(..)\n+                | hir::ExprKind::Tup(..)\n+                | hir::ExprKind::While(..) => Sugg::NonParen(snippet),\n                 hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n                 hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n                 hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n@@ -100,7 +99,8 @@ impl<'a> Sugg<'a> {\n     ///\n     /// - Applicability level `Unspecified` will never be changed.\n     /// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n-    /// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n+    /// - If the default value is used and the applicability level is `MachineApplicable`, change it\n+    ///   to\n     /// `HasPlaceholders`\n     pub fn hir_with_applicability(\n         cx: &LateContext<'_, '_>,\n@@ -126,39 +126,39 @@ impl<'a> Sugg<'a> {\n         let snippet = snippet(cx, expr.span, default);\n \n         match expr.node {\n-            ast::ExprKind::AddrOf(..) |\n-            ast::ExprKind::Box(..) |\n-            ast::ExprKind::Closure(..) |\n-            ast::ExprKind::If(..) |\n-            ast::ExprKind::IfLet(..) |\n-            ast::ExprKind::ObsoleteInPlace(..) |\n-            ast::ExprKind::Unary(..) |\n-            ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n-            ast::ExprKind::Async(..) |\n-            ast::ExprKind::Block(..) |\n-            ast::ExprKind::Break(..) |\n-            ast::ExprKind::Call(..) |\n-            ast::ExprKind::Continue(..) |\n-            ast::ExprKind::Yield(..) |\n-            ast::ExprKind::Field(..) |\n-            ast::ExprKind::ForLoop(..) |\n-            ast::ExprKind::Index(..) |\n-            ast::ExprKind::InlineAsm(..) |\n-            ast::ExprKind::Lit(..) |\n-            ast::ExprKind::Loop(..) |\n-            ast::ExprKind::Mac(..) |\n-            ast::ExprKind::MethodCall(..) |\n-            ast::ExprKind::Paren(..) |\n-            ast::ExprKind::Path(..) |\n-            ast::ExprKind::Repeat(..) |\n-            ast::ExprKind::Ret(..) |\n-            ast::ExprKind::Struct(..) |\n-            ast::ExprKind::Try(..) |\n-            ast::ExprKind::TryBlock(..) |\n-            ast::ExprKind::Tup(..) |\n-            ast::ExprKind::Array(..) |\n-            ast::ExprKind::While(..) |\n-            ast::ExprKind::WhileLet(..) => Sugg::NonParen(snippet),\n+            ast::ExprKind::AddrOf(..)\n+            | ast::ExprKind::Box(..)\n+            | ast::ExprKind::Closure(..)\n+            | ast::ExprKind::If(..)\n+            | ast::ExprKind::IfLet(..)\n+            | ast::ExprKind::ObsoleteInPlace(..)\n+            | ast::ExprKind::Unary(..)\n+            | ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            ast::ExprKind::Async(..)\n+            | ast::ExprKind::Block(..)\n+            | ast::ExprKind::Break(..)\n+            | ast::ExprKind::Call(..)\n+            | ast::ExprKind::Continue(..)\n+            | ast::ExprKind::Yield(..)\n+            | ast::ExprKind::Field(..)\n+            | ast::ExprKind::ForLoop(..)\n+            | ast::ExprKind::Index(..)\n+            | ast::ExprKind::InlineAsm(..)\n+            | ast::ExprKind::Lit(..)\n+            | ast::ExprKind::Loop(..)\n+            | ast::ExprKind::Mac(..)\n+            | ast::ExprKind::MethodCall(..)\n+            | ast::ExprKind::Paren(..)\n+            | ast::ExprKind::Path(..)\n+            | ast::ExprKind::Repeat(..)\n+            | ast::ExprKind::Ret(..)\n+            | ast::ExprKind::Struct(..)\n+            | ast::ExprKind::Try(..)\n+            | ast::ExprKind::TryBlock(..)\n+            | ast::ExprKind::Tup(..)\n+            | ast::ExprKind::Array(..)\n+            | ast::ExprKind::While(..)\n+            | ast::ExprKind::WhileLet(..) => Sugg::NonParen(snippet),\n             ast::ExprKind::Range(.., RangeLimits::HalfOpen) => Sugg::BinOp(AssocOp::DotDot, snippet),\n             ast::ExprKind::Range(.., RangeLimits::Closed) => Sugg::BinOp(AssocOp::DotDotEq, snippet),\n             ast::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n@@ -225,10 +225,12 @@ impl<'a> Sugg<'a> {\n         match self {\n             Sugg::NonParen(..) => self,\n             // (x) and (x).y() both don't need additional parens\n-            Sugg::MaybeParen(sugg) => if sugg.starts_with('(') && sugg.ends_with(')') {\n-                Sugg::MaybeParen(sugg)\n-            } else {\n-                Sugg::NonParen(format!(\"({})\", sugg).into())\n+            Sugg::MaybeParen(sugg) => {\n+                if sugg.starts_with('(') && sugg.ends_with(')') {\n+                    Sugg::MaybeParen(sugg)\n+                } else {\n+                    Sugg::NonParen(format!(\"({})\", sugg).into())\n+                }\n             },\n             Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n         }\n@@ -267,10 +269,7 @@ struct ParenHelper<T> {\n impl<T> ParenHelper<T> {\n     /// Build a `ParenHelper`.\n     fn new(paren: bool, wrapped: T) -> Self {\n-        Self {\n-            paren,\n-            wrapped,\n-        }\n+        Self { paren, wrapped }\n     }\n }\n \n@@ -320,7 +319,8 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n             || (other.precedence() == op.precedence()\n                 && ((op != other && associativity(op) != dir)\n                     || (op == other && associativity(op) != Associativity::Both)))\n-            || is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n+            || is_shift(op) && is_arith(other)\n+            || is_shift(other) && is_arith(op)\n     }\n \n     let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n@@ -338,24 +338,29 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n     let lhs = ParenHelper::new(lhs_paren, lhs);\n     let rhs = ParenHelper::new(rhs_paren, rhs);\n     let sugg = match op {\n-        AssocOp::Add |\n-        AssocOp::BitAnd |\n-        AssocOp::BitOr |\n-        AssocOp::BitXor |\n-        AssocOp::Divide |\n-        AssocOp::Equal |\n-        AssocOp::Greater |\n-        AssocOp::GreaterEqual |\n-        AssocOp::LAnd |\n-        AssocOp::LOr |\n-        AssocOp::Less |\n-        AssocOp::LessEqual |\n-        AssocOp::Modulus |\n-        AssocOp::Multiply |\n-        AssocOp::NotEqual |\n-        AssocOp::ShiftLeft |\n-        AssocOp::ShiftRight |\n-        AssocOp::Subtract => format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs),\n+        AssocOp::Add\n+        | AssocOp::BitAnd\n+        | AssocOp::BitOr\n+        | AssocOp::BitXor\n+        | AssocOp::Divide\n+        | AssocOp::Equal\n+        | AssocOp::Greater\n+        | AssocOp::GreaterEqual\n+        | AssocOp::LAnd\n+        | AssocOp::LOr\n+        | AssocOp::Less\n+        | AssocOp::LessEqual\n+        | AssocOp::Modulus\n+        | AssocOp::Multiply\n+        | AssocOp::NotEqual\n+        | AssocOp::ShiftLeft\n+        | AssocOp::ShiftRight\n+        | AssocOp::Subtract => format!(\n+            \"{} {} {}\",\n+            lhs,\n+            op.to_ast_binop().expect(\"Those are AST ops\").to_string(),\n+            rhs\n+        ),\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::ObsoleteInPlace => format!(\"in ({}) {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, token_to_string(&token::BinOp(op)), rhs),\n@@ -400,17 +405,8 @@ fn associativity(op: &AssocOp) -> Associativity {\n     match *op {\n         ObsoleteInPlace | Assign | AssignOp(_) => Associativity::Right,\n         Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n-        Divide |\n-        Equal |\n-        Greater |\n-        GreaterEqual |\n-        Less |\n-        LessEqual |\n-        Modulus |\n-        NotEqual |\n-        ShiftLeft |\n-        ShiftRight |\n-        Subtract => Associativity::Left,\n+        Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight\n+        | Subtract => Associativity::Left,\n         DotDot | DotDotEq => Associativity::None,\n     }\n }\n@@ -431,15 +427,14 @@ fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n         hir::BinOpKind::Shr => Shr,\n         hir::BinOpKind::Sub => Minus,\n \n-        | hir::BinOpKind::And\n+        hir::BinOpKind::And\n         | hir::BinOpKind::Eq\n         | hir::BinOpKind::Ge\n         | hir::BinOpKind::Gt\n         | hir::BinOpKind::Le\n         | hir::BinOpKind::Lt\n         | hir::BinOpKind::Ne\n-        | hir::BinOpKind::Or\n-        => panic!(\"This operator does not exist\"),\n+        | hir::BinOpKind::Or => panic!(\"This operator does not exist\"),\n     })\n }\n \n@@ -467,9 +462,7 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n /// before it on its line.\n fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n-    if let Some(line) = lo.file\n-        .get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */)\n-    {\n+    if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n             // we can mix char and byte positions here because we only consider `[ \\t]`\n             if lo.col == CharPos(pos) {\n@@ -496,7 +489,14 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n     /// ```rust,ignore\n     /// db.suggest_item_with_attr(cx, item, \"#[derive(Default)]\");\n     /// ```\n-    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D, applicability: Applicability);\n+    fn suggest_item_with_attr<D: Display + ?Sized>(\n+        &mut self,\n+        cx: &T,\n+        item: Span,\n+        msg: &str,\n+        attr: &D,\n+        applicability: Applicability,\n+    );\n \n     /// Suggest to add an item before another.\n     ///\n@@ -527,16 +527,18 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n }\n \n impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n-    fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D, applicability: Applicability) {\n+    fn suggest_item_with_attr<D: Display + ?Sized>(\n+        &mut self,\n+        cx: &T,\n+        item: Span,\n+        msg: &str,\n+        attr: &D,\n+        applicability: Applicability,\n+    ) {\n         if let Some(indent) = indentation(cx, item) {\n             let span = item.with_hi(item.lo());\n \n-            self.span_suggestion_with_applicability(\n-                        span,\n-                        msg,\n-                        format!(\"{}\\n{}\", attr, indent),\n-                        applicability,\n-                        );\n+            self.span_suggestion_with_applicability(span, msg, format!(\"{}\\n{}\", attr, indent), applicability);\n         }\n     }\n \n@@ -557,12 +559,7 @@ impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_error\n                 })\n                 .collect::<String>();\n \n-            self.span_suggestion_with_applicability(\n-                        span,\n-                        msg,\n-                        format!(\"{}\\n{}\", new_item, indent),\n-                        applicability,\n-                        );\n+            self.span_suggestion_with_applicability(span, msg, format!(\"{}\\n{}\", new_item, indent), applicability);\n         }\n     }\n \n@@ -575,15 +572,11 @@ impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_error\n             let non_whitespace_offset = src[fmpos.pos.to_usize()..].find(|c| c != ' ' && c != '\\t' && c != '\\n');\n \n             if let Some(non_whitespace_offset) = non_whitespace_offset {\n-                remove_span = remove_span.with_hi(remove_span.hi() + BytePos(non_whitespace_offset.try_into().expect(\"offset too large\")))\n+                remove_span = remove_span\n+                    .with_hi(remove_span.hi() + BytePos(non_whitespace_offset.try_into().expect(\"offset too large\")))\n             }\n         }\n \n-        self.span_suggestion_with_applicability(\n-            remove_span,\n-            msg,\n-            String::new(),\n-            applicability,\n-        );\n+        self.span_suggestion_with_applicability(remove_span, msg, String::new(), applicability);\n     }\n }"}, {"sha": "31aa4b6fb5a0cbbfe295c0dedadc17877389f69a", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::LateContext;\n \n use crate::rustc::hir::def::Def;"}, {"sha": "7d09c20db2749a389c65ff770694cec9a979dd2e", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::consts::constant;\n use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -90,12 +89,14 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n                 return;\n             }\n         },\n-        higher::VecArgs::Vec(args) => if let Some(last) = args.iter().last() {\n-            let span = args[0].span.to(last.span);\n+        higher::VecArgs::Vec(args) => {\n+            if let Some(last) = args.iter().last() {\n+                let span = args[0].span.to(last.span);\n \n-            format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n-        } else {\n-            \"&[]\".into()\n+                format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+            } else {\n+                \"&[]\".into()\n+            }\n         },\n     };\n "}, {"sha": "440ab7433cc83e630b9d62e7d545b1585f1d0f8e", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,7 +7,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc_errors::Applicability;\n@@ -336,9 +335,11 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                 let mut seen = false;\n                 for arg in &args {\n                     match arg.position {\n-                        ArgumentImplicitlyIs(n) | ArgumentIs(n) => if n == idx {\n-                            all_simple &= arg.format == SIMPLE;\n-                            seen = true;\n+                        ArgumentImplicitlyIs(n) | ArgumentIs(n) => {\n+                            if n == idx {\n+                                all_simple &= arg.format == SIMPLE;\n+                                seen = true;\n+                            }\n                         },\n                         ArgumentNamed(_) => {},\n                     }\n@@ -356,9 +357,11 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n                         for arg in &args {\n                             match arg.position {\n                                 ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n-                                ArgumentNamed(name) => if *p == name {\n-                                    seen = true;\n-                                    all_simple &= arg.format == SIMPLE;\n+                                ArgumentNamed(name) => {\n+                                    if *p == name {\n+                                        seen = true;\n+                                        all_simple &= arg.format == SIMPLE;\n+                                    }\n                                 },\n                             }\n                         }"}, {"sha": "20a92012520c5bbda653e6abfb427bc2e8c2c742", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1751d2496d4241b2a705ed871a8ad3d4402180b5/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=1751d2496d4241b2a705ed871a8ad3d4402180b5", "patch": "@@ -7,13 +7,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use crate::consts::{constant_simple, Constant};\n+use crate::rustc::hir::*;\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n use crate::utils::span_help_and_lint;\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for `0.0 / 0.0`.\n ///"}]}