{"sha": "f1132496dddbdd88f321a7919eec3d65136b3f75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTMyNDk2ZGRkYmRkODhmMzIxYTc5MTllZWMzZDY1MTM2YjNmNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T04:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T04:51:30Z"}, "message": "auto merge of #8590 : blake2-ppc/rust/std-str, r=alexcrichton\n\nImplement CharIterator as a separate struct, so that it can be .clone()'d. Fix `.char_range_at_reverse` so that it performs better, closer to the forwards version. This makes the reverse iterators and users like `.rfind()` perform better.\r\n\r\n    Before\r\n    test str::bench::char_iterator ... bench: 146 ns/iter (+/- 0)\r\n    test str::bench::char_iterator_ascii ... bench: 397 ns/iter (+/- 49)\r\n    test str::bench::char_iterator_rev ... bench: 576 ns/iter (+/- 8)\r\n    test str::bench::char_offset_iterator ... bench: 128 ns/iter (+/- 2)\r\n    test str::bench::char_offset_iterator_rev ... bench: 425 ns/iter (+/- 59)\r\n    \r\n    After\r\n    test str::bench::char_iterator ... bench: 130 ns/iter (+/- 1)\r\n    test str::bench::char_iterator_ascii ... bench: 307 ns/iter (+/- 5)\r\n    test str::bench::char_iterator_rev ... bench: 185 ns/iter (+/- 8)\r\n    test str::bench::char_offset_iterator ... bench: 131 ns/iter (+/- 13)\r\n    test str::bench::char_offset_iterator_rev ... bench: 183 ns/iter (+/- 2)\r\n\r\nTo be able to use a string slice to represent the CharIterator, a function `slice_unchecked` is added, that does the same as `slice_bytes` but without any boundary checks.\r\n\r\nIt would be possible to implement CharIterator with pointer arithmetic to make it *much more efficient*, but since vec iterator is still improving, it's too early to attempt to re-implement it in other places. Hopefully CharIterator can be implemented on top of vec iterator without any unsafe code later.\r\n\r\nAdditional changes fix the documentation about null termination.", "tree": {"sha": "06c11f35f1aa7b99f4c7a3f4f0f6e1294716753c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06c11f35f1aa7b99f4c7a3f4f0f6e1294716753c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1132496dddbdd88f321a7919eec3d65136b3f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1132496dddbdd88f321a7919eec3d65136b3f75", "html_url": "https://github.com/rust-lang/rust/commit/f1132496dddbdd88f321a7919eec3d65136b3f75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1132496dddbdd88f321a7919eec3d65136b3f75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e776c75e9694c2e1711943652c64a5e076afa8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e776c75e9694c2e1711943652c64a5e076afa8f", "html_url": "https://github.com/rust-lang/rust/commit/8e776c75e9694c2e1711943652c64a5e076afa8f"}, {"sha": "93de60e511d15b61a490ed690dee15c923ff9538", "url": "https://api.github.com/repos/rust-lang/rust/commits/93de60e511d15b61a490ed690dee15c923ff9538", "html_url": "https://github.com/rust-lang/rust/commit/93de60e511d15b61a490ed690dee15c923ff9538"}], "stats": {"total": 385, "additions": 254, "deletions": 131}, "files": [{"sha": "d5a44201ce615f4cb57347cf0b35c3287e4253cf", "filename": "src/libstd/str.rs", "status": "modified", "additions": 254, "deletions": 131, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/f1132496dddbdd88f321a7919eec3d65136b3f75/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1132496dddbdd88f321a7919eec3d65136b3f75/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f1132496dddbdd88f321a7919eec3d65136b3f75", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * String manipulation\n- *\n- * Strings are a packed UTF-8 representation of text, stored as null\n- * terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n- * for efficiency, but UTF-8 unsafe operations should be avoided.\n- */\n+//! String manipulation\n+//!\n+//! Strings are a packed UTF-8 representation of text, stored as\n+//! buffers of u8 bytes. The buffer is not null terminated.\n+//! Strings should be indexed in bytes, for efficiency, but UTF-8 unsafe\n+//! operations should be avoided.\n \n use at_vec;\n use cast;\n@@ -24,10 +23,10 @@ use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n-use iterator::{Filter, AdditiveIterator, Map};\n+use iterator::{Filter, AdditiveIterator, Map, Enumerate};\n use iterator::{Invert, DoubleEndedIterator};\n use libc;\n-use num::Zero;\n+use num::{Saturating, Zero};\n use option::{None, Option, Some};\n use ptr;\n use ptr::RawPtr;\n@@ -255,56 +254,101 @@ impl<'self, C: CharEq> CharEq for &'self [C] {\n Section: Iterators\n */\n \n-/// External iterator for a string's characters and their byte offsets.\n+/// External iterator for a string's characters.\n /// Use with the `std::iterator` module.\n #[deriving(Clone)]\n-pub struct CharOffsetIterator<'self> {\n-    priv index_front: uint,\n-    priv index_back: uint,\n+pub struct CharIterator<'self> {\n+    /// The slice remaining to be iterated\n     priv string: &'self str,\n }\n \n-impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n+impl<'self> Iterator<char> for CharIterator<'self> {\n     #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n-        if self.index_front < self.index_back {\n-            let CharRange {ch, next} = self.string.char_range_at(self.index_front);\n-            let index = self.index_front;\n-            self.index_front = next;\n-            Some((index, ch))\n+    fn next(&mut self) -> Option<char> {\n+        // Decode the next codepoint, then update\n+        // the slice to be just the remaining part\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at(0);\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n+            }\n+            Some(ch)\n         } else {\n             None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n+    }\n }\n \n-impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n+impl<'self> DoubleEndedIterator<char> for CharIterator<'self> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n-        if self.index_front < self.index_back {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.index_back);\n-            self.index_back = next;\n-            Some((next, ch))\n+    fn next_back(&mut self) -> Option<char> {\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, 0, next);\n+            }\n+            Some(ch)\n         } else {\n             None\n         }\n     }\n }\n \n-/// External iterator for a string's characters and their byte offsets in reverse order.\n-/// Use with the `std::iterator` module.\n-pub type CharOffsetRevIterator<'self> =\n-    Invert<CharOffsetIterator<'self>>;\n \n-/// External iterator for a string's characters.\n+/// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iterator` module.\n-pub type CharIterator<'self> =\n-    Map<'self, (uint, char), char, CharOffsetIterator<'self>>;\n+#[deriving(Clone)]\n+pub struct CharOffsetIterator<'self> {\n+    /// The original string to be iterated\n+    priv string: &'self str,\n+    priv iter: CharIterator<'self>,\n+}\n+\n+impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, char)> {\n+        // Compute the byte offset by using the pointer offset between\n+        // the original string slice and the iterator's remaining part\n+        let offset = do self.string.as_imm_buf |a, _| {\n+            do self.iter.string.as_imm_buf |b, _| {\n+                b as uint - a as uint\n+            }\n+        };\n+        self.iter.next().map_move(|ch| (offset, ch))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(uint, char)> {\n+        self.iter.next_back().map_move(|ch| {\n+            let offset = do self.string.as_imm_buf |a, _| {\n+                do self.iter.string.as_imm_buf |b, len| {\n+                    b as uint - a as uint + len\n+                }\n+            };\n+            (offset, ch)\n+        })\n+    }\n+}\n \n /// External iterator for a string's characters in reverse order.\n /// Use with the `std::iterator` module.\n-pub type CharRevIterator<'self> =\n-    Invert<Map<'self, (uint, char), char, CharOffsetIterator<'self>>>;\n+pub type CharRevIterator<'self> = Invert<CharIterator<'self>>;\n+\n+/// External iterator for a string's characters and their byte offsets in reverse order.\n+/// Use with the `std::iterator` module.\n+pub type CharOffsetRevIterator<'self> = Invert<CharOffsetIterator<'self>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iterator` module.\n@@ -313,12 +357,20 @@ pub type ByteIterator<'self> =\n \n /// External iterator for a string's bytes in reverse order.\n /// Use with the `std::iterator` module.\n-pub type ByteRevIterator<'self> =\n-    Invert<Map<'self, &'self u8, u8, vec::VecIterator<'self, u8>>>;\n+pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n+\n+/// An iterator over byte index and either &u8 or char\n+#[deriving(Clone)]\n+enum OffsetIterator<'self> {\n+    // use ByteIterator here when it can be cloned\n+    ByteOffset(Enumerate<vec::VecIterator<'self, u8>>),\n+    CharOffset(CharOffsetIterator<'self>),\n+}\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n pub struct CharSplitIterator<'self,Sep> {\n+    priv iter: OffsetIterator<'self>,\n     priv string: &'self str,\n     priv position: uint,\n     priv sep: Sep,\n@@ -327,7 +379,6 @@ pub struct CharSplitIterator<'self,Sep> {\n     /// Whether an empty string at the end is allowed\n     priv allow_trailing_empty: bool,\n     priv finished: bool,\n-    priv only_ascii: bool\n }\n \n /// An iterator over the words of a string, separated by an sequence of whitespace\n@@ -343,39 +394,39 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep>\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n-        let l = self.string.len();\n         let start = self.position;\n-\n-        if self.only_ascii {\n-            // this gives a *huge* speed up for splitting on ASCII\n-            // characters (e.g. '\\n' or ' ')\n-            while self.position < l && self.count > 0 {\n-                let byte = self.string[self.position];\n-\n-                if self.sep.matches(byte as char) {\n-                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n-                    self.position += 1;\n-                    self.count -= 1;\n-                    return Some(slice);\n-                }\n-                self.position += 1;\n-            }\n-        } else {\n-            while self.position < l && self.count > 0 {\n-                let CharRange {ch, next} = self.string.char_range_at(self.position);\n-\n-                if self.sep.matches(ch) {\n-                    let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n-                    self.position = next;\n-                    self.count -= 1;\n-                    return Some(slice);\n-                }\n-                self.position = next;\n+        let len = self.string.len();\n+\n+        if self.count > 0 {\n+            match self.iter {\n+                // this gives a *huge* speed up for splitting on ASCII\n+                // characters (e.g. '\\n' or ' ')\n+                ByteOffset(ref mut iter) =>\n+                    for (idx, &byte) in *iter {\n+                        if self.sep.matches(byte as char) {\n+                            self.position = idx + 1;\n+                            self.count -= 1;\n+                            return Some(unsafe {\n+                                raw::slice_bytes(self.string, start, idx)\n+                            })\n+                        }\n+                    },\n+                CharOffset(ref mut iter) =>\n+                    for (idx, ch) in *iter {\n+                        if self.sep.matches(ch) {\n+                            // skip over the separator\n+                            self.position = self.string.char_range_at(idx).next;\n+                            self.count -= 1;\n+                            return Some(unsafe {\n+                                raw::slice_bytes(self.string, start, idx)\n+                            })\n+                        }\n+                    },\n             }\n         }\n         self.finished = true;\n-        if self.allow_trailing_empty || start < l {\n-            Some(unsafe { raw::slice_bytes(self.string, start, l) })\n+        if self.allow_trailing_empty || start < len {\n+            Some(unsafe { raw::slice_bytes(self.string, start, len) })\n         } else {\n             None\n         }\n@@ -938,12 +989,21 @@ pub mod raw {\n     /// If end is greater than the length of the string.\n     #[inline]\n     pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        do s.as_imm_buf |sbuf, n| {\n-             assert!((begin <= end));\n-             assert!((end <= n));\n+        assert!(begin <= end);\n+        assert!(end <= s.len());\n+        slice_unchecked(s, begin, end)\n+    }\n \n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check slice boundaries!\n+    #[inline]\n+    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n+        do s.as_imm_buf |sbuf, _n| {\n              cast::transmute(Slice {\n-                 data: ptr::offset(sbuf, begin as int),\n+                 data: sbuf.offset_inbounds(begin as int),\n                  len: end - begin,\n              })\n         }\n@@ -1302,7 +1362,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~\n     #[inline]\n     fn iter(&self) -> CharIterator<'self> {\n-        self.char_offset_iter().map(|(_, c)| c)\n+        CharIterator{string: *self}\n     }\n \n     /// An iterator over the characters of `self`, in reverse order.\n@@ -1326,14 +1386,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the characters of `self` and their byte offsets.\n     #[inline]\n     fn char_offset_iter(&self) -> CharOffsetIterator<'self> {\n-        CharOffsetIterator {\n-            index_front: 0,\n-            index_back: self.len(),\n-            string: *self\n-        }\n+        CharOffsetIterator{string: *self, iter: self.iter()}\n     }\n \n-    /// An iterator over the characters of `self` and their byte offsets.\n+    /// An iterator over the characters of `self` and their byte offsets,\n+    /// in reverse order.\n     #[inline]\n     fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self> {\n         self.char_offset_iter().invert()\n@@ -1371,15 +1428,19 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> CharSplitIterator<'self, Sep> {\n-        let only_ascii = sep.only_ascii();\n+        let iter = if sep.only_ascii() {\n+            ByteOffset(self.as_bytes().iter().enumerate())\n+        } else {\n+            CharOffset(self.char_offset_iter())\n+        };\n         CharSplitIterator {\n+            iter: iter,\n             string: *self,\n             position: 0,\n             sep: sep,\n             count: count,\n             allow_trailing_empty: allow_trailing_empty,\n             finished: false,\n-            only_ascii: only_ascii\n         }\n     }\n \n@@ -1481,8 +1542,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// beyond the last character of the string\n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n-        assert!(self.is_char_boundary(begin));\n-        assert!(self.is_char_boundary(end));\n+        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n \n@@ -1502,7 +1562,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// out of bounds.\n     #[inline]\n     fn slice_to(&self, end: uint) -> &'self str {\n-        self.slice(0, end)\n+        assert!(self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, 0, end) }\n     }\n \n     /// Returns a slice of the string from the char range\n@@ -1512,23 +1573,24 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// beyond the last character of the string.\n     fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n         assert!(begin <= end);\n-        // not sure how to use the iterators for this nicely.\n-        let mut position = 0;\n         let mut count = 0;\n-        let l = self.len();\n-        while count < begin && position < l {\n-            position = self.char_range_at(position).next;\n-            count += 1;\n-        }\n-        if count < begin { fail!(\"Attempted to begin slice_chars beyond end of string\") }\n-        let start_byte = position;\n-        while count < end && position < l {\n-            position = self.char_range_at(position).next;\n+        let mut begin_byte = None;\n+        let mut end_byte = None;\n+\n+        // This could be even more efficient by not decoding,\n+        // only finding the char boundaries\n+        for (idx, _) in self.char_offset_iter() {\n+            if count == begin { begin_byte = Some(idx); }\n+            if count == end { end_byte = Some(idx); break; }\n             count += 1;\n         }\n-        if count < end { fail!(\"Attempted to end slice_chars beyond end of string\") }\n+        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n-        self.slice(start_byte, position)\n+        match (begin_byte, end_byte) {\n+            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n+        }\n     }\n \n     /// Returns true if `needle` is a prefix of the string.\n@@ -1724,6 +1786,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Returns false if the index points into the middle of a multi-byte\n     /// character sequence.\n+    #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         let b = self[index];\n@@ -1809,24 +1872,33 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// This function can be used to iterate over a unicode string in reverse.\n     ///\n     /// Returns 0 for next index if called on start index 0.\n+    #[inline]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         let mut prev = start;\n \n-        // while there is a previous byte == 10......\n-        while prev > 0u && self[prev - 1u] & 192u8 == TAG_CONT_U8 {\n-            prev -= 1u;\n-        }\n+        prev = prev.saturating_sub(1);\n+        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n \n-        // now refer to the initial byte of previous char\n-        if prev > 0u {\n-            prev -= 1u;\n-        } else {\n-            prev = 0u;\n-        }\n+        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n+        fn multibyte_char_range_at_rev(s: &str, mut i: uint) -> CharRange {\n+            // while there is a previous byte == 10......\n+            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n+                i -= 1u;\n+            }\n \n+            let mut val = s[i] as uint;\n+            let w = UTF8_CHAR_WIDTH[val] as uint;\n+            assert!((w != 0));\n+\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n \n-        let ch = self.char_at(prev);\n-        return CharRange {ch:ch, next:prev};\n+            return CharRange {ch: val as char, next: i};\n+        }\n+\n+        return multibyte_char_range_at_rev(*self, prev);\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string\n@@ -1836,8 +1908,6 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// The byte slice does not include the null terminator.\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe { cast::transmute(*self) }\n     }\n@@ -1854,10 +1924,8 @@ impl<'self> StrSlice<'self> for &'self str {\n                 if search.matches(b as char) { return Some(i) }\n             }\n         } else {\n-            let mut index = 0;\n-            for c in self.iter() {\n+            for (index, c) in self.char_offset_iter() {\n                 if search.matches(c) { return Some(index); }\n-                index += c.len_utf8_bytes();\n             }\n         }\n \n@@ -1871,15 +1939,14 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// `Some` containing the byte index of the last matching character\n     /// or `None` if there is no match\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n-        let mut index = self.len();\n         if search.only_ascii() {\n+            let mut index = self.len();\n             for b in self.byte_rev_iter() {\n                 index -= 1;\n                 if search.matches(b as char) { return Some(index); }\n             }\n         } else {\n-            for c in self.rev_iter() {\n-                index -= c.len_utf8_bytes();\n+            for (index, c) in self.char_offset_rev_iter() {\n                 if search.matches(c) { return Some(index); }\n             }\n         }\n@@ -2020,10 +2087,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Work with the byte buffer and length of a slice.\n     ///\n-    /// The given length is one byte longer than the 'official' indexable\n-    /// length of the string. This is to permit probing the byte past the\n-    /// indexable area for a null byte, as is the case in slices pointing\n-    /// to full strings, or suffixes of them.\n+    /// The buffer does not have a null terminator.\n     #[inline]\n     fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n@@ -2046,12 +2110,10 @@ pub trait OwnedStr {\n \n     /// Work with the mutable byte buffer and length of a slice.\n     ///\n-    /// The given length is one byte longer than the 'official' indexable\n-    /// length of the string. This is to permit probing the byte past the\n-    /// indexable area for a null byte, as is the case in slices pointing\n-    /// to full strings, or suffixes of them.\n+    /// The buffer does not have a null terminator.\n     ///\n-    /// Make sure any mutations to this buffer keep this string valid UTF8.\n+    /// The caller must make sure any mutations to this buffer keep the string\n+    /// valid UTF-8!\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T;\n }\n \n@@ -2152,12 +2214,10 @@ impl OwnedStr for ~str {\n         new_str\n     }\n \n-    /// Reserves capacity for exactly `n` bytes in the given string, not including\n-    /// the null terminator.\n+    /// Reserves capacity for exactly `n` bytes in the given string.\n     ///\n     /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`. To account for the null terminator,\n-    /// the underlying buffer will have the size `n` + 1.\n+    /// enough to hold a string of length `n`.\n     ///\n     /// If the capacity for `s` is already equal to or greater than the requested\n     /// capacity, then no action is taken.\n@@ -2177,8 +2237,7 @@ impl OwnedStr for ~str {\n     /// Reserves capacity for at least `n` bytes in the given string.\n     ///\n     /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`. To account for the null terminator,\n-    /// the underlying buffer will have the size `n` + 1.\n+    /// enough to hold a string of length `n`.\n     ///\n     /// This function will over-allocate in order to amortize the allocation costs\n     /// in scenarios where the caller may need to repeatedly reserve additional\n@@ -3210,6 +3269,14 @@ mod tests {\n         assert_eq!(pos, v.len());\n     }\n \n+    #[test]\n+    fn test_iterator_clone() {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let mut it = s.iter();\n+        it.next();\n+        assert!(it.zip(it.clone()).all(|(x,y)| x == y));\n+    }\n+\n     #[test]\n     fn test_byte_iterator() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -3425,6 +3492,62 @@ mod tests {\n mod bench {\n     use extra::test::BenchHarness;\n     use super::*;\n+    use prelude::*;\n+\n+    #[bench]\n+    fn char_iterator(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.char_len();\n+\n+        do bh.iter {\n+            assert_eq!(s.iter().len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn char_iterator_ascii(bh: &mut BenchHarness) {\n+        let s = \"Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\n+        Mary had a little lamb, Little lamb\";\n+        let len = s.char_len();\n+\n+        do bh.iter {\n+            assert_eq!(s.iter().len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn char_iterator_rev(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.char_len();\n+\n+        do bh.iter {\n+            assert_eq!(s.rev_iter().len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn char_offset_iterator(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.char_len();\n+\n+        do bh.iter {\n+            assert_eq!(s.char_offset_iter().len(), len);\n+        }\n+    }\n+\n+    #[bench]\n+    fn char_offset_iterator_rev(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        let len = s.char_len();\n+\n+        do bh.iter {\n+            assert_eq!(s.char_offset_rev_iter().len(), len);\n+        }\n+    }\n \n     #[bench]\n     fn is_utf8_100_ascii(bh: &mut BenchHarness) {"}]}