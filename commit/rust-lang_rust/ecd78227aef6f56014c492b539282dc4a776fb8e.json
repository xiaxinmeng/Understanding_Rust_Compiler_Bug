{"sha": "ecd78227aef6f56014c492b539282dc4a776fb8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZDc4MjI3YWVmNmY1NjAxNGM0OTJiNTM5MjgyZGM0YTc3NmZiOGU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-13T07:04:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-13T07:04:36Z"}, "message": "Merge pull request #147 from birkenfeld/forloop\n\nLint for for loops over indexes instead of items", "tree": {"sha": "084a732525cc179c2cbb57856a4bd625116a6c0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/084a732525cc179c2cbb57856a4bd625116a6c0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecd78227aef6f56014c492b539282dc4a776fb8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd78227aef6f56014c492b539282dc4a776fb8e", "html_url": "https://github.com/rust-lang/rust/commit/ecd78227aef6f56014c492b539282dc4a776fb8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecd78227aef6f56014c492b539282dc4a776fb8e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd396db9179d99a219726e4dcfb7875c6749390", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd396db9179d99a219726e4dcfb7875c6749390", "html_url": "https://github.com/rust-lang/rust/commit/dbd396db9179d99a219726e4dcfb7875c6749390"}, {"sha": "f6090909d3e7654b9244fff937d78e3e17b5f3e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6090909d3e7654b9244fff937d78e3e17b5f3e2", "html_url": "https://github.com/rust-lang/rust/commit/f6090909d3e7654b9244fff937d78e3e17b5f3e2"}], "stats": {"total": 175, "additions": 158, "deletions": 17}, "files": [{"sha": "33ce163a32674c8aa314bb4fdb7f03d5d8433bc2", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ecd78227aef6f56014c492b539282dc4a776fb8e", "patch": "@@ -32,6 +32,7 @@ pub mod unicode;\n pub mod strings;\n pub mod methods;\n pub mod returns;\n+pub mod loops;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -59,6 +60,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box returns::ReturnPass as LintPassObject);\n     reg.register_lint_pass(box methods::MethodsPass as LintPassObject);\n     reg.register_lint_pass(box types::LetPass as LintPassObject);\n+    reg.register_lint_pass(box loops::LoopsPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH,\n@@ -87,5 +89,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n                                            methods::STR_TO_STRING,\n                                            methods::STRING_TO_STRING,\n                                            types::LET_UNIT_VALUE,\n+                                           loops::NEEDLESS_RANGE_LOOP,\n                                            ]);\n }"}, {"sha": "83d7ca4eccb33dc31a8669622eb0a1487aa48dea", "filename": "src/loops.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=ecd78227aef6f56014c492b539282dc4a776fb8e", "patch": "@@ -0,0 +1,105 @@\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax::visit::{Visitor, walk_expr};\n+use std::collections::HashSet;\n+\n+use utils::{span_lint, get_parent_expr};\n+\n+declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n+               \"Warn about looping over a range of indices if a normal iterator would do\" }\n+\n+#[derive(Copy, Clone)]\n+pub struct LoopsPass;\n+\n+impl LintPass for LoopsPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NEEDLESS_RANGE_LOOP)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let Some((pat, arg, body)) = recover_for_loop(expr) {\n+            // the var must be a single name\n+            if let PatIdent(_, ref ident, _) = pat.node {\n+                // the iteratee must be a range literal\n+                if let ExprRange(_, _) = arg.node {\n+                    let mut visitor = VarVisitor { cx: cx, var: ident.node.name,\n+                                                   indexed: HashSet::new(), nonindex: false };\n+                    walk_expr(&mut visitor, body);\n+                    // linting condition: we only indexed one variable\n+                    if visitor.indexed.len() == 1 {\n+                        let indexed = visitor.indexed.into_iter().next().unwrap();\n+                        if visitor.nonindex {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is used to index `{}`. Consider using \\\n+                                 `for ({}, item) in {}.iter().enumerate()` or similar iterators.\",\n+                                ident.node.name.as_str(), indexed.as_str(),\n+                                ident.node.name.as_str(), indexed.as_str()));\n+                        } else {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is only used to index `{}`. \\\n+                                 Consider using `for item in &{}` or similar iterators.\",\n+                                ident.node.name.as_str(), indexed.as_str(), indexed.as_str()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Recover the essential nodes of a desugared for loop:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+fn recover_for_loop<'a>(expr: &'a Expr) -> Option<(&'a Pat, &'a Expr, &'a Expr)> {\n+    if_let_chain! {\n+        [\n+            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+            let ExprCall(_, ref iterargs) = iterexpr.node,\n+            iterargs.len() == 1,\n+            arms.len() == 1 && arms[0].guard.is_none(),\n+            let ExprLoop(ref block, _) = arms[0].body.node,\n+            block.stmts.is_empty(),\n+            let Some(ref loopexpr) = block.expr,\n+            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n+            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+            let PatEnum(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n+            somepats.len() == 1\n+        ], {\n+            return Some((&*somepats[0],\n+                         &*iterargs[0],\n+                         &*innerarms[0].body));\n+        }\n+    }\n+    None\n+}\n+\n+struct VarVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>, // context reference\n+    var: Name,               // var name to look for as index\n+    indexed: HashSet<Name>,  // indexed variables\n+    nonindex: bool,          // has the var been used otherwise?\n+}\n+\n+impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if let ExprPath(None, ref path) = expr.node {\n+            if path.segments.len() == 1 && path.segments[0].identifier.name == self.var {\n+                // we are referencing our variable! now check if it's as an index\n+                if_let_chain! {\n+                    [\n+                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                        let ExprPath(None, ref seqvar) = seqexpr.node,\n+                        seqvar.segments.len() == 1\n+                    ], {\n+                        self.indexed.insert(seqvar.segments[0].identifier.name);\n+                        return;  // no need to walk further\n+                    }\n+                }\n+                // we are not indexing anything, record that\n+                self.nonindex = true;\n+                return;\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "be28e14001c95d113274cffca9e6c22fc96b4e11", "filename": "src/returns.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=ecd78227aef6f56014c492b539282dc4a776fb8e", "patch": "@@ -69,17 +69,16 @@ impl ReturnPass {\n         // we need both a let-binding stmt and an expr\n         if_let_chain! {\n             [\n-                Some(stmt) = block.stmts.last(),\n-                StmtDecl(ref decl, _) = stmt.node,\n-                DeclLocal(ref local) = decl.node,\n-                Some(ref initexpr) = local.init,\n-                PatIdent(_, Spanned { node: id, .. }, _) = local.pat.node,\n-                Some(ref retexpr) = block.expr,\n-                ExprPath(_, ref path) = retexpr.node\n+                let Some(stmt) = block.stmts.last(),\n+                let StmtDecl(ref decl, _) = stmt.node,\n+                let DeclLocal(ref local) = decl.node,\n+                let Some(ref initexpr) = local.init,\n+                let PatIdent(_, Spanned { node: id, .. }, _) = local.pat.node,\n+                let Some(ref retexpr) = block.expr,\n+                let ExprPath(_, ref path) = retexpr.node,\n+                match_path(path, &[&*id.name.as_str()])\n             ], {\n-                if match_path(path, &[&*id.name.as_str()]) {\n-                    self.emit_let_lint(cx, retexpr.span, initexpr.span);\n-                }\n+                self.emit_let_lint(cx, retexpr.span, initexpr.span);\n             }\n         }\n     }"}, {"sha": "220dc6215fdbb17f1466559fc4bbe59c469eaa4f", "filename": "src/utils.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd78227aef6f56014c492b539282dc4a776fb8e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ecd78227aef6f56014c492b539282dc4a776fb8e", "patch": "@@ -93,9 +93,14 @@ pub fn walk_ptrs_ty<'t>(ty: ty::Ty<'t>) -> ty::Ty<'t> {\n     }\n }\n \n-/// Produce a nested chain of if-lets from the patterns:\n+/// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n-///     if_let_chain! {[Some(y) = x, Some(z) = y],\n+///     if_let_chain! {\n+///         [\n+///             Some(y) = x,\n+///             y.len() == 2,\n+///             Some(z) = y,\n+///         ],\n ///         {\n ///             block\n ///         }\n@@ -104,20 +109,32 @@ pub fn walk_ptrs_ty<'t>(ty: ty::Ty<'t>) -> ty::Ty<'t> {\n /// becomes\n ///\n ///     if let Some(y) = x {\n-///         if let Some(z) = y {\n-///             block\n+///         if y.len() == 2 {\n+///             if let Some(z) = y {\n+///                 block\n+///             }\n ///         }\n ///     }\n #[macro_export]\n macro_rules! if_let_chain {\n-    ([$pat:pat = $expr:expr, $($p2:pat = $e2:expr),+], $block:block) => {\n+    ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n         if let $pat = $expr {\n-           if_let_chain!{ [$($p2 = $e2),+], $block }\n+           if_let_chain!{ [$($tt)+], $block }\n         }\n     };\n-    ([$pat:pat = $expr:expr], $block:block) => {\n+    ([let $pat:pat = $expr:expr], $block:block) => {\n         if let $pat = $expr {\n            $block\n         }\n     };\n+    ([$expr:expr, $($tt:tt)+], $block:block) => {\n+        if $expr {\n+           if_let_chain!{ [$($tt)+], $block }\n+        }\n+    };\n+    ([$expr:expr], $block:block) => {\n+        if $expr {\n+           $block\n+        }\n+    };\n }"}, {"sha": "318e6fc85887f2b4f10ade9ee36eaf73808a91e4", "filename": "tests/compile-fail/for_loop.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ecd78227aef6f56014c492b539282dc4a776fb8e/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd78227aef6f56014c492b539282dc4a776fb8e/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=ecd78227aef6f56014c492b539282dc4a776fb8e", "patch": "@@ -0,0 +1,17 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(needless_range_loop)]\n+fn main() {\n+    let vec = vec![1, 2, 3, 4];\n+    let vec2 = vec![1, 2, 3, 4];\n+    for i in 0..vec.len() {      //~ERROR the loop variable `i` is only used to index `vec`.\n+        println!(\"{}\", vec[i]);\n+    }\n+    for i in 0..vec.len() {      //~ERROR the loop variable `i` is used to index `vec`.\n+        println!(\"{} {}\", vec[i], i);\n+    }\n+    for i in 0..vec.len() {      // not an error, indexing more than one variable\n+        println!(\"{} {}\", vec[i], vec2[i]);\n+    }\n+}"}]}