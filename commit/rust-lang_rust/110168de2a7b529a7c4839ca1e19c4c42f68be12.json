{"sha": "110168de2a7b529a7c4839ca1e19c4c42f68be12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMDE2OGRlMmE3YjUyOWE3YzQ4MzljYTFlMTljNGM0MmY2OGJlMTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-11T21:29:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-25T00:08:14Z"}, "message": "native: Implement clone/close_accept for unix\n\nThis commits implements {Tcp,Unix}Acceptor::{clone,close_accept} methods for\nunix. A windows implementation is coming in a later commit.\n\nThe clone implementation is based on atomic reference counting (as with all\nother clones), and the close_accept implementation is based on selecting on a\nself-pipe which signals that a close has been seen.", "tree": {"sha": "b590f2a6976d0c44b174c1eb3205a120a8072db0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b590f2a6976d0c44b174c1eb3205a120a8072db0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/110168de2a7b529a7c4839ca1e19c4c42f68be12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/110168de2a7b529a7c4839ca1e19c4c42f68be12", "html_url": "https://github.com/rust-lang/rust/commit/110168de2a7b529a7c4839ca1e19c4c42f68be12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/110168de2a7b529a7c4839ca1e19c4c42f68be12/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d9b219e6f84325ee32c70a29bf782e7ad54ebc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d9b219e6f84325ee32c70a29bf782e7ad54ebc8", "html_url": "https://github.com/rust-lang/rust/commit/6d9b219e6f84325ee32c70a29bf782e7ad54ebc8"}], "stats": {"total": 527, "additions": 481, "deletions": 46}, "files": [{"sha": "7a8a363a0a3509973d7fb63a3dac76d88120d6cd", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 73, "deletions": 20, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -14,10 +14,13 @@ use std::mem;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n+use std::sync::atomics;\n \n use super::{retry, keep_going};\n use super::c;\n use super::util;\n+use super::file::FileDesc;\n+use super::process;\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -479,9 +482,26 @@ impl TcpListener {\n     pub fn fd(&self) -> sock_t { self.inner.fd }\n \n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        try!(util::set_nonblocking(self.fd(), true));\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(last_error()),\n-            _ => Ok(TcpAcceptor { listener: self, deadline: 0 })\n+\n+            #[cfg(unix)]\n+            _ => {\n+                let (reader, writer) = try!(process::pipe());\n+                try!(util::set_nonblocking(reader.fd(), true));\n+                try!(util::set_nonblocking(writer.fd(), true));\n+                try!(util::set_nonblocking(self.fd(), true));\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomics::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n         }\n     }\n }\n@@ -502,31 +522,46 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n pub struct TcpAcceptor {\n-    listener: TcpListener,\n+    inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n+#[cfg(unix)]\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomics::AtomicBool,\n+}\n+\n impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.listener.fd() }\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n \n+    #[cfg(unix)]\n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        if self.deadline != 0 {\n-            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n-        }\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = mem::zeroed();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let size = mem::size_of::<libc::sockaddr_storage>();\n-            let mut size = size as libc::socklen_t;\n-            match retry(|| {\n-                libc::accept(self.fd(),\n-                             storagep as *mut libc::sockaddr,\n-                             &mut size as *mut libc::socklen_t) as libc::c_int\n-            }) as sock_t {\n-                -1 => Err(last_error()),\n-                fd => Ok(TcpStream::new(Inner::new(fd))),\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomics::SeqCst) {\n+            unsafe {\n+                let mut storage: libc::sockaddr_storage = mem::zeroed();\n+                let storagep = &mut storage as *mut libc::sockaddr_storage;\n+                let size = mem::size_of::<libc::sockaddr_storage>();\n+                let mut size = size as libc::socklen_t;\n+                match retry(|| {\n+                    libc::accept(self.fd(),\n+                                 storagep as *mut libc::sockaddr,\n+                                 &mut size as *mut libc::socklen_t) as libc::c_int\n+                }) as sock_t {\n+                    -1 if util::wouldblock() => {}\n+                    -1 => return Err(last_error()),\n+                    fd => return Ok(TcpStream::new(Inner::new(fd))),\n+                }\n             }\n+            try!(util::await([self.fd(), self.inner.reader.fd()],\n+                             deadline, util::Readable));\n         }\n+\n+        Err(util::eof())\n     }\n }\n \n@@ -546,6 +581,24 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n+        box TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        } as Box<rtio::RtioTcpAcceptor + Send>\n+    }\n+\n+    #[cfg(unix)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomics::SeqCst);\n+        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.inner_write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if util::wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -817,7 +870,7 @@ pub fn read<T>(fd: sock_t,\n             // With a timeout, first we wait for the socket to become\n             // readable using select(), specifying the relevant timeout for\n             // our previously set deadline.\n-            try!(util::await(fd, deadline, util::Readable));\n+            try!(util::await([fd], deadline, util::Readable));\n \n             // At this point, we're still within the timeout, and we've\n             // determined that the socket is readable (as returned by\n@@ -871,7 +924,7 @@ pub fn write<T>(fd: sock_t,\n         while written < buf.len() && (write_everything || written == 0) {\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n-            match util::await(fd, deadline, util::Writable) {\n+            match util::await([fd], deadline, util::Writable) {\n                 Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n                     assert!(deadline.is_some());\n                     return Err(util::short_write(written, \"short write\"))"}, {"sha": "4ad8383e6f8052ae10ba9a36a328928f960e5622", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -15,12 +15,14 @@ use std::mem;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n+use std::sync::atomics;\n \n use super::retry;\n use super::net;\n use super::util;\n use super::c;\n-use super::file::fd_t;\n+use super::process;\n+use super::file::{fd_t, FileDesc};\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n@@ -225,7 +227,23 @@ impl UnixListener {\n     pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(super::last_error()),\n-            _ => Ok(UnixAcceptor { listener: self, deadline: 0 })\n+\n+            #[cfg(unix)]\n+            _ => {\n+                let (reader, writer) = try!(process::pipe());\n+                try!(util::set_nonblocking(reader.fd(), true));\n+                try!(util::set_nonblocking(writer.fd(), true));\n+                try!(util::set_nonblocking(self.fd(), true));\n+                Ok(UnixAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomics::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n         }\n     }\n }\n@@ -240,29 +258,45 @@ impl rtio::RtioUnixListener for UnixListener {\n }\n \n pub struct UnixAcceptor {\n-    listener: UnixListener,\n+    inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n+#[cfg(unix)]\n+struct AcceptorInner {\n+    listener: UnixListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomics::AtomicBool,\n+}\n+\n impl UnixAcceptor {\n-    fn fd(&self) -> fd_t { self.listener.fd() }\n+    fn fd(&self) -> fd_t { self.inner.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n-        if self.deadline != 0 {\n-            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n-        }\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let storagep = &mut storage as *mut libc::sockaddr_storage;\n-        let size = mem::size_of::<libc::sockaddr_storage>();\n-        let mut size = size as libc::socklen_t;\n-        match retry(|| unsafe {\n-            libc::accept(self.fd(),\n-                         storagep as *mut libc::sockaddr,\n-                         &mut size as *mut libc::socklen_t) as libc::c_int\n-        }) {\n-            -1 => Err(super::last_error()),\n-            fd => Ok(UnixStream::new(Arc::new(Inner::new(fd))))\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomics::SeqCst) {\n+            unsafe {\n+                let mut storage: libc::sockaddr_storage = mem::zeroed();\n+                let storagep = &mut storage as *mut libc::sockaddr_storage;\n+                let size = mem::size_of::<libc::sockaddr_storage>();\n+                let mut size = size as libc::socklen_t;\n+                match retry(|| {\n+                    libc::accept(self.fd(),\n+                                 storagep as *mut libc::sockaddr,\n+                                 &mut size as *mut libc::socklen_t) as libc::c_int\n+                }) {\n+                    -1 if util::wouldblock() => {}\n+                    -1 => return Err(super::last_error()),\n+                    fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n+                }\n+            }\n+            try!(util::await([self.fd(), self.inner.reader.fd()],\n+                             deadline, util::Readable));\n         }\n+\n+        Err(util::eof())\n     }\n }\n \n@@ -273,6 +307,24 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        box UnixAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n+    }\n+\n+    #[cfg(unix)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomics::SeqCst);\n+        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.inner_write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if util::wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n }\n \n impl Drop for UnixListener {"}, {"sha": "6ad51ee586f4e464ddc00e6a7a56e73dfbf98c0b", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -99,10 +99,10 @@ use super::c;\n use super::util;\n use super::file::to_utf16;\n \n-struct Event(libc::HANDLE);\n+pub struct Event(libc::HANDLE);\n \n impl Event {\n-    fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n+    pub fn new(manual_reset: bool, initial_state: bool) -> IoResult<Event> {\n         let event = unsafe {\n             libc::CreateEventW(ptr::mut_null(),\n                                manual_reset as libc::BOOL,\n@@ -116,7 +116,7 @@ impl Event {\n         }\n     }\n \n-    fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }\n+    pub fn handle(&self) -> libc::HANDLE { let Event(handle) = *self; handle }\n }\n \n impl Drop for Event {"}, {"sha": "b8ec0cd549611dd59758d7e7b8d8de012ad4aee5", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -191,7 +191,7 @@ impl Drop for Process {\n     }\n }\n \n-fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n+pub fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n     #[cfg(unix)] use libc::EMFILE as ERROR;\n     #[cfg(windows)] use libc::WSAEMFILE as ERROR;\n     struct Closer { fd: libc::c_int }"}, {"sha": "aec29bc2d0316e284ed8b0a78b6aee011384dd1e", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use libc;\n+use std::cmp;\n use std::mem;\n use std::os;\n use std::ptr;\n@@ -166,10 +167,15 @@ pub fn connect_timeout(fd: net::sock_t,\n     }\n }\n \n-pub fn await(fd: net::sock_t, deadline: Option<u64>,\n+pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n              status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    c::fd_set(&mut set, fd);\n+    let mut max = 0;\n+    for &fd in fds.iter() {\n+        c::fd_set(&mut set, fd);\n+        max = cmp::max(max, fd + 1);\n+    }\n+\n     let (read, write) = match status {\n         Readable => (&mut set as *mut _, ptr::mut_null()),\n         Writable => (ptr::mut_null(), &mut set as *mut _),\n@@ -188,8 +194,7 @@ pub fn await(fd: net::sock_t, deadline: Option<u64>,\n                 &mut tv as *mut _\n             }\n         };\n-        let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        let r = unsafe { c::select(n, read, write, ptr::mut_null(), tvp) };\n+        let r = unsafe { c::select(max, read, write, ptr::mut_null(), tvp) };\n         r\n     }) {\n         -1 => Err(last_error()),"}, {"sha": "261d544a24149129c62ed4622221de78fb420b5e", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -246,6 +246,8 @@ pub trait RtioTcpAcceptor : RtioSocket {\n     fn accept_simultaneously(&mut self) -> IoResult<()>;\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n+    fn clone(&self) -> Box<RtioTcpAcceptor + Send>;\n+    fn close_accept(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioTcpStream : RtioSocket {\n@@ -335,6 +337,8 @@ pub trait RtioUnixListener {\n pub trait RtioUnixAcceptor {\n     fn accept(&mut self) -> IoResult<Box<RtioPipe + Send>>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n+    fn clone(&self) -> Box<RtioUnixAcceptor + Send>;\n+    fn close_accept(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioTTY {"}, {"sha": "ebc3940c16f6997a1bcfc89115cb3b35b715cfae", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -442,6 +442,54 @@ impl TcpAcceptor {\n     #[experimental = \"the type of the argument and name of this function are \\\n                       subject to change\"]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }\n+\n+    /// Closes the accepting capabilities of this acceptor.\n+    ///\n+    /// This function is similar to `TcpStream`'s `close_{read,write}` methods\n+    /// in that it will affect *all* cloned handles of this acceptor's original\n+    /// handle.\n+    ///\n+    /// Once this function succeeds, all future calls to `accept` will return\n+    /// immediately with an error, preventing all future calls to accept. The\n+    /// underlying socket will not be relinquished back to the OS until all\n+    /// acceptors have been deallocated.\n+    ///\n+    /// This is useful for waking up a thread in an accept loop to indicate that\n+    /// it should exit.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![allow(experimental)]\n+    /// use std::io::TcpListener;\n+    /// use std::io::{Listener, Acceptor, TimedOut};\n+    ///\n+    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let a2 = a.clone();\n+    ///\n+    /// spawn(proc() {\n+    ///     let mut a2 = a2;\n+    ///     for socket in a2.incoming() {\n+    ///         match socket {\n+    ///             Ok(s) => { /* handle s */ }\n+    ///             Err(ref e) if e.kind == EndOfFile => break, // closed\n+    ///             Err(e) => fail!(\"unexpected error: {}\", e),\n+    ///         }\n+    ///     }\n+    /// });\n+    ///\n+    /// # fn wait_for_sigint() {}\n+    /// // Now that our accept loop is running, wait for the program to be\n+    /// // requested to exit.\n+    /// wait_for_sigint();\n+    ///\n+    /// // Signal our accept loop to exit\n+    /// assert!(a.close_accept().is_ok());\n+    /// ```\n+    #[experimental]\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n@@ -453,6 +501,25 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n     }\n }\n \n+impl Clone for TcpAcceptor {\n+    /// Creates a new handle to this TCP acceptor, allowing for simultaneous\n+    /// accepts.\n+    ///\n+    /// The underlying TCP acceptor will not be closed until all handles to the\n+    /// acceptor have been deallocated. Incoming connections will be received on\n+    /// at most once acceptor, the same connection will not be accepted twice.\n+    ///\n+    /// The `close_accept` method will shut down *all* acceptors cloned from the\n+    /// same original acceptor, whereas the `set_timeout` method only affects\n+    /// the selector that it is called on.\n+    ///\n+    /// This function is useful for creating a handle to invoke `close_accept`\n+    /// on to wake up any other task blocked in `accept`.\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor { obj: self.obj.clone() }\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n@@ -1411,4 +1478,69 @@ mod test {\n         rxdone.recv();\n         rxdone.recv();\n     })\n+\n+    iotest!(fn clone_accept_smoke() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let mut a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+\n+        assert!(a.accept().is_ok());\n+        assert!(a2.accept().is_ok());\n+    })\n+\n+    iotest!(fn clone_accept_concurrent() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let a = l.listen().unwrap();\n+        let a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+\n+        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n+        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+\n+        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n+    })\n+\n+    iotest!(fn close_accept_smoke() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let mut a = l.listen().unwrap();\n+\n+        a.close_accept().unwrap();\n+        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n+    })\n+\n+    iotest!(fn close_accept_concurrent() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut a = a;\n+            tx.send(a.accept());\n+        });\n+        a2.close_accept().unwrap();\n+\n+        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+    })\n }"}, {"sha": "74f024a844e2c5f8f94c42b03d1aa01d484b424d", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -212,6 +212,15 @@ impl UnixAcceptor {\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.obj.set_timeout(timeout_ms)\n     }\n+\n+    /// Closes the accepting capabilities of this acceptor.\n+    ///\n+    /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n+    /// more information can be found in that documentation.\n+    #[experimental]\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n@@ -222,6 +231,25 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n     }\n }\n \n+impl Clone for UnixAcceptor {\n+    /// Creates a new handle to this unix acceptor, allowing for simultaneous\n+    /// accepts.\n+    ///\n+    /// The underlying unix acceptor will not be closed until all handles to the\n+    /// acceptor have been deallocated. Incoming connections will be received on\n+    /// at most once acceptor, the same connection will not be accepted twice.\n+    ///\n+    /// The `close_accept` method will shut down *all* acceptors cloned from the\n+    /// same original acceptor, whereas the `set_timeout` method only affects\n+    /// the selector that it is called on.\n+    ///\n+    /// This function is useful for creating a handle to invoke `close_accept`\n+    /// on to wake up any other task blocked in `accept`.\n+    fn clone(&self) -> UnixAcceptor {\n+        UnixAcceptor { obj: self.obj.clone() }\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n@@ -702,4 +730,71 @@ mod tests {\n \n         rx2.recv();\n     })\n+\n+    iotest!(fn clone_accept_smoke() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let mut a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr2);\n+        });\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr);\n+        });\n+\n+        assert!(a.accept().is_ok());\n+        assert!(a2.accept().is_ok());\n+    })\n+\n+    iotest!(fn clone_accept_concurrent() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let a = l.listen().unwrap();\n+        let a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+\n+        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n+        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr2);\n+        });\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr);\n+        });\n+\n+        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n+    })\n+\n+    iotest!(fn close_accept_smoke() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let mut a = l.listen().unwrap();\n+\n+        a.close_accept().unwrap();\n+        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n+    })\n+\n+    iotest!(fn close_accept_concurrent() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut a = a;\n+            tx.send(a.accept());\n+        });\n+        a2.close_accept().unwrap();\n+\n+        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+    })\n }"}, {"sha": "3e420e45cfce6b33b7a0694e2bdbf52f312f6538", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110168de2a7b529a7c4839ca1e19c4c42f68be12/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=110168de2a7b529a7c4839ca1e19c4c42f68be12", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate green;\n+extern crate native;\n+\n+use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n+use std::sync::{atomics, Arc};\n+use std::task::TaskBuilder;\n+use native::NativeTaskBuilder;\n+\n+static N: uint = 8;\n+static M: uint = 100;\n+\n+green_start!(main)\n+\n+fn main() {\n+    test();\n+\n+    let (tx, rx) = channel();\n+    TaskBuilder::new().native().spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+}\n+\n+fn test() {\n+    let mut l = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n+    let addr = l.socket_name().unwrap();\n+    let mut a = l.listen().unwrap();\n+    let cnt = Arc::new(atomics::AtomicUint::new(0));\n+\n+    let (tx, rx) = channel();\n+    for _ in range(0, N) {\n+        let a = a.clone();\n+        let cnt = cnt.clone();\n+        let tx = tx.clone();\n+        spawn(proc() {\n+            let mut a = a;\n+            let mut mycnt = 0u;\n+            loop {\n+                match a.accept() {\n+                    Ok(..) => {\n+                        mycnt += 1;\n+                        if cnt.fetch_add(1, atomics::SeqCst) == N * M - 1 {\n+                            break\n+                        }\n+                    }\n+                    Err(ref e) if e.kind == EndOfFile => break,\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            assert!(mycnt > 0);\n+            tx.send(());\n+        });\n+    }\n+\n+    for _ in range(0, N) {\n+        let tx = tx.clone();\n+        spawn(proc() {\n+            for _ in range(0, M) {\n+                let _s = TcpStream::connect(addr.ip.to_string().as_slice(),\n+                                            addr.port).unwrap();\n+            }\n+            tx.send(());\n+        });\n+    }\n+\n+    // wait for senders\n+    assert_eq!(rx.iter().take(N).count(), N);\n+\n+    // wait for one acceptor to die\n+    let _ = rx.recv();\n+\n+    // Notify other receivers should die\n+    a.close_accept().unwrap();\n+\n+    // wait for receivers\n+    assert_eq!(rx.iter().take(N - 1).count(), N - 1);\n+\n+    // Everything should have been accepted.\n+    assert_eq!(cnt.load(atomics::SeqCst), N * M);\n+}\n+"}]}