{"sha": "99a902c81d7bc57fece1b520591f328afe76154a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YTkwMmM4MWQ3YmM1N2ZlY2UxYjUyMDU5MWYzMjhhZmU3NjE1NGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-27T04:00:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-27T04:00:38Z"}, "message": "auto merge of #5120 : jbclements/rust/macros-have-scope, r=pcwalton\n\nr?\r\n\r\nAfter this patch, macros declared in a module, function, or block can only be used inside of that module, function or block, with the exception of modules declared with the #[macro_escape] attribute; these modules allow macros to escape, and can be used as a limited macro export mechanism.\r\n\r\nThis pull request also includes miscellaneous comments, lots of new test cases, a few renamings, and a few as-yet-unused data definitions for hygiene.", "tree": {"sha": "feb170d7d7bbae635fa641076ab97d1b3fbc9e14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feb170d7d7bbae635fa641076ab97d1b3fbc9e14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99a902c81d7bc57fece1b520591f328afe76154a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99a902c81d7bc57fece1b520591f328afe76154a", "html_url": "https://github.com/rust-lang/rust/commit/99a902c81d7bc57fece1b520591f328afe76154a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99a902c81d7bc57fece1b520591f328afe76154a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b50a48927db9408060d141b8dcb3a830272365", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b50a48927db9408060d141b8dcb3a830272365", "html_url": "https://github.com/rust-lang/rust/commit/28b50a48927db9408060d141b8dcb3a830272365"}, {"sha": "6aefaf22c758b76703ed850bcf817dda127a5d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aefaf22c758b76703ed850bcf817dda127a5d67", "html_url": "https://github.com/rust-lang/rust/commit/6aefaf22c758b76703ed850bcf817dda127a5d67"}], "stats": {"total": 844, "additions": 647, "deletions": 197}, "files": [{"sha": "4a1a1952907c6f65a800041478ca7e63127601fc", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -186,42 +186,46 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n     state\n }\n \n+// sadly, these macro definitions can't appear later,\n+// because they're needed in the following defs;\n+// this design could be improved.\n+\n+macro_rules! u8to64_le (\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     $buf[1+$i] as u64 << 8 |\n+     $buf[2+$i] as u64 << 16 |\n+     $buf[3+$i] as u64 << 24 |\n+     $buf[4+$i] as u64 << 32 |\n+     $buf[5+$i] as u64 << 40 |\n+     $buf[6+$i] as u64 << 48 |\n+     $buf[7+$i] as u64 << 56)\n+)\n+\n+macro_rules! rotl (\n+    ($x:expr, $b:expr) =>\n+    (($x << $b) | ($x >> (64 - $b)))\n+)\n+\n+macro_rules! compress (\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n+        $v0 = rotl!($v0, 32);\n+        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n+        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n+        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n+        $v2 = rotl!($v2, 32);\n+    })\n+)\n+\n \n impl io::Writer for SipState {\n \n     // Methods for io::writer\n     #[inline(always)]\n     fn write(&self, msg: &[const u8]) {\n \n-        macro_rules! u8to64_le (\n-            ($buf:expr, $i:expr) =>\n-            ($buf[0+$i] as u64 |\n-             $buf[1+$i] as u64 << 8 |\n-             $buf[2+$i] as u64 << 16 |\n-             $buf[3+$i] as u64 << 24 |\n-             $buf[4+$i] as u64 << 32 |\n-             $buf[5+$i] as u64 << 40 |\n-             $buf[6+$i] as u64 << 48 |\n-             $buf[7+$i] as u64 << 56)\n-        );\n-\n-        macro_rules! rotl (\n-            ($x:expr, $b:expr) =>\n-            (($x << $b) | ($x >> (64 - $b)))\n-        );\n-\n-        macro_rules! compress (\n-            ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-            ({\n-                $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-                $v0 = rotl!($v0, 32);\n-                $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-                $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-                $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-                $v2 = rotl!($v2, 32);\n-            })\n-        );\n-\n         let length = msg.len();\n         self.length += length;\n "}, {"sha": "3686c31ea6e648d165604c8fa24cc04ba19bab0e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -172,11 +172,6 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n // An option identifying a literal: either a unit-like struct or an\n // expression.\n pub enum Lit {"}, {"sha": "57cb1a937764cd47ebf2df2ef11e06a76bfa1b57", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -18,11 +18,6 @@ use middle::trans::datum::*;\n \n use core::str;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;"}, {"sha": "6226e83d046b3eb85ec845dc2ab92808911aab7a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -149,8 +149,6 @@ use syntax::codemap::spanned;\n // These are passed around by the code generating functions to track the\n // destination of a computation's value.\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n-\n pub enum Dest {\n     SaveIn(ValueRef),\n     Ignore,"}, {"sha": "14ed7692661d4dfd89d952264dbdcc2ba5602d4e", "filename": "src/librustc/middle/trans/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmacros.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-{\n+#[macro_escape];\n \n macro_rules! unpack_datum(\n     ($bcx: ident, $inp: expr) => (\n@@ -18,7 +18,7 @@ macro_rules! unpack_datum(\n             db.datum\n         }\n     )\n-);\n+)\n \n macro_rules! unpack_result(\n     ($bcx: ident, $inp: expr) => (\n@@ -28,7 +28,7 @@ macro_rules! unpack_result(\n             db.val\n         }\n     )\n-);\n+)\n \n macro_rules! trace_span(\n     ($bcx: ident, $sp: expr, $str: expr) => (\n@@ -39,7 +39,7 @@ macro_rules! trace_span(\n             }\n         }\n     )\n-);\n+)\n \n macro_rules! trace(\n     ($bcx: ident, $str: expr) => (\n@@ -50,6 +50,5 @@ macro_rules! trace(\n             }\n         }\n     )\n-);\n+)\n \n-}"}, {"sha": "07b6556df6aa0592d0ae627d2759406ff2a181f7", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -39,11 +39,6 @@ use syntax::ast_util::local_def;\n use syntax::print::pprust::expr_to_str;\n use syntax::{ast, ast_map};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n /**\n The main \"translation\" pass for methods.  Generates code\n for non-monomorphized methods only.  Other methods will"}, {"sha": "f63dac4c5ae55b8b4b5938a9df9f0bc19f1355c1", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -72,11 +72,6 @@ use syntax::ast::{Onceness, purity, ret_style};\n use syntax::ast;\n use syntax::codemap::span;\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n     fn tag(&self) -> ~str;"}, {"sha": "4fee6f061b1cacc80f06506624a0f7f17d5025cb", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -24,11 +24,6 @@ use std::list;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn, noreturn};\n use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n-\n pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n \n pub impl Lub {"}, {"sha": "e02772d951c556895a3602db073a731fd7372e30", "filename": "src/librustc/middle/typeck/infer/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmacros.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-{\n+#[macro_escape];\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -17,6 +17,5 @@ macro_rules! if_ok(\n             Err(e) => { return Err(e); }\n         }\n     )\n-);\n+)\n \n-}"}, {"sha": "8bb1f2f47e5e4820a037a97690f16e80254e374d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -287,6 +287,7 @@ use syntax::codemap;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n+pub mod macros;\n pub mod combine;\n pub mod glb;\n pub mod lattice;"}, {"sha": "12a9a6c4076e714417c2ceec4c847300b70c5694", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -25,10 +25,6 @@ use std::list::Nil;\n use std::list;\n use syntax::ast::{m_const, purity, ret_style};\n \n-pub fn macros() {\n-    // FIXME(#3114): Macro import/export.\n-    include!(\"macros.rs\");\n-}\n \n pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n "}, {"sha": "5df7ae493baacf4f2961444582b918ebc1ef19c4", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -49,6 +49,7 @@ use back_ = back;\n \n pub mod middle {\n     pub mod trans {\n+        pub mod macros;\n         pub mod inline;\n         pub mod monomorphize;\n         pub mod controlflow;"}, {"sha": "f129df3f300c1c09cbc115255371d7d4c30dbd96", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -161,7 +161,7 @@ fn nmoddoc_from_mod(\n           ast::foreign_item_const(*) => {} // XXX: Not implemented.\n         }\n     }\n-    doc:: NmodDoc {\n+    doc::NmodDoc {\n         item: itemdoc,\n         fns: fns,\n         index: None"}, {"sha": "5af67aa0e3b3381f10ef108bcea1552d2ec2b4e9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -29,8 +29,37 @@ macro_rules! interner_key (\n         (-3 as uint, 0u)))\n )\n \n+// an identifier contains an index into the interner\n+// table and a SyntaxContext to track renaming and\n+// macro expansion per Flatt et al., \"Macros\n+// That Work Together\"\n #[deriving_eq]\n-pub struct ident { repr: uint }\n+pub struct ident { repr: Name }\n+\n+// a SyntaxContext represents a chain of macro-expandings\n+// and renamings. Each macro expansion corresponds to\n+// a fresh uint\n+#[deriving_eq]\n+pub enum SyntaxContext {\n+    MT,\n+    Mark (Mrk,~SyntaxContext),\n+    Rename (~ident,Name,~SyntaxContext)\n+}\n+\n+/*\n+// ** this is going to have to apply to paths, not to idents.\n+// Returns true if these two identifiers access the same\n+// local binding or top-level binding... that's what it\n+// should do. For now, it just compares the names.\n+pub fn free_ident_eq (a : ident, b: ident) -> bool{\n+    a.repr == b.repr\n+}\n+*/\n+// a name represents a string, interned\n+type Name = uint;\n+// a mark represents a unique id associated\n+// with a macro expansion\n+type Mrk = uint;\n \n pub impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &S) {\n@@ -1230,6 +1259,7 @@ pub enum item_ {\n               Option<@trait_ref>, // (optional) trait this impl implements\n               @Ty, // self\n               ~[@method]),\n+    // a macro invocation (which includes macro definition)\n     item_mac(mac),\n }\n "}, {"sha": "0019acc1291f4c58ae7f9dd20ce271ea78941441", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -1173,6 +1173,8 @@ mod test {\n         CallToEmitEnumVariantArg(uint),\n         CallToEmitUint(uint),\n         CallToEmitNil,\n+        CallToEmitStruct(~str,uint),\n+        CallToEmitField(~str,uint),\n         // all of the ones I was too lazy to handle:\n         CallToOther\n     }\n@@ -1251,11 +1253,11 @@ mod test {\n         fn emit_rec(&self, f: fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_struct(&self, _name: &str, +_len: uint, f: fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_struct(&self, name: &str, +len: uint, f: fn()) {\n+            self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, _name: &str, +_idx: uint, f: fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_field(&self, name: &str, +idx: uint, f: fn()) {\n+            self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n         fn emit_tup(&self, +_len: uint, f: fn()) {\n@@ -1267,23 +1269,12 @@ mod test {\n     }\n \n \n-    #[auto_decode]\n-    #[auto_encode]\n-    struct Node {id: uint}\n-\n     fn to_call_log (val: Encodable<TestEncoder>) -> ~[call] {\n         let mut te = TestEncoder {call_log: @mut ~[]};\n         val.encode(&te);\n         copy *te.call_log\n     }\n-/*\n-    #[test] fn encode_test () {\n-        check_equal (to_call_log(Node{id:34}\n-                                 as Encodable::<std::json::Encoder>),\n-                     ~[CallToEnum (~\"Node\"),\n-                       CallToEnumVariant]);\n-    }\n-*/\n+\n     #[auto_encode]\n     enum Written {\n         Book(uint,uint),\n@@ -1300,4 +1291,17 @@ mod test {\n                        CallToEmitEnumVariantArg (1),\n                        CallToEmitUint (44)]);\n         }\n+\n+    pub enum BPos = uint;\n+\n+    #[auto_encode]\n+    pub struct HasPos { pos : BPos }\n+\n+    #[test] fn encode_newtype_test () {\n+        check_equal (to_call_log (HasPos {pos:BPos(48)}\n+                                 as Encodable::<TestEncoder>),\n+                    ~[CallToEmitStruct(~\"HasPos\",1),\n+                      CallToEmitField(~\"pos\",0),\n+                      CallToEmitUint(48)]);\n+    }\n }"}, {"sha": "0eaf6849b7eb7dc868d2e87f66c858a2cdaca2b2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 197, "deletions": 24, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -21,12 +21,12 @@ use parse::{parser, token};\n \n use core::io;\n use core::vec;\n-use std::oldmap::HashMap;\n+use core::hashmap::linear::LinearMap;\n \n // new-style macro! tt code:\n //\n //    SyntaxExpanderTT, SyntaxExpanderTTItem, MacResult,\n-//    NormalTT, ItemTT\n+//    NormalTT, IdentTT\n //\n // also note that ast::mac used to have a bunch of extraneous cases and\n // is now probably a redundant AST node, can be merged with\n@@ -71,36 +71,66 @@ pub enum SyntaxExtension {\n     // Token-tree expanders\n     NormalTT(SyntaxExpanderTT),\n \n+    // An IdentTT is a macro that has an\n+    // identifier in between the name of the\n+    // macro and the argument. Currently,\n+    // the only examples of this are\n+    // macro_rules! and proto!\n+\n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    ItemTT(SyntaxExpanderTTItem),\n+    IdentTT(SyntaxExpanderTTItem),\n }\n \n-type SyntaxExtensions = HashMap<@~str, SyntaxExtension>;\n+type SyntaxEnv = @mut MapChain<Name, Transformer>;\n+\n+// Name : the domain of SyntaxEnvs\n+// want to change these to uints....\n+// note that we use certain strings that are not legal as identifiers\n+// to indicate, for instance, how blocks are supposed to behave.\n+type Name = @~str;\n+\n+// Transformer : the codomain of SyntaxEnvs\n+\n+// NB: it may seem crazy to lump both of these into one environment;\n+// what would it mean to bind \"foo\" to BlockLimit(true)? The idea\n+// is that this follows the lead of MTWT, and accommodates growth\n+// toward a more uniform syntax syntax (sorry) where blocks are just\n+// another kind of transformer.\n+\n+enum Transformer {\n+    // this identifier maps to a syntax extension or macro\n+    SE(SyntaxExtension),\n+    // should blocks occurring here limit macro scopes?\n+    ScopeMacros(bool)\n+}\n \n-// A temporary hard-coded map of methods for expanding syntax extension\n+// The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-pub fn syntax_expander_table() -> SyntaxExtensions {\n+pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> SyntaxExtension {\n-        NormalTT(SyntaxExpanderTT{expander: f, span: None})\n+    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> @Transformer {\n+        @SE(NormalTT(SyntaxExpanderTT{expander: f, span: None}))\n     }\n-    // utility function to simplify creating ItemTT syntax extensions\n-    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> SyntaxExtension {\n-        ItemTT(SyntaxExpanderTTItem{expander: f, span: None})\n+    // utility function to simplify creating IdentTT syntax extensions\n+    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> @Transformer {\n+        @SE(IdentTT(SyntaxExpanderTTItem{expander: f, span: None}))\n     }\n-    let syntax_expanders = HashMap();\n+    let mut syntax_expanders = LinearMap::new();\n+    // NB identifier starts with space, and can't conflict with legal idents\n+    syntax_expanders.insert(@~\" block\",\n+                            @ScopeMacros(true));\n     syntax_expanders.insert(@~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(@~\"fmt\",\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         @~\"auto_encode\",\n-        ItemDecorator(ext::auto_encode::expand_auto_encode));\n+        @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         @~\"auto_decode\",\n-        ItemDecorator(ext::auto_encode::expand_auto_decode));\n+        @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(@~\"env\",\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(@~\"concat_idents\",\n@@ -110,25 +140,25 @@ pub fn syntax_expander_table() -> SyntaxExtensions {\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(@~\"deriving_eq\",\n-                            ItemDecorator(\n-                                ext::deriving::expand_deriving_eq));\n+                            @SE(ItemDecorator(\n+                                ext::deriving::expand_deriving_eq)));\n     syntax_expanders.insert(@~\"deriving_iter_bytes\",\n-                            ItemDecorator(\n-                                ext::deriving::expand_deriving_iter_bytes));\n+                            @SE(ItemDecorator(\n+                                ext::deriving::expand_deriving_iter_bytes)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(@~\"quote_tokens\",\n                        builtin_normal_tt(ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(@~\"quote_expr\",\n-                            builtin_normal_tt(ext::quote::expand_quote_expr));\n+                       builtin_normal_tt(ext::quote::expand_quote_expr));\n     syntax_expanders.insert(@~\"quote_ty\",\n-                            builtin_normal_tt(ext::quote::expand_quote_ty));\n+                       builtin_normal_tt(ext::quote::expand_quote_ty));\n     syntax_expanders.insert(@~\"quote_item\",\n-                            builtin_normal_tt(ext::quote::expand_quote_item));\n+                       builtin_normal_tt(ext::quote::expand_quote_item));\n     syntax_expanders.insert(@~\"quote_pat\",\n-                            builtin_normal_tt(ext::quote::expand_quote_pat));\n+                       builtin_normal_tt(ext::quote::expand_quote_pat));\n     syntax_expanders.insert(@~\"quote_stmt\",\n-                            builtin_normal_tt(ext::quote::expand_quote_stmt));\n+                       builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(@~\"line\",\n                             builtin_normal_tt(\n@@ -159,7 +189,7 @@ pub fn syntax_expander_table() -> SyntaxExtensions {\n     syntax_expanders.insert(\n         @~\"trace_macros\",\n         builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n-    return syntax_expanders;\n+    MapChain::new(~syntax_expanders)\n }\n \n // One of these is made during expansion and incrementally updated as we go;\n@@ -348,6 +378,149 @@ pub fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n     es\n }\n \n+// in order to have some notion of scoping for macros,\n+// we want to implement the notion of a transformation\n+// environment.\n+\n+// This environment maps Names to Transformers.\n+// Initially, this includes macro definitions and\n+// block directives.\n+\n+\n+\n+// Actually, the following implementation is parameterized\n+// by both key and value types.\n+\n+//impl question: how to implement it? Initially, the\n+// env will contain only macros, so it might be painful\n+// to add an empty frame for every context. Let's just\n+// get it working, first....\n+\n+// NB! the mutability of the underlying maps means that\n+// if expansion is out-of-order, a deeper scope may be\n+// able to refer to a macro that was added to an enclosing\n+// scope lexically later than the deeper scope.\n+\n+// Note on choice of representation: I've been pushed to\n+// use a top-level managed pointer by some difficulties\n+// with pushing and popping functionally, and the ownership\n+// issues.  As a result, the values returned by the table\n+// also need to be managed; the &self/... type that Maps\n+// return won't work for things that need to get outside\n+// of that managed pointer.  The easiest way to do this\n+// is just to insist that the values in the tables are\n+// managed to begin with.\n+\n+// a transformer env is either a base map or a map on top\n+// of another chain.\n+pub enum MapChain<K,V> {\n+    BaseMapChain(~LinearMap<K,@V>),\n+    ConsMapChain(~LinearMap<K,@V>,@mut MapChain<K,V>)\n+}\n+\n+\n+// get the map from an env frame\n+impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n+\n+    // Constructor. I don't think we need a zero-arg one.\n+    static fn new(+init: ~LinearMap<K,@V>) -> @mut MapChain<K,V> {\n+        @mut BaseMapChain(init)\n+    }\n+\n+    // add a new frame to the environment (functionally)\n+    fn push_frame (@mut self) -> @mut MapChain<K,V> {\n+        @mut ConsMapChain(~LinearMap::new() ,self)\n+    }\n+\n+// no need for pop, it'll just be functional.\n+\n+    // utility fn...\n+\n+    // ugh: can't get this to compile with mut because of the\n+    // lack of flow sensitivity.\n+    fn get_map(&self) -> &self/LinearMap<K,@V> {\n+        match *self {\n+            BaseMapChain (~ref map) => map,\n+            ConsMapChain (~ref map,_) => map\n+        }\n+    }\n+\n+// traits just don't work anywhere...?\n+//pub impl Map<Name,SyntaxExtension> for MapChain {\n+\n+    pure fn contains_key (&self, key: &K) -> bool {\n+        match *self {\n+            BaseMapChain (ref map) => map.contains_key(key),\n+            ConsMapChain (ref map,ref rest) =>\n+            (map.contains_key(key)\n+             || rest.contains_key(key))\n+        }\n+    }\n+    // should each_key and each_value operate on shadowed\n+    // names? I think not.\n+    // delaying implementing this....\n+    pure fn each_key (&self, _f: &fn (&K)->bool) {\n+        fail!(~\"unimplemented 2013-02-15T10:01\");\n+    }\n+\n+    pure fn each_value (&self, _f: &fn (&V) -> bool) {\n+        fail!(~\"unimplemented 2013-02-15T10:02\");\n+    }\n+\n+    // Returns a copy of the value that the name maps to.\n+    // Goes down the chain 'til it finds one (or bottom out).\n+    fn find (&self, key: &K) -> Option<@V> {\n+        match self.get_map().find (key) {\n+            Some(ref v) => Some(**v),\n+            None => match *self {\n+                BaseMapChain (_) => None,\n+                ConsMapChain (_,ref rest) => rest.find(key)\n+            }\n+        }\n+    }\n+\n+    // insert the binding into the top-level map\n+    fn insert (&mut self, +key: K, +ext: @V) -> bool {\n+        // can't abstract over get_map because of flow sensitivity...\n+        match *self {\n+            BaseMapChain (~ref mut map) => map.insert(key, ext),\n+            ConsMapChain (~ref mut map,_) => map.insert(key,ext)\n+        }\n+    }\n+\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use super::MapChain;\n+    use util::testing::check_equal;\n+\n+    #[test] fn testenv () {\n+        let mut a = LinearMap::new();\n+        a.insert (@~\"abc\",@15);\n+        let m = MapChain::new(~a);\n+        m.insert (@~\"def\",@16);\n+        // FIXME: #4492 (ICE)  check_equal(m.find(&@~\"abc\"),Some(@15));\n+        //  ....               check_equal(m.find(&@~\"def\"),Some(@16));\n+        check_equal(*(m.find(&@~\"abc\").get()),15);\n+        check_equal(*(m.find(&@~\"def\").get()),16);\n+        let n = m.push_frame();\n+        // old bindings are still present:\n+        check_equal(*(n.find(&@~\"abc\").get()),15);\n+        check_equal(*(n.find(&@~\"def\").get()),16);\n+        n.insert (@~\"def\",@17);\n+        // n shows the new binding\n+        check_equal(*(n.find(&@~\"abc\").get()),15);\n+        check_equal(*(n.find(&@~\"def\").get()),17);\n+        // ... but m still has the old ones\n+        // FIXME: #4492: check_equal(m.find(&@~\"abc\"),Some(@15));\n+        // FIXME: #4492: check_equal(m.find(&@~\"def\"),Some(@16));\n+        check_equal(*(m.find(&@~\"abc\").get()),15);\n+        check_equal(*(m.find(&@~\"def\").get()),16);\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "9a3e8da2b814570e3bc8bc714eba8c62db37ed04", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 262, "deletions": 49, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -17,13 +17,13 @@ use attr;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan};\n use ext::base::*;\n use fold::*;\n-use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n+use parse::{parser, parse_item_from_source_str, new_parser_from_tts};\n \n use core::option;\n use core::vec;\n-use std::oldmap::HashMap;\n+use core::hashmap::LinearMap;\n \n-pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n+pub fn expand_expr(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                    e: expr_, s: span, fld: ast_fold,\n                    orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n@@ -41,13 +41,14 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                 /* using idents and token::special_idents would make the\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(&extname) {\n+                // leaving explicit deref here to highlight unbox op:\n+                match (*extsbox).find(&extname) {\n                   None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n-                  Some(NormalTT(SyntaxExpanderTT{expander: exp,\n-                                                 span: exp_sp})) => {\n+                  Some(@SE(NormalTT(SyntaxExpanderTT{expander: exp,\n+                                                 span: exp_sp}))) => {\n                     cx.bt_push(ExpandedFrom(CallInfo{\n                         call_site: s,\n                         callee: NameAndSpan {\n@@ -92,7 +93,7 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n+pub fn expand_mod_items(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                         module_: ast::_mod, fld: ast_fold,\n                         orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n@@ -106,9 +107,8 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = attr::get_attr_name(attr);\n \n-            match exts.find(&mname) {\n-              None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n-              Some(ItemDecorator(dec_fn)) => {\n+            match (*extsbox).find(&mname) {\n+              Some(@SE(ItemDecorator(dec_fn))) => {\n                   cx.bt_push(ExpandedFrom(CallInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n@@ -119,7 +119,8 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();\n                   r\n-              }\n+              },\n+              _ => items,\n             }\n         }\n     };\n@@ -128,34 +129,94 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n }\n \n \n+// eval $e with a new exts frame:\n+macro_rules! with_exts_frame (\n+    ($extsboxexpr:expr,$e:expr) =>\n+    ({let extsbox = $extsboxexpr;\n+      let oldexts = *extsbox;\n+      *extsbox = oldexts.push_frame();\n+      let result = $e;\n+      *extsbox = oldexts;\n+      result\n+     })\n+)\n+\n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(exts: SyntaxExtensions,\n+pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n                    orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n-    let is_mod = match it.node {\n-      ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n-      _ => false\n-    };\n+    // need to do expansion first... it might turn out to be a module.\n     let maybe_it = match it.node {\n-      ast::item_mac(*) => expand_item_mac(exts, cx, it, fld),\n+      ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n       _ => Some(it)\n     };\n-\n     match maybe_it {\n       Some(it) => {\n-        if is_mod { cx.mod_push(it.ident); }\n-        let ret_val = orig(it, fld);\n-        if is_mod { cx.mod_pop(); }\n-        return ret_val;\n+          match it.node {\n+              ast::item_mod(_) | ast::item_foreign_mod(_) => {\n+                  cx.mod_push(it.ident);\n+                  let result =\n+                      // don't push a macro scope for macro_escape:\n+                      if contains_macro_escape(it.attrs) {\n+                      orig(it,fld)\n+                  } else {\n+                      // otherwise, push a scope:\n+                      with_exts_frame!(extsbox,orig(it,fld))\n+                  };\n+                  cx.mod_pop();\n+                  result\n+              }\n+              _ => orig(it,fld)\n+          }\n       }\n-      None => return None\n+      None => None\n     }\n }\n \n+// does this attribute list contain \"macro_escape\" ?\n+fn contains_macro_escape (attrs: &[ast::attribute]) -> bool{\n+    let mut accum = false;\n+    do attrs.each |attr| {\n+        let mname = attr::get_attr_name(attr);\n+        if (mname == @~\"macro_escape\") {\n+            accum = true;\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+    accum\n+}\n+\n+// this macro disables (one layer of) macro\n+// scoping, to allow a block to add macro bindings\n+// to its parent env\n+macro_rules! without_macro_scoping(\n+    ($extsexpr:expr,$exp:expr) =>\n+    ({\n+        // only evaluate this once:\n+        let exts = $extsexpr;\n+        // capture the existing binding:\n+        let existingBlockBinding =\n+            match exts.find(&@~\" block\"){\n+                Some(binding) => binding,\n+                None => cx.bug(\"expected to find \\\" block\\\" binding\")\n+            };\n+        // this prevents the block from limiting the macros' scope:\n+        exts.insert(@~\" block\",@ScopeMacros(false));\n+        let result = $exp;\n+        // reset the block binding. Note that since the original\n+        // one may have been inherited, this procedure may wind\n+        // up introducing a block binding where one didn't exist\n+        // before.\n+        exts.insert(@~\" block\",existingBlockBinding);\n+        result\n+    }))\n+\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(exts: SyntaxExtensions,\n+pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n                        cx: ext_ctxt, &&it: @ast::item,\n                        fld: ast_fold) -> Option<@ast::item> {\n \n@@ -167,11 +228,11 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match exts.find(&extname) {\n+    let expanded = match (*extsbox).find(&extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n-        Some(NormalTT(ref expand)) => {\n+        Some(@SE(NormalTT(ref expand))) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n@@ -187,7 +248,7 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n             }));\n             ((*expand).expander)(cx, it.span, tts)\n         }\n-        Some(ItemTT(ref expand)) => {\n+        Some(@SE(IdentTT(ref expand))) => {\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n@@ -214,15 +275,16 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n         MRAny(_, item_maker, _) =>\n             option::chain(item_maker(), |i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n-            exts.insert(@/*bad*/ copy mdef.name, (*mdef).ext);\n+            extsbox.insert(@/*bad*/ copy mdef.name, @SE((*mdef).ext));\n             None\n         }\n     };\n     cx.bt_pop();\n     return maybe_it;\n }\n \n-pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n+// expand a stmt\n+pub fn expand_stmt(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n                    && s: stmt_, sp: span, fld: ast_fold,\n                    orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n@@ -238,12 +300,12 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match exts.find(&extname) {\n+    let (fully_expanded, sp) = match (*extsbox).find(&extname) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n \n-        Some(NormalTT(\n-            SyntaxExpanderTT{expander: exp, span: exp_sp})) => {\n+        Some(@SE(NormalTT(\n+            SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n                 callee: NameAndSpan { name: *extname, span: exp_sp }\n@@ -271,27 +333,47 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n         }\n     };\n \n-    return (match fully_expanded {\n+    (match fully_expanded {\n         stmt_expr(e, stmt_id) if semi => stmt_semi(e, stmt_id),\n         _ => { fully_expanded } /* might already have a semi */\n     }, sp)\n \n }\n \n \n+\n+pub fn expand_block(extsbox: @mut SyntaxEnv, cx: ext_ctxt,\n+                    && blk: blk_, sp: span, fld: ast_fold,\n+                    orig: fn@(&&s: blk_, span, ast_fold) -> (blk_, span))\n+    -> (blk_, span) {\n+    match (*extsbox).find(&@~\" block\") {\n+        // no scope limit on macros in this block, no need\n+        // to push an exts frame:\n+        Some(@ScopeMacros(false)) => {\n+            orig (blk,sp,fld)\n+        },\n+        // this block should limit the scope of its macros:\n+        Some(@ScopeMacros(true)) => {\n+            // see note below about treatment of exts table\n+            with_exts_frame!(extsbox,orig(blk,sp,fld))\n+        },\n+        _ => cx.span_bug(sp,\n+                         ~\"expected ScopeMacros binding for \\\" block\\\"\")\n+    }\n+}\n+\n pub fn new_span(cx: ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n-// FIXME (#2247): this is a terrible kludge to inject some macros into\n-// the default compilation environment. When the macro-definition system\n-// is substantially more mature, these should move from here, into a\n-// compiled part of libcore at very least.\n+// FIXME (#2247): this is a moderately bad kludge to inject some macros into\n+// the default compilation environment. It would be much nicer to use\n+// a mechanism like syntax_quote to ensure hygiene.\n \n pub fn core_macros() -> ~str {\n     return\n-~\"{\n+~\"pub mod macros {\n     macro_rules! ignore (($($x:tt)*) => (()))\n \n     macro_rules! error ( ($( $arg:expr ),+) => (\n@@ -341,29 +423,160 @@ pub fn core_macros() -> ~str {\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::crate_cfg, c: @crate) -> @crate {\n-    let exts = syntax_expander_table();\n+    // adding *another* layer of indirection here so that the block\n+    // visitor can swap out one exts table for another for the duration\n+    // of the block.  The cleaner alternative would be to thread the\n+    // exts table through the fold, but that would require updating\n+    // every method/element of AstFoldFns in fold.rs.\n+    let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n     let f_pre = @AstFoldFns {\n-        fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n-        fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n-        fold_item: |a,b| expand_item(exts, cx, a, b, afp.fold_item),\n-        fold_stmt: |a,b,c| expand_stmt(exts, cx, a, b, c, afp.fold_stmt),\n+        fold_expr: |expr,span,recur|\n+            expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),\n+        fold_mod: |modd,recur|\n+            expand_mod_items(extsbox, cx, modd, recur, afp.fold_mod),\n+        fold_item: |item,recur|\n+            expand_item(extsbox, cx, item, recur, afp.fold_item),\n+        fold_stmt: |stmt,span,recur|\n+            expand_stmt(extsbox, cx, stmt, span, recur, afp.fold_stmt),\n+        fold_block: |blk,span,recur|\n+            expand_block (extsbox, cx, blk, span, recur, afp.fold_block),\n         new_span: |a| new_span(cx, a),\n         .. *afp};\n     let f = make_fold(f_pre);\n-    let cm = parse_expr_from_source_str(~\"<core-macros>\",\n-                                        @core_macros(),\n-                                        cfg,\n-                                        parse_sess);\n-\n+    // add a bunch of macros as though they were placed at the\n+    // head of the program (ick).\n+    let attrs = ~[spanned {span:codemap::dummy_sp(),\n+                           node: attribute_\n+                               {style:attr_outer,\n+                                value:spanned\n+                                    {node:meta_word(@~\"macro_escape\"),\n+                                     span:codemap::dummy_sp()},\n+                                is_sugared_doc:false}}];\n+\n+    let cm = match parse_item_from_source_str(~\"<core-macros>\",\n+                                              @core_macros(),\n+                                              cfg,attrs,\n+                                              parse_sess) {\n+        Some(item) => item,\n+        None => cx.bug(~\"expected core macros to parse correctly\")\n+    };\n     // This is run for its side-effects on the expander env,\n     // as it registers all the core macros as expanders.\n-    f.fold_expr(cm);\n+    f.fold_item(cm);\n \n     let res = @f.fold_crate(*c);\n     return res;\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::testing::check_equal;\n+\n+    // make sure that fail! is present\n+    #[test] fn fail_exists_test () {\n+        let src = ~\"fn main() { fail!(~\\\"something appropriately gloomy\\\");}\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // these following tests are quite fragile, in that they don't test what\n+    // *kind* of failure occurs.\n+\n+    // make sure that macros can leave scope\n+    #[should_fail]\n+    #[test] fn macros_cant_escape_fns_test () {\n+        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // make sure that macros can leave scope for modules\n+    #[should_fail]\n+    #[test] fn macros_cant_escape_mods_test () {\n+        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    // macro_escape modules shouldn't cause macros to leave scope\n+    #[test] fn macros_can_escape_flattened_mods_test () {\n+        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+                    fn inty() -> int { z!() }\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let crate_ast = parse::parse_crate_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,sess);\n+        // should fail:\n+        expand_crate(sess,cfg,crate_ast);\n+    }\n+\n+    #[test] fn core_macros_must_parse () {\n+        let src = ~\"\n+  pub mod macros {\n+    macro_rules! ignore (($($x:tt)*) => (()))\n+\n+    macro_rules! error ( ($( $arg:expr ),+) => (\n+        log(::core::error, fmt!( $($arg),+ )) ))\n+}\";\n+        let sess = parse::new_parse_sess(None);\n+        let cfg = ~[];\n+        let item_ast = parse::parse_item_from_source_str(\n+            ~\"<test>\",\n+            @src,\n+            cfg,~[make_dummy_attr (@~\"macro_escape\")],sess);\n+        match item_ast {\n+            Some(_) => (), // success\n+            None => fail!(~\"expected this to parse\")\n+        }\n+    }\n+\n+    #[test] fn test_contains_flatten (){\n+        let attr1 = make_dummy_attr (@~\"foo\");\n+        let attr2 = make_dummy_attr (@~\"bar\");\n+        let escape_attr = make_dummy_attr (@~\"macro_escape\");\n+        let attrs1 = ~[attr1, escape_attr, attr2];\n+        check_equal (contains_macro_escape (attrs1),true);\n+        let attrs2 = ~[attr1,attr2];\n+        check_equal (contains_macro_escape (attrs2),false);\n+    }\n+\n+    // make a \"meta_word\" outer attribute with the given name\n+    fn make_dummy_attr(s: @~str) -> ast::attribute {\n+        spanned {span:codemap::dummy_sp(),\n+                 node: attribute_\n+                     {style:attr_outer,\n+                      value:spanned\n+                          {node:meta_word(s),\n+                           span:codemap::dummy_sp()},\n+                      is_sugared_doc:false}}\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "808a80e6ad049d769d5a07cf74fbe77266184580", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -22,22 +22,9 @@ use core::result;\n use core::str;\n use core::vec;\n \n-fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n-    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n-    match call_site.expn_info {\n-        Some(next_expn_info) => {\n-            let ExpandedFrom(CallInfo {\n-                callee: NameAndSpan {name, _},\n-                _\n-            }) = *next_expn_info;\n-            // Don't recurse into file using \"include!\"\n-            if name == ~\"include\" { return expn_info; }\n-\n-            topmost_expn_info(next_expn_info)\n-        },\n-        None => expn_info\n-    }\n-}\n+// These macros all relate to the file system; they either return\n+// the column/row/filename of the expression, or they include\n+// a given file into the current one.\n \n /* line!(): expands to the current line number */\n pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n@@ -87,6 +74,9 @@ pub fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n                                   |x| cx.str_of(*x)), ~\"::\")))\n }\n \n+// include! : parse the given file as an expr\n+// This is generally a bad idea because it's going to behave\n+// unhygienically.\n pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n@@ -96,6 +86,7 @@ pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(p.parse_expr())\n }\n \n+// include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n@@ -126,6 +117,26 @@ pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     }\n }\n \n+// recur along an ExpnInfo chain to find the original expression\n+fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n+    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n+    match call_site.expn_info {\n+        Some(next_expn_info) => {\n+            let ExpandedFrom(CallInfo {\n+                callee: NameAndSpan {name, _},\n+                _\n+            }) = *next_expn_info;\n+            // Don't recurse into file using \"include!\"\n+            if name == ~\"include\" { return expn_info; }\n+\n+            topmost_expn_info(next_expn_info)\n+        },\n+        None => expn_info\n+    }\n+}\n+\n+// resolve a file-system path to an absolute file-system path (if it\n+// isn't already)\n fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {"}, {"sha": "51cc25e84a33cae4eb6787702d48a093e47f5cb8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -770,11 +770,13 @@ pub mod test {\n     use diagnostic;\n     use util::testing::{check_equal, check_equal_ptr};\n \n+    // represents a testing reader (incl. both reader and interner)\n     struct Env {\n         interner: @token::ident_interner,\n         string_reader: @mut StringReader\n     }\n \n+    // open a string reader for the given string\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", @teststr);\n@@ -809,6 +811,52 @@ pub mod test {\n         check_equal (string_reader.last_pos,BytePos(29))\n     }\n \n+    // check that the given reader produces the desired stream\n+    // of tokens (stop checking after exhausting the expected vec)\n+    fn check_tokenization (env: Env, expected: ~[token::Token]) {\n+        for expected.each |expected_tok| {\n+            let TokenAndSpan {tok:actual_tok, sp: _} =\n+                env.string_reader.next_token();\n+            check_equal(&actual_tok,expected_tok);\n+        }\n+    }\n+\n+    // make the identifier by looking up the string in the interner\n+    fn mk_ident (env: Env, id: ~str, is_mod_name: bool) -> token::Token {\n+        token::IDENT (env.interner.intern(@id),is_mod_name)\n+    }\n+\n+    #[test] fn doublecolonparsing () {\n+        let env = setup (~\"a b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",false),\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_2 () {\n+        let env = setup (~\"a::b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",true),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_3 () {\n+        let env = setup (~\"a ::b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",false),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n+    #[test] fn dcparsing_4 () {\n+        let env = setup (~\"a:: b\");\n+        check_tokenization (env,\n+                           ~[mk_ident (env,~\"a\",true),\n+                             token::MOD_SEP,\n+                             mk_ident (env,~\"b\",false)]);\n+    }\n+\n     #[test] fn character_a() {\n         let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} ="}, {"sha": "a31a73f594ad2e332a91f4f47bd782cf3923a2dd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -94,9 +94,7 @@ pub fn parse_crate_from_source_str(name: ~str,\n                                    sess: @mut ParseSess) -> @ast::crate {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n-    let r = p.parse_crate_mod(cfg);\n-    p.abort_if_errors();\n-    return r;\n+    maybe_aborted(p.parse_crate_mod(cfg),p)\n }\n \n pub fn parse_expr_from_source_str(name: ~str,\n@@ -105,9 +103,7 @@ pub fn parse_expr_from_source_str(name: ~str,\n                                   sess: @mut ParseSess) -> @ast::expr {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n-    let r = p.parse_expr();\n-    p.abort_if_errors();\n-    return r;\n+    maybe_aborted(p.parse_expr(), p)\n }\n \n pub fn parse_item_from_source_str(name: ~str,\n@@ -118,9 +114,7 @@ pub fn parse_item_from_source_str(name: ~str,\n                                -> Option<@ast::item> {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n-    let r = p.parse_item(attrs);\n-    p.abort_if_errors();\n-    return r;\n+    maybe_aborted(p.parse_item(attrs),p)\n }\n \n pub fn parse_stmt_from_source_str(name: ~str,\n@@ -130,9 +124,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n                                   sess: @mut ParseSess) -> @ast::stmt {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n-    let r = p.parse_stmt(attrs);\n-    p.abort_if_errors();\n-    return r;\n+    maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n pub fn parse_tts_from_source_str(name: ~str,\n@@ -142,9 +134,7 @@ pub fn parse_tts_from_source_str(name: ~str,\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n     *p.quote_depth += 1u;\n-    let r = p.parse_all_token_trees();\n-    p.abort_if_errors();\n-    return r;\n+    maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n@@ -159,8 +149,7 @@ pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n-    p.abort_if_errors();\n-    r\n+    maybe_aborted(r,p)\n }\n \n pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n@@ -181,8 +170,8 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     return Parser(sess, cfg, srdr as reader);\n }\n \n-// Read the entire source file, return a parser\n-// that draws from that string\n+/// Read the entire source file, return a parser\n+/// that draws from that string\n pub fn new_parser_result_from_file(sess: @mut ParseSess,\n                             cfg: ast::crate_cfg,\n                             path: &Path)\n@@ -201,7 +190,7 @@ pub fn new_parser_result_from_file(sess: @mut ParseSess,\n     }\n }\n \n-/// Create a new parser for an entire crate, handling errors as appropriate\n+/// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n@@ -232,6 +221,13 @@ pub fn new_parser_from_tts(sess: @mut ParseSess, cfg: ast::crate_cfg,\n     return Parser(sess, cfg, trdr as reader)\n }\n \n+// abort if necessary\n+pub fn maybe_aborted<T>(+result : T, p: Parser) -> T {\n+    p.abort_if_errors();\n+    result\n+}\n+\n+\n \n #[cfg(test)]\n mod test {"}, {"sha": "207f6d499159f788bd387c7bedd31072fc9ac5f5", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a902c81d7bc57fece1b520591f328afe76154a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=99a902c81d7bc57fece1b520591f328afe76154a", "patch": "@@ -87,7 +87,9 @@ pub enum Token {\n     LIT_STR(ast::ident),\n \n     /* Name components */\n-    // an identifier contains an \"is_mod_name\" boolean.\n+    // an identifier contains an \"is_mod_name\" boolean,\n+    // indicating whether :: follows this token with no\n+    // whitespace in between.\n     IDENT(ast::ident, bool),\n     UNDERSCORE,\n     LIFETIME(ast::ident),"}]}