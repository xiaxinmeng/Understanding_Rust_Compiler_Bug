{"sha": "b24330fb7d9e89d63eb03d81fe577172aad49525", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDMzMGZiN2Q5ZTg5ZDYzZWIwM2Q4MWZlNTc3MTcyYWFkNDk1MjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-08T14:16:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-08T14:16:37Z"}, "message": "Auto merge of #53705 - ms2300:tmp, r=oli-obk\n\n#53576 Renaming TyAnon -> TyOpaque\n\nFixes #53576", "tree": {"sha": "21d6904410856dedf7e6c3ab033b95014042f54b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21d6904410856dedf7e6c3ab033b95014042f54b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b24330fb7d9e89d63eb03d81fe577172aad49525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b24330fb7d9e89d63eb03d81fe577172aad49525", "html_url": "https://github.com/rust-lang/rust/commit/b24330fb7d9e89d63eb03d81fe577172aad49525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b24330fb7d9e89d63eb03d81fe577172aad49525/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05cb29e96f718a94d31afd094b1efd7c05be4269", "url": "https://api.github.com/repos/rust-lang/rust/commits/05cb29e96f718a94d31afd094b1efd7c05be4269", "html_url": "https://github.com/rust-lang/rust/commit/05cb29e96f718a94d31afd094b1efd7c05be4269"}, {"sha": "f4d4faaeedbdb7271221c9b48fd809a5e8469445", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d4faaeedbdb7271221c9b48fd809a5e8469445", "html_url": "https://github.com/rust-lang/rust/commit/f4d4faaeedbdb7271221c9b48fd809a5e8469445"}], "stats": {"total": 452, "additions": 228, "deletions": 224}, "files": [{"sha": "e43ef01baad0f8e7a782b13c5d30e37124f5ca5c", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -878,7 +878,7 @@ for ty::TyKind<'gcx>\n             Projection(ref projection_ty) => {\n                 projection_ty.hash_stable(hcx, hasher);\n             }\n-            Anon(def_id, substs) => {\n+            Opaque(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }"}, {"sha": "b30ccb5976c98c9cf46f2d85a320ae06d08adb0e", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -285,7 +285,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             | ty::Projection(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n-            | ty::Anon(..) => {\n+            | ty::Opaque(..) => {\n                 if t.flags.intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {"}, {"sha": "1cb813c39e68ce6fbb94f85362b1a94982c4021a", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::Param(..) |\n             ty::Closure(..) |\n             ty::GeneratorWitness(..) |\n-            ty::Anon(..) => {\n+            ty::Opaque(..) => {\n                 t.super_fold_with(self)\n             }\n         }"}, {"sha": "a092bac51878d802a98355b9022fb0555f46a161", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -48,7 +48,7 @@ use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n-pub mod anon_types;\n+pub mod opaque_types;\n pub mod at;\n pub mod canonical;\n mod combine;"}, {"sha": "9d65c3950626ceb85137355e5a7e40d41ab0e34c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "renamed", "additions": 87, "deletions": 84, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -22,13 +22,13 @@ use ty::outlives::Component;\n use ty::subst::{Kind, Substs, UnpackedKind};\n use util::nodemap::DefIdMap;\n \n-pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n+pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n-/// Information about the anonymous, abstract types whose values we\n+/// Information about the opaque, abstract types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n #[derive(Copy, Clone, Debug)]\n-pub struct AnonTypeDecl<'tcx> {\n+pub struct OpaqueTypeDecl<'tcx> {\n     /// The substitutions that we apply to the abstract that that this\n     /// `impl Trait` desugars to. e.g., if:\n     ///\n@@ -81,7 +81,7 @@ pub struct AnonTypeDecl<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all anonymized types in `value` with fresh inference variables\n+    /// Replace all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n     ///     impl Iterator<Item = impl Debug>\n@@ -92,47 +92,49 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///     ?0: Iterator<Item = ?1>\n     ///     ?1: Debug\n     ///\n-    /// Moreover, it returns a `AnonTypeMap` that would map `?0` to\n+    /// Moreover, it returns a `OpaqueTypeMap` that would map `?0` to\n     /// info about the `impl Iterator<..>` type and `?1` to info about\n     /// the `impl Debug` type.\n     ///\n     /// # Parameters\n     ///\n-    /// - `parent_def_id` -- we will only instantiate anonymous types\n+    /// - `parent_def_id` -- we will only instantiate opaque types\n     ///   with this parent. This is typically the def-id of the function\n-    ///   in whose return type anon types are being instantiated.\n+    ///   in whose return type opaque types are being instantiated.\n     /// - `body_id` -- the body-id with which the resulting obligations should\n     ///   be associated\n     /// - `param_env` -- the in-scope parameter environment to be used for\n     ///   obligations\n-    /// - `value` -- the value within which we are instantiating anon types\n-    pub fn instantiate_anon_types<T: TypeFoldable<'tcx>>(\n+    /// - `value` -- the value within which we are instantiating opaque types\n+    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: ast::NodeId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n-    ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n+    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n-            \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n+            \"instantiate_opaque_types(value={:?},\n+            parent_def_id={:?}, body_id={:?},\n+            param_env={:?})\",\n             value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n             parent_def_id,\n             body_id,\n             param_env,\n-            anon_types: DefIdMap(),\n+            opaque_types: DefIdMap(),\n             obligations: vec![],\n         };\n-        let value = instantiator.instantiate_anon_types_in_map(value);\n+        let value = instantiator.instantiate_opaque_types_in_map(value);\n         InferOk {\n-            value: (value, instantiator.anon_types),\n+            value: (value, instantiator.opaque_types),\n             obligations: instantiator.obligations,\n         }\n     }\n \n-    /// Given the map `anon_types` containing the existential `impl\n+    /// Given the map `opaque_types` containing the existential `impl\n     /// Trait` types whose underlying, hidden types are being\n     /// inferred, this method adds constraints to the regions\n     /// appearing in those underlying hidden types to ensure that they\n@@ -267,34 +269,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `anon_types` -- the map produced by `instantiate_anon_types`\n+    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    pub fn constrain_anon_types<FRR: FreeRegionRelations<'tcx>>(\n+    pub fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n-        anon_types: &AnonTypeMap<'tcx>,\n+        opaque_types: &OpaqueTypeMap<'tcx>,\n         free_region_relations: &FRR,\n     ) {\n-        debug!(\"constrain_anon_types()\");\n+        debug!(\"constrain_opaque_types()\");\n \n-        for (&def_id, anon_defn) in anon_types {\n-            self.constrain_anon_type(def_id, anon_defn, free_region_relations);\n+        for (&def_id, opaque_defn) in opaque_types {\n+            self.constrain_opaque_type(def_id, opaque_defn, free_region_relations);\n         }\n     }\n \n-    fn constrain_anon_type<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n-        anon_defn: &AnonTypeDecl<'tcx>,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n         free_region_relations: &FRR,\n     ) {\n-        debug!(\"constrain_anon_type()\");\n-        debug!(\"constrain_anon_type: def_id={:?}\", def_id);\n-        debug!(\"constrain_anon_type: anon_defn={:#?}\", anon_defn);\n+        debug!(\"constrain_opaque_type()\");\n+        debug!(\"constrain_opaque_type: def_id={:?}\", def_id);\n+        debug!(\"constrain_opaque_type: opaque_defn={:#?}\", opaque_defn);\n \n-        let concrete_ty = self.resolve_type_vars_if_possible(&anon_defn.concrete_ty);\n+        let concrete_ty = self.resolve_type_vars_if_possible(&opaque_defn.concrete_ty);\n \n-        debug!(\"constrain_anon_type: concrete_ty={:?}\", concrete_ty);\n+        debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n \n         let abstract_type_generics = self.tcx.generics_of(def_id);\n \n@@ -303,7 +305,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // If there are required region bounds, we can just skip\n         // ahead.  There will already be a registered region\n         // obligation related `concrete_ty` to those regions.\n-        if anon_defn.has_required_region_bounds {\n+        if opaque_defn.has_required_region_bounds {\n             return;\n         }\n \n@@ -321,11 +323,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 _ => continue\n             }\n             // Get the value supplied for this region from the substs.\n-            let subst_arg = anon_defn.substs.region_at(param.index as usize);\n+            let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n \n             // Compute the least upper bound of it with the other regions.\n-            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n-            debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n+            debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n+            debug!(\"constrain_opaque_types: subst_arg={:?}\", subst_arg);\n             match least_region {\n                 None => least_region = Some(subst_arg),\n                 Some(lr) => {\n@@ -355,7 +357,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n-        debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+        debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n         // Require that the type `concrete_ty` outlives\n         // `least_region`, modulo any type parameters that appear\n@@ -384,7 +386,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // annotations are needed in this case\n                         self.tcx\n                             .sess\n-                            .delay_span_bug(span, \"unresolved inf var in anon\");\n+                            .delay_span_bug(span, \"unresolved inf var in opaque\");\n                     }\n \n                     Component::Projection(ty::ProjectionTy {\n@@ -405,7 +407,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given the fully resolved, instantiated type for an anonymous\n+    /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an abstract type\n     /// definition -- that is, the inferred value of `Foo1<'x>` or\n@@ -420,22 +422,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// purpose of this function is to do that translation.\n     ///\n     /// (*) C1 and C2 were introduced in the comments on\n-    /// `constrain_anon_types`. Read that comment for more context.\n+    /// `constrain_opaque_types`. Read that comment for more context.\n     ///\n     /// # Parameters\n     ///\n     /// - `def_id`, the `impl Trait` type\n-    /// - `anon_defn`, the anonymous definition created in `instantiate_anon_types`\n+    /// - `opaque_defn`, the opaque definition created in `instantiate_opaque_types`\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n-    ///   `anon_defn.concrete_ty`\n-    pub fn infer_anon_definition_from_instantiation(\n+    ///   `opaque_defn.concrete_ty`\n+    pub fn infer_opaque_definition_from_instantiation(\n         &self,\n         def_id: DefId,\n-        anon_defn: &AnonTypeDecl<'tcx>,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n         instantiated_ty: Ty<'gcx>,\n     ) -> Ty<'gcx> {\n         debug!(\n-            \"infer_anon_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n+            \"infer_opaque_definition_from_instantiation(def_id={:?}, instantiated_ty={:?})\",\n             def_id, instantiated_ty\n         );\n \n@@ -448,7 +450,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n         let id_substs = Substs::identity_for_item(gcx, def_id);\n-        let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = anon_defn\n+        let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = opaque_defn\n             .substs\n             .iter()\n             .enumerate()\n@@ -467,7 +469,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 instantiated_ty,\n             ));\n         debug!(\n-            \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n+            \"infer_opaque_definition_from_instantiation: definition_ty={:?}\",\n             definition_ty\n         );\n \n@@ -487,7 +489,7 @@ struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// our own errors because they are sometimes derivative.\n     tainted_by_errors: bool,\n \n-    anon_type_def_id: DefId,\n+    opaque_type_def_id: DefId,\n     map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n     map_missing_regions_to_empty: bool,\n \n@@ -499,14 +501,14 @@ impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         tainted_by_errors: bool,\n-        anon_type_def_id: DefId,\n+        opaque_type_def_id: DefId,\n         map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n         hidden_ty: Ty<'tcx>,\n     ) -> Self {\n         Self {\n             tcx,\n             tainted_by_errors,\n-            anon_type_def_id,\n+            opaque_type_def_id,\n             map,\n             map_missing_regions_to_empty: false,\n             hidden_ty: Some(hidden_ty),\n@@ -554,7 +556,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n             None => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        let span = self.tcx.def_span(self.anon_type_def_id);\n+                        let span = self.tcx.def_span(self.opaque_type_def_id);\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n@@ -644,19 +646,19 @@ struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     parent_def_id: DefId,\n     body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n-    anon_types: AnonTypeMap<'tcx>,\n+    opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n-    fn instantiate_anon_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n-        debug!(\"instantiate_anon_types_in_map(value={:?})\", value);\n+    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        debug!(\"instantiate_opaque_types_in_map(value={:?})\", value);\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n             tcx,\n             reg_op: |reg| reg,\n             fldop: |ty| {\n-                if let ty::Anon(def_id, substs) = ty.sty {\n+                if let ty::Opaque(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is\n@@ -680,24 +682,24 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // ```\n                     //\n                     // Here, the return type of `foo` references a\n-                    // `Anon` indeed, but not one whose value is\n+                    // `Opaque` indeed, but not one whose value is\n                     // presently being inferred. You can get into a\n                     // similar situation with closure return types\n                     // today:\n                     //\n                     // ```rust\n                     // fn foo() -> impl Iterator { .. }\n                     // fn bar() {\n-                    //     let x = || foo(); // returns the Anon assoc with `foo`\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n+                    if let Some(opaque_node_id) = tcx.hir.as_local_node_id(def_id) {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n-                            let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n-                            parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n+                            let opaque_parent_node_id = tcx.hir.get_parent(opaque_node_id);\n+                            parent_def_id == tcx.hir.local_def_id(opaque_parent_node_id)\n                         };\n-                        let in_definition_scope = match tcx.hir.find(anon_node_id) {\n+                        let in_definition_scope = match tcx.hir.find(opaque_node_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -711,30 +713,30 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 }) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    anon_node_id,\n+                                    opaque_node_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,\n-                                    anon_node_id,\n+                                    opaque_node_id,\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir.node_to_string(anon_node_id),\n+                                tcx.hir.node_to_string(opaque_node_id),\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_anon_ty(ty, def_id, substs);\n+                            return self.fold_opaque_ty(ty, def_id, substs);\n                         }\n \n                         debug!(\n-                            \"instantiate_anon_types_in_map: \\\n-                             encountered anon outside it's definition scope \\\n+                            \"instantiate_opaque_types_in_map: \\\n+                             encountered opaque outside it's definition scope \\\n                              def_id={:?}\",\n                             def_id,\n                         );\n@@ -746,7 +748,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn fold_anon_ty(\n+    fn fold_opaque_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n@@ -756,64 +758,64 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n \n         debug!(\n-            \"instantiate_anon_types: Anon(def_id={:?}, substs={:?})\",\n+            \"instantiate_opaque_types: Opaque(def_id={:?}, substs={:?})\",\n             def_id, substs\n         );\n \n-        // Use the same type variable if the exact same Anon appears more\n+        // Use the same type variable if the exact same Opaque appears more\n         // than once in the return type (e.g. if it's passed to a type alias).\n-        if let Some(anon_defn) = self.anon_types.get(&def_id) {\n-            return anon_defn.concrete_ty;\n+        if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+            return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n         let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         debug!(\n-            \"instantiate_anon_types: predicates: {:#?}\",\n+            \"instantiate_opaque_types: predicates: {:#?}\",\n             predicates_of,\n         );\n         let bounds = predicates_of.instantiate(tcx, substs);\n-        debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n+        debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n         let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n         debug!(\n-            \"instantiate_anon_types: required_region_bounds={:?}\",\n+            \"instantiate_opaque_types: required_region_bounds={:?}\",\n             required_region_bounds\n         );\n \n         // make sure that we are in fact defining the *entire* type\n         // e.g. `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`.\n         debug!(\n-            \"instantiate_anon_types: param_env: {:#?}\",\n+            \"instantiate_opaque_types: param_env: {:#?}\",\n             self.param_env,\n         );\n         debug!(\n-            \"instantiate_anon_types: generics: {:#?}\",\n+            \"instantiate_opaque_types: generics: {:#?}\",\n             tcx.generics_of(def_id),\n         );\n \n-        self.anon_types.insert(\n+        self.opaque_types.insert(\n             def_id,\n-            AnonTypeDecl {\n+            OpaqueTypeDecl {\n                 substs,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n             },\n         );\n-        debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n+        debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n-            // which will be the concrete type, instead of the Anon.\n+            // which will be the concrete type, instead of the Opaque.\n             // This also instantiates nested `impl Trait`.\n-            let predicate = self.instantiate_anon_types_in_map(&predicate);\n+            let predicate = self.instantiate_opaque_types_in_map(&predicate);\n \n             let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);\n \n             // Require that the predicate holds for the concrete type.\n-            debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n+            debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n             self.obligations\n                 .push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -822,7 +824,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `anon_node_id` is a sibling or a child of a sibling of `def_id`\n+/// Whether `opaque_node_id` is a sibling or a child of a sibling of `def_id`\n ///\n /// ```rust\n /// pub mod foo {\n@@ -837,23 +839,24 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// ```\n ///\n /// Here, `def_id` will be the `DefId` of the existential type `Baz`.\n-/// `anon_node_id` is the `NodeId` of the reference to Baz -- so either the return type of f1 or f2.\n+/// `opaque_node_id` is the `NodeId` of the reference to Baz --\n+///  so either the return type of f1 or f2.\n /// We will return true if the reference is within the same module as the existential type\n /// So true for f1, false for f2.\n pub fn may_define_existential_type(\n     tcx: TyCtxt,\n     def_id: DefId,\n-    anon_node_id: ast::NodeId,\n+    opaque_node_id: ast::NodeId,\n ) -> bool {\n     let mut node_id = tcx\n         .hir\n         .as_local_node_id(def_id)\n         .unwrap();\n     // named existential types can be defined by any siblings or\n     // children of siblings\n-    let mod_id = tcx.hir.get_parent(anon_node_id);\n+    let mod_id = tcx.hir.get_parent(opaque_node_id);\n     // so we walk up the node tree until we hit the root or the parent\n-    // of the anon type\n+    // of the opaque type\n     while node_id != mod_id && node_id != ast::CRATE_NODE_ID {\n         node_id = tcx.hir.get_parent(node_id);\n     }", "previous_filename": "src/librustc/infer/anon_types/mod.rs"}, {"sha": "b8dd2a12fb58d3129d2437bbb7091e98792c3e21", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -483,7 +483,7 @@ fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n         ty::Closure(..) |\n         ty::Generator(..) |\n         ty::GeneratorWitness(..) |\n-        ty::Anon(..) => {\n+        ty::Opaque(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "a7c697c1cbafdc8b35cf39469ba671b027911597", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::Tuple(..) => Some(10),\n                 ty::Projection(..) => Some(11),\n                 ty::Param(..) => Some(12),\n-                ty::Anon(..) => Some(13),\n+                ty::Opaque(..) => Some(13),\n                 ty::Never => Some(14),\n                 ty::Adt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct => Some(15),"}, {"sha": "e50f59cbc82c1b03476c9cff3b5e422c58d02f3b", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n@@ -986,7 +986,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n         ty::Projection(ref data) => {\n             (data.trait_ref(tcx).def_id, data.substs)\n         }\n-        ty::Anon(def_id, substs) => (def_id, substs),\n+        ty::Opaque(def_id, substs) => (def_id, substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -1518,7 +1518,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n     let ty = if let ty::AssociatedKind::Existential = assoc_ty.item.kind {\n         let item_substs = Substs::identity_for_item(tcx, assoc_ty.item.def_id);\n-        tcx.mk_anon(assoc_ty.item.def_id, item_substs)\n+        tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)\n     };"}, {"sha": "fd8898dffd4f2da428494386eead02f528c62179", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -258,7 +258,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         ty::Dynamic(..)\n         | ty::Projection(..)\n         | ty::Param(_)\n-        | ty::Anon(..)\n+        | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Generator(..) => false,\n     }"}, {"sha": "ea8bc3b20aae94d4a61203e91bedfd83776d115e", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -99,7 +99,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => {\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {"}, {"sha": "232ef108537fefdb0ed634ad594e0db40bcf6940", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -1492,7 +1492,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n-            ty::Projection(_) | ty::Anon(..) => {}\n+            ty::Projection(_) | ty::Opaque(..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n@@ -1528,7 +1528,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n             ty::Projection(ref data) =>\n                 (data.trait_ref(self.tcx()).def_id, data.substs),\n-            ty::Anon(def_id, substs) => (def_id, substs),\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -2203,7 +2203,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ))\n             }\n \n-            ty::Projection(_) | ty::Param(_) | ty::Anon(..) => None,\n+            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n             ty::Infer(ty::CanonicalTy(_)) |\n@@ -2265,7 +2265,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Anon(..) => {\n+            ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -2369,7 +2369,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     .collect()\n             }\n \n-            ty::Anon(def_id, substs) => {\n+            ty::Opaque(def_id, substs) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question."}, {"sha": "eb6f7140a7db79692d6d526a0ee4161abea86398", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2136,7 +2136,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             self,\n             Adt, Array, Slice, RawPtr, Ref, FnDef, FnPtr,\n             Generator, GeneratorWitness, Dynamic, Closure, Tuple,\n-            Param, Infer, Projection, Anon, Foreign);\n+            Param, Infer, Projection, Opaque, Foreign);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n@@ -2606,8 +2606,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(Anon(def_id, substs))\n+    pub fn mk_opaque(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(Opaque(def_id, substs))\n     }\n \n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])"}, {"sha": "2b833c57140b4808d3354e0ad7429ee4965f1d69", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     \"type parameter\".to_string()\n                 }\n             }\n-            ty::Anon(..) => \"anonymized type\".to_string(),\n+            ty::Opaque(..) => \"opaque type\".to_string(),\n             ty::Error => \"type error\".to_string(),\n         }\n     }"}, {"sha": "22a77bd6253c88eac9fae621d4b183aea9f98219", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -47,7 +47,7 @@ pub enum SimplifiedTypeGen<D>\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n     GeneratorWitnessSimplifiedType(usize),\n-    AnonSimplifiedType(D),\n+    OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n     ForeignSimplifiedType(DefId),\n@@ -115,8 +115,8 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 None\n             }\n         }\n-        ty::Anon(def_id, _) => {\n-            Some(AnonSimplifiedType(def_id))\n+        ty::Opaque(def_id, _) => {\n+            Some(OpaqueSimplifiedType(def_id))\n         }\n         ty::Foreign(def_id) => {\n             Some(ForeignSimplifiedType(def_id))\n@@ -146,7 +146,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            AnonSimplifiedType(d) => AnonSimplifiedType(map(d)),\n+            OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             ParameterSimplifiedType => ParameterSimplifiedType,\n             ForeignSimplifiedType(d) => ForeignSimplifiedType(d),\n@@ -181,7 +181,7 @@ impl<'a, 'gcx, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n             ClosureSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             GeneratorSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             GeneratorWitnessSimplifiedType(n) => n.hash_stable(hcx, hasher),\n-            AnonSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            OpaqueSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             FunctionSimplifiedType(n) => n.hash_stable(hcx, hasher),\n             ForeignSimplifiedType(d) => d.hash_stable(hcx, hasher),\n         }"}, {"sha": "341ce40d153b0c8dddde45f254485bbaf9be55c8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -150,7 +150,7 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::Anon(_, substs) => {\n+            &ty::Opaque(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_substs(substs);\n             }"}, {"sha": "a661125d1ca03441601dbd08d2c86c494a46d1ab", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -771,7 +771,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             match t.sty {\n-                ty::Projection(..) | ty::Anon(..) => { return false; }\n+                ty::Projection(..) | ty::Opaque(..) => { return false; }\n                 _ => { }\n             }\n         }"}, {"sha": "0272865bda45bc9bde1166bb720fa2ec8f02f3c6", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -385,7 +385,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::FnPtr(_) |\n         ty::Projection(_) |\n         ty::Param(_) |\n-        ty::Anon(..) |\n+        ty::Opaque(..) |\n         ty::Infer(_) |\n         ty::Error |\n         ty::GeneratorWitness(..) |"}, {"sha": "17d613a2b181a14fb685d30c232ea4127a25af15", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -1103,7 +1103,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::Projection(_) | ty::Anon(..) => {\n+            ty::Projection(_) | ty::Opaque(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n@@ -1373,7 +1373,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::Projection(_) | ty::Anon(..) => {\n+            ty::Projection(_) | ty::Opaque(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -1685,7 +1685,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n             }\n \n-            ty::Projection(_) | ty::Anon(..) | ty::Param(_) |\n+            ty::Projection(_) | ty::Opaque(..) | ty::Param(_) |\n             ty::Infer(_) | ty::Error => {\n                 bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty)\n             }"}, {"sha": "a48aabc3cd7c7379c1f4a1a2de070fc89212e9e3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -559,7 +559,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_suggestable(&self) -> bool {\n         match self.sty {\n-            TyKind::Anon(..) |\n+            TyKind::Opaque(..) |\n             TyKind::FnDef(..) |\n             TyKind::FnPtr(..) |\n             TyKind::Dynamic(..) |\n@@ -2320,7 +2320,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     .collect()\n             }\n \n-            Projection(..) | Anon(..) => {\n+            Projection(..) | Opaque(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n                 vec![ty]"}, {"sha": "68f670708768706bc3390756b2c10ed34bf64688", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::Float(..) |       // OutlivesScalar\n             ty::Never |           // ...\n             ty::Adt(..) |         // OutlivesNominalType\n-            ty::Anon(..) |        // OutlivesNominalType (ish)\n+            ty::Opaque(..) |        // OutlivesNominalType (ish)\n             ty::Foreign(..) |     // OutlivesNominalType\n             ty::Str |             // OutlivesScalar (ish)\n             ty::Array(..) |       // ..."}, {"sha": "8f84fb7e39101f76a4fbbf0a19a063d9dabcbb0f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -564,11 +564,11 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n \n-        (&ty::Anon(a_def_id, a_substs), &ty::Anon(b_def_id, b_substs))\n+        (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            Ok(tcx.mk_anon(a_def_id, substs))\n+            Ok(tcx.mk_opaque(a_def_id, substs))\n         }\n \n         _ =>"}, {"sha": "737878375ec18c5ff1a34b91655287adb2b3c145", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -865,7 +865,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n             ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n             ty::Projection(ref data) => ty::Projection(data.fold_with(folder)),\n-            ty::Anon(did, substs) => ty::Anon(did, substs.fold_with(folder)),\n+            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n             ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n             ty::Param(..) | ty::Never | ty::Foreign(..) => return self\n@@ -900,7 +900,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n             ty::Projection(ref data) => data.visit_with(visitor),\n-            ty::Anon(_, ref substs) => substs.visit_with(visitor),\n+            ty::Opaque(_, ref substs) => substs.visit_with(visitor),\n             ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n             ty::Param(..) | ty::Never | ty::Foreign(..) => false,"}, {"sha": "962b115f1877a8abd8a4d024d7bf86417b53a0da", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -157,13 +157,13 @@ pub enum TyKind<'tcx> {\n     /// `<T as Trait<..>>::N`.\n     Projection(ProjectionTy<'tcx>),\n \n-    /// Anonymized (`impl Trait`) type found in a return type.\n+    /// Opaque (`impl Trait`) type found in a return type.\n     /// The DefId comes either from\n     /// * the `impl Trait` ast::Ty node,\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n     /// After typeck, the concrete type can be found in the `types` map.\n-    Anon(DefId, &'tcx Substs<'tcx>),\n+    Opaque(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param(ParamTy),\n@@ -1755,7 +1755,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n-            Anon(..) => true,\n+            Opaque(..) => true,\n             _ => false,\n         }\n     }\n@@ -1782,7 +1782,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }\n                 v\n             }\n-            Adt(_, substs) | Anon(_, substs) => {\n+            Adt(_, substs) | Opaque(_, substs) => {\n                 substs.regions().collect()\n             }\n             Closure(_, ClosureSubsts { ref substs }) |\n@@ -1867,7 +1867,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             ty::Adt(def, _substs) =>\n                 def.sized_constraint(tcx).is_empty(),\n \n-            ty::Projection(_) | ty::Param(_) | ty::Anon(..) => false,\n+            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n \n             ty::Infer(ty::TyVar(_)) => false,\n "}, {"sha": "cc0429de2f6241a644d97cf05b5f2f615bd44573", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -956,7 +956,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Can refer to a type which may drop.\n         // FIXME(eddyb) check this against a ParamEnv.\n         ty::Dynamic(..) | ty::Projection(..) | ty::Param(_) |\n-        ty::Anon(..) | ty::Infer(_) | ty::Error => true,\n+        ty::Opaque(..) | ty::Infer(_) | ty::Error => true,\n \n         // Structural recursion.\n         ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),"}, {"sha": "cf87c2d457471b7a72300ef5865c0233b83f9be8", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -114,7 +114,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n                 substs.types().rev().chain(opt_ty)\n             }));\n         }\n-        ty::Adt(_, substs) | ty::Anon(_, substs) => {\n+        ty::Adt(_, substs) | ty::Opaque(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n         ty::Closure(_, ref substs) => {"}, {"sha": "63206a660df411ddb022bc149fee9fd9a49ed947", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -360,7 +360,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // types appearing in the fn signature\n                 }\n \n-                ty::Anon(did, substs) => {\n+                ty::Opaque(did, substs) => {\n                     // all of the requirements on type parameters\n                     // should've been checked by the instantiation\n                     // of whatever returned this exact `impl Trait`."}, {"sha": "ddcc0fa9c9280d0ed609e2e93fe8eb05ae9cb822", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -17,7 +17,7 @@ use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{Bool, Char, Adt};\n use ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n use ty::{Param, RawPtr, Ref, Never, Tuple};\n-use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Anon};\n+use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use ty::{Dynamic, Int, Uint, Infer};\n use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n@@ -1102,9 +1102,9 @@ define_print! {\n                 }\n                 Foreign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n                 Projection(ref data) => data.print(f, cx),\n-                Anon(def_id, substs) => {\n+                Opaque(def_id, substs) => {\n                     if cx.is_verbose {\n-                        return write!(f, \"Anon({:?}, {:?})\", def_id, substs);\n+                        return write!(f, \"Opaque({:?}, {:?})\", def_id, substs);\n                     }\n \n                     ty::tls::with(|tcx| {"}, {"sha": "95a094bf909e1a3bc01451ec2f44ec4f3264d673", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -174,7 +174,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Error |\n         ty::Infer(_) |\n         ty::Projection(..) |\n-        ty::Anon(..) |\n+        ty::Opaque(..) |\n         ty::GeneratorWitness(..) |\n         ty::Param(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\"}, {"sha": "33181bd80e9374799400dea020e17a14ca1b6412", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -721,7 +721,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::Generator(..) |\n             ty::GeneratorWitness(..) |\n             ty::Projection(..) |\n-            ty::Anon(..) |\n+            ty::Opaque(..) |\n             ty::FnDef(..) => bug!(\"Unexpected type in foreign function\"),\n         }\n     }"}, {"sha": "265cd305eb97e5fa31c4b555db9b5293b5e773e7", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -72,16 +72,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // types.\n         let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map =\n+        let opaque_type_map =\n             self.fully_perform_op(\n                 Locations::All,\n                 CustomTypeOp::new(\n                     |infcx| {\n                         let mut obligations = ObligationAccumulator::default();\n \n                         let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, anon_type_map) =\n-                            obligations.add(infcx.instantiate_anon_types(\n+                        let (output_ty, opaque_type_map) =\n+                            obligations.add(infcx.instantiate_opaque_types(\n                                 mir_def_id,\n                                 dummy_body_id,\n                                 param_env,\n@@ -92,8 +92,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             output_ty\n                         );\n                         debug!(\n-                            \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n-                            anon_type_map\n+                            \"equate_inputs_and_outputs: opaque_type_map={:#?}\",\n+                            opaque_type_map\n                         );\n \n                         debug!(\n@@ -106,29 +106,30 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                 .eq(output_ty, mir_output_ty)?,\n                         );\n \n-                        for (&anon_def_id, anon_decl) in &anon_type_map {\n-                            let anon_defn_ty = tcx.type_of(anon_def_id);\n-                            let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n-                            let anon_defn_ty = renumber::renumber_regions(\n+                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                            let opaque_defn_ty = renumber::renumber_regions(\n                                 infcx,\n-                                &anon_defn_ty,\n+                                &opaque_defn_ty,\n                             );\n                             debug!(\n                                 \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                                anon_decl.concrete_ty\n+                                opaque_decl.concrete_ty\n                             );\n-                            debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                            debug!(\"equate_inputs_and_outputs: opaque_defn_ty={:?}\",\n+                                   opaque_defn_ty);\n                             obligations.add(\n                                 infcx\n                                     .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n                             );\n                         }\n \n                         debug!(\"equate_inputs_and_outputs: equated\");\n \n                         Ok(InferOk {\n-                            value: Some(anon_type_map),\n+                            value: Some(opaque_type_map),\n                             obligations: obligations.into_vec(),\n                         })\n                     },\n@@ -146,22 +147,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 None\n             });\n \n-        // Finally, if we instantiated the anon types successfully, we\n+        // Finally, if we instantiated the opaque types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n-        if let Some(anon_type_map) = anon_type_map {\n+        if let Some(opaque_type_map) = opaque_type_map {\n             self.fully_perform_op(\n                 Locations::All,\n                 CustomTypeOp::new(\n                     |_cx| {\n-                        infcx.constrain_anon_types(&anon_type_map, universal_region_relations);\n+                        infcx.constrain_opaque_types(&opaque_type_map, universal_region_relations);\n                         Ok(InferOk {\n                             value: (),\n                             obligations: vec![],\n                         })\n                     },\n-                    || \"anon_type_map\".to_string(),\n+                    || \"opaque_type_map\".to_string(),\n                 ),\n             ).unwrap();\n         }"}, {"sha": "dc437ee8510d7c46a7f1929dbe388878669a66e1", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -385,7 +385,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Projection(..) |\n             ty::Param(_) |\n             ty::GeneratorWitness(_) |\n-            ty::Anon(..) => {\n+            ty::Opaque(..) => {\n                 bug!(\"DefPathBasedNames: Trying to create type name for \\\n                                          unexpected type: {:?}\", t);\n             }"}, {"sha": "eacc23c9c4fe22cdfa69c9e953db7793f1959f45", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -100,7 +100,7 @@ fn check_ty(\n                 span,\n                 \"mutable references in const fn are unstable\".into(),\n             )),\n-            ty::Anon(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 return Err((span, \"function pointers in const fn are unstable\".into()))\n             }"}, {"sha": "fe66110120d40e2a1c212ce8371dbf402349fd17", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -490,7 +490,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n             ty::FnDef(def_id, ..) |\n             ty::Closure(def_id, ..) |\n             ty::Generator(def_id, ..) |\n-            ty::Anon(def_id, _) => Some(def_id),\n+            ty::Opaque(def_id, _) => Some(def_id),\n             _ => None\n         };\n \n@@ -652,7 +652,7 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     in_body: bool,\n     span: Span,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n-    visited_anon_tys: FxHashSet<DefId>\n+    visited_opaque_tys: FxHashSet<DefId>\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return true;\n                 }\n             }\n-            ty::Anon(def_id, ..) => {\n+            ty::Opaque(def_id, ..) => {\n                 for predicate in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n                         ty::Predicate::Trait(ref poly_trait_predicate) => {\n@@ -979,10 +979,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             return true;\n                         }\n                         for subst in trait_ref.substs.iter() {\n-                            // Skip repeated `Anon`s to avoid infinite recursion.\n+                            // Skip repeated `Opaque`s to avoid infinite recursion.\n                             if let UnpackedKind::Type(ty) = subst.unpack() {\n-                                if let ty::Anon(def_id, ..) = ty.sty {\n-                                    if !self.visited_anon_tys.insert(def_id) {\n+                                if let ty::Opaque(def_id, ..) = ty.sty {\n+                                    if !self.visited_opaque_tys.insert(def_id) {\n                                         continue;\n                                     }\n                                 }\n@@ -1728,7 +1728,7 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_body: false,\n         span: krate.span,\n         empty_tables: &empty_tables,\n-        visited_anon_tys: FxHashSet()\n+        visited_opaque_tys: FxHashSet()\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "e3ec2e6b9ce02b48dfabce331ed39510f7f6d2ff", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -123,7 +123,7 @@ fn dropck_outlives<'tcx>(\n \n                             // A projection that we couldn't resolve - it\n                             // might have a destructor.\n-                            ty::Projection(..) | ty::Anon(..) => {\n+                            ty::Projection(..) | ty::Opaque(..) => {\n                                 result.kinds.push(ty.into());\n                             }\n \n@@ -266,7 +266,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n         }),\n \n         // Types that can't be resolved. Pass them forward.\n-        ty::Projection(..) | ty::Anon(..) | ty::Param(..) => Ok(DtorckConstraint {\n+        ty::Projection(..) | ty::Opaque(..) | ty::Param(..) => Ok(DtorckConstraint {\n             outlives: vec![],\n             dtorck_types: vec![ty],\n             overflows: vec![],"}, {"sha": "eaf1d03de7d0f301af3da953d4d516f97bd99d5e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -1350,7 +1350,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n                 self.normalize_ty(\n                     span,\n-                    tcx.mk_anon(did, substs),\n+                    tcx.mk_opaque(did, substs),\n                 )\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n@@ -1543,7 +1543,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         });\n         debug!(\"impl_trait_ty_to_ty: final substs = {:?}\", substs);\n \n-        let ty = tcx.mk_anon(def_id, substs);\n+        let ty = tcx.mk_opaque(def_id, substs);\n         debug!(\"impl_trait_ty_to_ty: {}\", ty);\n         ty\n     }"}, {"sha": "ebe0c279aafab51304754c3b7b21b9499169d52e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -78,8 +78,8 @@ enum PointerKind<'tcx> {\n     Length,\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n-    /// The unsize info of this anon ty\n-    OfAnon(DefId, &'tcx Substs<'tcx>),\n+    /// The unsize info of this opaque ty\n+    OfOpaque(DefId, &'tcx Substs<'tcx>),\n     /// The unsize info of this parameter\n     OfParam(&'tcx ty::ParamTy),\n }\n@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n             ty::Projection(ref pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::Anon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n+            ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n             ty::Param(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n             ty::Infer(_) => None,"}, {"sha": "9ab269702db1c8d99c8fd4a04d2719fbecb82fae", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -91,7 +91,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n-use rustc::infer::anon_types::AnonTypeDecl;\n+use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n@@ -212,11 +212,11 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n \n-    // Anonymized types found in explicit return types and their\n+    // Opaque types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n-    // deanonymize Anon, after typeck is done with all functions.\n-    anon_types: RefCell<DefIdMap<AnonTypeDecl<'tcx>>>,\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n \n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n@@ -635,7 +635,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n-            anon_types: RefCell::new(DefIdMap()),\n+            opaque_types: RefCell::new(DefIdMap()),\n             implicit_region_bound,\n             body_id,\n         }\n@@ -1024,7 +1024,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_anon_types_from_return_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_return_value(fn_id, &declared_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -2222,34 +2222,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Replace the anonymized types from the return value of the\n-    /// function with type variables and records the `AnonTypeMap` for\n+    /// Replace the opaque types from the return value of the\n+    /// function with type variables and records the `OpaqueTypeMap` for\n     /// later use during writeback. See\n-    /// `InferCtxt::instantiate_anon_types` for more details.\n-    fn instantiate_anon_types_from_return_value<T: TypeFoldable<'tcx>>(\n+    /// `InferCtxt::instantiate_opaque_types` for more details.\n+    fn instantiate_opaque_types_from_return_value<T: TypeFoldable<'tcx>>(\n         &self,\n         fn_id: ast::NodeId,\n         value: &T,\n     ) -> T {\n         let fn_def_id = self.tcx.hir.local_def_id(fn_id);\n         debug!(\n-            \"instantiate_anon_types_from_return_value(fn_def_id={:?}, value={:?})\",\n+            \"instantiate_opaque_types_from_return_value(fn_def_id={:?}, value={:?})\",\n             fn_def_id,\n             value\n         );\n \n-        let (value, anon_type_map) = self.register_infer_ok_obligations(\n-            self.instantiate_anon_types(\n+        let (value, opaque_type_map) = self.register_infer_ok_obligations(\n+            self.instantiate_opaque_types(\n                 fn_def_id,\n                 self.body_id,\n                 self.param_env,\n                 value,\n             )\n         );\n \n-        let mut anon_types = self.anon_types.borrow_mut();\n-        for (ty, decl) in anon_type_map {\n-            let old_value = anon_types.insert(ty, decl);\n+        let mut opaque_types = self.opaque_types.borrow_mut();\n+        for (ty, decl) in opaque_type_map {\n+            let old_value = opaque_types.insert(ty, decl);\n             assert!(old_value.is_none(), \"instantiated twice: {:?}/{:?}\", ty, decl);\n         }\n "}, {"sha": "05fe0cb9262cc07d39a2d13233217f65a8470046", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -347,8 +347,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                        body_hir_id,\n                                        call_site_region);\n \n-        self.constrain_anon_types(\n-            &self.fcx.anon_types.borrow(),\n+        self.constrain_opaque_types(\n+            &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n         );\n     }"}, {"sha": "9e09f2cd1851ee38062d0895f36fec7c239b13fa", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::lang_items;\n-use rustc::infer::anon_types::may_define_existential_type;\n+use rustc::infer::opaque_types::may_define_existential_type;\n \n use syntax::ast;\n use syntax::feature_gate::{self, GateIssue};\n@@ -576,13 +576,13 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         fldop: |ty| {\n-            if let ty::Anon(def_id, substs) = ty.sty {\n-                trace!(\"check_existential_types: anon_ty, {:?}, {:?}\", def_id, substs);\n+            if let ty::Opaque(def_id, substs) = ty.sty {\n+                trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // only check named existential types\n                 if generics.parent.is_none() {\n-                    let anon_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                    if may_define_existential_type(tcx, fn_def_id, anon_node_id) {\n+                    let opaque_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                    if may_define_existential_type(tcx, fn_def_id, opaque_node_id) {\n                         trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n@@ -674,7 +674,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         }\n                     }\n                 } // if is_named_existential_type\n-            } // if let Anon\n+            } // if let Opaque\n             ty\n         },\n         reg_op: |reg| reg,"}, {"sha": "0b2f92ac4bcb658bbabf2d021e93b74d947522df", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_anon_types(body.value.span);\n+        wbcx.visit_opaque_types(body.value.span);\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n         wbcx.visit_user_provided_tys();\n@@ -393,18 +393,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_anon_types(&mut self, span: Span) {\n-        for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n+    fn visit_opaque_types(&mut self, span: Span) {\n+        for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-            let instantiated_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n+            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &node_id);\n \n             let generics = self.tcx().generics_of(def_id);\n \n             let definition_ty = if generics.parent.is_some() {\n                 // impl trait\n-                self.fcx.infer_anon_definition_from_instantiation(\n+                self.fcx.infer_opaque_definition_from_instantiation(\n                     def_id,\n-                    anon_defn,\n+                    opaque_defn,\n                     instantiated_ty,\n                 )\n             } else {\n@@ -427,8 +427,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         // find a type parameter\n                         if let ty::Param(..) = ty.sty {\n                             // look it up in the substitution list\n-                            assert_eq!(anon_defn.substs.len(), generics.params.len());\n-                            for (subst, param) in anon_defn.substs.iter().zip(&generics.params) {\n+                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n+                            for (subst, param) in opaque_defn.substs.iter().zip(&generics.params) {\n                                 if let UnpackedKind::Type(subst) = subst.unpack() {\n                                     if subst == ty {\n                                         // found it in the substitution list, replace with the\n@@ -460,7 +460,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                             ty::ReStatic => region,\n                             _ => {\n                                 trace!(\"checking {:?}\", region);\n-                                for (subst, p) in anon_defn.substs.iter().zip(&generics.params) {\n+                                for (subst, p) in opaque_defn.substs.iter().zip(&generics.params) {\n                                     if let UnpackedKind::Lifetime(subst) = subst.unpack() {\n                                         if subst == region {\n                                             // found it in the substitution list, replace with the\n@@ -477,7 +477,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                         }\n                                     }\n                                 }\n-                                trace!(\"anon_defn: {:#?}\", anon_defn);\n+                                trace!(\"opaque_defn: {:#?}\", opaque_defn);\n                                 trace!(\"generics: {:#?}\", generics);\n                                 self.tcx()\n                                     .sess\n@@ -501,7 +501,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 })\n             };\n \n-            if let ty::Anon(defin_ty_def_id, _substs) = definition_ty.sty {\n+            if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n                     // Concrete type resolved to the existential type itself\n                     // Force a cycle error\n@@ -516,8 +516,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 if old != definition_ty {\n                     span_bug!(\n                         span,\n-                        \"visit_anon_types tried to write \\\n-                         different types for the same existential type: {:?}, {:?}, {:?}\",\n+                        \"visit_opaque_types tried to write \\\n+                        different types for the same existential type: {:?}, {:?}, {:?}\",\n                         def_id,\n                         definition_ty,\n                         old,"}, {"sha": "cc83c24e51c04e0bb88806624e2529ac38f18ae9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -1646,18 +1646,18 @@ fn explicit_predicates_of<'a, 'tcx>(\n         Node::ImplItem(item) => match item.node {\n             ImplItemKind::Existential(ref bounds) => {\n                 let substs = Substs::identity_for_item(tcx, def_id);\n-                let anon_ty = tcx.mk_anon(def_id, substs);\n+                let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n                 // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                 let bounds = compute_bounds(\n                     &icx,\n-                    anon_ty,\n+                    opaque_ty,\n                     bounds,\n                     SizedByDefault::Yes,\n                     tcx.def_span(def_id),\n                 );\n \n-                predicates.extend(bounds.predicates(tcx, anon_ty));\n+                predicates.extend(bounds.predicates(tcx, opaque_ty));\n                 &item.generics\n             }\n             _ => &item.generics,\n@@ -1687,12 +1687,12 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     ref generics,\n                 }) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n-                    let anon_ty = tcx.mk_anon(def_id, substs);\n+                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(\n                         &icx,\n-                        anon_ty,\n+                        opaque_ty,\n                         bounds,\n                         SizedByDefault::Yes,\n                         tcx.def_span(def_id),\n@@ -1702,11 +1702,11 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         // impl Trait\n                         return ty::GenericPredicates {\n                             parent: None,\n-                            predicates: bounds.predicates(tcx, anon_ty),\n+                            predicates: bounds.predicates(tcx, opaque_ty),\n                         };\n                     } else {\n                         // named existential types\n-                        predicates.extend(bounds.predicates(tcx, anon_ty));\n+                        predicates.extend(bounds.predicates(tcx, opaque_ty));\n                         generics\n                     }\n                 }"}, {"sha": "1b481fc5a7d3174d9b0db5c25800a44d72502c9c", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -62,7 +62,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.sty {\n-            ty::Projection(..) | ty::Anon(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;\n             }"}, {"sha": "95544da0b8e0da47ba6b68c1d4f6fe67fba07440", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -302,7 +302,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_trait_ref(current, data.trait_ref(tcx), variance);\n             }\n \n-            ty::Anon(_, substs) => {\n+            ty::Opaque(_, substs) => {\n                 self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n "}, {"sha": "20b17afeab2f63f9c98096a1d166e457c3b8cfe0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2678,11 +2678,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Param(ref p) => Generic(p.name.to_string()),\n \n-            ty::Anon(def_id, substs) => {\n+            ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n                 let predicates_of = cx.tcx.predicates_of(def_id);\n-                let substs = cx.tcx.lift(&substs).expect(\"Anon lift failed\");\n+                let substs = cx.tcx.lift(&substs).expect(\"Opaque lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];\n                 let mut has_sized = false;"}, {"sha": "471eda45dafdc950430c222e3694f0a3510b5f66", "filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:16:18\n    |\n LL |     let z: i32 = x; //~ ERROR mismatched types\n-   |                  ^ expected i32, found anonymized type\n+   |                  ^ expected i32, found opaque type\n    |\n    = note: expected type `i32`\n               found type `WrongGeneric::<&{integer}>`"}, {"sha": "f1773b7c2fc8fa953197ab417877f49fcd3177e4", "filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:16:18\n    |\n LL |     let z: i32 = x; //~ ERROR mismatched types\n-   |                  ^ expected i32, found anonymized type\n+   |                  ^ expected i32, found opaque type\n    |\n    = note: expected type `i32`\n               found type `WrongGeneric::<&{integer}>`"}, {"sha": "ab937a9483c0c88d412daded809d6f4324208dee", "filename": "src/test/ui/existential_types/never_reveal_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fnever_reveal_concrete_type.stderr?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/never_reveal_concrete_type.rs:24:27\n    |\n LL |     let _: &'static str = x; //~ mismatched types\n-   |                           ^ expected reference, found anonymized type\n+   |                           ^ expected reference, found opaque type\n    |\n    = note: expected type `&'static str`\n               found type `NoReveal`"}, {"sha": "3f03174a4917b988c2f26c5f53bf4553ab64e6b5", "filename": "src/test/ui/existential_types/no_revealing_outside_defining_module.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_revealing_outside_defining_module.stderr?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/no_revealing_outside_defining_module.rs:26:19\n    |\n LL |     let _: &str = bomp(); //~ ERROR mismatched types\n-   |                   ^^^^^^ expected &str, found anonymized type\n+   |                   ^^^^^^ expected &str, found opaque type\n    |\n    = note: expected type `&str`\n               found type `Boo`\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n LL | fn bomp() -> boo::Boo {\n    |              -------- expected `Boo` because of return type\n LL |     \"\" //~ ERROR mismatched types\n-   |     ^^ expected anonymized type, found reference\n+   |     ^^ expected opaque type, found reference\n    |\n    = note: expected type `Boo`\n               found type `&'static str`"}, {"sha": "2ce24cf789dd37d4653d2baf058087bbdf8e7064", "filename": "src/test/ui/impl-trait/equality2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.rs?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -36,7 +36,7 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected type `u32`\n     //~| found type `impl Foo`\n-    //~| expected u32, found anonymized type\n+    //~| expected u32, found opaque type\n \n     let _: i32 = Leak::leak(hide(0_i32));\n     //~^ ERROR mismatched types"}, {"sha": "da51e35947a3b07562cec646fa7f5f550d4f981a", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b24330fb7d9e89d63eb03d81fe577172aad49525/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=b24330fb7d9e89d63eb03d81fe577172aad49525", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/equality2.rs:35:18\n    |\n LL |     let _: u32 = hide(0_u32);\n-   |                  ^^^^^^^^^^^ expected u32, found anonymized type\n+   |                  ^^^^^^^^^^^ expected u32, found opaque type\n    |\n    = note: expected type `u32`\n               found type `impl Foo`"}]}