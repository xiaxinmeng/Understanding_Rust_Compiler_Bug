{"sha": "eab6bb2ece0427d2ec165e510f2abaa84b857900", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYjZiYjJlY2UwNDI3ZDJlYzE2NWU1MTBmMmFiYWE4NGI4NTc5MDA=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-05T03:54:02Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:22Z"}, "message": "Handle fallout in documentation\n\nTweak the tutorial's section on vectors and strings, to slightly clarify\nthe difference between fixed-size vectors, vectors, and slices.", "tree": {"sha": "09b066f570f067fe927c0cb7cb8b7addf09156c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09b066f570f067fe927c0cb7cb8b7addf09156c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eab6bb2ece0427d2ec165e510f2abaa84b857900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eab6bb2ece0427d2ec165e510f2abaa84b857900", "html_url": "https://github.com/rust-lang/rust/commit/eab6bb2ece0427d2ec165e510f2abaa84b857900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eab6bb2ece0427d2ec165e510f2abaa84b857900/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752048a27135bdf15c6f00229b04cea7ceeaf739", "url": "https://api.github.com/repos/rust-lang/rust/commits/752048a27135bdf15c6f00229b04cea7ceeaf739", "html_url": "https://github.com/rust-lang/rust/commit/752048a27135bdf15c6f00229b04cea7ceeaf739"}], "stats": {"total": 160, "additions": 81, "deletions": 79}, "files": [{"sha": "1ab92d453785e41f1fe4f2b80ea3edf801e22408", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -266,8 +266,8 @@ Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n let xs = [0, 1, 1, 2, 3, 5, 8];\n-let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<~[int]>();\n-assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n+let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<Vec<int>>();\n+assert_eq!(ys, vec![10, 6, 4, 2, 2, 0]);\n ~~~\n \n The method requires a type hint for the container type, if the surrounding code\n@@ -278,14 +278,14 @@ implementing the `FromIterator` trait. For example, the implementation for\n vectors is as follows:\n \n ~~~ {.ignore}\n-impl<A> FromIterator<A> for ~[A] {\n-    pub fn from_iter<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n+impl<T> FromIterator<T> for Vec<T> {\n+    fn from_iter<I:Iterator<A>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n-        let mut xs = with_capacity(lower);\n-        for x in iterator {\n-            xs.push(x);\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in iterator {\n+            vector.push(element);\n         }\n-        xs\n+        vector\n     }\n }\n ~~~"}, {"sha": "1158044ae19019f3339a79fddac40fe36e491fd4", "filename": "src/doc/rust.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -3598,18 +3598,18 @@ and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~\n-fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\n+fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     if xs.len() == 0 {\n-       return ~[];\n+       return vec![];\n     }\n     let first: B = f(xs[0].clone());\n-    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n-    return ~[first] + rest;\n+    let rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n+    return [first] + rest;\n }\n ~~~~\n \n Here, `first` has type `B`, referring to `map`'s `B` type parameter;\n-and `rest` has type `~[B]`, a vector type with element type `B`.\n+and `rest` has type `Vec<B>`, a vector type with element type `B`.\n \n ### Self types\n "}, {"sha": "9b9153fe579462b47a9080e71c2743b9d6ebaa4c", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -1588,8 +1588,8 @@ let mut numbers = vec![1, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n-// The type of a unique vector is written as `~[int]`\n-let more_numbers: ~[int] = numbers.move_iter().collect();\n+// The type of a unique vector is written as `Vec<int>`\n+let more_numbers: Vec<int> = numbers.move_iter().map(|i| i+1).collect();\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n@@ -1633,7 +1633,7 @@ view[0] = 5;\n let ys: &mut [int] = &mut [1, 2, 3];\n ~~~\n \n-Square brackets denote indexing into a vector:\n+Square brackets denote indexing into a slice or fixed-size vector:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n@@ -1647,7 +1647,7 @@ match crayons[0] {\n }\n ~~~~\n \n-A vector can be destructured using pattern matching:\n+A slice or fixed-size vector can be destructured using pattern matching:\n \n ~~~~\n let numbers: &[int] = &[1, 2, 3];\n@@ -1660,9 +1660,10 @@ let score = match numbers {\n ~~~~\n \n Both vectors and strings support a number of useful [methods](#methods),\n-defined in [`std::vec`] and [`std::str`].\n+defined in [`std::vec`], [`std::slice`], and [`std::str`].\n \n [`std::vec`]: std/vec/index.html\n+[`std::slice`]: std/slice/index.html\n [`std::str`]: std/str/index.html\n \n # Ownership escape hatches"}, {"sha": "10ae30cf39d0cc08628657bd80f9269459492071", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -455,8 +455,8 @@ pub trait Iterator<A> {\n     ///\n     /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let b: ~[int] = a.iter().map(|&x| x).collect();\n-    /// assert!(a == b);\n+    /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n+    /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n     fn collect<B: FromIterator<A>>(&mut self) -> B {"}, {"sha": "689f59b471c90402c7ec9298d15d8bc697f8e58d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -621,12 +621,12 @@ impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n ///          0xD834];\n ///\n-/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n-///            ~[ScalarValue('\ud834\udd1e'),\n-///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///              LoneSurrogate(0xDD1E),\n-///              ScalarValue('i'), ScalarValue('c'),\n-///              LoneSurrogate(0xD834)]);\n+/// assert_eq!(str::utf16_items(v).collect::<Vec<_>>(),\n+///            vec![ScalarValue('\ud834\udd1e'),\n+///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///                 LoneSurrogate(0xDD1E),\n+///                 ScalarValue('i'), ScalarValue('c'),\n+///                 LoneSurrogate(0xD834)]);\n /// ```\n pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n     UTF16Items { iter : v.iter() }\n@@ -896,8 +896,8 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     fn chars(&self) -> Chars<'a>;\n \n@@ -925,14 +925,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n     fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -943,14 +943,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n     /// ```\n     fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n@@ -963,20 +963,20 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"B\"]);\n     ///\n-    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n     ///\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -991,14 +991,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n@@ -1013,14 +1013,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n+    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(1,4), (4,7)]);\n+    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(1,4), (4,7)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n+    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n     fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n \n@@ -1029,11 +1029,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n-    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n+    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n     fn split_str(&self, &'a str) -> StrSplits<'a>;\n \n@@ -1045,8 +1045,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     fn lines(&self) -> CharSplits<'a, char>;\n \n@@ -1058,8 +1058,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines_any().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     fn lines_any(&self) -> AnyLines<'a>;\n \n@@ -1071,8 +1071,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: ~[&str] = some_words.words().collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     fn words(&self) -> Words<'a>;\n \n@@ -1469,7 +1469,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let string = \"a\\nb\\nc\";\n-    /// let lines: ~[&str] = string.lines().collect();\n+    /// let lines: Vec<&str> = string.lines().collect();\n+    /// let lines = lines.as_slice();\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\""}, {"sha": "3de1dde240c9722ae81f48d72997bda6f29cffe6", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -51,7 +51,7 @@\n //! fn main() {\n //!     let args = os::args();\n //!\n-//!     let program = args[0].clone();\n+//!     let program = args.get(0).clone();\n //!\n //!     let opts = [\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),"}, {"sha": "2e4d7696c44d0b42a53fea7e5793af7b6adf690b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -166,14 +166,14 @@ use serialize::{json, Encodable, Decodable};\n  pub struct TestStruct1  {\n     data_int: u8,\n     data_str: ~str,\n-    data_vector: ~[u8],\n+    data_vector: Vec<u8>,\n  }\n \n // To serialize use the `json::str_encode` to encode an object in a string.\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:~[2,3,4,5]};\n+         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:vec![2,3,4,5]};\n     let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n@@ -201,7 +201,7 @@ use collections::TreeMap;\n pub struct TestStruct1  {\n     data_int: u8,\n     data_str: ~str,\n-    data_vector: ~[u8],\n+    data_vector: Vec<u8>,\n }\n \n impl ToJson for TestStruct1 {\n@@ -218,7 +218,7 @@ fn main() {\n     // Serialization using our impl of to_json\n \n     let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_owned(),\n-                                          data_vector:~[2,3,4,5]};\n+                                          data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n     let json_str: ~str = tjson.to_str();\n "}, {"sha": "4a53a064610cb0e5b8661a283d39cb2d06fb1823", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eab6bb2ece0427d2ec165e510f2abaa84b857900/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=eab6bb2ece0427d2ec165e510f2abaa84b857900", "patch": "@@ -76,7 +76,7 @@ Some examples of obvious things you might want to do\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n-    let lines: ~[~str] = file.lines().map(|x| x.unwrap()).collect();\n+    let lines: Vec<~str> = file.lines().map(|x| x.unwrap()).collect();\n     ```\n \n * Make a simple TCP client connection and request"}]}