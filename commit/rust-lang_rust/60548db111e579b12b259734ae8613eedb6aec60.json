{"sha": "60548db111e579b12b259734ae8613eedb6aec60", "node_id": "C_kwDOAAsO6NoAKDYwNTQ4ZGIxMTFlNTc5YjEyYjI1OTczNGFlODYxM2VlZGI2YWVjNjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T07:00:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-15T07:00:38Z"}, "message": "Auto merge of #14281 - XFFXFF:fix_missing_unsafe, r=Veykril\n\nfeat: add an autofix for inserting an unsafe block to missing unsafe diagnostic\n\nclose #14241", "tree": {"sha": "2af3bf0452a0b7b15dd877c1808bc06fdf92e399", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af3bf0452a0b7b15dd877c1808bc06fdf92e399"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60548db111e579b12b259734ae8613eedb6aec60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60548db111e579b12b259734ae8613eedb6aec60", "html_url": "https://github.com/rust-lang/rust/commit/60548db111e579b12b259734ae8613eedb6aec60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60548db111e579b12b259734ae8613eedb6aec60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d7ea0692f2a72276704109ee13ffb3284f4863", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d7ea0692f2a72276704109ee13ffb3284f4863", "html_url": "https://github.com/rust-lang/rust/commit/b4d7ea0692f2a72276704109ee13ffb3284f4863"}, {"sha": "0c935732bcb7f13a491181e8996be3ec1c2244ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c935732bcb7f13a491181e8996be3ec1c2244ac", "html_url": "https://github.com/rust-lang/rust/commit/0c935732bcb7f13a491181e8996be3ec1c2244ac"}], "stats": {"total": 381, "additions": 374, "deletions": 7}, "files": [{"sha": "eb32db250656c1dac5deb0563d3c7146b9f85d18", "filename": "crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 374, "deletions": 7, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/60548db111e579b12b259734ae8613eedb6aec60/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60548db111e579b12b259734ae8613eedb6aec60/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=60548db111e579b12b259734ae8613eedb6aec60", "patch": "@@ -1,4 +1,10 @@\n-use crate::{Diagnostic, DiagnosticsContext};\n+use hir::db::ExpandDatabase;\n+use ide_db::{assists::Assist, source_change::SourceChange};\n+use syntax::{ast, SyntaxNode};\n+use syntax::{match_ast, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-unsafe\n //\n@@ -9,11 +15,83 @@ pub(crate) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsaf\n         \"this operation is unsafe and requires an unsafe function or block\",\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Assist>> {\n+    // The fixit will not work correctly for macro expansions, so we don't offer it in that case.\n+    if d.expr.file_id.is_macro() {\n+        return None;\n+    }\n+\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let expr = d.expr.value.to_node(&root);\n+\n+    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr)?;\n+\n+    let replacement = format!(\"unsafe {{ {} }}\", node_to_add_unsafe_block.text());\n+    let edit = TextEdit::replace(node_to_add_unsafe_block.text_range(), replacement);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+    Some(vec![fix(\"add_unsafe\", \"Add unsafe block\", source_change, expr.syntax().text_range())])\n+}\n+\n+// Pick the first ancestor expression of the unsafe `expr` that is not a\n+// receiver of a method call, a field access, the left-hand side of an\n+// assignment, or a reference. As all of those cases would incur a forced move\n+// if wrapped which might not be wanted. That is:\n+// - `unsafe_expr.foo` -> `unsafe { unsafe_expr.foo }`\n+// - `unsafe_expr.foo.bar` -> `unsafe { unsafe_expr.foo.bar }`\n+// - `unsafe_expr.foo()` -> `unsafe { unsafe_expr.foo() }`\n+// - `unsafe_expr.foo.bar()` -> `unsafe { unsafe_expr.foo.bar() }`\n+// - `unsafe_expr += 1` -> `unsafe { unsafe_expr += 1 }`\n+// - `&unsafe_expr` -> `unsafe { &unsafe_expr }`\n+// - `&&unsafe_expr` -> `unsafe { &&unsafe_expr }`\n+fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> Option<SyntaxNode> {\n+    // The `unsafe_expr` might be:\n+    // - `ast::CallExpr`: call an unsafe function\n+    // - `ast::MethodCallExpr`: call an unsafe method\n+    // - `ast::PrefixExpr`: dereference a raw pointer\n+    // - `ast::PathExpr`: access a static mut variable\n+    for (node, parent) in\n+        unsafe_expr.syntax().ancestors().zip(unsafe_expr.syntax().ancestors().skip(1))\n+    {\n+        match_ast! {\n+            match parent {\n+                // If the `parent` is a `MethodCallExpr`, that means the `node`\n+                // is the receiver of the method call, because only the receiver\n+                // can be a direct child of a method call. The method name\n+                // itself is not an expression but a `NameRef`, and an argument\n+                // is a direct child of an `ArgList`.\n+                ast::MethodCallExpr(_) => continue,\n+                ast::FieldExpr(_) => continue,\n+                ast::RefExpr(_) => continue,\n+                ast::BinExpr(it) => {\n+                    // Check if the `node` is the left-hand side of an\n+                    // assignment, if so, we don't want to wrap it in an unsafe\n+                    // block, e.g. `unsafe_expr += 1`\n+                    let is_left_hand_side_of_assignment = {\n+                        if let Some(ast::BinaryOp::Assignment { .. }) = it.op_kind() {\n+                            it.lhs().map(|lhs| lhs.syntax().text_range().contains_range(node.text_range())).unwrap_or(false)\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    if !is_left_hand_side_of_assignment {\n+                        return Some(node);\n+                    }\n+                },\n+                _ => { return Some(node); }\n+\n+            }\n+        }\n+    }\n+    None\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::check_diagnostics;\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {\n@@ -23,7 +101,7 @@ fn main() {\n     let x = &5 as *const usize;\n     unsafe { let y = *x; }\n     let z = *x;\n-}         //^^ error: this operation is unsafe and requires an unsafe function or block\n+}         //^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n \"#,\n         )\n     }\n@@ -48,9 +126,9 @@ unsafe fn unsafe_fn() {\n \n fn main() {\n     unsafe_fn();\n-  //^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     HasUnsafe.unsafe_fn();\n-  //^^^^^^^^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         unsafe_fn();\n         HasUnsafe.unsafe_fn();\n@@ -72,7 +150,7 @@ static mut STATIC_MUT: Ty = Ty { a: 0 };\n \n fn main() {\n     let x = STATIC_MUT.a;\n-          //^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         let x = STATIC_MUT.a;\n     }\n@@ -94,9 +172,298 @@ extern \"rust-intrinsic\" {\n fn main() {\n     let _ = bitreverse(12);\n     let _ = floorf32(12.0);\n-          //^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n }\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn add_unsafe_block_when_dereferencing_a_raw_pointer() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = *x$0;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = unsafe { *x };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_function() {\n+        check_fix(\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    func$0();\n+}\n+\"#,\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    unsafe { func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_method() {\n+        check_fix(\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    s.func$0();\n+}\n+\"#,\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    unsafe { s.func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_accessing_mutable_static() {\n+        check_fix(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = STATIC_MUT$0.a;\n+}\n+\"#,\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT.a };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_intrinsic() {\n+        check_fix(\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = floorf32$0(12.0);\n+}\n+\"#,\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = unsafe { floorf32(12.0) };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_a_receiver_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    foo$0().len();\n+}\n+\"#,\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    unsafe { foo().len() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_an_argument_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(STATIC_MUT$0);\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(unsafe { STATIC_MUT });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_left_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    STATIC_MUT$0 = 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    unsafe { STATIC_MUT = 1 };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_right_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = unsafe { STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_binary_plus() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = STATIC_MUT$0 + 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT } + 1;\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &&STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &&STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_macro_call() {\n+        check_no_fix(\n+            r#\"\n+unsafe fn foo() -> u8 {\n+    0\n+}\n+\n+fn main() {\n+    let x = format!(\"foo: {}\", foo$0());\n+}\n+            \"#,\n+        )\n+    }\n }"}]}