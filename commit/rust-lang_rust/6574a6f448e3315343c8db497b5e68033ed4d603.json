{"sha": "6574a6f448e3315343c8db497b5e68033ed4d603", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NzRhNmY0NDhlMzMxNTM0M2M4ZGI0OTdiNWU2ODAzM2VkNGQ2MDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-02T12:13:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-02T12:13:53Z"}, "message": "Merge #5988\n\n5988: Postfix completions for fmt-like string literals r=matklad a=popzxc\n\nThis pull request adds a bunch of new postfix completions for `format`-like string literls.\r\n\r\nFor example, `\"{32} {some_var:?}\".println` will expand to `println!(\"{} {:?}\", 32, some_var)`.\r\n\r\nPostfix completions were added for most common format-like macros:\r\n\r\n- `println` -> `println!(...)`\r\n- `fmt` -> `format!(...)`\r\n- `panic` -> `panic!(...)`\r\n- `log` macros:\r\n  + `logi` -> `log::info!(...)`\r\n  + `logw` -> `log::warn!(...)`\r\n  + `loge` -> `log::error!(...)`\r\n  + `logt` -> `log::trace!(...)`\r\n  + `logd` -> `log::debug!(...)`\r\n\r\n![fmt_postfix](https://user-images.githubusercontent.com/12111581/92998650-a048af80-f523-11ea-8fd8-410146de8caa.gif)\r\n\r\n\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>", "tree": {"sha": "d4e01a4cefa3d15fb8e393abf3082b2418867fcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4e01a4cefa3d15fb8e393abf3082b2418867fcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6574a6f448e3315343c8db497b5e68033ed4d603", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdxmBCRBK7hj4Ov3rIwAAdHIIACNEJ5n1njUIaY147vkt6uND\nblFi7HE2dFgUnsHgrJvXhtNAxbTJGhrpnOy+O2DhrPnEqNCBjL2fnmcz0SasquFP\nCuaUnUnjBplbik57ppgkM/H3lRI2ojPYp8TvELq3D/vlGwQf3qdJyQintiZU3N/E\nbQ9EHv4HmfUsTcpKZAzyGZpNufuKiS1mB8wqN37ildgxMS3/BE6Xm19wfLTZP6f0\nxUA/LtAYS0x2TgHR8lIEfFPm7hJ8PYRIatZ10L34pedjb5SjczDZNOvRcvb/0/J7\nz2g88HR7CjfQS4K80ShXauc9zASLbf/yEGIlc+KR2Zx/gmvGePSlkTmpkspCVVo=\n=fv7b\n-----END PGP SIGNATURE-----\n", "payload": "tree d4e01a4cefa3d15fb8e393abf3082b2418867fcb\nparent d8e5265309cf92857c996d4f55372e3b431468bf\nparent 97f2905dec269891eb81a75cf0d639408a3f7268\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601640833 +0000\ncommitter GitHub <noreply@github.com> 1601640833 +0000\n\nMerge #5988\n\n5988: Postfix completions for fmt-like string literals r=matklad a=popzxc\n\nThis pull request adds a bunch of new postfix completions for `format`-like string literls.\r\n\r\nFor example, `\"{32} {some_var:?}\".println` will expand to `println!(\"{} {:?}\", 32, some_var)`.\r\n\r\nPostfix completions were added for most common format-like macros:\r\n\r\n- `println` -> `println!(...)`\r\n- `fmt` -> `format!(...)`\r\n- `panic` -> `panic!(...)`\r\n- `log` macros:\r\n  + `logi` -> `log::info!(...)`\r\n  + `logw` -> `log::warn!(...)`\r\n  + `loge` -> `log::error!(...)`\r\n  + `logt` -> `log::trace!(...)`\r\n  + `logd` -> `log::debug!(...)`\r\n\r\n![fmt_postfix](https://user-images.githubusercontent.com/12111581/92998650-a048af80-f523-11ea-8fd8-410146de8caa.gif)\r\n\r\n\n\nCo-authored-by: Igor Aleksanov <popzxc@yandex.ru>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6574a6f448e3315343c8db497b5e68033ed4d603", "html_url": "https://github.com/rust-lang/rust/commit/6574a6f448e3315343c8db497b5e68033ed4d603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6574a6f448e3315343c8db497b5e68033ed4d603/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8e5265309cf92857c996d4f55372e3b431468bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e5265309cf92857c996d4f55372e3b431468bf", "html_url": "https://github.com/rust-lang/rust/commit/d8e5265309cf92857c996d4f55372e3b431468bf"}, {"sha": "97f2905dec269891eb81a75cf0d639408a3f7268", "url": "https://api.github.com/repos/rust-lang/rust/commits/97f2905dec269891eb81a75cf0d639408a3f7268", "html_url": "https://github.com/rust-lang/rust/commit/97f2905dec269891eb81a75cf0d639408a3f7268"}], "stats": {"total": 340, "additions": 338, "deletions": 2}, "files": [{"sha": "db5319618e1e7536e040d93427acb1d7458df654", "filename": "crates/ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=6574a6f448e3315343c8db497b5e68033ed4d603", "patch": "@@ -1,11 +1,15 @@\n //! FIXME: write short doc here\n+\n+mod format_like;\n+\n use assists::utils::TryEnum;\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AstToken},\n     TextRange, TextSize,\n };\n use text_edit::TextEdit;\n \n+use self::format_like::add_format_like_completions;\n use crate::{\n     completion::{\n         completion_config::SnippetCap,\n@@ -207,6 +211,12 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         &format!(\"${{1}}({})\", receiver_text),\n     )\n     .add_to(acc);\n+\n+    if let ast::Expr::Literal(literal) = dot_receiver.clone() {\n+        if let Some(literal_text) = ast::String::cast(literal.token()) {\n+            add_format_like_completions(acc, ctx, &dot_receiver, cap, &literal_text);\n+        }\n+    }\n }\n \n fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal: bool) -> String {\n@@ -392,4 +402,53 @@ fn main() {\n         check_edit(\"dbg\", r#\"fn main() { &&42.<|> }\"#, r#\"fn main() { dbg!(&&42) }\"#);\n         check_edit(\"refm\", r#\"fn main() { &&42.<|> }\"#, r#\"fn main() { &&&mut 42 }\"#);\n     }\n+\n+    #[test]\n+    fn postfix_completion_for_format_like_strings() {\n+        check_edit(\n+            \"fmt\",\n+            r#\"fn main() { \"{some_var:?}\".<|> }\"#,\n+            r#\"fn main() { format!(\"{:?}\", some_var) }\"#,\n+        );\n+        check_edit(\n+            \"panic\",\n+            r#\"fn main() { \"Panic with {a}\".<|> }\"#,\n+            r#\"fn main() { panic!(\"Panic with {}\", a) }\"#,\n+        );\n+        check_edit(\n+            \"println\",\n+            r#\"fn main() { \"{ 2+2 } { SomeStruct { val: 1, other: 32 } :?}\".<|> }\"#,\n+            r#\"fn main() { println!(\"{} {:?}\", 2+2, SomeStruct { val: 1, other: 32 }) }\"#,\n+        );\n+        check_edit(\n+            \"loge\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::error!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logt\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::trace!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logd\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::debug!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logi\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::info!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"logw\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::warn!(\"{}\", 2+2) }\"#,\n+        );\n+        check_edit(\n+            \"loge\",\n+            r#\"fn main() { \"{2+2}\".<|> }\"#,\n+            r#\"fn main() { log::error!(\"{}\", 2+2) }\"#,\n+        );\n+    }\n }"}, {"sha": "0287fc803013297d01fbe2e7c7c001986ca3f30b", "filename": "crates/ide/src/completion/complete_postfix/format_like.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix%2Fformat_like.rs?ref=6574a6f448e3315343c8db497b5e68033ed4d603", "patch": "@@ -0,0 +1,277 @@\n+// Feature: Postfix completion for `format`-like strings.\n+//\n+// `\"Result {result} is {2 + 2}\"` is expanded to the `\"Result {} is {}\", result, 2 + 2`.\n+//\n+// The following postfix snippets are available:\n+//\n+// - `format` -> `format!(...)`\n+// - `panic` -> `panic!(...)`\n+// - `println` -> `println!(...)`\n+// - `log`:\n+//   + `logd` -> `log::debug!(...)`\n+//   + `logt` -> `log::trace!(...)`\n+//   + `logi` -> `log::info!(...)`\n+//   + `logw` -> `log::warn!(...)`\n+//   + `loge` -> `log::error!(...)`\n+\n+use crate::completion::{\n+    complete_postfix::postfix_snippet, completion_config::SnippetCap,\n+    completion_context::CompletionContext, completion_item::Completions,\n+};\n+use syntax::ast::{self, AstToken};\n+\n+/// Mapping (\"postfix completion item\" => \"macro to use\")\n+static KINDS: &[(&str, &str)] = &[\n+    (\"fmt\", \"format!\"),\n+    (\"panic\", \"panic!\"),\n+    (\"println\", \"println!\"),\n+    (\"logd\", \"log::debug!\"),\n+    (\"logt\", \"log::trace!\"),\n+    (\"logi\", \"log::info!\"),\n+    (\"logw\", \"log::warn!\"),\n+    (\"loge\", \"log::error!\"),\n+];\n+\n+pub(super) fn add_format_like_completions(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    dot_receiver: &ast::Expr,\n+    cap: SnippetCap,\n+    receiver_text: &ast::String,\n+) {\n+    let input = match string_literal_contents(receiver_text) {\n+        // It's not a string literal, do not parse input.\n+        Some(input) => input,\n+        None => return,\n+    };\n+\n+    let mut parser = FormatStrParser::new(input);\n+\n+    if parser.parse().is_ok() {\n+        for (label, macro_name) in KINDS {\n+            let snippet = parser.into_suggestion(macro_name);\n+\n+            postfix_snippet(ctx, cap, &dot_receiver, label, macro_name, &snippet).add_to(acc);\n+        }\n+    }\n+}\n+\n+/// Checks whether provided item is a string literal.\n+fn string_literal_contents(item: &ast::String) -> Option<String> {\n+    let item = item.text();\n+    if item.len() >= 2 && item.starts_with(\"\\\"\") && item.ends_with(\"\\\"\") {\n+        return Some(item[1..item.len() - 1].to_owned());\n+    }\n+\n+    None\n+}\n+\n+/// Parser for a format-like string. It is more allowing in terms of string contents,\n+/// as we expect variable placeholders to be filled with expressions.\n+#[derive(Debug)]\n+pub struct FormatStrParser {\n+    input: String,\n+    output: String,\n+    extracted_expressions: Vec<String>,\n+    state: State,\n+    parsed: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum State {\n+    NotExpr,\n+    MaybeExpr,\n+    Expr,\n+    MaybeIncorrect,\n+    FormatOpts,\n+}\n+\n+impl FormatStrParser {\n+    pub fn new(input: String) -> Self {\n+        Self {\n+            input: input.into(),\n+            output: String::new(),\n+            extracted_expressions: Vec::new(),\n+            state: State::NotExpr,\n+            parsed: false,\n+        }\n+    }\n+\n+    pub fn parse(&mut self) -> Result<(), ()> {\n+        let mut current_expr = String::new();\n+\n+        let mut placeholder_id = 1;\n+\n+        // Count of open braces inside of an expression.\n+        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+        let mut inexpr_open_count = 0;\n+\n+        for chr in self.input.chars() {\n+            match (self.state, chr) {\n+                (State::NotExpr, '{') => {\n+                    self.output.push(chr);\n+                    self.state = State::MaybeExpr;\n+                }\n+                (State::NotExpr, '}') => {\n+                    self.output.push(chr);\n+                    self.state = State::MaybeIncorrect;\n+                }\n+                (State::NotExpr, _) => {\n+                    self.output.push(chr);\n+                }\n+                (State::MaybeIncorrect, '}') => {\n+                    // It's okay, we met \"}}\".\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeIncorrect, _) => {\n+                    // Error in the string.\n+                    return Err(());\n+                }\n+                (State::MaybeExpr, '{') => {\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeExpr, '}') => {\n+                    // This is an empty sequence '{}'. Replace it with placeholder.\n+                    self.output.push(chr);\n+                    self.extracted_expressions.push(format!(\"${}\", placeholder_id));\n+                    placeholder_id += 1;\n+                    self.state = State::NotExpr;\n+                }\n+                (State::MaybeExpr, _) => {\n+                    current_expr.push(chr);\n+                    self.state = State::Expr;\n+                }\n+                (State::Expr, '}') => {\n+                    if inexpr_open_count == 0 {\n+                        self.output.push(chr);\n+                        self.extracted_expressions.push(current_expr.trim().into());\n+                        current_expr = String::new();\n+                        self.state = State::NotExpr;\n+                    } else {\n+                        // We're closing one brace met before inside of the expression.\n+                        current_expr.push(chr);\n+                        inexpr_open_count -= 1;\n+                    }\n+                }\n+                (State::Expr, ':') => {\n+                    if inexpr_open_count == 0 {\n+                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                        self.output.push(chr);\n+                        self.extracted_expressions.push(current_expr.trim().into());\n+                        current_expr = String::new();\n+                        self.state = State::FormatOpts;\n+                    } else {\n+                        // We're inside of braced expression, assume that it's a struct field name/value delimeter.\n+                        current_expr.push(chr);\n+                    }\n+                }\n+                (State::Expr, '{') => {\n+                    current_expr.push(chr);\n+                    inexpr_open_count += 1;\n+                }\n+                (State::Expr, _) => {\n+                    current_expr.push(chr);\n+                }\n+                (State::FormatOpts, '}') => {\n+                    self.output.push(chr);\n+                    self.state = State::NotExpr;\n+                }\n+                (State::FormatOpts, _) => {\n+                    self.output.push(chr);\n+                }\n+            }\n+        }\n+\n+        if self.state != State::NotExpr {\n+            return Err(());\n+        }\n+\n+        self.parsed = true;\n+        Ok(())\n+    }\n+\n+    pub fn into_suggestion(&self, macro_name: &str) -> String {\n+        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n+\n+        let expressions_as_string = self.extracted_expressions.join(\", \");\n+        format!(r#\"{}(\"{}\", {})\"#, macro_name, self.output, expressions_as_string)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check(input: &str, expect: &Expect) {\n+        let mut parser = FormatStrParser::new((*input).to_owned());\n+        let outcome_repr = if parser.parse().is_ok() {\n+            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n+            if parser.extracted_expressions.is_empty() {\n+                parser.output\n+            } else {\n+                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n+            }\n+        } else {\n+            // Parsing should fail, expected repr is \"-\".\n+            \"-\".to_owned()\n+        };\n+\n+        expect.assert_eq(&outcome_repr);\n+    }\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", expect![[\"no expressions\"]]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n+            (\"{malformed\", expect![[\"-\"]]),\n+            (\"malformed}\", expect![[\"-\"]]),\n+            (\"{{correct\", expect![[\"{{correct\"]]),\n+            (\"correct}}\", expect![[\"correct}}\"]]),\n+            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n+            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{incorrect}}\", expect![[\"-\"]]),\n+            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n+            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            check(input, output)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_into_suggestion() {\n+        let test_vector = &[\n+            (\"println!\", \"{}\", r#\"println!(\"{}\", $1)\"#),\n+            (\n+                \"log::info!\",\n+                \"{} {expr} {} {2 + 2}\",\n+                r#\"log::info!(\"{} {} {} {}\", $1, expr, $2, 2 + 2)\"#,\n+            ),\n+            (\"format!\", \"{expr:?}\", r#\"format!(\"{:?}\", expr)\"#),\n+        ];\n+\n+        for (kind, input, output) in test_vector {\n+            let mut parser = FormatStrParser::new((*input).to_owned());\n+            parser.parse().expect(\"Parsing must succeed\");\n+\n+            assert_eq!(&parser.into_suggestion(*kind), output);\n+        }\n+    }\n+}"}, {"sha": "101be8eb54b6fd49ba435863c4d1b94875d71dd5", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6574a6f448e3315343c8db497b5e68033ed4d603/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=6574a6f448e3315343c8db497b5e68033ed4d603", "patch": "@@ -469,7 +469,7 @@ impl<'a> CompletionContext<'a> {\n                     }\n                 } else {\n                     false\n-                }\n+                };\n         }\n         if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n             // As above"}]}