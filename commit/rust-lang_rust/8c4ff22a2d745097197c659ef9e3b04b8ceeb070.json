{"sha": "8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNGZmMjJhMmQ3NDUwOTcxOTdjNjU5ZWY5ZTNiMDRiOGNlZWIwNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-13T15:24:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-13T15:24:45Z"}, "message": "Auto merge of #48411 - nikomatsakis:chalkify-canonical-query-mir, r=eddyb\n\nintroduce canonical queries, use for normalization and dropck-outlives\n\nThis branch adds in the concept of a **canonicalized trait query** and uses it for three specific operations:\n\n- `infcx.at(cause, param_env).normalize(type_foldable)`\n    - normalizes all associated types in `type_foldable`\n- `tcx.normalize_erasing_regions(param_env, type_foldable)`\n    - like normalize, but erases regions first and in the result; this leads to better caching\n- `infcx.at(cause, param_env).dropck_outlives(ty)`\n    - produces the set of types that must be live when a value of type `ty` is dropped\n    - used from dropck but also NLL outlives\n\nThis is a kind of \"first step\" towards a more Chalk-ified approach. It leads to a **big** speedup for NLL, which is basically dominated by the dropck-outlives computation. Here are some timing measurements for the `syn` crate (pre-branch measurements coming soon):\n\n| Commit | NLL disabled | NLL enabled |\n| ------- | --- | --- |\n| Before my branch | 5.43s | 8.99s |\n| After my branch | 5.36s | 7.25s |\n\n(Note that NLL enabled still does *all the work* that NLL disabled does, so this is not really a way to compare the performance of NLL versus the AST-based borrow checker directly.) Since this affects all codepaths, I'd like to do a full perf run before we land anything.\n\nAlso, this is not the \"final point\" for canonicalization etc. I think canonicalization can be made substantially faster, for one thing. But it seems like a reasonable starting point for a branch that's gotten a bit larger than I would have liked.\n\n**Commit convention:** First of all, this entire branch ought to be a \"pure refactoring\", I believe, not changing anything about external behavior. Second, I've tagged the most important commits with `[VIC]` (very important commit), so you can scan for those. =)\n\nr? @eddyb", "tree": {"sha": "61da4bce1ccb69b9b35362a967ba2db8a58e1dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61da4bce1ccb69b9b35362a967ba2db8a58e1dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "html_url": "https://github.com/rust-lang/rust/commit/8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e65547d4fad0425d1db4f33a4d8134bf2cad939e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65547d4fad0425d1db4f33a4d8134bf2cad939e", "html_url": "https://github.com/rust-lang/rust/commit/e65547d4fad0425d1db4f33a4d8134bf2cad939e"}, {"sha": "17c4103f3f0cc8bd4dea9de5e7ef155daf363cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/17c4103f3f0cc8bd4dea9de5e7ef155daf363cfe", "html_url": "https://github.com/rust-lang/rust/commit/17c4103f3f0cc8bd4dea9de5e7ef155daf363cfe"}], "stats": {"total": 5489, "additions": 3783, "deletions": 1706}, "files": [{"sha": "ed32984bb5844b3d2870853d1c0515185897e24f", "filename": "src/Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -1884,6 +1884,7 @@ dependencies = [\n  \"rustc_privacy 0.0.0\",\n  \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n+ \"rustc_traits 0.0.0\",\n  \"rustc_trans_utils 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -2068,6 +2069,19 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_traits\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_trans\"\n version = \"0.0.0\""}, {"sha": "8d7fef90b754ef676f8118e4845620ac3cd98940", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -67,11 +67,12 @@ use hir::{HirId, ItemLocalId};\n \n use ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n+use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e. which sub-expression of the macro we are in) but don't need\n@@ -80,6 +81,10 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n+macro_rules! replace {\n+    ($x:tt with $($y:tt)*) => ($($y)*)\n+}\n+\n macro_rules! is_anon_attr {\n     (anon) => (true);\n     ($attr:ident) => (false);\n@@ -111,7 +116,7 @@ macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n         [$($attr:ident),* ]\n-        $variant:ident $(( $($tuple_arg:tt),* ))*\n+        $variant:ident $(( $tuple_arg_ty:ty $(,)* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n     ) => (\n@@ -134,7 +139,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <( $($tuple_arg,)* ) as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -186,7 +191,7 @@ macro_rules! define_dep_nodes {\n                         DepKind :: $variant => {\n                             // tuple args\n                             $({\n-                                $(erase!($tuple_arg);)*\n+                                erase!($tuple_arg_ty);\n                                 return true;\n                             })*\n \n@@ -205,7 +210,7 @@ macro_rules! define_dep_nodes {\n \n         pub enum DepConstructor<$tcx> {\n             $(\n-                $variant $(( $($tuple_arg),* ))*\n+                $variant $(( $tuple_arg_ty ))*\n                          $({ $($struct_arg_name : $struct_arg_ty),* })*\n             ),*\n         }\n@@ -227,15 +232,14 @@ macro_rules! define_dep_nodes {\n             {\n                 match dep {\n                     $(\n-                        DepConstructor :: $variant $(( $($tuple_arg),* ))*\n+                        DepConstructor :: $variant $(( replace!(($tuple_arg_ty) with arg) ))*\n                                                    $({ $($struct_arg_name),* })*\n                             =>\n                         {\n                             // tuple args\n                             $({\n-                                let tupled_args = ( $($tuple_arg,)* );\n-                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n-                                                                         tcx);\n+                                erase!($tuple_arg_ty);\n+                                let hash = DepNodeParams::to_fingerprint(&arg, tcx);\n                                 let dep_node = DepNode {\n                                     kind: DepKind::$variant,\n                                     hash\n@@ -247,7 +251,7 @@ macro_rules! define_dep_nodes {\n                                     tcx.sess.opts.debugging_opts.query_dep_graph)\n                                 {\n                                     tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n-                                        tupled_args.to_debug_str(tcx)\n+                                        arg.to_debug_str(tcx)\n                                     });\n                                 }\n \n@@ -631,7 +635,9 @@ define_dep_nodes!( <'tcx>\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n-    [anon] NormalizeTy,\n+    [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n+    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n@@ -679,43 +685,43 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.def_path_hash(self.0).0\n+        tcx.def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(self.0)\n+        tcx.item_path_str(*self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        tcx.hir.definitions().def_path_hash(self.0).0\n+        tcx.hir.definitions().def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.item_path_str(DefId::local(self.0))\n+        tcx.item_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n         let def_id = DefId {\n-            krate: self.0,\n+            krate: *self,\n             index: CRATE_DEF_INDEX,\n         };\n         tcx.def_path_hash(def_id).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n-        tcx.crate_name(self.0).as_str().to_string()\n+        tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n@@ -743,17 +749,17 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (HirId,) {\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n     fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n-        let (HirId {\n+        let HirId {\n             owner,\n             local_id: ItemLocalId(local_id),\n-        },) = *self;\n+        } = *self;\n \n         let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n         let local_id = Fingerprint::from_smaller_hash(local_id as u64);"}, {"sha": "4eb4f0edafe40981f2f8e77a63c2311f033df8fb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -19,6 +19,7 @@ use std::cell::RefCell;\n use std::hash as std_hash;\n use std::mem;\n use middle::region;\n+use infer;\n use traits;\n use ty;\n use mir;\n@@ -85,6 +86,9 @@ for ty::RegionKind {\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReCanonical(c) => {\n+                c.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.depth.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n@@ -130,6 +134,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CanonicalVar {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -1003,12 +1017,6 @@ impl_stable_hash_for!(struct ty::Destructor {\n     did\n });\n \n-impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n-    outlives,\n-    dtorck_types\n-});\n-\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1229,11 +1237,52 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::UniverseIndex {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.depth().hash_stable(hcx, hasher);\n     }\n }\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n+        variables, value\n+    }\n+);\n+\n+impl_stable_hash_for!(\n+    impl<'tcx> for struct infer::canonical::CanonicalVarValues<'tcx> {\n+        var_values\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n+    kind\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n+    Ty(k),\n+    Region\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n+    General,\n+    Int,\n+    Float\n+});\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, R> for struct infer::canonical::QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n+    region_outlives, ty_outlives\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::Certainty {\n+    Proven, Ambiguous\n+});"}, {"sha": "89dbc76c8a65c2b58306e8d3ea1d95f2de912d29", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -40,9 +40,9 @@ use super::*;\n use ty::relate::{Relate, TypeRelation};\n \n pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    cause: &'a ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub cause: &'a ObligationCause<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -281,6 +281,20 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Regions(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(cause: &ObligationCause<'tcx>,\n                 a_is_expected: bool,"}, {"sha": "9519baa3ff7bcdb2c67892d1abafd0e344249130", "filename": "src/librustc/infer/canonical.rs", "status": "added", "additions": 942, "deletions": 0, "changes": 942, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,942 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constriants\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+//!\n+//! For a more detailed look at what is happening here, check\n+//! out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html\n+\n+use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::fmt::Debug;\n+use std::ops::Index;\n+use syntax::codemap::Span;\n+use traits::{Obligation, ObligationCause, PredicateObligation};\n+use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n+use ty::subst::{Kind, UnpackedKind};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::CellUsizeExt;\n+\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewriten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Canonical<'gcx, V> {\n+    pub variables: CanonicalVarInfos<'gcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables.\n+///\n+/// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n+/// to get back a `CanonicalVarValues` containing fresh inference\n+/// variables.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// Region variable `'?R`.\n+    Region,\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General,\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResult<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug)]\n+pub struct QueryResult<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResult<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+/// Subset of `RegionConstraintData` produced by trait query.\n+#[derive(Clone, Debug, Default)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub region_outlives: Vec<(Region<'tcx>, Region<'tcx>)>,\n+    pub ty_outlives: Vec<(Ty<'tcx>, Region<'tcx>)>,\n+}\n+\n+/// Trait implemented by values that can be canonicalized. It mainly\n+/// serves to identify the interning table we will use.\n+pub trait Canonicalize<'gcx: 'tcx, 'tcx>: TypeFoldable<'tcx> + Lift<'gcx> {\n+    type Canonicalized: 'gcx + Debug;\n+\n+    /// After a value has been fully canonicalized and lifted, this\n+    /// method will allocate it in a global arena.\n+    fn intern(\n+        gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Creates a substitution S for the canonical value with fresh\n+    /// inference variables and applies it to the canonical value.\n+    /// Returns both the instantiated result *and* the substitution S.\n+    ///\n+    /// This is useful at the start of a query: it basically brings\n+    /// the canonical value \"into scope\" within your new infcx. At the\n+    /// end of processing, the substitution S (once canonicalized)\n+    /// then represents the values that you computed for each of the\n+    /// canonical inputs to your query.\n+    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> (T, CanonicalVarValues<'tcx>)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let canonical_inference_vars =\n+            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+        let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n+        (result, canonical_inference_vars)\n+    }\n+\n+    /// Given the \"infos\" about the canonical variables from some\n+    /// canonical, creates fresh inference variables with the same\n+    /// characteristics. You can then use `substitute` to instantiate\n+    /// the canonical variable with these inference variables.\n+    pub fn fresh_inference_vars_for_canonical_vars(\n+        &self,\n+        span: Span,\n+        variables: &Slice<CanonicalVarInfo>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n+            .iter()\n+            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .collect();\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    /// Given the \"info\" about a canonical variable, creates a fresh\n+    /// inference variable with the same characteristics.\n+    pub fn fresh_inference_var_for_canonical_var(\n+        &self,\n+        span: Span,\n+        cv_info: CanonicalVarInfo,\n+    ) -> Kind<'tcx> {\n+        match cv_info.kind {\n+            CanonicalVarKind::Ty(ty_kind) => {\n+                let ty = match ty_kind {\n+                    CanonicalTyVarKind::General => {\n+                        self.next_ty_var(\n+                            // FIXME(#48696) this handling of universes is not right.\n+                            ty::UniverseIndex::ROOT,\n+                            TypeVariableOrigin::MiscVariable(span),\n+                        )\n+                    }\n+\n+                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n+\n+                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n+                };\n+                Kind::from(ty)\n+            }\n+\n+            CanonicalVarKind::Region => {\n+                Kind::from(self.next_region_var(RegionVariableOrigin::MiscVariable(span)))\n+            }\n+        }\n+    }\n+\n+    /// Given the (canonicalized) result to a canonical query,\n+    /// instantiates the result so it can be used, plugging in the\n+    /// values from the canonical query. (Note that the result may\n+    /// have been ambiguous; you should check the certainty level of\n+    /// the query before applying this function.)\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#processing-the-canonicalized-query-result\n+    pub fn instantiate_query_result<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        // Every canonical query result includes values for each of\n+        // the inputs to the query. Therefore, we begin by unifying\n+        // these values with the original inputs that were\n+        // canonicalized.\n+        let result_values = &query_result.value.var_values;\n+        assert_eq!(original_values.len(), result_values.len());\n+\n+        // Quickly try to find initial values for the canonical\n+        // variables in the result in terms of the query. We do this\n+        // by iterating down the values that the query gave to each of\n+        // the canonical inputs. If we find that one of those values\n+        // is directly equal to one of the canonical variables in the\n+        // result, then we can type the corresponding value from the\n+        // input. See the example above.\n+        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n+            IndexVec::from_elem_n(None, query_result.variables.len());\n+\n+        // In terms of our example above, we are iterating over pairs like:\n+        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n+        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+            match result_value.unpack() {\n+                UnpackedKind::Type(result_value) => {\n+                    // e.g., here `result_value` might be `?0` in the example above...\n+                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+                UnpackedKind::Lifetime(result_value) => {\n+                    // e.g., here `result_value` might be `'?1` in the example above...\n+                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n+                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Create a result substitution: if we found a value for a\n+        // given variable in the loop above, use that. Otherwise, use\n+        // a fresh inference variable.\n+        let result_subst = &CanonicalVarValues {\n+            var_values: query_result\n+                .variables\n+                .iter()\n+                .enumerate()\n+                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n+                    Some(k) => k,\n+                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n+                })\n+                .collect(),\n+        };\n+\n+        // Unify the original values for the canonical variables in\n+        // the input with the value found in the query\n+        // post-substitution. Often, but not always, this is a no-op,\n+        // because we already found the mapping in the first step.\n+        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n+        };\n+        let mut obligations =\n+            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n+                .into_obligations();\n+\n+        obligations.extend(self.query_region_constraints_into_obligations(\n+            cause,\n+            param_env,\n+            &query_result.value.region_constraints,\n+            result_subst,\n+        ));\n+\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// Converts the region constraints resulting from a query into an\n+    /// iterator of obligations.\n+    fn query_region_constraints_into_obligations<'a>(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n+        result_subst: &'a CanonicalVarValues<'tcx>,\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        let QueryRegionConstraints {\n+            region_outlives,\n+            ty_outlives,\n+        } = unsubstituted_region_constraints;\n+\n+        let region_obligations = region_outlives.iter().map(move |(r1, r2)| {\n+            let r1 = substitute_value(self.tcx, result_subst, r1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n+            )\n+        });\n+\n+        let ty_obligations = ty_outlives.iter().map(move |(t1, r2)| {\n+            let t1 = substitute_value(self.tcx, result_subst, t1);\n+            let r2 = substitute_value(self.tcx, result_subst, r2);\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n+            )\n+        });\n+\n+        region_obligations.chain(ty_obligations)\n+    }\n+\n+    /// Given two sets of values for the same set of canonical variables, unify them.\n+    /// The second set is produced lazilly by supplying indices from the first set.\n+    fn unify_canonical_vars(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        variables1: &CanonicalVarValues<'tcx>,\n+        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        self.commit_if_ok(|_| {\n+            let mut obligations = vec![];\n+            for (index, value1) in variables1.var_values.iter_enumerated() {\n+                let value2 = variables2(index);\n+\n+                match (value1.unpack(), value2.unpack()) {\n+                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                    }\n+                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    _ => {\n+                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n+                    }\n+                }\n+            }\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        })\n+    }\n+\n+    /// Canonicalizes a query value `V`. When we canonicalize a query,\n+    /// we not only canonicalize unbound inference variables, but we\n+    /// *also* replace all free regions whatsoever. So for example a\n+    /// query like `T: Trait<'static>` would be canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#canonicalizing-the-query\n+    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        self.tcx.sess.perf_stats.queries_canonicalized.increment();\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(true),\n+        )\n+    }\n+\n+    /// Canonicalizes a query *response* `V`. When we canonicalize a\n+    /// query response, we only canonicalize unbound inference\n+    /// variables, and we leave other free regions alone. So,\n+    /// continuing with the example from `canonicalize_query`, if\n+    /// there was an input query `T: Trait<'static>`, it would have\n+    /// been canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n+    /// exists only one possible impl of `Trait`, and it looks like\n+    ///\n+    ///     impl<T> Trait<'static> for T { .. }\n+    ///\n+    /// then we would prepare a query result R that (among other\n+    /// things) includes a mapping to `'?0 := 'static`. When\n+    /// canonicalizing this query result R, we would leave this\n+    /// reference to `'static` alone.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits-canonicalization.html#canonicalizing-the-query-result\n+    pub fn canonicalize_response<V>(\n+        &self,\n+        value: &V,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(false),\n+        )\n+    }\n+}\n+\n+/// If this flag is true, then all free regions will be replaced with\n+/// a canonical var. This is used to make queries as generic as\n+/// possible. For example, the query `F: Foo<'static>` would be\n+/// canonicalized to `F: Foo<'0>`.\n+struct CanonicalizeAllFreeRegions(bool);\n+\n+struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n+    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    needs_canonical_flags: TypeFlags,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReVar(vid) => {\n+                let r = self.infcx\n+                    .unwrap()\n+                    .borrow_region_constraints()\n+                    .opportunistic_resolve_var(self.tcx, vid);\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Region,\n+                };\n+                debug!(\n+                    \"canonical: region var found with vid {:?}, \\\n+                     opportunistically resolved to {:?}\",\n+                    vid, r\n+                );\n+                let cvar = self.canonical_var(info, Kind::from(r));\n+                self.tcx().mk_region(ty::ReCanonical(cvar))\n+            }\n+\n+            ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReScope(_)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased => {\n+                if self.canonicalize_all_free_regions.0 {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, Kind::from(r));\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n+                bug!(\"canonical region encountered during canonicalization\")\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+\n+            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+\n+            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"encountered a fresh type during canonicalization\")\n+            }\n+\n+            ty::TyInfer(ty::CanonicalTy(_)) => {\n+                bug!(\"encountered a canonical type during canonicalization\")\n+            }\n+\n+            // Replace a `()` that \"would've fallen back\" to `!` with just `()`.\n+            ty::TyTuple(ref tys, true) => {\n+                assert!(tys.is_empty());\n+                self.tcx().mk_nil()\n+            }\n+\n+            ty::TyClosure(..)\n+            | ty::TyGenerator(..)\n+            | ty::TyGeneratorWitness(..)\n+            | ty::TyBool\n+            | ty::TyChar\n+            | ty::TyInt(..)\n+            | ty::TyUint(..)\n+            | ty::TyFloat(..)\n+            | ty::TyAdt(..)\n+            | ty::TyStr\n+            | ty::TyError\n+            | ty::TyArray(..)\n+            | ty::TySlice(..)\n+            | ty::TyRawPtr(..)\n+            | ty::TyRef(..)\n+            | ty::TyFnDef(..)\n+            | ty::TyFnPtr(_)\n+            | ty::TyDynamic(..)\n+            | ty::TyNever\n+            | ty::TyTuple(_, false)\n+            | ty::TyProjection(..)\n+            | ty::TyForeign(..)\n+            | ty::TyParam(..)\n+            | ty::TyAnon(..) => {\n+                if t.flags.intersects(self.needs_canonical_flags) {\n+                    t.super_fold_with(self)\n+                } else {\n+                    t\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+    /// The main `canonicalize` method, shared impl of\n+    /// `canonicalize_query` and `canonicalize_response`.\n+    fn canonicalize<V>(\n+        value: &V,\n+        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        debug_assert!(\n+            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            \"canonicalizing a canonical value: {:?}\",\n+            value,\n+        );\n+\n+        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n+            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n+        } else {\n+            TypeFlags::KEEP_IN_LOCAL_TCX\n+        };\n+\n+        let gcx = tcx.global_tcx();\n+\n+        // Fast path: nothing that needs to be canonicalized.\n+        if !value.has_type_flags(needs_canonical_flags) {\n+            let out_value = gcx.lift(value).unwrap();\n+            let canon_value = V::intern(\n+                gcx,\n+                Canonical {\n+                    variables: Slice::empty(),\n+                    value: out_value,\n+                },\n+            );\n+            let values = CanonicalVarValues {\n+                var_values: IndexVec::default(),\n+            };\n+            return (canon_value, values);\n+        }\n+\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            tcx,\n+            canonicalize_all_free_regions,\n+            needs_canonical_flags,\n+            variables: IndexVec::default(),\n+            indices: FxHashMap::default(),\n+            var_values: IndexVec::default(),\n+        };\n+        let out_value = value.fold_with(&mut canonicalizer);\n+\n+        // Once we have canonicalized `out_value`, it should not\n+        // contain anything that ties it to this inference context\n+        // anymore, so it should live in the global arena.\n+        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n+            bug!(\n+                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n+                out_value,\n+                value\n+            )\n+        });\n+\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+\n+        let canonical_value = V::intern(\n+            gcx,\n+            Canonical {\n+                variables: canonical_variables,\n+                value: out_value,\n+            },\n+        );\n+        let canonical_var_values = CanonicalVarValues {\n+            var_values: canonicalizer.var_values,\n+        };\n+        (canonical_value, canonical_var_values)\n+    }\n+\n+    /// Creates a canonical variable replacing `kind` from the input,\n+    /// or returns an existing variable if `kind` has already been\n+    /// seen. `kind` is expected to be an unbound variable (or\n+    /// potentially a free region).\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n+        let Canonicalizer {\n+            indices,\n+            variables,\n+            var_values,\n+            ..\n+        } = self;\n+\n+        indices\n+            .entry(kind)\n+            .or_insert_with(|| {\n+                let cvar1 = variables.push(info);\n+                let cvar2 = var_values.push(kind);\n+                assert_eq!(cvar1, cvar2);\n+                cvar1\n+            })\n+            .clone()\n+    }\n+\n+    /// Given a type variable `ty_var` of the given kind, first check\n+    /// if `ty_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `ty_var`.\n+    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n+        let bound_to = infcx.shallow_resolve(ty_var);\n+        if bound_to != ty_var {\n+            self.fold_ty(bound_to)\n+        } else {\n+            let info = CanonicalVarInfo {\n+                kind: CanonicalVarKind::Ty(ty_kind),\n+            };\n+            let cvar = self.canonical_var(info, Kind::from(ty_var));\n+            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n+        }\n+    }\n+}\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Instantiate the wrapped value, replacing each canonical value\n+    /// with the value given in `var_values`.\n+    fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    /// Invoke `projection_fn` with `self.value` to get a value V that\n+    /// is expressed in terms of the same canonical variables bound in\n+    /// `self`. Apply the substitution `var_values` to this value V,\n+    /// replacing each of the canonical variables.\n+    fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        let value = projection_fn(&self.value);\n+        substitute_value(tcx, var_values, value)\n+    }\n+}\n+\n+/// Substitute the values from `var_values` into `value`. `var_values`\n+/// must be values for the set of cnaonical variables that appear in\n+/// `value`.\n+fn substitute_value<'a, 'tcx, T>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    var_values: &CanonicalVarValues<'tcx>,\n+    value: &'a T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    if var_values.var_values.is_empty() {\n+        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n+        value.clone()\n+    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+        value.clone()\n+    } else {\n+        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+    }\n+}\n+\n+struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    var_values: &'cx CanonicalVarValues<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+                match self.var_values.var_values[c].unpack() {\n+                    UnpackedKind::Type(ty) => ty,\n+                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n+                }\n+            }\n+            _ => {\n+                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n+            },\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    for <'tcx> {\n+        ::infer::canonical::Certainty,\n+        ::infer::canonical::CanonicalVarInfo,\n+        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+        ::infer::canonical::CanonicalVarKind,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n+        variables,\n+        value,\n+    } where C: TypeFoldable<'tcx>\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n+        self.var_values.iter().cloned()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = Kind<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for CanonicalVarValues<'a> {\n+        type Lifted = CanonicalVarValues<'tcx>;\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for CanonicalVarValues<'tcx> {\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n+        type Lifted = QueryRegionConstraints<'tcx>;\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    } where R: TypeFoldable<'tcx>,\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n+        type Lifted = QueryResult<'tcx, R::Lifted>;\n+        var_values, region_constraints, certainty, value\n+    } where R: Lift<'tcx>\n+}\n+\n+impl<'tcx> Index<CanonicalVar> for CanonicalVarValues<'tcx> {\n+    type Output = Kind<'tcx>;\n+\n+    fn index(&self, value: CanonicalVar) -> &Kind<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}, {"sha": "1c581c44464e72ab7085df3a8f736a95fcaf9f75", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -476,6 +476,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 }\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 span_bug!(\n                     self.span,"}, {"sha": "96c2309882108769634a9f91b1c978a4b9e86b1b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -154,6 +154,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }\n@@ -975,6 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n+            infer::Regions(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }"}, {"sha": "6074bfd083d46dc82a0f1d8e5080ea8a85d6230e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -114,9 +114,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 self.tcx().types.re_erased\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    \"encountered unexpected region: {:?}\",\n                     r,\n                 );\n             }\n@@ -170,6 +171,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n+            ty::TyInfer(ty::CanonicalTy(..)) =>\n+                bug!(\"encountered canonical ty during freshening\"),\n+\n             ty::TyGenerator(..) |\n             ty::TyBool |\n             ty::TyChar |"}, {"sha": "00b2ac7449f7e9a9ac1e5378296d3c560b25eadb", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -258,6 +258,8 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.region_rels.tcx;\n         match (a, b) {\n+            (&ty::ReCanonical(..), _) |\n+            (_, &ty::ReCanonical(..)) |\n             (&ty::ReClosureBound(..), _) |\n             (_, &ty::ReClosureBound(..)) |\n             (&ReLateBound(..), _) |"}, {"sha": "fe919775da0b412a8e27280ca3b2bfed1d56e43a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 209, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -21,21 +21,20 @@ use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n-use mir::tcx::PlaceTy;\n use ty::subst::Substs;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations, Reveal};\n+use traits::{self, ObligationCause, PredicateObligations};\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n-use syntax_pos::{self, Span, DUMMY_SP};\n+use syntax_pos::{self, Span};\n use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n \n@@ -50,6 +49,7 @@ use self::unify_key::ToType;\n \n pub mod anon_types;\n pub mod at;\n+pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -68,6 +68,7 @@ pub mod type_variable;\n pub mod unify_key;\n \n #[must_use]\n+#[derive(Debug)]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n     pub obligations: PredicateObligations<'tcx>,\n@@ -191,6 +192,7 @@ pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n+    Regions(ExpectedFound<ty::Region<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n@@ -472,6 +474,12 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     }\n }\n \n+impl<'tcx> InferOk<'tcx, ()> {\n+    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n@@ -484,176 +492,7 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n-/// Helper trait for shortening the lifetimes inside a\n-/// value for post-type-checking normalization.\n-pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>)\n-                                 -> Self;\n-}\n-\n-macro_rules! items { ($($item:item)+) => ($($item)+) }\n-macro_rules! impl_trans_normalize {\n-    ($lt_gcx:tt, $($ty:ty),+) => {\n-        items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n-            fn trans_normalize<'a, 'tcx>(&self,\n-                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n-                                         param_env: ty::ParamEnv<'tcx>)\n-                                         -> Self {\n-                infcx.normalize_projections_in(param_env, self)\n-            }\n-        })+);\n-    }\n-}\n-\n-impl_trans_normalize!('gcx,\n-    Ty<'gcx>,\n-    &'gcx ty::Const<'gcx>,\n-    &'gcx Substs<'gcx>,\n-    ty::FnSig<'gcx>,\n-    ty::PolyFnSig<'gcx>,\n-    ty::ClosureSubsts<'gcx>,\n-    ty::PolyTraitRef<'gcx>,\n-    ty::ExistentialTraitRef<'gcx>\n-);\n-\n-impl<'gcx> TransNormalize<'gcx> for PlaceTy<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                 param_env: ty::ParamEnv<'tcx>)\n-                                 -> Self {\n-        match *self {\n-            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n-            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n-                PlaceTy::Downcast {\n-                    adt_def,\n-                    substs: substs.trans_normalize(infcx, param_env),\n-                    variant_index,\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// NOTE: Callable from trans only!\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Currently, higher-ranked type bounds inhibit normalization. Therefore,\n-    /// each time we erase them in translation, we need to normalize\n-    /// the contents.\n-    pub fn erase_late_bound_regions_and_normalize<T>(self, value: &ty::Binder<T>)\n-        -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        assert!(!value.needs_subst());\n-        let value = self.erase_late_bound_regions(value);\n-        self.fully_normalize_associated_types_in(&value)\n-    }\n-\n-    /// Fully normalizes any associated types in `value`, using an\n-    /// empty environment and `Reveal::All` mode (therefore, suitable\n-    /// only for monomorphized code during trans, basically).\n-    pub fn fully_normalize_associated_types_in<T>(self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        debug!(\"fully_normalize_associated_types_in(t={:?})\", value);\n-\n-        let param_env = ty::ParamEnv::empty(Reveal::All);\n-        let value = self.erase_regions(value);\n-\n-        if !value.has_projections() {\n-            return value;\n-        }\n-\n-        self.infer_ctxt().enter(|infcx| {\n-            value.trans_normalize(&infcx, param_env)\n-        })\n-    }\n-\n-    /// Does a best-effort to normalize any associated types in\n-    /// `value`; this includes revealing specializable types, so this\n-    /// should be not be used during type-checking, but only during\n-    /// optimization and code generation.\n-    pub fn normalize_associated_type_in_env<T>(\n-        self, value: &T, env: ty::ParamEnv<'tcx>\n-    ) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        debug!(\"normalize_associated_type_in_env(t={:?})\", value);\n-\n-        let value = self.erase_regions(value);\n-\n-        if !value.has_projections() {\n-            return value;\n-        }\n-\n-        self.infer_ctxt().enter(|infcx| {\n-            value.trans_normalize(&infcx, env.reveal_all())\n-       })\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn normalize_projections_in<T>(&self, param_env: ty::ParamEnv<'tcx>, value: &T) -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-    {\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-\n-        debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n-                result, obligations);\n-\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(self, obligation);\n-        }\n-\n-        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n-    }\n-\n-    /// Finishes processes any obligations that remain in the\n-    /// fulfillment context, and then returns the result with all type\n-    /// variables removed and regions erased. Because this is intended\n-    /// for use after type-check has completed, if any errors occur,\n-    /// it will panic. It is used during normalization and other cases\n-    /// where processing the obligations in `fulfill_cx` may cause\n-    /// type inference variables that appear in `result` to be\n-    /// unified, and hence we need to process those obligations to get\n-    /// the complete picture of the type.\n-    pub fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                            span: Span,\n-                                            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                            result: &T)\n-                                            -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-    {\n-        debug!(\"drain_fulfillment_cx_or_panic()\");\n-\n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                          errors);\n-            }\n-        }\n-\n-        let result = self.resolve_type_vars_if_possible(result);\n-        let result = self.tcx.erase_regions(&result);\n-\n-        match self.tcx.lift_to_global(&result) {\n-            Some(result) => result,\n-            None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n-            }\n-        }\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -1212,6 +1051,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().take_and_reset_data()\n     }\n \n+    /// Gives temporary access to the region constraint data.\n+    #[allow(non_camel_case_types)] // bug with impl trait\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let region_constraints = self.borrow_region_constraints();\n+        op(region_constraints.data())\n+    }\n+\n     /// Takes ownership of the list of variable regions. This implies\n     /// that all the region constriants have already been taken, and\n     /// hence that `resolve_regions_and_report_errors` can never be\n@@ -1246,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n                 // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n+                // variables from unifyxing to other type variables\n                 // directly (though they may be embedded\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n@@ -1623,40 +1472,12 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ValuePairs::Types(ref ef) => {\n-                ValuePairs::Types(ef.fold_with(folder))\n-            }\n-            ValuePairs::TraitRefs(ref ef) => {\n-                ValuePairs::TraitRefs(ef.fold_with(folder))\n-            }\n-            ValuePairs::PolyTraitRefs(ref ef) => {\n-                ValuePairs::PolyTraitRefs(ef.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ValuePairs::Types(ref ef) => ef.visit_with(visitor),\n-            ValuePairs::TraitRefs(ref ef) => ef.visit_with(visitor),\n-            ValuePairs::PolyTraitRefs(ref ef) => ef.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TypeTrace {\n-            cause: self.cause.fold_with(folder),\n-            values: self.values.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.cause.visit_with(visitor) || self.values.visit_with(visitor)\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n+        (ValuePairs::Types)(a),\n+        (ValuePairs::Regions)(a),\n+        (ValuePairs::TraitRefs)(a),\n+        (ValuePairs::PolyTraitRefs)(a),\n     }\n }\n \n@@ -1667,4 +1488,3 @@ impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n                self.sup_type)\n     }\n }\n-"}, {"sha": "e5461685bd470bd21a744008698bf75013d6f0ac", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -99,6 +99,16 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .push((body_id, obligation));\n     }\n \n+    /// Trait queries just want to pass back type obligations \"as is\"\n+    pub fn take_registered_region_obligations(\n+        &self,\n+    ) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+        ::std::mem::replace(\n+            &mut *self.region_obligations.borrow_mut(),\n+            vec![],\n+        )\n+    }\n+\n     /// Process the region obligations that must be proven (during\n     /// `regionck`) for the given `body_id`, given information about\n     /// the region bounds in scope and so forth. This function must be"}, {"sha": "0c8e49fda1840d7cab10569ee946bfebd5be85e9", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -350,6 +350,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         mem::replace(data, RegionConstraintData::default())\n     }\n \n+    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n+        &self.data\n+    }\n+\n     fn in_snapshot(&self) -> bool {\n         !self.undo_log.is_empty()\n     }"}, {"sha": "77b3a87c0ed16d50c2fc4a60761d52248015b5d8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -57,8 +57,9 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n-#![feature(macro_vis_matcher)]\n #![feature(match_default_bindings)]\n+#![feature(macro_lifetime_matcher)]\n+#![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(non_exhaustive)]\n #![feature(nonzero)]"}, {"sha": "4fa6594df169cd4af5f33efb3b9172410b6e7cba", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -34,7 +34,6 @@ use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use session::{config, early_error, Session};\n-use traits::Reveal;\n use ty::{self, TyCtxt, Ty};\n use ty::layout::{LayoutError, LayoutOf, TyLayout};\n use util::nodemap::FxHashMap;\n@@ -1055,7 +1054,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut cx = LateContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+        param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),\n         last_ast_node_with_lint_attrs: ast::CRATE_NODE_ID,"}, {"sha": "d8a723e184d2ca3f3d53c005c464434fba1ccbf6", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -119,6 +119,25 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+\n+    (impl<$tcx:lifetime $(, $T:ident)*> for struct $struct_name:path {\n+        $($field:ident),* $(,)*\n+    }) => {\n+        impl<'a, $tcx, $($T,)*> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n }\n \n #[macro_export]\n@@ -138,3 +157,303 @@ macro_rules! impl_stable_hash_for_spanned {\n     );\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Lift and TypeFoldable macros\n+//\n+// When possible, use one of these (relatively) convenient macros to write\n+// the impls for you.\n+\n+#[macro_export]\n+macro_rules! CloneLiftImpls {\n+    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+        $(\n+            impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n+                type Lifted = Self;\n+                fn lift_to_tcx<'a, 'gcx>(&self, _: $crate::ty::TyCtxt<'a, 'gcx, $tcx>) -> Option<Self> {\n+                    Some(Clone::clone(self))\n+                }\n+            }\n+        )+\n+    };\n+\n+    ($($ty:ty,)+) => {\n+        CloneLiftImpls! {\n+            for <'tcx> {\n+                $($ty,)+\n+            }\n+        }\n+    };\n+}\n+\n+/// Used for types that are `Copy` and which **do not care arena\n+/// allocated data** (i.e., don't need to be folded).\n+#[macro_export]\n+macro_rules! CloneTypeFoldableImpls {\n+    (for <$tcx:lifetime> { $($ty:ty,)+ }) => {\n+        $(\n+            impl<$tcx> $crate::ty::fold::TypeFoldable<$tcx> for $ty {\n+                fn super_fold_with<'gcx: $tcx, F: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                    &self,\n+                    _: &mut F\n+                ) -> $ty {\n+                    Clone::clone(self)\n+                }\n+\n+                fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                    &self,\n+                    _: &mut F)\n+                    -> bool\n+                {\n+                    false\n+                }\n+            }\n+        )+\n+    };\n+\n+    ($($ty:ty,)+) => {\n+        CloneTypeFoldableImpls! {\n+            for <'tcx> {\n+                $($ty,)+\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! CloneTypeFoldableAndLiftImpls {\n+    ($($t:tt)*) => {\n+        CloneTypeFoldableImpls! { $($t)* }\n+        CloneLiftImpls! { $($t)* }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! BraceStructLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                $(let $field = tcx.lift(&self.$field)?;)*\n+                Some(Self::Lifted { $($field),* })\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumLiftImpl {\n+    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n+        type Lifted = $lifted:ty;\n+        $(\n+            ($variant:path) ( $( $variant_arg:ident),* )\n+        ),*\n+        $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            type Lifted = $lifted;\n+\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+                match self {\n+                    $($variant ( $($variant_arg),* ) => {\n+                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n+                    })*\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! BraceStructTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                let $s { $($field,)* } = self;\n+                $s { $($field: $crate::ty::fold::TypeFoldable::fold_with($field, folder),)* }\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                let $s { $($field,)* } = self;\n+                false $(|| $crate::ty::fold::TypeFoldable::visit_with($field, visitor))*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! TupleStructTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($field:ident),* $(,)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                let $s($($field,)*)= self;\n+                $s($($crate::ty::fold::TypeFoldable::fold_with($field, folder),)*)\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                let $s($($field,)*) = self;\n+                false $(|| $crate::ty::fold::TypeFoldable::visit_with($field, visitor))*\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! EnumTypeFoldableImpl {\n+    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n+        $($variants:tt)*\n+    } $(where $($wc:tt)*)*) => {\n+        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n+            $(where $($wc)*)*\n+        {\n+            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n+                &self,\n+                folder: &mut V,\n+            ) -> Self {\n+                EnumTypeFoldableImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n+            }\n+\n+            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n+                &self,\n+                visitor: &mut V,\n+            ) -> bool {\n+                EnumTypeFoldableImpl!(@VisitVariants(self, visitor) input($($variants)*) output())\n+            }\n+        }\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        $variant (\n+                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)),*\n+                        )\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        $variant {\n+                            $($variant_arg: $crate::ty::fold::TypeFoldable::fold_with(\n+                                $variant_arg, $folder\n+                            )),* }\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@FoldVariants($this:expr, $folder:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @FoldVariants($this, $folder)\n+                input($($input)*)\n+                output(\n+                    $variant => { $variant }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                            $variant_arg, $visitor\n+                        ))*\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant { $($variant_arg),* } => {\n+                        false $(|| $crate::ty::fold::TypeFoldable::visit_with(\n+                            $variant_arg, $visitor\n+                        ))*\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@VisitVariants($this:expr, $visitor:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumTypeFoldableImpl!(\n+            @VisitVariants($this, $visitor)\n+                input($($input)*)\n+                output(\n+                    $variant => { false }\n+                    $($output)*\n+                )\n+        )\n+    };\n+}\n+"}, {"sha": "9b75c19a875ebc4ad83ac100ae5f1aa6a78afb92", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -76,3 +76,7 @@ fn calculate_predecessors(mir: &Mir) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n \n     result\n }\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    Cache,\n+}"}, {"sha": "939710ffd2b86a53a7864b91241da4dfd41e84da", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 64, "deletions": 122, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -2109,148 +2109,90 @@ pub enum ClosureOutlivesSubject<'tcx> {\n  * TypeFoldable implementations for MIR types\n  */\n \n-impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        Mir {\n-            basic_blocks: self.basic_blocks.fold_with(folder),\n-            visibility_scopes: self.visibility_scopes.clone(),\n-            visibility_scope_info: self.visibility_scope_info.clone(),\n-            promoted: self.promoted.fold_with(folder),\n-            yield_ty: self.yield_ty.fold_with(folder),\n-            generator_drop: self.generator_drop.fold_with(folder),\n-            generator_layout: self.generator_layout.fold_with(folder),\n-            local_decls: self.local_decls.fold_with(folder),\n-            arg_count: self.arg_count,\n-            upvar_decls: self.upvar_decls.clone(),\n-            spread_arg: self.spread_arg,\n-            span: self.span,\n-            cache: cache::Cache::new()\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.basic_blocks.visit_with(visitor) ||\n-        self.generator_drop.visit_with(visitor) ||\n-        self.generator_layout.visit_with(visitor) ||\n-        self.yield_ty.visit_with(visitor) ||\n-        self.promoted.visit_with(visitor)     ||\n-        self.local_decls.visit_with(visitor)\n-    }\n+CloneTypeFoldableAndLiftImpls! {\n+    Mutability,\n+    SourceInfo,\n+    UpvarDecl,\n+    ValidationOp,\n+    VisibilityScopeData,\n+    VisibilityScope,\n+    VisibilityScopeInfo,\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        GeneratorLayout {\n-            fields: self.fields.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.fields.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n+        basic_blocks,\n+        visibility_scopes,\n+        visibility_scope_info,\n+        promoted,\n+        yield_ty,\n+        generator_drop,\n+        generator_layout,\n+        local_decls,\n+        arg_count,\n+        upvar_decls,\n+        spread_arg,\n+        span,\n+        cache,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        LocalDecl {\n-            ty: self.ty.fold_with(folder),\n-            ..self.clone()\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n+        fields\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        BasicBlockData {\n-            statements: self.statements.fold_with(folder),\n-            terminator: self.terminator.fold_with(folder),\n-            is_cleanup: self.is_cleanup\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n+        mutability,\n+        is_user_variable,\n+        internal,\n+        ty,\n+        name,\n+        source_info,\n+        syntactic_scope,\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.statements.visit_with(visitor) || self.terminator.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n+        statements,\n+        terminator,\n+        is_cleanup,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ValidationOperand {\n-            place: self.place.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-            re: self.re,\n-            mutbl: self.mutbl,\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Place<'tcx>> {\n+        place, ty, re, mutbl\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.place.visit_with(visitor) || self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n+        source_info, kind\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::StatementKind::*;\n-\n-        let kind = match self.kind {\n-            Assign(ref place, ref rval) => Assign(place.fold_with(folder), rval.fold_with(folder)),\n-            SetDiscriminant { ref place, variant_index } => SetDiscriminant {\n-                place: place.fold_with(folder),\n-                variant_index,\n-            },\n-            StorageLive(ref local) => StorageLive(local.fold_with(folder)),\n-            StorageDead(ref local) => StorageDead(local.fold_with(folder)),\n-            InlineAsm { ref asm, ref outputs, ref inputs } => InlineAsm {\n-                asm: asm.clone(),\n-                outputs: outputs.fold_with(folder),\n-                inputs: inputs.fold_with(folder)\n-            },\n-\n-            // Note for future: If we want to expose the region scopes\n-            // during the fold, we need to either generalize EndRegion\n-            // to carry `[ty::Region]`, or extend the `TypeFolder`\n-            // trait with a `fn fold_scope`.\n-            EndRegion(ref region_scope) => EndRegion(region_scope.clone()),\n-\n-            Validate(ref op, ref places) =>\n-                Validate(op.clone(),\n-                         places.iter().map(|operand| operand.fold_with(folder)).collect()),\n-\n-            Nop => Nop,\n-        };\n-        Statement {\n-            source_info: self.source_info,\n-            kind,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n+        (StatementKind::Assign)(a, b),\n+        (StatementKind::SetDiscriminant) { place, variant_index },\n+        (StatementKind::StorageLive)(a),\n+        (StatementKind::StorageDead)(a),\n+        (StatementKind::InlineAsm) { asm, outputs, inputs },\n+        (StatementKind::Validate)(a, b),\n+        (StatementKind::EndRegion)(a),\n+        (StatementKind::Nop),\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::StatementKind::*;\n-\n-        match self.kind {\n-            Assign(ref place, ref rval) => { place.visit_with(visitor) || rval.visit_with(visitor) }\n-            SetDiscriminant { ref place, .. } => place.visit_with(visitor),\n-            StorageLive(ref local) |\n-            StorageDead(ref local) => local.visit_with(visitor),\n-            InlineAsm { ref outputs, ref inputs, .. } =>\n-                outputs.visit_with(visitor) || inputs.visit_with(visitor),\n-\n-            // Note for future: If we want to expose the region scopes\n-            // during the visit, we need to either generalize EndRegion\n-            // to carry `[ty::Region]`, or extend the `TypeVisitor`\n-            // trait with a `fn visit_scope`.\n-            EndRegion(ref _scope) => false,\n-\n-            Validate(ref _op, ref places) =>\n-                places.iter().any(|ty_and_place| ty_and_place.visit_with(visitor)),\n-\n-            Nop => false,\n-        }\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ClearCrossCrate<T> {\n+        (ClearCrossCrate::Clear),\n+        (ClearCrossCrate::Set)(a),\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {"}, {"sha": "d779ccd17360ad212af3b96272ce92030a59651d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -16,7 +16,6 @@\n use mir::*;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use hir;\n use ty::util::IntTypeExt;\n \n@@ -100,25 +99,10 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            PlaceTy::Ty { ty } => PlaceTy::Ty { ty: ty.fold_with(folder) },\n-            PlaceTy::Downcast { adt_def, substs, variant_index } => {\n-                PlaceTy::Downcast {\n-                    adt_def,\n-                    substs: substs.fold_with(folder),\n-                    variant_index,\n-                }\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            PlaceTy::Ty { ty } => ty.visit_with(visitor),\n-            PlaceTy::Downcast { substs, .. } => substs.visit_with(visitor)\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n+        (PlaceTy::Ty) { ty },\n+        (PlaceTy::Downcast) { adt_def, substs, variant_index },\n     }\n }\n "}, {"sha": "3f52ecfc0999b5980e8c28498d5faf93f4f0413e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -173,6 +173,15 @@ pub struct PerfStats {\n     pub symbol_hash_time: Cell<Duration>,\n     /// The accumulated time spent decoding def path tables from metadata\n     pub decode_def_path_tables_time: Cell<Duration>,\n+    /// Total number of values canonicalized queries constructed.\n+    pub queries_canonicalized: Cell<usize>,\n+    /// Number of times we canonicalized a value and found that the\n+    /// result had already been canonicalized.\n+    pub canonicalized_values_allocated: Cell<usize>,\n+    /// Number of times this query is invoked.\n+    pub normalize_ty_after_erasing_regions: Cell<usize>,\n+    /// Number of times this query is invoked.\n+    pub normalize_projection_ty: Cell<usize>,\n }\n \n /// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n@@ -858,6 +867,14 @@ impl Session {\n             \"Total time spent decoding DefPath tables:      {}\",\n             duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get())\n         );\n+        println!(\"Total queries canonicalized:                   {}\",\n+                 self.perf_stats.queries_canonicalized.get());\n+        println!(\"Total canonical values interned:               {}\",\n+                 self.perf_stats.canonicalized_values_allocated.get());\n+        println!(\"normalize_ty_after_erasing_regions:            {}\",\n+                 self.perf_stats.normalize_ty_after_erasing_regions.get());\n+        println!(\"normalize_projection_ty:                       {}\",\n+                 self.perf_stats.normalize_projection_ty.get());\n     }\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n@@ -1144,6 +1161,10 @@ pub fn build_session_(\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n+            queries_canonicalized: Cell::new(0),\n+            canonicalized_values_allocated: Cell::new(0),\n+            normalize_ty_after_erasing_regions: Cell::new(0),\n+            normalize_projection_ty: Cell::new(0),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n         optimization_fuel_crate,"}, {"sha": "06926b1648df5ed67acb09754865599c3e64e088", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -16,7 +16,7 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n-use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n@@ -125,7 +125,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n     // empty environment.\n-    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+    let param_env = ty::ParamEnv::empty();\n \n     let a_impl_header = with_fresh_ty_vars(selcx, param_env, a_def_id);\n     let b_impl_header = with_fresh_ty_vars(selcx, param_env, b_def_id);"}, {"sha": "b8455b97fa41f3eb7f514475eff5ceb954df1376", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -21,7 +21,6 @@ use super::{\n     TraitNotObjectSafe,\n     ConstEvalFailure,\n     PredicateObligation,\n-    Reveal,\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n@@ -140,7 +139,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n-                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                let param_env = ty::ParamEnv::empty();\n                 if let Ok(_) = self.can_sub(param_env, error, implication) {\n                     debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n                     return true"}, {"sha": "a2a5aa246cf776ce876169554ef65ce9e1001380", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -63,6 +63,8 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n+pub mod query;\n+\n // Whether to enable bug compatibility with issue #43355\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n@@ -695,7 +697,7 @@ fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            predicates);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::empty(Reveal::All);\n+        let param_env = ty::ParamEnv::reveal_all();\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();\n@@ -768,7 +770,10 @@ fn vtable_methods<'a, 'tcx>(\n                 // the trait type may have higher-ranked lifetimes in it;\n                 // so erase them if they appear, so that we get the type\n                 // at some particular call site\n-                let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n+                let substs = tcx.normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &ty::Binder(substs),\n+                );\n \n                 // It's possible that the method relies on where clauses that\n                 // do not hold for this particular set of type parameters."}, {"sha": "0fe4daa36ed4a628b8bda5beaa76a0aa9e5ad096", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,264 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::at::At;\n+use infer::canonical::{Canonical, Canonicalize, QueryResult};\n+use infer::InferOk;\n+use std::iter::FromIterator;\n+use traits::query::CanonicalTyGoal;\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Kind;\n+use std::rc::Rc;\n+\n+impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+    /// Given a type `ty` of some value being dropped, computes a set\n+    /// of \"kinds\" (types, regions) that must be outlive the execution\n+    /// of the destructor. These basically correspond to data that the\n+    /// destructor might access. This is used during regionck to\n+    /// impose \"outlives\" constraints on any lifetimes referenced\n+    /// within.\n+    ///\n+    /// The rules here are given by the \"dropck\" RFCs, notably [#1238]\n+    /// and [#1327]. This is a fixed-point computation, where we\n+    /// explore all the data that will be dropped (transitively) when\n+    /// a value of type `ty` is dropped. For each type T that will be\n+    /// dropped and which has a destructor, we must assume that all\n+    /// the types/regions of T are live during the destructor, unless\n+    /// they are marked with a special attribute (`#[may_dangle]`).\n+    ///\n+    /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+    /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n+    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<Kind<'tcx>>> {\n+        debug!(\n+            \"dropck_outlives(ty={:?}, param_env={:?})\",\n+            ty, self.param_env,\n+        );\n+\n+        // Quick check: there are a number of cases that we know do not require\n+        // any destructor.\n+        let tcx = self.infcx.tcx;\n+        if trivial_dropck_outlives(tcx, ty) {\n+            return InferOk { value: vec![], obligations: vec![] };\n+        }\n+\n+        let gcx = tcx.global_tcx();\n+        let (c_ty, orig_values) = self.infcx.canonicalize_query(&self.param_env.and(ty));\n+        let span = self.cause.span;\n+        match &gcx.dropck_outlives(c_ty) {\n+            Ok(result) if result.is_proven() => {\n+                match self.infcx.instantiate_query_result(\n+                    self.cause,\n+                    self.param_env,\n+                    &orig_values,\n+                    result,\n+                ) {\n+                    Ok(InferOk {\n+                        value: DropckOutlivesResult { kinds, overflows },\n+                        obligations,\n+                    }) => {\n+                        for overflow_ty in overflows.into_iter().take(1) {\n+                            let mut err = struct_span_err!(\n+                                tcx.sess,\n+                                span,\n+                                E0320,\n+                                \"overflow while adding drop-check rules for {}\",\n+                                self.infcx.resolve_type_vars_if_possible(&ty),\n+                            );\n+                            err.note(&format!(\"overflowed on {}\", overflow_ty));\n+                            err.emit();\n+                        }\n+\n+                        return InferOk {\n+                            value: kinds,\n+                            obligations,\n+                        };\n+                    }\n+\n+                    Err(_) => { /* fallthrough to error-handling code below */ }\n+                }\n+            }\n+\n+            _ => { /* fallthrough to error-handling code below */ }\n+        }\n+\n+        // Errors and ambiuity in dropck occur in two cases:\n+        // - unresolved inference variables at the end of typeck\n+        // - non well-formed types where projections cannot be resolved\n+        // Either of these should hvae created an error before.\n+        tcx.sess\n+            .delay_span_bug(span, \"dtorck encountered internal error\");\n+        return InferOk {\n+            value: vec![],\n+            obligations: vec![],\n+        };\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct DropckOutlivesResult<'tcx> {\n+    pub kinds: Vec<Kind<'tcx>>,\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n+\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+\n+    /// If, during the computation of the dtorck constraint, we\n+    /// overflow, that gets recorded here. The caller is expected to\n+    /// report an error.\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    pub fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![],\n+            overflows: vec![],\n+        }\n+    }\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n+    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for DtorckConstraint {\n+            outlives,\n+            dtorck_types,\n+            overflows,\n+        } in iter\n+        {\n+            result.outlives.extend(outlives);\n+            result.dtorck_types.extend(dtorck_types);\n+            result.overflows.extend(overflows);\n+        }\n+\n+        result\n+    }\n+}\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Ty<'tcx>> {\n+    type Canonicalized = CanonicalTyGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for DropckOutlivesResult<'tcx> {\n+        kinds, overflows\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for DropckOutlivesResult<'a> {\n+        type Lifted = DropckOutlivesResult<'tcx>;\n+        kinds, overflows\n+    }\n+}\n+\n+impl_stable_hash_for!(struct DropckOutlivesResult<'tcx> {\n+    kinds, overflows\n+});\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, DropckOutlivesResult<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, DropckOutlivesResult<'gcx>>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        Rc::new(value)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n+    outlives,\n+    dtorck_types,\n+    overflows\n+});\n+\n+/// This returns true if the type `ty` is \"trivial\" for\n+/// dropck-outlives -- that is, if it doesn't require any types to\n+/// outlive. This is similar but not *quite* the same as the\n+/// `needs_drop` test in the compiler already -- that is, for every\n+/// type T for which this function return true, needs-drop would\n+/// return false. But the reverse does not hold: in particular,\n+/// `needs_drop` returns false for `PhantomData`, but it is not\n+/// trivial for dropck-outlives.\n+///\n+/// Note also that `needs_drop` requires a \"global\" type (i.e., one\n+/// with erased regions), but this funtcion does not.\n+fn trivial_dropck_outlives<'cx, 'tcx>(tcx: TyCtxt<'cx, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        // None of these types have a destructor and hence they do not\n+        // require anything in particular to outlive the dtor's\n+        // execution.\n+        ty::TyInfer(ty::FreshIntTy(_))\n+        | ty::TyInfer(ty::FreshFloatTy(_))\n+        | ty::TyBool\n+        | ty::TyInt(_)\n+        | ty::TyUint(_)\n+        | ty::TyFloat(_)\n+        | ty::TyNever\n+        | ty::TyFnDef(..)\n+        | ty::TyFnPtr(_)\n+        | ty::TyChar\n+        | ty::TyGeneratorWitness(..)\n+        | ty::TyRawPtr(_)\n+        | ty::TyRef(..)\n+        | ty::TyStr\n+        | ty::TyForeign(..)\n+        | ty::TyError => true,\n+\n+        // [T; N] and [T] have same properties as T.\n+        ty::TyArray(ty, _) | ty::TySlice(ty) => trivial_dropck_outlives(tcx, ty),\n+\n+        // (T1..Tn) and closures have same properties as T1..Tn --\n+        // check if *any* of those are trivial.\n+        ty::TyTuple(ref tys, _) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n+        ty::TyClosure(def_id, ref substs) => substs\n+            .upvar_tys(def_id, tcx)\n+            .all(|t| trivial_dropck_outlives(tcx, t)),\n+\n+        ty::TyAdt(def, _) => {\n+            if def.is_union() {\n+                // Unions never run have a dtor.\n+                true\n+            } else {\n+                // Other types might. Moreover, PhantomData doesn't\n+                // have a dtor, but it is considered to own its\n+                // content, so it is non-trivial.\n+                false\n+            }\n+        }\n+\n+        // The following *might* require a destructor: it would deeper inspection to tell.\n+        ty::TyDynamic(..)\n+        | ty::TyProjection(..)\n+        | ty::TyParam(_)\n+        | ty::TyAnon(..)\n+        | ty::TyInfer(_)\n+        | ty::TyGenerator(..) => false,\n+    }\n+}"}, {"sha": "f1f9256f825373bca5101446e98f9ca7318292aa", "filename": "src/librustc/traits/query/mod.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental types for the trait query interface. The methods\n+//! defined in this module are all based on **canonicalization**,\n+//! which makes a canonical query by replacing unbound inference\n+//! variables and regions, so that results can be reused more broadly.\n+//! The providers for the queries defined here can be found in\n+//! `librustc_traits`.\n+\n+use infer::canonical::Canonical;\n+use ty::{self, Ty};\n+\n+pub mod dropck_outlives;\n+pub mod normalize;\n+pub mod normalize_erasing_regions;\n+\n+pub type CanonicalProjectionGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+\n+pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct NoSolution;\n+\n+pub type Fallible<T> = Result<T, NoSolution>;\n+\n+impl_stable_hash_for!(struct NoSolution { });"}, {"sha": "70c5cf5f3902934794b497b16a3465d77d1a401f", "filename": "src/librustc/traits/query/normalize.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,274 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for the 'normalization' query. This consists of a wrapper\n+//! which folds deeply, invoking the underlying\n+//! `normalize_projection_ty` query when it encounters projections.\n+\n+use infer::{InferCtxt, InferOk};\n+use infer::at::At;\n+use infer::canonical::{Canonical, Canonicalize, QueryResult};\n+use middle::const_val::ConstVal;\n+use mir::interpret::GlobalId;\n+use std::rc::Rc;\n+use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use traits::query::CanonicalProjectionGoal;\n+use traits::project::Normalized;\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::{Subst, Substs};\n+\n+use super::NoSolution;\n+\n+impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+    /// Normalize `value` in the context of the inference context,\n+    /// yielding a resulting type, or an error if `value` cannot be\n+    /// normalized. If you don't care about regions, you should prefer\n+    /// `normalize_erasing_regions`, which is more efficient.\n+    ///\n+    /// If the normalization succeeds and is unambigious, returns back\n+    /// the normalized value along with various outlives relations (in\n+    /// the form of obligations that must be discharged).\n+    ///\n+    /// NB. This will *eventually* be the main means of\n+    /// normalizing, but for now should be used only when we actually\n+    /// know that normalization will succeed, since error reporting\n+    /// and other details are still \"under development\".\n+    pub fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"normalize::<{}>(value={:?}, param_env={:?})\",\n+            unsafe { ::std::intrinsics::type_name::<T>() },\n+            value,\n+            self.param_env,\n+        );\n+        let mut normalizer = QueryNormalizer {\n+            infcx: self.infcx,\n+            cause: self.cause,\n+            param_env: self.param_env,\n+            obligations: vec![],\n+            error: false,\n+            anon_depth: 0,\n+        };\n+        if !value.has_projections() {\n+            return Ok(Normalized {\n+                value: value.clone(),\n+                obligations: vec![],\n+            });\n+        }\n+\n+        let value1 = value.fold_with(&mut normalizer);\n+        if normalizer.error {\n+            Err(NoSolution)\n+        } else {\n+            Ok(Normalized {\n+                value: value1,\n+                obligations: normalizer.obligations,\n+            })\n+        }\n+    }\n+}\n+\n+/// Result from the `normalize_projection_ty` query.\n+#[derive(Clone, Debug)]\n+pub struct NormalizationResult<'tcx> {\n+    /// Result of normalization.\n+    pub normalized_ty: Ty<'tcx>,\n+}\n+\n+struct QueryNormalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    cause: &'cx ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+    error: bool,\n+    anon_depth: usize,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = ty.super_fold_with(self);\n+        match ty.sty {\n+            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => {\n+                // (*)\n+                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                match self.param_env.reveal {\n+                    Reveal::UserFacing => ty,\n+\n+                    Reveal::All => {\n+                        let recursion_limit = self.tcx().sess.recursion_limit.get();\n+                        if self.anon_depth >= recursion_limit {\n+                            let obligation = Obligation::with_depth(\n+                                self.cause.clone(),\n+                                recursion_limit,\n+                                self.param_env,\n+                                ty,\n+                            );\n+                            self.infcx.report_overflow_error(&obligation, true);\n+                        }\n+\n+                        let generic_ty = self.tcx().type_of(def_id);\n+                        let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                        self.anon_depth += 1;\n+                        let folded_ty = self.fold_ty(concrete_ty);\n+                        self.anon_depth -= 1;\n+                        folded_ty\n+                    }\n+                }\n+            }\n+\n+            ty::TyProjection(ref data) if !data.has_escaping_regions() => {\n+                // (*)\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n+                let gcx = self.infcx.tcx.global_tcx();\n+\n+                let (c_data, orig_values) =\n+                    self.infcx.canonicalize_query(&self.param_env.and(*data));\n+                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n+                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n+                match gcx.normalize_projection_ty(c_data) {\n+                    Ok(result) => {\n+                        // We don't expect ambiguity.\n+                        if result.is_ambiguous() {\n+                            self.error = true;\n+                            return ty;\n+                        }\n+\n+                        match self.infcx.instantiate_query_result(\n+                            self.cause,\n+                            self.param_env,\n+                            &orig_values,\n+                            &result,\n+                        ) {\n+                            Ok(InferOk {\n+                                value: result,\n+                                obligations,\n+                            }) => {\n+                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                                self.obligations.extend(obligations);\n+                                return result.normalized_ty;\n+                            }\n+\n+                            Err(_) => {\n+                                self.error = true;\n+                                return ty;\n+                            }\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => {\n+                        self.error = true;\n+                        ty\n+                    }\n+                }\n+            }\n+\n+            _ => ty,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ConstVal::Unevaluated(def_id, substs) = constant.val {\n+            let tcx = self.infcx.tcx.global_tcx();\n+            if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n+                if substs.needs_infer() {\n+                    let identity_substs = Substs::identity_for_item(tcx, def_id);\n+                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n+                    if let Some(instance) = instance {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match tcx.const_eval(param_env.and(cid)) {\n+                            Ok(evaluated) => {\n+                                let evaluated = evaluated.subst(self.tcx(), substs);\n+                                return self.fold_const(evaluated);\n+                            }\n+                            Err(_) => {}\n+                        }\n+                    }\n+                } else {\n+                    if let Some(substs) = self.tcx().lift_to_global(&substs) {\n+                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n+                        if let Some(instance) = instance {\n+                            let cid = GlobalId {\n+                                instance,\n+                                promoted: None,\n+                            };\n+                            match tcx.const_eval(param_env.and(cid)) {\n+                                Ok(evaluated) => return self.fold_const(evaluated),\n+                                Err(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        constant\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for NormalizationResult<'tcx> {\n+        normalized_ty\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for NormalizationResult<'a> {\n+        type Lifted = NormalizationResult<'tcx>;\n+        normalized_ty\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>> {\n+    type Canonicalized = CanonicalProjectionGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, NormalizationResult<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, NormalizationResult<'gcx>>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        Rc::new(value)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct NormalizationResult<'tcx> {\n+    normalized_ty\n+});"}, {"sha": "a9734e9c2986e0831dd4c1c404e038ea2fa88ae3", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Methods for normalizing when you don't care about regions (and\n+//! aren't doing type inference). If either of those things don't\n+//! apply to you, use `infcx.normalize(...)`.\n+//!\n+//! The methods in this file use a `TypeFolder` to recursively process\n+//! contents, invoking the underlying\n+//! `normalize_ty_after_erasing_regions` query for each type found\n+//! within. (This underlying query is what is cached.)\n+\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+\n+impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n+    /// Erase the regions in `value` and then fully normalize all the\n+    /// types found within. The result will also have regions erased.\n+    ///\n+    /// This is appropriate to use only after type-check: it assumes\n+    /// that normalization will succeed, for example.\n+    pub fn normalize_erasing_regions<T>(self, param_env: ty::ParamEnv<'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"normalize_erasing_regions::<{}>(value={:?}, param_env={:?})\",\n+            unsafe { ::std::intrinsics::type_name::<T>() },\n+            value,\n+            param_env,\n+        );\n+\n+        // Erase first before we do the real query -- this keeps the\n+        // cache from being too polluted.\n+        let value = self.erase_regions(&value);\n+        if !value.has_projections() {\n+            value\n+        } else {\n+            value.fold_with(&mut NormalizeAfterErasingRegionsFolder {\n+                tcx: self,\n+                param_env: param_env,\n+            })\n+        }\n+    }\n+\n+    /// If you have a `Binder<T>`, you can do this to strip out the\n+    /// late-bound regions and then normalize the result, yielding up\n+    /// a `T` (with regions erased). This is appropriate when the\n+    /// binder is being instantiated at the call site.\n+    ///\n+    /// NB. Currently, higher-ranked type bounds inhibit\n+    /// normalization. Therefore, each time we erase them in\n+    /// translation, we need to normalize the contents.\n+    pub fn normalize_erasing_late_bound_regions<T>(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        assert!(!value.needs_subst());\n+        let value = self.erase_late_bound_regions(value);\n+        self.normalize_erasing_regions(param_env, value)\n+    }\n+}\n+\n+struct NormalizeAfterErasingRegionsFolder<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'cx, 'tcx> TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'cx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.tcx.normalize_ty_after_erasing_regions(self.param_env.and(ty))\n+    }\n+}"}, {"sha": "f2f54dcedfd6577c3305762dc238149242f6175a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -777,7 +777,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // value in order to work, so we can clear out the param env and get better\n             // caching. (If the current param env is inconsistent, we don't care what happens).\n             debug!(\"evaluate_trait_predicate_recursively({:?}) - in global\", obligation);\n-            obligation.param_env = ty::ParamEnv::empty(obligation.param_env.reveal);\n+            obligation.param_env = obligation.param_env.without_caller_bounds();\n         }\n \n         let stack = self.push_stack(previous_stack, &obligation);\n@@ -2083,9 +2083,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n             ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n+            ty::TyInfer(ty::FreshTy(_)) |\n+            ty::TyInfer(ty::FreshIntTy(_)) |\n+            ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2154,9 +2155,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ambiguous\n             }\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n+            ty::TyInfer(ty::FreshTy(_)) |\n+            ty::TyInfer(ty::FreshIntTy(_)) |\n+            ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2195,6 +2197,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyParam(..) |\n             ty::TyForeign(..) |\n             ty::TyProjection(..) |\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |"}, {"sha": "5ea089abb8e86ac6be8e413515d73671ab23f737", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n-use traits::{self, Reveal, ObligationCause};\n+use traits::{self, ObligationCause};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n@@ -132,7 +132,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     match ancestors.defs(tcx, item.name, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = ty::ParamEnv::empty(Reveal::All);\n+                let param_env = ty::ParamEnv::reveal_all();\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);"}, {"sha": "a2d98a456f49a0ea39b00b7e2eb7b226208b3bb9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 45, "deletions": 238, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -363,258 +363,65 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n     }\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableImplData {\n-            impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+        impl_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableGeneratorData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n+        closure_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableClosureData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+        closure_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableAutoImplData {\n-            trait_def_id: self.trait_def_id,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n+        trait_def_id, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableBuiltinData {\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+        nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.upcast_trait_ref.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n+        upcast_trait_ref, vtable_base, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::VtableFnPointerData {\n-            fn_ty: self.fn_ty.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.fn_ty.visit_with(visitor) || self.nested.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n+        fn_ty,\n+        nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableAutoImpl(ref t) => traits::VtableAutoImpl(t.fold_with(folder)),\n-            traits::VtableGenerator(ref d) => {\n-                traits::VtableGenerator(d.fold_with(folder))\n-            }\n-            traits::VtableClosure(ref d) => {\n-                traits::VtableClosure(d.fold_with(folder))\n-            }\n-            traits::VtableFnPointer(ref d) => {\n-                traits::VtableFnPointer(d.fold_with(folder))\n-            }\n-            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n-            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n-            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            traits::VtableImpl(ref v) => v.visit_with(visitor),\n-            traits::VtableAutoImpl(ref t) => t.visit_with(visitor),\n-            traits::VtableGenerator(ref d) => d.visit_with(visitor),\n-            traits::VtableClosure(ref d) => d.visit_with(visitor),\n-            traits::VtableFnPointer(ref d) => d.visit_with(visitor),\n-            traits::VtableParam(ref n) => n.visit_with(visitor),\n-            traits::VtableBuiltin(ref d) => d.visit_with(visitor),\n-            traits::VtableObject(ref d) => d.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        Normalized {\n-            value: self.value.fold_with(folder),\n-            obligations: self.obligations.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.value.visit_with(visitor) || self.obligations.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            super::ExprAssignable |\n-            super::MatchExpressionArm { arm_span: _, source: _ } |\n-            super::IfExpression |\n-            super::IfExpressionWithNoElse |\n-            super::MainFunctionType |\n-            super::StartFunctionType |\n-            super::IntrinsicType |\n-            super::MethodReceiver |\n-            super::MiscObligation |\n-            super::SliceOrArrayElem |\n-            super::TupleElem |\n-            super::ItemObligation(_) |\n-            super::AssignmentLhsSized |\n-            super::TupleInitializerSized |\n-            super::StructInitializerSized |\n-            super::VariableType(_) |\n-            super::ReturnType(_) |\n-            super::SizedReturnType |\n-            super::SizedYieldType |\n-            super::ReturnNoExpression |\n-            super::RepeatVec |\n-            super::FieldSized(_) |\n-            super::ConstSized |\n-            super::SharedStatic |\n-            super::BlockTailExpression(_) |\n-            super::CompareImplMethodObligation { .. } => self.clone(),\n-\n-            super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                super::ReferenceOutlivesReferent(ty.fold_with(folder))\n-            }\n-            super::ObjectTypeBound(ty, r) => {\n-                super::ObjectTypeBound(ty.fold_with(folder), r.fold_with(folder))\n-            }\n-            super::ObjectCastObligation(ty) => {\n-                super::ObjectCastObligation(ty.fold_with(folder))\n-            }\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                super::BuiltinDerivedObligation(cause.fold_with(folder))\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                super::ImplDerivedObligation(cause.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            super::ExprAssignable |\n-            super::MatchExpressionArm { arm_span: _, source: _ } |\n-            super::IfExpression |\n-            super::IfExpressionWithNoElse |\n-            super::MainFunctionType |\n-            super::StartFunctionType |\n-            super::IntrinsicType |\n-            super::MethodReceiver |\n-            super::MiscObligation |\n-            super::SliceOrArrayElem |\n-            super::TupleElem |\n-            super::ItemObligation(_) |\n-            super::AssignmentLhsSized |\n-            super::TupleInitializerSized |\n-            super::StructInitializerSized |\n-            super::VariableType(_) |\n-            super::ReturnType(_) |\n-            super::SizedReturnType |\n-            super::SizedYieldType |\n-            super::ReturnNoExpression |\n-            super::RepeatVec |\n-            super::FieldSized(_) |\n-            super::ConstSized |\n-            super::SharedStatic |\n-            super::BlockTailExpression(_) |\n-            super::CompareImplMethodObligation { .. } => false,\n-\n-            super::ProjectionWf(proj) => proj.visit_with(visitor),\n-            super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n-            super::ObjectTypeBound(ty, r) => ty.visit_with(visitor) || r.visit_with(visitor),\n-            super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n-            super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n-            super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::DerivedObligationCause<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::DerivedObligationCause {\n-            parent_trait_ref: self.parent_trait_ref.fold_with(folder),\n-            parent_code: self.parent_code.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.parent_trait_ref.visit_with(visitor) || self.parent_code.visit_with(visitor)\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+        (traits::VtableImpl)(a),\n+        (traits::VtableAutoImpl)(a),\n+        (traits::VtableGenerator)(a),\n+        (traits::VtableClosure)(a),\n+        (traits::VtableFnPointer)(a),\n+        (traits::VtableParam)(a),\n+        (traits::VtableBuiltin)(a),\n+        (traits::VtableObject)(a),\n+    } where N: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code: self.code.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.code.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+        value,\n+        obligations\n+    } where T: TypeFoldable<'tcx>\n }"}, {"sha": "cc8b74e0ee23a3fad3a90288ae5ff918c8dab0bd", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 56, "deletions": 96, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -14,14 +14,14 @@\n // general routines.\n \n use dep_graph::{DepKind, DepTrackingMapConfig};\n-use infer::TransNormalize;\n use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n-use hir::def_id::DefId;\n+use infer::InferCtxt;\n+use syntax_pos::Span;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::TypeFoldable;\n \n /// Attempts to resolve an obligation to a vtable.. The result is\n /// a shallow vtable resolution -- meaning that we do not\n@@ -87,111 +87,29 @@ pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Monomorphizes a type from the AST by first applying the in-scope\n-    /// substitutions and then normalizing any associated types.\n-    pub fn trans_apply_param_substs<T>(self,\n-                                       param_substs: &Substs<'tcx>,\n-                                       value: &T)\n-                                       -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n-        let substituted = value.subst(self, param_substs);\n-        let substituted = self.erase_regions(&substituted);\n-        AssociatedTypeNormalizer::new(self).fold(&substituted)\n-    }\n-\n-    pub fn trans_apply_param_substs_env<T>(\n+    /// Monomorphizes a type from the AST by first applying the\n+    /// in-scope substitutions and then normalizing any associated\n+    /// types.\n+    pub fn subst_and_normalize_erasing_regions<T>(\n         self,\n         param_substs: &Substs<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n+        value: &T\n     ) -> T\n     where\n-        T: TransNormalize<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"apply_param_substs_env(param_substs={:?}, value={:?}, param_env={:?})\",\n+            \"subst_and_normalize_erasing_regions(\\\n+             param_substs={:?}, \\\n+             value={:?}, \\\n+             param_env={:?})\",\n             param_substs,\n             value,\n             param_env,\n         );\n         let substituted = value.subst(self, param_substs);\n-        let substituted = self.erase_regions(&substituted);\n-        AssociatedTypeNormalizerEnv::new(self, param_env).fold(&substituted)\n-    }\n-\n-    pub fn trans_impl_self_ty(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n-                              -> Ty<'tcx>\n-    {\n-        self.trans_apply_param_substs(substs, &self.type_of(def_id))\n-    }\n-}\n-\n-struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-}\n-\n-impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n-        AssociatedTypeNormalizer { tcx }\n-    }\n-\n-    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projections() {\n-            value.clone()\n-        } else {\n-            value.fold_with(self)\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projections() {\n-            ty\n-        } else {\n-            debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-            self.tcx.fully_normalize_monormophic_ty(ty)\n-        }\n-    }\n-}\n-\n-struct AssociatedTypeNormalizerEnv<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    param_env: ty::ParamEnv<'gcx>,\n-}\n-\n-impl<'a, 'gcx> AssociatedTypeNormalizerEnv<'a, 'gcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>, param_env: ty::ParamEnv<'gcx>) -> Self {\n-        Self { tcx, param_env }\n-    }\n-\n-    fn fold<T: TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projections() {\n-            value.clone()\n-        } else {\n-            value.fold_with(self)\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizerEnv<'a, 'gcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projections() {\n-            ty\n-        } else {\n-            debug!(\"AssociatedTypeNormalizerEnv: ty={:?}\", ty);\n-            self.tcx.normalize_associated_type_in_env(&ty, self.param_env)\n-        }\n+        self.normalize_erasing_regions(param_env, substituted)\n     }\n }\n \n@@ -221,3 +139,45 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n         DepKind::TraitSelect\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// Finishes processes any obligations that remain in the\n+    /// fulfillment context, and then returns the result with all type\n+    /// variables removed and regions erased. Because this is intended\n+    /// for use after type-check has completed, if any errors occur,\n+    /// it will panic. It is used during normalization and other cases\n+    /// where processing the obligations in `fulfill_cx` may cause\n+    /// type inference variables that appear in `result` to be\n+    /// unified, and hence we need to process those obligations to get\n+    /// the complete picture of the type.\n+    fn drain_fulfillment_cx_or_panic<T>(&self,\n+                                        span: Span,\n+                                        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+                                        result: &T)\n+                                        -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        debug!(\"drain_fulfillment_cx_or_panic()\");\n+\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => { }\n+            Err(errors) => {\n+                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                          errors);\n+            }\n+        }\n+\n+        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.tcx.erase_regions(&result);\n+\n+        match self.tcx.lift_to_global(&result) {\n+            Some(result) => result,\n+            None => {\n+                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n+            }\n+        }\n+    }\n+}"}, {"sha": "9a687028b582c3ed9c93c04fc9a3993e0d042086", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -23,6 +23,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n use middle::const_val::ConstVal;\n use middle::cstore::{CrateStore, LinkMeta};\n@@ -131,6 +132,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    canonical_var_infos: RefCell<FxHashSet<Interned<'tcx, Slice<CanonicalVarInfo>>>>,\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n@@ -146,6 +148,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             substs: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n+            canonical_var_infos: RefCell::new(FxHashSet()),\n             predicates: RefCell::new(FxHashSet()),\n             const_: RefCell::new(FxHashSet()),\n         }\n@@ -1508,7 +1511,7 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n /// pointer differs. The latter case is possible if a primitive type,\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx> {\n-    type Lifted;\n+    type Lifted: 'tcx;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n@@ -1838,6 +1841,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, Slice<CanonicalVarInfo>> {\n+    fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n+        &self.0[..]\n+    }\n+}\n+\n impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n         &self.0[..]\n@@ -1970,6 +1979,22 @@ slice_interners!(\n     substs: _intern_substs(Kind)\n );\n \n+// This isn't a perfect fit: CanonicalVarInfo slices are always\n+// allocated in the global arena, so this `intern_method!` macro is\n+// overly general.  But we just return false for the code that checks\n+// whether they belong in the thread-local arena, so no harm done, and\n+// seems better than open-coding the rest.\n+intern_method! {\n+    'tcx,\n+    canonical_var_infos: _intern_canonical_var_infos(\n+        &[CanonicalVarInfo],\n+        alloc_slice,\n+        Deref::deref,\n+        |xs: &[CanonicalVarInfo]| -> &Slice<CanonicalVarInfo> { unsafe { mem::transmute(xs) } },\n+        |_xs: &[CanonicalVarInfo]| -> bool { false }\n+    ) -> Slice<CanonicalVarInfo>\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being\n@@ -2257,6 +2282,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n+        if ts.len() == 0 {\n+            Slice::empty()\n+        } else {\n+            self.global_tcx()._intern_canonical_var_infos(ts)\n+        }\n+    }\n+\n     pub fn mk_fn_sig<I>(self,\n                         inputs: I,\n                         output: I::Item,\n@@ -2504,9 +2537,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.features().clone_closures\n     };\n-    providers.fully_normalize_monormophic_ty = |tcx, ty| {\n-        tcx.fully_normalize_associated_types_in(&ty)\n-    };\n     providers.features_query = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(tcx.sess.features_untracked().clone())"}, {"sha": "8a0253ed2f1156e1a065a0017bfa015b25743af3", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -220,6 +220,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n             ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n             ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n             ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n             ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),"}, {"sha": "cae64fd4c95c67ab80cb09dbd97ea76cda8b4831", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -112,8 +112,16 @@ impl FlagComputation {\n                 match infer {\n                     ty::FreshTy(_) |\n                     ty::FreshIntTy(_) |\n-                    ty::FreshFloatTy(_) => {}\n-                    _ => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                    ty::FreshFloatTy(_) |\n+                    ty::CanonicalTy(_) => {\n+                        self.add_flags(TypeFlags::HAS_CANONICAL_VARS);\n+                    }\n+\n+                    ty::TyVar(_) |\n+                    ty::IntVar(_) |\n+                    ty::FloatVar(_) => {\n+                        self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                    }\n                 }\n             }\n "}, {"sha": "8071cd0c639da6b8a3dec899d13b7dd9853b94ab", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -49,6 +49,9 @@ use util::nodemap::FxHashSet;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n+///\n+/// To implement this conveniently, use the\n+/// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self;\n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "76f7a0b59a2a568352ee86726154598e2a21d76b", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -51,7 +51,11 @@ impl<'a, 'tcx> Instance<'tcx> {\n               -> Ty<'tcx>\n     {\n         let ty = tcx.type_of(self.def.def_id());\n-        tcx.trans_apply_param_substs(self.substs, &ty)\n+        tcx.subst_and_normalize_erasing_regions(\n+            self.substs,\n+            ty::ParamEnv::reveal_all(),\n+            &ty,\n+        )\n     }\n }\n \n@@ -184,7 +188,11 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n             resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n         } else {\n             let ty = tcx.type_of(def_id);\n-            let item_type = tcx.trans_apply_param_substs_env(substs, param_env, &ty);\n+            let item_type = tcx.subst_and_normalize_erasing_regions(\n+                substs,\n+                param_env,\n+                &ty,\n+            );\n \n             let def = match item_type.sty {\n                 ty::TyFnDef(..) if {\n@@ -199,7 +207,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n                 _ => {\n                     if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n                         let ty = substs.type_at(0);\n-                        if ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All)) {\n+                        if ty.needs_drop(tcx, ty::ParamEnv::reveal_all()) {\n                             debug!(\" => nontrivial drop glue\");\n                             ty::InstanceDef::DropGlue(def_id, Some(ty))\n                         } else {\n@@ -352,7 +360,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n         closure_did, substs);\n \n     let sig = substs.closure_sig(closure_did, tcx);\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([Kind::from(self_ty), sig.inputs()[0].into()].iter().cloned());\n "}, {"sha": "04353d2ece192dcdef6bd2da93021758d7dc67dd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -1213,7 +1213,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     data_ptr.valid_range.start = 1;\n                 }\n \n-                let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n+                let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n                 if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n                     return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             // Arrays and slices.\n             ty::TyArray(element, mut count) => {\n                 if count.has_projections() {\n-                    count = tcx.normalize_associated_type_in_env(&count, param_env);\n+                    count = tcx.normalize_erasing_regions(param_env, count);\n                     if count.has_projections() {\n                         return Err(LayoutError::Unknown(ty));\n                     }\n@@ -1686,7 +1686,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n+                let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n@@ -1953,7 +1953,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n+                let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n                 } else {\n@@ -2058,8 +2058,8 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        let param_env = self.param_env.reveal_all();\n-        let ty = self.tcx.normalize_associated_type_in_env(&ty, param_env);\n+        let param_env = self.param_env.with_reveal_all();\n+        let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let details = self.tcx.layout_raw(param_env.and(ty))?;\n         let layout = TyLayout {\n             ty,\n@@ -2084,9 +2084,9 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for LayoutCx<'tcx, ty::maps::TyCtxtAt<'a, 'tcx\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        let param_env = self.param_env.reveal_all();\n-        let ty = self.tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n-        let details = self.tcx.layout_raw(param_env.reveal_all().and(ty))?;\n+        let param_env = self.param_env.with_reveal_all();\n+        let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n+        let details = self.tcx.layout_raw(param_env.and(ty))?;\n         let layout = TyLayout {\n             ty,\n             details"}, {"sha": "dbfe7770bbde03c2158cf75111675ae6eec86265", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -11,7 +11,8 @@\n use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n-use ty::{self, Ty, TyCtxt};\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n+use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n \n@@ -51,6 +52,27 @@ impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt,\n+        goal: CanonicalProjectionGoal<'tcx>,\n+    ) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n+        format!(\"computing dropck types for `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_regions<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)\n@@ -588,12 +610,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::has_copy_closures<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::fully_normalize_monormophic_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: Ty) -> String {\n-        format!(\"normalizing types\")\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up enabled feature gates\")"}, {"sha": "b8167ec918638be880a6bc0351e98c105208dd01", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -11,6 +11,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -170,3 +171,23 @@ impl Key for InternedString {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for CanonicalProjectionGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl<'tcx> Key for CanonicalTyGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "7d726d2e3cd5dfc989411085b788fd45670c486d", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n+use infer::canonical::{Canonical, QueryResult};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n@@ -33,8 +34,11 @@ use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::Vtable;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n+use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n+use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n-use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n@@ -111,7 +115,9 @@ define_maps! { <'tcx>\n     [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n     [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] fn adt_dtorck_constraint: DtorckConstraint(\n+        DefId\n+    ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n \n     /// True if this is a const fn\n     [] fn is_const_fn: IsConstFn(DefId) -> bool,\n@@ -378,7 +384,27 @@ define_maps! { <'tcx>\n     // Normally you would just use `tcx.erase_regions(&value)`,\n     // however, which uses this query as a kind of cache.\n     [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n-    [] fn fully_normalize_monormophic_ty: normalize_ty_node(Ty<'tcx>) -> Ty<'tcx>,\n+\n+    /// Do not call this query directly: invoke `normalize` instead.\n+    [] fn normalize_projection_ty: NormalizeProjectionTy(\n+        CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n+    [] fn normalize_ty_after_erasing_regions: NormalizeTyAfterErasingRegions(\n+        ParamEnvAnd<'tcx, Ty<'tcx>>\n+    ) -> Ty<'tcx>,\n+\n+    /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n+    [] fn dropck_outlives: DropckOutlives(\n+        CanonicalTyGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+        NoSolution,\n+    >,\n \n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n@@ -537,9 +563,6 @@ fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::VtableMethods{ trait_ref }\n }\n-fn normalize_ty_node<'tcx>(_: Ty<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::NormalizeTy\n-}\n \n fn substitute_normalize_and_test_predicates_node<'tcx>(key: (DefId, &'tcx Substs<'tcx>))\n                                             -> DepConstructor<'tcx> {"}, {"sha": "bc7186f781a82498053208d8ca352be178276306", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -772,7 +772,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::FulfillObligation |\n         DepKind::VtableMethods |\n         DepKind::EraseRegionsTy |\n-        DepKind::NormalizeTy |\n+        DepKind::NormalizeProjectionTy |\n+        DepKind::NormalizeTyAfterErasingRegions |\n+        DepKind::DropckOutlives |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n "}, {"sha": "8d38d7dbbbbff6e3594f0319a727f991197a06ea", "filename": "src/librustc/ty/maps/values.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -35,12 +35,6 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        Self::empty()\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }"}, {"sha": "fc1d26b0e09100e665d14406012f27b8e1fbb9f5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 80, "deletions": 104, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -29,20 +29,18 @@ use mir::Mir;\n use mir::interpret::{GlobalId, Value, PrimVal};\n use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n-use traits;\n+use traits::{self, Reveal};\n use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n-use util::common::ErrorReported;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::iter::FromIterator;\n use std::ops::Deref;\n use rustc_data_structures::sync::Lrc;\n use std::slice;\n@@ -60,7 +58,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n \n use hir;\n \n-pub use self::sty::{Binder, DebruijnIndex};\n+pub use self::sty::{Binder, CanonicalVar, DebruijnIndex};\n pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n@@ -452,6 +450,10 @@ bitflags! {\n         // Currently we can't normalize projections w/ bound regions.\n         const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n \n+        // Set if this includes a \"canonical\" type or region var --\n+        // ought to be true only for the results of canonicalization.\n+        const HAS_CANONICAL_VARS = 1 << 13;\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -470,7 +472,8 @@ bitflags! {\n                                   TypeFlags::HAS_PROJECTION.bits |\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n                                   TypeFlags::HAS_LOCAL_NAMES.bits |\n-                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits;\n+                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n+                                  TypeFlags::HAS_CANONICAL_VARS.bits;\n     }\n }\n \n@@ -1396,32 +1399,81 @@ pub struct ParamEnv<'tcx> {\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n+    /// Construct a trait environment suitable for contexts where\n+    /// there are no where clauses in scope. Hidden types (like `impl\n+    /// Trait`) are left hidden, so this is suitable for ordinary\n+    /// type-checking.\n+    pub fn empty() -> Self {\n+        Self::new(ty::Slice::empty(), Reveal::UserFacing, ty::UniverseIndex::ROOT)\n+    }\n+\n+    /// Construct a trait environment with no where clauses in scope\n+    /// where the values of all `impl Trait` and other hidden types\n+    /// are revealed. This is suitable for monomorphized, post-typeck\n+    /// environments like trans or doing optimizations.\n+    ///\n+    /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// or invoke `param_env.with_reveal_all()`.\n+    pub fn reveal_all() -> Self {\n+        Self::new(ty::Slice::empty(), Reveal::All, ty::UniverseIndex::ROOT)\n+    }\n+\n+    /// Construct a trait environment with the given set of predicates.\n+    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n+               reveal: Reveal,\n+               universe: ty::UniverseIndex)\n+               -> Self {\n+        ty::ParamEnv { caller_bounds, reveal, universe }\n+    }\n+\n+    /// Returns a new parameter environment with the same clauses, but\n+    /// which \"reveals\" the true results of projections in all cases\n+    /// (even for associated types that are specializable).  This is\n+    /// the desired behavior during trans and certain other special\n+    /// contexts; normally though we want to use `Reveal::UserFacing`,\n+    /// which is the default.\n+    pub fn with_reveal_all(self) -> Self {\n+        ty::ParamEnv { reveal: Reveal::All, ..self }\n+    }\n+\n+    /// Returns this same environment but with no caller bounds.\n+    pub fn without_caller_bounds(self) -> Self {\n+        ty::ParamEnv { caller_bounds: ty::Slice::empty(), ..self }\n+    }\n+\n     /// Creates a suitable environment in which to perform trait\n-    /// queries on the given value. This will either be `self` *or*\n-    /// the empty environment, depending on whether `value` references\n-    /// type parameters that are in scope. (If it doesn't, then any\n-    /// judgements should be completely independent of the context,\n-    /// and hence we can safely use the empty environment so as to\n-    /// enable more sharing across functions.)\n+    /// queries on the given value. When type-checking, this is simply\n+    /// the pair of the environment plus value. But when reveal is set to\n+    /// All, then if `value` does not reference any type parameters, we will\n+    /// pair it with the empty environment. This improves caching and is generally\n+    /// invisible.\n     ///\n-    /// NB: This is a mildly dubious thing to do, in that a function\n-    /// (or other environment) might have wacky where-clauses like\n+    /// NB: We preserve the environment when type-checking because it\n+    /// is possible for the user to have wacky where-clauses like\n     /// `where Box<u32>: Copy`, which are clearly never\n-    /// satisfiable. The code will at present ignore these,\n-    /// effectively, when type-checking the body of said\n-    /// function. This preserves existing behavior in any\n-    /// case. --nmatsakis\n+    /// satisfiable. We generally want to behave as if they were true,\n+    /// although the surrounding function is never reachable.\n     pub fn and<T: TypeFoldable<'tcx>>(self, value: T) -> ParamEnvAnd<'tcx, T> {\n-        assert!(!value.needs_infer());\n-        if value.has_param_types() || value.has_self_ty() {\n-            ParamEnvAnd {\n-                param_env: self,\n-                value,\n+        match self.reveal {\n+            Reveal::UserFacing => {\n+                ParamEnvAnd {\n+                    param_env: self,\n+                    value,\n+                }\n             }\n-        } else {\n-            ParamEnvAnd {\n-                param_env: ParamEnv::empty(self.reveal),\n-                value,\n+\n+            Reveal::All => {\n+                if value.needs_infer() || value.has_param_types() || value.has_self_ty() {\n+                    ParamEnvAnd {\n+                        param_env: self,\n+                        value,\n+                    }\n+                } else {\n+                    ParamEnvAnd {\n+                        param_env: self.without_caller_bounds(),\n+                        value,\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1829,7 +1881,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         expr_did: DefId,\n     ) -> Option<Discr<'tcx>> {\n-        let param_env = ParamEnv::empty(traits::Reveal::UserFacing);\n+        let param_env = ParamEnv::empty();\n         let repr_type = self.repr.discr_type();\n         let bit_size = layout::Integer::from_attr(tcx, repr_type).size().bits();\n         let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n@@ -2607,38 +2659,6 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-/// Calculates the dtorck constraint for a type.\n-fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> DtorckConstraint<'tcx> {\n-    let def = tcx.adt_def(def_id);\n-    let span = tcx.def_span(def_id);\n-    debug!(\"dtorck_constraint: {:?}\", def);\n-\n-    if def.is_phantom_data() {\n-        let result = DtorckConstraint {\n-            outlives: vec![],\n-            dtorck_types: vec![\n-                tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])\n-           ]\n-        };\n-        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n-        return result;\n-    }\n-\n-    let mut result = def.all_fields()\n-        .map(|field| tcx.type_of(field.did))\n-        .map(|fty| tcx.dtorck_constraint_for_ty(span, fty, 0, fty))\n-        .collect::<Result<DtorckConstraint, ErrorReported>>()\n-        .unwrap_or(DtorckConstraint::empty());\n-    result.outlives.extend(tcx.destructor_constraints(def));\n-    result.dedup();\n-\n-    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n-\n-    result\n-}\n-\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Lrc<Vec<DefId>> {\n@@ -2754,7 +2774,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,\n-        adt_dtorck_constraint,\n         def_span,\n         param_env,\n         trait_of_item,\n@@ -2777,49 +2796,6 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }\n \n-/// A set of constraints that need to be satisfied in order for\n-/// a type to be valid for destruction.\n-#[derive(Clone, Debug)]\n-pub struct DtorckConstraint<'tcx> {\n-    /// Types that are required to be alive in order for this\n-    /// type to be valid for destruction.\n-    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n-    /// Types that could not be resolved: projections and params.\n-    pub dtorck_types: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx>\n-{\n-    fn from_iter<I: IntoIterator<Item=DtorckConstraint<'tcx>>>(iter: I) -> Self {\n-        let mut result = Self::empty();\n-\n-        for constraint in iter {\n-            result.outlives.extend(constraint.outlives);\n-            result.dtorck_types.extend(constraint.dtorck_types);\n-        }\n-\n-        result\n-    }\n-}\n-\n-\n-impl<'tcx> DtorckConstraint<'tcx> {\n-    fn empty() -> DtorckConstraint<'tcx> {\n-        DtorckConstraint {\n-            outlives: vec![],\n-            dtorck_types: vec![]\n-        }\n-    }\n-\n-    fn dedup<'a>(&mut self) {\n-        let mut outlives = FxHashSet();\n-        let mut dtorck_types = FxHashSet();\n-\n-        self.outlives.retain(|&val| outlives.replace(val).is_none());\n-        self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have"}, {"sha": "72e7d16b64dcec2da31f3930c3e0b23eb7112107", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -15,10 +15,8 @@\n \n use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n-use traits::Reveal;\n-use ty::subst::{UnpackedKind, Substs};\n+use ty::subst::{Kind, UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n use mir::interpret::{GlobalId, Value, PrimVal};\n use util::common::ErrorReported;\n@@ -143,15 +141,7 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        match (a.unpack(), b.unpack()) {\n-            (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n-                Ok(relation.relate_with_variance(variance, &a_lt, &b_lt)?.into())\n-            }\n-            (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n-                Ok(relation.relate_with_variance(variance, &a_ty, &b_ty)?.into())\n-            }\n-            (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => bug!()\n-        }\n+        relation.relate_with_variance(variance, a, b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -326,13 +316,9 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n #[derive(Debug, Clone)]\n struct GeneratorWitness<'tcx>(&'tcx ty::Slice<Ty<'tcx>>);\n \n-impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        GeneratorWitness(self.0.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor)\n+TupleStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n+        a\n     }\n }\n \n@@ -486,7 +472,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                     ConstVal::Value(Value::ByVal(prim)) => Ok(prim.to_u64().unwrap()),\n                     ConstVal::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n-                        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                        let param_env = ty::ParamEnv::empty();\n                         match tcx.lift_to_global(&substs) {\n                             Some(substs) => {\n                                 let instance = ty::Instance::resolve(\n@@ -698,6 +684,27 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &Kind<'tcx>,\n+        b: &Kind<'tcx>\n+    ) -> RelateResult<'tcx, Kind<'tcx>>\n+    where\n+        R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a,\n+    {\n+        match (a.unpack(), b.unpack()) {\n+            (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n+                Ok(relation.relate(&a_lt, &b_lt)?.into())\n+            }\n+            (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n+                Ok(relation.relate(&a_ty, &b_ty)?.into())\n+            }\n+            (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => bug!()\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n "}, {"sha": "0627bcdfb0ec1a863c6cbd697fe5754c9619399a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 127, "deletions": 414, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -28,153 +28,37 @@ use std::rc::Rc;\n // For things that don't carry any arena-allocated data (and are\n // copy...), just add them to this list.\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty,)+) => {\n-        $(\n-            impl<'tcx> Lift<'tcx> for $ty {\n-                type Lifted = Self;\n-                fn lift_to_tcx<'a, 'gcx>(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self> {\n-                    Some(*self)\n-                }\n-            }\n-\n-            impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n-                    *self\n-                }\n-\n-                fn super_visit_with<F: TypeVisitor<'tcx>>(&self, _: &mut F) -> bool {\n-                    false\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CopyImpls! {\n+CloneTypeFoldableAndLiftImpls! {\n     (),\n+    bool,\n+    usize,\n+    u64,\n+    ::middle::region::Scope,\n+    ::syntax::ast::FloatTy,\n+    ::syntax::ast::NodeId,\n+    ::syntax_pos::symbol::Symbol,\n+    ::hir::def::Def,\n+    ::hir::def_id::DefId,\n+    ::hir::InlineAsm,\n+    ::hir::MatchSource,\n+    ::hir::Mutability,\n     ::hir::Unsafety,\n     ::syntax::abi::Abi,\n-    ::hir::def_id::DefId,\n     ::mir::Local,\n     ::mir::Promoted,\n     ::traits::Reveal,\n+    ::ty::adjustment::AutoBorrowMutability,\n+    ::ty::AdtKind,\n+    // Including `BoundRegion` is a *bit* dubious, but direct\n+    // references to bound region appear in `ty::Error`, and aren't\n+    // really meant to be folded. In general, we can only fold a fully\n+    // general `Region`.\n+    ::ty::BoundRegion,\n+    ::ty::ClosureKind,\n+    ::ty::IntVarValue,\n     ::syntax_pos::Span,\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Macros\n-//\n-// When possible, use one of these (relatively) convenient macros to write\n-// the impls for you.\n-\n-#[macro_export]\n-macro_rules! BraceStructLiftImpl {\n-    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n-        type Lifted = $lifted:ty;\n-        $($field:ident),* $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            type Lifted = $lifted;\n-\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                $(let $field = tcx.lift(&self.$field)?;)*\n-                Some(Self::Lifted { $($field),* })\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! EnumLiftImpl {\n-    (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n-        type Lifted = $lifted:ty;\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            type Lifted = $lifted;\n-\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n-                    })*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! BraceStructTypeFoldableImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($field:ident),* $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n-                &self,\n-                folder: &mut V,\n-            ) -> Self {\n-                let $s { $($field,)* } = self;\n-                $s { $($field: $field.fold_with(folder),)* }\n-            }\n-\n-            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> bool {\n-                let $s { $($field,)* } = self;\n-                false $(|| $field.visit_with(visitor))*\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! EnumTypeFoldableImpl {\n-    (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n-    } $(where $($wc:tt)*)*) => {\n-        impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n-            $(where $($wc)*)*\n-        {\n-            fn super_fold_with<'gcx: $tcx, V: $crate::ty::fold::TypeFolder<'gcx, $tcx>>(\n-                &self,\n-                folder: &mut V,\n-            ) -> Self {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        $variant ( $($variant_arg.fold_with(folder)),* )\n-                    })*\n-                }\n-            }\n-\n-            fn super_visit_with<V: $crate::ty::fold::TypeVisitor<$tcx>>(\n-                &self,\n-                visitor: &mut V,\n-            ) -> bool {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        false $(|| $variant_arg.visit_with(visitor))*\n-                    })*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n@@ -776,6 +660,17 @@ BraceStructLiftImpl! {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n+/// AdtDefs are basically the same as a DefId.\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n@@ -786,14 +681,11 @@ impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Option<T> {\n+        (Some)(a),\n+        (None),\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n@@ -881,22 +773,11 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self  {\n-        use ty::ExistentialPredicate::*;\n-        match *self {\n-            Trait(ref tr) => Trait(tr.fold_with(folder)),\n-            Projection(ref p) => Projection(p.fold_with(folder)),\n-            AutoTrait(did) => AutoTrait(did),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::ExistentialPredicate::Trait(ref tr) => tr.visit_with(visitor),\n-            ty::ExistentialPredicate::Projection(ref p) => p.visit_with(visitor),\n-            ty::ExistentialPredicate::AutoTrait(_) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n+        (ty::ExistentialPredicate::Trait)(a),\n+        (ty::ExistentialPredicate::Projection)(a),\n+        (ty::ExistentialPredicate::AutoTrait)(a),\n     }\n }\n \n@@ -1049,13 +930,9 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n+        ty, mutbl\n     }\n }\n \n@@ -1065,20 +942,9 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let inputs_and_output = self.inputs_and_output.fold_with(folder);\n-        ty::FnSig {\n-            inputs_and_output: folder.tcx().intern_type_list(&inputs_and_output),\n-            variadic: self.variadic,\n-            unsafety: self.unsafety,\n-            abi: self.abi,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.inputs().iter().any(|i| i.visit_with(visitor)) ||\n-        self.output().visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+        inputs_and_output, variadic, unsafety, abi\n     }\n }\n \n@@ -1117,28 +983,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ClosureSubsts {\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+        substs,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GeneratorInterior {\n-           witness: self.witness.fold_with(folder),\n-           movable: self.movable,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.witness.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n+        witness, movable,\n     }\n }\n \n@@ -1149,74 +1002,32 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => self.clone(),\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                ty::adjustment::Adjust::Deref(overloaded.fold_with(folder))\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                ty::adjustment::Adjust::Borrow(autoref.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => false,\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                overloaded.visit_with(visitor)\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                autoref.visit_with(visitor)\n-            }\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n+        (ty::adjustment::Adjust::NeverToAny),\n+        (ty::adjustment::Adjust::ReifyFnPointer),\n+        (ty::adjustment::Adjust::UnsafeFnPointer),\n+        (ty::adjustment::Adjust::ClosureFnPointer),\n+        (ty::adjustment::Adjust::MutToConstPointer),\n+        (ty::adjustment::Adjust::Unsize),\n+        (ty::adjustment::Adjust::Deref)(a),\n+        (ty::adjustment::Adjust::Borrow)(a),\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::adjustment::OverloadedDeref {\n-            region: self.region.fold_with(folder),\n-            mutbl: self.mutbl,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.region.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n+        region, mutbl,\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n-                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n+        (ty::adjustment::AutoBorrow::Ref)(a, b),\n+        (ty::adjustment::AutoBorrow::RawPtr)(m),\n     }\n }\n \n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n         parent, predicates\n@@ -1234,43 +1045,17 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::Predicate::Trait(ref a) =>\n-                ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Subtype(ref binder) =>\n-                ty::Predicate::Subtype(binder.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref binder) =>\n-                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref binder) =>\n-                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n-            ty::Predicate::Projection(ref binder) =>\n-                ty::Predicate::Projection(binder.fold_with(folder)),\n-            ty::Predicate::WellFormed(data) =>\n-                ty::Predicate::WellFormed(data.fold_with(folder)),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) =>\n-                ty::Predicate::ClosureKind(closure_def_id, closure_substs.fold_with(folder), kind),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::Predicate::ObjectSafe(trait_def_id),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) =>\n-                ty::Predicate::ConstEvaluatable(def_id, substs.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n-            ty::Predicate::Subtype(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::Projection(ref binder) => binder.visit_with(visitor),\n-            ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n-            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) =>\n-                closure_substs.visit_with(visitor),\n-            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n-            ty::Predicate::ConstEvaluatable(_def_id, substs) => substs.visit_with(visitor),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+        (ty::Predicate::Trait)(a),\n+        (ty::Predicate::Subtype)(a),\n+        (ty::Predicate::RegionOutlives)(a),\n+        (ty::Predicate::TypeOutlives)(a),\n+        (ty::Predicate::Projection)(a),\n+        (ty::Predicate::WellFormed)(a),\n+        (ty::Predicate::ClosureKind)(a, b, c),\n+        (ty::Predicate::ObjectSafe)(a),\n+        (ty::Predicate::ConstEvaluatable)(a, b),\n     }\n }\n \n@@ -1298,71 +1083,40 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::SubtypePredicate {\n-            a_is_expected: self.a_is_expected,\n-            a: self.a.fold_with(folder),\n-            b: self.b.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.a.visit_with(visitor) || self.b.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ty::ParamEnvAnd<'tcx, T> {\n+        param_env, value\n+    } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitPredicate {\n-            trait_ref: self.trait_ref.fold_with(folder)\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.trait_ref.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n+        a_is_expected, a, b\n     }\n }\n \n-impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : TypeFoldable<'tcx>,\n-          U : TypeFoldable<'tcx>,\n-{\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::OutlivesPredicate(self.0.fold_with(folder),\n-                              self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+        trait_ref\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ClosureUpvar {\n-            def: self.def,\n-            span: self.span,\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.ty.visit_with(visitor)\n-    }\n+TupleStructTypeFoldableImpl! {\n+    impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U> {\n+        a, b\n+    } where T : TypeFoldable<'tcx>, U : TypeFoldable<'tcx>,\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::error::ExpectedFound {\n-            expected: self.expected.fold_with(folder),\n-            found: self.found.fold_with(folder),\n-        }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+        def, span, ty\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.expected.visit_with(visitor) || self.found.visit_with(visitor)\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n+        expected, found\n+    } where T: TypeFoldable<'tcx>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n@@ -1375,69 +1129,28 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use ty::error::TypeError::*;\n-\n-        match *self {\n-            Mismatch => Mismatch,\n-            UnsafetyMismatch(x) => UnsafetyMismatch(x.fold_with(folder)),\n-            AbiMismatch(x) => AbiMismatch(x.fold_with(folder)),\n-            Mutability => Mutability,\n-            TupleSize(x) => TupleSize(x),\n-            FixedArraySize(x) => FixedArraySize(x),\n-            ArgCount => ArgCount,\n-            RegionsDoesNotOutlive(a, b) => {\n-                RegionsDoesNotOutlive(a.fold_with(folder), b.fold_with(folder))\n-            },\n-            RegionsInsufficientlyPolymorphic(a, b) => {\n-                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n-            },\n-            RegionsOverlyPolymorphic(a, b) => {\n-                RegionsOverlyPolymorphic(a, b.fold_with(folder))\n-            },\n-            IntMismatch(x) => IntMismatch(x),\n-            FloatMismatch(x) => FloatMismatch(x),\n-            Traits(x) => Traits(x),\n-            VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => CyclicTy(t.fold_with(folder)),\n-            ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n-            Sorts(x) => Sorts(x.fold_with(folder)),\n-            ExistentialMismatch(x) => ExistentialMismatch(x.fold_with(folder)),\n-            OldStyleLUB(ref x) => OldStyleLUB(x.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use ty::error::TypeError::*;\n-\n-        match *self {\n-            UnsafetyMismatch(x) => x.visit_with(visitor),\n-            AbiMismatch(x) => x.visit_with(visitor),\n-            RegionsDoesNotOutlive(a, b) => {\n-                a.visit_with(visitor) || b.visit_with(visitor)\n-            },\n-            RegionsInsufficientlyPolymorphic(_, b) |\n-            RegionsOverlyPolymorphic(_, b) => {\n-                b.visit_with(visitor)\n-            },\n-            Sorts(x) => x.visit_with(visitor),\n-            OldStyleLUB(ref x) => x.visit_with(visitor),\n-            ExistentialMismatch(x) => x.visit_with(visitor),\n-            CyclicTy(t) => t.visit_with(visitor),\n-            Mismatch |\n-            Mutability |\n-            TupleSize(_) |\n-            FixedArraySize(_) |\n-            ArgCount |\n-            IntMismatch(_) |\n-            FloatMismatch(_) |\n-            Traits(_) |\n-            VariadicMismatch(_) |\n-            ProjectionMismatched(_) |\n-            ProjectionBoundsLength(_) => false,\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n+        (ty::error::TypeError::Mismatch),\n+        (ty::error::TypeError::UnsafetyMismatch)(x),\n+        (ty::error::TypeError::AbiMismatch)(x),\n+        (ty::error::TypeError::Mutability),\n+        (ty::error::TypeError::TupleSize)(x),\n+        (ty::error::TypeError::FixedArraySize)(x),\n+        (ty::error::TypeError::ArgCount),\n+        (ty::error::TypeError::RegionsDoesNotOutlive)(a, b),\n+        (ty::error::TypeError::RegionsInsufficientlyPolymorphic)(a, b),\n+        (ty::error::TypeError::RegionsOverlyPolymorphic)(a, b),\n+        (ty::error::TypeError::IntMismatch)(x),\n+        (ty::error::TypeError::FloatMismatch)(x),\n+        (ty::error::TypeError::Traits)(x),\n+        (ty::error::TypeError::VariadicMismatch)(x),\n+        (ty::error::TypeError::CyclicTy)(t),\n+        (ty::error::TypeError::ProjectionMismatched)(x),\n+        (ty::error::TypeError::ProjectionBoundsLength)(x),\n+        (ty::error::TypeError::Sorts)(x),\n+        (ty::error::TypeError::ExistentialMismatch)(x),\n+        (ty::error::TypeError::OldStyleLUB)(x),\n     }\n }\n "}, {"sha": "109422564c84d31134f594911a4c95138dbaf331", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -1047,6 +1047,9 @@ pub enum RegionKind {\n     /// `ClosureRegionRequirements` that are produced by MIR borrowck.\n     /// See `ClosureRegionRequirements` for more details.\n     ReClosureBound(RegionVid),\n+\n+    /// Canonicalized region, used only when preparing a trait query.\n+    ReCanonical(CanonicalVar),\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n@@ -1091,8 +1094,13 @@ pub enum InferTy {\n     FreshTy(u32),\n     FreshIntTy(u32),\n     FreshFloatTy(u32),\n+\n+    /// Canonicalized type variable, used only when preparing a trait query.\n+    CanonicalTy(CanonicalVar),\n }\n \n+newtype_index!(CanonicalVar);\n+\n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n@@ -1213,6 +1221,10 @@ impl RegionKind {\n             }\n             ty::ReErased => {\n             }\n+            ty::ReCanonical(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_CANONICAL_VARS;\n+            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }"}, {"sha": "a301049fe1c4022da43636eba170082e99629a8b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Slice, Region, Ty, TyCtxt};\n+use ty::{self, Lift, Slice, Region, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -40,6 +40,7 @@ const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n \n+#[derive(Debug)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n@@ -113,6 +114,17 @@ impl<'tcx> fmt::Display for Kind<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n+    type Lifted = Kind<'tcx>;\n+\n+    fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self.unpack() {\n+            UnpackedKind::Lifetime(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n+            UnpackedKind::Type(a) => a.lift_to_tcx(tcx).map(|a| a.into()),\n+        }\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match self.unpack() {"}, {"sha": "753f89d8cd2932a042afa7d0452f8610b460efbb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 119, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -16,10 +16,10 @@ use hir::map::{DefPathData, Node};\n use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n-use traits::{self, Reveal};\n+use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::{Subst, UnpackedKind};\n+use ty::subst::UnpackedKind;\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::Integer;\n@@ -182,30 +182,6 @@ pub enum Representability {\n }\n \n impl<'tcx> ty::ParamEnv<'tcx> {\n-    /// Construct a trait environment suitable for contexts where\n-    /// there are no where clauses in scope.\n-    pub fn empty(reveal: Reveal) -> Self {\n-        Self::new(ty::Slice::empty(), reveal, ty::UniverseIndex::ROOT)\n-    }\n-\n-    /// Construct a trait environment with the given set of predicates.\n-    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n-               reveal: Reveal,\n-               universe: ty::UniverseIndex)\n-               -> Self {\n-        ty::ParamEnv { caller_bounds, reveal, universe }\n-    }\n-\n-    /// Returns a new parameter environment with the same clauses, but\n-    /// which \"reveals\" the true results of projections in all cases\n-    /// (even for associated types that are specializable).  This is\n-    /// the desired behavior during trans and certain other special\n-    /// contexts; normally though we want to use `Reveal::UserFacing`,\n-    /// which is the default.\n-    pub fn reveal_all(self) -> Self {\n-        ty::ParamEnv { reveal: Reveal::All, ..self }\n-    }\n-\n     pub fn can_type_implement_copy<'a>(self,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n@@ -561,99 +537,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Return a set of constraints that needs to be satisfied in\n-    /// order for `ty` to be valid for destruction.\n-    pub fn dtorck_constraint_for_ty(self,\n-                                    span: Span,\n-                                    for_ty: Ty<'tcx>,\n-                                    depth: usize,\n-                                    ty: Ty<'tcx>)\n-                                    -> Result<ty::DtorckConstraint<'tcx>, ErrorReported>\n-    {\n-        debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n-               span, for_ty, depth, ty);\n-\n-        if depth >= self.sess.recursion_limit.get() {\n-            let mut err = struct_span_err!(\n-                self.sess, span, E0320,\n-                \"overflow while adding drop-check rules for {}\", for_ty);\n-            err.note(&format!(\"overflowed on {}\", ty));\n-            err.emit();\n-            return Err(ErrorReported);\n-        }\n-\n-        let result = match ty.sty {\n-            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-            ty::TyFloat(_) | ty::TyStr | ty::TyNever | ty::TyForeign(..) |\n-            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) |\n-            ty::TyGeneratorWitness(..) => {\n-                // these types never have a destructor\n-                Ok(ty::DtorckConstraint::empty())\n-            }\n-\n-            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n-                // single-element containers, behave like their element\n-                self.dtorck_constraint_for_ty(span, for_ty, depth+1, ety)\n-            }\n-\n-            ty::TyTuple(tys, _) => {\n-                tys.iter().map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyClosure(def_id, substs) => {\n-                substs.upvar_tys(def_id, self).map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyGenerator(def_id, substs, _) => {\n-                // Note that the interior types are ignored here.\n-                // Any type reachable inside the interior must also be reachable\n-                // through the upvars.\n-                substs.upvar_tys(def_id, self).map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyAdt(def, substs) => {\n-                let ty::DtorckConstraint {\n-                    dtorck_types, outlives\n-                } = self.at(span).adt_dtorck_constraint(def.did);\n-                Ok(ty::DtorckConstraint {\n-                    // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n-                    // there, but that needs some way to handle cycles.\n-                    dtorck_types: dtorck_types.subst(self, substs),\n-                    outlives: outlives.subst(self, substs)\n-                })\n-            }\n-\n-            // Objects must be alive in order for their destructor\n-            // to be called.\n-            ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n-                outlives: vec![ty.into()],\n-                dtorck_types: vec![],\n-            }),\n-\n-            // Types that can't be resolved. Pass them forward.\n-            ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => {\n-                Ok(ty::DtorckConstraint {\n-                    outlives: vec![],\n-                    dtorck_types: vec![ty],\n-                })\n-            }\n-\n-            ty::TyInfer(..) | ty::TyError => {\n-                self.sess.delay_span_bug(span, \"unresolved type in dtorck\");\n-                Err(ErrorReported)\n-            }\n-        };\n-\n-        debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n-        result\n-    }\n-\n     pub fn is_closure(self, def_id: DefId) -> bool {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }\n@@ -858,6 +741,9 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReCanonical(c) => {\n+                self.hash(c);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 self.hash(db.depth);\n                 self.hash(i);"}, {"sha": "96b77d351e24cb38da56c030d7ceb22e8ef4a17e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -373,3 +373,13 @@ fn test_to_readable_str() {\n     assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n     assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n }\n+\n+pub trait CellUsizeExt {\n+    fn increment(&self);\n+}\n+\n+impl CellUsizeExt for Cell<usize> {\n+    fn increment(&self) {\n+        self.set(self.get() + 1);\n+    }\n+}"}, {"sha": "efa53c775ae255380d92631b7fd57ef878f01b72", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -721,6 +721,9 @@ define_print! {\n                 ty::ReEarlyBound(ref data) => {\n                     write!(f, \"{}\", data.name)\n                 }\n+                ty::ReCanonical(_) => {\n+                    write!(f, \"'_\")\n+                }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n                 ty::ReSkolemized(_, br) => {\n@@ -785,6 +788,10 @@ define_print! {\n                     write!(f, \"{:?}\", vid)\n                 }\n \n+                ty::ReCanonical(c) => {\n+                    write!(f, \"'?{}\", c.index())\n+                }\n+\n                 ty::ReSkolemized(id, ref bound_region) => {\n                     write!(f, \"ReSkolemized({:?}, {:?})\", id, bound_region)\n                 }\n@@ -888,6 +895,7 @@ define_print! {\n                     ty::TyVar(_) => write!(f, \"_\"),\n                     ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n                     ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                    ty::CanonicalTy(_) => write!(f, \"_\"),\n                     ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n                     ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n                     ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n@@ -899,6 +907,7 @@ define_print! {\n                 ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::CanonicalTy(v) => write!(f, \"?{:?}\", v.index()),\n                 ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n                 ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n                 ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)"}, {"sha": "a01b3cbf47bee420ae4f8080b725dfb3b97ea11e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -427,6 +427,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             // These cannot exist in borrowck\n             RegionKind::ReVar(..) |\n+            RegionKind::ReCanonical(..) |\n             RegionKind::ReSkolemized(..) |\n             RegionKind::ReClosureBound(..) |\n             RegionKind::ReErased => span_bug!(borrow_span,"}, {"sha": "49234f4ed7fdea35ddf76342525db774d4d1cad3", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n                     ty::ReStatic => self.item_ub,\n \n+                    ty::ReCanonical(_) |\n                     ty::ReEmpty |\n                     ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |"}, {"sha": "459aa9ea488fd808c924ca3ed04540d02e6fdb16", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -23,6 +23,7 @@\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(i128_type)]\n #![feature(from_ref)]\n "}, {"sha": "a5b1a7e57ab4668167dc893fb2bbf003396138d2", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -330,7 +330,7 @@ macro_rules! newtype_index {\n     );\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<fn(&I)>"}, {"sha": "3bff79ed3a6fce0c2ebf5dc662397835f5ff2564", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -28,6 +28,7 @@ rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n+rustc_traits = { path = \"../librustc_traits\" }\n rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "542f818c3818a3db39dc66c90dd2a562cd9bc138", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -31,6 +31,7 @@ use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver, ResolverArenas};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n+use rustc_traits;\n use rustc_trans_utils::trans_crate::TransCrate;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -942,6 +943,7 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     traits::provide(providers);\n     reachable::provide(providers);\n     rustc_passes::provide(providers);\n+    rustc_traits::provide(providers);\n     middle::region::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);"}, {"sha": "746f2db4767f92842ea4372284a350ca39ab944e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -46,6 +46,7 @@ extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;\n extern crate rustc_save_analysis;\n+extern crate rustc_traits;\n extern crate rustc_trans_utils;\n extern crate rustc_typeck;\n extern crate serialize;"}, {"sha": "06610609ebdbddb3c6036ddb4f53e34a6ed20cac", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -18,7 +18,7 @@ use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc::middle::region;\n use rustc::ty::subst::Subst;\n-use rustc::traits::{ObligationCause, Reveal};\n+use rustc::traits::ObligationCause;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::maps::OnDiskCache;\n use rustc::infer::{self, InferOk, InferResult};\n@@ -153,7 +153,7 @@ fn test_env<F>(source_string: &str,\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut region_scope_tree = region::ScopeTree::default();\n-            let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+            let param_env = ty::ParamEnv::empty();\n             body(Env {\n                 infcx: &infcx,\n                 region_scope_tree: &mut region_scope_tree,"}, {"sha": "031033f7208e1dff4767e43afdec28e79e56ffbb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -33,7 +33,7 @@ use rustc::hir::def_id::DefId;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if def.has_dtor(cx.tcx) {\n             return;\n         }\n-        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+        let param_env = ty::ParamEnv::empty();\n         if !ty.moves_by_default(cx.tcx, param_env, item.span) {\n             return;\n         }"}, {"sha": "445fe0cc40197dfef59c8278b0c4496e39756990", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -12,7 +12,7 @@\n \n use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -509,8 +509,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // make sure the fields are actually safe.\n                         let mut all_phantom = true;\n                         for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.fully_normalize_associated_types_in(\n-                                &field.ty(cx, substs)\n+                            let field_ty = cx.normalize_erasing_regions(\n+                                ParamEnv::reveal_all(),\n+                                field.ty(cx, substs),\n                             );\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields\n@@ -556,8 +557,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         let mut all_phantom = true;\n                         for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.fully_normalize_associated_types_in(\n-                                &field.ty(cx, substs)\n+                            let field_ty = cx.normalize_erasing_regions(\n+                                ParamEnv::reveal_all(),\n+                                field.ty(cx, substs),\n                             );\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n@@ -596,8 +598,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // Check the contained variants.\n                         for variant in &def.variants {\n                             for field in &variant.fields {\n-                                let arg = cx.fully_normalize_associated_types_in(\n-                                    &field.ty(cx, substs)\n+                                let arg = cx.normalize_erasing_regions(\n+                                    ParamEnv::reveal_all(),\n+                                    field.ty(cx, substs),\n                                 );\n                                 let r = self.check_type_for_ffi(cache, arg);\n                                 match r {\n@@ -716,7 +719,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n-        let ty = self.cx.tcx.fully_normalize_associated_types_in(&ty);\n+        let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n \n         match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}"}, {"sha": "f77c22bd895440681a7be3228ca31109f85218ab", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -18,7 +18,9 @@\n #![feature(fs_read_write)]\n #![feature(i128_type)]\n #![feature(libc)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(proc_macro_internals)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(specialization)]"}, {"sha": "84ba13674505f177e6a37a9b55ec25df36ff4bee", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -457,6 +457,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (RegionKind::ReLateBound(_, _), _)\n             | (RegionKind::ReSkolemized(_, _), _)\n             | (RegionKind::ReClosureBound(_), _)\n+            | (RegionKind::ReCanonical(_), _)\n             | (RegionKind::ReErased, _) => {\n                 span_bug!(drop_span, \"region does not make sense in this context\");\n             }"}, {"sha": "8da7c497973e7e7599ef62e1ef2b7b58c325fa41", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -732,7 +732,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 for (index, field) in def.all_fields().enumerate() {\n                     let gcx = self.tcx.global_tcx();\n                     let field_ty = field.ty(gcx, substs);\n-                    let field_ty = gcx.normalize_associated_type_in_env(&field_ty, self.param_env);\n+                    let field_ty = gcx.normalize_erasing_regions(self.param_env, field_ty);\n                     let place = drop_place.clone().field(Field::new(index), field_ty);\n \n                     self.visit_terminator_drop(loc, term, flow_state, &place, field_ty, span);"}, {"sha": "d19fd2bb5969dfc353142cfda186e5f93c19e8da", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 27, "deletions": 74, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -14,13 +14,9 @@ use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::mir::Local;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::traits;\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::infer::InferOk;\n-use rustc::util::common::ErrorReported;\n use borrow_check::nll::type_check::AtLocation;\n-use rustc_data_structures::fx::FxHashSet;\n-use syntax::codemap::DUMMY_SP;\n use util::liveness::LivenessResults;\n \n use super::TypeChecker;\n@@ -105,8 +101,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             for live_local in live_locals {\n                 debug!(\n                     \"add_liveness_constraints: location={:?} live_local={:?}\",\n-                    location,\n-                    live_local\n+                    location, live_local\n                 );\n \n                 self.flow_inits.each_state_bit(|mpi_init| {\n@@ -157,8 +152,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     {\n         debug!(\n             \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n-            value,\n-            location\n+            value, location\n         );\n \n         self.tcx.for_each_free_region(&value, |live_region| {\n@@ -182,9 +176,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     ) {\n         debug!(\n             \"add_drop_live_constraint(dropped_local={:?}, dropped_ty={:?}, location={:?})\",\n-            dropped_local,\n-            dropped_ty,\n-            location\n+            dropped_local, dropped_ty, location\n         );\n \n         // If we end visiting the same type twice (usually due to a cycle involving\n@@ -197,73 +189,34 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         //\n         // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n         // ourselves in one large 'fully_perform_op' callback.\n-        let (type_constraints, kind_constraints) = self.cx.fully_perform_op(location.at_self(),\n-            |cx| {\n-\n-            let tcx = cx.infcx.tcx;\n-            let mut selcx = traits::SelectionContext::new(cx.infcx);\n-            let cause = cx.misc(cx.last_span);\n-\n-            let mut types = vec![(dropped_ty, 0)];\n-            let mut final_obligations = Vec::new();\n-            let mut type_constraints = Vec::new();\n-            let mut kind_constraints = Vec::new();\n-\n-            let mut known = FxHashSet();\n-\n-            while let Some((ty, depth)) = types.pop() {\n-                let span = DUMMY_SP; // FIXME\n-                let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                    Ok(result) => result,\n-                    Err(ErrorReported) => {\n-                        continue;\n-                    }\n-                };\n-\n-                let ty::DtorckConstraint {\n-                    outlives,\n-                    dtorck_types,\n-                } = result;\n-\n-                // All things in the `outlives` array may be touched by\n-                // the destructor and must be live at this point.\n-                for outlive in outlives {\n+        let kind_constraints = self.cx\n+            .fully_perform_op(location.at_self(), |cx| {\n+                let span = cx.last_span;\n+\n+                let mut final_obligations = Vec::new();\n+                let mut kind_constraints = Vec::new();\n+\n+                let InferOk {\n+                    value: kinds,\n+                    obligations,\n+                } = cx.infcx\n+                    .at(&cx.misc(span), cx.param_env)\n+                    .dropck_outlives(dropped_ty);\n+                for kind in kinds {\n+                    // All things in the `outlives` array may be touched by\n+                    // the destructor and must be live at this point.\n                     let cause = Cause::DropVar(dropped_local, location);\n-                    kind_constraints.push((outlive, location, cause));\n+                    kind_constraints.push((kind, location, cause));\n                 }\n \n-                // However, there may also be some types that\n-                // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-                // associated types and parameters). We need to normalize\n-                // associated types here and possibly recursively process.\n-                for ty in dtorck_types {\n-                    let traits::Normalized { value: ty, obligations } =\n-                        traits::normalize(&mut selcx, cx.param_env, cause.clone(), &ty);\n-\n-                    final_obligations.extend(obligations);\n+                final_obligations.extend(obligations);\n \n-                    let ty = cx.infcx.resolve_type_and_region_vars_if_possible(&ty);\n-                    match ty.sty {\n-                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                            let cause = Cause::DropVar(dropped_local, location);\n-                            type_constraints.push((ty, location, cause));\n-                        }\n-\n-                        _ => if known.insert(ty) {\n-                            types.push((ty, depth + 1));\n-                        },\n-                    }\n-                }\n-            }\n-\n-            Ok(InferOk {\n-                value: (type_constraints, kind_constraints), obligations: final_obligations\n+                Ok(InferOk {\n+                    value: kind_constraints,\n+                    obligations: final_obligations,\n+                })\n             })\n-        }).unwrap();\n-\n-        for (ty, location, cause) in type_constraints {\n-            self.push_type_live_constraint(ty, location, cause);\n-        }\n+            .unwrap();\n \n         for (kind, location, cause) in kind_constraints {\n             self.push_type_live_constraint(kind, location, cause);"}, {"sha": "06e6be5cd56a35c6ca1c73127689484892e714f4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -20,7 +20,8 @@ use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::traits::{self, FulfillmentContext};\n+use rustc::traits::{self, Normalized, FulfillmentContext};\n+use rustc::traits::query::NoSolution;\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n@@ -243,8 +244,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         debug!(\n             \"sanitize_constant(constant={:?}, location={:?})\",\n-            constant,\n-            location\n+            constant, location\n         );\n \n         let expected_ty = match constant.literal {\n@@ -678,8 +678,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         let data = self.infcx.take_and_reset_region_constraints();\n         if !data.is_empty() {\n-            debug!(\"fully_perform_op: constraints generated at {:?} are {:#?}\",\n-                   locations, data);\n+            debug!(\n+                \"fully_perform_op: constraints generated at {:?} are {:#?}\",\n+                locations, data\n+            );\n             self.constraints\n                 .outlives_sets\n                 .push(OutlivesSet { locations, data });\n@@ -1137,12 +1139,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             TerminatorKind::FalseUnwind {\n                 real_target,\n-                unwind\n+                unwind,\n             } => {\n                 self.assert_iscleanup(mir, block_data, real_target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n-                        span_mirbug!(self, block_data, \"cleanup in cleanup block via false unwind\");\n+                        span_mirbug!(\n+                            self,\n+                            block_data,\n+                            \"cleanup in cleanup block via false unwind\"\n+                        );\n                     }\n                     self.assert_iscleanup(mir, block_data, unwind, true);\n                 }\n@@ -1435,8 +1441,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"prove_aggregate_predicates(aggregate_kind={:?}, location={:?})\",\n-            aggregate_kind,\n-            location\n+            aggregate_kind, location\n         );\n \n         let instantiated_predicates = match aggregate_kind {\n@@ -1502,8 +1507,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn prove_predicates(&mut self, predicates: &[ty::Predicate<'tcx>], location: Location) {\n         debug!(\n             \"prove_predicates(predicates={:?}, location={:?})\",\n-            predicates,\n-            location\n+            predicates, location\n         );\n         self.fully_perform_op(location.at_self(), |this| {\n             let cause = this.misc(this.last_span);\n@@ -1550,10 +1554,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         self.fully_perform_op(location.at_self(), |this| {\n-            let mut selcx = traits::SelectionContext::new(this.infcx);\n-            let cause = this.misc(this.last_span);\n-            let traits::Normalized { value, obligations } =\n-                traits::normalize(&mut selcx, this.param_env, cause, value);\n+            let Normalized { value, obligations } = this.infcx\n+                .at(&this.misc(this.last_span), this.param_env)\n+                .normalize(value)\n+                .unwrap_or_else(|NoSolution| {\n+                    span_bug!(\n+                        this.last_span,\n+                        \"normalization of `{:?}` failed at {:?}\",\n+                        value,\n+                        location,\n+                    );\n+                });\n             Ok(InferOk { value, obligations })\n         }).unwrap()\n     }"}, {"sha": "c236ce2abc5f01cdf5cac0bd25907dbc5076e3b3", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -249,7 +249,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"substs: {:#?}\", self.substs());\n         trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.tcx.trans_apply_param_substs_env(self.substs(), self.param_env, &substs);\n+        let substs = self.tcx.subst_and_normalize_erasing_regions(\n+            self.substs(),\n+            self.param_env,\n+            &substs,\n+        );\n         ty::Instance::resolve(\n             *self.tcx,\n             self.param_env,\n@@ -285,10 +289,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n-        let without_lifetimes = self.tcx.erase_regions(&ty);\n-        let substituted = without_lifetimes.subst(*self.tcx, substs);\n-        let substituted = self.tcx.fully_normalize_monormophic_ty(&substituted);\n-        substituted\n+        let substituted = ty.subst(*self.tcx, substs);\n+        self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n     }\n \n     /// Return the size and aligment of the value at the given type.\n@@ -724,7 +726,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     ClosureFnPointer => {\n                         match self.eval_operand(operand)?.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n-                                let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n+                                let substs = self.tcx.subst_and_normalize_erasing_regions(\n+                                    self.substs(),\n+                                    ty::ParamEnv::reveal_all(),\n+                                    &substs,\n+                                );\n                                 let instance = ty::Instance::resolve_closure(\n                                     *self.tcx,\n                                     def_id,\n@@ -949,8 +955,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n         let param_env = if self.tcx.is_static(gid.instance.def_id()).is_some() {\n-            use rustc::traits;\n-            ty::ParamEnv::empty(traits::Reveal::All)\n+            ty::ParamEnv::reveal_all()\n         } else {\n             self.param_env\n         };"}, {"sha": "be34b8705eb18de6ce11272a11f33c5357fa19ec", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -75,8 +75,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n                                 let real_sig = instance_ty.fn_sig(*self.tcx);\n-                                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n-                                let real_sig = self.tcx.erase_late_bound_regions_and_normalize(&real_sig);\n+                                let sig = self.tcx.normalize_erasing_late_bound_regions(\n+                                    ty::ParamEnv::reveal_all(),\n+                                    &sig,\n+                                );\n+                                let real_sig = self.tcx.normalize_erasing_late_bound_regions(\n+                                    ty::ParamEnv::reveal_all(),\n+                                    &real_sig,\n+                                );\n                                 if !self.check_sig_compat(sig, real_sig)? {\n                                     return err!(FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n@@ -95,7 +101,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                 };\n                 let args = self.operands_to_args(args)?;\n-                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n+                let sig = self.tcx.normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &sig,\n+                );\n                 self.eval_fn_call(\n                     fn_def,\n                     destination,\n@@ -113,7 +122,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n                 let ty = self.place_ty(location);\n-                let ty = self.tcx.trans_apply_param_substs(self.substs(), &ty);\n+                let ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    self.substs(),\n+                    ty::ParamEnv::reveal_all(),\n+                    &ty,\n+                );\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n                 let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);"}, {"sha": "7fd2ea265de8025579deb08ae0d72fc4372daf77", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -196,7 +196,6 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{Value, PrimVal, AllocId, Pointer};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n-use rustc::traits;\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n@@ -383,7 +382,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 instance,\n                 promoted: None,\n             };\n-            let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+            let param_env = ty::ParamEnv::reveal_all();\n \n             match tcx.const_eval(param_env.and(cid)) {\n                 Ok(val) => collect_const(tcx, val, instance.substs, &mut neighbors),\n@@ -524,11 +523,17 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                                  &target_ty);\n+                let target_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &target_ty,\n+                );\n                 let source_ty = operand.ty(self.mir, self.tcx);\n-                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                                  &source_ty);\n+                let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &source_ty,\n+                );\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.tcx,\n                                                                             source_ty,\n                                                                             target_ty);\n@@ -544,14 +549,20 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n                 let fn_ty = operand.ty(self.mir, self.tcx);\n-                let fn_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                              &fn_ty);\n+                let fn_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &fn_ty,\n+                );\n                 visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n                 let source_ty = operand.ty(self.mir, self.tcx);\n-                let source_ty = self.tcx.trans_apply_param_substs(self.param_substs,\n-                                                                  &source_ty);\n+                let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &source_ty,\n+                );\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n@@ -596,14 +607,22 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n-                let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n+                let callee_ty = tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &callee_ty,\n+                );\n                 visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                 let ty = location.ty(self.mir, self.tcx)\n                     .to_ty(self.tcx);\n-                let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n+                let ty = tcx.subst_and_normalize_erasing_regions(\n+                    self.param_substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &ty,\n+                );\n                 visit_drop_use(self.tcx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |\n@@ -654,7 +673,7 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n-                                             ty::ParamEnv::empty(traits::Reveal::All),\n+                                             ty::ParamEnv::reveal_all(),\n                                              def_id,\n                                              substs).unwrap();\n         visit_instance_use(tcx, instance, is_direct_call, output);\n@@ -776,7 +795,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n-            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All)) {\n+            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n                 return false;\n             }\n             let tail = tcx.struct_tail(ty);\n@@ -859,7 +878,7 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let methods = methods.iter().cloned().filter_map(|method| method)\n                 .map(|(def_id, substs)| ty::Instance::resolve(\n                         tcx,\n-                        ty::ParamEnv::empty(traits::Reveal::All),\n+                        ty::ParamEnv::reveal_all(),\n                         def_id,\n                         substs).unwrap())\n                 .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n@@ -1013,7 +1032,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n \n         let start_instance = Instance::resolve(\n             self.tcx,\n-            ty::ParamEnv::empty(traits::Reveal::All),\n+            ty::ParamEnv::reveal_all(),\n             start_def_id,\n             self.tcx.mk_substs(iter::once(Kind::from(main_ret_ty)))\n         ).unwrap();\n@@ -1062,7 +1081,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n \n                     let instance = ty::Instance::resolve(tcx,\n-                                                         ty::ParamEnv::empty(traits::Reveal::All),\n+                                                         ty::ParamEnv::reveal_all(),\n                                                          method.def_id,\n                                                          callee_substs).unwrap();\n \n@@ -1120,7 +1139,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         output,\n         param_substs: instance.substs,\n     }.visit_mir(&mir);\n-    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+    let param_env = ty::ParamEnv::reveal_all();\n     for (i, promoted) in mir.promoted.iter().enumerate() {\n         use rustc_data_structures::indexed_vec::Idx;\n         let cid = GlobalId {\n@@ -1155,9 +1174,12 @@ fn collect_const<'a, 'tcx>(\n \n     let val = match constant.val {\n         ConstVal::Unevaluated(def_id, substs) => {\n-            let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n-            let substs = tcx.trans_apply_param_substs(param_substs,\n-                                                        &substs);\n+            let param_env = ty::ParamEnv::reveal_all();\n+            let substs = tcx.subst_and_normalize_erasing_regions(\n+                param_substs,\n+                param_env,\n+                &substs,\n+            );\n             let instance = ty::Instance::resolve(tcx,\n                                                 param_env,\n                                                 def_id,"}, {"sha": "10e2a84038de120456a7768076e5cd73d97b819a", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -347,7 +347,10 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 output.push_str(\"fn(\");\n \n-                let sig = self.tcx.erase_late_bound_regions_and_normalize(&sig);\n+                let sig = self.tcx.normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &sig,\n+                );\n \n                 if !sig.inputs().is_empty() {\n                     for &parameter_type in sig.inputs() {"}, {"sha": "5c38735d9203460f265bb46fadda1581e0d1e7dd", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -88,7 +88,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n         closure_did, substs);\n \n     let sig = substs.closure_sig(closure_did, tcx);\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs([\n         Kind::from(self_ty),\n@@ -154,7 +154,7 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n {\n     let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n     let substs = tcx.intern_substs(&[ty.into()]);\n-    Instance::resolve(tcx, ty::ParamEnv::empty(traits::Reveal::All), def_id, substs).unwrap()\n+    Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n }\n \n pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -168,7 +168,7 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match tcx.trans_fulfill_obligation( (ty::ParamEnv::empty(traits::Reveal::All), trait_ref)) {\n+    match tcx.trans_fulfill_obligation( (ty::ParamEnv::reveal_all(), trait_ref)) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }"}, {"sha": "3789342b3891dd9b7d0a91b9f12f0f7b61826fb7", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -645,7 +645,11 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = tcx.trans_impl_self_ty(impl_def_id, instance.substs);\n+                let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                    instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &tcx.type_of(impl_def_id),\n+                );\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);\n                 }"}, {"sha": "62af09cc491096922fc5c8e3280b7b9c8ca305f6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -832,14 +832,11 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = gcx.fn_sig(def_id).no_late_bound_regions()\n-        .expect(\"LBR in ADT constructor signature\");\n-    let sig = gcx.erase_regions(&sig);\n     let param_env = gcx.param_env(def_id);\n \n-    // Normalize the sig now that we have liberated the late-bound\n-    // regions.\n-    let sig = gcx.normalize_associated_type_in_env(&sig, param_env);\n+    // Normalize the sig.\n+    let sig = gcx.fn_sig(def_id).no_late_bound_regions().expect(\"LBR in ADT constructor signature\");\n+    let sig = gcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {\n         ty::TyAdt(adt_def, substs) => (adt_def, substs),"}, {"sha": "6380d2a5c15fee12e0729cbded2f3ff961958687", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -129,8 +129,12 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n                                                                            callsite.location.span,\n                                                                            callsite.callee) {\n-                    Ok(ref callee_mir) if self.should_inline(callsite, callee_mir) => {\n-                        subst_and_normalize(callee_mir, self.tcx, &callsite.substs, param_env)\n+                    Ok(callee_mir) if self.should_inline(callsite, callee_mir) => {\n+                        self.tcx.subst_and_normalize_erasing_regions(\n+                            &callsite.substs,\n+                            param_env,\n+                            callee_mir,\n+                        )\n                     }\n                     Ok(_) => continue,\n \n@@ -664,30 +668,6 @@ fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n-fn subst_and_normalize<'a, 'tcx: 'a>(\n-    mir: &Mir<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    substs: &'tcx ty::subst::Substs<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Mir<'tcx> {\n-    struct Folder<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        substs: &'tcx ty::subst::Substs<'tcx>,\n-    }\n-    impl<'a, 'tcx: 'a> ty::fold::TypeFolder<'tcx, 'tcx> for Folder<'a, 'tcx> {\n-        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-            self.tcx.trans_apply_param_substs_env(&self.substs, self.param_env, &t)\n-        }\n-    }\n-    let mut f = Folder { tcx, param_env, substs };\n-    mir.fold_with(&mut f)\n-}\n-\n /**\n  * Integrator.\n  *"}, {"sha": "94446a98e63fe1c46969f365c77f817c9f9353f9", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;\n@@ -1237,7 +1237,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             }\n             let ty = mir.return_ty();\n             tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                let param_env = ty::ParamEnv::empty();\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx,"}, {"sha": "3f5208dd2d4b8c67f1cfc5184e788528aa527834", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -206,11 +206,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             let field = Field::new(i);\n             let subpath = self.elaborator.field_subpath(variant_path, field);\n \n-            let field_ty =\n-                self.tcx().normalize_associated_type_in_env(\n-                    &f.ty(self.tcx(), substs),\n-                    self.elaborator.param_env()\n-                );\n+            let field_ty = self.tcx().normalize_erasing_regions(\n+                self.elaborator.param_env(),\n+                f.ty(self.tcx(), substs),\n+            );\n             (base_place.clone().field(field, field_ty), subpath)\n         }).collect()\n     }"}, {"sha": "356ad9ec11bb70c0b6e4883e8d22af3c0eb690c0", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -34,7 +34,6 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::traits::Reveal;\n use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n@@ -87,7 +86,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_static: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),\n-        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+        param_env: ty::ParamEnv::empty(),\n         identity_substs: Substs::empty(),\n         result: ItemLocalSet(),\n     };"}, {"sha": "953747756517dfb5f3d3bea4df5e5496e12d6f22", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -13,6 +13,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n #![feature(custom_attribute)]\n+#![feature(macro_lifetime_matcher)]\n #![allow(unused_attributes)]\n \n #[macro_use]"}, {"sha": "dc2a21cdab256db89eff1f3b9cf1b3b7a9baa4ce", "filename": "src/librustc_traits/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_traits\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_traits\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+bitflags = \"1.0\"\n+graphviz = { path = \"../libgraphviz\" }\n+log = { version = \"0.4\" }\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "2274f3942bdbcf4d40df5a84f8dbe768aae160fa", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,285 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::hir::def_id::DefId;\n+use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n+use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n+use rustc::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::subst::Subst;\n+use rustc::util::nodemap::FxHashSet;\n+use std::rc::Rc;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use util;\n+\n+crate fn dropck_outlives<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> Result<Rc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>, NoSolution> {\n+    debug!(\"dropck_outlives(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let tcx = infcx.tcx;\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: for_ty,\n+            },\n+            canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recusion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet();\n+\n+        let fulfill_cx = &mut FulfillmentContext::new();\n+\n+        let cause = ObligationCause::dummy();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            let DtorckConstraint {\n+                dtorck_types,\n+                outlives,\n+                overflows,\n+            } = dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.extend(outlives);\n+            result.overflows.extend(overflows);\n+\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in dtorck_types {\n+                match infcx.at(&cause, param_env).normalize(&ty) {\n+                    Ok(Normalized {\n+                        value: ty,\n+                        obligations,\n+                    }) => {\n+                        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                        debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                        match ty.sty {\n+                            // All parameters live for the duration of the\n+                            // function.\n+                            ty::TyParam(..) => {}\n+\n+                            // A projection that we couldn't resolve - it\n+                            // might have a destructor.\n+                            ty::TyProjection(..) | ty::TyAnon(..) => {\n+                                result.kinds.push(ty.into());\n+                            }\n+\n+                            _ => {\n+                                if ty_set.insert(ty) {\n+                                    ty_stack.push((ty, depth + 1));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // We don't actually expect to fail to normalize.\n+                    // That implies a WF error somewhere else.\n+                    Err(NoSolution) => {\n+                        return Err(NoSolution);\n+                    }\n+                }\n+            }\n+        }\n+\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+\n+        util::make_query_response(infcx, canonical_inference_vars, result, fulfill_cx)\n+    })\n+}\n+\n+/// Return a set of constraints that needs to be satisfied in\n+/// order for `ty` to be valid for destruction.\n+fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    for_ty: Ty<'tcx>,\n+    depth: usize,\n+    ty: Ty<'tcx>,\n+) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+    debug!(\n+        \"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n+        span, for_ty, depth, ty\n+    );\n+\n+    if depth >= tcx.sess.recursion_limit.get() {\n+        return Ok(DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![],\n+            overflows: vec![ty],\n+        });\n+    }\n+\n+    let result = match ty.sty {\n+        ty::TyBool\n+        | ty::TyChar\n+        | ty::TyInt(_)\n+        | ty::TyUint(_)\n+        | ty::TyFloat(_)\n+        | ty::TyStr\n+        | ty::TyNever\n+        | ty::TyForeign(..)\n+        | ty::TyRawPtr(..)\n+        | ty::TyRef(..)\n+        | ty::TyFnDef(..)\n+        | ty::TyFnPtr(_)\n+        | ty::TyGeneratorWitness(..) => {\n+            // these types never have a destructor\n+            Ok(DtorckConstraint::empty())\n+        }\n+\n+        ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+            // single-element containers, behave like their element\n+            dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n+        }\n+\n+        ty::TyTuple(tys, _) => tys.iter()\n+            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+            .collect(),\n+\n+        ty::TyClosure(def_id, substs) => substs\n+            .upvar_tys(def_id, tcx)\n+            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+            .collect(),\n+\n+        ty::TyGenerator(def_id, substs, _) => {\n+            // Note that the interior types are ignored here.\n+            // Any type reachable inside the interior must also be reachable\n+            // through the upvars.\n+            substs\n+                .upvar_tys(def_id, tcx)\n+                .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+                .collect()\n+        }\n+\n+        ty::TyAdt(def, substs) => {\n+            let DtorckConstraint {\n+                dtorck_types,\n+                outlives,\n+                overflows,\n+            } = tcx.at(span).adt_dtorck_constraint(def.did)?;\n+            Ok(DtorckConstraint {\n+                // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+                // there, but that needs some way to handle cycles.\n+                dtorck_types: dtorck_types.subst(tcx, substs),\n+                outlives: outlives.subst(tcx, substs),\n+                overflows: overflows.subst(tcx, substs),\n+            })\n+        }\n+\n+        // Objects must be alive in order for their destructor\n+        // to be called.\n+        ty::TyDynamic(..) => Ok(DtorckConstraint {\n+            outlives: vec![ty.into()],\n+            dtorck_types: vec![],\n+            overflows: vec![],\n+        }),\n+\n+        // Types that can't be resolved. Pass them forward.\n+        ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => Ok(DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![ty],\n+            overflows: vec![],\n+        }),\n+\n+        ty::TyInfer(..) | ty::TyError => {\n+            // By the time this code runs, all type variables ought to\n+            // be fully resolved.\n+            Err(NoSolution)\n+        }\n+    };\n+\n+    debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n+    result\n+}\n+\n+/// Calculates the dtorck constraint for a type.\n+crate fn adt_dtorck_constraint<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+    let def = tcx.adt_def(def_id);\n+    let span = tcx.def_span(def_id);\n+    debug!(\"dtorck_constraint: {:?}\", def);\n+\n+    if def.is_phantom_data() {\n+        let result = DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])],\n+            overflows: vec![],\n+        };\n+        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+        return Ok(result);\n+    }\n+\n+    let mut result = def.all_fields()\n+        .map(|field| tcx.type_of(field.did))\n+        .map(|fty| dtorck_constraint_for_ty(tcx, span, fty, 0, fty))\n+        .collect::<Result<DtorckConstraint, NoSolution>>()?;\n+    result.outlives.extend(tcx.destructor_constraints(def));\n+    dedup_dtorck_constraint(&mut result);\n+\n+    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+\n+    Ok(result)\n+}\n+\n+fn dedup_dtorck_constraint<'tcx>(c: &mut DtorckConstraint<'tcx>) {\n+    let mut outlives = FxHashSet();\n+    let mut dtorck_types = FxHashSet();\n+\n+    c.outlives.retain(|&val| outlives.replace(val).is_none());\n+    c.dtorck_types\n+        .retain(|&val| dtorck_types.replace(val).is_none());\n+}"}, {"sha": "45d23a2733a2a3337d12c3020323e0b14072d6a3", "filename": "src/librustc_traits/lib.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! New recursive solver modeled on Chalk's recursive solver. Most of\n+//! the guts are broken up into modules; see the comments in those modules.\n+\n+#![deny(warnings)]\n+\n+#![feature(crate_visibility_modifier)]\n+#![feature(match_default_bindings)]\n+#![feature(underscore_lifetimes)]\n+\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_data_structures;\n+extern crate syntax;\n+extern crate syntax_pos;\n+\n+mod dropck_outlives;\n+mod normalize_projection_ty;\n+mod normalize_erasing_regions;\n+mod util;\n+\n+use rustc::ty::maps::Providers;\n+\n+pub fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        dropck_outlives: dropck_outlives::dropck_outlives,\n+        adt_dtorck_constraint: dropck_outlives::adt_dtorck_constraint,\n+        normalize_projection_ty: normalize_projection_ty::normalize_projection_ty,\n+        normalize_ty_after_erasing_regions:\n+            normalize_erasing_regions::normalize_ty_after_erasing_regions,\n+        ..*p\n+    };\n+}"}, {"sha": "14f8694dbf72a0a2e9acf82681f3bb2e2e210cc2", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{Normalized, ObligationCause};\n+use rustc::traits::query::NoSolution;\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::util::common::CellUsizeExt;\n+\n+crate fn normalize_ty_after_erasing_regions<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Ty<'tcx> {\n+    let ParamEnvAnd { param_env, value } = goal;\n+    tcx.sess\n+        .perf_stats\n+        .normalize_ty_after_erasing_regions\n+        .increment();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = ObligationCause::dummy();\n+        match infcx.at(&cause, param_env).normalize(&value) {\n+            Ok(Normalized {\n+                value: normalized_value,\n+                obligations: normalized_obligations,\n+            }) => {\n+                // We don't care about the `obligations`; they are\n+                // always only region relations, and we are about to\n+                // erase those anyway:\n+                debug_assert_eq!(\n+                    normalized_obligations\n+                        .iter()\n+                        .find(|p| not_outlives_predicate(&p.predicate)),\n+                    None,\n+                );\n+\n+                let normalized_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+                let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n+                tcx.lift_to_global(&normalized_value).unwrap()\n+            }\n+            Err(NoSolution) => bug!(\"could not fully normalize `{:?}`\", value),\n+        }\n+    })\n+}\n+\n+fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n+    match p {\n+        ty::Predicate::RegionOutlives(..) | ty::Predicate::TypeOutlives(..) => false,\n+        ty::Predicate::Trait(..)\n+        | ty::Predicate::Projection(..)\n+        | ty::Predicate::WellFormed(..)\n+        | ty::Predicate::ObjectSafe(..)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::Subtype(..)\n+        | ty::Predicate::ConstEvaluatable(..) => true,\n+    }\n+}"}, {"sha": "55785d9586cc37cebbd46479b1fcecf9293ec0ba", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n+                    SelectionContext};\n+use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n+use rustc::util::common::CellUsizeExt;\n+use std::rc::Rc;\n+use syntax::ast::DUMMY_NODE_ID;\n+use syntax_pos::DUMMY_SP;\n+use util;\n+\n+crate fn normalize_projection_ty<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<Rc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.sess.perf_stats.normalize_projection_ty.increment();\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: goal,\n+            },\n+            canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+        let fulfill_cx = &mut FulfillmentContext::new();\n+        let selcx = &mut SelectionContext::new(infcx);\n+        let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+        let Normalized {\n+            value: answer,\n+            obligations,\n+        } = traits::normalize_projection_type(selcx, param_env, goal, cause, 0);\n+        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+        // Now that we have fulfilled as much as we can, create a solution\n+        // from what we've learned.\n+        util::make_query_response(\n+            infcx,\n+            canonical_inference_vars,\n+            NormalizationResult { normalized_ty: answer },\n+            fulfill_cx,\n+        )\n+    })\n+}"}, {"sha": "976eb442a0d13ee0dc1b833fe80dcc319f8e6487", "filename": "src/librustc_traits/util.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::InferCtxt;\n+use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraints,\n+                              QueryResult};\n+use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n+use rustc::traits::FulfillmentContext;\n+use rustc::traits::query::NoSolution;\n+use rustc::ty;\n+use std::fmt::Debug;\n+\n+/// The canonicalization form of `QueryResult<'tcx, T>`.\n+type CanonicalizedQueryResult<'gcx, 'tcx, T> =\n+    <QueryResult<'tcx, T> as Canonicalize<'gcx, 'tcx>>::Canonicalized;\n+\n+crate fn make_query_response<'gcx, 'tcx, T>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    inference_vars: CanonicalVarValues<'tcx>,\n+    answer: T,\n+    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+) -> Result<CanonicalizedQueryResult<'gcx, 'tcx, T>, NoSolution>\n+where\n+    T: Debug,\n+    QueryResult<'tcx, T>: Canonicalize<'gcx, 'tcx>,\n+{\n+    let tcx = infcx.tcx;\n+\n+    debug!(\n+        \"make_query_response(\\\n+         inference_vars={:?}, \\\n+         answer={:?})\",\n+        inference_vars, answer,\n+    );\n+\n+    // Select everything, returning errors.\n+    let true_errors = match fulfill_cx.select_where_possible(infcx) {\n+        Ok(()) => vec![],\n+        Err(errors) => errors,\n+    };\n+    debug!(\"true_errors = {:#?}\", true_errors);\n+\n+    if !true_errors.is_empty() {\n+        // FIXME -- we don't indicate *why* we failed to solve\n+        debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n+        return Err(NoSolution);\n+    }\n+\n+    // Anything left unselected *now* must be an ambiguity.\n+    let ambig_errors = match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => vec![],\n+        Err(errors) => errors,\n+    };\n+    debug!(\"ambig_errors = {:#?}\", ambig_errors);\n+\n+    let region_obligations = infcx.take_registered_region_obligations();\n+\n+    let (region_outlives, ty_outlives) = infcx.with_region_constraints(|region_constraints| {\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = region_constraints;\n+\n+        assert!(verifys.is_empty());\n+        assert!(givens.is_empty());\n+\n+        let region_outlives: Vec<_> = constraints\n+            .into_iter()\n+            .map(|(k, _)| match *k {\n+                Constraint::VarSubVar(v1, v2) => {\n+                    (tcx.mk_region(ty::ReVar(v1)), tcx.mk_region(ty::ReVar(v2)))\n+                }\n+                Constraint::VarSubReg(v1, r2) => (tcx.mk_region(ty::ReVar(v1)), r2),\n+                Constraint::RegSubVar(r1, v2) => (r1, tcx.mk_region(ty::ReVar(v2))),\n+                Constraint::RegSubReg(r1, r2) => (r1, r2),\n+            })\n+            .collect();\n+\n+        let ty_outlives: Vec<_> = region_obligations\n+            .into_iter()\n+            .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n+            .collect();\n+\n+        (region_outlives, ty_outlives)\n+    });\n+\n+    let certainty = if ambig_errors.is_empty() {\n+        Certainty::Proven\n+    } else {\n+        Certainty::Ambiguous\n+    };\n+\n+    let (canonical_result, _) = infcx.canonicalize_response(&QueryResult {\n+        var_values: inference_vars,\n+        region_constraints: QueryRegionConstraints {\n+            region_outlives,\n+            ty_outlives,\n+        },\n+        certainty,\n+        value: answer,\n+    });\n+\n+    debug!(\n+        \"make_query_response: canonical_result = {:#?}\",\n+        canonical_result\n+    );\n+\n+    Ok(canonical_result)\n+}"}, {"sha": "c1dc8c6684a17ca8216b2e7fda5691b8f9edce9c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -650,7 +650,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                        -> Self {\n         let fn_ty = instance.ty(cx.tcx);\n         let sig = ty_fn_sig(cx, fn_ty);\n-        let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         FnType::new(cx, sig, &[])\n     }\n "}, {"sha": "4da082e9d50f1088440b1654153d735e9a4d2176", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -462,7 +462,7 @@ pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tc\n \n     let fn_ty = instance.ty(cx.tcx);\n     let sig = common::ty_fn_sig(cx, fn_ty);\n-    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n     let lldecl = match cx.instances.borrow().get(&instance) {\n         Some(&val) => val,"}, {"sha": "1dcf349e23bd882028b1cd37a63f0828e48c1712", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -25,7 +25,6 @@ use type_of::LayoutLlvmExt;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::LayoutOf;\n-use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc_back::PanicStrategy;\n \n@@ -185,7 +184,7 @@ pub fn resolve_and_get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         cx,\n         ty::Instance::resolve(\n             cx.tcx,\n-            ty::ParamEnv::empty(traits::Reveal::All),\n+            ty::ParamEnv::reveal_all(),\n             def_id,\n             substs\n         ).unwrap()"}, {"sha": "c71c0cc0ebf2c9ee3a98b25a649b6d0bfd5004c0", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -25,7 +25,6 @@ use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n@@ -40,15 +39,15 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use context::CodegenCx;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n+    ty.needs_drop(tcx, ty::ParamEnv::reveal_all())\n }\n \n pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All))\n+    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all())\n }\n \n pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_freeze(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+    ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n }\n \n /*"}, {"sha": "1f2c3cc883c682fcf3e3283ce434d11fb6091115", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -14,7 +14,6 @@ use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::traits;\n use debuginfo;\n use callee;\n use base;\n@@ -435,7 +434,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n \n     pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All)) {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n             return false;\n         }\n \n@@ -464,7 +463,7 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CodegenCx<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.tcx.layout_of(ty::ParamEnv::empty(traits::Reveal::All).and(ty))\n+        self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n             .unwrap_or_else(|e| match e {\n                 LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n                 _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)"}, {"sha": "20cc57522b5d768d2b3e88037b442793f3c048f8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n use rustc::ty::Instance;\n use common::CodegenCx;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n@@ -353,7 +353,10 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = cx.tcx.erase_late_bound_regions_and_normalize(&signature);\n+    let signature = cx.tcx.normalize_erasing_late_bound_regions(\n+        ty::ParamEnv::reveal_all(),\n+        &signature,\n+    );\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n@@ -589,7 +592,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n             let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n-                cx.tcx.fully_normalize_associated_types_in(&t)\n+                cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n             prepare_tuple_metadata(cx,\n                                    t,"}, {"sha": "c13b91eb3b6bd228f162c2c60d5451e07f9c3b0b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -30,7 +30,7 @@ use abi::Abi;\n use common::CodegenCx;\n use builder::Builder;\n use monomorphize::Instance;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, ParamEnv, Ty};\n use rustc::mir;\n use rustc::session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n@@ -378,7 +378,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let actual_type = cx.tcx.fully_normalize_associated_types_in(&actual_type);\n+            let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n@@ -391,7 +391,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n             substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx.fully_normalize_associated_types_in(&ty);\n+                let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n@@ -429,7 +429,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx.trans_impl_self_ty(impl_def_id, instance.substs);\n+                let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n+                    instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &cx.tcx.type_of(impl_def_id),\n+                );\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`)."}, {"sha": "211de95c96ede4376fc96241d25b9468eea49f5d", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -117,8 +117,10 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         },\n         ty::TyDynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx.erase_late_bound_regions_and_normalize(\n-                    &principal);\n+                let principal = cx.tcx.normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &principal,\n+                );\n                 push_item_name(cx, principal.def_id, false, output);\n                 push_type_params(cx, principal.substs, output);\n             }\n@@ -138,7 +140,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+            let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);"}, {"sha": "c2010feb1b63885f2a5df185eec6e8b0d57a5c7c", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -22,7 +22,7 @@\n \n use llvm::{self, ValueRef};\n use llvm::AttributePlace::Function;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc::session::config::Sanitizer;\n use rustc_back::PanicStrategy;\n use abi::{Abi, FnType};\n@@ -127,7 +127,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n                             fn_type: Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n     let sig = common::ty_fn_sig(cx, fn_type);\n-    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n     let fty = FnType::new(cx, sig, &[]);"}, {"sha": "4cef7470c62d738ab181381f61d2182eb3a59ebe", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -100,7 +100,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     };\n \n     let sig = callee_ty.fn_sig(tcx);\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n+    let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n     let arg_tys = sig.inputs();\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n@@ -1035,7 +1035,10 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n     let tcx = bx.tcx();\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig(tcx));\n+    let sig = tcx.normalize_erasing_late_bound_regions(\n+        ty::ParamEnv::reveal_all(),\n+        &callee_ty.fn_sig(tcx),\n+    );\n     let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument"}, {"sha": "96c5bb3b91d2e72cd3b4ec82a374f2229c03a347", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -12,7 +12,6 @@ use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n-use rustc::traits;\n use rustc::mir;\n use abi::{Abi, FnType, ArgType, PassMode};\n use base;\n@@ -282,7 +281,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     ty::TyDynamic(..) => {\n                         let fn_ty = drop_fn.ty(bx.cx.tcx);\n                         let sig = common::ty_fn_sig(bx.cx, fn_ty);\n-                        let sig = bx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                        let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+                            ty::ParamEnv::reveal_all(),\n+                            &sig,\n+                        );\n                         let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n                         args = &args[..1];\n                         (meth::DESTRUCTOR.get_fn(&bx, place.llextra, &fn_ty), fn_ty)\n@@ -419,7 +421,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n                         (Some(ty::Instance::resolve(bx.cx.tcx,\n-                                                    ty::ParamEnv::empty(traits::Reveal::All),\n+                                                    ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n                          None)\n@@ -431,7 +433,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 };\n                 let def = instance.map(|i| i.def);\n                 let sig = callee.layout.ty.fn_sig(bx.tcx());\n-                let sig = bx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+                    ty::ParamEnv::reveal_all(),\n+                    &sig,\n+                );\n                 let abi = sig.abi;\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves."}, {"sha": "977c7c983d6f2458dd4eb0e08b54897de84f2837", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -12,7 +12,6 @@ use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstVal, ConstEvalErr};\n use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n-use rustc::traits;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{Allocation, GlobalId, MemoryPointer, PrimVal, Value as MiriValue};\n@@ -126,7 +125,7 @@ pub fn trans_static_initializer<'a, 'tcx>(\n         instance,\n         promoted: None\n     };\n-    let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+    let param_env = ty::ParamEnv::reveal_all();\n     cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc_id = cx\n@@ -152,7 +151,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         match constant.val {\n             ConstVal::Unevaluated(def_id, ref substs) => {\n                 let tcx = bx.tcx();\n-                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let param_env = ty::ParamEnv::reveal_all();\n                 let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n                 let cid = GlobalId {\n                     instance,\n@@ -172,7 +171,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n         match constant.literal {\n             mir::Literal::Promoted { index } => {\n-                let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+                let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n                     instance: self.instance,\n                     promoted: Some(index),\n@@ -201,7 +200,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 let values: Result<Vec<ValueRef>, _> = (0..fields).map(|field| {\n                     let field = const_val_field(\n                         bx.tcx(),\n-                        ty::ParamEnv::empty(traits::Reveal::All),\n+                        ty::ParamEnv::reveal_all(),\n                         self.instance,\n                         None,\n                         mir::Field::new(field as usize),"}, {"sha": "0533b04a0c1d88a0897ae897b960f94b4a02f494", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -16,7 +16,6 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n-use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n@@ -108,9 +107,13 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n+        where T: TypeFoldable<'tcx>\n     {\n-        self.cx.tcx.trans_apply_param_substs(self.param_substs, value)\n+        self.cx.tcx.subst_and_normalize_erasing_regions(\n+            self.param_substs,\n+            ty::ParamEnv::reveal_all(),\n+            value,\n+        )\n     }\n \n     pub fn set_debug_loc(&mut self, bx: &Builder, source_info: mir::SourceInfo) {"}, {"sha": "f37114ee4acd1a16f4f4254273e7c7a29db7f0df", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -258,7 +258,10 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                     cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n                 }\n                 ty::TyFnPtr(sig) => {\n-                    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+                    let sig = cx.tcx.normalize_erasing_late_bound_regions(\n+                        ty::ParamEnv::reveal_all(),\n+                        &sig,\n+                    );\n                     FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::from_bytes(0))"}, {"sha": "b6459b624104fd038e8e7875433226ba0a7d78df", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -501,7 +501,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty::TraitContainer(_) => tcx.mk_self_type()\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n-        let param_env = ty::ParamEnv::empty(Reveal::All);\n+        let param_env = ty::ParamEnv::reveal_all();\n \n         tcx.infer_ctxt().enter(|infcx| {\n             let self_arg_ty = tcx.liberate_late_bound_regions(\n@@ -759,7 +759,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+        let param_env = ty::ParamEnv::empty();\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n "}, {"sha": "67c9832cbf9f467337e57e6d6894822b02096eb2", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -16,10 +16,10 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, Reveal, ObligationCause};\n+use rustc::traits::{self, ObligationCause};\n use util::common::ErrorReported;\n-use util::nodemap::FxHashSet;\n \n+use syntax::ast;\n use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identified by\n@@ -126,7 +126,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         // it did the wrong thing, so I chose to preserve existing\n         // behavior, since it ought to be simply more\n         // conservative. -nmatsakis\n-        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty(Reveal::UserFacing));\n+        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n         infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &outlives_env);\n         Ok(())\n@@ -282,6 +282,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n+    body_id: ast::NodeId,\n     scope: region::Scope)\n     -> Result<(), ErrorReported>\n {\n@@ -297,46 +298,15 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     };\n     let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n     let origin = || infer::SubregionOrigin::SafeDestructor(span);\n-\n-    let ty = rcx.fcx.resolve_type_vars_if_possible(&ty);\n-    let for_ty = ty;\n-    let mut types = vec![(ty, 0)];\n-    let mut known = FxHashSet();\n-    while let Some((ty, depth)) = types.pop() {\n-        let ty::DtorckConstraint {\n-            dtorck_types, outlives\n-        } = rcx.tcx.dtorck_constraint_for_ty(span, for_ty, depth, ty)?;\n-\n-        for ty in dtorck_types {\n-            let ty = rcx.fcx.normalize_associated_types_in(span, &ty);\n-            let ty = rcx.fcx.resolve_type_vars_with_obligations(ty);\n-            let ty = rcx.fcx.resolve_type_and_region_vars_if_possible(&ty);\n-            match ty.sty {\n-                // All parameters live for the duration of the\n-                // function.\n-                ty::TyParam(..) => {}\n-\n-                // A projection that we couldn't resolve - it\n-                // might have a destructor.\n-                ty::TyProjection(..) | ty::TyAnon(..) => {\n-                    rcx.type_must_outlive(origin(), ty, parent_scope);\n-                }\n-\n-                _ => {\n-                    if let None = known.replace(ty) {\n-                        types.push((ty, depth+1));\n-                    }\n-                }\n-            }\n-        }\n-\n-        for outlive in outlives {\n-            match outlive.unpack() {\n-                UnpackedKind::Lifetime(lt) => rcx.sub_regions(origin(), parent_scope, lt),\n-                UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n-            }\n+    let cause = &ObligationCause::misc(span, body_id);\n+    let infer_ok = rcx.infcx.at(cause, rcx.fcx.param_env).dropck_outlives(ty);\n+    debug!(\"dropck_outlives = {:#?}\", infer_ok);\n+    let kinds = rcx.fcx.register_infer_ok_obligations(infer_ok);\n+    for kind in kinds {\n+        match kind.unpack() {\n+            UnpackedKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n+            UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n         }\n     }\n-\n     Ok(())\n }"}, {"sha": "48591998a1fb8972eeccfb76dae25aa578374fe9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -3997,7 +3997,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprRepeat(ref element, count) => {\n             let count_def_id = tcx.hir.body_owner_def_id(count);\n-            let param_env = ty::ParamEnv::empty(traits::Reveal::UserFacing);\n+            let param_env = ty::ParamEnv::empty();\n             let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n             let instance = ty::Instance::resolve(\n                 tcx.global_tcx(),"}, {"sha": "9ed4ab45a1ba7dd19c22d9a5e3ebd95e76107e9f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -411,8 +411,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n             let typ = self.resolve_node_type(hir_id);\n+            let body_id = self.body_id;\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, var_scope);\n+                self, typ, span, body_id, var_scope);\n         })\n     }\n }\n@@ -884,8 +885,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n+                        let body_id = self.body_id;\n                         let _ = dropck::check_safety_of_destructor_if_necessary(\n-                            self, typ, span, rvalue_scope);\n+                            self, typ, span, body_id, rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n                     _ => {"}, {"sha": "ea90c35cb8f2ef548608a8dca7be8ae12e14092d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -110,7 +110,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode};\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -158,7 +158,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n-        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+        let param_env = ty::ParamEnv::empty();\n         let mut fulfill_cx = FulfillmentContext::new();\n         match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {"}, {"sha": "2a4e92034de844e93c5ff4aa881f7d532d3704c2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -423,6 +423,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // way early-bound regions do, so we skip them here.\n             }\n \n+            ty::ReCanonical(_) |\n             ty::ReFree(..) |\n             ty::ReClosureBound(..) |\n             ty::ReScope(..) |"}, {"sha": "ff281a53ab7e4b18c383d2a9fe9bcc261868bb5b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -1490,6 +1490,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::ReSkolemized(..) |\n             ty::ReEmpty |\n             ty::ReClosureBound(_) |\n+            ty::ReCanonical(_) |\n             ty::ReErased => None\n         }\n     }"}, {"sha": "87fee986de76848269302a70ab310789e888c441", "filename": "src/test/ui/issue-48132.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fissue-48132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fissue-48132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-48132.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #48132. This was failing due to problems around\n+// the projection caching and dropck type enumeration.\n+\n+// run-pass\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+struct Inner<I, V> {\n+    iterator: I,\n+    item: V,\n+}\n+\n+struct Outer<I: Iterator> {\n+    inner: Inner<I, I::Item>,\n+}\n+\n+fn outer<I>(iterator: I) -> Outer<I>\n+where I: Iterator,\n+      I::Item: Default,\n+{\n+    Outer {\n+        inner: Inner {\n+            iterator: iterator,\n+            item: Default::default(),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    outer(std::iter::once(&1).cloned());\n+}"}, {"sha": "745b59e0658f1dc77d6dc88bda141fa279a7a9d0", "filename": "src/test/ui/issue-48179.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fissue-48179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fissue-48179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-48179.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #48132. This was failing due to problems around\n+// the projection caching and dropck type enumeration.\n+\n+// run-pass\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+pub struct Container<T: Iterator> {\n+    value: Option<T::Item>,\n+}\n+\n+impl<T: Iterator> Container<T> {\n+    pub fn new(iter: T) -> Self {\n+        panic!()\n+    }\n+}\n+\n+pub struct Wrapper<'a> {\n+    content: &'a Content,\n+}\n+\n+impl<'a, 'de> Wrapper<'a> {\n+    pub fn new(content: &'a Content) -> Self {\n+        Wrapper {\n+            content: content,\n+        }\n+    }\n+}\n+\n+pub struct Content;\n+\n+fn crash_it(content: Content) {\n+    let items = vec![content];\n+    let map = items.iter().map(|ref o| Wrapper::new(o));\n+\n+    let mut map_visitor = Container::new(map);\n+\n+}\n+\n+fn main() {}"}, {"sha": "a0d1faf1f0e84486d934294e07bc0e41db8afdb8", "filename": "src/test/ui/nll/issue-31567.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-31567.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #31567: cached results of projections were\n+// causing region relations not to be enforced at all the places where\n+// they have to be enforced.\n+\n+#![feature(nll)]\n+\n+struct VecWrapper<'a>(&'a mut S);\n+\n+struct S(Box<u32>);\n+\n+fn get_dangling<'a>(v: VecWrapper<'a>) -> &'a u32 {\n+    let s_inner: &'a S = &*v.0; //~ ERROR `*v.0` does not live long enough\n+    &s_inner.0\n+}\n+\n+impl<'a> Drop for VecWrapper<'a> {\n+    fn drop(&mut self) {\n+        *self.0 = S(Box::new(0));\n+    }\n+}\n+\n+fn main() {\n+    let mut s = S(Box::new(11));\n+    let vw = VecWrapper(&mut s);\n+    let dangling = get_dangling(vw);\n+    println!(\"{}\", dangling);\n+}"}, {"sha": "e0ff653e2b4d45983b0e6514176116b9725f8596", "filename": "src/test/ui/nll/issue-31567.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-31567.stderr?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `*v.0` does not live long enough\n+  --> $DIR/issue-31567.rs:22:26\n+   |\n+LL |     let s_inner: &'a S = &*v.0; //~ ERROR `*v.0` does not live long enough\n+   |                          ^^^^^ borrowed value does not live long enough\n+LL |     &s_inner.0\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 21:1...\n+  --> $DIR/issue-31567.rs:21:1\n+   |\n+LL | fn get_dangling<'a>(v: VecWrapper<'a>) -> &'a u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}, {"sha": "c962f193cd5b09043e55b0253f238db486d754a1", "filename": "src/test/ui/nll/issue-47470.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-47470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-47470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-47470.rs?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #47470: cached results of projections were\n+// causing region relations not to be enforced at all the places where\n+// they have to be enforced.\n+\n+#![feature(nll)]\n+\n+struct Foo<'a>(&'a ());\n+trait Bar {\n+    type Assoc;\n+    fn get(self) -> Self::Assoc;\n+}\n+\n+impl<'a> Bar for Foo<'a> {\n+    type Assoc = &'a u32;\n+    fn get(self) -> Self::Assoc {\n+        let local = 42;\n+        &local //~ ERROR `local` does not live long enough\n+    }\n+}\n+\n+fn main() {\n+    let f = Foo(&()).get();\n+    println!(\"{}\", f);\n+}"}, {"sha": "1356461a6e410c799165026b70d7299fd685d8ba", "filename": "src/test/ui/nll/issue-47470.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-47470.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c4ff22a2d745097197c659ef9e3b04b8ceeb070/src%2Ftest%2Fui%2Fnll%2Fissue-47470.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-47470.stderr?ref=8c4ff22a2d745097197c659ef9e3b04b8ceeb070", "patch": "@@ -0,0 +1,17 @@\n+error[E0597]: `local` does not live long enough\n+  --> $DIR/issue-47470.rs:27:9\n+   |\n+LL |         &local //~ ERROR `local` does not live long enough\n+   |         ^^^^^^ borrowed value does not live long enough\n+LL |     }\n+   |     - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 23:1...\n+  --> $DIR/issue-47470.rs:23:1\n+   |\n+LL | impl<'a> Bar for Foo<'a> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}]}