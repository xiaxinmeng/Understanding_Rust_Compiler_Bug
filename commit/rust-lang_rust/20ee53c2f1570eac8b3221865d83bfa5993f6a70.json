{"sha": "20ee53c2f1570eac8b3221865d83bfa5993f6a70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZWU1M2MyZjE1NzBlYWM4YjMyMjE4NjVkODNiZmE1OTkzZjZhNzA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-07T00:42:29Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-07T03:55:20Z"}, "message": "Improve path resolution diagnostics", "tree": {"sha": "d608ce79e9b1c93041a00a8db3dd158a8eb7651c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d608ce79e9b1c93041a00a8db3dd158a8eb7651c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ee53c2f1570eac8b3221865d83bfa5993f6a70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ee53c2f1570eac8b3221865d83bfa5993f6a70", "html_url": "https://github.com/rust-lang/rust/commit/20ee53c2f1570eac8b3221865d83bfa5993f6a70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ee53c2f1570eac8b3221865d83bfa5993f6a70/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd331e16642363c333804fe3322ae6bc0be8fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd331e16642363c333804fe3322ae6bc0be8fbc", "html_url": "https://github.com/rust-lang/rust/commit/7fd331e16642363c333804fe3322ae6bc0be8fbc"}], "stats": {"total": 133, "additions": 67, "deletions": 66}, "files": [{"sha": "e8adb1d94ba4db6199740959d5da4c63808ed58b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/20ee53c2f1570eac8b3221865d83bfa5993f6a70/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ee53c2f1570eac8b3221865d83bfa5993f6a70/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=20ee53c2f1570eac8b3221865d83bfa5993f6a70", "patch": "@@ -1716,9 +1716,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Some(def) =>\n+                                Ok(def) =>\n                                     self.record_def(item.id, PathResolution::new(def, 0)),\n-                                None => {\n+                                Err(true) => self.record_def(item.id, err_path_resolution()),\n+                                Err(false) => {\n                                     resolve_error(self,\n                                                   prefix.span,\n                                                   ResolutionError::FailedToResolve(\n@@ -1837,7 +1838,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                trait_path: &Path,\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n-        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n+        self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n             if let Def::Trait(_) = path_res.base_def {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n@@ -1857,9 +1858,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n                 err.emit();\n-                Err(())\n+                Err(true)\n             }\n-        } else {\n+        }).map_err(|error_reported| {\n+            if error_reported { return }\n \n             // find possible candidates\n             let trait_name = trait_path.segments.last().unwrap().identifier.name;\n@@ -1882,8 +1884,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 );\n \n             resolve_error(self, trait_path.span, error);\n-            Err(())\n-        }\n+        })\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n@@ -1892,15 +1893,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &hir::WherePredicate::BoundPredicate(_) |\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS);\n-                    if let Some(PathResolution { base_def: Def::TyParam(..), .. }) = path_res {\n-                        self.record_def(eq_pred.id, path_res.unwrap());\n-                    } else {\n-                        resolve_error(self,\n-                                      eq_pred.span,\n-                                      ResolutionError::UndeclaredAssociatedType);\n+                    self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS).and_then(|path_res| {\n+                        if let PathResolution { base_def: Def::TyParam(..), .. } = path_res {\n+                            Ok(self.record_def(eq_pred.id, path_res))\n+                        } else {\n+                            Err(false)\n+                        }\n+                    }).map_err(|error_reported| {\n                         self.record_def(eq_pred.id, err_path_resolution());\n-                    }\n+                        if error_reported { return }\n+                        resolve_error(self, eq_pred.span, ResolutionError::UndeclaredAssociatedType);\n+                    }).unwrap_or(());\n                 }\n             }\n         }\n@@ -2170,21 +2173,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                match resolution {\n-                    Some(def) => {\n-                        // Write the result into the def map.\n-                        debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                               path_names_to_string(path, 0),\n-                               ty.id,\n-                               def);\n-                        self.record_def(ty.id, def);\n-                    }\n-                    None => {\n-                        self.record_def(ty.id, err_path_resolution());\n-\n-                        // Keep reporting some errors even if they're ignored above.\n-                        self.resolve_path(ty.id, path, 0, TypeNS);\n+                if let Some(def) = resolution {\n+                    // Write the result into the def map.\n+                    debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                           path_names_to_string(path, 0), ty.id, def);\n+                    self.record_def(ty.id, def);\n+                } else {\n+                    self.record_def(ty.id, err_path_resolution());\n \n+                    // Keep reporting some errors even if they're ignored above.\n+                    if let Err(true) = self.resolve_path(ty.id, path, 0, TypeNS) {\n+                        // `resolve_path` already reported the error\n+                    } else {\n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n                         } else {\n@@ -2483,11 +2483,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatKind::Struct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, 0, TypeNS) {\n-                        Some(definition) => {\n+                        Ok(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n-                        result => {\n-                            debug!(\"(resolving pattern) didn't find struct def: {:?}\", result);\n+                        Err(true) => self.record_def(pattern.id, err_path_resolution()),\n+                        Err(false) => {\n                             resolve_error(\n                                 self,\n                                 path.span,\n@@ -2554,14 +2554,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace)\n+            this.resolve_path(id, path, 0, namespace).ok()\n         });\n         for depth in 1..max_assoc_types {\n             if resolution.is_some() {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS);\n+                resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n             });\n         }\n         if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n@@ -2574,7 +2574,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `middle::def::PathResolution` for more info.\n     fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n-                    -> Option<PathResolution> {\n+                    -> Result<PathResolution, bool /* true if an error was reported */ > {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n@@ -2613,14 +2613,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let unqualified_def = resolve_identifier_with_fallback(self, true);\n-            return unqualified_def.and_then(|def| self.adjust_local_def(def, span)).map(mk_res);\n+            let def = resolve_identifier_with_fallback(self, true).ok_or(false);\n+            return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n         }\n \n         let unqualified_def = resolve_identifier_with_fallback(self, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n-            (Some(d), Some(ref ud)) if d == ud.def => {\n+            (Ok(d), Some(ref ud)) if d == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2741,7 +2741,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Option<Def> {\n+                                    -> Result<Def, bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2762,9 +2762,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                return None;\n+                return Err(true);\n             }\n-            Indeterminate => return None,\n+            Indeterminate => return Err(false),\n             Success(resulting_module) => {\n                 containing_module = resulting_module;\n             }\n@@ -2775,7 +2775,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result.success().map(|binding| {\n             self.check_privacy(containing_module, name, binding, span);\n             binding.def().unwrap()\n-        })\n+        }).ok_or(false)\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2784,7 +2784,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Option<Def> {\n+                                   -> Result<Def, bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2810,10 +2810,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                return None;\n+                return Err(true);\n             }\n \n-            Indeterminate => return None,\n+            Indeterminate => return Err(false),\n \n             Success(resulting_module) => {\n                 containing_module = resulting_module;\n@@ -2825,7 +2825,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result.success().map(|binding| {\n             self.check_privacy(containing_module, name, binding, span);\n             binding.def().unwrap()\n-        })\n+        }).ok_or(false)\n     }\n \n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n@@ -3040,25 +3040,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     });\n \n                     self.record_def(expr.id, err_path_resolution());\n-                    match type_res.map(|r| r.base_def) {\n-                        Some(Def::Struct(..)) => {\n-                            let mut err = resolve_struct_error(self,\n-                                expr.span,\n-                                ResolutionError::StructVariantUsedAsFunction(&path_name));\n-\n-                            let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n-                                              path_name);\n-                            if self.emit_errors {\n-                                err.fileline_help(expr.span, &msg);\n-                            } else {\n-                                err.span_help(expr.span, &msg);\n-                            }\n-                            err.emit();\n-                        }\n-                        _ => {\n-                            // Keep reporting some errors even if they're ignored above.\n-                            self.resolve_path(expr.id, path, 0, ValueNS);\n \n+                    if let Ok(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n+                        let error_variant = ResolutionError::StructVariantUsedAsFunction(&path_name);\n+                        let mut err = resolve_struct_error(self, expr.span, error_variant);\n+\n+                        let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n+                                          path_name);\n+\n+                        if self.emit_errors {\n+                            err.fileline_help(expr.span, &msg);\n+                        } else {\n+                            err.span_help(expr.span, &msg);\n+                        }\n+                        err.emit();\n+                    } else {\n+                        // Keep reporting some errors even if they're ignored above.\n+                        if let Err(true) = self.resolve_path(expr.id, path, 0, ValueNS) {\n+                            // `resolve_path` already reported the error\n+                        } else {\n                             let mut method_scope = false;\n                             self.value_ribs.iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n@@ -3132,8 +3132,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n                 match self.resolve_path(expr.id, path, 0, TypeNS) {\n-                    Some(definition) => self.record_def(expr.id, definition),\n-                    None => {\n+                    Ok(definition) => self.record_def(expr.id, definition),\n+                    Err(true) => self.record_def(expr.id, err_path_resolution()),\n+                    Err(false) => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n \n                         resolve_error(self,"}]}