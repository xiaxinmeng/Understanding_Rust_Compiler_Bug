{"sha": "c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYTc0ZDg3YmQ1YThmOGJkMzIzNTBmNzRhM2ZhNGZiMWY5YmY1ZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-12-05T23:13:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-08T23:41:53Z"}, "message": "Implement GLB algorithm. (Issue #2263)\n\nr=brson", "tree": {"sha": "d57ad7fd251f4dfbe2d43e32ca160372503e17a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d57ad7fd251f4dfbe2d43e32ca160372503e17a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "html_url": "https://github.com/rust-lang/rust/commit/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b71d14442a1942ecf45fc4ac619f473e8367ae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b71d14442a1942ecf45fc4ac619f473e8367ae6", "html_url": "https://github.com/rust-lang/rust/commit/3b71d14442a1942ecf45fc4ac619f473e8367ae6"}], "stats": {"total": 624, "additions": 517, "deletions": 107}, "files": [{"sha": "24095ebfe003a5d94cf5661b994928baa6c3164e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -188,6 +188,9 @@ fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n         w.write_char('|');\n         enc_bound_region(w, cx, *br);\n       }\n+      ty::br_fresh(id) => {\n+        w.write_uint(id);\n+      }\n     }\n }\n "}, {"sha": "c97553ce1c073a4e7edfb3c2794242e5ea8f65ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -418,7 +418,8 @@ impl ty::Region: tr {\n impl ty::bound_region: tr {\n     fn tr(xcx: extended_decode_ctxt) -> ty::bound_region {\n         match self {\n-            ty::br_anon(_) | ty::br_named(_) | ty::br_self => self,\n+            ty::br_anon(_) | ty::br_named(_) | ty::br_self |\n+            ty::br_fresh(_) => self,\n             ty::br_cap_avoid(id, br) => ty::br_cap_avoid(xcx.tr_id(id),\n                                                          @br.tr(xcx))\n         }"}, {"sha": "2880e4b770e1650dcc56e2b704d98a04f8aa3396", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -72,7 +72,7 @@ export expr_ty_params_and_ty;\n export expr_is_lval, expr_kind;\n export ExprKind, LvalueExpr, RvalueDatumExpr, RvalueDpsExpr, RvalueStmtExpr;\n export field_ty;\n-export fold_ty, fold_sty_to_ty, fold_region, fold_regions;\n+export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_sig;\n export apply_op_on_t_to_ty_fn;\n export fold_regions_and_ty, walk_regions_and_ty;\n export field;\n@@ -145,7 +145,7 @@ export ty_struct;\n export Region, bound_region, encl_region;\n export re_bound, re_free, re_scope, re_static, re_infer;\n export ReVar, ReSkolemized;\n-export br_self, br_anon, br_named, br_cap_avoid;\n+export br_self, br_anon, br_named, br_cap_avoid, br_fresh;\n export get, type_has_params, type_needs_infer, type_has_regions;\n export type_is_region_ptr;\n export type_id;\n@@ -606,6 +606,9 @@ enum bound_region {\n     /// Named region parameters for functions (a in &a/T)\n     br_named(ast::ident),\n \n+    /// Fresh bound identifiers created during GLB computations.\n+    br_fresh(uint),\n+\n     /**\n      * Handles capture-avoiding substitution in a rather subtle case.  If you\n      * have a closure whose argument types are being inferred based on the\n@@ -1311,6 +1314,17 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n     mk_t(tcx, fold_sty(sty, foldop))\n }\n \n+fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n+    let args = do sig.inputs.map |arg| {\n+        { mode: arg.mode, ty: fldop(arg.ty) }\n+    };\n+\n+    FnSig {\n+        inputs: move args,\n+        output: fldop(sig.output)\n+    }\n+}\n+\n fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n@@ -1489,8 +1503,8 @@ fn apply_op_on_t_to_ty_fn(\n fn fold_regions(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region, in_fn: bool) -> Region) -> t {\n-\n+    fldr: fn(r: Region, in_fn: bool) -> Region) -> t\n+{\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: fn(Region, bool) -> Region) -> t {\n         if !type_has_regions(ty) { return ty; }\n@@ -2744,7 +2758,10 @@ impl bound_region : to_bytes::IterBytes {\n           to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n \n           ty::br_cap_avoid(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f)\n+          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f),\n+\n+          ty::br_fresh(ref x) =>\n+          to_bytes::iter_bytes_2(&4u8, x, lsb0, f)\n         }\n     }\n }\n@@ -4493,6 +4510,12 @@ impl bound_region : cmp::Eq {\n                     _ => false\n                 }\n             }\n+            br_fresh(e0a) => {\n+                match (*other) {\n+                    br_fresh(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n         }\n     }\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }"}, {"sha": "8eb3e0336dfb294172af0aeb44944753979a835a", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -80,7 +80,7 @@ enum Assign = combine_fields;\n \n impl Assign {\n     fn tys(a: ty::t, b: ty::t) -> ares {\n-        debug!(\"Assign.tys(%s -> %s)\",\n+        debug!(\"Assign.tys(%s => %s)\",\n                a.to_str(self.infcx),\n                b.to_str(self.infcx));\n         let _r = indenter();\n@@ -139,7 +139,7 @@ priv impl Assign {\n         a: ty::t, b: ty::t,\n         +a_bnd: Option<ty::t>, +b_bnd: Option<ty::t>) -> ares {\n \n-        debug!(\"Assign.assign_tys_or_sub(%s -> %s, %s -> %s)\",\n+        debug!(\"Assign.assign_tys_or_sub(%s => %s, %s => %s)\",\n                a.to_str(self.infcx), b.to_str(self.infcx),\n                a_bnd.to_str(self.infcx), b_bnd.to_str(self.infcx));\n         let _r = indenter();"}, {"sha": "f790939f4e7d231aceb8fd1fe913d77b32adb6a7", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -69,6 +69,7 @@ trait combine {\n     fn infcx() -> infer_ctxt;\n     fn tag() -> ~str;\n     fn a_is_expected() -> bool;\n+    fn span() -> span;\n \n     fn sub() -> Sub;\n     fn lub() -> Lub;"}, {"sha": "920b058770acb40aedbd99ab56e3097e050245bf", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -15,6 +15,8 @@ use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::ToStr;\n \n+use std::list;\n+\n use syntax::ast::{Many, Once};\n \n enum Glb = combine_fields;  // \"greatest lower bound\" (common subtype)\n@@ -23,6 +25,7 @@ impl Glb: combine {\n     fn infcx() -> infer_ctxt { self.infcx }\n     fn tag() -> ~str { ~\"glb\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n+    fn span() -> span { self.span }\n \n     fn sub() -> Sub { Sub(*self) }\n     fn lub() -> Lub { Lub(*self) }\n@@ -144,7 +147,122 @@ impl Glb: combine {\n     }\n \n     fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+        // Note: this is a subtle algorithm.  For a full explanation,\n+        // please see the large comment in `region_inference.rs`.\n+\n+        debug!(\"%s.fns(%?, %?)\",\n+               self.tag(), a.to_str(self.infcx), b.to_str(self.infcx));\n+        let _indenter = indenter();\n+\n+        // Take a snapshot.  We'll never roll this back, but in later\n+        // phases we do want to be able to examine \"all bindings that\n+        // were created as part of this type comparison\", and making a\n+        // snapshot is a convenient way to do that.\n+        let snapshot = self.infcx.region_vars.start_snapshot();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let (a_with_fresh, a_isr) =\n+            self.infcx.replace_bound_regions_with_fresh_regions(\n+                self.span, a);\n+        let a_vars = var_ids(&self, a_isr);\n+        let (b_with_fresh, b_isr) =\n+            self.infcx.replace_bound_regions_with_fresh_regions(\n+                self.span, b);\n+        let b_vars = var_ids(&self, b_isr);\n+\n+        // Collect constraints.\n+        let fn_ty0 = if_ok!(super_fns(&self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"fn_ty0 = %s\", fn_ty0.to_str(self.infcx));\n+\n+        // Generalize the regions appearing in fn_ty0 if possible\n+        let new_vars =\n+            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n+        let fn_ty1 =\n+            self.infcx.fold_regions_in_sig(\n+                &fn_ty0,\n+                |r, _in_fn| generalize_region(&self, snapshot,\n+                                              new_vars, a_isr, a_vars, b_vars,\n+                                              r));\n+        debug!(\"fn_ty1 = %s\", fn_ty1.to_str(self.infcx));\n+        return Ok(move fn_ty1);\n+\n+        fn generalize_region(self: &Glb,\n+                             snapshot: uint,\n+                             new_vars: &[RegionVid],\n+                             a_isr: isr_alist,\n+                             a_vars: &[RegionVid],\n+                             b_vars: &[RegionVid],\n+                             r0: ty::Region) -> ty::Region {\n+            if !is_var_in_set(new_vars, r0) {\n+                return r0;\n+            }\n+\n+            let tainted = self.infcx.region_vars.tainted(snapshot, r0);\n+\n+            let mut a_r = None, b_r = None, only_new_vars = true;\n+            for tainted.each |r| {\n+                if is_var_in_set(a_vars, *r) {\n+                    if a_r.is_some() {\n+                        return fresh_bound_variable(self);\n+                    } else {\n+                        a_r = Some(*r);\n+                    }\n+                } else if is_var_in_set(b_vars, *r) {\n+                    if b_r.is_some() {\n+                        return fresh_bound_variable(self);\n+                    } else {\n+                        b_r = Some(*r);\n+                    }\n+                } else if !is_var_in_set(new_vars, *r) {\n+                    only_new_vars = false;\n+                }\n+            }\n+\n+                // NB---I do not believe this algorithm computes\n+                // (necessarily) the GLB.  As written it can\n+                // spuriously fail.  In particular, if there is a case\n+                // like: fn(fn(&a)) and fn(fn(&b)), where a and b are\n+                // free, it will return fn(&c) where c = GLB(a,b).  If\n+                // however this GLB is not defined, then the result is\n+                // an error, even though something like\n+                // \"fn<X>(fn(&X))\" where X is bound would be a\n+                // subtype of both of those.\n+                //\n+                // The problem is that if we were to return a bound\n+                // variable, we'd be computing a lower-bound, but not\n+                // necessarily the *greatest* lower-bound.\n+\n+            if a_r.is_some() && b_r.is_some() && only_new_vars {\n+                // Related to exactly one bound variable from each fn:\n+                return rev_lookup(self, a_isr, a_r.get());\n+            } else if a_r.is_none() && b_r.is_none() {\n+                // Not related to bound variables from either fn:\n+                return r0;\n+            } else {\n+                // Other:\n+                return fresh_bound_variable(self);\n+            }\n+        }\n+\n+        fn rev_lookup(self: &Glb,\n+                      a_isr: isr_alist,\n+                      r: ty::Region) -> ty::Region\n+        {\n+            for list::each(a_isr) |pair| {\n+                let (a_br, a_r) = *pair;\n+                if a_r == r {\n+                    return ty::re_bound(a_br);\n+                }\n+            }\n+\n+            self.infcx.tcx.sess.span_bug(\n+                self.span,\n+                fmt!(\"could not find original bound region for %?\", r));\n+        }\n+\n+        fn fresh_bound_variable(self: &Glb) -> ty::Region {\n+            self.infcx.region_vars.new_bound()\n+        }\n     }\n \n     fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {"}, {"sha": "ea994c238c61d41f5ff9cd9ecfe2e3efa8c7a779", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -14,6 +14,8 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::unify::*;\n use middle::typeck::infer::to_str::ToStr;\n \n+use std::list;\n+\n // ______________________________________________________________________\n // Lattice operations on variables\n //\n@@ -158,3 +160,29 @@ fn lattice_var_and_t<L:lattice_ops combine>(\n       }\n     }\n }\n+\n+// ___________________________________________________________________________\n+// Random utility functions used by LUB/GLB when computing LUB/GLB of\n+// fn types\n+\n+fn var_ids<T: combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n+    let mut result = ~[];\n+    for list::each(isr) |pair| {\n+        match pair.second() {\n+            ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n+            r => {\n+                self.infcx().tcx.sess.span_bug(\n+                    self.span(),\n+                    fmt!(\"Found non-region-vid: %?\", r));\n+            }\n+        }\n+    }\n+    return result;\n+}\n+\n+fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n+    match r {\n+        ty::re_infer(ty::ReVar(ref v)) => new_vars.contains(v),\n+        _ => false\n+    }\n+}"}, {"sha": "10ac6a3add9ac3e7a734914ba583d05bc32081b9", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -31,6 +31,7 @@ impl Lub: combine {\n     fn infcx() -> infer_ctxt { self.infcx }\n     fn tag() -> ~str { ~\"lub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n+    fn span() -> span { self.span }\n \n     fn sub() -> Sub { Sub(*self) }\n     fn lub() -> Lub { Lub(*self) }\n@@ -139,12 +140,10 @@ impl Lub: combine {\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n         let fn_ty1 =\n-            ty::apply_op_on_t_to_ty_fn(\n-                self.infcx.tcx, &fn_ty0,\n-                |t| ty::fold_regions(\n-                    self.infcx.tcx, t,\n-                    |r, _in_fn| generalize_region(&self, snapshot,\n-                                                  new_vars, a_isr, r)));\n+            self.infcx.fold_regions_in_sig(\n+                &fn_ty0,\n+                |r, _in_fn| generalize_region(&self, snapshot, new_vars,\n+                                              a_isr, r));\n         return Ok(move fn_ty1);\n \n         fn generalize_region(self: &Lub,\n@@ -153,7 +152,7 @@ impl Lub: combine {\n                              a_isr: isr_alist,\n                              r0: ty::Region) -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n-            if !is_new_var(new_vars, r0) {\n+            if !is_var_in_set(new_vars, r0) {\n                 debug!(\"generalize_region(r0=%?): not new variable\", r0);\n                 return r0;\n             }\n@@ -163,7 +162,7 @@ impl Lub: combine {\n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n-            if !tainted.all(|r| is_new_var(new_vars, *r)) {\n+            if !tainted.all(|r| is_var_in_set(new_vars, *r)) {\n                 debug!(\"generalize_region(r0=%?): \\\n                         non-new-variables found in %?\",\n                        r0, tainted);\n@@ -190,13 +189,6 @@ impl Lub: combine {\n                 fmt!(\"Region %? is not associated with \\\n                       any bound region from A!\", r0));\n         }\n-\n-        fn is_new_var(new_vars: &[RegionVid], r: ty::Region) -> bool {\n-            match r {\n-                ty::re_infer(ty::ReVar(ref v)) => new_vars.contains(v),\n-                _ => false\n-            }\n-        }\n     }\n \n     fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {"}, {"sha": "7d6a2c4366e22784fff7b5b59f3c03bf22770293", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -799,5 +799,16 @@ impl infer_ctxt {\n         (fn_ty, isr)\n     }\n \n+    fn fold_regions_in_sig(\n+        &self,\n+        fn_ty: &ty::FnTy,\n+        fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnTy\n+    {\n+        let sig = do ty::fold_sig(&fn_ty.sig) |t| {\n+            ty::fold_regions(self.tcx, t, fldr)\n+        };\n+        ty::FnTyBase {meta: fn_ty.meta, sig: sig}\n+    }\n+\n }\n "}, {"sha": "e5ca30a3e2ce3228990b56f7955ff2c230592d6a", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 185, "deletions": 67, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -337,6 +337,61 @@ therefore considering subtyping and in particular does not consider\n LUB or GLB computation.  We have to consider this.  Here is the\n algorithm I implemented.\n \n+First though, let's discuss what we are trying to compute in more\n+detail.  The LUB is basically the \"common supertype\" and the GLB is\n+\"common subtype\"; one catch is that the LUB should be the\n+*most-specific* common supertype and the GLB should be *most general*\n+common subtype (as opposed to any common supertype or any common\n+subtype).\n+\n+Anyway, to help clarify, here is a table containing some\n+function pairs and their LUB/GLB:\n+\n+```\n+Type 1              Type 2              LUB               GLB\n+fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n+fn(&A)              fn(&X)              --                fn<a>(&a)\n+fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n+fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n+```\n+\n+### Conventions\n+\n+I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n+letters for free regions (`&A`).  Region variables written with a\n+dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n+bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n+\n+### High-level summary\n+\n+Both the LUB and the GLB algorithms work in a similar fashion.  They\n+begin by replacing all bound regions (on both sides) with fresh region\n+inference variables.  Therefore, both functions are converted to types\n+that contain only free regions.  We can then compute the LUB/GLB in a\n+straightforward way, as described in `combine.rs`.  This results in an\n+interim type T.  The algorithms then examine the regions that appear\n+in T and try to, in some cases, replace them with bound regions to\n+yield the final result.\n+\n+To decide whether to replace a region `R` that appears in `T` with a\n+bound region, the algorithms make use of two bits of information.\n+First is a set `V` that contains all region variables created as part\n+of the LUB/GLB computation. `V` will contain the region variables\n+created to replace the bound regions in the input types, but it also\n+contains 'intermediate' variables created to represent the LUB/GLB of\n+individual regions.  Basically, when asked to compute the LUB/GLB of a\n+region variable with another region, the inferencer cannot oblige\n+immediately since the valuese of that variables are not known.\n+Therefore, it creates a new variable that is related to the two\n+regions.  For example, the LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.  So `V` will contain these intermediate variables as well.\n+\n+The other important factor in deciding how to replace a region in T is\n+the function `Tainted($r)` which, for a region variable, identifies\n+all regions that the region variable is related to in some way\n+(`Tainted()` made an appearance in the subtype computation as well).\n+\n ### LUB\n \n The LUB algorithm proceeds in three steps:\n@@ -345,47 +400,28 @@ The LUB algorithm proceeds in three steps:\n    inference variables.\n 2. Compute the LUB \"as normal\", meaning compute the GLB of each\n    pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type F.\n-3. Map the regions appearing in `F` using the procedure described below.\n-\n-For each region `R` that appears in `F`, we may need to replace it\n-with a bound region.  Let `V` be the set of fresh variables created as\n-part of the LUB procedure (either in step 1 or step 2).  You may be\n-wondering how variables can be created in step 2.  The answer is that\n-when we are asked to compute the LUB or GLB of two region variables,\n-we do so by producing a new region variable that is related to those\n-two variables.  i.e., The LUB of two variables `$x` and `$y` is a\n-fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-<= $z`.\n-\n-To decide how to replace a region `R`, we must examine `Tainted(R)`.\n-This function searches through the constraints which were generated\n-when computing the bounds of all the argument and return types and\n-produces a list of all regions to which `R` is related, directly or\n-indirectly.\n-\n-If `R` is not in `V` or `Tainted(R)` contains any region that is not\n-in `V`, then `R` is not replaced (that is, `R` is mapped to itself).\n-Otherwise, if `Tainted(R)` is a subset of `V`, then we select the\n-earliest variable in `Tainted(R)` that originates from the left-hand\n-side and replace `R` with a bound version of that variable.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn(&a)`.\n-In this case, `&a` will be replaced with `$a` (the $ indicates an\n-inference variable) which will be linked to the free region `&A`, and\n-hence `V = { $a }` and `Tainted($a) = { &A }`.  Since `$a` is not a\n-member of `V`, we leave `$a` as is.  When region inference happens,\n-`$a` will be resolved to `&A`, as we wanted.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn(&a)`.\n-In this case, `&a` will be replaced with `$a` (the $ indicates an\n-inference variable) which will be linked to the free region `&A`, and\n-hence `V = { $a }` and `Tainted($a) = { $a, &A }`.  Since `&A` is not a\n-member of `V`, we leave `$a` as is.  When region inference happens,\n-`$a` will be resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.\n-In this case, we'll end up with a graph that looks like:\n+   so forth.  Combine those to a new function type `F`.\n+3. Replace each region `R` that appears in `F` as follows:\n+   - Let `V` be the set of variables created during the LUB\n+     computational steps 1 and 2, as described in the previous section.\n+   - If `R` is not in `V`, replace `R` with itself.\n+   - If `Tainted(R)` contains a region that is not in `V`,\n+     replace `R` with itself.\n+   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n+     from the left-hand side and replace `R` with the bound region that\n+     this variable was a replacement for.\n+\n+So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n+In this case, `&a` will be replaced with `$a` and the interim LUB type\n+`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n+{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n+`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n+we leave `$b` as is.  When region inference happens, `$b` will be\n+resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n+this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n+&h)` and a graph that looks like:\n \n ```\n      $a        $b     *--$x\n@@ -399,8 +435,8 @@ the LUB/GLB of things requiring inference.  This means that `V` and\n `Tainted` will look like:\n \n ```\n-V = {$a, $b, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $x }\n+V = {$a, $b, $g, $h, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n ```\n \n Therefore we replace both `$g` and `$h` with `$a`, and end up\n@@ -413,40 +449,90 @@ in computing the replacements for the various variables. For each\n region `R` that appears in the type `F`, we again compute `Tainted(R)`\n and examine the results:\n \n-1. If `Tainted(R) = {R}` is a singleton set, replace `R` with itself.\n+1. If `R` is not in `V`, it is not replaced.\n 2. Else, if `Tainted(R)` contains only variables in `V`, and it\n    contains exactly one variable from the LHS and one variable from\n    the RHS, then `R` can be mapped to the bound version of the\n    variable from the LHS.\n-3. Else, `R` is mapped to a fresh bound variable.\n+3. Else, if `Tainted(R)` contains no variable from the LHS and no\n+   variable from the RHS, then `R` can be mapped to itself.\n+4. Else, `R` is mapped to a fresh bound variable.\n \n These rules are pretty complex.  Let's look at some examples to see\n how they play out.\n \n-Out first example was `fn(&a)` and `fn(&X)`---in\n-this case, the LUB will be a variable `$g`, and `Tainted($g) =\n-{$g,$a,$x}`.  By these rules, we'll replace `$g` with a fresh bound\n-variable, so the result is `fn(&z)`, which is fine.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. XXX\n-\n-The next example is `fn(&a, &b)` and `fn(&x, &x)`. In this case, as\n-before, we'll end up with `F=fn(&g, &h)` where `Tainted($g) =\n-Tainted($h) = {$g, $a, $b, $x}`.  This means that we'll select fresh\n-bound varibales `g` and `h` and wind up with `fn(&g, &h)`.\n+Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n+be replaced with `$a` and we will ultimately compute a\n+(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n+Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n+replacement for `$g` we consult the rules above:\n+- Rule (1) does not apply because `$g \\in V`\n+- Rule (2) does not apply because `&X \\in Tainted($g)`\n+- Rule (3) does not apply because `$a \\in Tainted($g)`\n+- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n+So our final result is `fn(&z)`, which is correct.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n+have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n+Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n+by rule (3), `$g` is mapped to itself, and hence the result is\n+`fn($g)`.  This result is correct (in this case, at least), but it is\n+indicative of a case that *can* lead us into concluding that there is\n+no GLB when in fact a GLB does exist.  See the section \"Questionable\n+Results\" below for more details.\n+\n+The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n+before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n+Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n+we'll select fresh bound variables `y` and `z` and wind up with\n+`fn(&y, &z)`.\n \n For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&x, &x)`.  In this case, we'll get `F=fn(&g,\n-&h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n+$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n $x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`.\n-Horray!\n-\n-### Why are these correct?\n-\n-You may be wondering whether this algorithm is correct.  So am I.  But\n-I believe it is.  (Justification forthcoming, haven't had time to\n-write it)\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n+is the desired result.\n+\n+### Shortcomings and correctness\n+\n+You may be wondering whether this algorithm is correct.  The answer is\n+\"sort of\".  There are definitely cases where they fail to compute a\n+result even though a correct result exists.  I believe, though, that\n+if they succeed, then the result is valid, and I will attempt to\n+convince you.  The basic argument is that the \"pre-replacement\" step\n+computes a set of constraints.  The replacements, then, attempt to\n+satisfy those constraints, using bound identifiers where needed.\n+\n+For now I will briefly go over the cases for LUB/GLB and identify\n+their intent:\n+\n+- LUB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains only values in V, then this region is unconstrained\n+    and can therefore be generalized, otherwise it cannot.\n+- GLB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains exactly one variable from each side, and\n+    only variables in V, that indicates that those two bound regions\n+    must be equated.\n+  - Otherwise, if Tainted(R) references any variables from left or right\n+    side, then it is trying to combine a bound region with a free one or\n+    multiple bound regions, so we need to select fresh bound regions.\n+\n+Sorry this is more of a shorthand to myself.  I will try to write up something\n+more convincing in the future.\n+\n+#### Where are the algorithms wrong?\n+\n+- The pre-replacement computation can fail even though using a\n+  bound-region would have succeeded.\n+- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n+  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n+  to regions without a GLB, then this is effectively a failure to compute\n+  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n \n */\n \n@@ -457,7 +543,7 @@ use middle::region::is_subregion_of;\n use middle::region;\n use middle::ty;\n use middle::ty::{Region, RegionVid, re_static, re_infer, re_free, re_bound};\n-use middle::ty::{re_scope, ReVar, ReSkolemized};\n+use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::to_str::ToStr;\n use syntax::codemap;\n use util::ppaux::note_and_explain_region;\n@@ -553,6 +639,7 @@ struct RegionVarBindings {\n     lubs: CombineMap,\n     glbs: CombineMap,\n     mut skolemization_count: uint,\n+    mut bound_count: uint,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -579,6 +666,7 @@ fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n         lubs: CombineMap(),\n         glbs: CombineMap(),\n         skolemization_count: 0,\n+        bound_count: 0,\n         undo_log: ~[]\n     }\n }\n@@ -655,6 +743,26 @@ impl RegionVarBindings {\n         re_infer(ReSkolemized(sc, br))\n     }\n \n+    fn new_bound(&self) -> Region {\n+        // Creates a fresh bound variable for use in GLB computations.\n+        // See discussion of GLB computation in the large comment at\n+        // the top of this file for more details.\n+        //\n+        // This computation is mildly wrong in the face of rollover.\n+        // It's conceivable, if unlikely, that one might wind up with\n+        // accidental capture for nested functions in that case, if\n+        // the outer function had bound regions created a very long\n+        // time before and the inner function somehow wound up rolling\n+        // over such that supposedly fresh identifiers were in fact\n+        // shadowed.  We should convert our bound_region\n+        // representation to use deBruijn indices or something like\n+        // that to eliminate that possibility.\n+\n+        let sc = self.bound_count;\n+        self.bound_count += 1;\n+        re_bound(br_fresh(sc))\n+    }\n+\n     fn add_constraint(&self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n@@ -687,6 +795,16 @@ impl RegionVarBindings {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), span);\n             Ok(())\n           }\n+          (re_bound(br), _) => {\n+            self.tcx.sess.span_bug(\n+                span,\n+                fmt!(\"Cannot relate bound region as subregion: %?\", br));\n+          }\n+          (_, re_bound(br)) => {\n+            self.tcx.sess.span_bug(\n+                span,\n+                fmt!(\"Cannot relate bound region as superregion: %?\", br));\n+          }\n           _ => {\n             if self.is_subregion_of(sub, sup) {\n                 Ok(())"}, {"sha": "c96724bd6525fb96f93cc20eb0c0156c0d704d27", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -24,6 +24,7 @@ impl Sub: combine {\n     fn infcx() -> infer_ctxt { self.infcx }\n     fn tag() -> ~str { ~\"sub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n+    fn span() -> span { self.span }\n \n     fn sub() -> Sub { Sub(*self) }\n     fn lub() -> Lub { Lub(*self) }"}, {"sha": "abc249a45ec3f85956d43909cf93dda2080a067c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 112, "deletions": 13, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -16,7 +16,7 @@ Note: This module is only compiled when doing unit testing.\n \n */\n \n-\n+use dvec::DVec;\n use std::getopts;\n use std::map::HashMap;\n use std::getopts;\n@@ -36,18 +36,23 @@ use middle::ty::{FnTyBase, FnMeta, FnSig};\n struct Env {\n     crate: @ast::crate,\n     tcx: ty::ctxt,\n-    infcx: infer::infer_ctxt\n+    infcx: infer::infer_ctxt,\n+    err_messages: @DVec<~str>\n }\n \n struct RH {\n     id: ast::node_id,\n     sub: &[RH]\n }\n \n+const EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n+\n fn setup_env(test_name: &str, source_string: &str) -> Env {\n-    let matches = &getopts(~[~\"-Z\", ~\"verbose\"], optgroups()).get();\n-    let sessopts = build_session_options(~\"rustc\", matches, diagnostic::emit);\n-    let sess = build_session(sessopts, diagnostic::emit);\n+    let messages = @DVec();\n+    let matches = getopts(~[~\"-Z\", ~\"verbose\"], optgroups()).get();\n+    let diag = diagnostic::collect(messages);\n+    let sessopts = build_session_options(~\"rustc\", &matches, diag);\n+    let sess = build_session(sessopts, diag);\n     let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n     let dm = HashMap();\n     let amap = HashMap();\n@@ -66,7 +71,10 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    return Env { crate: crate, tcx: tcx, infcx: infcx };\n+    return Env {crate: crate,\n+                tcx: tcx,\n+                infcx: infcx,\n+                err_messages: messages};\n }\n \n impl Env {\n@@ -210,6 +218,22 @@ impl Env {\n \n     fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }\n \n+    fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n+\n+    fn resolve_regions(exp_count: uint) {\n+        debug!(\"resolve_regions(%u)\", exp_count);\n+\n+        self.infcx.resolve_regions();\n+        if self.err_messages.len() != exp_count {\n+            for self.err_messages.each |msg| {\n+                debug!(\"Error encountered: %s\", *msg);\n+            }\n+            fmt!(\"Resolving regions encountered %u errors but expected %u!\",\n+                 self.err_messages.len(),\n+                 exp_count);\n+        }\n+    }\n+\n     /// Checks that `LUB(t1,t2) == t_lub`\n     fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n@@ -222,6 +246,30 @@ impl Env {\n                 // sanity check for good measure:\n                 self.assert_subtype(t1, t);\n                 self.assert_subtype(t2, t);\n+\n+                self.resolve_regions(0);\n+            }\n+        }\n+    }\n+\n+    /// Checks that `GLB(t1,t2) == t_glb`\n+    fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n+        debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n+               self.ty_to_str(t1),\n+               self.ty_to_str(t2),\n+               self.ty_to_str(t_glb));\n+        match self.glb().tys(t1, t2) {\n+            Err(e) => {\n+                fail fmt!(\"Unexpected error computing LUB: %?\", e)\n+            }\n+            Ok(t) => {\n+                self.assert_eq(t, t_glb);\n+\n+                // sanity check for good measure:\n+                self.assert_subtype(t, t1);\n+                self.assert_subtype(t, t2);\n+\n+                self.resolve_regions(0);\n             }\n         }\n     }\n@@ -236,11 +284,22 @@ impl Env {\n             }\n         }\n     }\n+\n+    /// Checks that `GLB(t1,t2)` is undefined\n+    fn check_no_glb(&self, t1: ty::t, t2: ty::t) {\n+        match self.glb().tys(t1, t2) {\n+            Err(_) => {}\n+            Ok(t) => {\n+                fail fmt!(\"Unexpected success computing GLB: %?\",\n+                          self.ty_to_str(t))\n+            }\n+        }\n+    }\n }\n \n #[test]\n fn contravariant_region_ptr() {\n-    let env = setup_env(\"contravariant_region_ptr\", \"\");\n+    let env = setup_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR);\n     env.create_simple_region_hierarchy();\n     let t_rptr1 = env.t_rptr_scope(1);\n     let t_rptr10 = env.t_rptr_scope(10);\n@@ -251,7 +310,7 @@ fn contravariant_region_ptr() {\n \n #[test]\n fn lub_bound_bound() {\n-    let env = setup_env(\"lub_bound_bound\", \"\");\n+    let env = setup_env(\"lub_bound_bound\", EMPTY_SOURCE_STR);\n     let t_rptr_bound1 = env.t_rptr_bound(1);\n     let t_rptr_bound2 = env.t_rptr_bound(2);\n     env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n@@ -261,7 +320,7 @@ fn lub_bound_bound() {\n \n #[test]\n fn lub_bound_free() {\n-    let env = setup_env(\"lub_bound_free\", \"\");\n+    let env = setup_env(\"lub_bound_free\", EMPTY_SOURCE_STR);\n     let t_rptr_bound1 = env.t_rptr_bound(1);\n     let t_rptr_free1 = env.t_rptr_free(0, 1);\n     env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n@@ -271,7 +330,7 @@ fn lub_bound_free() {\n \n #[test]\n fn lub_bound_static() {\n-    let env = setup_env(\"lub_bound_static\", \"\");\n+    let env = setup_env(\"lub_bound_static\", EMPTY_SOURCE_STR);\n     let t_rptr_bound1 = env.t_rptr_bound(1);\n     let t_rptr_static = env.t_rptr_static();\n     env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n@@ -281,7 +340,7 @@ fn lub_bound_static() {\n \n #[test]\n fn lub_bound_bound_inverse_order() {\n-    let env = setup_env(\"lub_bound_bound_inverse_order\", \"\");\n+    let env = setup_env(\"lub_bound_bound_inverse_order\", EMPTY_SOURCE_STR);\n     let t_rptr_bound1 = env.t_rptr_bound(1);\n     let t_rptr_bound2 = env.t_rptr_bound(2);\n     env.check_lub(env.t_fn([t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n@@ -291,7 +350,7 @@ fn lub_bound_bound_inverse_order() {\n \n #[test]\n fn lub_free_free() {\n-    let env = setup_env(\"lub_free_free\", \"\");\n+    let env = setup_env(\"lub_free_free\", EMPTY_SOURCE_STR);\n     let t_rptr_free1 = env.t_rptr_free(0, 1);\n     let t_rptr_free2 = env.t_rptr_free(0, 2);\n     let t_rptr_static = env.t_rptr_static();\n@@ -302,10 +361,50 @@ fn lub_free_free() {\n \n #[test]\n fn lub_returning_scope() {\n-    let env = setup_env(\"lub_returning_scope\", \"\");\n+    let env = setup_env(\"lub_returning_scope\", EMPTY_SOURCE_STR);\n     let t_rptr_scope10 = env.t_rptr_scope(10);\n     let t_rptr_scope11 = env.t_rptr_scope(11);\n     env.check_no_lub(env.t_fn([], t_rptr_scope10),\n                      env.t_fn([], t_rptr_scope11));\n }\n \n+#[test]\n+fn glb_free_free_with_common_scope() {\n+    let env = setup_env(\"glb_free_free\", EMPTY_SOURCE_STR);\n+    let t_rptr_free1 = env.t_rptr_free(0, 1);\n+    let t_rptr_free2 = env.t_rptr_free(0, 2);\n+    let t_rptr_scope = env.t_rptr_scope(0);\n+    env.check_glb(env.t_fn([t_rptr_free1], env.t_int()),\n+                  env.t_fn([t_rptr_free2], env.t_int()),\n+                  env.t_fn([t_rptr_scope], env.t_int()));\n+}\n+\n+#[test]\n+fn glb_bound_bound() {\n+    let env = setup_env(\"glb_bound_bound\", EMPTY_SOURCE_STR);\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_bound2 = env.t_rptr_bound(2);\n+    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_bound2], env.t_int()),\n+                  env.t_fn([t_rptr_bound1], env.t_int()));\n+}\n+\n+#[test]\n+fn glb_bound_free() {\n+    let env = setup_env(\"glb_bound_free\", EMPTY_SOURCE_STR);\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_free1 = env.t_rptr_free(0, 1);\n+    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_free1], env.t_int()),\n+                  env.t_fn([t_rptr_bound1], env.t_int()));\n+}\n+\n+#[test]\n+fn glb_bound_static() {\n+    let env = setup_env(\"glb_bound_static\", EMPTY_SOURCE_STR);\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_static = env.t_rptr_static();\n+    env.check_glb(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_static], env.t_int()),\n+                  env.t_fn([t_rptr_bound1], env.t_int()));\n+}"}, {"sha": "071f12a92d4fead9bb41100917f14d518746001e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -13,7 +13,8 @@ use middle::ty;\n use middle::ty::{arg, canon_mode};\n use middle::ty::{bound_copy, bound_const, bound_durable, bound_owned,\n         bound_trait};\n-use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n+use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid,\n+                 br_fresh};\n use middle::ty::{ctxt, field, method};\n use middle::ty::{mt, t, param_bound};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n@@ -94,6 +95,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         let prefix = match br {\n           br_anon(idx) => fmt!(\"the anonymous lifetime #%u defined on\",\n                                idx + 1),\n+          br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n           _ => fmt!(\"the lifetime %s as defined on\",\n                     bound_region_to_str(cx, br))\n         };\n@@ -140,6 +142,7 @@ fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n       br_named(id)         => fmt!(\"%s%s%s\", prefix, cx.sess.str_of(id), sep),\n       br_self              => fmt!(\"%sself%s\", prefix, sep),\n       br_anon(_)           => prefix.to_str(),\n+      br_fresh(_)          => prefix.to_str(),\n       br_cap_avoid(_, br)  => bound_region_to_str_adorned(cx, prefix,\n                                                           *br, sep)\n     }"}, {"sha": "1f26711abb9666bd08fc961df5d16618bf816629", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -315,6 +315,10 @@ pub impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: span) -> ~str {\n+        if self.files.len() == 0 && sp == ast_util::dummy_sp() {\n+            return ~\"no-location\";\n+        }\n+\n         let lo = self.lookup_char_pos_adj(sp.lo);\n         let hi = self.lookup_char_pos_adj(sp.hi);\n         return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,"}, {"sha": "ddffa04622f322317fc590b0aa05e69a8fb9648f", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c3a74d87bd5a8f8bd32350f74a3fa4fb1f9bf5e6", "patch": "@@ -17,9 +17,11 @@ use core::io;\n use core::option;\n use core::str;\n use core::vec;\n+use core::dvec::DVec;\n+\n use std::term;\n \n-export emitter, emit;\n+export emitter, collect, emit;\n export level, fatal, error, warning, note;\n export span_handler, handler, mk_span_handler, mk_handler;\n export codemap_span_handler, codemap_handler;\n@@ -143,7 +145,7 @@ fn mk_handler(emitter: Option<emitter>) -> handler {\n       Some(e) => e,\n       None => {\n         let f = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n-            msg: &str, t: level) {\n+                    msg: &str, t: level) {\n             emit(cmsp, msg, t);\n         };\n         f\n@@ -206,6 +208,12 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n+fn collect(messages: @DVec<~str>)\n+    -> fn@(Option<(@codemap::CodeMap, span)>, &str, level)\n+{\n+    |_o, msg: &str, _l| { messages.push(msg.to_str()); }\n+}\n+\n fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {"}]}