{"sha": "a5cdb6566bd0c1bd80ccd06f9c92950451993671", "node_id": "C_kwDOAAsO6NoAKGE1Y2RiNjU2NmJkMGMxYmQ4MGNjZDA2ZjljOTI5NTA0NTE5OTM2NzE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-15T08:28:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-15T08:28:12Z"}, "message": "Rollup merge of #100506 - lcnr:fnctxt-yeet, r=compiler-errors\n\nchange `InlineAsmCtxt` to not talk about `FnCtxt`\n\nwip for https://github.com/rust-lang/compiler-team/issues/529. this currently uses both the `FnCtxt` and is used by `check_mod_item_types`. This should be the only thing blocking that MCP afaict.\n\nI am still unsure whether `rustc_hir_typeck` should depend on `rustc_hir_analysis` to use the `InlineAsmCtxt`. I think that's the best solution for now, so that's what I will go for\n\nr? `@compiler-errors`", "tree": {"sha": "c316b5f1eae7d2a48caf3a8c9617c49bf27d8ef3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c316b5f1eae7d2a48caf3a8c9617c49bf27d8ef3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5cdb6566bd0c1bd80ccd06f9c92950451993671", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi+gOcCRBK7hj4Ov3rIwAAzN4IAAE+MQqMEGr7bEJ+F5+ZOzlF\nW1GJ3AkK8sNgyyMifczfmraxZtpxYXg2OIUoRNaF9lD32HoEdT8zcVgQK2i7/2hw\njZUjtiNRau9qHFkRmxQYIa13zMU1+4QvO2ZmeL0UScIGAN3CZmUuzddfQovLVsKm\nXFN/9scXXU1wob0Zl/zptqIacvp+TnmLSSksq+kgpN/UqyqmWtGuwqfprReg8Htn\nx/SCPnp8M9WYyO7FkZzpfb4DYASftCY70XbuK+sZUDZzZ0sRDwiZ50QvycOyjHM2\nHIOJmfkumcBpiaAH1sETb/0PzxUhbhkr2jQ+ANNTwKd9Z5VdxF7so1y8acJARwg=\n=6E9v\n-----END PGP SIGNATURE-----\n", "payload": "tree c316b5f1eae7d2a48caf3a8c9617c49bf27d8ef3\nparent ee63d09bd6e37439dfbe8814dd5664bb1f4b6438\nparent 1137fffe28899e992dc43b1152ea7daaa9ab3424\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660552092 +0200\ncommitter GitHub <noreply@github.com> 1660552092 +0200\n\nRollup merge of #100506 - lcnr:fnctxt-yeet, r=compiler-errors\n\nchange `InlineAsmCtxt` to not talk about `FnCtxt`\n\nwip for https://github.com/rust-lang/compiler-team/issues/529. this currently uses both the `FnCtxt` and is used by `check_mod_item_types`. This should be the only thing blocking that MCP afaict.\n\nI am still unsure whether `rustc_hir_typeck` should depend on `rustc_hir_analysis` to use the `InlineAsmCtxt`. I think that's the best solution for now, so that's what I will go for\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5cdb6566bd0c1bd80ccd06f9c92950451993671", "html_url": "https://github.com/rust-lang/rust/commit/a5cdb6566bd0c1bd80ccd06f9c92950451993671", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5cdb6566bd0c1bd80ccd06f9c92950451993671/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee63d09bd6e37439dfbe8814dd5664bb1f4b6438", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee63d09bd6e37439dfbe8814dd5664bb1f4b6438", "html_url": "https://github.com/rust-lang/rust/commit/ee63d09bd6e37439dfbe8814dd5664bb1f4b6438"}, {"sha": "1137fffe28899e992dc43b1152ea7daaa9ab3424", "url": "https://api.github.com/repos/rust-lang/rust/commits/1137fffe28899e992dc43b1152ea7daaa9ab3424", "html_url": "https://github.com/rust-lang/rust/commit/1137fffe28899e992dc43b1152ea7daaa9ab3424"}], "stats": {"total": 79, "additions": 45, "deletions": 34}, "files": [{"sha": "aab60de80ef14e65592dea4556e3495a5e11367a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5cdb6566bd0c1bd80ccd06f9c92950451993671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5cdb6566bd0c1bd80ccd06f9c92950451993671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=a5cdb6566bd0c1bd80ccd06f9c92950451993671", "patch": "@@ -58,7 +58,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"FnCtxt::check_asm: {} deferred checks\", deferred_asm_checks.len());\n         for (asm, hir_id) in deferred_asm_checks.drain(..) {\n             let enclosing_id = self.tcx.hir().enclosing_body_owner(hir_id);\n-            InlineAsmCtxt::new_in_fn(self)\n+            let get_operand_ty = |expr| {\n+                let ty = self.typeck_results.borrow().expr_ty_adjusted(expr);\n+                let ty = self.resolve_vars_if_possible(ty);\n+                if ty.has_infer_types_or_consts() {\n+                    assert!(self.is_tainted_by_errors());\n+                    self.tcx.ty_error()\n+                } else {\n+                    self.tcx.erase_regions(ty)\n+                }\n+            };\n+            InlineAsmCtxt::new_in_fn(self.tcx, self.param_env, get_operand_ty)\n                 .check_asm(asm, self.tcx.hir().local_def_id_to_hir_id(enclosing_id));\n         }\n     }"}, {"sha": "721ebba6514779066e486d8214ebe3ab2bd76aea", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a5cdb6566bd0c1bd80ccd06f9c92950451993671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5cdb6566bd0c1bd80ccd06f9c92950451993671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=a5cdb6566bd0c1bd80ccd06f9c92950451993671", "patch": "@@ -9,7 +9,6 @@ use rustc_session::lint;\n use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n-use rustc_trait_selection::infer::InferCtxtExt;\n \n use super::FnCtxt;\n \n@@ -98,62 +97,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         err.emit();\n     }\n+}\n+\n+pub struct InlineAsmCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    get_operand_ty: Box<dyn Fn(&'tcx hir::Expr<'tcx>) -> Ty<'tcx> + 'a>,\n+}\n+\n+impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n+    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n+        InlineAsmCtxt {\n+            tcx,\n+            param_env: ty::ParamEnv::empty(),\n+            get_operand_ty: Box::new(|e| bug!(\"asm operand in global asm: {e:?}\")),\n+        }\n+    }\n+\n+    pub fn new_in_fn(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        get_operand_ty: impl Fn(&'tcx hir::Expr<'tcx>) -> Ty<'tcx> + 'a,\n+    ) -> Self {\n+        InlineAsmCtxt { tcx, param_env, get_operand_ty: Box::new(get_operand_ty) }\n+    }\n \n     // FIXME(compiler-errors): This could use `<$ty as Pointee>::Metadata == ()`\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if self.tcx.erase_regions(ty).is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n             return true;\n         }\n         false\n     }\n-}\n-\n-pub struct InlineAsmCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    fcx: Option<&'a FnCtxt<'a, 'tcx>>,\n-}\n-\n-impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n-    pub fn new_global_asm(tcx: TyCtxt<'tcx>) -> Self {\n-        InlineAsmCtxt { tcx, fcx: None }\n-    }\n-\n-    pub fn new_in_fn(fcx: &'a FnCtxt<'a, 'tcx>) -> Self {\n-        InlineAsmCtxt { tcx: fcx.tcx, fcx: Some(fcx) }\n-    }\n \n     fn check_asm_operand_type(\n         &self,\n         idx: usize,\n         reg: InlineAsmRegOrRegClass,\n-        expr: &hir::Expr<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n-        tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+        tied_input: Option<(&'tcx hir::Expr<'tcx>, Option<InlineAsmType>)>,\n         target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n-        let fcx = self.fcx.unwrap_or_else(|| span_bug!(expr.span, \"asm operand for global asm\"));\n-        // Check the type against the allowed types for inline asm.\n-        let ty = fcx.typeck_results.borrow().expr_ty_adjusted(expr);\n-        let ty = fcx.resolve_vars_if_possible(ty);\n+        let ty = (self.get_operand_ty)(expr);\n+        if ty.has_infer_types_or_consts() {\n+            bug!(\"inference variable in asm operand ty: {:?} {:?}\", expr, ty);\n+        }\n         let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n             64 => InlineAsmType::I64,\n             _ => unreachable!(),\n         };\n \n-        // Expect types to be fully resolved, no const or type variables.\n-        if ty.has_infer_types_or_consts() {\n-            assert!(fcx.is_tainted_by_errors());\n-            return None;\n-        }\n-\n         let asm_ty = match *ty.kind() {\n             // `!` is allowed for input but not for output (issue #87802)\n             ty::Never if is_input => return None,\n@@ -167,7 +169,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n             ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n             ty::FnPtr(_) => Some(asm_ty_isize),\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if fcx.is_thin_ptr_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n                 Some(asm_ty_isize)\n             }\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n@@ -219,7 +221,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, ty, DUMMY_SP) {\n+        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));\n@@ -240,8 +242,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 let msg = \"incompatible types for asm inout argument\";\n                 let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n \n-                let in_expr_ty = fcx.typeck_results.borrow().expr_ty_adjusted(in_expr);\n-                let in_expr_ty = fcx.resolve_vars_if_possible(in_expr_ty);\n+                let in_expr_ty = (self.get_operand_ty)(in_expr);\n                 err.span_label(in_expr.span, &format!(\"type `{in_expr_ty}`\"));\n                 err.span_label(expr.span, &format!(\"type `{ty}`\"));\n                 err.note("}]}