{"sha": "4b23a0962db486c8a96d673a1b17decc26a26b34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMjNhMDk2MmRiNDg2YzhhOTZkNjczYTFiMTdkZWNjMjZhMjZiMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-10T08:38:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-10T08:38:52Z"}, "message": "Auto merge of #29647 - goyox86:goyox86/rustfmting-librustc_frontII, r=nrc\n\nHi Rustaceans!\n\nThis is the second take  on running latest rustfmt on librustc_front!\n\nThis is the same in https://github.com/rust-lang/rust/pull/29075 but cleaned. All fixups have been applied.\n\n//cc @nrc", "tree": {"sha": "c60547cd5f7f39dd54de7590f4541179b5497791", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c60547cd5f7f39dd54de7590f4541179b5497791"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b23a0962db486c8a96d673a1b17decc26a26b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b23a0962db486c8a96d673a1b17decc26a26b34", "html_url": "https://github.com/rust-lang/rust/commit/4b23a0962db486c8a96d673a1b17decc26a26b34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b23a0962db486c8a96d673a1b17decc26a26b34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6aee7c5d2c3e5796844671cf072487f6fb04cb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aee7c5d2c3e5796844671cf072487f6fb04cb9b", "html_url": "https://github.com/rust-lang/rust/commit/6aee7c5d2c3e5796844671cf072487f6fb04cb9b"}, {"sha": "cbd2ef818514b8a17f23031c0048ac3b28acd981", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbd2ef818514b8a17f23031c0048ac3b28acd981", "html_url": "https://github.com/rust-lang/rust/commit/cbd2ef818514b8a17f23031c0048ac3b28acd981"}], "stats": {"total": 388, "additions": 192, "deletions": 196}, "files": [{"sha": "c4bc003e1923ac6a6dbeba51ba63ed2e03a3c84f", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -431,14 +431,16 @@ pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n }\n \n pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n-    v.map(|Spanned {node: Variant_ {name, attrs, data, disr_expr}, span}| Spanned {\n-        node: Variant_ {\n-            name: name,\n-            attrs: fold_attrs(attrs, fld),\n-            data: fld.fold_variant_data(data),\n-            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(span),\n+    v.map(|Spanned { node: Variant_ { name, attrs, data, disr_expr }, span }| {\n+        Spanned {\n+            node: Variant_ {\n+                name: name,\n+                attrs: fold_attrs(attrs, fld),\n+                data: fld.fold_variant_data(data),\n+                disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+            },\n+            span: fld.new_span(span),\n+        }\n     })\n }\n \n@@ -696,12 +698,14 @@ pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -\n pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n     match vdata {\n         VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n+                                fld.new_id(id))\n         }\n         VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)), fld.new_id(id))\n+            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n+                               fld.new_id(id))\n         }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id))\n+        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id)),\n     }\n }\n \n@@ -740,8 +744,7 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n \n pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n     Field {\n-        name: respan(folder.new_span(name.span),\n-                     folder.fold_name(name.node)),\n+        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n         expr: folder.fold_expr(expr),\n         span: folder.new_span(span),\n     }\n@@ -812,8 +815,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety,\n-                            folder.fold_trait_ref((*trait_ref).clone()))\n+            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n             let new_impl_items = impl_items.into_iter()\n@@ -854,8 +856,7 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>,\n             attrs: fold_attrs(attrs, folder),\n             node: match node {\n                 ConstTraitItem(ty, default) => {\n-                    ConstTraitItem(folder.fold_ty(ty),\n-                                   default.map(|x| folder.fold_expr(x)))\n+                    ConstTraitItem(folder.fold_ty(ty), default.map(|x| folder.fold_expr(x)))\n                 }\n                 MethodTraitItem(sig, body) => {\n                     MethodTraitItem(noop_fold_method_sig(sig, folder),\n@@ -883,8 +884,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> SmallVe\n                     ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n                 }\n                 MethodImplItem(sig, body) => {\n-                    MethodImplItem(noop_fold_method_sig(sig, folder),\n-                                   folder.fold_block(body))\n+                    MethodImplItem(noop_fold_method_sig(sig, folder), folder.fold_block(body))\n                 }\n                 TypeImplItem(ty) => TypeImplItem(folder.fold_ty(ty)),\n             },\n@@ -981,8 +981,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n             attrs: fold_attrs(attrs, folder),\n             node: match node {\n                 ForeignItemFn(fdec, generics) => {\n-                    ForeignItemFn(folder.fold_fn_decl(fdec),\n-                                  folder.fold_generics(generics))\n+                    ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n                 }\n                 ForeignItemStatic(t, m) => {\n                     ForeignItemStatic(folder.fold_ty(t), m)\n@@ -1074,12 +1073,10 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n             }\n             ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n             ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f),\n-                         args.move_map(|x| folder.fold_expr(x)))\n+                ExprCall(folder.fold_expr(f), args.move_map(|x| folder.fold_expr(x)))\n             }\n             ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(respan(folder.new_span(name.span),\n-                                      folder.fold_name(name.node)),\n+                ExprMethodCall(respan(folder.new_span(name.span), folder.fold_name(name.node)),\n                                tps.move_map(|x| folder.fold_ty(x)),\n                                args.move_map(|x| folder.fold_expr(x)))\n             }\n@@ -1127,13 +1124,11 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n             }\n             ExprField(el, name) => {\n                 ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(name.span),\n-                                 folder.fold_name(name.node)))\n+                          respan(folder.new_span(name.span), folder.fold_name(name.node)))\n             }\n             ExprTupField(el, index) => {\n                 ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span),\n-                                    folder.fold_usize(index.node)))\n+                             respan(folder.new_span(index.span), folder.fold_usize(index.node)))\n             }\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n@@ -1152,12 +1147,10 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n                 ExprPath(qself, folder.fold_path(path))\n             }\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label| {\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node))\n+                respan(folder.new_span(label.span), folder.fold_ident(label.node))\n             })),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label| {\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node))\n+                respan(folder.new_span(label.span), folder.fold_ident(label.node))\n             })),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n             ExprInlineAsm(InlineAsm {"}, {"sha": "b017a07dde0a1f0664cbf39099a045abeb3e57e8", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -1062,7 +1062,6 @@ pub type ViewPath = Spanned<ViewPath_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ViewPath_ {\n-\n     /// `foo::bar::baz as quux`\n     ///\n     /// or just\n@@ -1151,7 +1150,7 @@ impl StructFieldKind {\n \n     pub fn visibility(&self) -> Visibility {\n         match *self {\n-            NamedField(_, vis) | UnnamedField(vis) => vis\n+            NamedField(_, vis) | UnnamedField(vis) => vis,\n         }\n     }\n }\n@@ -1183,24 +1182,36 @@ impl VariantData {\n     }\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id\n+            VariantData::Struct(_, id) | VariantData::Tuple(_, id) | VariantData::Unit(id) => id,\n         }\n     }\n     pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self { true } else { false }\n+        if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n     pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self { true } else { false }\n+        if let VariantData::Tuple(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n     pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self { true } else { false }\n+        if let VariantData::Unit(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n \n-/*\n-  FIXME (#3300): Should allow items to be anonymous. Right now\n-  we just use dummy names for anon items.\n- */\n+\n+\n+//  FIXME (#3300): Should allow items to be anonymous. Right now\n+//  we just use dummy names for anon items.\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n@@ -1244,7 +1255,7 @@ pub enum Item_ {\n \n     // Default trait implementations\n     ///\n-    // `impl Trait for .. {}`\n+    /// `impl Trait for .. {}`\n     ItemDefaultImpl(Unsafety, TraitRef),\n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n     ItemImpl(Unsafety,"}, {"sha": "d13b92c04f82a440917db8d92997325ff9b75ea9", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'hir> LoweringContext<'a> {\n     fn next_id(&self) -> NodeId {\n         let cached = self.cached_id.get();\n         if cached == 0 {\n-            return self.id_assigner.next_node_id()\n+            return self.id_assigner.next_node_id();\n         }\n \n         self.cached_id.set(cached + 1);\n@@ -214,8 +214,7 @@ pub fn lower_ty(_lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n             TyVec(ref ty) => hir::TyVec(lower_ty(_lctx, ty)),\n             TyPtr(ref mt) => hir::TyPtr(lower_mt(_lctx, mt)),\n             TyRptr(ref region, ref mt) => {\n-                hir::TyRptr(lower_opt_lifetime(_lctx, region),\n-                            lower_mt(_lctx, mt))\n+                hir::TyRptr(lower_opt_lifetime(_lctx, region), lower_mt(_lctx, mt))\n             }\n             TyBareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n@@ -502,13 +501,17 @@ pub fn lower_variant_data(_lctx: &LoweringContext, vdata: &VariantData) -> hir::\n     match *vdata {\n         VariantData::Struct(ref fields, id) => {\n             hir::VariantData::Struct(fields.iter()\n-                                           .map(|f| lower_struct_field(_lctx, f)).collect(), id)\n+                                           .map(|f| lower_struct_field(_lctx, f))\n+                                           .collect(),\n+                                     id)\n         }\n         VariantData::Tuple(ref fields, id) => {\n             hir::VariantData::Tuple(fields.iter()\n-                                          .map(|f| lower_struct_field(_lctx, f)).collect(), id)\n+                                          .map(|f| lower_struct_field(_lctx, f))\n+                                          .collect(),\n+                                    id)\n         }\n-        VariantData::Unit(id) => hir::VariantData::Unit(id)\n+        VariantData::Unit(id) => hir::VariantData::Unit(id),\n     }\n }\n \n@@ -676,8 +679,7 @@ pub fn lower_impl_item(_lctx: &LoweringContext, i: &ImplItem) -> P<hir::ImplItem\n                 hir::ConstImplItem(lower_ty(_lctx, ty), lower_expr(_lctx, expr))\n             }\n             MethodImplItem(ref sig, ref body) => {\n-                hir::MethodImplItem(lower_method_sig(_lctx, sig),\n-                                    lower_block(_lctx, body))\n+                hir::MethodImplItem(lower_method_sig(_lctx, sig), lower_block(_lctx, body))\n             }\n             TypeImplItem(ref ty) => hir::TypeImplItem(lower_ty(_lctx, ty)),\n             MacImplItem(..) => panic!(\"Shouldn't exist any more\"),\n@@ -743,8 +745,7 @@ pub fn lower_foreign_item(_lctx: &LoweringContext, i: &ForeignItem) -> P<hir::Fo\n         attrs: i.attrs.clone(),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n-                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec),\n-                                   lower_generics(_lctx, generics))\n+                hir::ForeignItemFn(lower_fn_decl(_lctx, fdec), lower_generics(_lctx, generics))\n             }\n             ForeignItemStatic(ref t, m) => {\n                 hir::ForeignItemStatic(lower_ty(_lctx, t), m)\n@@ -855,8 +856,9 @@ pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n             }\n             PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(_lctx, x)).collect()),\n             PatBox(ref inner) => hir::PatBox(lower_pat(_lctx, inner)),\n-            PatRegion(ref inner, mutbl) => hir::PatRegion(lower_pat(_lctx, inner),\n-                                                          lower_mutability(_lctx, mutbl)),\n+            PatRegion(ref inner, mutbl) => {\n+                hir::PatRegion(lower_pat(_lctx, inner), lower_mutability(_lctx, mutbl))\n+            }\n             PatRange(ref e1, ref e2) => {\n                 hir::PatRange(lower_expr(_lctx, e1), lower_expr(_lctx, e2))\n             }\n@@ -1021,11 +1023,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     InPlace::finalize(place)\n                 // })\n                 let expr = {\n-                    let call_move_val_init = hir::StmtSemi(make_call(lctx,\n-                                                    &move_val_init,\n-                                                    vec![expr_ident(lctx, e.span, p_ptr_ident),\n-                                                         pop_unsafe_expr]),\n-                                                           lctx.next_id());\n+                    let call_move_val_init =\n+                        hir::StmtSemi(make_call(lctx,\n+                                                &move_val_init,\n+                                                vec![expr_ident(lctx, e.span, p_ptr_ident),\n+                                                     pop_unsafe_expr]),\n+                                      lctx.next_id());\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n                     let call = make_call(lctx,\n@@ -1100,14 +1103,10 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     }\n                 });\n \n-                hir::ExprIf(lower_expr(lctx, cond),\n-                            lower_block(lctx, blk),\n-                            else_opt)\n+                hir::ExprIf(lower_expr(lctx, cond), lower_block(lctx, blk), else_opt)\n             }\n             ExprWhile(ref cond, ref body, opt_ident) => {\n-                hir::ExprWhile(lower_expr(lctx, cond),\n-                               lower_block(lctx, body),\n-                               opt_ident)\n+                hir::ExprWhile(lower_expr(lctx, cond), lower_block(lctx, body), opt_ident)\n             }\n             ExprLoop(ref body, opt_ident) => {\n                 hir::ExprLoop(lower_block(lctx, body), opt_ident)\n@@ -1132,8 +1131,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                   lower_expr(lctx, er))\n             }\n             ExprField(ref el, ident) => {\n-                hir::ExprField(lower_expr(lctx, el),\n-                               respan(ident.span, ident.node.name))\n+                hir::ExprField(lower_expr(lctx, el), respan(ident.span, ident.node.name))\n             }\n             ExprTupField(ref el, ident) => {\n                 hir::ExprTupField(lower_expr(lctx, el), ident)\n@@ -1406,10 +1404,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         path_global(e.span, strs)\n                     };\n \n-                    expr_call(lctx,\n-                              e.span,\n-                              expr_path(lctx, into_iter_path),\n-                              vec![head])\n+                    expr_call(lctx, e.span, expr_path(lctx, into_iter_path), vec![head])\n                 };\n \n                 let match_expr = expr_match(lctx,\n@@ -1428,7 +1423,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                           false,\n                                                           result_ident,\n                                                           match_expr)],\n-                                            Some(expr_ident(lctx, e.span, result_ident))))\n+                                            Some(expr_ident(lctx, e.span, result_ident))));\n             }\n \n             ExprMac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1525,7 +1520,7 @@ pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n \n fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     hir::Arm {\n-        attrs: vec!(),\n+        attrs: vec![],\n         pats: pats,\n         guard: None,\n         body: expr,\n@@ -1562,9 +1557,7 @@ fn expr_match(lctx: &LoweringContext,\n               arms: Vec<hir::Arm>,\n               source: hir::MatchSource)\n               -> P<hir::Expr> {\n-    expr(lctx,\n-         span,\n-         hir::ExprMatch(arg, arms, source))\n+    expr(lctx, span, hir::ExprMatch(arg, arms, source))\n }\n \n fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n@@ -1626,7 +1619,7 @@ fn block_all(lctx: &LoweringContext,\n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n     let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n     let path = path_global(span, some);\n-    pat_enum(lctx, span, path, vec!(pat))\n+    pat_enum(lctx, span, path, vec![pat])\n }\n \n fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n@@ -1675,7 +1668,7 @@ fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n }\n \n fn path_ident(span: Span, id: Ident) -> hir::Path {\n-    path(span, vec!(id))\n+    path(span, vec![id])\n }\n \n fn path(span: Span, strs: Vec<Ident>) -> hir::Path {\n@@ -1723,7 +1716,7 @@ fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<Ident> {\n         v.push(str_to_ident(s));\n     }\n     v.extend(components.iter().map(|s| str_to_ident(s)));\n-    return v\n+    return v;\n }\n \n // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n@@ -1765,9 +1758,7 @@ mod test {\n \n     impl MockAssigner {\n         fn new() -> MockAssigner {\n-            MockAssigner {\n-                next_id: Cell::new(0),\n-            }\n+            MockAssigner { next_id: Cell::new(0) }\n         }\n     }\n \n@@ -1787,14 +1778,18 @@ mod test {\n                 expn_id: codemap::NO_EXPANSION,\n             }\n         }\n-        fn cfg(&self) -> ast::CrateConfig { Vec::new() }\n+        fn cfg(&self) -> ast::CrateConfig {\n+            Vec::new()\n+        }\n         fn ident_of(&self, st: &str) -> ast::Ident {\n             parse::token::str_to_ident(st)\n         }\n         fn name_of(&self, st: &str) -> ast::Name {\n             parse::token::intern(st)\n         }\n-        fn parse_sess(&self) -> &parse::ParseSess { self }\n+        fn parse_sess(&self) -> &parse::ParseSess {\n+            self\n+        }\n     }\n \n     impl NodeIdAssigner for MockAssigner {\n@@ -1821,11 +1816,20 @@ mod test {\n         let cx = parse::ParseSess::new();\n         let mut assigner = MockAssigner::new();\n \n-        let ast_if_let = quote_expr!(&cx, if let Some(foo) = baz { bar(foo); });\n+        let ast_if_let = quote_expr!(&cx,\n+                                     if let Some(foo) = baz {\n+                                         bar(foo);\n+                                     });\n         let ast_if_let = assigner.fold_expr(ast_if_let);\n-        let ast_while_let = quote_expr!(&cx, while let Some(foo) = baz { bar(foo); });\n+        let ast_while_let = quote_expr!(&cx,\n+                                        while let Some(foo) = baz {\n+                                            bar(foo);\n+                                        });\n         let ast_while_let = assigner.fold_expr(ast_while_let);\n-        let ast_for = quote_expr!(&cx, for i in 0..10 { foo(i); });\n+        let ast_for = quote_expr!(&cx,\n+                                  for i in 0..10 {\n+                                      foo(i);\n+                                  });\n         let ast_for = assigner.fold_expr(ast_for);\n         let ast_in = quote_expr!(&cx, in HEAP { foo() });\n         let ast_in = assigner.fold_expr(ast_in);"}, {"sha": "2fd374f756050e439938942d9cd20c1de3682025", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 64, "deletions": 81, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -899,18 +899,16 @@ impl<'a> State<'a> {\n         if !struct_def.is_struct() {\n             if struct_def.is_tuple() {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent,\n-                                   struct_def.fields(),\n-                                   |s, field| {\n-                                       match field.node.kind {\n-                                           hir::NamedField(..) => panic!(\"unexpected named field\"),\n-                                           hir::UnnamedField(vis) => {\n-                                               try!(s.print_visibility(vis));\n-                                               try!(s.maybe_print_comment(field.span.lo));\n-                                               s.print_type(&*field.node.ty)\n-                                           }\n-                                       }\n-                                   }));\n+                try!(self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                    match field.node.kind {\n+                        hir::NamedField(..) => panic!(\"unexpected named field\"),\n+                        hir::UnnamedField(vis) => {\n+                            try!(s.print_visibility(vis));\n+                            try!(s.maybe_print_comment(field.span.lo));\n+                            s.print_type(&*field.node.ty)\n+                        }\n+                    }\n+                }));\n                 try!(self.pclose());\n             }\n             try!(self.print_where_clause(&generics.where_clause));\n@@ -1489,44 +1487,37 @@ impl<'a> State<'a> {\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent,\n-                                   &a.outputs,\n-                                   |s, &(ref co, ref o, is_rw)| {\n-                                       match co.slice_shift_char() {\n-                                           Some(('=', operand)) if is_rw => {\n-                                               try!(s.print_string(&format!(\"+{}\", operand),\n-                                                                   ast::CookedStr))\n-                                           }\n-                                           _ => try!(s.print_string(&co, ast::CookedStr)),\n-                                       }\n-                                       try!(s.popen());\n-                                       try!(s.print_expr(&**o));\n-                                       try!(s.pclose());\n-                                       Ok(())\n-                                   }));\n+                try!(self.commasep(Inconsistent, &a.outputs, |s, &(ref co, ref o, is_rw)| {\n+                    match co.slice_shift_char() {\n+                        Some(('=', operand)) if is_rw => {\n+                            try!(s.print_string(&format!(\"+{}\", operand), ast::CookedStr))\n+                        }\n+                        _ => try!(s.print_string(&co, ast::CookedStr)),\n+                    }\n+                    try!(s.popen());\n+                    try!(s.print_expr(&**o));\n+                    try!(s.pclose());\n+                    Ok(())\n+                }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent,\n-                                   &a.inputs,\n-                                   |s, &(ref co, ref o)| {\n-                                       try!(s.print_string(&co, ast::CookedStr));\n-                                       try!(s.popen());\n-                                       try!(s.print_expr(&**o));\n-                                       try!(s.pclose());\n-                                       Ok(())\n-                                   }));\n+                try!(self.commasep(Inconsistent, &a.inputs, |s, &(ref co, ref o)| {\n+                    try!(s.print_string(&co, ast::CookedStr));\n+                    try!(s.popen());\n+                    try!(s.print_expr(&**o));\n+                    try!(s.pclose());\n+                    Ok(())\n+                }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent,\n-                                   &a.clobbers,\n-                                   |s, co| {\n-                                       try!(s.print_string(&co, ast::CookedStr));\n-                                       Ok(())\n-                                   }));\n+                try!(self.commasep(Inconsistent, &a.clobbers, |s, co| {\n+                    try!(s.print_string(&co, ast::CookedStr));\n+                    Ok(())\n+                }));\n \n-                let mut options = vec!();\n+                let mut options = vec![];\n                 if a.volatile {\n                     options.push(\"volatile\");\n                 }\n@@ -1540,12 +1531,10 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent,\n-                                       &*options,\n-                                       |s, &co| {\n-                                           try!(s.print_string(co, ast::CookedStr));\n-                                           Ok(())\n-                                       }));\n+                    try!(self.commasep(Inconsistent, &*options, |s, &co| {\n+                        try!(s.print_string(co, ast::CookedStr));\n+                        Ok(())\n+                    }));\n                 }\n \n                 try!(self.pclose());\n@@ -1610,7 +1599,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(path.span.lo));\n \n         let mut first = !path.global;\n-        for segment in &path.segments[..path.segments.len()-depth] {\n+        for segment in &path.segments[..path.segments.len() - depth] {\n             if first {\n                 first = false\n             } else {\n@@ -1694,9 +1683,7 @@ impl<'a> State<'a> {\n \n             hir::ParenthesizedParameters(ref data) => {\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.commasep(Inconsistent,\n-                                   &data.inputs,\n-                                   |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n@@ -1716,8 +1703,8 @@ impl<'a> State<'a> {\n     pub fn print_pat(&mut self, pat: &hir::Pat) -> io::Result<()> {\n         try!(self.maybe_print_comment(pat.span.lo));\n         try!(self.ann.pre(self, NodePat(pat)));\n-        /* Pat isn't normalized, but the beauty of it\n-         is that it doesn't matter */\n+        // Pat isn't normalized, but the beauty of it\n+        // is that it doesn't matter\n         match pat.node {\n             hir::PatWild => try!(word(&mut self.s, \"_\")),\n             hir::PatIdent(binding_mode, ref path1, ref sub) => {\n@@ -2066,18 +2053,16 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent,\n-                           &ints[..],\n-                           |s, &idx| {\n-                               if idx < generics.lifetimes.len() {\n-                                   let lifetime = &generics.lifetimes[idx];\n-                                   s.print_lifetime_def(lifetime)\n-                               } else {\n-                                   let idx = idx - generics.lifetimes.len();\n-                                   let param = &generics.ty_params[idx];\n-                                   s.print_ty_param(param)\n-                               }\n-                           }));\n+        try!(self.commasep(Inconsistent, &ints[..], |s, &idx| {\n+            if idx < generics.lifetimes.len() {\n+                let lifetime = &generics.lifetimes[idx];\n+                s.print_lifetime_def(lifetime)\n+            } else {\n+                let idx = idx - generics.lifetimes.len();\n+                let param = &generics.ty_params[idx];\n+                s.print_ty_param(param)\n+            }\n+        }));\n \n         try!(word(&mut self.s, \">\"));\n         Ok(())\n@@ -2098,7 +2083,7 @@ impl<'a> State<'a> {\n \n     pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n-            return Ok(())\n+            return Ok(());\n         }\n \n         try!(space(&mut self.s));\n@@ -2170,18 +2155,16 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent,\n-                                   &segments[..],\n-                                   |s, w| {\n-                                       match w.node {\n-                                           hir::PathListIdent { name, .. } => {\n-                                               s.print_name(name)\n-                                           }\n-                                           hir::PathListMod { .. } => {\n-                                               word(&mut s.s, \"self\")\n-                                           }\n-                                       }\n-                                   }));\n+                try!(self.commasep(Inconsistent, &segments[..], |s, w| {\n+                    match w.node {\n+                        hir::PathListIdent { name, .. } => {\n+                            s.print_name(name)\n+                        }\n+                        hir::PathListMod { .. } => {\n+                            word(&mut s.s, \"self\")\n+                        }\n+                    }\n+                }));\n                 word(&mut self.s, \"}\")\n             }\n         }\n@@ -2286,7 +2269,7 @@ impl<'a> State<'a> {\n         match self.next_comment() {\n             Some(ref cmnt) => {\n                 if (*cmnt).style != comments::Trailing {\n-                    return Ok(())\n+                    return Ok(());\n                 }\n                 let span_line = cm.lookup_char_pos(span.hi);\n                 let comment_line = cm.lookup_char_pos((*cmnt).pos);"}, {"sha": "a2c52b274d55fb1dd2878597d7b51f21babc6623", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n     fn visit_item(&mut self, item: &Item) {\n         if !self.pass_through_items {\n             if self.visited_outermost {\n-                return\n+                return;\n             } else {\n                 self.visited_outermost = true\n             }\n@@ -282,11 +282,11 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n     }\n \n     fn visit_variant_data(&mut self,\n-                        struct_def: &VariantData,\n-                        _: Name,\n-                        _: &hir::Generics,\n-                        _: NodeId,\n-                        _: Span) {\n+                          struct_def: &VariantData,\n+                          _: Name,\n+                          _: &hir::Generics,\n+                          _: NodeId,\n+                          _: Span) {\n         self.operation.visit_id(struct_def.id());\n         visit::walk_struct_def(self, struct_def);\n     }"}, {"sha": "94986ceced60a6f282d2ed82c8ed7457842bfb2e", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b23a0962db486c8a96d673a1b17decc26a26b34/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=4b23a0962db486c8a96d673a1b17decc26a26b34", "patch": "@@ -112,15 +112,22 @@ pub trait Visitor<'v> : Sized {\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'v VariantData, _: Name,\n-                        _: &'v Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self,\n+                          s: &'v VariantData,\n+                          _: Name,\n+                          _: &'v Generics,\n+                          _: NodeId,\n+                          _: Span) {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'v StructField) {\n         walk_struct_field(self, s)\n     }\n-    fn visit_enum_def(&mut self, enum_definition: &'v EnumDef,\n-                      generics: &'v Generics, item_id: NodeId, _: Span) {\n+    fn visit_enum_def(&mut self,\n+                      enum_definition: &'v EnumDef,\n+                      generics: &'v Generics,\n+                      item_id: NodeId,\n+                      _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n@@ -226,9 +233,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_list!(visitor,\n-               visit_lifetime_def,\n-               &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -298,20 +303,15 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemDefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(_, _,\n-                 ref type_parameters,\n-                 ref opt_trait_reference,\n-                 ref typ,\n-                 ref impl_items) => {\n+        ItemImpl(_, _, ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_variant_data(struct_definition, item.name,\n-                                     generics, item.id, item.span);\n+            visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n@@ -326,16 +326,23 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics,\n                                          item_id: NodeId) {\n-    walk_list!(visitor, visit_variant, &enum_definition.variants, generics, item_id);\n+    walk_list!(visitor,\n+               visit_variant,\n+               &enum_definition.variants,\n+               generics,\n+               item_id);\n }\n \n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n                                         item_id: NodeId) {\n     visitor.visit_name(variant.span, variant.node.name);\n-    visitor.visit_variant_data(&variant.node.data, variant.node.name,\n-                             generics, item_id, variant.span);\n+    visitor.visit_variant_data(&variant.node.data,\n+                               variant.node.name,\n+                               generics,\n+                               item_id,\n+                               variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n@@ -357,9 +364,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         }\n         TyBareFn(ref function_declaration) => {\n             walk_fn_decl(visitor, &function_declaration.decl);\n-            walk_list!(visitor,\n-                       visit_lifetime_def,\n-                       &function_declaration.lifetimes);\n+            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n         TyPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {"}]}