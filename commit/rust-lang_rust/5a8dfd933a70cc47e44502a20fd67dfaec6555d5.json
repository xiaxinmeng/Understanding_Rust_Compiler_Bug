{"sha": "5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "node_id": "C_kwDOAAsO6NoAKDVhOGRmZDkzM2E3MGNjNDdlNDQ1MDJhMjBmZDY3ZGZhZWM2NTU1ZDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T21:49:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T21:49:31Z"}, "message": "Auto merge of #85158 - JulianKnodt:array_const_val, r=cjgillot\n\nMir-Opt for copying enums with large discrepancies\n\nI have been meaning to make this for quite a while, based off of this [hackmd](https://hackmd.io/`@ft4bxUsFT5CEUBmRKYHr7w/rJM8BBPzD).`\n\nI'm not sure where to put this opt now that I've made it, so I'd appreciate suggestions on that!\nIt's also one long chain of statements, not sure if there's a more friendly format to make it.\n\nr? `@tmiasko`\nI would `r` oli but he's on leave so he suggested I `r` tmiasko or wesleywiser.", "tree": {"sha": "5d156b3fe87069d0cc29b7e2b351630ddf900326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d156b3fe87069d0cc29b7e2b351630ddf900326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "html_url": "https://github.com/rust-lang/rust/commit/5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2773383a314a4b8f481ce2bed12c32de794ffbe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2773383a314a4b8f481ce2bed12c32de794ffbe9", "html_url": "https://github.com/rust-lang/rust/commit/2773383a314a4b8f481ce2bed12c32de794ffbe9"}, {"sha": "15d4728cda673e90b4db1ea2c60d18a6fae306d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d4728cda673e90b4db1ea2c60d18a6fae306d0", "html_url": "https://github.com/rust-lang/rust/commit/15d4728cda673e90b4db1ea2c60d18a6fae306d0"}], "stats": {"total": 789, "additions": 789, "deletions": 0}, "files": [{"sha": "89f8de235835a45a84633bd4d4b22f58ef2669ee", "filename": "compiler/rustc_mir_transform/src/large_enums.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,298 @@\n+use crate::rustc_middle::ty::util::IntTypeExt;\n+use crate::MirPass;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::mir::interpret::AllocId;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, AdtDef, Const, ParamEnv, Ty, TyCtxt};\n+use rustc_session::Session;\n+use rustc_target::abi::{HasDataLayout, Size, TagEncoding, Variants};\n+\n+/// A pass that seeks to optimize unnecessary moves of large enum types, if there is a large\n+/// enough discrepancy between them.\n+///\n+/// i.e. If there is are two variants:\n+/// ```\n+/// enum Example {\n+///   Small,\n+///   Large([u32; 1024]),\n+/// }\n+/// ```\n+/// Instead of emitting moves of the large variant,\n+/// Perform a memcpy instead.\n+/// Based off of [this HackMD](https://hackmd.io/@ft4bxUsFT5CEUBmRKYHr7w/rJM8BBPzD).\n+///\n+/// In summary, what this does is at runtime determine which enum variant is active,\n+/// and instead of copying all the bytes of the largest possible variant,\n+/// copy only the bytes for the currently active variant.\n+pub struct EnumSizeOpt {\n+    pub(crate) discrepancy: u64,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for EnumSizeOpt {\n+    fn is_enabled(&self, sess: &Session) -> bool {\n+        sess.opts.unstable_opts.unsound_mir_opts || sess.mir_opt_level() >= 3\n+    }\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // NOTE: This pass may produce different MIR based on the alignment of the target\n+        // platform, but it will still be valid.\n+        self.optim(tcx, body);\n+    }\n+}\n+\n+impl EnumSizeOpt {\n+    fn candidate<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        alloc_cache: &mut FxHashMap<Ty<'tcx>, AllocId>,\n+    ) -> Option<(AdtDef<'tcx>, usize, AllocId)> {\n+        let adt_def = match ty.kind() {\n+            ty::Adt(adt_def, _substs) if adt_def.is_enum() => adt_def,\n+            _ => return None,\n+        };\n+        let layout = tcx.layout_of(param_env.and(ty)).ok()?;\n+        let variants = match &layout.variants {\n+            Variants::Single { .. } => return None,\n+            Variants::Multiple { tag_encoding, .. }\n+                if matches!(tag_encoding, TagEncoding::Niche { .. }) =>\n+            {\n+                return None;\n+            }\n+            Variants::Multiple { variants, .. } if variants.len() <= 1 => return None,\n+            Variants::Multiple { variants, .. } => variants,\n+        };\n+        let min = variants.iter().map(|v| v.size).min().unwrap();\n+        let max = variants.iter().map(|v| v.size).max().unwrap();\n+        if max.bytes() - min.bytes() < self.discrepancy {\n+            return None;\n+        }\n+\n+        let num_discrs = adt_def.discriminants(tcx).count();\n+        if variants.iter_enumerated().any(|(var_idx, _)| {\n+            let discr_for_var = adt_def.discriminant_for_variant(tcx, var_idx).val;\n+            (discr_for_var > usize::MAX as u128) || (discr_for_var as usize >= num_discrs)\n+        }) {\n+            return None;\n+        }\n+        if let Some(alloc_id) = alloc_cache.get(&ty) {\n+            return Some((*adt_def, num_discrs, *alloc_id));\n+        }\n+\n+        let data_layout = tcx.data_layout();\n+        let ptr_sized_int = data_layout.ptr_sized_integer();\n+        let target_bytes = ptr_sized_int.size().bytes() as usize;\n+        let mut data = vec![0; target_bytes * num_discrs];\n+        macro_rules! encode_store {\n+            ($curr_idx: expr, $endian: expr, $bytes: expr) => {\n+                let bytes = match $endian {\n+                    rustc_target::abi::Endian::Little => $bytes.to_le_bytes(),\n+                    rustc_target::abi::Endian::Big => $bytes.to_be_bytes(),\n+                };\n+                for (i, b) in bytes.into_iter().enumerate() {\n+                    data[$curr_idx + i] = b;\n+                }\n+            };\n+        }\n+\n+        for (var_idx, layout) in variants.iter_enumerated() {\n+            let curr_idx =\n+                target_bytes * adt_def.discriminant_for_variant(tcx, var_idx).val as usize;\n+            let sz = layout.size;\n+            match ptr_sized_int {\n+                rustc_target::abi::Integer::I32 => {\n+                    encode_store!(curr_idx, data_layout.endian, sz.bytes() as u32);\n+                }\n+                rustc_target::abi::Integer::I64 => {\n+                    encode_store!(curr_idx, data_layout.endian, sz.bytes());\n+                }\n+                _ => unreachable!(),\n+            };\n+        }\n+        let alloc = interpret::Allocation::from_bytes(\n+            data,\n+            tcx.data_layout.ptr_sized_integer().align(&tcx.data_layout).abi,\n+            Mutability::Not,\n+        );\n+        let alloc = tcx.create_memory_alloc(tcx.intern_const_alloc(alloc));\n+        Some((*adt_def, num_discrs, *alloc_cache.entry(ty).or_insert(alloc)))\n+    }\n+    fn optim<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut alloc_cache = FxHashMap::default();\n+        let body_did = body.source.def_id();\n+        let param_env = tcx.param_env(body_did);\n+\n+        let blocks = body.basic_blocks.as_mut();\n+        let local_decls = &mut body.local_decls;\n+\n+        for bb in blocks {\n+            bb.expand_statements(|st| {\n+                if let StatementKind::Assign(box (\n+                    lhs,\n+                    Rvalue::Use(Operand::Copy(rhs) | Operand::Move(rhs)),\n+                )) = &st.kind\n+                {\n+                    let ty = lhs.ty(local_decls, tcx).ty;\n+\n+                    let source_info = st.source_info;\n+                    let span = source_info.span;\n+\n+                    let (adt_def, num_variants, alloc_id) =\n+                        self.candidate(tcx, param_env, ty, &mut alloc_cache)?;\n+                    let alloc = tcx.global_alloc(alloc_id).unwrap_memory();\n+\n+                    let tmp_ty = tcx.mk_ty(ty::Array(\n+                        tcx.types.usize,\n+                        Const::from_usize(tcx, num_variants as u64),\n+                    ));\n+\n+                    let size_array_local = local_decls.push(LocalDecl::new(tmp_ty, span));\n+                    let store_live = Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageLive(size_array_local),\n+                    };\n+\n+                    let place = Place::from(size_array_local);\n+                    let constant_vals = Constant {\n+                        span,\n+                        user_ty: None,\n+                        literal: ConstantKind::Val(\n+                            interpret::ConstValue::ByRef { alloc, offset: Size::ZERO },\n+                            tmp_ty,\n+                        ),\n+                    };\n+                    let rval = Rvalue::Use(Operand::Constant(box (constant_vals)));\n+\n+                    let const_assign =\n+                        Statement { source_info, kind: StatementKind::Assign(box (place, rval)) };\n+\n+                    let discr_place = Place::from(\n+                        local_decls\n+                            .push(LocalDecl::new(adt_def.repr().discr_type().to_ty(tcx), span)),\n+                    );\n+\n+                    let store_discr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (discr_place, Rvalue::Discriminant(*rhs))),\n+                    };\n+\n+                    let discr_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n+\n+                    let cast_discr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            discr_cast_place,\n+                            Rvalue::Cast(\n+                                CastKind::IntToInt,\n+                                Operand::Copy(discr_place),\n+                                tcx.types.usize,\n+                            ),\n+                        )),\n+                    };\n+\n+                    let size_place =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.types.usize, span)));\n+\n+                    let store_size = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            size_place,\n+                            Rvalue::Use(Operand::Copy(Place {\n+                                local: size_array_local,\n+                                projection: tcx.intern_place_elems(&[PlaceElem::Index(\n+                                    discr_cast_place.local,\n+                                )]),\n+                            })),\n+                        )),\n+                    };\n+\n+                    let dst =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.mk_mut_ptr(ty), span)));\n+\n+                    let dst_ptr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            dst,\n+                            Rvalue::AddressOf(Mutability::Mut, *lhs),\n+                        )),\n+                    };\n+\n+                    let dst_cast_ty = tcx.mk_mut_ptr(tcx.types.u8);\n+                    let dst_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(dst_cast_ty, span)));\n+\n+                    let dst_cast = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            dst_cast_place,\n+                            Rvalue::Cast(CastKind::PtrToPtr, Operand::Copy(dst), dst_cast_ty),\n+                        )),\n+                    };\n+\n+                    let src =\n+                        Place::from(local_decls.push(LocalDecl::new(tcx.mk_imm_ptr(ty), span)));\n+\n+                    let src_ptr = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            src,\n+                            Rvalue::AddressOf(Mutability::Not, *rhs),\n+                        )),\n+                    };\n+\n+                    let src_cast_ty = tcx.mk_imm_ptr(tcx.types.u8);\n+                    let src_cast_place =\n+                        Place::from(local_decls.push(LocalDecl::new(src_cast_ty, span)));\n+\n+                    let src_cast = Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            src_cast_place,\n+                            Rvalue::Cast(CastKind::PtrToPtr, Operand::Copy(src), src_cast_ty),\n+                        )),\n+                    };\n+\n+                    let deinit_old =\n+                        Statement { source_info, kind: StatementKind::Deinit(box dst) };\n+\n+                    let copy_bytes = Statement {\n+                        source_info,\n+                        kind: StatementKind::Intrinsic(\n+                            box NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping {\n+                                src: Operand::Copy(src_cast_place),\n+                                dst: Operand::Copy(dst_cast_place),\n+                                count: Operand::Copy(size_place),\n+                            }),\n+                        ),\n+                    };\n+\n+                    let store_dead = Statement {\n+                        source_info,\n+                        kind: StatementKind::StorageDead(size_array_local),\n+                    };\n+                    let iter = [\n+                        store_live,\n+                        const_assign,\n+                        store_discr,\n+                        cast_discr,\n+                        store_size,\n+                        dst_ptr,\n+                        dst_cast,\n+                        src_ptr,\n+                        src_cast,\n+                        deinit_old,\n+                        copy_bytes,\n+                        store_dead,\n+                    ]\n+                    .into_iter();\n+\n+                    st.make_nop();\n+                    Some(iter)\n+                } else {\n+                    None\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "45cd4024c9f57513be06007a5297b1c5d0733c07", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -1,6 +1,7 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(box_syntax)]\n #![feature(let_chains)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n@@ -73,6 +74,7 @@ mod function_item_references;\n mod generator;\n mod inline;\n mod instcombine;\n+mod large_enums;\n mod lower_intrinsics;\n mod lower_slice_len;\n mod match_branches;\n@@ -583,6 +585,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &simplify::SimplifyLocals::new(\"final\"),\n             &multiple_return_terminators::MultipleReturnTerminators,\n             &deduplicate_blocks::DeduplicateBlocks,\n+            &large_enums::EnumSizeOpt { discrepancy: 128 },\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n             // Dump the end result for testing and debugging purposes."}, {"sha": "b139deeee1fc99c027648061664198b1b01fb455", "filename": "tests/mir-opt/enum_opt.cand.EnumSizeOpt.32bit.diff", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.32bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,68 @@\n+- // MIR for `cand` before EnumSizeOpt\n++ // MIR for `cand` after EnumSizeOpt\n+  \n+  fn cand() -> Candidate {\n+      let mut _0: Candidate;               // return place in scope 0 at $DIR/enum_opt.rs:+0:18: +0:27\n+      let mut _1: Candidate;               // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: Candidate;               // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:34\n+      let mut _3: [u8; 8196];              // in scope 0 at $DIR/enum_opt.rs:+2:24: +2:33\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _8: *mut Candidate;          // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _10: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _12: [usize; 2];             // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _13: isize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _14: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _15: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _16: *mut Candidate;         // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _17: *mut u8;                // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _18: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _19: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = Candidate::Small(const 1_u8); // scope 0 at $DIR/enum_opt.rs:+1:15: +1:34\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _3 = [const 1_u8; 8196];         // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _2 = Candidate::Large(move _3);  // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _4 = const [2_usize, 8197_usize]; // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _6 = _5 as usize (IntToInt);     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _9 = _8 as *mut u8 (PtrToPtr);   // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _11 = _10 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         Deinit(_8);                      // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         copy_nonoverlapping(dst = _9, src = _11, count = _7); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+-         _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageLive(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _12 = const [2_usize, 8197_usize]; // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _13 = discriminant(_1);          // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _14 = _13 as usize (IntToInt);   // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _15 = _12[_14];                  // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _16 = &raw mut _0;               // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _17 = _16 as *mut u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _18 = &raw const _1;             // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _19 = _18 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         Deinit(_16);                     // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         copy_nonoverlapping(dst = _17, src = _19, count = _15); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageDead(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "b139deeee1fc99c027648061664198b1b01fb455", "filename": "tests/mir-opt/enum_opt.cand.EnumSizeOpt.64bit.diff", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.cand.EnumSizeOpt.64bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,68 @@\n+- // MIR for `cand` before EnumSizeOpt\n++ // MIR for `cand` after EnumSizeOpt\n+  \n+  fn cand() -> Candidate {\n+      let mut _0: Candidate;               // return place in scope 0 at $DIR/enum_opt.rs:+0:18: +0:27\n+      let mut _1: Candidate;               // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: Candidate;               // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:34\n+      let mut _3: [u8; 8196];              // in scope 0 at $DIR/enum_opt.rs:+2:24: +2:33\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _8: *mut Candidate;          // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _10: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:34\n++     let mut _12: [usize; 2];             // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _13: isize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _14: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _15: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _16: *mut Candidate;         // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _17: *mut u8;                // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _18: *const Candidate;       // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _19: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = Candidate::Small(const 1_u8); // scope 0 at $DIR/enum_opt.rs:+1:15: +1:34\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _3 = [const 1_u8; 8196];         // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _2 = Candidate::Large(move _3);  // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _4 = const [2_usize, 8197_usize]; // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _6 = _5 as usize (IntToInt);     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _9 = _8 as *mut u8 (PtrToPtr);   // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         _11 = _10 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         Deinit(_8);                      // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         copy_nonoverlapping(dst = _9, src = _11, count = _7); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+-         _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageLive(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _12 = const [2_usize, 8197_usize]; // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _13 = discriminant(_1);          // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _14 = _13 as usize (IntToInt);   // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _15 = _12[_14];                  // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _16 = &raw mut _0;               // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _17 = _16 as *mut u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _18 = &raw const _1;             // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _19 = _18 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         Deinit(_16);                     // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         copy_nonoverlapping(dst = _17, src = _19, count = _15); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageDead(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "a80001149ebb75aa32b61ef794a31dd495da9902", "filename": "tests/mir-opt/enum_opt.invalid.EnumSizeOpt.32bit.diff", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.32bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,28 @@\n+- // MIR for `invalid` before EnumSizeOpt\n++ // MIR for `invalid` after EnumSizeOpt\n+  \n+  fn invalid() -> InvalidIdxs {\n+      let mut _0: InvalidIdxs;             // return place in scope 0 at $DIR/enum_opt.rs:+0:21: +0:32\n+      let mut _1: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:36\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:+2:26: +2:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = InvalidIdxs::A;             // scope 0 at $DIR/enum_opt.rs:+1:15: +1:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:36\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:26: +2:35\n+          _3 = [const 0_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:+2:26: +2:35\n+          _2 = InvalidIdxs::Large(move _3); // scope 1 at $DIR/enum_opt.rs:+2:7: +2:36\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:35: +2:36\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:36\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:35: +2:36\n+          _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "a80001149ebb75aa32b61ef794a31dd495da9902", "filename": "tests/mir-opt/enum_opt.invalid.EnumSizeOpt.64bit.diff", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.invalid.EnumSizeOpt.64bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,28 @@\n+- // MIR for `invalid` before EnumSizeOpt\n++ // MIR for `invalid` after EnumSizeOpt\n+  \n+  fn invalid() -> InvalidIdxs {\n+      let mut _0: InvalidIdxs;             // return place in scope 0 at $DIR/enum_opt.rs:+0:21: +0:32\n+      let mut _1: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: InvalidIdxs;             // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:36\n+      let mut _3: [u64; 1024];             // in scope 0 at $DIR/enum_opt.rs:+2:26: +2:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = InvalidIdxs::A;             // scope 0 at $DIR/enum_opt.rs:+1:15: +1:29\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:36\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:26: +2:35\n+          _3 = [const 0_u64; 1024];        // scope 1 at $DIR/enum_opt.rs:+2:26: +2:35\n+          _2 = InvalidIdxs::Large(move _3); // scope 1 at $DIR/enum_opt.rs:+2:7: +2:36\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:35: +2:36\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:36\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:35: +2:36\n+          _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "2768d708049260d6e2ea9d532ce9d6a442744ff9", "filename": "tests/mir-opt/enum_opt.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.rs?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,86 @@\n+// unit-test: EnumSizeOpt\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+// compile-flags: -Zunsound-mir-opts\n+\n+#![feature(arbitrary_enum_discriminant, repr128)]\n+\n+// Tests that an enum with a variant with no data gets correctly transformed.\n+pub enum NoData {\n+  Large([u8; 8196]),\n+  None,\n+}\n+\n+// Tests that an enum with a variant with data that is a valid candidate gets transformed.\n+pub enum Candidate {\n+  Small(u8),\n+  Large([u8; 8196]),\n+}\n+\n+// Tests that an enum which has a discriminant much higher than the variant does not get\n+// tformed.\n+#[repr(u32)]\n+pub enum InvalidIdxs {\n+  A = 302,\n+  Large([u64; 1024]),\n+}\n+\n+// Tests that an enum with too high of a discriminant index (not in bounds of usize) does not\n+// get tformed.\n+#[repr(u128)]\n+pub enum NotTrunctable {\n+    A = 0,\n+    B([u8; 1024]) = 1,\n+    C([u8; 4096]) = 0x10000000000000001,\n+}\n+\n+// Tests that an enum with discriminants in random order still gets tformed correctly.\n+#[repr(u32)]\n+pub enum RandOrderDiscr {\n+  A = 13,\n+  B([u8; 1024]) = 5,\n+  C = 7,\n+}\n+\n+// EMIT_MIR enum_opt.unin.EnumSizeOpt.diff\n+pub fn unin() -> NoData {\n+  let mut a = NoData::None;\n+  a = NoData::Large([1; 8196]);\n+  a\n+}\n+\n+// EMIT_MIR enum_opt.cand.EnumSizeOpt.diff\n+pub fn cand() -> Candidate {\n+  let mut a = Candidate::Small(1);\n+  a = Candidate::Large([1; 8196]);\n+  a\n+}\n+\n+// EMIT_MIR enum_opt.invalid.EnumSizeOpt.diff\n+pub fn invalid() -> InvalidIdxs {\n+  let mut a = InvalidIdxs::A;\n+  a = InvalidIdxs::Large([0; 1024]);\n+  a\n+}\n+\n+// EMIT_MIR enum_opt.trunc.EnumSizeOpt.diff\n+pub fn trunc() -> NotTrunctable {\n+  let mut a = NotTrunctable::A;\n+  a = NotTrunctable::B([0; 1024]);\n+  a = NotTrunctable::C([0; 4096]);\n+  a\n+}\n+\n+pub fn rand_order() -> RandOrderDiscr {\n+  let mut a = RandOrderDiscr::A;\n+  a = RandOrderDiscr::B([0; 1024]);\n+  a = RandOrderDiscr::C;\n+  a\n+}\n+\n+pub fn main() {\n+  unin();\n+  cand();\n+  invalid();\n+  trunc();\n+  rand_order();\n+}"}, {"sha": "1ef79044d4fc6cf5cfa54a64087b73dbf0e61433", "filename": "tests/mir-opt/enum_opt.trunc.EnumSizeOpt.32bit.diff", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.32bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,37 @@\n+- // MIR for `trunc` before EnumSizeOpt\n++ // MIR for `trunc` after EnumSizeOpt\n+  \n+  fn trunc() -> NotTrunctable {\n+      let mut _0: NotTrunctable;           // return place in scope 0 at $DIR/enum_opt.rs:+0:19: +0:32\n+      let mut _1: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:34\n+      let mut _3: [u8; 1024];              // in scope 0 at $DIR/enum_opt.rs:+2:24: +2:33\n+      let mut _4: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+3:7: +3:34\n+      let mut _5: [u8; 4096];              // in scope 0 at $DIR/enum_opt.rs:+3:24: +3:33\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = NotTrunctable::A;           // scope 0 at $DIR/enum_opt.rs:+1:15: +1:31\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _3 = [const 0_u8; 1024];         // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _2 = NotTrunctable::B(move _3);  // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+          StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+3:7: +3:34\n+          StorageLive(_5);                 // scope 1 at $DIR/enum_opt.rs:+3:24: +3:33\n+          _5 = [const 0_u8; 4096];         // scope 1 at $DIR/enum_opt.rs:+3:24: +3:33\n+          _4 = NotTrunctable::C(move _5);  // scope 1 at $DIR/enum_opt.rs:+3:7: +3:34\n+          StorageDead(_5);                 // scope 1 at $DIR/enum_opt.rs:+3:33: +3:34\n+          _1 = move _4;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:34\n+          StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+3:33: +3:34\n+          _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+4:3: +4:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+5:1: +5:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "1ef79044d4fc6cf5cfa54a64087b73dbf0e61433", "filename": "tests/mir-opt/enum_opt.trunc.EnumSizeOpt.64bit.diff", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.trunc.EnumSizeOpt.64bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,37 @@\n+- // MIR for `trunc` before EnumSizeOpt\n++ // MIR for `trunc` after EnumSizeOpt\n+  \n+  fn trunc() -> NotTrunctable {\n+      let mut _0: NotTrunctable;           // return place in scope 0 at $DIR/enum_opt.rs:+0:19: +0:32\n+      let mut _1: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:34\n+      let mut _3: [u8; 1024];              // in scope 0 at $DIR/enum_opt.rs:+2:24: +2:33\n+      let mut _4: NotTrunctable;           // in scope 0 at $DIR/enum_opt.rs:+3:7: +3:34\n+      let mut _5: [u8; 4096];              // in scope 0 at $DIR/enum_opt.rs:+3:24: +3:33\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = NotTrunctable::A;           // scope 0 at $DIR/enum_opt.rs:+1:15: +1:31\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _3 = [const 0_u8; 1024];         // scope 1 at $DIR/enum_opt.rs:+2:24: +2:33\n+          _2 = NotTrunctable::B(move _3);  // scope 1 at $DIR/enum_opt.rs:+2:7: +2:34\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+          _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:34\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:33: +2:34\n+          StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+3:7: +3:34\n+          StorageLive(_5);                 // scope 1 at $DIR/enum_opt.rs:+3:24: +3:33\n+          _5 = [const 0_u8; 4096];         // scope 1 at $DIR/enum_opt.rs:+3:24: +3:33\n+          _4 = NotTrunctable::C(move _5);  // scope 1 at $DIR/enum_opt.rs:+3:7: +3:34\n+          StorageDead(_5);                 // scope 1 at $DIR/enum_opt.rs:+3:33: +3:34\n+          _1 = move _4;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:34\n+          StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+3:33: +3:34\n+          _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+4:3: +4:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+5:1: +5:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "ad9f12cf9595373c1ba60d825aa076b01b19dbdc", "filename": "tests/mir-opt/enum_opt.unin.EnumSizeOpt.32bit.diff", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.32bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,68 @@\n+- // MIR for `unin` before EnumSizeOpt\n++ // MIR for `unin` after EnumSizeOpt\n+  \n+  fn unin() -> NoData {\n+      let mut _0: NoData;                  // return place in scope 0 at $DIR/enum_opt.rs:+0:18: +0:24\n+      let mut _1: NoData;                  // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: NoData;                  // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:31\n+      let mut _3: [u8; 8196];              // in scope 0 at $DIR/enum_opt.rs:+2:21: +2:30\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _8: *mut NoData;             // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _10: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _12: [usize; 2];             // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _13: isize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _14: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _15: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _16: *mut NoData;            // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _17: *mut u8;                // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _18: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _19: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = NoData::None;               // scope 0 at $DIR/enum_opt.rs:+1:15: +1:27\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:31\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:21: +2:30\n+          _3 = [const 1_u8; 8196];         // scope 1 at $DIR/enum_opt.rs:+2:21: +2:30\n+          _2 = NoData::Large(move _3);     // scope 1 at $DIR/enum_opt.rs:+2:7: +2:31\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:30: +2:31\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _4 = const [8197_usize, 1_usize]; // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _6 = _5 as usize (IntToInt);     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _9 = _8 as *mut u8 (PtrToPtr);   // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _11 = _10 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         Deinit(_8);                      // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         copy_nonoverlapping(dst = _9, src = _11, count = _7); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:30: +2:31\n+-         _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageLive(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _12 = const [8197_usize, 1_usize]; // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _13 = discriminant(_1);          // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _14 = _13 as usize (IntToInt);   // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _15 = _12[_14];                  // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _16 = &raw mut _0;               // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _17 = _16 as *mut u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _18 = &raw const _1;             // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _19 = _18 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         Deinit(_16);                     // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         copy_nonoverlapping(dst = _17, src = _19, count = _15); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageDead(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "ad9f12cf9595373c1ba60d825aa076b01b19dbdc", "filename": "tests/mir-opt/enum_opt.unin.EnumSizeOpt.64bit.diff", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5a8dfd933a70cc47e44502a20fd67dfaec6555d5/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fenum_opt.unin.EnumSizeOpt.64bit.diff?ref=5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "patch": "@@ -0,0 +1,68 @@\n+- // MIR for `unin` before EnumSizeOpt\n++ // MIR for `unin` after EnumSizeOpt\n+  \n+  fn unin() -> NoData {\n+      let mut _0: NoData;                  // return place in scope 0 at $DIR/enum_opt.rs:+0:18: +0:24\n+      let mut _1: NoData;                  // in scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+      let mut _2: NoData;                  // in scope 0 at $DIR/enum_opt.rs:+2:7: +2:31\n+      let mut _3: [u8; 8196];              // in scope 0 at $DIR/enum_opt.rs:+2:21: +2:30\n++     let mut _4: [usize; 2];              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _5: isize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _6: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _7: usize;                   // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _8: *mut NoData;             // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _9: *mut u8;                 // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _10: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _11: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+2:3: +2:31\n++     let mut _12: [usize; 2];             // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _13: isize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _14: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _15: usize;                  // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _16: *mut NoData;            // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _17: *mut u8;                // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _18: *const NoData;          // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n++     let mut _19: *const u8;              // in scope 0 at $DIR/enum_opt.rs:+3:3: +3:4\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/enum_opt.rs:+1:7: +1:12\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/enum_opt.rs:+1:7: +1:12\n+          _1 = NoData::None;               // scope 0 at $DIR/enum_opt.rs:+1:15: +1:27\n+          StorageLive(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:7: +2:31\n+          StorageLive(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:21: +2:30\n+          _3 = [const 1_u8; 8196];         // scope 1 at $DIR/enum_opt.rs:+2:21: +2:30\n+          _2 = NoData::Large(move _3);     // scope 1 at $DIR/enum_opt.rs:+2:7: +2:31\n+          StorageDead(_3);                 // scope 1 at $DIR/enum_opt.rs:+2:30: +2:31\n+-         _1 = move _2;                    // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         StorageLive(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _4 = const [8197_usize, 1_usize]; // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _5 = discriminant(_2);           // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _6 = _5 as usize (IntToInt);     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _7 = _4[_6];                     // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _8 = &raw mut _1;                // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _9 = _8 as *mut u8 (PtrToPtr);   // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _10 = &raw const _2;             // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         _11 = _10 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         Deinit(_8);                      // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         copy_nonoverlapping(dst = _9, src = _11, count = _7); // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n++         StorageDead(_4);                 // scope 1 at $DIR/enum_opt.rs:+2:3: +2:31\n+          StorageDead(_2);                 // scope 1 at $DIR/enum_opt.rs:+2:30: +2:31\n+-         _0 = move _1;                    // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageLive(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _12 = const [8197_usize, 1_usize]; // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _13 = discriminant(_1);          // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _14 = _13 as usize (IntToInt);   // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _15 = _12[_14];                  // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _16 = &raw mut _0;               // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _17 = _16 as *mut u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _18 = &raw const _1;             // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         _19 = _18 as *const u8 (PtrToPtr); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         Deinit(_16);                     // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         copy_nonoverlapping(dst = _17, src = _19, count = _15); // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n++         StorageDead(_12);                // scope 1 at $DIR/enum_opt.rs:+3:3: +3:4\n+          StorageDead(_1);                 // scope 0 at $DIR/enum_opt.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/enum_opt.rs:+4:2: +4:2\n+      }\n+  }\n+  "}]}