{"sha": "8da59521e1d88677fa875770e5a3e091a199265f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTU5NTIxZTFkODg2NzdmYTg3NTc3MGU1YTNlMDkxYTE5OTI2NWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-15T07:10:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-15T07:10:03Z"}, "message": "Rollup merge of #71100 - RalfJung:miri-frame-hook, r=oli-obk\n\nMiri: expand frame hooks\n\nThis is needed to make https://github.com/rust-lang/miri/pull/1330 work.\n\nr? @oli-obk @eddyb", "tree": {"sha": "2415a90dc02d6f69095d5d8461278e4d656c6bb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2415a90dc02d6f69095d5d8461278e4d656c6bb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da59521e1d88677fa875770e5a3e091a199265f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJelrNLCRBK7hj4Ov3rIwAAdHIIABO9XnhmwZjz7V5rBiwIgv0c\nokcD+b2nbUlRLAzet09FYlUgKAijCtOV/I8Dr5BCcKdL12O5uT9WhzXTtVBtzgEW\nCOIwcc7ip65Y4GLY2vFndBdKKhQCyijt+wO/bPpDVIY90vJBh0lI4MzVl2VuGiws\nJ6XosCv26cHft8HZxgahuLrsQFuKeNzYENUxKHuQCcxR4o6MsNpvXDhk1YpgLstw\nltIOK4uB3hAAsYaXTFT5mwVn9VU+KEVF/Ohx5k3Zwty0z5/+bFizjkFiOo32CG54\n80g3VQt07FDdfoPpb8vesRnCxg3Cpd7DXwGdhkTFyl+0JNkbby0/ry8HZaqA9nQ=\n=Uj3V\n-----END PGP SIGNATURE-----\n", "payload": "tree 2415a90dc02d6f69095d5d8461278e4d656c6bb5\nparent ffafd1528094cc9355e751d4b0595a89a11a9a8e\nparent f2d4c93c6c56d8cfe1d69646ba1f788823e6bc35\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586934603 +0200\ncommitter GitHub <noreply@github.com> 1586934603 +0200\n\nRollup merge of #71100 - RalfJung:miri-frame-hook, r=oli-obk\n\nMiri: expand frame hooks\n\nThis is needed to make https://github.com/rust-lang/miri/pull/1330 work.\n\nr? @oli-obk @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da59521e1d88677fa875770e5a3e091a199265f", "html_url": "https://github.com/rust-lang/rust/commit/8da59521e1d88677fa875770e5a3e091a199265f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da59521e1d88677fa875770e5a3e091a199265f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffafd1528094cc9355e751d4b0595a89a11a9a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffafd1528094cc9355e751d4b0595a89a11a9a8e", "html_url": "https://github.com/rust-lang/rust/commit/ffafd1528094cc9355e751d4b0595a89a11a9a8e"}, {"sha": "f2d4c93c6c56d8cfe1d69646ba1f788823e6bc35", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d4c93c6c56d8cfe1d69646ba1f788823e6bc35", "html_url": "https://github.com/rust-lang/rust/commit/f2d4c93c6c56d8cfe1d69646ba1f788823e6bc35"}], "stats": {"total": 134, "additions": 88, "deletions": 46}, "files": [{"sha": "3f0774767fd7a4ede2666ff6c41cd1c4bc2226bb", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -1,7 +1,7 @@\n use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InternKind,\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n     ScalarMaybeUndef, StackPopCleanup,\n };\n@@ -147,25 +147,28 @@ pub(super) fn op_to_const<'tcx>(\n     match immediate {\n         Ok(mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n-        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n-            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n+        Err(imm) => match *imm {\n+            Immediate::Scalar(x) => match x {\n+                ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+                ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n+            },\n+            Immediate::ScalarPair(a, b) => {\n+                let (data, start) = match a.not_undef().unwrap() {\n+                    Scalar::Ptr(ptr) => {\n+                        (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                    }\n+                    Scalar::Raw { .. } => (\n+                        ecx.tcx\n+                            .intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n+                        0,\n+                    ),\n+                };\n+                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let start = start.try_into().unwrap();\n+                let len: usize = len.try_into().unwrap();\n+                ConstValue::Slice { data, start, end: start + len }\n+            }\n         },\n-        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n-            let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => {\n-                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                }\n-                Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n-                    0,\n-                ),\n-            };\n-            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n-            let start = start.try_into().unwrap();\n-            let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice { data, start, end: start + len }\n-        }\n     }\n }\n "}, {"sha": "e53ca6b31bb67f276471af7be9a54d459602593c", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -13,8 +13,8 @@ use rustc_middle::mir::AssertMessage;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n-    self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n-    PlaceTy, Pointer, Scalar,\n+    self, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind,\n+    OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n@@ -342,8 +342,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n     }\n \n     #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        Ok(frame)\n     }\n \n     fn before_access_global("}, {"sha": "f111eecb9450e33625f58147a24f01839b362a98", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -159,6 +159,21 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n+impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n+    pub fn with_extra<Extra>(self, extra: Extra) -> Frame<'mir, 'tcx, Tag, Extra> {\n+        Frame {\n+            body: self.body,\n+            instance: self.instance,\n+            return_to_block: self.return_to_block,\n+            return_place: self.return_place,\n+            locals: self.locals,\n+            block: self.block,\n+            stmt: self.stmt,\n+            extra,\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<mir::SourceInfo> {\n@@ -586,8 +601,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ::log_settings::settings().indentation += 1;\n \n         // first push a stack frame so we have access to the local substs\n-        let extra = M::stack_push(self)?;\n-        self.stack.push(Frame {\n+        let pre_frame = Frame {\n             body,\n             block: Some(mir::START_BLOCK),\n             return_to_block,\n@@ -597,8 +611,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             locals: IndexVec::new(),\n             instance,\n             stmt: 0,\n-            extra,\n-        });\n+            extra: (),\n+        };\n+        let frame = M::init_frame_extra(self, pre_frame)?;\n+        self.stack.push(frame);\n \n         // don't allocate at all for trivial constants\n         if body.local_decls.len() > 1 {\n@@ -630,6 +646,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().locals = locals;\n         }\n \n+        M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > *self.tcx.sess.recursion_limit.get() {\n@@ -725,16 +742,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         // Cleanup: deallocate all locals that are backed by an allocation.\n-        for local in frame.locals {\n+        for local in &frame.locals {\n             self.deallocate_local(local.value)?;\n         }\n \n-        if M::stack_pop(self, frame.extra, unwinding)? == StackPopJump::NoJump {\n+        let return_place = frame.return_place;\n+        if M::after_stack_pop(self, frame, unwinding)? == StackPopJump::NoJump {\n             // The hook already did everything.\n             // We want to skip the `info!` below, hence early return.\n             return Ok(());\n         }\n-        // Normal return.\n+        // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n             let unwind = next_block.expect(\"Encountered StackPopCleanup::None when unwinding!\");\n@@ -743,7 +761,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Follow the normal return edge.\n             // Validate the return value. Do this after deallocating so that we catch dangling\n             // references.\n-            if let Some(return_place) = frame.return_place {\n+            if let Some(return_place) = return_place {\n                 if M::enforce_validity(self) {\n                     // Data got changed, better make sure it matches the type!\n                     // It is still possible that the return place held invalid data while"}, {"sha": "8bf8d904cb29eb8c3a1ce3f6489b50cd145dd15d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -279,13 +279,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called immediately before a new stack frame got pushed.\n-    fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n+    /// Called immediately before a new stack frame gets pushed.\n+    fn init_frame_extra(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx, Self::PointerTag>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n+\n+    /// Called immediately after a stack frame got pushed and its locals got initialized.\n+    fn after_stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n \n-    /// Called immediately after a stack frame gets popped\n-    fn stack_pop(\n+    /// Called immediately after a stack frame got popped, but before jumping back to the caller.\n+    fn after_stack_pop(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _extra: Self::FrameExtra,\n+        _frame: Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n         _unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         // By default, we do not support unwinding from panics"}, {"sha": "893f4c1db7e0aa20b24c9d82228d2e582d40e4cb", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -87,7 +87,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag = ()> {\n-    pub(crate) imm: Immediate<Tag>,\n+    imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -183,6 +183,11 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n         ImmTy { imm: val.into(), layout }\n     }\n \n+    #[inline]\n+    pub fn from_immediate(imm: Immediate<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n+        ImmTy { imm, layout }\n+    }\n+\n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, layout: TyAndLayout<'tcx>) -> Option<Self> {\n         Some(Self::from_scalar(Scalar::try_from_uint(i, layout.size)?, layout))\n@@ -424,7 +429,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op, layout })\n     }\n \n-    /// Every place can be read from, so we can turn them into an operand\n+    /// Every place can be read from, so we can turn them into an operand.\n+    /// This will definitely return `Indirect` if the place is a `Ptr`, i.e., this\n+    /// will never actually read from memory.\n     #[inline(always)]\n     pub fn place_to_op(\n         &self,"}, {"sha": "9ac4b3551fc4307c0ea01da5f11d5929ca4ff1d8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -247,7 +247,7 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n             Operand::Immediate(_) if self.layout.is_zst() => {\n                 Ok(MPlaceTy::dangling(self.layout, cx))\n             }\n-            Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n+            Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }\n "}, {"sha": "49fee1bddcb6db1b06cdc8343938ff2896ea8373", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -407,7 +407,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n                 // Adjust receiver argument.\n                 args[0] =\n-                    OpTy::from(ImmTy { layout: this_receiver_ptr, imm: receiver_place.ptr.into() });\n+                    OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n@@ -436,10 +436,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => (instance, place),\n         };\n \n-        let arg = ImmTy {\n-            imm: place.to_ref(),\n-            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n-        };\n+        let arg = ImmTy::from_immediate(\n+            place.to_ref(),\n+            self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n+        );\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n         let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);"}, {"sha": "80c12a30135ff6509fc2aa2af41ed908b672dcf7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da59521e1d88677fa875770e5a3e091a199265f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8da59521e1d88677fa875770e5a3e091a199265f", "patch": "@@ -290,8 +290,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        Ok(frame)\n     }\n }\n "}]}