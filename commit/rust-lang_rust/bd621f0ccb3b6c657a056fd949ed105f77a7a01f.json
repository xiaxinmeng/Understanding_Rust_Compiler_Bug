{"sha": "bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNjIxZjBjY2IzYjZjNjU3YTA1NmZkOTQ5ZWQxMDVmNzdhN2EwMWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-16T19:57:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-16T21:43:22Z"}, "message": "Project region bounds out of the trait when deciding whether a\nprojection type outlives a given region. Fixes #20890.", "tree": {"sha": "0cd558e1736e8953da374f7c656faafff22e7efc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd558e1736e8953da374f7c656faafff22e7efc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "html_url": "https://github.com/rust-lang/rust/commit/bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee2bfae011e368e224d6d4f4c9fad13606ee99da", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2bfae011e368e224d6d4f4c9fad13606ee99da", "html_url": "https://github.com/rust-lang/rust/commit/ee2bfae011e368e224d6d4f4c9fad13606ee99da"}], "stats": {"total": 202, "additions": 200, "deletions": 2}, "files": [{"sha": "5c9face66e1d99dc698f43ec4075b585a97a1fc8", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -84,6 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n+#[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region,\n     pub sup_type: Ty<'tcx>,"}, {"sha": "6403c1af8e147b38e33a0129efd58c1d9c94b8a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -297,14 +297,25 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n-        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+\n+        // Make a copy of the region obligations vec because we'll need\n+        // to be able to borrow the fulfillment-cx below when projecting.\n+        let region_obligations =\n+            self.fcx.inh.fulfillment_cx.borrow()\n+                                       .region_obligations(node_id)\n+                                       .to_vec();\n+\n+        for r_o in region_obligations.iter() {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateRegionParamBound(r_o.cause.span);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n+\n+        // Processing the region obligations should not cause the list to grow further:\n+        assert_eq!(region_obligations.len(),\n+                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -1480,6 +1491,15 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                    generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n+    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n+    match *generic {\n+        GenericKind::Param(..) => { }\n+        GenericKind::Projection(ref projection_ty) => {\n+            param_bounds.push_all(\n+                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+        }\n+    }\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n@@ -1511,3 +1531,73 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          region,\n                                          param_bounds);\n }\n+\n+fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              projection_ty: &ty::ProjectionTy<'tcx>)\n+                              -> Vec<ty::Region>\n+{\n+    let fcx = rcx.fcx;\n+    let tcx = fcx.tcx();\n+    let infcx = fcx.infcx();\n+\n+    debug!(\"projection_bounds(projection_ty={})\",\n+           projection_ty.repr(tcx));\n+\n+    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+\n+    // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n+    // in looking for a trait definition like:\n+    //\n+    // ```\n+    // trait SomeTrait<'a> {\n+    //     type SomeType : 'a;\n+    // }\n+    // ```\n+    //\n+    // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n+    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            // we're only interesting in `T : 'a` style predicates:\n+            let outlives = match predicate {\n+                ty::Predicate::TypeOutlives(data) => data,\n+                _ => { return None; }\n+            };\n+\n+            debug!(\"projection_bounds: outlives={} (1)\",\n+                   outlives.repr(tcx));\n+\n+            // apply the substitutions (and normalize any projected types)\n+            let outlives = fcx.instantiate_type_scheme(span,\n+                                                       projection_ty.trait_ref.substs,\n+                                                       &outlives);\n+\n+            debug!(\"projection_bounds: outlives={} (2)\",\n+                   outlives.repr(tcx));\n+\n+            let region_result = infcx.try(|_| {\n+                let (outlives, _) =\n+                    infcx.replace_late_bound_regions_with_fresh_var(\n+                        span,\n+                        infer::AssocTypeProjection(projection_ty.item_name),\n+                        &outlives);\n+\n+                debug!(\"projection_bounds: outlives={} (3)\",\n+                       outlives.repr(tcx));\n+\n+                // check whether this predicate applies to our current projection\n+                match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n+                    Ok(()) => { Ok(outlives.1) }\n+                    Err(_) => { Err(()) }\n+                }\n+            });\n+\n+            debug!(\"projection_bounds: region_result={}\",\n+                   region_result.repr(tcx));\n+\n+            region_result.ok()\n+        })\n+        .collect()\n+}"}, {"sha": "f833361e3b505cc136f093ab56db2ae7b99419b0", "filename": "src/test/compile-fail/regions-assoc-type-region-bound-in-trait-not-met.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler checks that arbitrary region bounds declared\n+// in the trait must be satisfied on the impl. Issue #20890.\n+\n+trait Foo<'a> { type Value: 'a; }\n+\n+impl<'a> Foo<'a> for &'a i16 {\n+    // OK.\n+    type Value = &'a i32;\n+}\n+\n+impl<'a> Foo<'static> for &'a i32 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+impl<'a,'b> Foo<'b> for &'a i64 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+fn main() { }"}, {"sha": "0871d8b01f6e49e324481cf3677fd5d4d16c25eb", "filename": "src/test/compile-fail/regions-assoc-type-static-bound-in-trait-not-met.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler checks that the 'static bound declared in\n+// the trait must be satisfied on the impl. Issue #20890.\n+\n+trait Foo { type Value: 'static; }\n+\n+impl<'a> Foo for &'a i32 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+impl<'a> Foo for i32 {\n+    // OK.\n+    type Value = i32;\n+}\n+\n+fn main() { }"}, {"sha": "77e1a214764540d7226f6fe1f543f6fdb0986442", "filename": "src/test/run-pass/regions-assoc-type-region-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler considers the 'a bound declared in the\n+// trait. Issue #20890.\n+\n+trait Foo<'a> {\n+    type Value: 'a;\n+\n+    fn get(&self) -> &'a Self::Value;\n+}\n+\n+fn takes_foo<'a,F: Foo<'a>>(f: &'a F) {\n+    // This call would be illegal, because it results in &'a F::Value,\n+    // and the only way we know that `F::Value : 'a` is because of the\n+    // trait declaration.\n+\n+    f.get();\n+}\n+\n+fn main() { }"}, {"sha": "6b629a9035db2538504b947f0534e9b17070e317", "filename": "src/test/run-pass/regions-assoc-type-static-bound.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd621f0ccb3b6c657a056fd949ed105f77a7a01f/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs?ref=bd621f0ccb3b6c657a056fd949ed105f77a7a01f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler considers the 'static bound declared in the\n+// trait. Issue #20890.\n+\n+trait Foo { type Value: 'static; }\n+\n+fn require_static<T: 'static>() {}\n+\n+fn takes_foo<F: Foo>() {\n+    require_static::<F::Value>()\n+}\n+\n+fn main() { }"}]}