{"sha": "e0685e22a3a7a5735f635bd28bdcb5084dd5be34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjg1ZTIyYTNhN2E1NzM1ZjYzNWJkMjhiZGNiNTA4NGRkNWJlMzQ=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-25T08:53:27Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-25T10:17:31Z"}, "message": "Make omission of impossible if-else branches work with constants\n\nUntil now, we only optimized away impossible branches when there is a\nliteral true/false in the code. But since the LLVM IR builder already does\nconstant folding for us, we can trivially expand that to work with\nconstants as well.\n\nRefs #7834", "tree": {"sha": "a84ae4838a9e69004e7c3d8977df454736670ac8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a84ae4838a9e69004e7c3d8977df454736670ac8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0685e22a3a7a5735f635bd28bdcb5084dd5be34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0685e22a3a7a5735f635bd28bdcb5084dd5be34", "html_url": "https://github.com/rust-lang/rust/commit/e0685e22a3a7a5735f635bd28bdcb5084dd5be34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0685e22a3a7a5735f635bd28bdcb5084dd5be34/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a08622e8754dbc43ccd2f08031227527645d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a08622e8754dbc43ccd2f08031227527645d39", "html_url": "https://github.com/rust-lang/rust/commit/75a08622e8754dbc43ccd2f08031227527645d39"}], "stats": {"total": 58, "additions": 26, "deletions": 32}, "files": [{"sha": "a00cd94ad54efcb484f0973c4b78014fd23d5a61", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e0685e22a3a7a5735f635bd28bdcb5084dd5be34/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0685e22a3a7a5735f635bd28bdcb5084dd5be34/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e0685e22a3a7a5735f635bd28bdcb5084dd5be34", "patch": "@@ -65,44 +65,38 @@ pub fn trans_if(bcx: @mut Block,\n \n     let _icx = push_ctxt(\"trans_if\");\n \n-    match cond.node {\n-        // `if true` and `if false` can be trans'd more efficiently,\n-        // by dropping branches that are known to be impossible.\n-        ast::expr_lit(@ref l) => match l.node {\n-            ast::lit_bool(true) => {\n-                // if true { .. } [else { .. }]\n-                let then_bcx_in = scope_block(bcx, thn.info(), \"if_true_then\");\n-                let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n-                let then_bcx_out = trans_block_cleanups(then_bcx_out,\n-                                                        block_cleanups(then_bcx_in));\n-                Br(bcx, then_bcx_in.llbb);\n-                return then_bcx_out;\n-            }\n-            ast::lit_bool(false) => {\n-                match els {\n-                    // if false { .. } else { .. }\n-                    Some(elexpr) => {\n-                        let (else_bcx_in, else_bcx_out) =\n-                            trans_if_else(bcx, elexpr, dest, \"if_false_else\");\n-                        Br(bcx, else_bcx_in.llbb);\n-                        return else_bcx_out;\n-                    }\n-                    // if false { .. }\n-                    None => return bcx,\n+    let Result {bcx, val: cond_val} =\n+        expr::trans_to_datum(bcx, cond).to_result();\n+\n+    let cond_val = bool_to_i1(bcx, cond_val);\n+\n+    // Drop branches that are known to be impossible\n+    if is_const(cond_val) && !is_undef(cond_val) {\n+        if const_to_uint(cond_val) == 1 {\n+            // if true { .. } [else { .. }]\n+            let then_bcx_in = scope_block(bcx, thn.info(), \"if_true_then\");\n+            let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n+            let then_bcx_out = trans_block_cleanups(then_bcx_out,\n+                                                    block_cleanups(then_bcx_in));\n+            Br(bcx, then_bcx_in.llbb);\n+            return then_bcx_out;\n+        } else {\n+            match els {\n+                // if false { .. } else { .. }\n+                Some(elexpr) => {\n+                    let (else_bcx_in, else_bcx_out) =\n+                        trans_if_else(bcx, elexpr, dest, \"if_false_else\");\n+                    Br(bcx, else_bcx_in.llbb);\n+                    return else_bcx_out;\n                 }\n+                // if false { .. }\n+                None => return bcx,\n             }\n-            _ => {}\n-        },\n-        _ => {}\n+        }\n     }\n \n-    let Result {bcx, val: cond_val} =\n-        expr::trans_to_datum(bcx, cond).to_result();\n-\n     let then_bcx_in = scope_block(bcx, thn.info(), \"then\");\n \n-    let cond_val = bool_to_i1(bcx, cond_val);\n-\n     let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n     let then_bcx_out = trans_block_cleanups(then_bcx_out,\n                                             block_cleanups(then_bcx_in));"}]}