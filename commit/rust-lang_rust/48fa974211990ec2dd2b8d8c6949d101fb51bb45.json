{"sha": "48fa974211990ec2dd2b8d8c6949d101fb51bb45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZmE5NzQyMTE5OTBlYzJkZDJiOGQ4YzY5NDlkMTAxZmI1MWJiNDU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-11-09T02:54:34Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-11-22T22:14:27Z"}, "message": "Suggest correct syntax when writing type arg instead of assoc type\n\nWhen confusing an associated type with a type argument, suggest the\nappropriate syntax.\n\nGiven `Iterator<isize>`, suggest `Iterator<Item = isize>`.", "tree": {"sha": "2d3395ec5e84232d2d1832bf56d968ef1c0ab8d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3395ec5e84232d2d1832bf56d968ef1c0ab8d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48fa974211990ec2dd2b8d8c6949d101fb51bb45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48fa974211990ec2dd2b8d8c6949d101fb51bb45", "html_url": "https://github.com/rust-lang/rust/commit/48fa974211990ec2dd2b8d8c6949d101fb51bb45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48fa974211990ec2dd2b8d8c6949d101fb51bb45/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f4b29c6df3fc78adbda9c915f01f8e354d9ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f4b29c6df3fc78adbda9c915f01f8e354d9ca1", "html_url": "https://github.com/rust-lang/rust/commit/b6f4b29c6df3fc78adbda9c915f01f8e354d9ca1"}], "stats": {"total": 135, "additions": 88, "deletions": 47}, "files": [{"sha": "f1192cf98ae1cf19374af5df5624ff6849b50b66", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 73, "deletions": 41, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=48fa974211990ec2dd2b8d8c6949d101fb51bb45", "patch": "@@ -182,7 +182,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n-        let (substs, assoc_bindings) = item_segment.with_generic_args(|generic_args| {\n+        let (substs, assoc_bindings, _) = item_segment.with_generic_args(|generic_args| {\n             self.create_substs_for_ast_path(\n                 span,\n                 def_id,\n@@ -256,7 +256,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             },\n             def.parent.is_none() && def.has_self, // `has_self`\n             seg.infer_types || suppress_mismatch, // `infer_types`\n-        )\n+        ).0\n     }\n \n     /// Check that the correct number of generic arguments have been provided.\n@@ -269,7 +269,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_types: bool,\n-    ) -> bool {\n+    ) -> (bool, Option<Vec<Span>>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -303,13 +303,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     let mut err = tcx.sess.struct_span_err(span, msg);\n                     err.span_note(span_late, note);\n                     err.emit();\n-                    return true;\n+                    return (true, None);\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n                     tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n                                   args.args[0].id(), multispan, msg);\n-                    return false;\n+                    return (false, None);\n                 }\n             }\n         }\n@@ -323,7 +323,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             // For kinds without defaults (i.e. lifetimes), `required == permitted`.\n             // For other kinds (i.e. types), `permitted` may be greater than `required`.\n             if required <= provided && provided <= permitted {\n-                return false;\n+                return (false, None);\n             }\n \n             // Unfortunately lifetime and type parameter mismatches are typically styled\n@@ -338,19 +338,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 (required, \"\")\n             };\n \n+            let mut potential_assoc_types: Option<Vec<Span>> = None;\n             let (spans, label) = if required == permitted && provided > permitted {\n                 // In the case when the user has provided too many arguments,\n                 // we want to point to the unexpected arguments.\n-                (\n-                    args.args[offset+permitted .. offset+provided]\n+                let spans: Vec<Span> = args.args[offset+permitted .. offset+provided]\n                         .iter()\n                         .map(|arg| arg.span())\n-                        .collect(),\n-                    format!(\n-                        \"unexpected {} argument\",\n-                        kind,\n-                    ),\n-                )\n+                        .collect();\n+                potential_assoc_types = Some(spans.clone());\n+                (spans, format!( \"unexpected {} argument\", kind))\n             } else {\n                 (vec![span], format!(\n                     \"expected {}{} {} argument{}\",\n@@ -377,7 +374,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n             err.emit();\n \n-            provided > required // `suppress_error`\n+            (provided > required, // `suppress_error`\n+             potential_assoc_types)\n         };\n \n         if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n@@ -399,7 +397,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 arg_counts.lifetimes,\n             )\n         } else {\n-            false\n+            (false, None)\n         }\n     }\n \n@@ -557,7 +555,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         generic_args: &hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n-        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+        -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n     {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -573,7 +571,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(generic_params.has_self, self_ty.is_some());\n \n         let has_self = generic_params.has_self;\n-        Self::check_generic_arg_count(\n+        let (_, potential_assoc_types) = Self::check_generic_arg_count(\n             self.tcx(),\n             span,\n             &generic_params,\n@@ -678,7 +676,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         debug!(\"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n                generic_params, self_ty, substs);\n \n-        (substs, assoc_bindings)\n+        (substs, assoc_bindings, potential_assoc_types)\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n@@ -720,19 +718,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n         speculative: bool)\n-        -> ty::PolyTraitRef<'tcx>\n+        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n-                                                 trait_def_id,\n-                                                 self_ty,\n-                                                 trait_ref.path.segments.last().unwrap());\n+        let (substs, assoc_bindings, potential_assoc_types) = self.create_substs_for_ast_trait_ref(\n+            trait_ref.path.span,\n+            trait_def_id,\n+            self_ty,\n+            trait_ref.path.segments.last().unwrap(),\n+        );\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -747,14 +746,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n                trait_ref, poly_projections, poly_trait_ref);\n-        poly_trait_ref\n+        (poly_trait_ref, potential_assoc_types)\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n-        -> ty::PolyTraitRef<'tcx>\n+        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n         self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n                                               poly_projections, false)\n@@ -767,7 +766,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n-        let (substs, assoc_bindings) =\n+        let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span,\n                                                  trait_def_id,\n                                                  self_ty,\n@@ -776,13 +775,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref(&self,\n-                                       span: Span,\n-                                       trait_def_id: DefId,\n-                                       self_ty: Ty<'tcx>,\n-                                       trait_segment: &hir::PathSegment)\n-                                       -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n-    {\n+    fn create_substs_for_ast_trait_ref(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &hir::PathSegment,\n+    ) -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n@@ -972,9 +971,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n \n         let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n-                                                        dummy_self,\n-                                                        &mut projection_bounds);\n+        let (principal, potential_assoc_types) = self.instantiate_poly_trait_ref(\n+            &trait_bounds[0],\n+            dummy_self,\n+            &mut projection_bounds,\n+        );\n         debug!(\"principal: {:?}\", principal);\n \n         for trait_bound in trait_bounds[1..].iter() {\n@@ -1047,16 +1048,47 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 if associated_types.len() == 1 { \"\" } else { \"s\" },\n                 names,\n             );\n-            for item_def_id in associated_types {\n-                let assoc_item = tcx.associated_item(item_def_id);\n+            let mut suggest = false;\n+            let mut potential_assoc_types_spans = vec![];\n+            if let Some(potential_assoc_types) = potential_assoc_types {\n+                if potential_assoc_types.len() == associated_types.len() {\n+                    // Only suggest when the amount of missing associated types is equals to the\n+                    // extra type arguments present, as that gives us a relatively high confidence\n+                    // that the user forgot to give the associtated type's name. The canonical\n+                    // example would be trying to use `Iterator<isize>` instead of\n+                    // `Iterator<Item=isize>`.\n+                    suggest = true;\n+                    potential_assoc_types_spans = potential_assoc_types;\n+                }\n+            }\n+            let mut suggestions = vec![];\n+            for (i, item_def_id) in associated_types.iter().enumerate() {\n+                let assoc_item = tcx.associated_item(*item_def_id);\n                 err.span_label(\n                     span,\n                     format!(\"missing associated type `{}` value\", assoc_item.ident),\n                 );\n                 err.span_label(\n-                    tcx.def_span(item_def_id),\n+                    tcx.def_span(*item_def_id),\n                     format!(\"`{}` defined here\", assoc_item.ident),\n                 );\n+                if suggest {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(\n+                        potential_assoc_types_spans[i],\n+                    ) {\n+                        suggestions.push((\n+                            potential_assoc_types_spans[i],\n+                            format!(\"{} = {}\", assoc_item.ident, snippet),\n+                        ));\n+                    }\n+                }\n+            }\n+            if !suggestions.is_empty() {\n+                err.multipart_suggestion_with_applicability(\n+                    \"if you meant to assign the missing associated type, use the name\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n             err.emit();\n         }"}, {"sha": "a1bb0b53f1fce38a0d5f4275c0f067a5dd9631dc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=48fa974211990ec2dd2b8d8c6949d101fb51bb45", "patch": "@@ -1892,7 +1892,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n-                            let trait_ref = AstConv::instantiate_poly_trait_ref(\n+                            let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n@@ -2016,7 +2016,12 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     let mut projection_bounds = Vec::new();\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)\n+        let (poly_trait_ref, _) = astconv.instantiate_poly_trait_ref(\n+            bound,\n+            param_ty,\n+            &mut projection_bounds,\n+        );\n+        (poly_trait_ref, bound.span)\n     }).collect();\n \n     let region_bounds = region_bounds\n@@ -2057,7 +2062,7 @@ fn predicates_from_bound<'tcx>(\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n+            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n             iter::once((pred.to_predicate(), tr.span)).chain(\n                 projections\n                     .into_iter()"}, {"sha": "0fba311d7f7d5ea49255865419b25c2fea9f58f5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=48fa974211990ec2dd2b8d8c6949d101fb51bb45", "patch": "@@ -389,7 +389,7 @@ pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait:\n     let env_def_id = tcx.hir.local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut projections = Vec::new();\n-    let principal = astconv::AstConv::instantiate_poly_trait_ref_inner(\n+    let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner(\n         &item_cx, hir_trait, tcx.types.err, &mut projections, true\n     );\n "}, {"sha": "58e7718ba5bb4fbdcbb088c0f2c191576dde78d2", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.rs?ref=48fa974211990ec2dd2b8d8c6949d101fb51bb45", "previous_filename": "src/test/ui/error-codes/E0107-b.rs"}, {"sha": "053f7010421129a2cac943b90324eeff9ec4f3f0", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.stderr", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48fa974211990ec2dd2b8d8c6949d101fb51bb45/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr?ref=48fa974211990ec2dd2b8d8c6949d101fb51bb45", "patch": "@@ -1,13 +1,13 @@\n error[E0107]: wrong number of type arguments: expected 2, found 4\n-  --> $DIR/E0107-b.rs:6:42\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:6:42\n    |\n LL |  pub struct Foo { i: Box<T<usize, usize, usize, usize, B=usize>> }\n    |                                          ^^^^^  ^^^^^ unexpected type argument\n    |                                          |\n    |                                          unexpected type argument\n \n error[E0191]: the value of the associated types `A` (from the trait `T`), `C` (from the trait `T`) must be specified\n-  --> $DIR/E0107-b.rs:6:26\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:6:26\n    |\n LL |     type A;\n    |     ------- `A` defined here\n@@ -20,6 +20,10 @@ LL |  pub struct Foo { i: Box<T<usize, usize, usize, usize, B=usize>> }\n    |                          |\n    |                          missing associated type `A` value\n    |                          missing associated type `C` value\n+help: if you meant to assign the missing associated type, use the name\n+   |\n+LL |  pub struct Foo { i: Box<T<usize, usize, A = usize, C = usize, B=usize>> }\n+   |                                          ^^^^^^^^^  ^^^^^^^^^\n \n error: aborting due to 2 previous errors\n ", "previous_filename": "src/test/ui/error-codes/E0107-b.stderr"}]}