{"sha": "5ea8eb55cd9f4547b332f43c9f723de30187c223", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYThlYjU1Y2Q5ZjQ1NDdiMzMyZjQzYzlmNzIzZGUzMDE4N2MyMjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-16T07:04:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-16T07:04:10Z"}, "message": "Auto merge of #55067 - ljedrz:generic_iterator_related_improvements, r=petrochenkov\n\nA few iterator-related improvements\n\n- typeck: don't collect into a vector when unnecessary\n- create only one vector when winnowing candidates\n- change a cloning map to `into_iter`", "tree": {"sha": "df2da6dfb48859b7b70894116893ba1b2b5b18f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2da6dfb48859b7b70894116893ba1b2b5b18f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ea8eb55cd9f4547b332f43c9f723de30187c223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea8eb55cd9f4547b332f43c9f723de30187c223", "html_url": "https://github.com/rust-lang/rust/commit/5ea8eb55cd9f4547b332f43c9f723de30187c223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ea8eb55cd9f4547b332f43c9f723de30187c223/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df0d6ad9c1510630b234f6bb96a69a081de0b307", "url": "https://api.github.com/repos/rust-lang/rust/commits/df0d6ad9c1510630b234f6bb96a69a081de0b307", "html_url": "https://github.com/rust-lang/rust/commit/df0d6ad9c1510630b234f6bb96a69a081de0b307"}, {"sha": "a14a950c44ec6a2a4ed38e0b133c35e2245d194a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14a950c44ec6a2a4ed38e0b133c35e2245d194a", "html_url": "https://github.com/rust-lang/rust/commit/a14a950c44ec6a2a4ed38e0b133c35e2245d194a"}], "stats": {"total": 34, "additions": 16, "deletions": 18}, "files": [{"sha": "3c2caa39d76e07938995c828e1ba7dc23087989e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -71,6 +71,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(macro_at_most_once_rep)]\n #![feature(crate_visibility_modifier)]\n+#![feature(transpose_result)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "156a27a7d0abd9c48c49434c477fa97530ecd0f7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -1368,8 +1368,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // Winnow, but record the exact outcome of evaluation, which\n         // is needed for specialization. Propagate overflow if it occurs.\n-        let candidates: Result<Vec<Option<EvaluatedCandidate<'_>>>, _> = candidates\n-            .into_iter()\n+        let mut candidates = candidates.into_iter()\n             .map(|c| match self.evaluate_candidate(stack, &c) {\n                 Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n@@ -1378,10 +1377,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(_) => Ok(None),\n                 Err(OverflowError) => Err(Overflow),\n             })\n-            .collect();\n-\n-        let mut candidates: Vec<EvaluatedCandidate<'_>> =\n-            candidates?.into_iter().filter_map(|c| c).collect();\n+           .flat_map(Result::transpose)\n+           .collect::<Result<Vec<_>, _>>()?;\n \n         debug!(\n             \"winnowed to {} candidates for {:?}: {:?}\",\n@@ -1390,7 +1387,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             candidates\n         );\n \n-        // If there are STILL multiple candidate, we can further\n+        // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n         // resolving specializations.\n         if candidates.len() > 1 {"}, {"sha": "5f63f11338a15c664afaaa2a7b19bfe2b43ae3ed", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 match (r1, r2) {\n                     (Representability::SelfRecursive(v1),\n                      Representability::SelfRecursive(v2)) => {\n-                        Representability::SelfRecursive(v1.iter().map(|s| *s).chain(v2).collect())\n+                        Representability::SelfRecursive(v1.into_iter().chain(v2).collect())\n                     }\n                     (r1, r2) => cmp::max(r1, r2)\n                 }"}, {"sha": "1978f86545e7bfc5d4372273401a45675b1e2891", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -1592,8 +1592,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_fn\");\n \n         let tcx = self.tcx();\n-        let input_tys: Vec<Ty> =\n-            decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n+        let input_tys =\n+            decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) => self.ast_ty_to_ty(output),\n@@ -1603,7 +1603,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n         let bare_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n-            input_tys.into_iter(),\n+            input_tys,\n             output_ty,\n             decl.variadic,\n             unsafety,"}, {"sha": "c9158af178feae0c60341a58f1a52c6dcb534273", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -626,7 +626,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n+        let all_arm_pats_diverge = arms.iter().map(|arm| {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n@@ -642,7 +642,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 Diverges::Maybe => Diverges::Maybe,\n                 Diverges::Always | Diverges::WarnedAlways => Diverges::WarnedAlways,\n             }\n-        }).collect();\n+        });\n \n         // Now typecheck the blocks.\n         //"}, {"sha": "d840c587464ee7d0f5857b4289fd5f89b06deedf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ea8eb55cd9f4547b332f43c9f723de30187c223/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5ea8eb55cd9f4547b332f43c9f723de30187c223", "patch": "@@ -1769,7 +1769,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n     }\n \n     // For each field, figure out if it's known to be a ZST and align(1)\n-    let field_infos: Vec<_> = adt.non_enum_variant().fields.iter().map(|field| {\n+    let field_infos = adt.non_enum_variant().fields.iter().map(|field| {\n         let ty = field.ty(tcx, Substs::identity_for_item(tcx, field.did));\n         let param_env = tcx.param_env(field.did);\n         let layout = tcx.layout_of(param_env.and(ty));\n@@ -1778,19 +1778,19 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n         let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n         let align1 = layout.map(|layout| layout.align.abi() == 1).unwrap_or(false);\n         (span, zst, align1)\n-    }).collect();\n+    });\n \n-    let non_zst_fields = field_infos.iter().filter(|(_span, zst, _align1)| !*zst);\n+    let non_zst_fields = field_infos.clone().filter(|(_span, zst, _align1)| !*zst);\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count != 1 {\n-        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| *span).collect();\n+        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| span).collect();\n         struct_span_err!(tcx.sess, sp, E0690,\n                          \"transparent struct needs exactly one non-zero-sized field, but has {}\",\n                          non_zst_count)\n         .span_note(field_spans, \"non-zero-sized field\")\n         .emit();\n     }\n-    for &(span, zst, align1) in &field_infos {\n+    for (span, zst, align1) in field_infos {\n         if zst && !align1 {\n             span_err!(tcx.sess, span, E0691,\n                       \"zero-sized field in transparent struct has alignment larger than 1\");"}]}