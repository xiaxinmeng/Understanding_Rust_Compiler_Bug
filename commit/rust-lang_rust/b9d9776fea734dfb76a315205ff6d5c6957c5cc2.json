{"sha": "b9d9776fea734dfb76a315205ff6d5c6957c5cc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDk3NzZmZWE3MzRkZmI3NmEzMTUyMDVmZjZkNWM2OTU3YzVjYzI=", "commit": {"author": {"name": "William Bain", "email": "bain.william.a@gmail.com", "date": "2020-12-29T22:23:53Z"}, "committer": {"name": "William Bain", "email": "bain.william.a@gmail.com", "date": "2021-01-11T00:48:10Z"}, "message": "Refactor `cannot infer ...` message rendering", "tree": {"sha": "699f9ee64ed56bfd8d290b5d8cd4af9fa33276f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/699f9ee64ed56bfd8d290b5d8cd4af9fa33276f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d9776fea734dfb76a315205ff6d5c6957c5cc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9776fea734dfb76a315205ff6d5c6957c5cc2", "html_url": "https://github.com/rust-lang/rust/commit/b9d9776fea734dfb76a315205ff6d5c6957c5cc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9776fea734dfb76a315205ff6d5c6957c5cc2/comments", "author": {"login": "wabain", "id": 7651435, "node_id": "MDQ6VXNlcjc2NTE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7651435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wabain", "html_url": "https://github.com/wabain", "followers_url": "https://api.github.com/users/wabain/followers", "following_url": "https://api.github.com/users/wabain/following{/other_user}", "gists_url": "https://api.github.com/users/wabain/gists{/gist_id}", "starred_url": "https://api.github.com/users/wabain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wabain/subscriptions", "organizations_url": "https://api.github.com/users/wabain/orgs", "repos_url": "https://api.github.com/users/wabain/repos", "events_url": "https://api.github.com/users/wabain/events{/privacy}", "received_events_url": "https://api.github.com/users/wabain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wabain", "id": 7651435, "node_id": "MDQ6VXNlcjc2NTE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7651435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wabain", "html_url": "https://github.com/wabain", "followers_url": "https://api.github.com/users/wabain/followers", "following_url": "https://api.github.com/users/wabain/following{/other_user}", "gists_url": "https://api.github.com/users/wabain/gists{/gist_id}", "starred_url": "https://api.github.com/users/wabain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wabain/subscriptions", "organizations_url": "https://api.github.com/users/wabain/orgs", "repos_url": "https://api.github.com/users/wabain/repos", "events_url": "https://api.github.com/users/wabain/events{/privacy}", "received_events_url": "https://api.github.com/users/wabain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "html_url": "https://github.com/rust-lang/rust/commit/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e"}], "stats": {"total": 237, "additions": 92, "deletions": 145}, "files": [{"sha": "e2b04730b1f88c6c144c68b0d682ce5472a8315c", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 92, "deletions": 145, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9776fea734dfb76a315205ff6d5c6957c5cc2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9776fea734dfb76a315205ff6d5c6957c5cc2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b9d9776fea734dfb76a315205ff6d5c6957c5cc2", "patch": "@@ -217,16 +217,10 @@ impl UseDiagnostic<'_> {\n \n /// Suggest giving an appropriate return type to a closure expression.\n fn closure_return_type_suggestion(\n-    span: Span,\n     err: &mut DiagnosticBuilder<'_>,\n     output: &FnRetTy<'_>,\n     body: &Body<'_>,\n-    descr: &str,\n-    name: &str,\n     ret: &str,\n-    use_diag: Option<&UseDiagnostic<'_>>,\n-    parent_name: Option<String>,\n-    parent_descr: Option<&str>,\n ) {\n     let (arrow, post) = match output {\n         FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n@@ -244,18 +238,6 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(\n-        span,\n-        InferCtxt::cannot_infer_msg(\n-            span,\n-            \"type\",\n-            &name,\n-            &descr,\n-            use_diag,\n-            parent_name,\n-            parent_descr,\n-        ),\n-    );\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -300,9 +282,52 @@ impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n pub struct InferenceDiagnosticsData {\n     pub name: String,\n     pub span: Option<Span>,\n-    pub description: Cow<'static, str>,\n-    pub parent_name: Option<String>,\n-    pub parent_description: Option<&'static str>,\n+    pub kind: UnderspecifiedArgKind,\n+    pub parent: Option<InferenceDiagnosticsParentData>,\n+}\n+\n+pub struct InferenceDiagnosticsParentData {\n+    pub prefix: &'static str,\n+    pub name: String,\n+}\n+\n+pub enum UnderspecifiedArgKind {\n+    Type { prefix: Cow<'static, str> },\n+    Const { is_parameter: bool },\n+}\n+\n+impl InferenceDiagnosticsData {\n+    /// Generate a label for a generic argument which can't be inferred. When not\n+    /// much is known about the argument, `use_diag` may be used to describe the\n+    /// labeled value.\n+    fn cannot_infer_msg(&self, use_diag: Option<&UseDiagnostic<'_>>) -> String {\n+        if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n+            if let Some(use_diag) = use_diag {\n+                return format!(\"cannot infer type of {}\", use_diag.descr());\n+            }\n+\n+            return \"cannot infer type\".to_string();\n+        }\n+\n+        let suffix = match (&self.parent, use_diag) {\n+            (Some(parent), _) => format!(\" declared on the {} `{}`\", parent.prefix, parent.name),\n+            (None, Some(use_diag)) => format!(\" in {}\", use_diag.type_descr()),\n+            (None, None) => String::new(),\n+        };\n+\n+        // For example: \"cannot infer type for type parameter `T`\"\n+        format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n+    }\n+}\n+\n+impl UnderspecifiedArgKind {\n+    fn prefix_string(&self) -> Cow<'static, str> {\n+        match self {\n+            Self::Type { prefix } => format!(\"type for {}\", prefix).into(),\n+            Self::Const { is_parameter: true } => \"the value of const parameter\".into(),\n+            Self::Const { is_parameter: false } => \"the value of the constant\".into(),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -322,32 +347,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) =\n                         var_origin.kind\n                     {\n-                        let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n-                        let (parent_name, parent_description) =\n-                            if let Some(parent_def_id) = parent_def_id {\n+                        let parent_data = def_id\n+                            .and_then(|def_id| self.tcx.parent(def_id))\n+                            .and_then(|parent_def_id| {\n                                 let parent_name = self\n                                     .tcx\n                                     .def_key(parent_def_id)\n                                     .disambiguated_data\n                                     .data\n-                                    .get_opt_name()\n-                                    .map(|parent_symbol| parent_symbol.to_string());\n-\n-                                (\n-                                    parent_name,\n-                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                                )\n-                            } else {\n-                                (None, None)\n-                            };\n+                                    .get_opt_name()?\n+                                    .to_string();\n+\n+                                Some(InferenceDiagnosticsParentData {\n+                                    prefix: self.tcx.def_kind(parent_def_id).descr(parent_def_id),\n+                                    name: parent_name,\n+                                })\n+                            });\n \n                         if name != kw::SelfUpper {\n                             return InferenceDiagnosticsData {\n                                 name: name.to_string(),\n                                 span: Some(var_origin.span),\n-                                description: \"type parameter\".into(),\n-                                parent_name,\n-                                parent_description,\n+                                kind: UnderspecifiedArgKind::Type {\n+                                    prefix: \"type parameter\".into(),\n+                                },\n+                                parent: parent_data,\n                             };\n                         }\n                     }\n@@ -362,9 +386,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 InferenceDiagnosticsData {\n                     name: s,\n                     span: None,\n-                    description: ty.prefix_string(),\n-                    parent_name: None,\n-                    parent_description: None,\n+                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string() },\n+                    parent: None,\n                 }\n             }\n             GenericArgKind::Const(ct) => {\n@@ -374,31 +397,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n                         origin.kind\n                     {\n-                        let parent_def_id = self.tcx.parent(def_id);\n-                        let (parent_name, parent_description) =\n-                            if let Some(parent_def_id) = parent_def_id {\n-                                let parent_name = self\n-                                    .tcx\n-                                    .def_key(parent_def_id)\n-                                    .disambiguated_data\n-                                    .data\n-                                    .get_opt_name()\n-                                    .map(|parent_symbol| parent_symbol.to_string());\n-\n-                                (\n-                                    parent_name,\n-                                    Some(self.tcx.def_kind(parent_def_id).descr(parent_def_id)),\n-                                )\n-                            } else {\n-                                (None, None)\n-                            };\n+                        let parent_data = self.tcx.parent(def_id).and_then(|parent_def_id| {\n+                            let parent_name = self\n+                                .tcx\n+                                .def_key(parent_def_id)\n+                                .disambiguated_data\n+                                .data\n+                                .get_opt_name()?\n+                                .to_string();\n+\n+                            Some(InferenceDiagnosticsParentData {\n+                                prefix: self.tcx.def_kind(parent_def_id).descr(parent_def_id),\n+                                name: parent_name,\n+                            })\n+                        });\n \n                         return InferenceDiagnosticsData {\n                             name: name.to_string(),\n                             span: Some(origin.span),\n-                            description: \"const parameter\".into(),\n-                            parent_name,\n-                            parent_description,\n+                            kind: UnderspecifiedArgKind::Const { is_parameter: true },\n+                            parent: parent_data,\n                         };\n                     }\n \n@@ -413,9 +431,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     InferenceDiagnosticsData {\n                         name: s,\n                         span: Some(origin.span),\n-                        description: \"the constant\".into(),\n-                        parent_name: None,\n-                        parent_description: None,\n+                        kind: UnderspecifiedArgKind::Const { is_parameter: false },\n+                        parent: None,\n                     }\n                 } else {\n                     bug!(\"unexpect const: {:?}\", ct);\n@@ -554,19 +571,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 if let Some((decl, body_id)) = closure_decl_and_body_id {\n                     closure_return_type_suggestion(\n-                        span,\n                         &mut err,\n                         &decl.output,\n                         self.tcx.hir().body(body_id),\n-                        &arg_data.description,\n-                        &arg_data.name,\n                         &ret,\n-                        use_diag,\n-                        arg_data.parent_name,\n-                        arg_data.parent_description,\n                     );\n                     // We don't want to give the other suggestions when the problem is the\n                     // closure return type.\n+                    err.span_label(\n+                        span,\n+                        arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n+                    );\n                     return err;\n                 }\n \n@@ -703,47 +718,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |\n         //   = note: type must be known at this point\n         let span = arg_data.span.unwrap_or(err_span);\n+\n+        // Avoid multiple labels pointing at `span`.\n         if !err\n             .span\n             .span_labels()\n             .iter()\n             .any(|span_label| span_label.label.is_some() && span_label.span == span)\n             && local_visitor.found_arg_pattern.is_none()\n         {\n-            let (kind_str, const_value) = match arg.unpack() {\n-                GenericArgKind::Type(_) => (\"type\", None),\n-                GenericArgKind::Const(_) => (\"the value\", Some(())),\n-                GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n-            };\n-\n             // FIXME(const_generics): we would like to handle const arguments\n             // as part of the normal diagnostics flow below, but there appear to\n             // be subtleties in doing so, so for now we special-case const args\n             // here.\n-            if let Some(suggestion) = const_value\n-                .and_then(|_| arg_data.parent_name.as_ref())\n-                .map(|parent| format!(\"{}::<{}>\", parent, arg_data.name))\n+            if let (UnderspecifiedArgKind::Const { .. }, Some(parent_data)) =\n+                (&arg_data.kind, &arg_data.parent)\n             {\n                 err.span_suggestion_verbose(\n                     span,\n                     \"consider specifying the const argument\",\n-                    suggestion,\n+                    format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n \n-            // Avoid multiple labels pointing at `span`.\n             err.span_label(\n                 span,\n-                InferCtxt::cannot_infer_msg(\n-                    span,\n-                    kind_str,\n-                    &arg_data.name,\n-                    &arg_data.description,\n-                    use_diag,\n-                    arg_data.parent_name,\n-                    arg_data.parent_description,\n-                ),\n+                arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n             );\n         }\n \n@@ -826,61 +827,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(\n-            span,\n-            InferCtxt::cannot_infer_msg(\n-                span,\n-                \"type\",\n-                &data.name,\n-                &data.description,\n-                None,\n-                data.parent_name,\n-                data.parent_description,\n-            ),\n-        );\n+        err.span_label(span, data.cannot_infer_msg(None));\n         err\n     }\n-\n-    fn cannot_infer_msg(\n-        span: Span,\n-        kind_str: &str,\n-        type_name: &str,\n-        descr: &str,\n-        use_diag: Option<&UseDiagnostic<'_>>,\n-        parent_name: Option<String>,\n-        parent_descr: Option<&str>,\n-    ) -> String {\n-        let use_diag = use_diag.filter(|d| d.applies_to(span));\n-\n-        if type_name == \"_\" {\n-            if let Some(use_diag) = use_diag {\n-                format!(\"cannot infer {} of {}\", kind_str, use_diag.descr())\n-            } else {\n-                format!(\"cannot infer {}\", kind_str)\n-            }\n-        } else {\n-            let extra_descr = if let Some(parent_name) = parent_name {\n-                let parent_type_descr = if let Some(parent_descr) = parent_descr {\n-                    format!(\" the {}\", parent_descr)\n-                } else {\n-                    \"\".into()\n-                };\n-\n-                format!(\" declared on{} `{}`\", parent_type_descr, parent_name)\n-            } else if let Some(use_diag) = use_diag {\n-                format!(\" in {}\", use_diag.type_descr())\n-            } else {\n-                \"\".into()\n-            };\n-\n-            // FIXME: We really shouldn't be dealing with strings here\n-            // but instead use a sensible enum for cases like this.\n-            let preposition = if \"the value\" == kind_str { \"of\" } else { \"for\" };\n-            // For example: \"cannot infer type for type parameter `T`\"\n-            format!(\n-                \"cannot infer {} {} {} `{}`{}\",\n-                kind_str, preposition, descr, type_name, extra_descr\n-            )\n-        }\n-    }\n }"}]}