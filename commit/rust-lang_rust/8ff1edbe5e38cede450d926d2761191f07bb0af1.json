{"sha": "8ff1edbe5e38cede450d926d2761191f07bb0af1", "node_id": "C_kwDOAAsO6NoAKDhmZjFlZGJlNWUzOGNlZGU0NTBkOTI2ZDI3NjExOTFmMDdiYjBhZjE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-22T09:38:46Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-22T10:35:59Z"}, "message": "fix previous failures and address review", "tree": {"sha": "cb401f40ca781065e809e7ae004ed1e83b9f82ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb401f40ca781065e809e7ae004ed1e83b9f82ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ff1edbe5e38cede450d926d2761191f07bb0af1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff1edbe5e38cede450d926d2761191f07bb0af1", "html_url": "https://github.com/rust-lang/rust/commit/8ff1edbe5e38cede450d926d2761191f07bb0af1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ff1edbe5e38cede450d926d2761191f07bb0af1/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf3409e16845bf52e72f4ffdac9db139a24a8d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf3409e16845bf52e72f4ffdac9db139a24a8d3", "html_url": "https://github.com/rust-lang/rust/commit/6cf3409e16845bf52e72f4ffdac9db139a24a8d3"}], "stats": {"total": 370, "additions": 204, "deletions": 166}, "files": [{"sha": "45502c720ae792d56141ecf902801c051551ad17", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -20,8 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::interpret::EvalToConstValueResult;\n+use rustc_middle::mir::interpret::{ErrorHandled, EvalToConstValueResult};\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -695,9 +694,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         // Reject any attempt to unify two unevaluated constants that contain inference\n-        // variables.\n-        // FIXME `TyCtxt::const_eval_resolve` already rejects the resolution of those\n-        // constants early, but the canonicalization below messes with that mechanism.\n+        // variables, since inference variables in queries lead to ICEs.\n         if a.substs.has_infer_types_or_consts() || b.substs.has_infer_types_or_consts() {\n             debug!(\"a or b contain infer vars in its substs -> cannot unify\");\n             return false;\n@@ -1621,8 +1618,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n-            debug!(\"has infer types or consts\");\n-            return Err(ErrorHandled::TooGeneric);\n+            debug!(\"substs have infer types or consts: {:?}\", substs);\n+            if substs.has_infer_types_or_consts() {\n+                return Err(ErrorHandled::TooGeneric);\n+            }\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);"}, {"sha": "639a9bc600ac4f0d7cb15a55bf33ece28551aa63", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // variables. We reject those here since `resolve_opt_const_arg`\n         // would fail otherwise\n         if ct.substs.has_infer_types_or_consts() {\n-            return Err(ErrorHandled::TooGeneric);\n+            bug!(\"did not expect inference variables here\");\n         }\n \n         match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {"}, {"sha": "c44e961363048172157469a7ba41583e075de859", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 112, "deletions": 96, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -569,6 +569,18 @@ pub(super) fn thir_abstract_const<'tcx>(\n     }\n }\n \n+/// Tries to unify two abstract constants using structural equality.\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(super) fn try_unify<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    a: AbstractConst<'tcx>,\n+    b: AbstractConst<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> bool {\n+    let const_unify_ctxt = ConstUnifyCtxt::new(tcx, param_env);\n+    const_unify_ctxt.try_unify_inner(a, b)\n+}\n+\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n@@ -622,115 +634,119 @@ where\n     recurse(tcx, ct, &mut f)\n }\n \n-// Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-// ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n-// Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-#[inline]\n-#[instrument(skip(tcx), level = \"debug\")]\n-fn try_replace_substs_in_root<'tcx>(\n+pub(super) struct ConstUnifyCtxt<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    mut abstr_const: AbstractConst<'tcx>,\n-) -> Option<AbstractConst<'tcx>> {\n-    while let Node::Leaf(ct) = abstr_const.root(tcx) {\n-        match AbstractConst::from_const(tcx, ct) {\n-            Ok(Some(act)) => abstr_const = act,\n-            Ok(None) => break,\n-            Err(_) => return None,\n-        }\n-    }\n-\n-    Some(abstr_const)\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n-/// Tries to unify two abstract constants using structural equality.\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(super) fn try_unify<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    a: AbstractConst<'tcx>,\n-    b: AbstractConst<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    let a = match try_replace_substs_in_root(tcx, a) {\n-        Some(a) => a,\n-        None => {\n-            return true;\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+        ConstUnifyCtxt { tcx, param_env }\n+    }\n+\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n+    // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n+    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n         }\n-    };\n \n-    let b = match try_replace_substs_in_root(tcx, b) {\n-        Some(b) => b,\n-        None => {\n+        Some(abstr_const)\n+    }\n+\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_unify_inner(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n             return true;\n-        }\n-    };\n+        };\n \n-    let a_root = a.root(tcx);\n-    let b_root = b.root(tcx);\n-    debug!(?a_root, ?b_root);\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n \n-    match (a_root, b_root) {\n-        (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-            let a_ct = a_ct.eval(tcx, param_env);\n-            debug!(\"a_ct evaluated: {:?}\", a_ct);\n-            let b_ct = b_ct.eval(tcx, param_env);\n-            debug!(\"b_ct evaluated: {:?}\", b_ct);\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n \n-            if a_ct.ty() != b_ct.ty() {\n-                return false;\n-            }\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n \n-            match (a_ct.val(), b_ct.val()) {\n-                // We can just unify errors with everything to reduce the amount of\n-                // emitted errors here.\n-                (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                    a_param == b_param\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n                 }\n-                (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                // means that we only allow inference variables if they are equal.\n-                (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                // We expand generic anonymous constants at the start of this function, so this\n-                // branch should only be taking when dealing with associated constants, at\n-                // which point directly comparing them seems like the desired behavior.\n-                //\n-                // FIXME(generic_const_exprs): This isn't actually the case.\n-                // We also take this branch for concrete anonymous constants and\n-                // expand generic anonymous constants with concrete substs.\n-                (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                    a_uv == b_uv\n+\n+                match (a_ct.val(), b_ct.val()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n                 }\n-                // FIXME(generic_const_exprs): We may want to either actually try\n-                // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                // this, for now we just return false here.\n-                _ => false,\n             }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify_inner(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify_inner(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify_inner(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify_inner(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify_inner(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify_inner(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n         }\n-        (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(al), b.subtree(bl), param_env)\n-                && try_unify(tcx, a.subtree(ar), b.subtree(br), param_env)\n-        }\n-        (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(av), b.subtree(bv), param_env)\n-        }\n-        (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-            if a_args.len() == b_args.len() =>\n-        {\n-            try_unify(tcx, a.subtree(a_f), b.subtree(b_f), param_env)\n-                && iter::zip(a_args, b_args)\n-                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn), param_env))\n-        }\n-        (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_kind == b_kind) =>\n-        {\n-            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand), param_env)\n-        }\n-        // use this over `_ => false` to make adding variants to `Node` less error prone\n-        (Node::Cast(..), _)\n-        | (Node::FunctionCall(..), _)\n-        | (Node::UnaryOp(..), _)\n-        | (Node::Binop(..), _)\n-        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "df1e8cdcde00df46fd266bd6a2d6ee5bcb302379", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -581,7 +581,11 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return ProcessResult::Changed(vec![]);\n                             }\n                         }"}, {"sha": "e06ecc528aaa6a4daed9d73b95351f6cd1b62f4a", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -860,7 +860,10 @@ pub fn provide(providers: &mut ty::query::Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        try_unify_abstract_consts: const_evaluatable::try_unify_abstract_consts,\n+        try_unify_abstract_consts: |tcx, param_env_and| {\n+            let (param_env, (a, b)) = param_env_and.into_parts();\n+            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n+        },\n         ..*providers\n     };\n }"}, {"sha": "fe369ca5c461cea9aba820d9b4ecbd9f0d6b7bf0", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -643,7 +643,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if self.infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if self.infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return Ok(EvaluatedToOk);\n                             }\n                         }"}, {"sha": "57b642dc38fab0ac3c3d64d13f3307bba4b87b16", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -243,7 +243,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n-                ) => tcx.try_unify_abstract_consts((a, b)),\n+                ) => tcx.try_unify_abstract_consts(self_param_env.and((a, b))),\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "71c164ab0a5bf68dd863951b0bd51bd98f7dff4c", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -2,103 +2,115 @@\n #![allow(incomplete_features)]\n \n trait TensorDimension {\n-    const DIM : usize;\n-    //~^ ERROR cycle detected when resolving instance `<LazyUpdim<T, {T::DIM}, DIM>\n-    const ISSCALAR : bool = Self::DIM == 0;\n-    fn is_scalar(&self) -> bool {Self::ISSCALAR}\n+    const DIM: usize;\n+    //~^ ERROR cycle detected when resolving instance\n+    // FIXME Given the current state of the compiler its expected that we cycle here,\n+    // but the cycle is still wrong.\n+    const ISSCALAR: bool = Self::DIM == 0;\n+    fn is_scalar(&self) -> bool {\n+        Self::ISSCALAR\n+    }\n }\n \n-trait TensorSize : TensorDimension {\n-    fn size(&self) -> [usize;Self::DIM];\n-    fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n-        index.iter().zip(self.size().iter()).all(|(i,s)| i < s)\n+trait TensorSize: TensorDimension {\n+    fn size(&self) -> [usize; Self::DIM];\n+    fn inbounds(&self, index: [usize; Self::DIM]) -> bool {\n+        index.iter().zip(self.size().iter()).all(|(i, s)| i < s)\n     }\n }\n \n-\n trait Broadcastable: TensorSize + Sized {\n     type Element;\n-    fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n-    fn lazy_updim<const NEWDIM : usize>(&self, size : [usize;NEWDIM] ) ->\n-       LazyUpdim<Self,{Self::DIM},NEWDIM>\n-    {\n-        assert!(NEWDIM >= Self::DIM,\n-            \"Updimmed tensor cannot have fewer indices than the initial one.\");\n-        LazyUpdim {size,reference:&self}\n+    fn bget(&self, index: [usize; Self::DIM]) -> Option<Self::Element>;\n+    fn lazy_updim<const NEWDIM: usize>(\n+        &self,\n+        size: [usize; NEWDIM],\n+    ) -> LazyUpdim<Self, { Self::DIM }, NEWDIM> {\n+        assert!(\n+            NEWDIM >= Self::DIM,\n+            \"Updimmed tensor cannot have fewer indices than the initial one.\"\n+        );\n+        LazyUpdim { size, reference: &self }\n     }\n-    fn bmap<T,F :Fn(Self::Element) -> T>(&self,foo : F) -> BMap<T,Self,F,{Self::DIM}>{\n-        BMap {reference:self,closure : foo}\n+    fn bmap<T, F: Fn(Self::Element) -> T>(&self, foo: F) -> BMap<T, Self, F, { Self::DIM }> {\n+        BMap { reference: self, closure: foo }\n     }\n }\n \n-\n-struct LazyUpdim<'a,T : Broadcastable,const OLDDIM : usize, const DIM : usize> {\n-    size : [usize;DIM],\n-    reference : &'a T\n+struct LazyUpdim<'a, T: Broadcastable, const OLDDIM: usize, const DIM: usize> {\n+    size: [usize; DIM],\n+    reference: &'a T,\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorDimension for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    const DIM : usize = DIM;\n+impl<'a, T: Broadcastable, const DIM: usize> TensorDimension for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    const DIM: usize = DIM;\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorSize for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    fn size(&self) -> [usize;DIM] {self.size}\n+impl<'a, T: Broadcastable, const DIM: usize> TensorSize for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    fn size(&self) -> [usize; DIM] {\n+        self.size\n+    }\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM>\n-{\n+impl<'a, T: Broadcastable, const DIM: usize> Broadcastable for LazyUpdim<'a, T, { T::DIM }, DIM> {\n     type Element = T::Element;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         assert!(DIM >= T::DIM);\n-        if !self.inbounds(index) {return None}\n+        if !self.inbounds(index) {\n+            return None;\n+        }\n         let size = self.size();\n-        let newindex : [usize;T::DIM] = Default::default();\n+        let newindex: [usize; T::DIM] = Default::default();\n         self.reference.bget(newindex)\n     }\n }\n \n-struct BMap<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  , const DIM: usize> {\n-    reference : &'a T,\n-    closure : F\n+struct BMap<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> {\n+    reference: &'a T,\n+    closure: F,\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R,\n-     const DIM: usize> TensorDimension for BMap<'a,R,T,F,DIM> {\n-\n-    const DIM : usize = DIM;\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorDimension\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    const DIM: usize = DIM;\n }\n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-      const DIM: usize> TensorSize for BMap<'a,R,T,F,DIM> {\n-\n-    fn size(&self) -> [usize;DIM] {self.reference.size()}\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorSize\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    fn size(&self) -> [usize; DIM] {\n+        self.reference.size()\n+    }\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-  const DIM: usize> Broadcastable for BMap<'a,R,T,F,DIM> {\n-\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> Broadcastable\n+    for BMap<'a, R, T, F, DIM>\n+{\n     type Element = R;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         self.reference.bget(index).map(&self.closure)\n     }\n }\n \n impl<T> TensorDimension for Vec<T> {\n-    const DIM : usize = 1;\n+    const DIM: usize = 1;\n }\n impl<T> TensorSize for Vec<T> {\n-    fn size(&self) -> [usize;1] {[self.len()]}\n+    fn size(&self) -> [usize; 1] {\n+        [self.len()]\n+    }\n }\n impl<T: Clone> Broadcastable for Vec<T> {\n     type Element = T;\n-    fn bget(& self,index : [usize;1]) -> Option<T> {\n+    fn bget(&self, index: [usize; 1]) -> Option<T> {\n         self.get(index[0]).cloned()\n     }\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n-    let bv = v.lazy_updim([3,4]);\n-    let bbv = bv.bmap(|x| x*x);\n+    let v = vec![1, 2, 3];\n+    let bv = v.lazy_updim([3, 4]);\n+    let bbv = bv.bmap(|x| x * x);\n \n-    println!(\"The size of v is {:?}\",bbv.bget([0,2]).expect(\"Out of bounds.\"));\n+    println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n }"}, {"sha": "8705a39fa4bcd3397061a59f03e9bfcec0821941", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ff1edbe5e38cede450d926d2761191f07bb0af1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ff1edbe5e38cede450d926d2761191f07bb0af1/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=8ff1edbe5e38cede450d926d2761191f07bb0af1", "patch": "@@ -1,16 +1,16 @@\n-error[E0391]: cycle detected when resolving instance `<LazyUpdim<T, {T::DIM}, DIM> as TensorDimension>::DIM`\n+error[E0391]: cycle detected when resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n   --> $DIR/issue-83765.rs:5:5\n    |\n-LL |     const DIM : usize;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     const DIM: usize;\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires checking if `TensorDimension` fulfills its obligations...\n   --> $DIR/issue-83765.rs:4:1\n    |\n LL | trait TensorDimension {\n    | ^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires resolving instance `<LazyUpdim<T, {T::DIM}, DIM> as TensorDimension>::DIM`, completing the cycle\n-   = note: cycle used when normalizing `<LazyUpdim<T, {T::DIM}, DIM> as TensorDimension>::DIM`\n+   = note: ...which again requires resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n+   = note: cycle used when normalizing `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n \n error: aborting due to previous error\n "}]}