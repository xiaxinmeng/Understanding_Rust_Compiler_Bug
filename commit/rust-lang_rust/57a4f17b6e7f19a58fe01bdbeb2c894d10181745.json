{"sha": "57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTRmMTdiNmU3ZjE5YTU4ZmUwMWJkYmViMmM4OTRkMTAxODE3NDU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-02T16:25:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-02T16:25:15Z"}, "message": "Rollup merge of #59446 - Aaron1011:fix/debuginfo-overflow, r=oli-obk\n\nFix stack overflow when generating debuginfo for 'recursive' type\n\nBy using 'impl trait', it's possible to create a self-referential\ntype as follows:\n\nfn foo() -> impl Copy { foo }\n\nThis is a function which returns itself.\nNormally, the signature of this function would be impossible\nto write - it would look like 'fn foo() -> fn() -> fn() ...'\ne.g. a function which returns a function, which returns a function...\n\nUsing 'impl trait' allows us to avoid writing this infinitely long\ntype. While it's useless for practical purposes, it does compile and run\n\nHowever, issues arise when we try to generate llvm debuginfo for such a\ntype. All 'impl trait' types (e.g. ty::Opaque) are resolved when we\ngenerate debuginfo, which can lead to us recursing back to the original\n'fn' type when we try to process its return type.\n\nTo resolve this, I've modified debuginfo generation to account for these\nkinds of weird types. Unfortunately, there's no 'correct' debuginfo that\nwe can generate - 'impl trait' does not exist in debuginfo, and this\nkind of recursive type is impossible to directly represent.\n\nTo ensure that we emit *something*, this commit emits dummy\ndebuginfo/type names whenever it encounters a self-reference. In\npractice, this should never happen - it's just to ensure that we can\nemit some kind of debuginfo, even if it's not particularly meaningful\n\nFixes #58463", "tree": {"sha": "5419cad939c9f00f9f2df1fd6739c2bfbda99f06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5419cad939c9f00f9f2df1fd6739c2bfbda99f06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJco4zrCRBK7hj4Ov3rIwAAdHIIAGhewHMkHi/Y0Pj8N4wgZ+8K\nAWUwgj3us/T90XfiD3jZP53lJMRYGFC1Kgy+R/cx7cE7GoQw3nynLqCWc0ZtO2ZI\nUK0QRNKwweuEvzDqmBWq2vMfhvsyYY2SknDyxHiRTIRFz4xNXwI12sN8yjiZPaP4\nvReUSmDP6HHZUvclyibOyyVJdAsN0o6/trkMqWGnXLRyXdZPogtyUDx7nKvjjMU8\npnaQnWklAed6JC5+vtS8SBkGBTrgebBK0zAjxrZfAYBuJ+io40Z4cNuNsLMd2+4L\nrMixlYQ0HY9fFsdB48tLdBqN+mQyhkUSUi1gdMmoHH4k6jT4F3MaFz7qxt68LKg=\n=F/2H\n-----END PGP SIGNATURE-----\n", "payload": "tree 5419cad939c9f00f9f2df1fd6739c2bfbda99f06\nparent 6bd01efcead9e2a62e1e7704d95a07d1a451d282\nparent c13daeb036273d3fd0544c3cc58592f2a86d1631\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554222315 +0200\ncommitter GitHub <noreply@github.com> 1554222315 +0200\n\nRollup merge of #59446 - Aaron1011:fix/debuginfo-overflow, r=oli-obk\n\nFix stack overflow when generating debuginfo for 'recursive' type\n\nBy using 'impl trait', it's possible to create a self-referential\ntype as follows:\n\nfn foo() -> impl Copy { foo }\n\nThis is a function which returns itself.\nNormally, the signature of this function would be impossible\nto write - it would look like 'fn foo() -> fn() -> fn() ...'\ne.g. a function which returns a function, which returns a function...\n\nUsing 'impl trait' allows us to avoid writing this infinitely long\ntype. While it's useless for practical purposes, it does compile and run\n\nHowever, issues arise when we try to generate llvm debuginfo for such a\ntype. All 'impl trait' types (e.g. ty::Opaque) are resolved when we\ngenerate debuginfo, which can lead to us recursing back to the original\n'fn' type when we try to process its return type.\n\nTo resolve this, I've modified debuginfo generation to account for these\nkinds of weird types. Unfortunately, there's no 'correct' debuginfo that\nwe can generate - 'impl trait' does not exist in debuginfo, and this\nkind of recursive type is impossible to directly represent.\n\nTo ensure that we emit *something*, this commit emits dummy\ndebuginfo/type names whenever it encounters a self-reference. In\npractice, this should never happen - it's just to ensure that we can\nemit some kind of debuginfo, even if it's not particularly meaningful\n\nFixes #58463\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "html_url": "https://github.com/rust-lang/rust/commit/57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bd01efcead9e2a62e1e7704d95a07d1a451d282", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd01efcead9e2a62e1e7704d95a07d1a451d282", "html_url": "https://github.com/rust-lang/rust/commit/6bd01efcead9e2a62e1e7704d95a07d1a451d282"}, {"sha": "c13daeb036273d3fd0544c3cc58592f2a86d1631", "url": "https://api.github.com/repos/rust-lang/rust/commits/c13daeb036273d3fd0544c3cc58592f2a86d1631", "html_url": "https://github.com/rust-lang/rust/commit/c13daeb036273d3fd0544c3cc58592f2a86d1631"}], "stats": {"total": 151, "additions": 134, "deletions": 17}, "files": [{"sha": "94d520ec78c71a54f48822c7bbfbda17a155a338", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "patch": "@@ -117,6 +117,32 @@ impl TypeMap<'ll, 'tcx> {\n         }\n     }\n \n+    // Removes a Ty to metadata mapping\n+    // This is useful when computing the metadata for a potentially\n+    // recursive type (e.g. a function ptr of the form:\n+    //\n+    // fn foo() -> impl Copy { foo }\n+    //\n+    // This kind of type cannot be properly represented\n+    // via LLVM debuginfo. As a workaround,\n+    // we register a temporary Ty to metadata mapping\n+    // for the function before we compute its actual metadata.\n+    // If the metadata computation ends up recursing back to the\n+    // original function, it will use the temporary mapping\n+    // for the inner self-reference, preventing us from\n+    // recursing forever.\n+    //\n+    // This function is used to remove the temporary metadata\n+    // mapping after we've computed the actual metadata\n+    fn remove_type(\n+        &mut self,\n+        type_: Ty<'tcx>,\n+    ) {\n+        if self.type_to_metadata.remove(type_).is_none() {\n+            bug!(\"Type metadata Ty '{}' is not in the TypeMap!\", type_);\n+        }\n+    }\n+\n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(\n@@ -608,17 +634,49 @@ pub fn type_metadata(\n             }\n         }\n         ty::FnDef(..) | ty::FnPtr(_) => {\n-            let fn_metadata = subroutine_type_metadata(cx,\n-                                                       unique_type_id,\n-                                                       t.fn_sig(cx.tcx),\n-                                                       usage_site_span).metadata;\n+\n             if let Some(metadata) = debug_context(cx).type_map\n                .borrow()\n                .find_metadata_for_unique_id(unique_type_id)\n             {\n                 return metadata;\n             }\n \n+            // It's possible to create a self-referential\n+            // type in Rust by using 'impl trait':\n+            //\n+            // fn foo() -> impl Copy { foo }\n+            //\n+            // See TypeMap::remove_type for more detals\n+            // about the workaround\n+\n+            let temp_type = {\n+                unsafe {\n+                    // The choice of type here is pretty arbitrary -\n+                    // anything reading the debuginfo for a recursive\n+                    // type is going to see *somthing* weird - the only\n+                    // question is what exactly it will see\n+                    let (size, align) = cx.size_and_align_of(t);\n+                    llvm::LLVMRustDIBuilderCreateBasicType(\n+                        DIB(cx),\n+                        SmallCStr::new(\"<recur_type>\").as_ptr(),\n+                        size.bits(),\n+                        align.bits() as u32,\n+                        DW_ATE_unsigned)\n+                }\n+            };\n+\n+            let type_map = &debug_context(cx).type_map;\n+            type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n+\n+            let fn_metadata = subroutine_type_metadata(cx,\n+                                                       unique_type_id,\n+                                                       t.fn_sig(cx.tcx),\n+                                                       usage_site_span).metadata;\n+\n+            type_map.borrow_mut().remove_type(t);\n+\n+\n             // This is actually a function pointer, so wrap it in pointer DI\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n "}, {"sha": "eff7cd1bc8a485f5b77dc0d1c89190f55c86b41f", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "patch": "@@ -5,6 +5,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use rustc::hir;\n \n@@ -17,7 +18,8 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              qualified: bool)\n                                              -> String {\n     let mut result = String::with_capacity(64);\n-    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    let mut visited = FxHashSet::default();\n+    push_debuginfo_type_name(cx, t, qualified, &mut result, &mut visited);\n     result\n }\n \n@@ -26,7 +28,9 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n-                                          output: &mut String) {\n+                                          output: &mut String,\n+                                          visited: &mut FxHashSet<Ty<'tcx>>) {\n+\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n@@ -42,12 +46,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Foreign(def_id) => push_item_name(cx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n-            push_type_params(cx, substs, output);\n+            push_type_params(cx, substs, output, visited);\n         },\n         ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_debuginfo_type_name(cx, component_type, true, output);\n+                push_debuginfo_type_name(cx, component_type, true, output, visited);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -65,7 +69,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n@@ -79,15 +83,15 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push_str(\"mut \");\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('*');\n             }\n         },\n         ty::Array(inner_type, len) => {\n             output.push('[');\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n             output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n@@ -98,7 +102,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('[');\n             }\n \n-            push_debuginfo_type_name(cx, inner_type, true, output);\n+            push_debuginfo_type_name(cx, inner_type, true, output, visited);\n \n             if cpp_like_names {\n                 output.push('>');\n@@ -113,12 +117,31 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     &principal,\n                 );\n                 push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output);\n+                push_type_params(cx, principal.substs, output, visited);\n             } else {\n                 output.push_str(\"dyn '_\");\n             }\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n+            // We've encountered a weird 'recursive type'\n+            // Currently, the only way to generate such a type\n+            // is by using 'impl trait':\n+            //\n+            // fn foo() -> impl Copy { foo }\n+            //\n+            // There's not really a sensible name we can generate,\n+            // since we don't include 'impl trait' types (e.g. ty::Opaque)\n+            // in the output\n+            //\n+            // Since we need to generate *something*, we just\n+            // use a dummy string that should make it clear\n+            // that something unusual is going on\n+            if !visited.insert(t) {\n+                output.push_str(\"<recursive_type>\");\n+                return;\n+            }\n+\n+\n             let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n@@ -136,7 +159,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n-                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    push_debuginfo_type_name(cx, parameter_type, true, output, visited);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -155,8 +178,20 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output(), true, output);\n+                push_debuginfo_type_name(cx, sig.output(), true, output, visited);\n             }\n+\n+\n+            // We only keep the type in 'visited'\n+            // for the duration of the body of this method.\n+            // It's fine for a particular function type\n+            // to show up multiple times in one overall type\n+            // (e.g. MyType<fn() -> u8, fn() -> u8>\n+            //\n+            // We only care about avoiding recursing\n+            // directly back to the type we're currently\n+            // processing\n+            visited.remove(t);\n         },\n         ty::Closure(..) => {\n             output.push_str(\"closure\");\n@@ -200,15 +235,16 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     // common denominator - otherwise we would run into conflicts.\n     fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   substs: SubstsRef<'tcx>,\n-                                  output: &mut String) {\n+                                  output: &mut String,\n+                                  visited: &mut FxHashSet<Ty<'tcx>>) {\n         if substs.types().next().is_none() {\n             return;\n         }\n \n         output.push('<');\n \n         for type_parameter in substs.types() {\n-            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            push_debuginfo_type_name(cx, type_parameter, true, output, visited);\n             output.push_str(\", \");\n         }\n "}, {"sha": "f9113d50197c19950fead49653da4d78b495b374", "filename": "src/test/codegen/fn-impl-trait-self.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs?ref=57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -g\n+//\n+// CHECK-LABEL: @main\n+// CHECK: {{.*}}DIDerivedType(tag: DW_TAG_pointer_type, name: \"fn() -> <recursive_type>\",{{.*}}\n+//\n+// CHECK: {{.*}}DISubroutineType{{.*}}\n+// CHECK: {{.*}}DIBasicType(name: \"<recur_type>\", encoding: DW_ATE_unsigned)\n+\n+pub fn foo() -> impl Copy {\n+    foo\n+}\n+\n+fn main() {\n+    let my_res = foo();\n+}"}, {"sha": "8ab845366b7b4b873687dbc9e7aa6c4b82cd4237", "filename": "src/test/run-pass/issues/issue-58463.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a4f17b6e7f19a58fe01bdbeb2c894d10181745/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-58463.rs?ref=57a4f17b6e7f19a58fe01bdbeb2c894d10181745", "patch": "@@ -0,0 +1,8 @@\n+// run-pass\n+// compile-flags:-C debuginfo=2\n+fn foo() -> impl Copy {\n+    foo\n+}\n+fn main() {\n+    foo();\n+}"}]}