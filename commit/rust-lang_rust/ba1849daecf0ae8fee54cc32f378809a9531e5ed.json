{"sha": "ba1849daecf0ae8fee54cc32f378809a9531e5ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTg0OWRhZWNmMGFlOGZlZTU0Y2MzMmYzNzg4MDlhOTUzMWU1ZWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-13T13:09:56Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: move most of lifetime elision to resolve_lifetimes.", "tree": {"sha": "52a212d16ae5ae8a28a47102582676f81a7a60bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52a212d16ae5ae8a28a47102582676f81a7a60bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba1849daecf0ae8fee54cc32f378809a9531e5ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1849daecf0ae8fee54cc32f378809a9531e5ed", "html_url": "https://github.com/rust-lang/rust/commit/ba1849daecf0ae8fee54cc32f378809a9531e5ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba1849daecf0ae8fee54cc32f378809a9531e5ed/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "html_url": "https://github.com/rust-lang/rust/commit/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856"}], "stats": {"total": 1305, "additions": 703, "deletions": 602}, "files": [{"sha": "b51a7d4104ab92865a5f76d3ba2c3f542a32f690", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -327,6 +327,69 @@ struct ListNode {\n This works because `Box` is a pointer, so its size is well-known.\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```compile_fail,E0106\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; // correct\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```compile_fail,E0106\n+// error, no input lifetimes\n+fn foo() -> &str { }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```compile_fail,E0106\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { }\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:"}, {"sha": "7ca251f3ff91de62de25fac1399814690d4fc3e1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -314,9 +314,10 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n+                    let span = Span { hi: t.span.lo, ..t.span };\n                     let lifetime = match *region {\n                         Some(ref lt) => self.lower_lifetime(lt),\n-                        None => self.elided_lifetime(t.span)\n+                        None => self.elided_lifetime(span)\n                     };\n                     hir::TyRptr(lifetime, self.lower_mt(mt))\n                 }"}, {"sha": "4e02485a40b7d6f612e3b0be03b0fbb6578db022", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 492, "deletions": 10, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -22,11 +22,16 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n+\n+use std::cell::Cell;\n use std::mem::replace;\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n+use errors::DiagnosticBuilder;\n use util::nodemap::{NodeMap, FxHashSet, FxHashMap};\n+use rustc_back::slice;\n \n use hir;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -36,6 +41,7 @@ pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n     LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n+    LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n     Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n }\n \n@@ -51,9 +57,18 @@ impl Region {\n         (def.lifetime.name, Region::LateBound(depth, def.lifetime.id))\n     }\n \n+    fn late_anon(index: &Cell<u32>) -> Region {\n+        let i = index.get();\n+        index.set(i + 1);\n+        let depth = ty::DebruijnIndex::new(1);\n+        Region::LateBoundAnon(depth, i)\n+    }\n+\n     fn id(&self) -> Option<ast::NodeId> {\n         match *self {\n-            Region::Static => None,\n+            Region::Static |\n+            Region::LateBoundAnon(..) => None,\n+\n             Region::EarlyBound(_, id) |\n             Region::LateBound(_, id) |\n             Region::Free(_, id) => Some(id)\n@@ -65,6 +80,25 @@ impl Region {\n             Region::LateBound(depth, id) => {\n                 Region::LateBound(depth.shifted(amount), id)\n             }\n+            Region::LateBoundAnon(depth, index) => {\n+                Region::LateBoundAnon(depth.shifted(amount), index)\n+            }\n+            _ => self\n+        }\n+    }\n+\n+    fn from_depth(self, depth: u32) -> Region {\n+        match self {\n+            Region::LateBound(debruijn, id) => {\n+                Region::LateBound(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, id)\n+            }\n+            Region::LateBoundAnon(debruijn, index) => {\n+                Region::LateBoundAnon(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, index)\n+            }\n             _ => self\n         }\n     }\n@@ -122,14 +156,46 @@ enum Scope<'a> {\n \n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n     /// if this is a fn body, otherwise the original definitions are used.\n+    /// Unspecified lifetimes are inferred, unless an elision scope is nested,\n+    /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n     Body {\n         id: hir::BodyId,\n         s: ScopeRef<'a>\n     },\n \n+    /// A scope which either determines unspecified lifetimes or errors\n+    /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n+    Elision {\n+        elide: Elide,\n+        s: ScopeRef<'a>\n+    },\n+\n     Root\n }\n \n+#[derive(Clone, Debug)]\n+enum Elide {\n+    /// Use a fresh anonymous late-bound lifetime each time, by\n+    /// incrementing the counter to generate sequential indices.\n+    FreshLateAnon(Cell<u32>),\n+    /// Always use this one lifetime.\n+    Exact(Region),\n+    /// Like `Exact(Static)` but requires `#![feature(static_in_const)]`.\n+    Static,\n+    /// Less or more than one lifetime were found, error on unspecified.\n+    Error(Vec<ElisionFailureInfo>)\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ElisionFailureInfo {\n+    /// Where we can find the argument pattern.\n+    parent: Option<hir::BodyId>,\n+    /// The index of the argument in the original definition.\n+    index: usize,\n+    lifetime_count: usize,\n+    have_bound_regions: bool\n+}\n+\n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n@@ -189,12 +255,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::ItemUse(..) |\n             hir::ItemMod(..) |\n             hir::ItemDefaultImpl(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) => {\n+            hir::ItemForeignMod(..) => {\n                 // These sorts of items have no lifetime parameters at all.\n                 intravisit::walk_item(self, item);\n             }\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) => {\n+                // No lifetime parameters, but implied 'static.\n+                let scope = Scope::Elision {\n+                    elide: Elide::Static,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |_, this| intravisit::walk_item(this, item));\n+            }\n             hir::ItemTy(_, ref generics) |\n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n@@ -299,6 +372,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.is_elided() {\n+            self.resolve_elided_lifetimes(slice::ref_slice(lifetime_ref));\n             return;\n         }\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n@@ -308,6 +382,31 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n+    fn visit_path_parameters(&mut self, _: Span, params: &'tcx hir::PathParameters) {\n+        match *params {\n+            hir::AngleBracketedParameters(ref data) => {\n+                if data.lifetimes.iter().all(|l| l.is_elided()) {\n+                    self.resolve_elided_lifetimes(&data.lifetimes);\n+                } else {\n+                    for l in &data.lifetimes { self.visit_lifetime(l); }\n+                }\n+                for ty in &data.types { self.visit_ty(ty); }\n+                for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+            }\n+            hir::ParenthesizedParameters(ref data) => {\n+                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n+            }\n+        }\n+    }\n+\n+    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n+        let output = match fd.output {\n+            hir::DefaultReturn(_) => None,\n+            hir::Return(ref ty) => Some(ty)\n+        };\n+        self.visit_fn_like_elision(&fd.inputs, output);\n+    }\n+\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n@@ -478,10 +577,6 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n             }\n             intravisit::walk_expr(self, ex)\n         }\n-\n-        fn visit_item(&mut self, _: &hir::Item) {\n-            // do not recurse into items defined in the block\n-        }\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n@@ -499,7 +594,9 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                Scope::Body { s, .. } => { scope = s; }\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } => { scope = s; }\n+\n                 Scope::Root => { return; }\n \n                 Scope::Binder { ref lifetimes, s } => {\n@@ -639,6 +736,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         scope = s;\n                     }\n                 }\n+\n+                Scope::Elision { s, .. } => {\n+                    scope = s;\n+                }\n             }\n         };\n \n@@ -672,6 +773,386 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n+                             output: Option<&'tcx P<hir::Ty>>) {\n+        let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n+        let arg_scope = Scope::Elision {\n+            elide: arg_elide.clone(),\n+            s: self.scope\n+        };\n+        self.with(arg_scope, |_, this| {\n+            for input in inputs {\n+                this.visit_ty(input);\n+            }\n+            match *this.scope {\n+                Scope::Elision { ref elide, .. } => {\n+                    arg_elide = elide.clone();\n+                }\n+                _ => bug!()\n+            }\n+        });\n+\n+        let output = match output {\n+            Some(ty) => ty,\n+            None => return\n+        };\n+\n+        // Figure out if there's a body we can get argument names from,\n+        // and whether there's a `self` argument (treated specially).\n+        let mut assoc_item_kind = None;\n+        let mut impl_self = None;\n+        let parent = self.hir_map.get_parent_node(output.id);\n+        let body = match self.hir_map.get(parent) {\n+            // `fn` definitions and methods.\n+            hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(.., body), ..\n+            })  => Some(body),\n+\n+            hir::map::NodeTraitItem(&hir::TraitItem {\n+                node: hir::TraitItemKind::Method(_, ref m), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemTrait(.., ref trait_items) => {\n+                        assoc_item_kind = trait_items.iter().find(|ti| ti.id.node_id == parent)\n+                                                            .map(|ti| ti.kind);\n+                    }\n+                    _ => {}\n+                }\n+                match *m {\n+                    hir::TraitMethod::Required(_) => None,\n+                    hir::TraitMethod::Provided(body) => Some(body),\n+                }\n+            }\n+\n+            hir::map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(_, body), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n+                        impl_self = Some(self_ty);\n+                        assoc_item_kind = impl_items.iter().find(|ii| ii.id.node_id == parent)\n+                                                           .map(|ii| ii.kind);\n+                    }\n+                    _ => {}\n+                }\n+                Some(body)\n+            }\n+\n+            // `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n+            hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n+\n+            // Foreign `fn` decls are terrible because we messed up,\n+            // and their return types get argument type elision.\n+            // And now too much code out there is abusing this rule.\n+            hir::map::NodeForeignItem(_) => {\n+                let arg_scope = Scope::Elision {\n+                    elide: arg_elide,\n+                    s: self.scope\n+                };\n+                self.with(arg_scope, |_, this| this.visit_ty(output));\n+                return;\n+            }\n+\n+            // Everything else (only closures?) doesn't\n+            // actually enjoy elision in return types.\n+            _ => {\n+                self.visit_ty(output);\n+                return;\n+            }\n+        };\n+\n+        let has_self = match assoc_item_kind {\n+            Some(hir::AssociatedItemKind::Method { has_self }) => has_self,\n+            _ => false\n+        };\n+\n+        // In accordance with the rules for lifetime elision, we can determine\n+        // what region to use for elision in the output type in two ways.\n+        // First (determined here), if `self` is by-reference, then the\n+        // implied output region is the region of the self parameter.\n+        if has_self {\n+            // Look for `self: &'a Self` - also desugared from `&'a self`,\n+            // and if that matches, use it for elision and return early.\n+            let is_self_ty = |def: Def| {\n+                if let Def::SelfTy(..) = def {\n+                    return true;\n+                }\n+\n+                // Can't always rely on literal (or implied) `Self` due\n+                // to the way elision rules were originally specified.\n+                let impl_self = impl_self.map(|ty| &ty.node);\n+                if let Some(&hir::TyPath(hir::QPath::Resolved(None, ref path))) = impl_self {\n+                    match path.def {\n+                        // Whitelist the types that unambiguously always\n+                        // result in the same type constructor being used\n+                        // (it can't differ between `Self` and `self`).\n+                        Def::Struct(_) |\n+                        Def::Union(_) |\n+                        Def::Enum(_) |\n+                        Def::Trait(_) |\n+                        Def::PrimTy(_) => return def == path.def,\n+                        _ => {}\n+                    }\n+                }\n+\n+                false\n+            };\n+\n+            if let hir::TyRptr(lifetime_ref, ref mt) = inputs[0].node {\n+                if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n+                    if is_self_ty(path.def) {\n+                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                            let scope = Scope::Elision {\n+                                elide: Elide::Exact(lifetime),\n+                                s: self.scope\n+                            };\n+                            self.with(scope, |_, this| this.visit_ty(output));\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Second, if there was exactly one lifetime (either a substitution or a\n+        // reference) in the arguments, then any anonymous regions in the output\n+        // have that lifetime.\n+        let mut possible_implied_output_region = None;\n+        let mut lifetime_count = 0;\n+        let arg_lifetimes = inputs.iter().enumerate().skip(has_self as usize).map(|(i, input)| {\n+            let mut gather = GatherLifetimes {\n+                map: self.map,\n+                binder_depth: 1,\n+                have_bound_regions: false,\n+                lifetimes: FxHashSet()\n+            };\n+            gather.visit_ty(input);\n+\n+            lifetime_count += gather.lifetimes.len();\n+\n+            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                // there's a chance that the unique lifetime of this\n+                // iteration will be the appropriate lifetime for output\n+                // parameters, so lets store it.\n+                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+            }\n+\n+            ElisionFailureInfo {\n+                parent: body,\n+                index: i,\n+                lifetime_count: gather.lifetimes.len(),\n+                have_bound_regions: gather.have_bound_regions\n+            }\n+        }).collect();\n+\n+        let elide = if lifetime_count == 1 {\n+            Elide::Exact(possible_implied_output_region.unwrap())\n+        } else {\n+            Elide::Error(arg_lifetimes)\n+        };\n+\n+        let scope = Scope::Elision {\n+            elide: elide,\n+            s: self.scope\n+        };\n+        self.with(scope, |_, this| this.visit_ty(output));\n+\n+        struct GatherLifetimes<'a> {\n+            map: &'a NamedRegionMap,\n+            binder_depth: u32,\n+            have_bound_regions: bool,\n+            lifetimes: FxHashSet<Region>,\n+        }\n+\n+        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n+            fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_ty(&mut self, ty: &hir::Ty) {\n+                let delta = match ty.node {\n+                    hir::TyBareFn(_) => 1,\n+                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                        // if this path references a trait, then this will resolve to\n+                        // a trait ref, which introduces a binding scope.\n+                        match path.def {\n+                            Def::Trait(..) => 1,\n+                            _ => 0\n+                        }\n+                    }\n+                    _ => 0\n+                };\n+                self.binder_depth += delta;\n+                intravisit::walk_ty(self, ty);\n+                self.binder_depth -= delta;\n+            }\n+\n+            fn visit_poly_trait_ref(&mut self,\n+                                    trait_ref: &hir::PolyTraitRef,\n+                                    modifier: &hir::TraitBoundModifier) {\n+                self.binder_depth += 1;\n+                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+                self.binder_depth -= 1;\n+            }\n+\n+            fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n+                for l in &lifetime_def.bounds { self.visit_lifetime(l); }\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                    match lifetime {\n+                        Region::LateBound(debruijn, _) |\n+                        Region::LateBoundAnon(debruijn, _)\n+                                if debruijn.depth < self.binder_depth => {\n+                            self.have_bound_regions = true;\n+                        }\n+                        _ => {\n+                            self.lifetimes.insert(lifetime.from_depth(self.binder_depth));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[hir::Lifetime]) {\n+        if lifetime_refs.is_empty() {\n+            return;\n+        }\n+\n+        let span = lifetime_refs[0].span;\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let error = loop {\n+            match *scope {\n+                // Do not assign any resolution, it will be inferred.\n+                Scope::Body { .. } => return,\n+\n+                Scope::Root => break None,\n+\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n+                    scope = s;\n+                }\n+\n+                Scope::Elision { ref elide, .. } => {\n+                    let lifetime = match *elide {\n+                        Elide::FreshLateAnon(ref counter) => {\n+                            for lifetime_ref in lifetime_refs {\n+                                let lifetime = Region::late_anon(counter).shifted(late_depth);\n+                                self.insert_lifetime(lifetime_ref, lifetime);\n+                            }\n+                            return;\n+                        }\n+                        Elide::Exact(l) => l.shifted(late_depth),\n+                        Elide::Static => {\n+                            if !self.sess.features.borrow().static_in_const {\n+                                self.sess\n+                                    .struct_span_err(span,\n+                                                     \"this needs a `'static` lifetime or the \\\n+                                                      `static_in_const` feature, see #35897\")\n+                                    .emit();\n+                            }\n+                            Region::Static\n+                        }\n+                        Elide::Error(ref e) => break Some(e)\n+                    };\n+                    for lifetime_ref in lifetime_refs {\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    return;\n+                }\n+            }\n+        };\n+\n+        let mut err = struct_span_err!(self.sess, span, E0106,\n+            \"missing lifetime specifier{}\",\n+            if lifetime_refs.len() > 1 { \"s\" } else { \"\" });\n+        let msg = if lifetime_refs.len() > 1 {\n+            format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n+        } else {\n+            format!(\"expected lifetime parameter\")\n+        };\n+        err.span_label(span, &msg);\n+\n+        if let Some(params) = error {\n+            if lifetime_refs.len() == 1 {\n+                self.report_elision_failure(&mut err, params);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n+    fn report_elision_failure(&mut self,\n+                              db: &mut DiagnosticBuilder,\n+                              params: &[ElisionFailureInfo]) {\n+        let mut m = String::new();\n+        let len = params.len();\n+\n+        let elided_params: Vec<_> = params.iter().cloned()\n+                                          .filter(|info| info.lifetime_count > 0)\n+                                          .collect();\n+\n+        let elided_len = elided_params.len();\n+\n+        for (i, info) in elided_params.into_iter().enumerate() {\n+            let ElisionFailureInfo {\n+                parent, index, lifetime_count: n, have_bound_regions\n+            } = info;\n+\n+            let help_name = if let Some(body) = parent {\n+                let arg = &self.hir_map.body(body).arguments[index];\n+                format!(\"`{}`\", self.hir_map.node_to_pretty_string(arg.pat.id))\n+            } else {\n+                format!(\"argument {}\", index + 1)\n+            };\n+\n+            m.push_str(&(if n == 1 {\n+                help_name\n+            } else {\n+                format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                        if have_bound_regions { \"free \" } else { \"\" } )\n+            })[..]);\n+\n+            if elided_len == 2 && i == 0 {\n+                m.push_str(\" or \");\n+            } else if i + 2 == elided_len {\n+                m.push_str(\", or \");\n+            } else if i != elided_len - 1 {\n+                m.push_str(\", \");\n+            }\n+\n+        }\n+\n+        if len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   there is no value for it to be borrowed from\");\n+            help!(db,\n+                  \"consider giving it a 'static lifetime\");\n+        } else if elided_len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value with \\\n+                   an elided lifetime, but the lifetime cannot be derived from \\\n+                   the arguments\");\n+            help!(db,\n+                  \"consider giving it an explicit bounded or 'static \\\n+                   lifetime\");\n+        } else if elided_len == 1 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say which {} it is borrowed from\",\n+                  m);\n+        } else {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say whether it is borrowed from {}\",\n+                  m);\n+        }\n+    }\n+\n     fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n@@ -729,7 +1210,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         loop {\n             match *old_scope {\n-                Scope::Body { s, .. } => {\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } => {\n                     old_scope = s;\n                 }\n "}, {"sha": "42a220e1b9b4b16a829df0fbaaf924426c6b82dc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 55, "deletions": 282, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -61,9 +61,7 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n-             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n-             ElisionFailureInfo, ElidedLifetime};\n+use rscope::{RegionScope, ObjectLifetimeDefaultRscope, ShiftedRscope};\n use rscope::{AnonTypeScope, MaybeWithAnonTypes, ExplicitRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n@@ -74,7 +72,6 @@ use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -111,6 +108,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// See ParameterEnvironment::free_substs for more information.\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n+    /// What lifetime should we use when a lifetime is omitted (and not elided)?\n+    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> &'tcx ty::Region;\n+\n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n@@ -161,94 +162,16 @@ struct ConvertedBinding<'tcx> {\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-fn report_elision_failure(\n-    tcx: TyCtxt,\n-    db: &mut DiagnosticBuilder,\n-    params: Vec<ElisionFailureInfo>)\n-{\n-    let mut m = String::new();\n-    let len = params.len();\n-\n-    let elided_params: Vec<_> = params.into_iter()\n-                                       .filter(|info| info.lifetime_count > 0)\n-                                       .collect();\n-\n-    let elided_len = elided_params.len();\n-\n-    for (i, info) in elided_params.into_iter().enumerate() {\n-        let ElisionFailureInfo {\n-            parent, index, lifetime_count: n, have_bound_regions\n-        } = info;\n-\n-        let help_name = if let Some(body) = parent {\n-            let arg = &tcx.hir.body(body).arguments[index];\n-            format!(\"`{}`\", tcx.hir.node_to_pretty_string(arg.pat.id))\n-        } else {\n-            format!(\"argument {}\", index + 1)\n-        };\n-\n-        m.push_str(&(if n == 1 {\n-            help_name\n-        } else {\n-            format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n-                    if have_bound_regions { \"free \" } else { \"\" } )\n-        })[..]);\n-\n-        if elided_len == 2 && i == 0 {\n-            m.push_str(\" or \");\n-        } else if i + 2 == elided_len {\n-            m.push_str(\", or \");\n-        } else if i != elided_len - 1 {\n-            m.push_str(\", \");\n-        }\n-\n-    }\n-\n-    if len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    there is no value for it to be borrowed from\");\n-        help!(db,\n-                   \"consider giving it a 'static lifetime\");\n-    } else if elided_len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value with \\\n-                    an elided lifetime, but the lifetime cannot be derived from \\\n-                    the arguments\");\n-        help!(db,\n-                   \"consider giving it an explicit bounded or 'static \\\n-                    lifetime\");\n-    } else if elided_len == 1 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say which {} it is borrowed from\",\n-                   m);\n-    } else {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say whether it is borrowed from {}\",\n-                   m);\n-    }\n-}\n-\n impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n-    pub fn ast_region_to_region(&self, lifetime: &hir::Lifetime) -> &'tcx ty::Region {\n-        self.opt_ast_region_to_region(&ExplicitRscope, lifetime.span, Some(lifetime), None)\n-    }\n-\n-    fn try_opt_ast_region_to_region(&self,\n-        rscope: &RegionScope,\n-        default_span: Span,\n-        opt_lifetime: Option<&hir::Lifetime>,\n+    pub fn ast_region_to_region(&self,\n+        lifetime: &hir::Lifetime,\n         def: Option<&ty::RegionParameterDef>)\n-        -> Result<&'tcx ty::Region, Option<Vec<ElisionFailureInfo>>>\n+        -> &'tcx ty::Region\n     {\n         let tcx = self.tcx();\n-        let name = opt_lifetime.map(|l| l.name);\n-        let resolved = opt_lifetime.and_then(|l| tcx.named_region_map.defs.get(&l.id));\n-        let r = tcx.mk_region(match resolved {\n+        let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n             Some(&rl::Region::Static) => {\n-                ty::ReStatic\n+                tcx.mk_region(ty::ReStatic)\n             }\n \n             Some(&rl::Region::LateBound(debruijn, id)) => {\n@@ -263,16 +186,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      .get(&id)\n                                      .cloned()\n                                      .unwrap_or(ty::Issue32330::WontChange);\n-                ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n-                                                      name.unwrap(),\n-                                                      issue_32330))\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReLateBound(debruijn,\n+                    ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)))\n+            }\n+\n+            Some(&rl::Region::LateBoundAnon(debruijn, index)) => {\n+                tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n             }\n \n-            Some(&rl::Region::EarlyBound(index, _)) => {\n-                ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            Some(&rl::Region::EarlyBound(index, id)) => {\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     index: index,\n-                    name: name.unwrap()\n-                })\n+                    name: name\n+                }))\n             }\n \n             Some(&rl::Region::Free(scope, id)) => {\n@@ -283,47 +211,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      .get(&id)\n                                      .cloned()\n                                      .unwrap_or(ty::Issue32330::WontChange);\n-                ty::ReFree(ty::FreeRegion {\n-                        scope: scope.to_code_extent(&tcx.region_maps),\n-                        bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n-                                                  name.unwrap(),\n-                                                  issue_32330)\n-                })\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                    scope: scope.to_code_extent(&tcx.region_maps),\n+                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)\n+                }))\n \n                     // (*) -- not late-bound, won't change\n             }\n \n-            None => rscope.anon_region(default_span, def)?\n-        });\n+            None => self.re_infer(lifetime.span, def)\n+        };\n \n-        debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n-                opt_lifetime,\n+        debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\",\n+                lifetime,\n                 r);\n \n-        Ok(r)\n-    }\n-\n-    pub fn opt_ast_region_to_region(&self,\n-        rscope: &RegionScope,\n-        default_span: Span,\n-        opt_lifetime: Option<&hir::Lifetime>,\n-        def: Option<&ty::RegionParameterDef>) -> &'tcx ty::Region\n-    {\n-        let tcx = self.tcx();\n-        self.try_opt_ast_region_to_region(rscope, default_span, opt_lifetime, def)\n-            .unwrap_or_else(|params| {\n-                let ampersand_span = Span { hi: default_span.lo, ..default_span};\n-\n-                let mut err = struct_span_err!(tcx.sess, ampersand_span, E0106,\n-                                               \"missing lifetime specifier\");\n-                err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n-\n-                if let Some(params) = params {\n-                    report_elision_failure(tcx, &mut err, params);\n-                }\n-                err.emit();\n-                tcx.mk_region(ty::ReStatic)\n-            })\n+        r\n     }\n \n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n@@ -404,20 +308,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n-        let mut reported_lifetime_count_mismatch = false;\n-        let mut report_lifetime_count_mismatch = || {\n-            if !reported_lifetime_count_mismatch {\n-                reported_lifetime_count_mismatch = true;\n-                let all_infer = lifetimes.iter().all(|lt| lt.is_elided());\n-                let supplied = if all_infer { 0 } else { supplied_num_region_params };\n-                report_lifetime_number_error(tcx, span,\n-                                             supplied,\n-                                             expected_num_region_params);\n-            }\n-        };\n-\n         if expected_num_region_params != supplied_num_region_params {\n-            report_lifetime_count_mismatch();\n+            report_lifetime_number_error(tcx, span,\n+                                         supplied_num_region_params,\n+                                         expected_num_region_params);\n         }\n \n         // If a self-type was declared, one should be provided.\n@@ -445,11 +339,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            let l = lifetimes.get(i);\n-            self.try_opt_ast_region_to_region(rscope, span, l, Some(def)).unwrap_or_else(|_| {\n-                report_lifetime_count_mismatch();\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                self.ast_region_to_region(lifetime, Some(def))\n+            } else {\n                 tcx.mk_region(ty::ReStatic)\n-            })\n+            }\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -533,92 +427,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (substs, assoc_bindings)\n     }\n \n-    /// Returns the appropriate lifetime to use for any output lifetimes\n-    /// (if one exists) and a vector of the (pattern, number of lifetimes)\n-    /// corresponding to each input type/pattern.\n-    fn find_implied_output_region<I>(&self,\n-                                     input_tys: &[Ty<'tcx>],\n-                                     parent: Option<hir::BodyId>,\n-                                     input_indices: I) -> ElidedLifetime\n-        where I: Iterator<Item=usize>\n-    {\n-        let tcx = self.tcx();\n-        let mut lifetimes_for_params = Vec::with_capacity(input_tys.len());\n-        let mut possible_implied_output_region = None;\n-        let mut lifetimes = 0;\n-\n-        for (input_type, index) in input_tys.iter().zip(input_indices) {\n-            let mut regions = FxHashSet();\n-            let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n-\n-            debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n-                    have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n-\n-            lifetimes += regions.len();\n-\n-            if lifetimes == 1 && regions.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = regions.iter().cloned().next();\n-            }\n-\n-            lifetimes_for_params.push(ElisionFailureInfo {\n-                parent: parent,\n-                index: index,\n-                lifetime_count: regions.len(),\n-                have_bound_regions: have_bound_regions\n-            });\n-        }\n-\n-        if lifetimes == 1 {\n-            Ok(*possible_implied_output_region.unwrap())\n-        } else {\n-            Err(Some(lifetimes_for_params))\n-        }\n-    }\n-\n-    fn convert_ty_with_lifetime_elision(&self,\n-                                        elided_lifetime: ElidedLifetime,\n-                                        ty: &hir::Ty,\n-                                        anon_scope: Option<AnonTypeScope>)\n-                                        -> Ty<'tcx>\n-    {\n-        match elided_lifetime {\n-            Ok(implied_output_region) => {\n-                let rb = ElidableRscope::new(implied_output_region);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-            Err(param_lifetimes) => {\n-                // All regions must be explicitly specified in the output\n-                // if the lifetime elision rules do not apply. This saves\n-                // the user from potentially-confusing errors.\n-                let rb = UnelidableRscope::new(param_lifetimes);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-        }\n-    }\n-\n     fn convert_parenthesized_parameters(&self,\n                                         rscope: &RegionScope,\n                                         region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n         let anon_scope = rscope.anon_type_scope();\n-        let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n+        let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n+            self.ast_ty_arg_to_ty(&rscope, None, region_substs, a_t)\n         }));\n-        let input_params = 0..inputs.len();\n-        let implied_output_region = self.find_implied_output_region(&inputs, None, input_params);\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                       &output_ty,\n-                                                       anon_scope),\n-                 output_ty.span)\n+                (self.ast_ty_to_ty(&rscope, output_ty), output_ty.span)\n             }\n             None => {\n                 (self.tcx().mk_nil(), data.span)\n@@ -1469,7 +1292,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n-                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, Some(region), None);\n+                let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n                 let rscope1 =\n                     &ObjectLifetimeDefaultRscope::new(\n@@ -1489,9 +1312,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let anon_scope = rscope.anon_type_scope();\n                 let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n                                                               bf.abi,\n-                                                              None,\n                                                               &bf.decl,\n-                                                              None,\n                                                               anon_scope,\n                                                               anon_scope);\n \n@@ -1626,37 +1447,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    pub fn ty_of_method(&self,\n-                        sig: &hir::MethodSig,\n-                        opt_self_value_ty: Option<Ty<'tcx>>,\n-                        body: Option<hir::BodyId>,\n-                        anon_scope: Option<AnonTypeScope>)\n-                        -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(sig.unsafety,\n-                                     sig.abi,\n-                                     opt_self_value_ty,\n-                                     &sig.decl,\n-                                     body,\n-                                     None,\n-                                     anon_scope)\n-    }\n-\n-    pub fn ty_of_bare_fn(&self,\n-                         unsafety: hir::Unsafety,\n-                         abi: abi::Abi,\n-                         decl: &hir::FnDecl,\n-                         body: hir::BodyId,\n-                         anon_scope: Option<AnonTypeScope>)\n-                         -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, Some(body), None, anon_scope)\n+    pub fn ty_of_fn(&self,\n+                    unsafety: hir::Unsafety,\n+                    abi: abi::Abi,\n+                    decl: &hir::FnDecl,\n+                    anon_scope: Option<AnonTypeScope>)\n+                    -> &'tcx ty::BareFnTy<'tcx> {\n+        self.ty_of_method_or_bare_fn(unsafety, abi, decl, None, anon_scope)\n     }\n \n     fn ty_of_method_or_bare_fn(&self,\n                                unsafety: hir::Unsafety,\n                                abi: abi::Abi,\n-                               opt_self_value_ty: Option<Ty<'tcx>>,\n                                decl: &hir::FnDecl,\n-                               body: Option<hir::BodyId>,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n                                -> &'tcx ty::BareFnTy<'tcx>\n@@ -1665,40 +1468,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // New region names that appear inside of the arguments of the function\n         // declaration are bound to that function type.\n-        let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n+        let rb = MaybeWithAnonTypes::new(ExplicitRscope, arg_anon_scope);\n \n         let input_tys: Vec<Ty> =\n             decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n \n-        let has_self = opt_self_value_ty.is_some();\n-        let explicit_self = opt_self_value_ty.map(|self_value_ty| {\n-            ExplicitSelf::determine(self_value_ty, input_tys[0])\n-        });\n-\n-        let implied_output_region = match explicit_self {\n-            // `implied_output_region` is the region that will be assumed for any\n-            // region parameters in the return type. In accordance with the rules for\n-            // lifetime elision, we can determine it in two ways. First (determined\n-            // here), if self is by-reference, then the implied output region is the\n-            // region of the self parameter.\n-            Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n-\n-            // Second, if there was exactly one lifetime (either a substitution or a\n-            // reference) in the arguments, then any anonymous regions in the output\n-            // have that lifetime.\n-            _ => {\n-                let arg_tys = &input_tys[has_self as usize..];\n-                let arg_params = has_self as usize..input_tys.len();\n-                self.find_implied_output_region(arg_tys, body, arg_params)\n-\n-            }\n-        };\n-\n         let output_ty = match decl.output {\n             hir::Return(ref output) =>\n-                self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                      &output,\n-                                                      ret_anon_scope),\n+                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(ExplicitRscope, ret_anon_scope), output),\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n@@ -1725,10 +1502,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_closure(expected_sig={:?})\",\n                expected_sig);\n \n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = rscope::BindingRscope::new();\n-\n         let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n             let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n                 // no guarantee that the correct number of expected args\n@@ -1739,7 +1512,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     None\n                 }\n             });\n-            self.ty_of_arg(&rb, a, expected_arg_ty)\n+            self.ty_of_arg(&ExplicitRscope, a, expected_arg_ty)\n         });\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n@@ -1755,7 +1528,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 expected_ret_ty.unwrap(),\n             _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&rb, &output),\n+                self.ast_ty_to_ty(&ExplicitRscope, &output),\n             hir::DefaultReturn(..) => bug!(),\n         };\n \n@@ -1820,7 +1593,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if let Some(&r) = explicit_region_bounds.get(0) {\n             // Explicitly specified region bound. Use that.\n-            return Some(self.ast_region_to_region(r));\n+            return Some(self.ast_region_to_region(r, None));\n         }\n \n         if let Some(principal) = existential_predicates.principal() {"}, {"sha": "a8b5d718f81d0302f81397f3bd23a1cc2af6036a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -97,7 +97,7 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n-use rscope::{ElisionFailureInfo, RegionScope};\n+use rscope::RegionScope;\n use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n@@ -1410,6 +1410,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n+    fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n+                -> &'tcx ty::Region {\n+        let v = match def {\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n+            None => infer::MiscVariable(span)\n+        };\n+        self.next_region_var(v)\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n@@ -1465,15 +1474,6 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n         // be some expression).\n         *self.next_region_var(infer::MiscVariable(span))\n     }\n-\n-    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        let v = match def {\n-            Some(def) => infer::EarlyBoundRegion(span, def.name),\n-            None => infer::MiscVariable(span)\n-        };\n-        Ok(*self.next_region_var(v))\n-    }\n }\n \n /// Controls whether the arguments are tupled. This is used for the call\n@@ -4408,7 +4408,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n-            AstConv::opt_ast_region_to_region(self, self, span, lifetimes.get(i), Some(def))\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                AstConv::ast_region_to_region(self, lifetime, Some(def))\n+            } else {\n+                self.re_infer(span, Some(def))\n+            }\n         }, |def, substs| {\n             let mut i = def.index as usize;\n "}, {"sha": "70bd43751ebdf7129270a8210e7decb5f7409ae2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 53, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -437,6 +437,11 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> &'tcx ty::Region {\n+        span_bug!(span, \"unelided lifetime in signature\");\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         struct_span_err!(\n             self.tcx().sess,\n@@ -639,8 +644,6 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: AssociatedItemContainer,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n-                            untransformed_rcvr_ty: Ty<'tcx>,\n-                            body: Option<hir::BodyId>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n     let def_id = ccx.tcx.hir.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n@@ -652,14 +655,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n         TraitContainer(_) => None\n     };\n-    let assoc_item = ccx.tcx.associated_item(def_id);\n-    let self_value_ty = if assoc_item.method_has_self_argument {\n-        Some(untransformed_rcvr_ty)\n-    } else {\n-        None\n-    };\n-    let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                    sig, self_value_ty, body, anon_scope);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                sig.unsafety, sig.abi, &sig.decl, anon_scope);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.hir.span(id), def_id);\n@@ -876,14 +873,9 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n-        hir::TraitItemKind::Method(ref sig, ref method) => {\n-            let body = match *method {\n-                hir::TraitMethod::Required(_) => None,\n-                hir::TraitMethod::Provided(body) => Some(body)\n-            };\n+        hir::TraitItemKind::Method(ref sig, _) => {\n             convert_method(ccx, TraitContainer(trait_def_id),\n-                           trait_item.id, sig, tcx.mk_self_type(),\n-                           body, &trait_predicates);\n+                           trait_item.id, sig, &trait_predicates);\n         }\n     }\n }\n@@ -896,7 +888,6 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n     let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n     let impl_predicates = tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n-    let impl_self_ty = tcx.item_type(impl_def_id);\n \n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n@@ -923,10 +914,8 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n-        hir::ImplItemKind::Method(ref sig, body) => {\n-            convert_method(ccx, ImplContainer(impl_def_id),\n-                           impl_item.id, sig, impl_self_ty,\n-                           Some(body), &impl_predicates);\n+        hir::ImplItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, ImplContainer(impl_def_id), impl_item.id, sig, &impl_predicates);\n         }\n     }\n }\n@@ -1472,7 +1461,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n-                    AstConv::ast_region_to_region(&ccx.icx(&()), l)\n+                    AstConv::ast_region_to_region(&ccx.icx(&()), l, None)\n                 }).collect(),\n                 pure_wrt_drop: l.pure_wrt_drop,\n             }\n@@ -1545,11 +1534,11 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&StaticRscope::new(&ccx.tcx), &t)\n+                        ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, body) => {\n-                        let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                          body, Some(AnonTypeScope::new(def_id)));\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl,\n+                                                     Some(AnonTypeScope::new(def_id)));\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n@@ -1765,7 +1754,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             name: param.lifetime.name\n         }));\n         for bound in &param.bounds {\n-            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound);\n+            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n@@ -1816,7 +1805,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = AstConv::ast_region_to_region(&ccx.icx(&()), lifetime);\n+                            let region = AstConv::ast_region_to_region(&ccx.icx(&()),\n+                                                                       lifetime,\n+                                                                       None);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1825,9 +1816,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime);\n+                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound);\n+                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n@@ -1935,7 +1926,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                       hir::TraitTyParamBound(..) =>\n                           None,\n                       hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(AstConv::ast_region_to_region(&ccx.icx(&()), lifetime)),\n+                          Some(AstConv::ast_region_to_region(&ccx.icx(&()), lifetime, None)),\n                   }\n               })\n               .collect()\n@@ -1997,7 +1988,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     }).collect();\n \n     let region_bounds = region_bounds.into_iter().map(|r| {\n-        astconv.ast_region_to_region(r)\n+        astconv.ast_region_to_region(r, None)\n     }).collect();\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n@@ -2039,7 +2030,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                        .collect()\n         }\n         hir::RegionTyParamBound(ref lifetime) => {\n-            let region = astconv.ast_region_to_region(lifetime);\n+            let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }\n@@ -2057,18 +2048,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let rb = BindingRscope::new();\n-    let input_tys = decl.inputs\n-                        .iter()\n-                        .map(|a| AstConv::ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n-                        .collect::<Vec<_>>();\n-\n-    let output = match decl.output {\n-        hir::Return(ref ty) =>\n-            AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty),\n-        hir::DefaultReturn(..) =>\n-            ccx.tcx.mk_nil(),\n-    };\n+    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl, None);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n@@ -2084,21 +2064,17 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n+        for (input, ty) in decl.inputs.iter().zip(*fty.sig.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&ty, output)\n+            check(&ty, *fty.sig.output().skip_binder())\n         }\n     }\n \n     let id = ccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.hir.span(id), def_id);\n-    ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n-        abi: abi,\n-        unsafety: hir::Unsafety::Unsafe,\n-        sig: ty::Binder(ccx.tcx.mk_fn_sig(input_tys.into_iter(), output, decl.variadic)),\n-    }))\n+    ccx.tcx.mk_fn_def(def_id, substs, fty)\n }\n \n pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,"}, {"sha": "7f8c508bf22245e5387f87b8ffc40b4153328081", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 69, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -1412,85 +1412,19 @@ fn main() {\n ```\n \"##,\n \n-E0106: r##\"\n-This error indicates that a lifetime is missing from a type. If it is an error\n-inside a function signature, the problem may be with failing to adhere to the\n-lifetime elision rules (see below).\n-\n-Here are some simple examples of where you'll run into this error:\n-\n-```compile_fail,E0106\n-struct Foo { x: &bool }        // error\n-struct Foo<'a> { x: &'a bool } // correct\n-\n-enum Bar { A(u8), B(&bool), }        // error\n-enum Bar<'a> { A(u8), B(&'a bool), } // correct\n-\n-type MyStr = &str;        // error\n-type MyStr<'a> = &'a str; // correct\n-```\n-\n-Lifetime elision is a special, limited kind of inference for lifetimes in\n-function signatures which allows you to leave out lifetimes in certain cases.\n-For more background on lifetime elision see [the book][book-le].\n-\n-The lifetime elision rules require that any function signature with an elided\n-output lifetime must either have\n-\n- - exactly one input lifetime\n- - or, multiple input lifetimes, but the function must also be a method with a\n-   `&self` or `&mut self` receiver\n-\n-In the first case, the output lifetime is inferred to be the same as the unique\n-input lifetime. In the second case, the lifetime is instead inferred to be the\n-same as the lifetime on `&self` or `&mut self`.\n-\n-Here are some examples of elision errors:\n-\n-```compile_fail,E0106\n-// error, no input lifetimes\n-fn foo() -> &str { }\n-\n-// error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { }\n-\n-// error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { }\n-```\n-\n-[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n-\"##,\n-\n E0107: r##\"\n This error means that an incorrect number of lifetime parameters were provided\n-for a type (like a struct or enum) or trait.\n-\n-Some basic examples include:\n+for a type (like a struct or enum) or trait:\n \n ```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n+struct Foo<'a, 'b>(&'a str, &'b str);\n enum Bar { A, B, C }\n \n struct Baz<'a> {\n-    foo: Foo,     // error: expected 1, found 0\n+    foo: Foo<'a>, // error: expected 2, found 1\n     bar: Bar<'a>, // error: expected 0, found 1\n }\n ```\n-\n-Here's an example that is currently an error, but may work in a future version\n-of Rust:\n-\n-```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n-\n-trait Quux { }\n-impl Quux for Foo { } // error: expected 1, found 0\n-```\n-\n-Lifetime elision in implementation headers was part of the lifetime elision\n-RFC. It is, however, [currently unimplemented][iss15872].\n-\n-[iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n E0116: r##\""}, {"sha": "3ac917c396cf153eae8cb18e0a23dfd1b976eba7", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -8,28 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n \n use astconv::AstConv;\n \n-use std::cell::Cell;\n use syntax_pos::Span;\n \n-#[derive(Clone)]\n-pub struct ElisionFailureInfo {\n-    /// Where we can find the argument pattern.\n-    pub parent: Option<hir::BodyId>,\n-    /// The index of the argument in the original definition.\n-    pub index: usize,\n-    pub lifetime_count: usize,\n-    pub have_bound_regions: bool\n-}\n-\n-pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n-\n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of\n /// this reference has been omitted. When converting this\n@@ -41,9 +27,6 @@ pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n /// can return `Err(())` to indicate that this is not a scope in which\n /// regions can legally be omitted.\n pub trait RegionScope {\n-    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n-\n     /// If an object omits any explicit lifetime bound, and none can\n     /// be derived from the object traits, what should we use? If\n     /// `None` is returned, an explicit annotation is required.\n@@ -115,11 +98,6 @@ impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n         self.base_scope.object_lifetime_default(span)\n     }\n \n-    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        self.base_scope.anon_region(span, def)\n-    }\n-\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n         self.base_scope.base_object_lifetime_default(span)\n     }\n@@ -135,105 +113,6 @@ impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n-    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        Err(None)\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);\n-\n-impl UnelidableRscope {\n-    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope {\n-        UnelidableRscope(v)\n-    }\n-}\n-\n-impl RegionScope for UnelidableRscope {\n-    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        Err(self.0.clone())\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// A scope in which omitted anonymous region defaults to\n-// `default`. This is used after the `->` in function signatures. The\n-// latter use may go away. Note that object-lifetime defaults work a\n-// bit differently, as specified in RFC #599.\n-pub struct ElidableRscope {\n-    default: ty::Region,\n-}\n-\n-impl ElidableRscope {\n-    pub fn new(r: ty::Region) -> ElidableRscope {\n-        ElidableRscope { default: r }\n-    }\n-}\n-\n-impl RegionScope for ElidableRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over\n-        // lifetime elision.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        Ok(self.default)\n-    }\n-}\n-\n-/// A scope that behaves as an ElidabeRscope with a `'static` default region\n-/// that should also warn if the `static_in_const` feature is unset.\n-#[derive(Copy, Clone)]\n-pub struct StaticRscope<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> StaticRscope<'a, 'gcx, 'tcx> {\n-    /// create a new StaticRscope from a reference to the `TyCtxt`\n-    pub fn new(tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        StaticRscope { tcx: tcx }\n-    }\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> RegionScope for StaticRscope<'a, 'gcx, 'tcx> {\n-    fn anon_region(&self, span: Span, _: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        if !self.tcx.sess.features.borrow().static_in_const {\n-            self.tcx\n-                .sess\n-                .struct_span_err(span,\n-                                 \"this needs a `'static` lifetime or the \\\n-                                 `static_in_const` feature, see #35897\")\n-                .emit();\n-        }\n-        Ok(ty::ReStatic)\n-    }\n-\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         Some(self.base_object_lifetime_default(span))\n     }\n@@ -243,41 +122,6 @@ impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> RegionScope for StaticRscope<'a, 'gcx, 'tcx>\n     }\n }\n \n-/// A scope in which we generate anonymous, late-bound regions for\n-/// omitted regions. This occurs in function signatures.\n-pub struct BindingRscope {\n-    anon_bindings: Cell<u32>,\n-}\n-\n-impl BindingRscope {\n-    pub fn new() -> BindingRscope {\n-        BindingRscope {\n-            anon_bindings: Cell::new(0),\n-        }\n-    }\n-}\n-\n-impl RegionScope for BindingRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over the\n-        // binding defaults in a fn signature.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_region(&self, _: Span, _: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        let idx = self.anon_bindings.get();\n-        self.anon_bindings.set(idx + 1);\n-        Ok(ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(idx)))\n-    }\n-}\n-\n /// A scope which overrides the default object lifetime but has no other effect.\n pub struct ObjectLifetimeDefaultRscope<'r> {\n     base_scope: &'r (RegionScope+'r),\n@@ -315,12 +159,6 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n         self.base_scope.base_object_lifetime_default(span)\n     }\n \n-    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        self.base_scope.anon_region(span, def)\n-    }\n-\n     fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n         self.base_scope.anon_type_scope()\n     }\n@@ -348,12 +186,6 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n         ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n     }\n \n-    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n-                   -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        self.base_scope.anon_region(span, def).map(|r| ty::fold::shift_region(r, 1))\n-    }\n-\n     fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n         self.base_scope.anon_type_scope()\n     }"}, {"sha": "d5644ab0608877a2fd5ad62d4f2fb768abcdaa03", "filename": "src/test/compile-fail/E0106.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2FE0106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2FE0106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0106.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -23,5 +23,17 @@ type MyStr = &str;\n         //~^ ERROR E0106\n         //~| NOTE expected lifetime parameter\n \n+struct Baz<'a>(&'a str);\n+struct Buzz<'a, 'b>(&'a str, &'b str);\n+\n+struct Quux {\n+    baz: Baz,\n+    //~^ ERROR E0106\n+    //~| expected lifetime parameter\n+    buzz: Buzz,\n+    //~^ ERROR E0106\n+    //~| expected 2 lifetime parameters\n+}\n+\n fn main() {\n }"}, {"sha": "16ebd3e9ca5f2abfa3d3b4f92a0a28a2e058479d", "filename": "src/test/compile-fail/E0107.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0107.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -18,9 +18,6 @@ enum Bar {\n }\n \n struct Baz<'a, 'b, 'c> {\n-    foo: Foo,\n-    //~^ ERROR E0107\n-    //~| expected 1 lifetime parameter\n     buzz: Buzz<'a>,\n     //~^ ERROR E0107\n     //~| expected 2 lifetime parameters"}, {"sha": "e6251a0d318a35321da6f640bada3adb1528adeb", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -22,10 +22,11 @@ struct SomeStruct<I : for<'x> Foo<&'x isize>> {\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n-    field: <I as Foo<&isize>>::A\n-    //~^ ERROR missing lifetime specifier\n-}\n+// FIXME(eddyb) This one doesn't even compile because of the unsupported syntax.\n+\n+// struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n+//     field: <I as for<'y> Foo<&'y isize>>::A\n+// }\n \n struct YetAnotherStruct<'a, I : for<'x> Foo<&'x isize>> {\n     field: <I as Foo<&'a isize>>::A"}, {"sha": "43371eb6340f434d89aa8b903fe5cf4e463586ef", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -38,4 +38,28 @@ fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n     panic!()\n }\n \n+// Cases which used to work but now don't.\n+\n+type StaticStr = &'static str; // hides 'static\n+trait WithLifetime<'a> {\n+    type Output; // can hide 'a\n+}\n+\n+// This worked because the type of the first argument contains\n+// 'static, although StaticStr doesn't even have parameters.\n+fn j(_x: StaticStr) -> &isize { //~ ERROR missing lifetime specifier\n+//~^ HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n+// This worked because the compiler resolved the argument type\n+// to <T as WithLifetime<'a>>::Output which has the hidden 'a.\n+fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n+//~^ ERROR missing lifetime specifier\n+//~| HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n fn main() {}"}, {"sha": "93635e7fddea781c7b9f065c598abe20ee416f33", "filename": "src/test/compile-fail/rfc1623.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1849daecf0ae8fee54cc32f378809a9531e5ed/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1623.rs?ref=ba1849daecf0ae8fee54cc32f378809a9531e5ed", "patch": "@@ -15,8 +15,10 @@ fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 {\n }\n \n // the boundaries of elision\n-static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 = &(non_elidable as fn(&u8, &u8) -> &u8);\n+static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 =\n //~^ ERROR missing lifetime specifier [E0106]\n+    &(non_elidable as fn(&u8, &u8) -> &u8);\n+    //~^ ERROR missing lifetime specifier [E0106]\n \n struct SomeStruct<'x, 'y, 'z: 'x> {\n     foo: &'x Foo<'z>,"}]}