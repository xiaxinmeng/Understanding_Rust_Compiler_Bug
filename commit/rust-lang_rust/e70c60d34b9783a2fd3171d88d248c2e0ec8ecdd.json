{"sha": "e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "node_id": "C_kwDOAAsO6NoAKGU3MGM2MGQzNGI5NzgzYTJmZDMxNzFkODhkMjQ4YzJlMGVjOGVjZGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T08:02:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T08:02:38Z"}, "message": "Auto merge of #97783 - matthiaskrgr:rollup-14t9htt, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #90905 (Add empty impl blocks if they have documentation)\n - #97683 (Fail gracefully when encountering an HRTB in APIT. )\n - #97721 (Do `suggest_await_before_try` with infer variables in self, and clean up binders)\n - #97752 (typo: `-Zcodegen-backend=llvm -Cpasses=list` should work now)\n - #97759 (Suggest adding `{}` for `'label: non_block_expr`)\n - #97764 (use strict provenance APIs)\n - #97765 (Restore a test that was intended to test `as` cast to ptr)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5408b1ac29becada73eddc0d75196e5b1e66d289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5408b1ac29becada73eddc0d75196e5b1e66d289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "html_url": "https://github.com/rust-lang/rust/commit/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6609c6734de4df43e24d7672f8ae8786ecc8047e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6609c6734de4df43e24d7672f8ae8786ecc8047e", "html_url": "https://github.com/rust-lang/rust/commit/6609c6734de4df43e24d7672f8ae8786ecc8047e"}, {"sha": "1258fa9d9be2811497c03235cd3db60aad6a9763", "url": "https://api.github.com/repos/rust-lang/rust/commits/1258fa9d9be2811497c03235cd3db60aad6a9763", "html_url": "https://github.com/rust-lang/rust/commit/1258fa9d9be2811497c03235cd3db60aad6a9763"}], "stats": {"total": 501, "additions": 419, "deletions": 82}, "files": [{"sha": "1a7972716d3df0faa8368e233ab069fcd9b12a4e", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -1055,13 +1055,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        let backend_name = debug_flags.iter().find_map(|x| {\n-            if x.starts_with(\"codegen-backend=\") {\n-                Some(&x[\"codegen-backends=\".len()..])\n-            } else {\n-                None\n-            }\n-        });\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n         get_codegen_backend(&None, backend_name).print_passes();\n         return None;\n     }"}, {"sha": "83821b5b536c4447e2e3882dd19d2da0df1b8ec6", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -734,7 +734,7 @@ impl<'hir> WherePredicate<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic, PartialEq, Eq)]\n pub enum PredicateOrigin {\n     WhereClause,\n     GenericParam,"}, {"sha": "b786c52e6880f8f926da967871954777ffa92b0a", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -13,10 +13,13 @@ use rustc_ast::tokenstream::Spacing;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n+use rustc_ast::visit::Visitor;\n+use rustc_ast::StmtKind;\n use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp, DUMMY_NODE_ID};\n use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast_pretty::pprust;\n+use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -1548,9 +1551,66 @@ impl<'a> Parser<'a> {\n             Ok(self.mk_expr_err(lo))\n         } else {\n             let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-            self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n+\n+            let mut err = self.struct_span_err(self.token.span, msg);\n+            err.span_label(self.token.span, msg);\n+\n             // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n-            self.parse_expr()\n+            let expr = self.parse_expr().map(|expr| {\n+                let span = expr.span;\n+\n+                let found_labeled_breaks = {\n+                    struct FindLabeledBreaksVisitor(bool);\n+\n+                    impl<'ast> Visitor<'ast> for FindLabeledBreaksVisitor {\n+                        fn visit_expr_post(&mut self, ex: &'ast Expr) {\n+                            if let ExprKind::Break(Some(_label), _) = ex.kind {\n+                                self.0 = true;\n+                            }\n+                        }\n+                    }\n+\n+                    let mut vis = FindLabeledBreaksVisitor(false);\n+                    vis.visit_expr(&expr);\n+                    vis.0\n+                };\n+\n+                // Suggestion involves adding a (as of time of writing this, unstable) labeled block.\n+                //\n+                // If there are no breaks that may use this label, suggest removing the label and\n+                // recover to the unmodified expression.\n+                if !found_labeled_breaks {\n+                    let msg = \"consider removing the label\";\n+                    err.span_suggestion_verbose(\n+                        lo.until(span),\n+                        msg,\n+                        \"\",\n+                        Applicability::MachineApplicable,\n+                    );\n+\n+                    return expr;\n+                }\n+\n+                let sugg_msg = \"consider enclosing expression in a block\";\n+                let suggestions = vec![\n+                    (span.shrink_to_lo(), \"{ \".to_owned()),\n+                    (span.shrink_to_hi(), \" }\".to_owned()),\n+                ];\n+\n+                err.multipart_suggestion_verbose(\n+                    sugg_msg,\n+                    suggestions,\n+                    Applicability::MachineApplicable,\n+                );\n+\n+                // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to supress future errors about `break 'label`.\n+                let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n+                let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n+                self.mk_expr(span, ExprKind::Block(blk, label), ThinVec::new())\n+            });\n+\n+            err.emit();\n+            expr\n         }?;\n \n         if !ate_colon && consume_colon {"}, {"sha": "bfc42902be4ca23bb5b7be05ec421caa0b3debfa", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 64, "deletions": 7, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -207,6 +207,13 @@ enum Scope<'a> {\n         /// In some cases not allowing late bounds allows us to avoid ICEs.\n         /// This is almost ways set to true.\n         allow_late_bound: bool,\n+\n+        /// If this binder comes from a where clause, specify how it was created.\n+        /// This is used to diagnose inaccessible lifetimes in APIT:\n+        /// ```ignore (illustrative)\n+        /// fn foo(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n+        /// ```\n+        where_bound_origin: Option<hir::PredicateOrigin>,\n     },\n \n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n@@ -277,17 +284,19 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 opaque_type_parent,\n                 scope_type,\n                 hir_id,\n-                s: _,\n                 allow_late_bound,\n+                where_bound_origin,\n+                s: _,\n             } => f\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n                 .field(\"next_early_index\", next_early_index)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n-                .field(\"s\", &\"..\")\n                 .field(\"allow_late_bound\", allow_late_bound)\n+                .field(\"where_bound_origin\", where_bound_origin)\n+                .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Body { id, s: _ } => {\n                 f.debug_struct(\"Body\").field(\"id\", id).field(\"s\", &\"..\").finish()\n@@ -638,6 +647,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, move |this| intravisit::walk_fn(this, fk, fd, b, s, hir_id));\n             }\n@@ -753,6 +763,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                     allow_late_bound: false,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -818,6 +829,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n                     // a bare fn has no bounds, so everything\n@@ -1006,6 +1018,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: false,\n+                            where_bound_origin: None,\n                         };\n                         this.with(scope, |this| {\n                             this.visit_generics(generics);\n@@ -1026,6 +1039,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         opaque_type_parent: false,\n                         scope_type: BinderScopeType::Normal,\n                         allow_late_bound: false,\n+                        where_bound_origin: None,\n                     };\n                     self.with(scope, |this| {\n                         let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1084,6 +1098,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: false,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1151,6 +1166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     allow_late_bound: true,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n                     let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1266,6 +1282,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         ref bounded_ty,\n                         bounds,\n                         ref bound_generic_params,\n+                        origin,\n                         ..\n                     }) => {\n                         let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n@@ -1296,6 +1313,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             allow_late_bound: true,\n+                            where_bound_origin: Some(origin),\n                         };\n                         this.with(scope, |this| {\n                             this.visit_ty(&bounded_ty);\n@@ -1368,6 +1386,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     opaque_type_parent: false,\n                     scope_type,\n                     allow_late_bound: true,\n+                    where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n                     intravisit::walk_param_bound(this, bound);\n@@ -1420,6 +1439,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             opaque_type_parent: false,\n             scope_type,\n             allow_late_bound: true,\n+            where_bound_origin: None,\n         };\n         self.with(scope, |this| {\n             walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n@@ -1680,6 +1700,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n             allow_late_bound: true,\n+            where_bound_origin: None,\n         };\n         self.with(scope, walk);\n     }\n@@ -1783,12 +1804,48 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             self.insert_lifetime(lifetime_ref, def);\n-        } else {\n-            self.tcx.sess.delay_span_bug(\n-                lifetime_ref.span,\n-                &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n-            );\n+            return;\n         }\n+\n+        // We may fail to resolve higher-ranked lifetimes that are mentionned by APIT.\n+        // AST-based resolution does not care for impl-trait desugaring, which are the\n+        // responibility of lowering.  This may create a mismatch between the resolution\n+        // AST found (`region_def_id`) which points to HRTB, and what HIR allows.\n+        // ```\n+        // fn foo(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n+        // ```\n+        //\n+        // In such case, walk back the binders to diagnose it properly.\n+        let mut scope = self.scope;\n+        loop {\n+            match *scope {\n+                Scope::Binder {\n+                    where_bound_origin: Some(hir::PredicateOrigin::ImplTrait), ..\n+                } => {\n+                    let mut err = self.tcx.sess.struct_span_err(\n+                        lifetime_ref.span,\n+                        \"`impl Trait` can only mention lifetimes bound at the fn or impl level\",\n+                    );\n+                    err.span_note(self.tcx.def_span(region_def_id), \"lifetime declared here\");\n+                    err.emit();\n+                    return;\n+                }\n+                Scope::Root => break,\n+                Scope::Binder { s, .. }\n+                | Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.delay_span_bug(\n+            lifetime_ref.span,\n+            &format!(\"Could not resolve {:?} in scope {:#?}\", lifetime_ref, self.scope,),\n+        );\n     }\n \n     fn visit_segment_args("}, {"sha": "185f500808f2725e33e2a0607238aa483f993fc1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -5,7 +5,7 @@ use super::{\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n-use crate::traits::normalize_projection_type;\n+use crate::traits::normalize_to;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -2706,55 +2706,43 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n \n                 let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n-\n-                // Do not check on infer_types to avoid panic in evaluate_obligation.\n-                if self_ty.has_infer_types() {\n-                    return;\n-                }\n-                let self_ty = self.tcx.erase_regions(self_ty);\n-\n                 let impls_future = self.type_implements_trait(\n                     future_trait,\n-                    self_ty.skip_binder(),\n+                    self.tcx.erase_late_bound_regions(self_ty),\n                     ty::List::empty(),\n                     obligation.param_env,\n                 );\n+                if !impls_future.must_apply_modulo_regions() {\n+                    return;\n+                }\n \n                 let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n                 // `<T as Future>::Output`\n-                let projection_ty = ty::ProjectionTy {\n-                    // `T`\n-                    substs: self.tcx.mk_substs_trait(\n-                        trait_pred.self_ty().skip_binder(),\n-                        &self.fresh_substs_for_item(span, item_def_id)[1..],\n-                    ),\n-                    // `Future::Output`\n-                    item_def_id,\n-                };\n-\n-                let mut selcx = SelectionContext::new(self);\n-\n-                let mut obligations = vec![];\n-                let normalized_ty = normalize_projection_type(\n-                    &mut selcx,\n+                let projection_ty = trait_pred.map_bound(|trait_pred| {\n+                    self.tcx.mk_projection(\n+                        item_def_id,\n+                        // Future::Output has no substs\n+                        self.tcx.mk_substs_trait(trait_pred.self_ty(), &[]),\n+                    )\n+                });\n+                let projection_ty = normalize_to(\n+                    &mut SelectionContext::new(self),\n                     obligation.param_env,\n-                    projection_ty,\n                     obligation.cause.clone(),\n-                    0,\n-                    &mut obligations,\n+                    projection_ty,\n+                    &mut vec![],\n                 );\n \n                 debug!(\n                     \"suggest_await_before_try: normalized_projection_type {:?}\",\n-                    self.resolve_vars_if_possible(normalized_ty)\n+                    self.resolve_vars_if_possible(projection_ty)\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred.map_bound(|trait_pred| (trait_pred, normalized_ty.ty().unwrap())),\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, projection_ty.skip_binder())),\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)\n-                    && impls_future.must_apply_modulo_regions()\n                     && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n                     && snippet.ends_with('?')\n                 {"}, {"sha": "a3b4e5886ef68a656911180a9ecdd6b7f9a9fcc8", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -532,7 +532,7 @@ pub const fn null<T>() -> *const T {\n #[rustc_diagnostic_item = \"ptr_null\"]\n #[cfg(not(bootstrap))]\n pub const fn null<T: ?Sized + Thin>() -> *const T {\n-    from_raw_parts(0 as *const (), ())\n+    from_raw_parts(invalid(0), ())\n }\n \n /// Creates a null mutable raw pointer.\n@@ -709,7 +709,7 @@ where\n #[rustc_diagnostic_item = \"ptr_null_mut\"]\n #[cfg(not(bootstrap))]\n pub const fn null_mut<T: ?Sized + Thin>() -> *mut T {\n-    from_raw_parts_mut(0 as *mut (), ())\n+    from_raw_parts_mut(invalid_mut(0), ())\n }\n \n /// Forms a raw slice from a pointer and a length."}, {"sha": "f762e38900552748b2d1409001008e960a2a3d18", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -94,6 +94,10 @@\n   in the specified file. The number of occurrences must match the given\n   count.\n \n+* `@count PATH XPATH TEXT COUNT` checks for the occurrence of the given XPath\n+  with the given text in the specified file. The number of occurrences must\n+  match the given count.\n+\n * `@snapshot NAME PATH XPATH` creates a snapshot test named NAME.\n   A snapshot test captures a subtree of the DOM, at the location\n   determined by the XPath, and compares it to a pre-recorded value\n@@ -382,23 +386,25 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n     return ret\n \n \n-def check_tree_text(tree, path, pat, regexp):\n+# Returns the number of occurences matching the regex (`regexp`) and the text (`pat`).\n+def check_tree_text(tree, path, pat, regexp, stop_at_first):\n     path = normalize_xpath(path)\n-    ret = False\n+    match_count = 0\n     try:\n         for e in tree.findall(path):\n             try:\n                 value = flatten(e)\n             except KeyError:\n                 continue\n             else:\n-                ret = check_string(value, pat, regexp)\n-                if ret:\n-                    break\n+                if check_string(value, pat, regexp):\n+                    match_count += 1\n+                    if stop_at_first:\n+                        break\n     except Exception:\n         print('Failed to get path \"{}\"'.format(path))\n         raise\n-    return ret\n+    return match_count\n \n \n def get_tree_count(tree, path):\n@@ -518,6 +524,19 @@ def print_err(lineno, context, err, message=None):\n         stderr(\"\\t{}\".format(context))\n \n \n+def get_nb_matching_elements(cache, c, regexp, stop_at_first):\n+    tree = cache.get_tree(c.args[0])\n+    pat, sep, attr = c.args[1].partition('/@')\n+    if sep:  # attribute\n+        tree = cache.get_tree(c.args[0])\n+        return check_tree_attr(tree, pat, attr, c.args[2], False)\n+    else:  # normalized text\n+        pat = c.args[1]\n+        if pat.endswith('/text()'):\n+            pat = pat[:-7]\n+        return check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp, stop_at_first)\n+\n+\n ERR_COUNT = 0\n \n \n@@ -538,16 +557,7 @@ def check_command(c, cache):\n                 ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n             elif len(c.args) == 3:  # @has/matches <path> <pat> <match> = XML tree test\n                 cerr = \"`XPATH PATTERN` did not match\"\n-                tree = cache.get_tree(c.args[0])\n-                pat, sep, attr = c.args[1].partition('/@')\n-                if sep:  # attribute\n-                    tree = cache.get_tree(c.args[0])\n-                    ret = check_tree_attr(tree, pat, attr, c.args[2], regexp)\n-                else:  # normalized text\n-                    pat = c.args[1]\n-                    if pat.endswith('/text()'):\n-                        pat = pat[:-7]\n-                    ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n+                ret = get_nb_matching_elements(cache, c, regexp, True) != 0\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n \n@@ -557,6 +567,11 @@ def check_command(c, cache):\n                 found = get_tree_count(cache.get_tree(c.args[0]), c.args[1])\n                 cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n                 ret = expected == found\n+            elif len(c.args) == 4:  # @count <path> <pat> <text> <count> = count test\n+                expected = int(c.args[3])\n+                found = get_nb_matching_elements(cache, c, False, False)\n+                cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n+                ret = found == expected\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n "}, {"sha": "cb887d16906a141406bebd16b542c678addd8f57", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -1600,6 +1600,13 @@ fn render_impl(\n         }\n \n         if let Some(ref dox) = i.impl_item.collapsed_doc_value() {\n+            if trait_.is_none() && i.inner_impl().items.is_empty() {\n+                w.write_str(\n+                    \"<div class=\\\"item-info\\\">\\\n+                    <div class=\\\"stab empty-impl\\\">This impl block contains no items.</div>\n+                </div>\",\n+                );\n+            }\n             write!(\n                 w,\n                 \"<div class=\\\"docblock\\\">{}</div>\","}, {"sha": "8e0521d9ad6a14acf42e2f7b6b08b0ffb895057d", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -281,9 +281,13 @@ details.undocumented > summary::before {\n \tcolor: #000;\n }\n \n+/* Created this empty rule to satisfy the theme checks. */\n+.stab.empty-impl {}\n+\n .stab.unstable,\n .stab.deprecated,\n-.stab.portability {\n+.stab.portability,\n+.stab.empty-impl {\n \tcolor: #c5c5c5;\n \tbackground: #314559 !important;\n \tborder-style: none !important;"}, {"sha": "071ad006ed3501aacbda80fe1028d561f8a87b8d", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -266,6 +266,7 @@ details.undocumented > summary::before {\n \tcolor: #ddd;\n }\n \n+.stab.empty-impl { background: #FFF5D6; border-color: #FFC600; color: #2f2f2f; }\n .stab.unstable { background: #FFF5D6; border-color: #FFC600; color: #2f2f2f; }\n .stab.deprecated { background: #ffc4c4; border-color: #db7b7b; color: #2f2f2f; }\n .stab.portability { background: #F3DFFF; border-color: #b07bdb; color: #2f2f2f; }"}, {"sha": "5c3789bf4630a46a08b813d99596067d861d86c7", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -255,6 +255,7 @@ details.undocumented > summary::before {\n \tcolor: #000;\n }\n \n+.stab.empty-impl { background: #FFF5D6; border-color: #FFC600; }\n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n .stab.deprecated { background: #ffc4c4; border-color: #db7b7b; }\n .stab.portability { background: #F3DFFF; border-color: #b07bdb; }"}, {"sha": "0fd124e61541581f4d630cafaf23a560e59ffe7b", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -124,8 +124,9 @@ pub(crate) struct ImplStripper<'a> {\n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n+            // Impl blocks can be skipped if they are: empty; not a trait impl; and have no\n+            // documentation.\n+            if imp.trait_.is_none() && imp.items.is_empty() && i.doc_value().is_none() {\n                 return None;\n             }\n             if let Some(did) = imp.for_.def_id(self.cache) {"}, {"sha": "6a2a254f63a7fd09a9d5d8369375cb80697ec1a2", "filename": "src/test/rustdoc/empty-impl-block.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fempty-impl-block.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Foo.html'\n+pub struct Foo;\n+\n+// @has - '//*[@class=\"docblock\"]' 'Hello empty impl block!'\n+// @has - '//*[@class=\"item-info\"]' 'This impl block contains no items.'\n+/// Hello empty impl block!\n+impl Foo {}\n+// We ensure that this empty impl block without doc isn't rendered.\n+// @count - '//*[@class=\"impl has-srclink\"]' 'impl Foo' 1\n+impl Foo {}\n+\n+// Just to ensure that empty trait impl blocks are rendered.\n+pub struct Another;\n+pub trait Bar {}\n+\n+// @has 'foo/struct.Another.html'\n+// @has - '//h3[@class=\"code-header in-band\"]' 'impl Bar for Another'\n+impl Bar for Another {}"}, {"sha": "50aa1a856a7161fc576bdce44120f92cf9a7a50c", "filename": "src/test/ui/cast/casts-issue-46365.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fcast%2Fcasts-issue-46365.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fcast%2Fcasts-issue-46365.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-issue-46365.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -3,5 +3,6 @@ struct Lorem {\n }\n \n fn main() {\n-    let _foo: *mut Lorem = core::ptr::NonNull::dangling().as_ptr(); // no error here\n+    // Testing `as` casts, so deliberately not using `ptr::null`.\n+    let _foo: *mut Lorem = 0 as *mut _; // no error here\n }"}, {"sha": "b9551c2ceb0e52bc0ce0d01c70c6e3092fc798d3", "filename": "src/test/ui/impl-trait/universal_wrong_hrtb.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,8 @@\n+trait Trait<'a> {\n+    type Assoc;\n+}\n+\n+fn test_argument_position(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n+//~^ ERROR `impl Trait` can only mention lifetimes bound at the fn or impl level\n+\n+fn main() {}"}, {"sha": "37eb8dfa1a1415260884c5c386828cb704ede398", "filename": "src/test/ui/impl-trait/universal_wrong_hrtb.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_hrtb.stderr?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,14 @@\n+error: `impl Trait` can only mention lifetimes bound at the fn or impl level\n+  --> $DIR/universal_wrong_hrtb.rs:5:73\n+   |\n+LL | fn test_argument_position(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n+   |                                                                         ^^\n+   |\n+note: lifetime declared here\n+  --> $DIR/universal_wrong_hrtb.rs:5:39\n+   |\n+LL | fn test_argument_position(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n+   |                                       ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5c9597c440cbdefe98bc5c1af9cd3064ae7f2aa0", "filename": "src/test/ui/parser/labeled-no-colon-expr.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flabeled-no-colon-expr.stderr?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -47,6 +47,12 @@ error: expected `while`, `for`, `loop` or `{` after a label\n    |\n LL |     'l4 0;\n    |         ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider removing the label\n+   |\n+LL -     'l4 0;\n+LL +     0;\n+   | \n \n error: labeled expression must be followed by `:`\n   --> $DIR/labeled-no-colon-expr.rs:8:9"}, {"sha": "fe546a71971176cb1addee19aa68d4bcdc670e86", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.fixed", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.fixed?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,27 @@\n+// run-rustfix\n+#![feature(label_break_value)]\n+fn main() {\n+    let _ = 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+\n+    match () { () => {}, }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    'label: { match () { () => break 'label, } }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    #[allow(unused_labels)]\n+    'label: { match () { () => 'lp: loop { break 'lp 0 }, } }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+\n+    let x = 1;\n+    let _i = 'label: { match x { //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+        0 => 42,\n+        1 if false => break 'label 17,\n+        1 => {\n+            if true {\n+                break 'label 13\n+            } else {\n+                break 'label 0;\n+            }\n+        }\n+        _ => 1,\n+    } };\n+\n+    let other = 3;\n+    let _val = 'label: { (1, if other == 3 { break 'label (2, 3) } else { other }) }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+}"}, {"sha": "35862e2eef9736bf4c7e262ad7077c536dcb08c3", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -1,5 +1,27 @@\n+// run-rustfix\n+#![feature(label_break_value)]\n fn main() {\n-    'label: 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    let _ = 'label: 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n \n-    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+    'label: match () { () => {}, }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    'label: match () { () => break 'label, }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+    #[allow(unused_labels)]\n+    'label: match () { () => 'lp: loop { break 'lp 0 }, }; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+\n+    let x = 1;\n+    let _i = 'label: match x { //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+        0 => 42,\n+        1 if false => break 'label 17,\n+        1 => {\n+            if true {\n+                break 'label 13\n+            } else {\n+                break 'label 0;\n+            }\n+        }\n+        _ => 1,\n+    };\n+\n+    let other = 3;\n+    let _val = 'label: (1, if other == 3 { break 'label (2, 3) } else { other }); //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n }"}, {"sha": "767389c48088a7c76f1b9327ada80a05bdf0f5e2", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.stderr", "status": "modified", "additions": 69, "deletions": 11, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -1,17 +1,75 @@\n error: expected `while`, `for`, `loop` or `{` after a label\n-  --> $DIR/recover-labeled-non-block-expr.rs:2:13\n+  --> $DIR/recover-labeled-non-block-expr.rs:4:21\n    |\n-LL |     'label: 1 + 1;\n-   |             ^ expected `while`, `for`, `loop` or `{` after a label\n+LL |     let _ = 'label: 1 + 1;\n+   |                     ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider removing the label\n+   |\n+LL -     let _ = 'label: 1 + 1;\n+LL +     let _ = 1 + 1;\n+   | \n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:6:13\n+   |\n+LL |     'label: match () { () => {}, };\n+   |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider removing the label\n+   |\n+LL -     'label: match () { () => {}, };\n+LL +     match () { () => {}, };\n+   | \n \n-error[E0308]: mismatched types\n-  --> $DIR/recover-labeled-non-block-expr.rs:4:33\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:7:13\n+   |\n+LL |     'label: match () { () => break 'label, };\n+   |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider enclosing expression in a block\n+   |\n+LL |     'label: { match () { () => break 'label, } };\n+   |             +                                  +\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:9:13\n+   |\n+LL |     'label: match () { () => 'lp: loop { break 'lp 0 }, };\n+   |             ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider enclosing expression in a block\n+   |\n+LL |     'label: { match () { () => 'lp: loop { break 'lp 0 }, } };\n+   |             +                                               +\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:12:22\n+   |\n+LL |     let _i = 'label: match x {\n+   |                      ^^^^^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider enclosing expression in a block\n+   |\n+LL ~     let _i = 'label: { match x {\n+LL |         0 => 42,\n+LL |         1 if false => break 'label 17,\n+LL |         1 => {\n+LL |             if true {\n+LL |                 break 'label 13\n+ ...\n+\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:26:24\n+   |\n+LL |     let _val = 'label: (1, if other == 3 { break 'label (2, 3) } else { other });\n+   |                        ^ expected `while`, `for`, `loop` or `{` after a label\n+   |\n+help: consider enclosing expression in a block\n    |\n-LL |     let _recovery_witness: () = 0;\n-   |                            --   ^ expected `()`, found integer\n-   |                            |\n-   |                            expected due to this\n+LL |     let _val = 'label: { (1, if other == 3 { break 'label (2, 3) } else { other }) };\n+   |                        +                                                           +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c42bdfff5f9e6723a2ba4d3a569bf861fb1cd11b", "filename": "src/test/ui/suggestions/issue-97704.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.fixed?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,19 @@\n+// edition:2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+async fn foo() -> Result<(), i32> {\n+    func(async { Ok::<_, i32>(()) }).await?;\n+    //~^ ERROR the `?` operator can only be applied to values that implement `Try`\n+\n+    Ok(())\n+}\n+\n+async fn func<T>(fut: impl Future<Output = T>) -> T {\n+    fut.await\n+}\n+\n+fn main() {}"}, {"sha": "5dfee6cac60973cb5849ea96677c148653aff615", "filename": "src/test/ui/suggestions/issue-97704.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.rs?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,19 @@\n+// edition:2021\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use std::future::Future;\n+\n+async fn foo() -> Result<(), i32> {\n+    func(async { Ok::<_, i32>(()) })?;\n+    //~^ ERROR the `?` operator can only be applied to values that implement `Try`\n+\n+    Ok(())\n+}\n+\n+async fn func<T>(fut: impl Future<Output = T>) -> T {\n+    fut.await\n+}\n+\n+fn main() {}"}, {"sha": "ca017be45ac47b0345d93d2510198cbb3ca210a0", "filename": "src/test/ui/suggestions/issue-97704.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97704.stderr?ref=e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the `?` operator can only be applied to values that implement `Try`\n+  --> $DIR/issue-97704.rs:9:5\n+   |\n+LL |     func(async { Ok::<_, i32>(()) })?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl Future<Output = Result<(), i32>>`\n+   |\n+   = help: the trait `Try` is not implemented for `impl Future<Output = Result<(), i32>>`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     func(async { Ok::<_, i32>(()) }).await?;\n+   |                                     ++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}