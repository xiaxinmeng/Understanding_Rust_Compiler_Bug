{"sha": "063bbc485eca78d734b4987688b9277b2bc0bc6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2M2JiYzQ4NWVjYTc4ZDczNGI0OTg3Njg4YjkyNzdiMmJjMGJjNmU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-14T14:39:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T14:39:04Z"}, "message": "Rollup merge of #74220 - lzutao:windows-path-com, r=LukasKalbertodt\n\nRefactor Windows `parse_prefix`\n\nThese changes make me feel more readable.\nSee the commit messages for more details.", "tree": {"sha": "2fbfb5dab244787b16bd10a729c6ea9b223896ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fbfb5dab244787b16bd10a729c6ea9b223896ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/063bbc485eca78d734b4987688b9277b2bc0bc6e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDcOJCRBK7hj4Ov3rIwAAdHIIAAEIGJ5v7+4IR19pgXCcp4ke\nR06+i66ESktaTJIIv1Gir9Y4QhlOtPR1TVQsRVYtzUPRZLXjFbCgDD6mq7XPHcBO\nT5JXPDEzLLjpf7zhOJ2Y21Vo/qhSfLnLmgo5gmUk7GrGtUMyHF5YhzQjVPIg0o+M\nxOc0ZPHvCu2MzY1jZUHXDzgTECTlsmSnDcTcprcnTGPHYsB2nq5DOw8+e5pTrDZe\nj0istMFBSLnYX4QMIBsx1YW3zqZ06mHmHlU+AoNu5mOtiQjx+W8h3zw23i9zoHQO\nnNfWKJOzjYjtqlNEfabh3OC2vZ+nh5aNhm1pE4T1tYZDD97yKUvElVh7kyEZsFQ=\n=VmkE\n-----END PGP SIGNATURE-----\n", "payload": "tree 2fbfb5dab244787b16bd10a729c6ea9b223896ec\nparent b9a0f5803ecd6dfd66dcd921e31d26a57faa8aad\nparent e31898b02409b8ce5db32761d45c78f9f74dbdc6\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594737544 -0700\ncommitter GitHub <noreply@github.com> 1594737544 -0700\n\nRollup merge of #74220 - lzutao:windows-path-com, r=LukasKalbertodt\n\nRefactor Windows `parse_prefix`\n\nThese changes make me feel more readable.\nSee the commit messages for more details.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/063bbc485eca78d734b4987688b9277b2bc0bc6e", "html_url": "https://github.com/rust-lang/rust/commit/063bbc485eca78d734b4987688b9277b2bc0bc6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/063bbc485eca78d734b4987688b9277b2bc0bc6e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9a0f5803ecd6dfd66dcd921e31d26a57faa8aad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a0f5803ecd6dfd66dcd921e31d26a57faa8aad", "html_url": "https://github.com/rust-lang/rust/commit/b9a0f5803ecd6dfd66dcd921e31d26a57faa8aad"}, {"sha": "e31898b02409b8ce5db32761d45c78f9f74dbdc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e31898b02409b8ce5db32761d45c78f9f74dbdc6", "html_url": "https://github.com/rust-lang/rust/commit/e31898b02409b8ce5db32761d45c78f9f74dbdc6"}], "stats": {"total": 172, "additions": 103, "deletions": 69}, "files": [{"sha": "5215db7cdb3ce8d43217ab583443560f0fdde99e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=063bbc485eca78d734b4987688b9277b2bc0bc6e", "patch": "@@ -242,8 +242,8 @@\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n-#![feature(cfg_accessible)]\n #![feature(can_vector)]\n+#![feature(cfg_accessible)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]\n@@ -276,8 +276,8 @@\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(int_error_matching)]\n-#![feature(into_future)]\n #![feature(integer_atomics)]\n+#![feature(into_future)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(link_args)]\n@@ -286,6 +286,7 @@\n #![feature(log_syntax)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n+#![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n@@ -305,7 +306,7 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n-#![feature(min_specialization)]\n+#![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}, {"sha": "dda3ed68cfc95aac651c2d65f27ecf6abf77a68f", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=063bbc485eca78d734b4987688b9277b2bc0bc6e", "patch": "@@ -2,6 +2,16 @@ use crate::ffi::OsStr;\n use crate::mem;\n use crate::path::Prefix;\n \n+#[cfg(test)]\n+mod tests;\n+\n+pub const MAIN_SEP_STR: &str = \"\\\\\";\n+pub const MAIN_SEP: char = '\\\\';\n+\n+// The unsafety here stems from converting between `&OsStr` and `&[u8]`\n+// and back. This is safe to do because (1) we only look at ASCII\n+// contents of the encoding and (2) new &OsStr values are produced\n+// only from ASCII-bounded slices of existing &OsStr values.\n fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { mem::transmute(s) }\n }\n@@ -19,76 +29,79 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'\\\\'\n }\n \n+// In most DOS systems, it is not possible to have more than 26 drive letters.\n+// See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n+pub fn is_valid_drive_letter(disk: u8) -> bool {\n+    disk.is_ascii_alphabetic()\n+}\n+\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n-    use crate::path::Prefix::*;\n-    unsafe {\n-        // The unsafety here stems from converting between &OsStr and &[u8]\n-        // and back. This is safe to do because (1) we only look at ASCII\n-        // contents of the encoding and (2) new &OsStr values are produced\n-        // only from ASCII-bounded slices of existing &OsStr values.\n-        let mut path = os_str_as_u8_slice(path);\n+    use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n+\n+    let path = os_str_as_u8_slice(path);\n \n-        if path.starts_with(br\"\\\\\") {\n-            // \\\\\n-            path = &path[2..];\n-            if path.starts_with(br\"?\\\") {\n-                // \\\\?\\\n-                path = &path[2..];\n-                if path.starts_with(br\"UNC\\\") {\n-                    // \\\\?\\UNC\\server\\share\n-                    path = &path[4..];\n-                    let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                        Some((server, share)) => {\n-                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n-                        }\n-                        None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n-                    };\n-                    return Some(VerbatimUNC(server, share));\n-                } else {\n-                    // \\\\?\\path\n-                    let idx = path.iter().position(|&b| b == b'\\\\');\n-                    if idx == Some(2) && path[1] == b':' {\n-                        let c = path[0];\n-                        if c.is_ascii() && (c as char).is_alphabetic() {\n-                            // \\\\?\\C:\\ path\n-                            return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                        }\n+    // \\\\\n+    if let Some(path) = path.strip_prefix(br\"\\\\\") {\n+        // \\\\?\\\n+        if let Some(path) = path.strip_prefix(br\"?\\\") {\n+            // \\\\?\\UNC\\server\\share\n+            if let Some(path) = path.strip_prefix(br\"UNC\\\") {\n+                let (server, share) = match get_first_two_components(path, is_verbatim_sep) {\n+                    Some((server, share)) => unsafe {\n+                        (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n+                    },\n+                    None => (unsafe { u8_slice_as_os_str(path) }, OsStr::new(\"\")),\n+                };\n+                return Some(VerbatimUNC(server, share));\n+            } else {\n+                // \\\\?\\path\n+                match path {\n+                    // \\\\?\\C:\\path\n+                    [c, b':', b'\\\\', ..] if is_valid_drive_letter(*c) => {\n+                        return Some(VerbatimDisk(c.to_ascii_uppercase()));\n+                    }\n+                    // \\\\?\\cat_pics\n+                    _ => {\n+                        let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+                        let slice = &path[..idx];\n+                        return Some(Verbatim(unsafe { u8_slice_as_os_str(slice) }));\n                     }\n-                    let slice = &path[..idx.unwrap_or(path.len())];\n-                    return Some(Verbatim(u8_slice_as_os_str(slice)));\n-                }\n-            } else if path.starts_with(b\".\\\\\") {\n-                // \\\\.\\path\n-                path = &path[2..];\n-                let pos = path.iter().position(|&b| b == b'\\\\');\n-                let slice = &path[..pos.unwrap_or(path.len())];\n-                return Some(DeviceNS(u8_slice_as_os_str(slice)));\n-            }\n-            match parse_two_comps(path, is_sep_byte) {\n-                Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n-                    // \\\\server\\share\n-                    return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n                 }\n-                _ => (),\n             }\n-        } else if path.get(1) == Some(&b':') {\n-            // C:\n-            let c = path[0];\n-            if c.is_ascii() && (c as char).is_alphabetic() {\n-                return Some(Disk(c.to_ascii_uppercase()));\n+        } else if let Some(path) = path.strip_prefix(b\".\\\\\") {\n+            // \\\\.\\COM42\n+            let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+            let slice = &path[..idx];\n+            return Some(DeviceNS(unsafe { u8_slice_as_os_str(slice) }));\n+        }\n+        match get_first_two_components(path, is_sep_byte) {\n+            Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+                // \\\\server\\share\n+                return Some(unsafe { UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)) });\n             }\n+            _ => {}\n+        }\n+    } else if let [c, b':', ..] = path {\n+        // C:\n+        if is_valid_drive_letter(*c) {\n+            return Some(Disk(c.to_ascii_uppercase()));\n         }\n-        return None;\n-    }\n-\n-    fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n-        let first = &path[..path.iter().position(|x| f(*x))?];\n-        path = &path[(first.len() + 1)..];\n-        let idx = path.iter().position(|x| f(*x));\n-        let second = &path[..idx.unwrap_or(path.len())];\n-        Some((first, second))\n     }\n+    None\n }\n \n-pub const MAIN_SEP_STR: &str = \"\\\\\";\n-pub const MAIN_SEP: char = '\\\\';\n+/// Returns the first two path components with predicate `f`.\n+///\n+/// The two components returned will be use by caller\n+/// to construct `VerbatimUNC` or `UNC` Windows path prefix.\n+///\n+/// Returns [`None`] if there are no separators in path.\n+fn get_first_two_components(path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+    let idx = path.iter().position(|&x| f(x))?;\n+    // Panic safe\n+    // The max `idx+1` is `path.len()` and `path[path.len()..]` is a valid index.\n+    let (first, path) = (&path[..idx], &path[idx + 1..]);\n+    let idx = path.iter().position(|&x| f(x)).unwrap_or(path.len());\n+    let second = &path[..idx];\n+    Some((first, second))\n+}"}, {"sha": "fbac1dc1ca17a017091e27a6bd082e11181a0729", "filename": "src/libstd/sys/windows/path/tests.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=063bbc485eca78d734b4987688b9277b2bc0bc6e", "patch": "@@ -0,0 +1,21 @@\n+use super::*;\n+\n+#[test]\n+fn test_get_first_two_components() {\n+    assert_eq!(\n+        get_first_two_components(br\"server\\share\", is_verbatim_sep),\n+        Some((&b\"server\"[..], &b\"share\"[..])),\n+    );\n+\n+    assert_eq!(\n+        get_first_two_components(br\"server\\\", is_verbatim_sep),\n+        Some((&b\"server\"[..], &b\"\"[..]))\n+    );\n+\n+    assert_eq!(\n+        get_first_two_components(br\"\\server\\\", is_verbatim_sep),\n+        Some((&b\"\"[..], &b\"server\"[..]))\n+    );\n+\n+    assert_eq!(get_first_two_components(br\"there are no separators here\", is_verbatim_sep), None,);\n+}"}, {"sha": "d354a9b1842c21c9eee5eb8c76efbfe287c1bcd5", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063bbc485eca78d734b4987688b9277b2bc0bc6e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=063bbc485eca78d734b4987688b9277b2bc0bc6e", "patch": "@@ -641,9 +641,8 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn current() -> Thread {\n     thread_info::current_thread().expect(\n-        \"use of std::thread::current() is not \\\n-                                          possible after the thread's local \\\n-                                          data has been destroyed\",\n+        \"use of std::thread::current() is not possible \\\n+         after the thread's local data has been destroyed\",\n     )\n }\n "}]}