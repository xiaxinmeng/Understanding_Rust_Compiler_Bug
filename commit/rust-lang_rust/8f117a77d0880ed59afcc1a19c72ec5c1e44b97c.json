{"sha": "8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "node_id": "C_kwDOAAsO6NoAKDhmMTE3YTc3ZDA4ODBlZDU5YWZjYzFhMTljNzJlYzVjMWU0NGI5N2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T20:12:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T20:12:35Z"}, "message": "Auto merge of #91865 - matthiaskrgr:rollup-rai9ecq, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #91699 (Add `-webkit-appearance: none` to search input)\n - #91846 (rustdoc: Reduce number of arguments for `run_test` a bit)\n - #91847 (Fix FIXME for `generic_arg_infer` in `create_substs_for_ast_path`)\n - #91849 (GATs outlives lint: Try to prove bounds)\n - #91855 (Stabilize const_cstr_unchecked)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c1df0a20824dcb0936f0a52051c2129e2d0e96c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1df0a20824dcb0936f0a52051c2129e2d0e96c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "html_url": "https://github.com/rust-lang/rust/commit/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1796de7bb123df3f3d32124ededf1344434f672e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1796de7bb123df3f3d32124ededf1344434f672e", "html_url": "https://github.com/rust-lang/rust/commit/1796de7bb123df3f3d32124ededf1344434f672e"}, {"sha": "ff214b745de20917b398510e78e7aba5afba9a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff214b745de20917b398510e78e7aba5afba9a72", "html_url": "https://github.com/rust-lang/rust/commit/ff214b745de20917b398510e78e7aba5afba9a72"}], "stats": {"total": 477, "additions": 300, "deletions": 177}, "files": [{"sha": "1dfaae7a1504f1143fbc96b6374aa0054f4e3d42", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -6,7 +6,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n-#![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]"}, {"sha": "e93cdf7942118033c722eb3e2b34976730a769ff", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n-pub struct RegionRelations<'a, 'tcx> {\n+pub(crate) struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The context used for debug messages"}, {"sha": "a5ec84a4f14469591e8fe8fc07b616d1a65cdf63", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -28,7 +28,7 @@ use std::fmt;\n /// assuming such values can be found. It returns the final values of\n /// all the variables as well as a set of errors that must be reported.\n #[instrument(level = \"debug\", skip(region_rels, var_infos, data))]\n-pub fn resolve<'tcx>(\n+pub(crate) fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,"}, {"sha": "aad8dd2119f2fa933430755c8988c7a727bb7629", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -414,34 +414,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 arg: &GenericArg<'_>,\n             ) -> subst::GenericArg<'tcx> {\n                 let tcx = self.astconv.tcx();\n+\n+                let mut handle_ty_args = |has_default, ty: &hir::Ty<'_>| {\n+                    if has_default {\n+                        tcx.check_optional_stability(\n+                            param.def_id,\n+                            Some(arg.id()),\n+                            arg.span(),\n+                            None,\n+                            |_, _| {\n+                                // Default generic parameters may not be marked\n+                                // with stability attributes, i.e. when the\n+                                // default parameter was defined at the same time\n+                                // as the rest of the type. As such, we ignore missing\n+                                // stability attributes.\n+                            },\n+                        )\n+                    }\n+                    if let (hir::TyKind::Infer, false) = (&ty.kind, self.astconv.allow_ty_infer()) {\n+                        self.inferred_params.push(ty.span);\n+                        tcx.ty_error().into()\n+                    } else {\n+                        self.astconv.ast_ty_to_ty(ty).into()\n+                    }\n+                };\n+\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n                         self.astconv.ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (&GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n-                        if has_default {\n-                            tcx.check_optional_stability(\n-                                param.def_id,\n-                                Some(arg.id()),\n-                                arg.span(),\n-                                None,\n-                                |_, _| {\n-                                    // Default generic parameters may not be marked\n-                                    // with stability attributes, i.e. when the\n-                                    // default parameter was defined at the same time\n-                                    // as the rest of the type. As such, we ignore missing\n-                                    // stability attributes.\n-                                },\n-                            )\n-                        }\n-                        if let (hir::TyKind::Infer, false) =\n-                            (&ty.kind, self.astconv.allow_ty_infer())\n-                        {\n-                            self.inferred_params.push(ty.span);\n-                            tcx.ty_error().into()\n-                        } else {\n-                            self.astconv.ast_ty_to_ty(ty).into()\n-                        }\n+                        handle_ty_args(has_default, ty)\n+                    }\n+                    (&GenericParamDefKind::Type { has_default, .. }, GenericArg::Infer(inf)) => {\n+                        handle_ty_args(has_default, &inf.to_ty())\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         ty::Const::from_opt_const_arg_anon_const(\n@@ -453,41 +459,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         )\n                         .into()\n                     }\n-                    (&GenericParamDefKind::Const { has_default }, hir::GenericArg::Infer(inf)) => {\n-                        if has_default {\n-                            tcx.const_param_default(param.def_id).into()\n-                        } else if self.astconv.allow_ty_infer() {\n-                            // FIXME(const_generics): Actually infer parameter here?\n-                            todo!()\n-                        } else {\n-                            self.inferred_params.push(inf.span);\n-                            tcx.ty_error().into()\n-                        }\n-                    }\n-                    (\n-                        &GenericParamDefKind::Type { has_default, .. },\n-                        hir::GenericArg::Infer(inf),\n-                    ) => {\n-                        if has_default {\n-                            tcx.check_optional_stability(\n-                                param.def_id,\n-                                Some(arg.id()),\n-                                arg.span(),\n-                                None,\n-                                |_, _| {\n-                                    // Default generic parameters may not be marked\n-                                    // with stability attributes, i.e. when the\n-                                    // default parameter was defined at the same time\n-                                    // as the rest of the type. As such, we ignore missing\n-                                    // stability attributes.\n-                                },\n-                            );\n-                        }\n+                    (&GenericParamDefKind::Const { .. }, hir::GenericArg::Infer(inf)) => {\n+                        let ty = tcx.at(self.span).type_of(param.def_id);\n                         if self.astconv.allow_ty_infer() {\n-                            self.astconv.ast_ty_to_ty(&inf.to_ty()).into()\n+                            self.astconv.ct_infer(ty, Some(param), inf.span).into()\n                         } else {\n                             self.inferred_params.push(inf.span);\n-                            tcx.ty_error().into()\n+                            tcx.const_error(ty).into()\n                         }\n                     }\n                     _ => unreachable!(),"}, {"sha": "1404bc271673eb41d518c639cf787f052fd809ef", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -426,22 +426,48 @@ fn check_gat_where_clauses(\n         }\n     }\n \n-    // If there are any missing clauses, emit an error\n-    let mut clauses = clauses.unwrap_or_default();\n+    // If there are any clauses that aren't provable, emit an error\n+    let clauses = clauses.unwrap_or_default();\n     debug!(?clauses);\n     if !clauses.is_empty() {\n-        let written_predicates: ty::GenericPredicates<'_> =\n-            tcx.explicit_predicates_of(trait_item.def_id);\n+        let param_env = tcx.param_env(trait_item.def_id);\n+\n         let mut clauses: Vec<_> = clauses\n-            .drain_filter(|clause| !written_predicates.predicates.iter().any(|p| &p.0 == clause))\n+            .into_iter()\n+            .filter(|clause| match clause.kind().skip_binder() {\n+                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    !region_known_to_outlive(\n+                        tcx,\n+                        trait_item.hir_id(),\n+                        param_env,\n+                        &FxHashSet::default(),\n+                        a,\n+                        b,\n+                    )\n+                }\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    !ty_known_to_outlive(\n+                        tcx,\n+                        trait_item.hir_id(),\n+                        param_env,\n+                        &FxHashSet::default(),\n+                        a,\n+                        b,\n+                    )\n+                }\n+                _ => bug!(\"Unexpected PredicateKind\"),\n+            })\n             .map(|clause| format!(\"{}\", clause))\n             .collect();\n+\n         // We sort so that order is predictable\n         clauses.sort();\n+\n         if !clauses.is_empty() {\n+            let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n             let mut err = tcx.sess.struct_span_err(\n                 trait_item.span,\n-                &format!(\"Missing required bounds on {}\", trait_item.ident),\n+                &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n             );\n \n             let suggestion = format!(\n@@ -455,11 +481,22 @@ fn check_gat_where_clauses(\n             );\n             err.span_suggestion(\n                 trait_item.generics.where_clause.tail_span_for_suggestion(),\n-                \"add the required where clauses\",\n+                &format!(\"add the required where clause{}\", plural),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n \n+            let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n+            err.note(&format!(\n+                \"{} currently required to ensure that impls have maximum flexibility\",\n+                bound\n+            ));\n+            err.note(\n+                \"we are soliciting feedback, see issue #87479 \\\n+                 <https://github.com/rust-lang/rust/issues/87479> \\\n+                 for more information\",\n+            );\n+\n             err.emit()\n         }\n     }\n@@ -541,7 +578,8 @@ fn region_known_to_outlive<'tcx>(\n         });\n \n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-        (&infcx).push_sub_region_constraint(origin, region_a, region_b);\n+        // `region_a: region_b` -> `region_b <= region_a`\n+        (&infcx).push_sub_region_constraint(origin, region_b, region_a);\n \n         let errors = infcx.resolve_regions(\n             id.expect_owner().to_def_id(),"}, {"sha": "9c1b79d696697f7ecc94af9b2096e8621c1404af", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -1259,7 +1259,7 @@ impl CStr {\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-    #[rustc_const_unstable(feature = \"const_cstr_unchecked\", issue = \"90343\")]\n+    #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n         // SAFETY: Casting to CStr is safe because its internal representation\n         // is a [u8] too (safe only inside std)."}, {"sha": "dabab667ee968a56755bd18ffb6fa8d20171c853", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -252,7 +252,6 @@\n #![feature(char_internals)]\n #![cfg_attr(not(bootstrap), feature(concat_bytes))]\n #![feature(concat_idents)]\n-#![feature(const_cstr_unchecked)]\n #![feature(const_fn_floating_point_arithmetic)]\n #![feature(const_fn_fn_ptr_basics)]\n #![feature(const_fn_trait_bound)]"}, {"sha": "ac24543929b663df349edbbb7c9e59bbb8f982dc", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -29,20 +29,21 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::{Arc, Mutex};\n \n use crate::clean::{types::AttributesExt, Attributes};\n-use crate::config::Options;\n+use crate::config::Options as RustdocOptions;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::lint::init_lints;\n use crate::passes::span_of_attrs;\n \n+/// Options that apply to all doctests in a crate or Markdown file (for `rustdoc foo.md`).\n #[derive(Clone, Default)]\n-crate struct TestOptions {\n+crate struct GlobalTestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n     crate no_crate_inject: bool,\n     /// Additional crate-level attributes to add to doctests.\n     crate attrs: Vec<String>,\n }\n \n-crate fn run(options: Options) -> Result<(), ErrorReported> {\n+crate fn run(options: RustdocOptions) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -214,10 +215,10 @@ crate fn run_tests(mut test_args: Vec<String>, nocapture: bool, tests: Vec<test:\n }\n \n // Look for `#![doc(test(no_crate_inject))]`, used by crates in the std facade.\n-fn scrape_test_config(attrs: &[ast::Attribute]) -> TestOptions {\n+fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n     use rustc_ast_pretty::pprust;\n \n-    let mut opts = TestOptions { no_crate_inject: false, attrs: Vec::new() };\n+    let mut opts = GlobalTestOptions { no_crate_inject: false, attrs: Vec::new() };\n \n     let test_attrs: Vec<_> = attrs\n         .iter()\n@@ -292,66 +293,63 @@ fn run_test(\n     test: &str,\n     crate_name: &str,\n     line: usize,\n-    options: Options,\n-    should_panic: bool,\n+    rustdoc_options: RustdocOptions,\n+    mut lang_string: LangString,\n     no_run: bool,\n-    as_test_harness: bool,\n     runtool: Option<String>,\n     runtool_args: Vec<String>,\n     target: TargetTriple,\n-    compile_fail: bool,\n-    mut error_codes: Vec<String>,\n-    opts: &TestOptions,\n+    opts: &GlobalTestOptions,\n     edition: Edition,\n     outdir: DirState,\n     path: PathBuf,\n     test_id: &str,\n     report_unused_externs: impl Fn(UnusedExterns),\n ) -> Result<(), TestFailure> {\n     let (test, line_offset, supports_color) =\n-        make_test(test, Some(crate_name), as_test_harness, opts, edition, Some(test_id));\n+        make_test(test, Some(crate_name), lang_string.test_harness, opts, edition, Some(test_id));\n \n     let output_file = outdir.path().join(\"rust_out\");\n \n-    let rustc_binary = options\n+    let rustc_binary = rustdoc_options\n         .test_builder\n         .as_deref()\n         .unwrap_or_else(|| rustc_interface::util::rustc_path().expect(\"found rustc\"));\n     let mut compiler = Command::new(&rustc_binary);\n     compiler.arg(\"--crate-type\").arg(\"bin\");\n-    for cfg in &options.cfgs {\n+    for cfg in &rustdoc_options.cfgs {\n         compiler.arg(\"--cfg\").arg(&cfg);\n     }\n-    if let Some(sysroot) = options.maybe_sysroot {\n+    if let Some(sysroot) = rustdoc_options.maybe_sysroot {\n         compiler.arg(\"--sysroot\").arg(sysroot);\n     }\n     compiler.arg(\"--edition\").arg(&edition.to_string());\n     compiler.env(\"UNSTABLE_RUSTDOC_TEST_PATH\", path);\n     compiler.env(\"UNSTABLE_RUSTDOC_TEST_LINE\", format!(\"{}\", line as isize - line_offset as isize));\n     compiler.arg(\"-o\").arg(&output_file);\n-    if as_test_harness {\n+    if lang_string.test_harness {\n         compiler.arg(\"--test\");\n     }\n-    if options.json_unused_externs && !compile_fail {\n+    if rustdoc_options.json_unused_externs && !lang_string.compile_fail {\n         compiler.arg(\"--error-format=json\");\n         compiler.arg(\"--json\").arg(\"unused-externs\");\n         compiler.arg(\"-Z\").arg(\"unstable-options\");\n         compiler.arg(\"-W\").arg(\"unused_crate_dependencies\");\n     }\n-    for lib_str in &options.lib_strs {\n+    for lib_str in &rustdoc_options.lib_strs {\n         compiler.arg(\"-L\").arg(&lib_str);\n     }\n-    for extern_str in &options.extern_strs {\n+    for extern_str in &rustdoc_options.extern_strs {\n         compiler.arg(\"--extern\").arg(&extern_str);\n     }\n     compiler.arg(\"-Ccodegen-units=1\");\n-    for codegen_options_str in &options.codegen_options_strs {\n+    for codegen_options_str in &rustdoc_options.codegen_options_strs {\n         compiler.arg(\"-C\").arg(&codegen_options_str);\n     }\n-    for debugging_option_str in &options.debugging_opts_strs {\n+    for debugging_option_str in &rustdoc_options.debugging_opts_strs {\n         compiler.arg(\"-Z\").arg(&debugging_option_str);\n     }\n-    if no_run && !compile_fail && options.persist_doctests.is_none() {\n+    if no_run && !lang_string.compile_fail && rustdoc_options.persist_doctests.is_none() {\n         compiler.arg(\"--emit=metadata\");\n     }\n     compiler.arg(\"--target\").arg(match target {\n@@ -360,7 +358,7 @@ fn run_test(\n             path.to_str().expect(\"target path must be valid unicode\").to_string()\n         }\n     });\n-    if let ErrorOutputType::HumanReadable(kind) = options.error_format {\n+    if let ErrorOutputType::HumanReadable(kind) = rustdoc_options.error_format {\n         let (short, color_config) = kind.unzip();\n \n         if short {\n@@ -418,20 +416,20 @@ fn run_test(\n \n     let out = out_lines.join(\"\\n\");\n     let _bomb = Bomb(&out);\n-    match (output.status.success(), compile_fail) {\n+    match (output.status.success(), lang_string.compile_fail) {\n         (true, true) => {\n             return Err(TestFailure::UnexpectedCompilePass);\n         }\n         (true, false) => {}\n         (false, true) => {\n-            if !error_codes.is_empty() {\n+            if !lang_string.error_codes.is_empty() {\n                 // We used to check if the output contained \"error[{}]: \" but since we added the\n                 // colored output, we can't anymore because of the color escape characters before\n                 // the \":\".\n-                error_codes.retain(|err| !out.contains(&format!(\"error[{}]\", err)));\n+                lang_string.error_codes.retain(|err| !out.contains(&format!(\"error[{}]\", err)));\n \n-                if !error_codes.is_empty() {\n-                    return Err(TestFailure::MissingErrorCodes(error_codes));\n+                if !lang_string.error_codes.is_empty() {\n+                    return Err(TestFailure::MissingErrorCodes(lang_string.error_codes));\n                 }\n             }\n         }\n@@ -454,11 +452,11 @@ fn run_test(\n     } else {\n         cmd = Command::new(output_file);\n     }\n-    if let Some(run_directory) = options.test_run_directory {\n+    if let Some(run_directory) = rustdoc_options.test_run_directory {\n         cmd.current_dir(run_directory);\n     }\n \n-    let result = if options.nocapture {\n+    let result = if rustdoc_options.nocapture {\n         cmd.status().map(|status| process::Output {\n             status,\n             stdout: Vec::new(),\n@@ -470,9 +468,9 @@ fn run_test(\n     match result {\n         Err(e) => return Err(TestFailure::ExecutionError(e)),\n         Ok(out) => {\n-            if should_panic && out.status.success() {\n+            if lang_string.should_panic && out.status.success() {\n                 return Err(TestFailure::UnexpectedRunPass);\n-            } else if !should_panic && !out.status.success() {\n+            } else if !lang_string.should_panic && !out.status.success() {\n                 return Err(TestFailure::ExecutionFailure(out));\n             }\n         }\n@@ -487,7 +485,7 @@ crate fn make_test(\n     s: &str,\n     crate_name: Option<&str>,\n     dont_insert_main: bool,\n-    opts: &TestOptions,\n+    opts: &GlobalTestOptions,\n     edition: Edition,\n     test_id: Option<&str>,\n ) -> (String, usize, bool) {\n@@ -804,11 +802,11 @@ crate struct Collector {\n     // the `names` vector of that test will be `[\"Title\", \"Subtitle\"]`.\n     names: Vec<String>,\n \n-    options: Options,\n+    rustdoc_options: RustdocOptions,\n     use_headers: bool,\n     enable_per_target_ignores: bool,\n     crate_name: Symbol,\n-    opts: TestOptions,\n+    opts: GlobalTestOptions,\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n@@ -820,17 +818,17 @@ crate struct Collector {\n impl Collector {\n     crate fn new(\n         crate_name: Symbol,\n-        options: Options,\n+        rustdoc_options: RustdocOptions,\n         use_headers: bool,\n-        opts: TestOptions,\n+        opts: GlobalTestOptions,\n         source_map: Option<Lrc<SourceMap>>,\n         filename: Option<PathBuf>,\n         enable_per_target_ignores: bool,\n     ) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n-            options,\n+            rustdoc_options,\n             use_headers,\n             enable_per_target_ignores,\n             crate_name,\n@@ -884,14 +882,14 @@ impl Tester for Collector {\n         let name = self.generate_name(line, &filename);\n         let crate_name = self.crate_name.to_string();\n         let opts = self.opts.clone();\n-        let edition = config.edition.unwrap_or(self.options.edition);\n-        let options = self.options.clone();\n-        let runtool = self.options.runtool.clone();\n-        let runtool_args = self.options.runtool_args.clone();\n-        let target = self.options.target.clone();\n+        let edition = config.edition.unwrap_or(self.rustdoc_options.edition);\n+        let rustdoc_options = self.rustdoc_options.clone();\n+        let runtool = self.rustdoc_options.runtool.clone();\n+        let runtool_args = self.rustdoc_options.runtool_args.clone();\n+        let target = self.rustdoc_options.target.clone();\n         let target_str = target.to_string();\n         let unused_externs = self.unused_extern_reports.clone();\n-        let no_run = config.no_run || options.no_run;\n+        let no_run = config.no_run || rustdoc_options.no_run;\n         if !config.compile_fail {\n             self.compiling_test_count.fetch_add(1, Ordering::SeqCst);\n         }\n@@ -925,7 +923,7 @@ impl Tester for Collector {\n                 self.visited_tests.entry((file.clone(), line)).and_modify(|v| *v += 1).or_insert(0)\n             },\n         );\n-        let outdir = if let Some(mut path) = options.persist_doctests.clone() {\n+        let outdir = if let Some(mut path) = rustdoc_options.persist_doctests.clone() {\n             path.push(&test_id);\n \n             std::fs::create_dir_all(&path)\n@@ -965,15 +963,12 @@ impl Tester for Collector {\n                     &test,\n                     &crate_name,\n                     line,\n-                    options,\n-                    config.should_panic,\n+                    rustdoc_options,\n+                    config,\n                     no_run,\n-                    config.test_harness,\n                     runtool,\n                     runtool_args,\n                     target,\n-                    config.compile_fail,\n-                    config.error_codes,\n                     &opts,\n                     edition,\n                     outdir,"}, {"sha": "360d2259ea3d2ea799a833687fd57402e9a121ba", "filename": "src/librustdoc/doctest/tests.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest%2Ftests.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -1,10 +1,10 @@\n-use super::{make_test, TestOptions};\n+use super::{make_test, GlobalTestOptions};\n use rustc_span::edition::DEFAULT_EDITION;\n \n #[test]\n fn make_test_basic() {\n     //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() {\n@@ -19,7 +19,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_name_no_use() {\n     // If you give a crate name but *don't* use it within the test, it won't bother inserting\n     // the `extern crate` statement.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() {\n@@ -34,7 +34,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_name() {\n     // If you give a crate name and use it within the test, it will insert an `extern crate`\n     // statement before `fn main`.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -52,7 +52,7 @@ assert_eq!(2+2, 4);\n fn make_test_no_crate_inject() {\n     // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n     // adding it anyway.\n-    let opts = TestOptions { no_crate_inject: true, attrs: vec![] };\n+    let opts = GlobalTestOptions { no_crate_inject: true, attrs: vec![] };\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -70,7 +70,7 @@ fn make_test_ignore_std() {\n     // Even if you include a crate name, and use it in the doctest, we still won't include an\n     // `extern crate` statement if the crate is \"std\" -- that's included already by the\n     // compiler!\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use std::*;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -87,7 +87,7 @@ assert_eq!(2+2, 4);\n fn make_test_manual_extern_crate() {\n     // When you manually include an `extern crate` statement in your doctest, `make_test`\n     // assumes you've included one for your own crate too.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"extern crate asdf;\n use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -104,7 +104,7 @@ assert_eq!(2+2, 4);\n \n #[test]\n fn make_test_manual_extern_crate_with_macro_use() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#[macro_use] extern crate asdf;\n use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -123,7 +123,7 @@ assert_eq!(2+2, 4);\n fn make_test_opts_attrs() {\n     // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n     // those instead of the stock `#![allow(unused)]`.\n-    let mut opts = TestOptions::default();\n+    let mut opts = GlobalTestOptions::default();\n     opts.attrs.push(\"feature(sick_rad)\".to_string());\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -155,7 +155,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_attrs() {\n     // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n     // them outside the generated main function.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#![feature(sick_rad)]\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -171,7 +171,7 @@ assert_eq!(2+2, 4);\n #[test]\n fn make_test_with_main() {\n     // Including your own `fn main` wrapper lets the test use it verbatim.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"fn main() {\n     assert_eq!(2+2, 4);\n }\";\n@@ -187,7 +187,7 @@ fn main() {\n #[test]\n fn make_test_fake_main() {\n     // ... but putting it in a comment will still provide a wrapper.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"//Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -203,7 +203,7 @@ assert_eq!(2+2, 4);\n #[test]\n fn make_test_dont_insert_main() {\n     // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"//Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -216,7 +216,7 @@ assert_eq!(2+2, 4);\"\n \n #[test]\n fn make_test_issues_21299_33731() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n \n     let input = \"// fn main\n assert_eq!(2+2, 4);\";\n@@ -248,7 +248,7 @@ assert_eq!(asdf::foo, 4);\n \n #[test]\n fn make_test_main_in_macro() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#[macro_use] extern crate my_crate;\n test_wrapper! {\n     fn main() {}\n@@ -267,7 +267,7 @@ test_wrapper! {\n #[test]\n fn make_test_returns_result() {\n     // creates an inner function and unwraps it\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use std::io;\n let mut input = String::new();\n io::stdin().read_line(&mut input)?;\n@@ -287,7 +287,7 @@ Ok::<(), io:Error>(())\n #[test]\n fn make_test_named_wrapper() {\n     // creates an inner function with a specific name\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() { #[allow(non_snake_case)] fn _doctest_main__some_unique_name() {"}, {"sha": "5751ec2cc02b349b65aa7589c8525e5e9b2f12f9", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -892,6 +892,10 @@ h2.small-section-header > .anchor {\n \ttop: 10px;\n }\n .search-input {\n+\t/* Override Normalize.css: it has a rule that sets\n+\t   -webkit-appearance: textfield for search inputs. That\n+\t   causes rounded corners and no border on iOS Safari. */\n+\t-webkit-appearance: none;\n \t/* Override Normalize.css: we have margins and do\n \t not want to overflow - the `moz` attribute is necessary\n \t until Firefox 29, too early to drop at this point */"}, {"sha": "906b8f8a245709656d2e657c573de12397913eba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Symbol;\n \n use crate::config::{Options, RenderOptions};\n-use crate::doctest::{Collector, TestOptions};\n+use crate::doctest::{Collector, GlobalTestOptions};\n use crate::html::escape::Escape;\n use crate::html::markdown;\n use crate::html::markdown::{\n@@ -129,7 +129,7 @@ crate fn render<P: AsRef<Path>>(\n crate fn test(options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n-    let mut opts = TestOptions::default();\n+    let mut opts = GlobalTestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(\n         Symbol::intern(&options.input.display().to_string()),"}, {"sha": "251160a0f5f290a50a85e97e5869442ce0b04bc4", "filename": "src/test/ui/const-generics/generic_arg_infer/dont-use-defaults.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fdont-use-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fdont-use-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fdont-use-defaults.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+#![feature(generic_arg_infer)]\n+\n+// test that we dont use defaults to aide in type inference\n+\n+struct Foo<const N: usize = 2>;\n+impl<const N: usize> Foo<N> {\n+    fn make_arr() -> [(); N] {\n+        [(); N]\n+    }\n+}\n+\n+fn main() {\n+    let [(), (), ()] = Foo::<_>::make_arr();\n+}"}, {"sha": "413cc1539248a05e390bb2b578ca662e13ee1785", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -0,0 +1,8 @@\n+#![feature(portable_simd)]\n+#![feature(generic_arg_infer)]\n+use std::simd::Mask;\n+\n+fn main() {\n+    let y = Mask::<_, _>::splat(false);\n+    //~^ error: type annotations needed for `Mask<_, {_: usize}>`\n+}"}, {"sha": "71a5ff79280fdd0f8196590ad8ec5f0c78c430c6", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -0,0 +1,18 @@\n+error[E0283]: type annotations needed for `Mask<_, {_: usize}>`\n+  --> $DIR/issue-91614.rs:6:13\n+   |\n+LL |     let y = Mask::<_, _>::splat(false);\n+   |         -   ^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T`\n+   |         |\n+   |         consider giving `y` the explicit type `Mask<_, LANES>`, where the type parameter `T` is specified\n+   |\n+   = note: cannot satisfy `_: MaskElement`\n+note: required by a bound in `Mask::<T, LANES>::splat`\n+  --> $SRC_DIR/core/src/../../portable-simd/crates/core_simd/src/masks.rs:LL:COL\n+   |\n+LL |     T: MaskElement,\n+   |        ^^^^^^^^^^^ required by this bound in `Mask::<T, LANES>::splat`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "5863bac2f9d0bdb19f7eb1a8840c7fb39b988bb9", "filename": "src/test/ui/generic-associated-types/issue-86787.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -9,7 +9,7 @@ enum Either<L, R> {\n pub trait HasChildrenOf {\n     type T;\n     type TRef<'a>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n \n     fn ref_children<'a>(&'a self) -> Vec<Self::TRef<'a>>;\n     fn take_children(self) -> Vec<Self::T>;"}, {"sha": "d4b2267d3ddc713e8796b6b47074b80ee5225d36", "filename": "src/test/ui/generic-associated-types/issue-86787.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-86787.stderr?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -1,10 +1,13 @@\n-error: Missing required bounds on TRef\n+error: missing required bound on `TRef`\n   --> $DIR/issue-86787.rs:11:5\n    |\n LL |     type TRef<'a>;\n    |     ^^^^^^^^^^^^^-\n    |                  |\n-   |                  help: add the required where clauses: `where Self: 'a`\n+   |                  help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n error: aborting due to previous error\n "}, {"sha": "37b3a6155d5aee89a1cb8854944039e2c4991fad", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n // We have a `&'a self`, so we need a `Self: 'a`\n trait Iterable {\n     type Item<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn iter<'a>(&'a self) -> Self::Item<'a>;\n }\n \n@@ -23,7 +23,7 @@ impl<T> Iterable for T {\n // We have a `&'a T`, so we need a `T: 'x`\n trait Deserializer<T> {\n     type Out<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize<'a>(&self, input: &'a T) -> Self::Out<'a>;\n }\n \n@@ -37,14 +37,14 @@ impl<T> Deserializer<T> for () {\n // We have a `&'b T` and a `'b: 'a`, so it is implied that `T: 'a`. Therefore, we need a `T: 'x`\n trait Deserializer2<T> {\n     type Out<'x>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize2<'a, 'b: 'a>(&self, input1: &'b T) -> Self::Out<'a>;\n }\n \n // We have a `&'a T` and a `&'b U`, so we need a `T: 'x` and a `U: 'y`\n trait Deserializer3<T, U> {\n     type Out<'x, 'y>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn deserialize2<'a, 'b>(&self, input: &'a T, input2: &'b U) -> Self::Out<'a, 'b>;\n }\n \n@@ -59,7 +59,7 @@ struct Wrap<T>(T);\n // We pass `Wrap<T>` and we see `&'z Wrap<T>`, so we require `D: 'x`\n trait Des {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, Wrap<T>>;\n }\n /*\n@@ -75,7 +75,7 @@ impl Des for () {\n // implied bound that `T: 'z`, so we require `D: 'x`\n trait Des2 {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z Wrap<T>) -> Self::Out<'z, T>;\n }\n /*\n@@ -90,7 +90,7 @@ impl Des2 for () {\n // We see `&'z T`, so we require `D: 'x`\n trait Des3 {\n     type Out<'x, D>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn des<'z, T>(&self, data: &'z T) -> Self::Out<'z, T>;\n }\n /*\n@@ -112,22 +112,22 @@ trait NoGat<'a> {\n // FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n trait TraitLifetime<'a> {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method(&'a self) -> Self::Bar<'a>;\n }\n \n // Like above, but we have a where clause that can prove what we want\n // FIXME: we require two bounds (`where Self: 'a, Self: 'b`) when we should only require one\n trait TraitLifetimeWhere<'a> where Self: 'a {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method(&'a self) -> Self::Bar<'a>;\n }\n \n // Explicit bound instead of implicit; we want to still error\n trait ExplicitBound {\n     type Bar<'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn method<'b>(&self, token: &'b ()) -> Self::Bar<'b> where Self: 'b;\n }\n \n@@ -141,14 +141,15 @@ trait NotInReturn {\n trait IterableTwo {\n     type Item<'a>;\n     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n }\n \n-// We also should report region outlives clauses\n+// We also should report region outlives clauses. Here, we know that `'y: 'x`,\n+// because of `&'x &'y`, so we require that `'b: 'a`.\n trait RegionOutlives {\n     type Bar<'a, 'b>;\n-    //~^ Missing required bounds\n+    //~^ missing required\n     fn foo<'x, 'y>(&self, input: &'x &'y ()) -> Self::Bar<'x, 'y>;\n }\n \n@@ -161,6 +162,17 @@ impl Foo for () {\n }\n */\n \n+// Similar to the above, except with explicit bounds\n+trait ExplicitRegionOutlives<'ctx> {\n+    type Fut<'out>;\n+    //~^ missing required\n+\n+    fn test<'out>(ctx: &'ctx i32) -> Self::Fut<'out>\n+    where\n+        'ctx: 'out;\n+}\n+\n+\n // If there are multiple methods that return the GAT, require a set of clauses\n // that can be satisfied by *all* methods\n trait MultipleMethods {\n@@ -170,4 +182,11 @@ trait MultipleMethods {\n     fn gimme_default(&self) -> Self::Bar<'static>;\n }\n \n+// We would normally require `Self: 'a`, but we can prove that `Self: 'static`\n+// because of the the bounds on the trait, so the bound is proven\n+trait Trait: 'static {\n+    type Assoc<'a>;\n+    fn make_assoc(_: &u32) -> Self::Assoc<'_>;\n+}\n+\n fn main() {}"}, {"sha": "3b9146ad875a34b36394f4b81e72910f92c8be0a", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f117a77d0880ed59afcc1a19c72ec5c1e44b97c/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=8f117a77d0880ed59afcc1a19c72ec5c1e44b97c", "patch": "@@ -1,98 +1,145 @@\n-error: Missing required bounds on Item\n+error: missing required bound on `Item`\n   --> $DIR/self-outlives-lint.rs:9:5\n    |\n LL |     type Item<'x>;\n    |     ^^^^^^^^^^^^^-\n    |                  |\n-   |                  help: add the required where clauses: `where Self: 'x`\n+   |                  help: add the required where clause: `where Self: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:25:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where T: 'x`\n+   |                 help: add the required where clause: `where T: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:39:5\n    |\n LL |     type Out<'x>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where T: 'x`\n+   |                 help: add the required where clause: `where T: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bounds on `Out`\n   --> $DIR/self-outlives-lint.rs:46:5\n    |\n LL |     type Out<'x, 'y>;\n    |     ^^^^^^^^^^^^^^^^-\n    |                     |\n    |                     help: add the required where clauses: `where T: 'x, U: 'y`\n+   |\n+   = note: these bounds are currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:61:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:77:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Out\n+error: missing required bound on `Out`\n   --> $DIR/self-outlives-lint.rs:92:5\n    |\n LL |     type Out<'x, D>;\n    |     ^^^^^^^^^^^^^^^-\n    |                    |\n-   |                    help: add the required where clauses: `where D: 'x`\n+   |                    help: add the required where clause: `where D: 'x`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bounds on `Bar`\n   --> $DIR/self-outlives-lint.rs:114:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n    |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+   |\n+   = note: these bounds are currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bound on `Bar`\n   --> $DIR/self-outlives-lint.rs:122:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where Self: 'a, Self: 'b`\n+   |                 help: add the required where clause: `where Self: 'b`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n+error: missing required bound on `Bar`\n   --> $DIR/self-outlives-lint.rs:129:5\n    |\n LL |     type Bar<'b>;\n    |     ^^^^^^^^^^^^-\n    |                 |\n-   |                 help: add the required where clauses: `where Self: 'b`\n+   |                 help: add the required where clause: `where Self: 'b`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Iterator\n+error: missing required bound on `Iterator`\n   --> $DIR/self-outlives-lint.rs:143:5\n    |\n LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n    |                                                       |\n-   |                                                       help: add the required where clauses: `where Self: 'a`\n+   |                                                       help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: Missing required bounds on Bar\n-  --> $DIR/self-outlives-lint.rs:150:5\n+error: missing required bound on `Bar`\n+  --> $DIR/self-outlives-lint.rs:151:5\n    |\n LL |     type Bar<'a, 'b>;\n    |     ^^^^^^^^^^^^^^^^-\n    |                     |\n-   |                     help: add the required where clauses: `where 'a: 'b`\n+   |                     help: add the required where clause: `where 'b: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n+error: missing required bound on `Fut`\n+  --> $DIR/self-outlives-lint.rs:167:5\n+   |\n+LL |     type Fut<'out>;\n+   |     ^^^^^^^^^^^^^^-\n+   |                   |\n+   |                   help: add the required where clause: `where 'ctx: 'out`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}]}