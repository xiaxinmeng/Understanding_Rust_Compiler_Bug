{"sha": "de046bf4572a75cf534a2342358a422b2f18d01c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMDQ2YmY0NTcyYTc1Y2Y1MzRhMjM0MjM1OGE0MjJiMmYxOGQwMWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-04T19:59:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-04T19:59:21Z"}, "message": "Merge #7559\n\n7559: Make `ModPath`'s representation private r=jonas-schievink a=jonas-schievink\n\nThis lets us switch out the `Vec` for something more efficient\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "87f58e72537569806e689a6be4c404a496431360", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87f58e72537569806e689a6be4c404a496431360"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de046bf4572a75cf534a2342358a422b2f18d01c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgHFIZCRBK7hj4Ov3rIwAAdHIIAIj51hYZAw7oo4naGhGAwOrm\nga+4EWA4ux6b7CcBWAjDDmAGgcx/tP0O6ensrK1esWml8eW41/QjKHOXRlIGbiRL\nIYTBXfXxzrgMVUm/l5GWyNakx7DymRITu+ymmfaet41KB+/RafXoCp7coaqEn9k2\nZJc5j3zWpzpiiHTS4df+rtQuU+lXgMfrQywv3qeoPKrmf4yzz1eqULQeToopDf5U\neD6KuMh3lo6ikjIBD1+AoNuTZP+SkUm4bHss2cum/d/9TFjjUyWpNgNpPHCLyDe3\nlYeGzaHImRoWhKllXbgtIVZ17QR81tz8xnmmCQYtNgbRNCt88sGEy+RcaUPNG4Y=\n=XwSQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 87f58e72537569806e689a6be4c404a496431360\nparent 4c1fcda0f8183060de5a341fffa2b30e65bdb52f\nparent 5d99ba1d9a5acf02a5cd50e456f164bd80b523b5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612468761 +0000\ncommitter GitHub <noreply@github.com> 1612468761 +0000\n\nMerge #7559\n\n7559: Make `ModPath`'s representation private r=jonas-schievink a=jonas-schievink\n\nThis lets us switch out the `Vec` for something more efficient\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de046bf4572a75cf534a2342358a422b2f18d01c", "html_url": "https://github.com/rust-lang/rust/commit/de046bf4572a75cf534a2342358a422b2f18d01c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de046bf4572a75cf534a2342358a422b2f18d01c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c1fcda0f8183060de5a341fffa2b30e65bdb52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c1fcda0f8183060de5a341fffa2b30e65bdb52f", "html_url": "https://github.com/rust-lang/rust/commit/4c1fcda0f8183060de5a341fffa2b30e65bdb52f"}, {"sha": "5d99ba1d9a5acf02a5cd50e456f164bd80b523b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d99ba1d9a5acf02a5cd50e456f164bd80b523b5", "html_url": "https://github.com/rust-lang/rust/commit/5d99ba1d9a5acf02a5cd50e456f164bd80b523b5"}], "stats": {"total": 121, "additions": 70, "deletions": 51}, "files": [{"sha": "5c7678b5397745a06c4d9bd7b82796dcfc7666f6", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -151,8 +151,8 @@ fn insert_import(\n         ctx.config.insert_use.prefix_kind,\n     );\n     if let Some(mut mod_path) = mod_path {\n-        mod_path.segments.pop();\n-        mod_path.segments.push(variant_hir_name.clone());\n+        mod_path.pop_segment();\n+        mod_path.push_segment(variant_hir_name.clone());\n         let scope = ImportScope::find_insert_use_container(scope_node, &ctx.sema)?;\n         *rewriter += insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use.merge);\n     }"}, {"sha": "c9f9284835c2b525e2431d266a24817bb971e5b1", "filename": "crates/completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -175,7 +175,7 @@ fn compute_fuzzy_completion_order_key(\n     user_input_lowercased: &str,\n ) -> usize {\n     mark::hit!(certain_fuzzy_order_test);\n-    let proposed_import_name = match proposed_mod_path.segments.last() {\n+    let proposed_import_name = match proposed_mod_path.segments().last() {\n         Some(name) => name.to_string().to_lowercase(),\n         None => return usize::MAX,\n     };"}, {"sha": "e2482f9592d0cd2e48f2fc98abbea771b9c1bf30", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -63,7 +63,7 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n             if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n                 // Variants with trivial paths are already added by the existing completion logic,\n                 // so we should avoid adding these twice\n-                if path.segments.len() > 1 {\n+                if path.segments().len() > 1 {\n                     acc.add_qualified_enum_variant(ctx, variant, path);\n                 }\n             }"}, {"sha": "884711f11e42ca3330fed011d85d3fea9851843e", "filename": "crates/completion/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fitem.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -332,9 +332,9 @@ impl Builder {\n                 label = format!(\"{} ({})\", label, import_to_add.import_path);\n             } else {\n                 let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n-                let _ = import_path_without_last_segment.segments.pop();\n+                let _ = import_path_without_last_segment.pop_segment();\n \n-                if !import_path_without_last_segment.segments.is_empty() {\n+                if !import_path_without_last_segment.segments().is_empty() {\n                     lookup = lookup.or_else(|| Some(label.clone()));\n                     insert_text = insert_text.or_else(|| Some(label.clone()));\n                     label = format!(\"{}::{}\", import_path_without_last_segment, label);"}, {"sha": "eddaaa6f3db2a66b55293c9cf12750fa4889ebab", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -57,7 +57,7 @@ pub(crate) fn render_resolution_with_import<'a>(\n         ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n         ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n         ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => import_edit.import_path.segments.last()?.to_string(),\n+        _ => import_edit.import_path.segments().last()?.to_string(),\n     };\n     Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n         item.completion_kind = CompletionKind::Magic;"}, {"sha": "9214193b427bb3cd09103cfda8a9a0a44e0123e0", "filename": "crates/completion/src/render/enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -45,8 +45,8 @@ impl<'a> EnumRender<'a> {\n         let (qualified_name, short_qualified_name) = match &path {\n             Some(path) => {\n                 let full = path.to_string();\n-                let short =\n-                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n+                let segments = path.segments();\n+                let short = segments[segments.len().saturating_sub(2)..].iter().join(\"::\");\n                 (full, short)\n             }\n             None => (name.to_string(), name.to_string()),"}, {"sha": "aa2c6e04ecac74ec9212ac5554741ed20f88420b", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -36,13 +36,13 @@ const MAX_PATH_LEN: usize = 15;\n \n impl ModPath {\n     fn starts_with_std(&self) -> bool {\n-        self.segments.first() == Some(&known::std)\n+        self.segments().first() == Some(&known::std)\n     }\n \n     // When std library is present, paths starting with `std::`\n     // should be preferred over paths starting with `core::` and `alloc::`\n     fn can_start_with_std(&self) -> bool {\n-        let first_segment = self.segments.first();\n+        let first_segment = self.segments().first();\n         first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n }\n@@ -157,7 +157,7 @@ fn find_path_inner(\n     if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n         if let Some(mut path) = find_path(db, ItemInNs::Types(variant.parent.into()), from) {\n             let data = db.enum_data(variant.parent);\n-            path.segments.push(data.variants[variant.local_id].name.clone());\n+            path.push_segment(data.variants[variant.local_id].name.clone());\n             return Some(path);\n         }\n         // If this doesn't work, it seems we have no way of referring to the\n@@ -186,7 +186,7 @@ fn find_path_inner(\n                 best_path_len - 1,\n                 prefixed,\n             ) {\n-                path.segments.push(name);\n+                path.push_segment(name);\n \n                 let new_path = if let Some(best_path) = best_path {\n                     select_best_path(best_path, path, prefer_no_std)\n@@ -215,7 +215,7 @@ fn find_path_inner(\n                     prefixed,\n                 )?;\n                 mark::hit!(partially_imported);\n-                path.segments.push(info.path.segments.last().unwrap().clone());\n+                path.push_segment(info.path.segments.last().unwrap().clone());\n                 Some(path)\n             })\n         });"}, {"sha": "3233b1957b976ea6e5be050a521db09148c657b9", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -240,7 +240,7 @@ impl ItemVisibilities {\n     fn alloc(&mut self, vis: RawVisibility) -> RawVisibilityId {\n         match &vis {\n             RawVisibility::Public => RawVisibilityId::PUB,\n-            RawVisibility::Module(path) if path.segments.is_empty() => match &path.kind {\n+            RawVisibility::Module(path) if path.segments().is_empty() => match &path.kind {\n                 PathKind::Super(0) => RawVisibilityId::PRIV,\n                 PathKind::Crate => RawVisibilityId::PUB_CRATE,\n                 _ => RawVisibilityId(self.arena.alloc(vis).into_raw().into()),\n@@ -251,10 +251,8 @@ impl ItemVisibilities {\n }\n \n static VIS_PUB: RawVisibility = RawVisibility::Public;\n-static VIS_PRIV: RawVisibility =\n-    RawVisibility::Module(ModPath { kind: PathKind::Super(0), segments: Vec::new() });\n-static VIS_PUB_CRATE: RawVisibility =\n-    RawVisibility::Module(ModPath { kind: PathKind::Crate, segments: Vec::new() });\n+static VIS_PRIV: RawVisibility = RawVisibility::Module(ModPath::from_kind(PathKind::Super(0)));\n+static VIS_PUB_CRATE: RawVisibility = RawVisibility::Module(ModPath::from_kind(PathKind::Crate));\n \n #[derive(Default, Debug, Eq, PartialEq)]\n struct GenericParamsStorage {"}, {"sha": "8f2f0b340637fdef34cce288fa45c31ff3be6187", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -750,7 +750,8 @@ impl Ctx {\n \n fn desugar_future_path(orig: TypeRef) -> Path {\n     let path = path![core::future::Future];\n-    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n+    let mut generic_args: Vec<_> =\n+        std::iter::repeat(None).take(path.segments().len() - 1).collect();\n     let mut last = GenericArgs::empty();\n     let binding =\n         AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };"}, {"sha": "b50923747c4719d9911171ad6ee45546dff3bf93", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -662,7 +662,7 @@ impl AsMacroCall for AstIdWithPath<ast::Item> {\n             def.as_lazy_macro(\n                 db.upcast(),\n                 krate,\n-                MacroCallKind::Attr(self.ast_id, self.path.segments.last()?.to_string()),\n+                MacroCallKind::Attr(self.ast_id, self.path.segments().last()?.to_string()),\n             )\n             .into(),\n         )"}, {"sha": "6bd41bc082140a1cedcba48f56ee63ba1e8409b2", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -655,7 +655,7 @@ impl DefCollector<'_> {\n                 }\n             }\n         } else {\n-            match import.path.segments.last() {\n+            match import.path.segments().last() {\n                 Some(last_segment) => {\n                     let name = match &import.alias {\n                         Some(ImportAlias::Alias(name)) => Some(name.clone()),\n@@ -956,7 +956,7 @@ impl DefCollector<'_> {\n                 let item_tree = self.db.item_tree(import.file_id);\n                 let import_data = &item_tree[import.value];\n \n-                match (import_data.path.segments.first(), &import_data.path.kind) {\n+                match (import_data.path.segments().first(), &import_data.path.kind) {\n                     (Some(krate), PathKind::Plain) | (Some(krate), PathKind::Abs) => {\n                         if diagnosed_extern_crates.contains(krate) {\n                             continue;"}, {"sha": "f2b59172dce0777979e1c2053a6836e9f9ca5230", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -149,7 +149,7 @@ impl DefMap {\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n+        let mut segments = path.segments().iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n@@ -190,7 +190,7 @@ impl DefMap {\n                 // BuiltinShadowMode wasn't Module, then we need to try\n                 // resolving it as a builtin.\n                 let prefer_module =\n-                    if path.segments.len() == 1 { shadow } else { BuiltinShadowMode::Module };\n+                    if path.segments().len() == 1 { shadow } else { BuiltinShadowMode::Module };\n \n                 log::debug!(\"resolving {:?} in module\", segment);\n                 self.resolve_name_in_module(db, original_module, &segment, prefer_module)\n@@ -203,10 +203,10 @@ impl DefMap {\n                         None => match &self.block {\n                             Some(block) => {\n                                 // Look up remaining path in parent `DefMap`\n-                                let new_path = ModPath {\n-                                    kind: PathKind::Super(lvl - i),\n-                                    segments: path.segments.clone(),\n-                                };\n+                                let new_path = ModPath::from_segments(\n+                                    PathKind::Super(lvl - i),\n+                                    path.segments().to_vec(),\n+                                );\n                                 log::debug!(\"`super` path: {} -> {} in parent map\", path, new_path);\n                                 return block.parent.def_map(db).resolve_path_fp_with_macro(\n                                     db,\n@@ -258,10 +258,10 @@ impl DefMap {\n             curr_per_ns = match curr {\n                 ModuleDefId::ModuleId(module) => {\n                     if module.krate != self.krate {\n-                        let path = ModPath {\n-                            segments: path.segments[i..].to_vec(),\n-                            kind: PathKind::Super(0),\n-                        };\n+                        let path = ModPath::from_segments(\n+                            PathKind::Super(0),\n+                            path.segments()[i..].iter().cloned(),\n+                        );\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = module.def_map(db);\n                         let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);"}, {"sha": "0caad53d3abea1107ad157cad69ee743a2c06947", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -20,7 +20,7 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModPath {\n     pub kind: PathKind,\n-    pub segments: Vec<Name>,\n+    segments: Vec<Name>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -53,6 +53,11 @@ impl ModPath {\n         ModPath { kind, segments }\n     }\n \n+    /// Creates a `ModPath` from a `PathKind`, with no extra path segments.\n+    pub const fn from_kind(kind: PathKind) -> ModPath {\n+        ModPath { kind, segments: Vec::new() }\n+    }\n+\n     /// Calls `cb` with all paths, represented by this use item.\n     pub(crate) fn expand_use_item(\n         item_src: InFile<ast::Use>,\n@@ -64,6 +69,18 @@ impl ModPath {\n         }\n     }\n \n+    pub fn segments(&self) -> &[Name] {\n+        &self.segments\n+    }\n+\n+    pub fn push_segment(&mut self, segment: Name) {\n+        self.segments.push(segment);\n+    }\n+\n+    pub fn pop_segment(&mut self) -> Option<Name> {\n+        self.segments.pop()\n+    }\n+\n     /// Returns the number of segments in the path (counting special segments like `$crate` and\n     /// `super`).\n     pub fn len(&self) -> usize {\n@@ -78,7 +95,7 @@ impl ModPath {\n     }\n \n     pub fn is_ident(&self) -> bool {\n-        self.kind == PathKind::Plain && self.segments.len() == 1\n+        self.as_ident().is_some()\n     }\n \n     pub fn is_self(&self) -> bool {\n@@ -87,10 +104,14 @@ impl ModPath {\n \n     /// If this path is a single identifier, like `foo`, return its name.\n     pub fn as_ident(&self) -> Option<&Name> {\n-        if !self.is_ident() {\n+        if self.kind != PathKind::Plain {\n             return None;\n         }\n-        self.segments.first()\n+\n+        match &*self.segments {\n+            [name] => Some(name),\n+            _ => None,\n+        }\n     }\n }\n "}, {"sha": "f9ad50301c5c67de813e0aeb678676666e357fe9", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -164,7 +164,7 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<(TypeNs, Option<usize>)> {\n-        let first_name = path.segments.first()?;\n+        let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n             match scope {\n@@ -179,7 +179,7 @@ impl Resolver {\n \n                 Scope::GenericParams { params, def } => {\n                     if let Some(local_id) = params.find_type_by_name(first_name) {\n-                        let idx = if path.segments.len() == 1 { None } else { Some(1) };\n+                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n                         return Some((\n                             TypeNs::GenericParam(TypeParamId { local_id, parent: *def }),\n                             idx,\n@@ -188,13 +188,13 @@ impl Resolver {\n                 }\n                 Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments.len() == 1 { None } else { Some(1) };\n+                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::SelfType(*impl_), idx));\n                     }\n                 }\n                 Scope::AdtScope(adt) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments.len() == 1 { None } else { Some(1) };\n+                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::AdtSelfType(*adt), idx));\n                     }\n                 }\n@@ -270,9 +270,9 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<ResolveValueResult> {\n-        let n_segments = path.segments.len();\n+        let n_segments = path.segments().len();\n         let tmp = name![self];\n-        let first_name = if path.is_self() { &tmp } else { path.segments.first()? };\n+        let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n             match scope {"}, {"sha": "38da3132bf70ba793bb4cf31f117b9f95ff8f5e6", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -22,8 +22,7 @@ pub enum RawVisibility {\n \n impl RawVisibility {\n     pub(crate) const fn private() -> RawVisibility {\n-        let path = ModPath { kind: PathKind::Super(0), segments: Vec::new() };\n-        RawVisibility::Module(path)\n+        RawVisibility::Module(ModPath::from_kind(PathKind::Super(0)))\n     }\n \n     pub(crate) fn from_ast(\n@@ -59,15 +58,15 @@ impl RawVisibility {\n                 RawVisibility::Module(path)\n             }\n             ast::VisibilityKind::PubCrate => {\n-                let path = ModPath { kind: PathKind::Crate, segments: Vec::new() };\n+                let path = ModPath::from_kind(PathKind::Crate);\n                 RawVisibility::Module(path)\n             }\n             ast::VisibilityKind::PubSuper => {\n-                let path = ModPath { kind: PathKind::Super(1), segments: Vec::new() };\n+                let path = ModPath::from_kind(PathKind::Super(1));\n                 RawVisibility::Module(path)\n             }\n             ast::VisibilityKind::PubSelf => {\n-                let path = ModPath { kind: PathKind::Plain, segments: Vec::new() };\n+                let path = ModPath::from_kind(PathKind::Plain);\n                 RawVisibility::Module(path)\n             }\n             ast::VisibilityKind::Pub => RawVisibility::Public,"}, {"sha": "4b683c5a741641d93462f13f6d3623423e53fb0b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -461,7 +461,7 @@ impl<'a> InferenceContext<'a> {\n                         (ty, variant)\n                     }\n                     Some(1) => {\n-                        let segment = path.mod_path().segments.last().unwrap();\n+                        let segment = path.mod_path().segments().last().unwrap();\n                         // this could be an enum variant or associated type\n                         if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n                             let enum_data = self.db.enum_data(enum_id);"}, {"sha": "bc7aee110329dad0d8de80b8f36e2f58a315daf7", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -24,7 +24,7 @@ pub fn mod_path_to_ast(path: &hir::ModPath) -> ast::Path {\n     }\n \n     segments.extend(\n-        path.segments\n+        path.segments()\n             .iter()\n             .map(|segment| make::path_segment(make::name_ref(&segment.to_string()))),\n     );"}, {"sha": "5a65012160bd3b9effc7cc75f38d63caecb0543e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de046bf4572a75cf534a2342358a422b2f18d01c/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=de046bf4572a75cf534a2342358a422b2f18d01c", "patch": "@@ -1729,7 +1729,7 @@ fn fill_resolve_data(\n ) -> Option<()> {\n     let import_edit = item.import_to_add()?;\n     let full_import_path = import_edit.import_path.to_string();\n-    let imported_name = import_edit.import_path.segments.clone().pop()?.to_string();\n+    let imported_name = import_edit.import_path.segments().last()?.to_string();\n \n     *resolve_data = Some(\n         to_value(CompletionResolveData {"}]}