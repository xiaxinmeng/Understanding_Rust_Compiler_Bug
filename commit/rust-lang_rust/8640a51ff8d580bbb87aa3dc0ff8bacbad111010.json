{"sha": "8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NDBhNTFmZjhkNTgwYmJiODdhYTNkYzBmZjhiYWNiYWQxMTEwMTA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-02-24T00:12:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-02-24T00:12:35Z"}, "message": "Implement multiple patterns with `|` in `if let` and `while let`", "tree": {"sha": "88f843f5e37f4dcc658bb13104dba12e119a3b71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88f843f5e37f4dcc658bb13104dba12e119a3b71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "html_url": "https://github.com/rust-lang/rust/commit/8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "063deba92e44809125a433ca6e6c1ad0993313bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/063deba92e44809125a433ca6e6c1ad0993313bf", "html_url": "https://github.com/rust-lang/rust/commit/063deba92e44809125a433ca6e6c1ad0993313bf"}], "stats": {"total": 359, "additions": 231, "deletions": 128}, "files": [{"sha": "89ed47ea194fb7e51859e9748946561b024046d6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -2956,7 +2956,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+            ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n                 //   match <sub_expr> {\n@@ -2970,8 +2970,8 @@ impl<'a> LoweringContext<'a> {\n                 {\n                     let body = self.lower_block(body, false);\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    arms.push(self.arm(hir_vec![pat], body_expr));\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    arms.push(self.arm(pats, body_expr));\n                 }\n \n                 // _ => [<else_opt>|()]\n@@ -3000,7 +3000,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_label) => {\n+            ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -3021,8 +3021,8 @@ impl<'a> LoweringContext<'a> {\n                 // `<pat> => <body>`\n                 let pat_arm = {\n                     let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                    let pat = self.lower_pat(pat);\n-                    self.arm(hir_vec![pat], body_expr)\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    self.arm(pats, body_expr)\n                 };\n \n                 // `_ => break`"}, {"sha": "e4e9ee58330cc58b775692491e72a68164b0b412", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -59,6 +59,7 @@ use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -2329,17 +2330,17 @@ impl<'a> Resolver<'a> {\n \n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.is_empty() {\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+        if pats.is_empty() {\n             return;\n         }\n \n         let mut missing_vars = FxHashMap();\n         let mut inconsistent_vars = FxHashMap();\n-        for (i, p) in arm.pats.iter().enumerate() {\n+        for (i, p) in pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&p);\n \n-            for (j, q) in arm.pats.iter().enumerate() {\n+            for (j, q) in pats.iter().enumerate() {\n                 if i == j {\n                     continue;\n                 }\n@@ -2404,9 +2405,8 @@ impl<'a> Resolver<'a> {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n \n-        // This has to happen *after* we determine which\n-        // pat_idents are variants\n-        self.check_consistent_bindings(arm);\n+        // This has to happen *after* we determine which pat_idents are variants\n+        self.check_consistent_bindings(&arm.pats);\n \n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n@@ -2490,7 +2490,9 @@ impl<'a> Resolver<'a> {\n                         &ident.node.name.as_str())\n                 );\n             }\n-            Some(..) if pat_src == PatternSource::Match => {\n+            Some(..) if pat_src == PatternSource::Match ||\n+                        pat_src == PatternSource::IfLet ||\n+                        pat_src == PatternSource::WhileLet => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n                 def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n@@ -3480,11 +3482,16 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+            ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n                 self.visit_expr(subexpression);\n \n                 self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n+                let mut bindings_list = FxHashMap();\n+                for pat in pats {\n+                    self.resolve_pattern(pat, PatternSource::IfLet, &mut bindings_list);\n+                }\n+                // This has to happen *after* we determine which pat_idents are variants\n+                self.check_consistent_bindings(pats);\n                 self.visit_block(if_block);\n                 self.ribs[ValueNS].pop();\n \n@@ -3500,11 +3507,16 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n+            ExprKind::WhileLet(ref pats, ref subexpression, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n                     this.visit_expr(subexpression);\n                     this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n+                    let mut bindings_list = FxHashMap();\n+                    for pat in pats {\n+                        this.resolve_pattern(pat, PatternSource::WhileLet, &mut bindings_list);\n+                    }\n+                    // This has to happen *after* we determine which pat_idents are variants\n+                    this.check_consistent_bindings(pats);\n                     this.visit_block(block);\n                     this.ribs[ValueNS].pop();\n                 });"}, {"sha": "6e98604101345a6796fd526a08955020ee430ea8", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -1031,6 +1031,81 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n+    fn process_var_decl_multi(&mut self, pats: &'l [P<ast::Pat>]) {\n+        let mut collector = PathCollector::new();\n+        for pattern in pats {\n+            // collect paths from the arm's patterns\n+            collector.visit_pat(&pattern);\n+            self.visit_pat(&pattern);\n+        }\n+\n+        // process collected paths\n+        for (id, i, sp, immut) in collector.collected_idents {\n+            match self.save_ctxt.get_path_def(id) {\n+                HirDef::Local(id) => {\n+                    let mut value = if immut == ast::Mutability::Immutable {\n+                        self.span.snippet(sp).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let typ = self.save_ctxt\n+                        .tables\n+                        .node_id_to_type_opt(hir_id)\n+                        .map(|t| t.to_string())\n+                        .unwrap_or(String::new());\n+                    value.push_str(\": \");\n+                    value.push_str(&typ);\n+\n+                    if !self.span.filter_generated(Some(sp), sp) {\n+                        let qualname = format!(\"{}${}\", i.to_string(), id);\n+                        let id = ::id_from_node_id(id, &self.save_ctxt);\n+                        let span = self.span_from_span(sp);\n+\n+                        self.dumper.dump_def(\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n+                            Def {\n+                                kind: DefKind::Local,\n+                                id,\n+                                span,\n+                                name: i.to_string(),\n+                                qualname,\n+                                value: typ,\n+                                parent: None,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: String::new(),\n+                                sig: None,\n+                                attributes: vec![],\n+                            },\n+                        );\n+                    }\n+                }\n+                HirDef::StructCtor(..) |\n+                HirDef::VariantCtor(..) |\n+                HirDef::Const(..) |\n+                HirDef::AssociatedConst(..) |\n+                HirDef::Struct(..) |\n+                HirDef::Variant(..) |\n+                HirDef::TyAlias(..) |\n+                HirDef::AssociatedTy(..) |\n+                HirDef::SelfTy(..) => {\n+                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n+                }\n+                def => error!(\n+                    \"unexpected definition kind when processing collected idents: {:?}\",\n+                    def\n+                ),\n+            }\n+        }\n+\n+        for (id, ref path) in collector.collected_paths {\n+            self.process_path(id, path);\n+        }\n+    }\n \n     fn process_var_decl(&mut self, p: &'l ast::Pat, value: String) {\n         // The local could declare multiple new vars, we must walk the\n@@ -1622,17 +1697,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     v.nest_scope(ex.id, |v| v.visit_expr(body))\n                 });\n             }\n-            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n-            ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n+            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n                 let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n-                let value = self.span.snippet(subexpression.span);\n-                self.process_var_decl(pattern, value);\n+            ast::ExprKind::WhileLet(ref pats, ref subexpression, ref block, _) => {\n+                self.process_var_decl_multi(pats);\n+                debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n+                self.visit_expr(subexpression);\n+                visit::walk_block(self, block);\n+            }\n+            ast::ExprKind::IfLet(ref pats, ref subexpression, ref block, ref opt_else) => {\n+                self.process_var_decl_multi(pats);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n                 opt_else.as_ref().map(|el| self.visit_expr(el));\n@@ -1661,79 +1740,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_arm(&mut self, arm: &'l ast::Arm) {\n-        let mut collector = PathCollector::new();\n-        for pattern in &arm.pats {\n-            // collect paths from the arm's patterns\n-            collector.visit_pat(&pattern);\n-            self.visit_pat(&pattern);\n-        }\n-\n-        // process collected paths\n-        for (id, i, sp, immut) in collector.collected_idents {\n-            match self.save_ctxt.get_path_def(id) {\n-                HirDef::Local(id) => {\n-                    let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(sp).to_string()\n-                    } else {\n-                        \"<mutable>\".to_string()\n-                    };\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                    let typ = self.save_ctxt\n-                        .tables\n-                        .node_id_to_type_opt(hir_id)\n-                        .map(|t| t.to_string())\n-                        .unwrap_or(String::new());\n-                    value.push_str(\": \");\n-                    value.push_str(&typ);\n-\n-                    if !self.span.filter_generated(Some(sp), sp) {\n-                        let qualname = format!(\"{}${}\", i.to_string(), id);\n-                        let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(sp);\n-\n-                        self.dumper.dump_def(\n-                            &Access {\n-                                public: false,\n-                                reachable: false,\n-                            },\n-                            Def {\n-                                kind: DefKind::Local,\n-                                id,\n-                                span,\n-                                name: i.to_string(),\n-                                qualname,\n-                                value: typ,\n-                                parent: None,\n-                                children: vec![],\n-                                decl_id: None,\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n-                            },\n-                        );\n-                    }\n-                }\n-                HirDef::StructCtor(..) |\n-                HirDef::VariantCtor(..) |\n-                HirDef::Const(..) |\n-                HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) |\n-                HirDef::Variant(..) |\n-                HirDef::TyAlias(..) |\n-                HirDef::AssociatedTy(..) |\n-                HirDef::SelfTy(..) => {\n-                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n-                }\n-                def => error!(\n-                    \"unexpected definition kind when processing collected idents: {:?}\",\n-                    def\n-                ),\n-            }\n-        }\n-\n-        for (id, ref path) in collector.collected_paths {\n-            self.process_path(id, path);\n-        }\n+        self.process_var_decl_multi(&arm.pats);\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n     }"}, {"sha": "6609b77b132c62f27dec7f5c3ea4c61c182a1bc9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -1085,7 +1085,7 @@ pub enum ExprKind {\n     /// `if let pat = expr { block } else { expr }`\n     ///\n     /// This is desugared to a `match` expression.\n-    IfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n+    IfLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n@@ -1095,7 +1095,7 @@ pub enum ExprKind {\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n+    WhileLet(Vec<P<Pat>>, P<Expr>, P<Block>, Option<Label>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`"}, {"sha": "04f2a0048fa781b30addab5ef3fdd1996d834331", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -449,6 +449,9 @@ declare_features! (\n \n     // Use `?` as the Kleene \"at most one\" operator\n     (active, macro_at_most_once_rep, \"1.25.0\", Some(48075)),\n+\n+    // Multiple patterns with `|` in `if let` and `while let`\n+    (active, if_while_or_patterns, \"1.26.0\", Some(48215)),\n );\n \n declare_features! (\n@@ -1686,6 +1689,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Catch(_) => {\n                 gate_feature_post!(&self, catch_expr, e.span, \"`catch` expression is experimental\");\n             }\n+            ast::ExprKind::IfLet(ref pats, ..) | ast::ExprKind::WhileLet(ref pats, ..) => {\n+                if pats.len() > 1 {\n+                    gate_feature_post!(&self, if_while_or_patterns, e.span,\n+                                    \"multiple patterns in `if let` and `while let` are unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "e8eb75f5e6018e6e97e1c39d6cdbd1caf8d79130", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -1210,8 +1210,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprKind::IfLet(pat, expr, tr, fl) => {\n-                ExprKind::IfLet(folder.fold_pat(pat),\n+            ExprKind::IfLet(pats, expr, tr, fl) => {\n+                ExprKind::IfLet(pats.move_map(|pat| folder.fold_pat(pat)),\n                           folder.fold_expr(expr),\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n@@ -1221,8 +1221,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           folder.fold_block(body),\n                           opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::WhileLet(pat, expr, body, opt_label) => {\n-                ExprKind::WhileLet(folder.fold_pat(pat),\n+            ExprKind::WhileLet(pats, expr, body, opt_label) => {\n+                ExprKind::WhileLet(pats.move_map(|pat| folder.fold_pat(pat)),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n                              opt_label.map(|label| folder.fold_label(label)))"}, {"sha": "50955f2786fc619a98493afad125cfe719bdbae8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -3226,7 +3226,7 @@ impl<'a> Parser<'a> {\n                              -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         self.expect_keyword(keywords::Let)?;\n-        let pat = self.parse_pat()?;\n+        let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n@@ -3236,7 +3236,7 @@ impl<'a> Parser<'a> {\n         } else {\n             (thn.span, None)\n         };\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pats, expr, thn, els), attrs))\n     }\n \n     // `move |args| expr`\n@@ -3327,13 +3327,13 @@ impl<'a> Parser<'a> {\n                                 span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n-        let pat = self.parse_pat()?;\n+        let pats = self.parse_pats()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_label), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pats, expr, body, opt_label), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten"}, {"sha": "9cad9f46e98cfef05af3906fc9d24a2a763a16d5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -1767,11 +1767,11 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n-                    ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n+                    ast::ExprKind::IfLet(ref pats, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if let \")?;\n-                        self.print_pat(pat)?;\n+                        self.print_pats(pats)?;\n                         self.s.space()?;\n                         self.word_space(\"=\")?;\n                         self.print_expr_as_cond(expr)?;\n@@ -1805,10 +1805,10 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,\n+    pub fn print_if_let(&mut self, pats: &[P<ast::Pat>], expr: &ast::Expr, blk: &ast::Block,\n                         elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if let\")?;\n-        self.print_pat(pat)?;\n+        self.print_pats(pats)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr_as_cond(expr)?;\n@@ -2109,8 +2109,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(test, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n-                self.print_if_let(pat, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n+            ast::ExprKind::IfLet(ref pats, ref expr, ref blk, ref elseopt) => {\n+                self.print_if_let(pats, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n@@ -2122,13 +2122,13 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_label) => {\n+            ast::ExprKind::WhileLet(ref pats, ref expr, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n-                self.print_pat(pat)?;\n+                self.print_pats(pats)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_as_cond(expr)?;\n@@ -2664,6 +2664,20 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodePat(pat))\n     }\n \n+    fn print_pats(&mut self, pats: &[P<ast::Pat>]) -> io::Result<()> {\n+        let mut first = true;\n+        for p in pats {\n+            if first {\n+                first = false;\n+            } else {\n+                self.s.space()?;\n+                self.word_space(\"|\")?;\n+            }\n+            self.print_pat(p)?;\n+        }\n+        Ok(())\n+    }\n+\n     fn print_arm(&mut self, arm: &ast::Arm) -> io::Result<()> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n@@ -2674,16 +2688,7 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         self.maybe_print_comment(arm.pats[0].span.lo())?;\n         self.print_outer_attributes(&arm.attrs)?;\n-        let mut first = true;\n-        for p in &arm.pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space()?;\n-                self.word_space(\"|\")?;\n-            }\n-            self.print_pat(p)?;\n-        }\n+        self.print_pats(&arm.pats)?;\n         self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;"}, {"sha": "640f90ecb4a4367e57d9b4b32b4f1bf1966f6279", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -705,15 +705,15 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n-            visitor.visit_pat(pattern);\n+        ExprKind::IfLet(ref pats, ref subexpression, ref if_block, ref optional_else) => {\n+            walk_list!(visitor, visit_pat, pats);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::WhileLet(ref pats, ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_pat(pattern);\n+            walk_list!(visitor, visit_pat, pats);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }"}, {"sha": "a516a3e5dcd75967253c9c9a39e57d791341bde5", "filename": "src/test/run-pass/rfc-2175-or-if-while-let/basic.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2175-or-if-while-let%2Fbasic.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(if_while_or_patterns)]\n+\n+enum E {\n+    V(u8),\n+    U(u8),\n+    W,\n+}\n+use E::*;\n+\n+fn main() {\n+    let mut e = V(10);\n+\n+    if let V(x) | U(x) = e {\n+        assert_eq!(x, 10);\n+    }\n+    while let V(x) | U(x) = e {\n+        assert_eq!(x, 10);\n+        e = W;\n+    }\n+}"}, {"sha": "3df140c77fc811e3d4f1da9528eb340ea2168e4f", "filename": "src/test/ui/feature-gate-if_while_or_patterns.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.rs?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    if let 0 | 1 = 0 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+        ;\n+    }\n+    while let 0 | 1 = 1 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+        break;\n+    }\n+}"}, {"sha": "c906fa5a2f45af5198b088a06428a2e1fcd0bec9", "filename": "src/test/ui/feature-gate-if_while_or_patterns.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8640a51ff8d580bbb87aa3dc0ff8bacbad111010/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-if_while_or_patterns.stderr?ref=8640a51ff8d580bbb87aa3dc0ff8bacbad111010", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: multiple patterns in `if let` and `while let` are unstable (see issue #48215)\n+  --> $DIR/feature-gate-if_while_or_patterns.rs:12:5\n+   |\n+12 | /     if let 0 | 1 = 0 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+13 | |         ;\n+14 | |     }\n+   | |_____^\n+   |\n+   = help: add #![feature(if_while_or_patterns)] to the crate attributes to enable\n+\n+error[E0658]: multiple patterns in `if let` and `while let` are unstable (see issue #48215)\n+  --> $DIR/feature-gate-if_while_or_patterns.rs:15:5\n+   |\n+15 | /     while let 0 | 1 = 1 { //~ ERROR multiple patterns in `if let` and `while let` are unstable\n+16 | |         break;\n+17 | |     }\n+   | |_____^\n+   |\n+   = help: add #![feature(if_while_or_patterns)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+"}]}