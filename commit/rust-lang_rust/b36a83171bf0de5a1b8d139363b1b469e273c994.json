{"sha": "b36a83171bf0de5a1b8d139363b1b469e273c994", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNmE4MzE3MWJmMGRlNWExYjhkMTM5MzYzYjFiNDY5ZTI3M2M5OTQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-16T07:40:45Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T06:03:34Z"}, "message": "Turn PrimVal into an enum including Undefined.\n\nThis is step 1 of a refactoring to fix #95. The `Undefined` variant is\nso far unused and the old `bits` and `relocation` fields are emulated\nwith two new temporary methods. There should be no functional change due\nto this commit.", "tree": {"sha": "0b9366d45e5e6a1e3e9ec6399c053232de45cc5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b9366d45e5e6a1e3e9ec6399c053232de45cc5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b36a83171bf0de5a1b8d139363b1b469e273c994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b36a83171bf0de5a1b8d139363b1b469e273c994", "html_url": "https://github.com/rust-lang/rust/commit/b36a83171bf0de5a1b8d139363b1b469e273c994", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b36a83171bf0de5a1b8d139363b1b469e273c994/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9674e507ca45309c6bf2e155a82cc29d6e626ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9674e507ca45309c6bf2e155a82cc29d6e626ef2", "html_url": "https://github.com/rust-lang/rust/commit/9674e507ca45309c6bf2e155a82cc29d6e626ef2"}], "stats": {"total": 252, "additions": 132, "deletions": 120}, "files": [{"sha": "4412bd3d41884400af0e9d12f72e6f1274d55d37", "filename": "src/cast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -20,9 +20,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             F32 => self.cast_float(val.to_f32() as f64, dest_ty),\n             F64 => self.cast_float(val.to_f64(), dest_ty),\n \n-            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits as i64, dest_ty),\n+            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits() as i64, dest_ty),\n \n-            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, dest_ty, false),\n+            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits(), dest_ty, false),\n \n             FnPtr | Ptr => self.cast_ptr(val.to_ptr(), dest_ty),\n         }\n@@ -39,15 +39,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyBool if v == 1 => Ok(PrimVal::from_bool(true)),\n             TyBool => Err(EvalError::InvalidBool),\n \n-            TyInt(IntTy::I8)  => Ok(PrimVal::new(v as i64 as i8  as u64)),\n-            TyInt(IntTy::I16) => Ok(PrimVal::new(v as i64 as i16 as u64)),\n-            TyInt(IntTy::I32) => Ok(PrimVal::new(v as i64 as i32 as u64)),\n-            TyInt(IntTy::I64) => Ok(PrimVal::new(v as i64 as i64 as u64)),\n+            TyInt(IntTy::I8)  => Ok(PrimVal::Bytes(v as i64 as i8  as u64)),\n+            TyInt(IntTy::I16) => Ok(PrimVal::Bytes(v as i64 as i16 as u64)),\n+            TyInt(IntTy::I32) => Ok(PrimVal::Bytes(v as i64 as i32 as u64)),\n+            TyInt(IntTy::I64) => Ok(PrimVal::Bytes(v as i64 as i64 as u64)),\n \n-            TyUint(UintTy::U8)  => Ok(PrimVal::new(v as u8  as u64)),\n-            TyUint(UintTy::U16) => Ok(PrimVal::new(v as u16 as u64)),\n-            TyUint(UintTy::U32) => Ok(PrimVal::new(v as u32 as u64)),\n-            TyUint(UintTy::U64) => Ok(PrimVal::new(v)),\n+            TyUint(UintTy::U8)  => Ok(PrimVal::Bytes(v as u8  as u64)),\n+            TyUint(UintTy::U16) => Ok(PrimVal::Bytes(v as u16 as u64)),\n+            TyUint(UintTy::U32) => Ok(PrimVal::Bytes(v as u32 as u64)),\n+            TyUint(UintTy::U64) => Ok(PrimVal::Bytes(v)),\n \n             TyInt(IntTy::Is) => {\n                 let int_ty = self.tcx.sess.target.int_type;\n@@ -66,10 +66,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i64 as f32)),\n             TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n \n-            TyChar if v as u8 as u64 == v => Ok(PrimVal::new(v)),\n+            TyChar if v as u8 as u64 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            TyRawPtr(_) => Ok(PrimVal::from_ptr(Pointer::from_int(v))),\n+            TyRawPtr(_) => Ok(PrimVal::Pointer(Pointer::from_int(v))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyRef(..) | TyRawPtr(_) | TyFnPtr(_) | TyInt(_) | TyUint(_) =>\n-                Ok(PrimVal::from_ptr(ptr)),\n+                Ok(PrimVal::Pointer(ptr)),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }"}, {"sha": "7ed1a17e44f5646f50e7915912e6b135c56d1d5b", "filename": "src/eval_context.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -172,15 +172,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::from_ptr(ptr), PrimVal::from_uint(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::Pointer(ptr), PrimVal::from_uint(s.len() as u64)))\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::ConstFloat;\n \n         let primval = match *const_val {\n-            Integral(const_int) => PrimVal::new(const_int.to_u64_unchecked()),\n+            Integral(const_int) => PrimVal::Bytes(const_int.to_u64_unchecked()),\n \n             Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n             Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                PrimVal::from_ptr(ptr)\n+                PrimVal::Pointer(ptr)\n             }\n \n             Struct(_)    => unimplemented!(),\n@@ -315,14 +315,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                        .expect(\"global should have been cached (freeze)\");\n                 match global_value.data.expect(\"global should have been initialized\") {\n                     Value::ByRef(ptr) => self.memory.freeze(ptr.alloc_id)?,\n-                    Value::ByVal(val) => if let Some(alloc_id) = val.relocation {\n+                    Value::ByVal(val) => if let Some(alloc_id) = val.relocation() {\n                         self.memory.freeze(alloc_id)?;\n                     },\n                     Value::ByValPair(a, b) => {\n-                        if let Some(alloc_id) = a.relocation {\n+                        if let Some(alloc_id) = a.relocation() {\n                             self.memory.freeze(alloc_id)?;\n                         }\n-                        if let Some(alloc_id) = b.relocation {\n+                        if let Some(alloc_id) = b.relocation() {\n                             self.memory.freeze(alloc_id)?;\n                         }\n                     },\n@@ -500,7 +500,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n                             let n = adt_def.variants[variant].disr_val.to_u64_unchecked();\n-                            self.write_primval(dest, PrimVal::new(n), dest_ty)?;\n+                            self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::CEnum\", kind);\n                         }\n@@ -563,12 +563,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ref(_, _, ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let (raw_ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n-                let ptr = PrimVal::from_ptr(raw_ptr);\n+                let ptr = PrimVal::Pointer(raw_ptr);\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n                     LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_uint(len)),\n-                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::from_ptr(vtable)),\n+                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Pointer(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::from_ptr(ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Pointer(ptr), dest_ty)?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnDef(def_id, substs, fn_ty) => {\n                             let fn_ty = self.tcx.erase_regions(&fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::from_ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::Pointer(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n                     },\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let (def_id, substs, _, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx, def_id, substs, unsafe_fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::from_ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::Pointer(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n@@ -1093,10 +1093,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         match ty.sty {\n-            ty::TyBool if val.bits > 1 => Err(EvalError::InvalidBool),\n+            ty::TyBool if val.bits() > 1 => Err(EvalError::InvalidBool),\n \n-            ty::TyChar if ::std::char::from_u32(val.bits as u32).is_none()\n-                => Err(EvalError::InvalidChar(val.bits as u32 as u64)),\n+            ty::TyChar if ::std::char::from_u32(val.bits() as u32).is_none()\n+                => Err(EvalError::InvalidChar(val.bits() as u32 as u64)),\n \n             _ => Ok(()),\n         }\n@@ -1150,23 +1150,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::from_ptr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::Pointer)?,\n             ty::TyBox(ty) |\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 let p = self.memory.read_ptr(ptr)?;\n                 if self.type_is_sized(ty) {\n-                    PrimVal::from_ptr(p)\n+                    PrimVal::Pointer(p)\n                 } else {\n                     trace!(\"reading fat pointer extra of type {}\", ty);\n                     let extra = ptr.offset(self.memory.pointer_size());\n                     let extra = match self.tcx.struct_tail(ty).sty {\n-                        ty::TyDynamic(..) => PrimVal::from_ptr(self.memory.read_ptr(extra)?),\n+                        ty::TyDynamic(..) => PrimVal::Pointer(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n                         ty::TyStr => PrimVal::from_uint(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n-                    return Ok(Some(Value::ByValPair(PrimVal::from_ptr(p), extra)));\n+                    return Ok(Some(Value::ByValPair(PrimVal::Pointer(p), extra)));\n                 }\n             }\n \n@@ -1225,7 +1225,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                         let ptr = src.read_ptr(&self.memory)?;\n                         let len = PrimVal::from_uint(length as u64);\n-                        let ptr = PrimVal::from_ptr(ptr);\n+                        let ptr = PrimVal::Pointer(ptr);\n                         self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n                     }\n                     (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n@@ -1239,8 +1239,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let trait_ref = self.tcx.erase_regions(&trait_ref);\n                         let vtable = self.get_vtable(trait_ref)?;\n                         let ptr = src.read_ptr(&self.memory)?;\n-                        let ptr = PrimVal::from_ptr(ptr);\n-                        let extra = PrimVal::from_ptr(vtable);\n+                        let ptr = PrimVal::Pointer(ptr);\n+                        let extra = PrimVal::Pointer(vtable);\n                         self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)?;\n                     },\n \n@@ -1301,12 +1301,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                     Value::ByVal(val) => {\n                         trace!(\"frame[{}] {:?}: {:?}\", frame, local, val);\n-                        if let Some(alloc_id) = val.relocation { allocs.push(alloc_id); }\n+                        if let Some(alloc_id) = val.relocation() { allocs.push(alloc_id); }\n                     }\n                     Value::ByValPair(val1, val2) => {\n                         trace!(\"frame[{}] {:?}: ({:?}, {:?})\", frame, local, val1, val2);\n-                        if let Some(alloc_id) = val1.relocation { allocs.push(alloc_id); }\n-                        if let Some(alloc_id) = val2.relocation { allocs.push(alloc_id); }\n+                        if let Some(alloc_id) = val1.relocation() { allocs.push(alloc_id); }\n+                        if let Some(alloc_id) = val2.relocation() { allocs.push(alloc_id); }\n                     }\n                 }\n             }"}, {"sha": "ac457966b31ab2a7fa9fba5fb6f2fd2e0c1e2d7a", "filename": "src/memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -587,18 +587,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         val: PrimVal,\n         kind: PrimValKind,\n     ) -> EvalResult<'tcx, ()> {\n-        if let Some(alloc_id) = val.relocation {\n-            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits));\n+        if let Some(alloc_id) = val.relocation() {\n+            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits()));\n         }\n \n         use value::PrimValKind::*;\n         let (size, bits) = match kind {\n-            I8 | U8 | Bool         => (1, val.bits as u8  as u64),\n-            I16 | U16              => (2, val.bits as u16 as u64),\n-            I32 | U32 | F32 | Char => (4, val.bits as u32 as u64),\n-            I64 | U64 | F64        => (8, val.bits),\n+            I8 | U8 | Bool         => (1, val.bits() as u8  as u64),\n+            I16 | U16              => (2, val.bits() as u16 as u64),\n+            I32 | U32 | F32 | Char => (4, val.bits() as u32 as u64),\n+            I64 | U64 | F64        => (8, val.bits()),\n             // int -> ptr transmutes are handled here\n-            FnPtr | Ptr            => return self.write_usize(dest, val.bits),\n+            FnPtr | Ptr            => return self.write_usize(dest, val.bits()),\n         };\n \n         self.write_uint(dest, bits, size)"}, {"sha": "9e879eaf98077fc84996973cf090196c3b339d21", "filename": "src/operator.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n macro_rules! overflow {\n     ($op:ident, $l:expr, $r:expr) => ({\n         let (val, overflowed) = $l.$op($r);\n-        let primval = PrimVal::new(val as u64);\n+        let primval = PrimVal::Bytes(val as u64);\n         Ok((primval, overflowed))\n     })\n }\n@@ -112,7 +112,7 @@ macro_rules! float_arithmetic {\n         let l = $from_bits($l);\n         let r = $from_bits($r);\n         let bits = $to_bits(l $float_op r);\n-        PrimVal::new(bits)\n+        PrimVal::Bytes(bits)\n     })\n }\n \n@@ -148,7 +148,7 @@ pub fn binary_op<'tcx>(\n         return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n     }\n \n-    let (l, r) = (left.bits, right.bits);\n+    let (l, r) = (left.bits(), right.bits());\n \n     // These ops can have an RHS with a different numeric type.\n     if bin_op == Shl || bin_op == Shr {\n@@ -165,7 +165,7 @@ pub fn binary_op<'tcx>(\n \n         // Cast to `u32` because `overflowing_sh{l,r}` only take `u32`, then apply the bitmask\n         // to ensure it's within the valid shift value range.\n-        let r = (right.bits as u32) & (type_bits - 1);\n+        let r = (right.bits() as u32) & (type_bits - 1);\n \n         return match bin_op {\n             Shl => int_shift!(left_kind, overflowing_shl, l, r),\n@@ -213,9 +213,9 @@ pub fn binary_op<'tcx>(\n         (Gt, _) => PrimVal::from_bool(l >  r),\n         (Ge, _) => PrimVal::from_bool(l >= r),\n \n-        (BitOr,  _) => PrimVal::new(l | r),\n-        (BitAnd, _) => PrimVal::new(l & r),\n-        (BitXor, _) => PrimVal::new(l ^ r),\n+        (BitOr,  _) => PrimVal::Bytes(l | r),\n+        (BitAnd, _) => PrimVal::Bytes(l & r),\n+        (BitXor, _) => PrimVal::Bytes(l ^ r),\n \n         (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n         (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n@@ -254,31 +254,31 @@ pub fn unary_op<'tcx>(\n     use value::PrimValKind::*;\n \n     let bits = match (un_op, val_kind) {\n-        (Not, Bool) => !bits_to_bool(val.bits) as u64,\n+        (Not, Bool) => !bits_to_bool(val.bits()) as u64,\n \n-        (Not, U8)  => !(val.bits as u8) as u64,\n-        (Not, U16) => !(val.bits as u16) as u64,\n-        (Not, U32) => !(val.bits as u32) as u64,\n-        (Not, U64) => !val.bits,\n+        (Not, U8)  => !(val.bits() as u8) as u64,\n+        (Not, U16) => !(val.bits() as u16) as u64,\n+        (Not, U32) => !(val.bits() as u32) as u64,\n+        (Not, U64) => !val.bits(),\n \n-        (Not, I8)  => !(val.bits as i8) as u64,\n-        (Not, I16) => !(val.bits as i16) as u64,\n-        (Not, I32) => !(val.bits as i32) as u64,\n-        (Not, I64) => !(val.bits as i64) as u64,\n+        (Not, I8)  => !(val.bits() as i8) as u64,\n+        (Not, I16) => !(val.bits() as i16) as u64,\n+        (Not, I32) => !(val.bits() as i32) as u64,\n+        (Not, I64) => !(val.bits() as i64) as u64,\n \n-        (Neg, I8)  => -(val.bits as i8) as u64,\n-        (Neg, I16) => -(val.bits as i16) as u64,\n-        (Neg, I32) => -(val.bits as i32) as u64,\n-        (Neg, I64) => -(val.bits as i64) as u64,\n+        (Neg, I8)  => -(val.bits() as i8) as u64,\n+        (Neg, I16) => -(val.bits() as i16) as u64,\n+        (Neg, I32) => -(val.bits() as i32) as u64,\n+        (Neg, I64) => -(val.bits() as i64) as u64,\n \n-        (Neg, F32) => f32_to_bits(-bits_to_f32(val.bits)),\n-        (Neg, F64) => f64_to_bits(-bits_to_f64(val.bits)),\n+        (Neg, F32) => f32_to_bits(-bits_to_f32(val.bits())),\n+        (Neg, F64) => f64_to_bits(-bits_to_f64(val.bits())),\n \n         _ => {\n             let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n             return Err(EvalError::Unimplemented(msg));\n         }\n     };\n \n-    Ok(PrimVal::new(bits))\n+    Ok(PrimVal::Bytes(bits))\n }"}, {"sha": "de9c972ffd41b471e96b31a0dd8b7d7c2216f6fd", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n                 let new_ptr = ptr.signed_offset(offset);\n-                self.write_primval(dest, PrimVal::from_ptr(new_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Pointer(new_ptr), dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.write_primval(dest, PrimVal::new(discr_val), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n \n             \"drop_in_place\" => {\n@@ -235,16 +235,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Value::ByRef(ptr)\n                         },\n                         None => match this.ty_to_primval_kind(dest_ty) {\n-                            Ok(_) => Value::ByVal(PrimVal::new(0)),\n+                            Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n                                 this.memory.write_repeat(ptr, 0, size)?;\n                                 Value::ByRef(ptr)\n                             }\n                         },\n-                        Some(Value::ByVal(_)) => Value::ByVal(PrimVal::new(0)),\n+                        Some(Value::ByVal(_)) => Value::ByVal(PrimVal::Bytes(0)),\n                         Some(Value::ByValPair(..)) =>\n-                            Value::ByValPair(PrimVal::new(0), PrimVal::new(0)),\n+                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0)),\n                     };\n                     Ok(Some(zero_val))\n                 };\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.signed_offset(offset * pointee_size);\n-                self.write_primval(dest, PrimVal::from_ptr(result_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Pointer(result_ptr), dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::new(n), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n             }\n \n             \"transmute\" => {\n@@ -507,18 +507,18 @@ macro_rules! integer_intrinsic {\n \n         use value::PrimValKind::*;\n         let bits = match $kind {\n-            I8 => (val.bits as i8).$method() as u64,\n-            U8 => (val.bits as u8).$method() as u64,\n-            I16 => (val.bits as i16).$method() as u64,\n-            U16 => (val.bits as u16).$method() as u64,\n-            I32 => (val.bits as i32).$method() as u64,\n-            U32 => (val.bits as u32).$method() as u64,\n-            I64 => (val.bits as i64).$method() as u64,\n-            U64 => (val.bits as u64).$method() as u64,\n+            I8 => (val.bits() as i8).$method() as u64,\n+            U8 => (val.bits() as u8).$method() as u64,\n+            I16 => (val.bits() as i16).$method() as u64,\n+            U16 => (val.bits() as u16).$method() as u64,\n+            I32 => (val.bits() as i32).$method() as u64,\n+            U32 => (val.bits() as u32).$method() as u64,\n+            I64 => (val.bits() as i64).$method() as u64,\n+            U64 => (val.bits() as u64).$method() as u64,\n             _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n         };\n \n-        PrimVal::new(bits)\n+        PrimVal::Bytes(bits)\n     });\n }\n "}, {"sha": "c48a8a72c3d5ce87fbbad7fafb2d2c217252aa48", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.value_to_primval(args[0], usize)?.to_u64();\n                 let align = self.value_to_primval(args[1], usize)?.to_u64();\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.write_primval(dest, PrimVal::from_ptr(ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Pointer(ptr), dest_ty)?;\n             }\n \n             \"__rust_deallocate\" => {\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.value_to_primval(args[2], usize)?.to_u64();\n                 let align = self.value_to_primval(args[3], usize)?.to_u64();\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n-                self.write_primval(dest, PrimVal::from_ptr(new_ptr), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Pointer(new_ptr), dest_ty)?;\n             }\n \n             \"memcmp\" => {\n@@ -372,7 +372,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                self.write_primval(dest, PrimVal::new(result as u64), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(result as u64), dest_ty)?;\n             }\n \n             \"memchr\" => {\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 ptr\n                             },\n                         };\n-                        args[0].0 = Value::ByVal(PrimVal::from_ptr(ptr));\n+                        args[0].0 = Value::ByVal(PrimVal::Pointer(ptr));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n \n@@ -550,7 +550,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n                     let (self_ptr, vtable) = first_arg.expect_ptr_vtable_pair(&self.memory)?;\n-                    *first_arg = Value::ByVal(PrimVal::from_ptr(self_ptr));\n+                    *first_arg = Value::ByVal(PrimVal::Pointer(self_ptr));\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n@@ -633,7 +633,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 // run drop impl before the fields' drop impls\n                 if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, Value::ByVal(PrimVal::from_ptr(adt_ptr)), substs));\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::Pointer(adt_ptr)), substs));\n                 }\n                 let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n@@ -701,7 +701,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let (def_id, substs, _abi, sig) = self.memory.get_fn(drop_fn.alloc_id)?;\n                     let real_ty = sig.inputs()[0];\n                     self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                    drop.push((def_id, Value::ByVal(PrimVal::from_ptr(ptr)), substs));\n+                    drop.push((def_id, Value::ByVal(PrimVal::Pointer(ptr)), substs));\n                 } else {\n                     // just a sanity check\n                     assert_eq!(drop_fn.offset, 0);"}, {"sha": "7055548095d07288079c23993beeb8bfc3c977ff", "filename": "src/value.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36a83171bf0de5a1b8d139363b1b469e273c994/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=b36a83171bf0de5a1b8d139363b1b469e273c994", "patch": "@@ -46,13 +46,17 @@ pub enum Value {\n /// A `PrimVal` represents an immediate, primitive value existing outside of an allocation. It is\n /// considered to be like a\n #[derive(Clone, Copy, Debug, PartialEq)]\n-pub struct PrimVal {\n-    pub bits: u64,\n+pub enum PrimVal {\n+    Bytes(u64),\n \n+    // FIXME(solson): Rename this variant to Ptr.\n+    // FIXME(solson): Outdated comment, pulled from `relocations` field I deleted.\n     /// This field is initialized when the `PrimVal` represents a pointer into an `Allocation`. An\n     /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n     /// large enough to contain one, hence the `Option`.\n-    pub relocation: Option<AllocId>,\n+    Pointer(Pointer),\n+\n+    Undefined,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n@@ -110,56 +114,64 @@ impl<'a, 'tcx: 'a> Value {\n }\n \n impl PrimVal {\n-    pub fn new(bits: u64) -> Self {\n-        PrimVal { bits: bits, relocation: None }\n-    }\n-\n-    pub fn new_with_relocation(bits: u64, alloc_id: AllocId) -> Self {\n-        PrimVal { bits: bits, relocation: Some(alloc_id) }\n+    // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n+    // stick around with this name.\n+    pub fn bits(&self) -> u64 {\n+        match *self {\n+            PrimVal::Bytes(b) => b,\n+            PrimVal::Pointer(p) => p.offset,\n+            PrimVal::Undefined => panic!(\".bits()() on PrimVal::Undefined\"),\n+        }\n     }\n \n-    pub fn from_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new_with_relocation(ptr.offset as u64, ptr.alloc_id)\n+    // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n+    // stick around with this name.\n+    pub fn relocation(&self) -> Option<AllocId> {\n+        if let PrimVal::Pointer(ref p) = *self {\n+            Some(p.alloc_id)\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        PrimVal::new(b as u64)\n+        PrimVal::Bytes(b as u64)\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        PrimVal::new(c as u64)\n+        PrimVal::Bytes(c as u64)\n     }\n \n     pub fn from_f32(f: f32) -> Self {\n-        PrimVal::new(f32_to_bits(f))\n+        PrimVal::Bytes(f32_to_bits(f))\n     }\n \n     pub fn from_f64(f: f64) -> Self {\n-        PrimVal::new(f64_to_bits(f))\n+        PrimVal::Bytes(f64_to_bits(f))\n     }\n \n     pub fn from_uint(n: u64) -> Self {\n-        PrimVal::new(n)\n+        PrimVal::Bytes(n)\n     }\n \n     pub fn from_int(n: i64) -> Self {\n-        PrimVal::new(n as u64)\n+        PrimVal::Bytes(n as u64)\n     }\n \n     pub fn to_f32(self) -> f32 {\n-        assert!(self.relocation.is_none());\n-        bits_to_f32(self.bits)\n+        assert!(self.relocation().is_none());\n+        bits_to_f32(self.bits())\n     }\n \n     pub fn to_f64(self) -> f64 {\n-        assert!(self.relocation.is_none());\n-        bits_to_f64(self.bits)\n+        assert!(self.relocation().is_none());\n+        bits_to_f64(self.bits())\n     }\n \n     pub fn to_ptr(self) -> Pointer {\n-        self.relocation.map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits)\n-        }).unwrap_or_else(|| Pointer::from_int(self.bits))\n+        self.relocation().map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits())\n+        }).unwrap_or_else(|| Pointer::from_int(self.bits()))\n     }\n \n     pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n@@ -170,24 +182,24 @@ impl PrimVal {\n         if let Some(ptr) = self.try_as_ptr() {\n             return ptr.to_int().expect(\"non abstract ptr\") as u64;\n         }\n-        self.bits\n+        self.bits()\n     }\n \n     pub fn to_i64(self) -> i64 {\n         if let Some(ptr) = self.try_as_ptr() {\n             return ptr.to_int().expect(\"non abstract ptr\") as i64;\n         }\n-        self.bits as i64\n+        self.bits() as i64\n     }\n \n     pub fn try_as_ptr(self) -> Option<Pointer> {\n-        self.relocation.map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits)\n+        self.relocation().map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits())\n         })\n     }\n \n     pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n-        match self.bits {\n+        match self.bits() {\n             0 => Ok(false),\n             1 => Ok(true),\n             _ => Err(EvalError::InvalidBool),"}]}