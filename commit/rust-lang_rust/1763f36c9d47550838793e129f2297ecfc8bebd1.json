{"sha": "1763f36c9d47550838793e129f2297ecfc8bebd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NjNmMzZjOWQ0NzU1MDgzODc5M2UxMjlmMjI5N2VjZmM4YmViZDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-27T02:28:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-28T01:41:04Z"}, "message": "Bring native process bindings up to date\n\nMove the tests into libstd, use the `iotest!` macro to test both native and uv\nbindings, and use the cloexec trick to figure out when the child process fails\nin exec.", "tree": {"sha": "67036da1dac631ab73b437c96d276c35d3949717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67036da1dac631ab73b437c96d276c35d3949717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1763f36c9d47550838793e129f2297ecfc8bebd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1763f36c9d47550838793e129f2297ecfc8bebd1", "html_url": "https://github.com/rust-lang/rust/commit/1763f36c9d47550838793e129f2297ecfc8bebd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1763f36c9d47550838793e129f2297ecfc8bebd1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "html_url": "https://github.com/rust-lang/rust/commit/00d87e0d8198ffb268251b5af2eb2ce19249c7f8"}], "stats": {"total": 542, "additions": 288, "deletions": 254}, "files": [{"sha": "543132cce1561f5a358fa0cacec3b393d914d0f1", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -37,7 +37,7 @@ fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n         let mut ret;\n         loop {\n             ret = f(data, amt);\n-            if cfg!(not(windows)) { break } // windows has no eintr\n+            if cfg!(windows) { break } // windows has no eintr\n             // if we get an eintr, then try again\n             if ret != -1 || os::errno() as int != eintr { break }\n         }\n@@ -73,7 +73,10 @@ impl FileDesc {\n         FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    // FIXME(#10465) these functions should not be public, but anything in\n+    //               native::io wanting to use them is forced to have all the\n+    //               rtio traits in scope\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n         let ret = keep_going(buf, |buf, len| {\n@@ -899,7 +902,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{CFile, FileDesc};\n+    use super::{CFile, FileDesc, CloseFd};\n     use std::io;\n     use std::libc;\n     use std::os;"}, {"sha": "5609614234922c1aa831fcd4f2ba319d0e7322ee", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -55,7 +55,7 @@ fn unimpl() -> IoError {\n     }\n }\n \n-fn last_error() -> IoError {\n+fn translate_error(errno: i32, detail: bool) -> IoError {\n     #[cfg(windows)]\n     fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n         match errno {\n@@ -79,14 +79,16 @@ fn last_error() -> IoError {\n         }\n     }\n \n-    let (kind, desc) = get_err(os::errno() as i32);\n+    let (kind, desc) = get_err(errno);\n     IoError {\n         kind: kind,\n         desc: desc,\n-        detail: Some(os::last_os_error())\n+        detail: if detail {Some(os::last_os_error())} else {None},\n     }\n }\n \n+fn last_error() -> IoError { translate_error(os::errno() as i32, true) }\n+\n // unix has nonzero values as errors\n fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n     if ret != 0 {\n@@ -106,6 +108,17 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     }\n }\n \n+#[cfg(unix)]\n+fn retry(f: || -> libc::c_int) -> IoResult<libc::c_int> {\n+    loop {\n+        match f() {\n+            -1 if os::errno() as int == libc::EINTR as int => {}\n+            -1 => return Err(last_error()),\n+            n => return Ok(n),\n+        }\n+    }\n+}\n+\n /// Implementation of rt::rtio's IoFactory trait to generate handles to the\n /// native I/O functionality.\n pub struct IoFactory;"}, {"sha": "33abb27f16b34f64f8ececcf7c92ddb5e94f72dc", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -18,6 +18,7 @@ use p = std::io::process;\n \n #[cfg(windows)] use std::cast;\n \n+use super::IoResult;\n use super::file;\n \n /**\n@@ -37,7 +38,7 @@ pub struct Process {\n     priv handle: *(),\n \n     /// None until finish() is called.\n-    priv exit_code: Option<int>,\n+    priv exit_code: Option<p::ProcessExit>,\n }\n \n impl Process {\n@@ -105,23 +106,28 @@ impl Process {\n             for pipe in err_pipe.iter() { libc::close(pipe.out); }\n         }\n \n-        Ok((Process { pid: res.pid, handle: res.handle, exit_code: None }, ret_io))\n+        match res {\n+            Ok(res) => {\n+                Ok((Process { pid: res.pid, handle: res.handle, exit_code: None },\n+                    ret_io))\n+            }\n+            Err(e) => Err(e)\n+        }\n     }\n }\n \n impl rtio::RtioProcess for Process {\n     fn id(&self) -> pid_t { self.pid }\n \n     fn wait(&mut self) -> p::ProcessExit {\n-        let code = match self.exit_code {\n+        match self.exit_code {\n             Some(code) => code,\n             None => {\n                 let code = waitpid(self.pid);\n                 self.exit_code = Some(code);\n                 code\n             }\n-        };\n-        return p::ExitStatus(code); // XXX: this is wrong\n+        }\n     }\n \n     fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n@@ -177,7 +183,8 @@ struct SpawnProcessResult {\n fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+                    in_fd: c_int, out_fd: c_int,\n+                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use std::libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use std::libc::consts::os::extra::{\n         TRUE, FALSE,\n@@ -241,7 +248,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n                     if created == FALSE {\n-                        create_err = Some(os::last_os_error());\n+                        create_err = Some(super::last_error());\n                     }\n                 })\n             })\n@@ -251,21 +258,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdOutput);\n         CloseHandle(si.hStdError);\n \n-        for msg in create_err.iter() {\n-            fail!(\"failure in CreateProcess: {}\", *msg);\n+        match create_err {\n+            Some(err) => return Err(err),\n+            None => {}\n         }\n \n-        // We close the thread handle because std::we don't care about keeping the\n+        // We close the thread handle because we don't care about keeping the\n         // thread id valid, and we aren't keeping the thread handle around to be\n         // able to close it later. We don't close the process handle however\n         // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n         CloseHandle(pi.hThread);\n \n-        SpawnProcessResult {\n+        Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n             handle: pi.hProcess as *()\n-        }\n+        })\n     }\n }\n \n@@ -303,9 +311,8 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n     }\n }\n \n-// FIXME: this is only pub so it can be tested (see issue #4536)\n #[cfg(windows)]\n-pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     let mut cmd = ~\"\";\n     append_arg(&mut cmd, prog);\n     for arg in args.iter() {\n@@ -360,55 +367,102 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+                    in_fd: c_int, out_fd: c_int,\n+                    err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use std::libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use std::libc::funcs::bsd44::getdtablesize;\n+    use std::libc::c_ulong;\n+    use std::unstable::intrinsics;\n \n     mod rustrt {\n         extern {\n             pub fn rust_unset_sigprocmask();\n         }\n     }\n \n-    #[cfg(windows)]\n-    unsafe fn set_environ(_envp: *c_void) {}\n     #[cfg(target_os = \"macos\")]\n     unsafe fn set_environ(envp: *c_void) {\n         extern { fn _NSGetEnviron() -> *mut *c_void; }\n \n         *_NSGetEnviron() = envp;\n     }\n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    #[cfg(not(target_os = \"macos\"))]\n     unsafe fn set_environ(envp: *c_void) {\n-        extern {\n-            static mut environ: *c_void;\n-        }\n+        extern { static mut environ: *c_void; }\n         environ = envp;\n     }\n \n-    unsafe {\n+    unsafe fn set_cloexec(fd: c_int) {\n+        extern { fn ioctl(fd: c_int, req: c_ulong) -> c_int; }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        static FIOCLEX: c_ulong = 0x20006601;\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        static FIOCLEX: c_ulong = 0x5451;\n+\n+        let ret = ioctl(fd, FIOCLEX);\n+        assert_eq!(ret, 0);\n+    }\n+\n+    let pipe = os::pipe();\n+    let mut input = file::FileDesc::new(pipe.input, file::CloseFd);\n+    let mut output = file::FileDesc::new(pipe.out, file::CloseFd);\n+\n+    unsafe { set_cloexec(output.fd()) };\n \n+    unsafe {\n         let pid = fork();\n         if pid < 0 {\n             fail!(\"failure in fork: {}\", os::last_os_error());\n         } else if pid > 0 {\n-            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n+            drop(output);\n+            let mut bytes = [0, ..4];\n+            return match input.inner_read(bytes) {\n+                Ok(4) => {\n+                    let errno = (bytes[0] << 24) as i32 |\n+                                (bytes[1] << 16) as i32 |\n+                                (bytes[2] <<  8) as i32 |\n+                                (bytes[3] <<  0) as i32;\n+                    Err(super::translate_error(errno, false))\n+                }\n+                Err(e) => {\n+                    assert!(e.kind == io::BrokenPipe ||\n+                            e.kind == io::EndOfFile,\n+                            \"unexpected error: {:?}\", e);\n+                    Ok(SpawnProcessResult {\n+                        pid: pid,\n+                        handle: ptr::null()\n+                    })\n+                }\n+                Ok(..) => fail!(\"short read on the cloexec pipe\"),\n+            };\n         }\n+        drop(input);\n \n         rustrt::rust_unset_sigprocmask();\n \n-        if dup2(in_fd, 0) == -1 {\n+        if in_fd == -1 {\n+            libc::close(libc::STDIN_FILENO);\n+        } else if dup2(in_fd, 0) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n-        if dup2(out_fd, 1) == -1 {\n+        if out_fd == -1 {\n+            libc::close(libc::STDOUT_FILENO);\n+        } else if dup2(out_fd, 1) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n-        if dup2(err_fd, 2) == -1 {\n+        if err_fd == -1 {\n+            libc::close(libc::STDERR_FILENO);\n+        } else if dup2(err_fd, 2) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).invert() {\n-            close(fd as c_int);\n+            if fd != output.fd() {\n+                close(fd as c_int);\n+            }\n         }\n \n         with_dirp(dir, |dirp| {\n@@ -421,11 +475,18 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            with_argv(prog, args, |argv| {\n-                execvp(*argv, argv);\n-                // execvp only returns if an error occurred\n-                fail!(\"failure in execvp: {}\", os::last_os_error());\n-            })\n+        });\n+        with_argv(prog, args, |argv| {\n+            execvp(*argv, argv);\n+            let errno = os::errno();\n+            let bytes = [\n+                (errno << 24) as u8,\n+                (errno << 16) as u8,\n+                (errno <<  8) as u8,\n+                (errno <<  0) as u8,\n+            ];\n+            output.inner_write(bytes);\n+            intrinsics::abort();\n         })\n     }\n }\n@@ -534,11 +595,11 @@ fn free_handle(_handle: *()) {\n  * operate on a none-existent process or, even worse, on a newer process\n  * with the same id.\n  */\n-fn waitpid(pid: pid_t) -> int {\n+fn waitpid(pid: pid_t) -> p::ProcessExit {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> int {\n+    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n         use std::libc::types::os::arch::extra::DWORD;\n         use std::libc::consts::os::extra::{\n             SYNCHRONIZE,\n@@ -572,7 +633,7 @@ fn waitpid(pid: pid_t) -> int {\n                 }\n                 if status != STILL_ACTIVE {\n                     CloseHandle(process);\n-                    return status as int;\n+                    return p::ExitStatus(status as int);\n                 }\n                 if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n                     CloseHandle(process);\n@@ -583,43 +644,36 @@ fn waitpid(pid: pid_t) -> int {\n     }\n \n     #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> int {\n+    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n         use std::libc::funcs::posix01::wait;\n \n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0xffi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0x7fi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            (status >> 8i32) & 0xffi32\n+        mod imp {\n+            pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+            pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+            pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n         }\n \n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            status >> 8i32\n+        mod imp {\n+            pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+            pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+            pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n         }\n \n         let mut status = 0 as c_int;\n-        if unsafe { wait::waitpid(pid, &mut status, 0) } == -1 {\n-            fail!(\"failure in waitpid: {}\", os::last_os_error());\n+        match super::retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+            Err(e) => fail!(\"unknown waitpid error: {:?}\", e),\n+            Ok(_ret) => {\n+                if imp::WIFEXITED(status) {\n+                    p::ExitStatus(imp::WEXITSTATUS(status) as int)\n+                } else {\n+                    p::ExitSignal(imp::WTERMSIG(status) as int)\n+                }\n+            }\n         }\n-\n-        return if WIFEXITED(status) {\n-            WEXITSTATUS(status) as int\n-        } else {\n-            1\n-        };\n     }\n }\n \n@@ -646,8 +700,4 @@ mod tests {\n             ~\"echo \\\"a b c\\\"\"\n         );\n     }\n-\n-    // Currently most of the tests of this functionality live inside std::run,\n-    // but they may move here eventually as a non-blocking backend is added to\n-    // std::run\n }"}, {"sha": "9b8a8b57e678e7d54cc7a749e745cb0126073de3", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -117,7 +117,6 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io;\n-    use comm;\n     use task;\n \n     #[test]"}, {"sha": "c963057acdea2c3bbeb81a74114b5fb889a1e4a6", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -134,9 +134,8 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use io::net::ip::{Ipv4Addr, SocketAddr};\n+    use io::net::ip::SocketAddr;\n     use io::*;\n-    use io::test::{next_test_ip4, next_test_ip6};\n     use prelude::*;\n \n     #[test] #[ignore]"}, {"sha": "a8b7e8e00ead01139d0fbfeca6203c13729881d1", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 149, "deletions": 2, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -169,5 +169,152 @@ impl Drop for Process {\n     }\n }\n \n-// Tests for this module can be found in the rtio-processes run-pass test, along\n-// with the justification for why it's not located here.\n+#[cfg(test)]\n+mod tests {\n+    use io::process::{ProcessConfig, Process};\n+    use prelude::*;\n+    use str;\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn smoke() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"true\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().success());\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn smoke_failure() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"if-this-is-a-binary-then-the-world-has-ended\",\n+            args: [],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        match io::result(|| Process::new(args)) {\n+            Ok(..) => fail!(),\n+            Err(..) => {}\n+        }\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn exit_reported_right() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"exit 1\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().matches_exit_status(1));\n+    })\n+\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn signal_reported_right() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"kill -1 $$\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        match p.wait() {\n+            process::ExitSignal(1) => {},\n+            result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n+        }\n+    })\n+\n+    pub fn read_all(input: &mut Reader) -> ~str {\n+        let mut ret = ~\"\";\n+        let mut buf = [0, ..1024];\n+        loop {\n+            match input.read(buf) {\n+                None => { break }\n+                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    pub fn run_output(args: ProcessConfig) -> ~str {\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.io[0].is_none());\n+        assert!(p.io[1].is_some());\n+        let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert!(p.wait().success());\n+        return ret;\n+    }\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn stdout_works() {\n+        let io = ~[Ignored, CreatePipe(false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"echo foobar\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"foobar\\n\");\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn set_cwd_works() {\n+        let io = ~[Ignored, CreatePipe(false, true)];\n+        let cwd = Some(\"/\");\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"pwd\"],\n+            env: None,\n+            cwd: cwd,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"/\\n\");\n+    })\n+\n+    // FIXME(#10380)\n+    #[cfg(unix, not(target_os=\"android\"))]\n+    iotest!(fn stdin_works() {\n+        let io = ~[CreatePipe(true, false),\n+                   CreatePipe(false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"read line; echo $line\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n+        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+        p.io[0] = None; // close stdin;\n+        let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert!(p.wait().success());\n+        assert_eq!(out, ~\"foobar\\n\");\n+    })\n+\n+}"}, {"sha": "c189bd47b06aaad1cc122f0be7d726c5b770abbd", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -33,6 +33,7 @@ macro_rules! iotest (\n             use io::net::udp::*;\n             #[cfg(unix)]\n             use io::net::unix::*;\n+            use io::process::*;\n             use str;\n             use util;\n "}, {"sha": "33be746e604d94c590c8db45b647871fd9a2d744", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1763f36c9d47550838793e129f2297ecfc8bebd1/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=1763f36c9d47550838793e129f2297ecfc8bebd1", "patch": "@@ -339,7 +339,7 @@ mod tests {\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::pipe::PipeStream;\n-    use io::{Writer, Reader, io_error, FileNotFound, OtherIoError};\n+    use io::{Writer, Reader, io_error, FileNotFound};\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)"}, {"sha": "6463a1d5321716350c6f739599d7108e3850bee8", "filename": "src/test/run-pass/rtio-processes.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d87e0d8198ffb268251b5af2eb2ce19249c7f8/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=00d87e0d8198ffb268251b5af2eb2ce19249c7f8", "patch": "@@ -1,178 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: --test\n-// xfail-fast\n-\n-// In the current state of affairs, libuv registers a SIGCHLD handler when a\n-// process is spawned through it. This is not done with a SA_RESTART flag,\n-// meaning that all of our syscalls run the risk of returning EINTR. This error\n-// is not correctly handled in the majority of std::io, so these can't run with\n-// the main body of tests there.\n-//\n-// That being said, libuv correctly handles EINTR completely, so these tests\n-// themselves are safe against that. Currently the test runner may run into this\n-// problem, but it's less likely than a whole suite of tests...\n-//\n-// See #9341\n-\n-use std::io;\n-use std::io::process;\n-use std::io::process::{Process, ProcessConfig, CreatePipe, Ignored};\n-use std::str;\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn smoke() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"true\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.wait().success());\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn smoke_failure() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"if-this-is-a-binary-then-the-world-has-ended\",\n-        args: [],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    match io::result(|| Process::new(args)) {\n-        Ok(..) => fail!(),\n-        Err(..) => {}\n-    }\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn exit_reported_right() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"exit 1\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.wait().matches_exit_status(1));\n-}\n-\n-#[test]\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn signal_reported_right() {\n-    let io = ~[];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"kill -1 $$\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    match p.wait() {\n-        process::ExitSignal(1) => {},\n-        result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n-    }\n-}\n-\n-fn read_all(input: &mut Reader) -> ~str {\n-    let mut ret = ~\"\";\n-    let mut buf = [0, ..1024];\n-    loop {\n-        match input.read(buf) {\n-            None => { break }\n-            Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n-        }\n-    }\n-    return ret;\n-}\n-\n-fn run_output(args: ProcessConfig) -> ~str {\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.io[0].is_none());\n-    assert!(p.io[1].is_some());\n-    let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert!(p.wait().success());\n-    return ret;\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn stdout_works() {\n-    let io = ~[Ignored, CreatePipe(false, true)];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"echo foobar\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    assert_eq!(run_output(args), ~\"foobar\\n\");\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn set_cwd_works() {\n-    let io = ~[Ignored, CreatePipe(false, true)];\n-    let cwd = Some(\"/\");\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"pwd\"],\n-        env: None,\n-        cwd: cwd,\n-        io: io,\n-    };\n-    assert_eq!(run_output(args), ~\"/\\n\");\n-}\n-\n-#[test]\n-// FIXME(#10380)\n-#[cfg(unix, not(target_os=\"android\"))]\n-fn stdin_works() {\n-    let io = ~[CreatePipe(true, false),\n-               CreatePipe(false, true)];\n-    let args = ProcessConfig {\n-        program: \"/bin/sh\",\n-        args: [~\"-c\", ~\"read line; echo $line\"],\n-        env: None,\n-        cwd: None,\n-        io: io,\n-    };\n-    let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n-    p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n-    p.io[0] = None; // close stdin;\n-    let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n-    assert!(p.wait().success());\n-    assert_eq!(out, ~\"foobar\\n\");\n-}"}]}