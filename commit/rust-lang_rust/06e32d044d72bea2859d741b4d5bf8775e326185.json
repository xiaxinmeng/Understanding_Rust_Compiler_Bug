{"sha": "06e32d044d72bea2859d741b4d5bf8775e326185", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZTMyZDA0NGQ3MmJlYTI4NTlkNzQxYjRkNWJmODc3NWUzMjYxODU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-01-16T21:05:13Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-01-16T21:23:11Z"}, "message": "avoid double-unsizing arrays in bytestring match lowering\n\nThe match lowering code, when lowering matches against bytestrings,\nworks by coercing both the scrutinee and the pattern to `&[u8]` and\nthen comparing them using `<[u8] as Eq>::eq`.\n\nIf the scrutinee is already of type `&[u8]`, then unsizing it is both\nunneccessary and a trait error caught by the new and updated MIR typeck,\nso this PR changes lowering to avoid doing that (match lowering tried to\navoid that before, but that attempt was quite broken).\n\nFixes #46920.", "tree": {"sha": "0429c624fd252ab182c416f4df26c0cdfda56e9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0429c624fd252ab182c416f4df26c0cdfda56e9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06e32d044d72bea2859d741b4d5bf8775e326185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06e32d044d72bea2859d741b4d5bf8775e326185", "html_url": "https://github.com/rust-lang/rust/commit/06e32d044d72bea2859d741b4d5bf8775e326185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06e32d044d72bea2859d741b4d5bf8775e326185/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6072a7b3835f1875e81c9fd27799f9b20a0770c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6072a7b3835f1875e81c9fd27799f9b20a0770c", "html_url": "https://github.com/rust-lang/rust/commit/e6072a7b3835f1875e81c9fd27799f9b20a0770c"}], "stats": {"total": 111, "additions": 88, "deletions": 23}, "files": [{"sha": "bdcbfc0bdd85e9f6506216ac340d219cfcdb67a3", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/06e32d044d72bea2859d741b4d5bf8775e326185/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e32d044d72bea2859d741b4d5bf8775e326185/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=06e32d044d72bea2859d741b4d5bf8775e326185", "patch": "@@ -174,12 +174,50 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Convert a byte array or byte slice to a byte slice.\n+    fn to_slice_operand(&mut self,\n+                        block: BasicBlock,\n+                        source_info: SourceInfo,\n+                        operand: Operand<'tcx>)\n+                        -> Operand<'tcx>\n+    {\n+        let tcx = self.hir.tcx();\n+        let ty = operand.ty(&self.local_decls, tcx);\n+        debug!(\"to_slice_operand({:?}, {:?}: {:?})\", block, operand, ty);\n+        match ty.sty {\n+            ty::TyRef(region, mt) => match mt.ty.sty {\n+                ty::TyArray(ety, _) => {\n+                    let ty = tcx.mk_imm_ref(region, tcx.mk_slice(ety));\n+                    let temp = self.temp(ty, source_info.span);\n+                    self.cfg.push_assign(block, source_info, &temp,\n+                                         Rvalue::Cast(CastKind::Unsize, operand, ty));\n+                    Operand::Move(temp)\n+                }\n+                ty::TySlice(_) => operand,\n+                _ => {\n+                    span_bug!(source_info.span,\n+                              \"bad operand {:?}: {:?} to `to_slice_operand`\", operand, ty)\n+                }\n+            }\n+            _ => {\n+                span_bug!(source_info.span,\n+                          \"bad operand {:?}: {:?} to `to_slice_operand`\", operand, ty)\n+            }\n+        }\n+\n+    }\n+\n     /// Generates the code to perform a test.\n     pub fn perform_test(&mut self,\n                         block: BasicBlock,\n                         place: &Place<'tcx>,\n                         test: &Test<'tcx>)\n                         -> Vec<BasicBlock> {\n+        debug!(\"perform_test({:?}, {:?}: {:?}, {:?})\",\n+               block,\n+               place,\n+               place.ty(&self.local_decls, self.hir.tcx()),\n+               test);\n         let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n@@ -258,45 +296,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ret\n             }\n \n-            TestKind::Eq { value, mut ty } => {\n+            TestKind::Eq { value, ty } => {\n+                let tcx = self.hir.tcx();\n                 let mut val = Operand::Copy(place.clone());\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n-                let expect = if let ConstVal::ByteStr(bytes) = value.val {\n-                    let tcx = self.hir.tcx();\n-\n-                    // Unsize the place to &[u8], too, if necessary.\n-                    if let ty::TyRef(region, mt) = ty.sty {\n-                        if let ty::TyArray(_, _) = mt.ty.sty {\n-                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n-                            let val_slice = self.temp(ty, test.span);\n-                            self.cfg.push_assign(block, source_info, &val_slice,\n-                                                 Rvalue::Cast(CastKind::Unsize, val, ty));\n-                            val = Operand::Move(val_slice);\n-                        }\n-                    }\n-\n-                    assert!(ty.is_slice());\n-\n+                //\n+                // We want to do this even when the scrutinee is a reference to an\n+                // array, so we can call `<[u8]>::eq` rather than having to find an\n+                // `<[u8; N]>::eq`.\n+                let (expect, val) = if let ConstVal::ByteStr(bytes) = value.val {\n                     let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n                         value\n                     });\n \n-                    let slice = self.temp(ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &slice,\n-                                         Rvalue::Cast(CastKind::Unsize, array, ty));\n-                    Operand::Move(slice)\n+                    let val = self.to_slice_operand(block, source_info, val);\n+                    let slice = self.to_slice_operand(block, source_info, array);\n+                    (slice, val)\n                 } else {\n-                    self.literal_operand(test.span, ty, Literal::Value {\n+                    (self.literal_operand(test.span, ty, Literal::Value {\n                         value\n-                    })\n+                    }), val)\n                 };\n \n                 // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n                 let fail = self.cfg.start_new_block();\n+                let ty = expect.ty(&self.local_decls, tcx);\n                 if let ty::TyRef(_, mt) = ty.sty {\n                     assert!(ty.is_slice());\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();"}, {"sha": "236f6995c51b8dd897f17988a7986bd405e40122", "filename": "src/test/run-pass/issue-46920-byte-array-patterns.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06e32d044d72bea2859d741b4d5bf8775e326185/src%2Ftest%2Frun-pass%2Fissue-46920-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e32d044d72bea2859d741b4d5bf8775e326185/src%2Ftest%2Frun-pass%2Fissue-46920-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-46920-byte-array-patterns.rs?ref=06e32d044d72bea2859d741b4d5bf8775e326185", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const CURSOR_PARTITION_LABEL: &'static [u8] = b\"partition\";\n+const CURSOR_EVENT_TYPE_LABEL: &'static [u8] = b\"event_type\";\n+const BYTE_PATTERN: &'static [u8; 5] = b\"hello\";\n+\n+fn match_slice(x: &[u8]) -> u32 {\n+    match x {\n+        CURSOR_PARTITION_LABEL => 0,\n+        CURSOR_EVENT_TYPE_LABEL => 1,\n+        _ => 2,\n+    }\n+}\n+\n+fn match_array(x: &[u8; 5]) -> bool {\n+    match x {\n+        BYTE_PATTERN => true,\n+        _ => false\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match_slice(b\"abcde\"), 2);\n+    assert_eq!(match_slice(b\"event_type\"), 1);\n+    assert_eq!(match_slice(b\"partition\"), 0);\n+\n+    assert_eq!(match_array(b\"hello\"), true);\n+    assert_eq!(match_array(b\"hella\"), false);\n+}"}]}