{"sha": "83ddc33347cade429fdb47509818e775a67c1af6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZGRjMzMzNDdjYWRlNDI5ZmRiNDc1MDk4MThlNzc1YTY3YzFhZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-28T10:58:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-28T10:58:10Z"}, "message": "Auto merge of #53314 - nikomatsakis:nll-invert-liveness, r=pnkfelix\n\nNLL: experiment with inverting liveness\n\nI got inspired to see what would happen here.\n\nFixes #52460\n\nr? @pnkfelix", "tree": {"sha": "79b4b9e46b5127dbaae17128ffedc1b17c5bd414", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79b4b9e46b5127dbaae17128ffedc1b17c5bd414"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ddc33347cade429fdb47509818e775a67c1af6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ddc33347cade429fdb47509818e775a67c1af6", "html_url": "https://github.com/rust-lang/rust/commit/83ddc33347cade429fdb47509818e775a67c1af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ddc33347cade429fdb47509818e775a67c1af6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59e52b1b969545e6b7b8595913dc2e1a741d495d", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e52b1b969545e6b7b8595913dc2e1a741d495d", "html_url": "https://github.com/rust-lang/rust/commit/59e52b1b969545e6b7b8595913dc2e1a741d495d"}, {"sha": "8d231ec872aa7ede20faf70e988ebfbded351b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d231ec872aa7ede20faf70e988ebfbded351b53", "html_url": "https://github.com/rust-lang/rust/commit/8d231ec872aa7ede20faf70e988ebfbded351b53"}], "stats": {"total": 1609, "additions": 1001, "deletions": 608}, "files": [{"sha": "0840f333c876b1ec6e95af8074a5bc8bf1e7889a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -194,12 +194,12 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     #[inline]\n-    pub fn predecessors(&self) -> ReadGuard<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+    pub fn predecessors(&self) -> ReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         self.cache.predecessors(self)\n     }\n \n     #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> ReadGuard<Vec<BasicBlock>> {\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> ReadGuard<'_, Vec<BasicBlock>> {\n         ReadGuard::map(self.predecessors(), |p| &p[bb])\n     }\n \n@@ -328,6 +328,14 @@ impl<'tcx> Mir<'tcx> {\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n+\n+    /// Get the location of the terminator for the given block\n+    pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n+        Location {\n+            block: bb,\n+            statement_index: self[bb].statements.len(),\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "9b7f4cec47b8e70fb90ef8c0e731c2bef5285002", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -38,13 +38,13 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(\n \n     // compute the post order index (rank) for each node\n     let mut post_order_rank: IndexVec<G::Node, usize> =\n-        IndexVec::from_elem_n(usize::default(), graph.num_nodes());\n+        (0..graph.num_nodes()).map(|_| 0).collect();\n     for (index, node) in rpo.iter().rev().cloned().enumerate() {\n         post_order_rank[node] = index;\n     }\n \n     let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n-        IndexVec::from_elem_n(Option::default(), graph.num_nodes());\n+        (0..graph.num_nodes()).map(|_| None).collect();\n     immediate_dominators[start_node] = Some(start_node);\n \n     let mut changed = true;"}, {"sha": "936dec924090052af3f00a31b64e054765b668a2", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -20,6 +20,8 @@\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n+#![feature(impl_header_lifetime_elision)]\n #![feature(unboxed_closures)]\n #![feature(fn_traits)]\n #![feature(unsize)]\n@@ -86,6 +88,7 @@ pub mod thin_vec;\n pub mod transitive_relation;\n pub mod tuple_slice;\n pub use ena::unify;\n+pub mod vec_linked_list;\n pub mod work_queue;\n pub mod fingerprint;\n "}, {"sha": "390dca6b9055fe252ab45892a787ba82ac69ba6f", "filename": "src/librustc_data_structures/vec_linked_list.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fvec_linked_list.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use indexed_vec::{Idx, IndexVec};\n+\n+pub fn iter<Ls>(\n+    first: Option<Ls::LinkIndex>,\n+    links: &'a Ls,\n+) -> impl Iterator<Item = Ls::LinkIndex> + 'a\n+where\n+    Ls: Links,\n+{\n+    VecLinkedListIterator {\n+        links: links,\n+        current: first,\n+    }\n+}\n+\n+pub struct VecLinkedListIterator<Ls>\n+where\n+    Ls: Links,\n+{\n+    links: Ls,\n+    current: Option<Ls::LinkIndex>,\n+}\n+\n+impl<Ls> Iterator for VecLinkedListIterator<Ls>\n+where\n+    Ls: Links,\n+{\n+    type Item = Ls::LinkIndex;\n+\n+    fn next(&mut self) -> Option<Ls::LinkIndex> {\n+        if let Some(c) = self.current {\n+            self.current = <Ls as Links>::next(&self.links, c);\n+            Some(c)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub trait Links {\n+    type LinkIndex: Copy;\n+\n+    fn next(links: &Self, index: Self::LinkIndex) -> Option<Self::LinkIndex>;\n+}\n+\n+impl<Ls> Links for &Ls\n+where\n+    Ls: Links,\n+{\n+    type LinkIndex = Ls::LinkIndex;\n+\n+    fn next(links: &Self, index: Ls::LinkIndex) -> Option<Ls::LinkIndex> {\n+        <Ls as Links>::next(links, index)\n+    }\n+}\n+\n+pub trait LinkElem {\n+    type LinkIndex: Copy;\n+\n+    fn next(elem: &Self) -> Option<Self::LinkIndex>;\n+}\n+\n+impl<L, E> Links for IndexVec<L, E>\n+where\n+    E: LinkElem<LinkIndex = L>,\n+    L: Idx,\n+{\n+    type LinkIndex = L;\n+\n+    fn next(links: &Self, index: L) -> Option<L> {\n+        <E as LinkElem>::next(&links[index])\n+    }\n+}"}, {"sha": "192fa2b9eeaf7238dd9c22da42d287d61504262b", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -89,6 +89,10 @@ impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n         each_flow!(self, reset_to_entry_of(bb));\n     }\n \n+    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n+        each_flow!(self, reset_to_exit_of(bb));\n+    }\n+\n     fn reconstruct_statement_effect(&mut self, location: Location) {\n         each_flow!(self, reconstruct_statement_effect(location));\n     }"}, {"sha": "a35117f2e35605ec82c83f7f9eed0c46de95162e", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n-use util::liveness::{self, DefUse, LivenessMode};\n+use util::liveness::{self, DefUse};\n \n crate fn find<'tcx>(\n     mir: &Mir<'tcx>,\n@@ -32,10 +32,6 @@ crate fn find<'tcx>(\n         tcx,\n         region_vid,\n         start_point,\n-        liveness_mode: LivenessMode {\n-            include_regular_use: true,\n-            include_drops: true,\n-        },\n     };\n \n     uf.find()\n@@ -47,7 +43,6 @@ struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n-    liveness_mode: LivenessMode,\n }\n \n impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n@@ -108,7 +103,6 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n             mir: self.mir,\n             tcx: self.tcx,\n             region_vid: self.region_vid,\n-            liveness_mode: self.liveness_mode,\n             def_use_result: None,\n         };\n \n@@ -122,7 +116,6 @@ struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir: &'cx Mir<'tcx>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n-    liveness_mode: LivenessMode,\n     def_use_result: Option<DefUseResult>,\n }\n \n@@ -146,23 +139,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'gcx, 'tcx> {\n         });\n \n         if found_it {\n-            match liveness::categorize(context, self.liveness_mode) {\n-                Some(DefUse::Def) => {\n-                    self.def_use_result = Some(DefUseResult::Def);\n-                }\n-\n-                Some(DefUse::Use) => {\n-                    self.def_use_result = if context.is_drop() {\n-                        Some(DefUseResult::UseDrop { local })\n-                    } else {\n-                        Some(DefUseResult::UseLive { local })\n-                    };\n-                }\n-\n-                None => {\n-                    self.def_use_result = None;\n-                }\n-            }\n+            self.def_use_result = match liveness::categorize(context) {\n+                Some(DefUse::Def) => Some(DefUseResult::Def),\n+                Some(DefUse::Use) => Some(DefUseResult::UseLive { local }),\n+                Some(DefUse::Drop) => Some(DefUseResult::UseDrop { local }),\n+                None => None,\n+            };\n         }\n     }\n }"}, {"sha": "b80f9784d6f8757879ecff6571036725c581fe8b", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n use borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n-use borrow_check::nll::type_check::liveness::liveness_map::{NllLivenessMap, LocalWithRegion};\n+use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n@@ -22,22 +22,19 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n-use rustc::util::nodemap::FxHashMap;\n use rustc_errors::Diagnostic;\n-use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::env;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n use transform::MirSource;\n-use util::liveness::{LivenessResults, LiveVarSet};\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n use util as mir_util;\n-use util::pretty::{self, ALIGN};\n+use util::pretty;\n \n mod constraint_generation;\n pub mod explain_borrow;\n@@ -111,8 +108,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let MirTypeckResults {\n         constraints,\n         universal_region_relations,\n-        liveness,\n-        liveness_map,\n     } = type_check::type_check(\n         infcx,\n         param_env,\n@@ -205,8 +200,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n-        &liveness,\n-        &liveness_map,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -222,8 +215,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResults<LocalWithRegion>,\n-    liveness_map: &NllLivenessMap,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -233,34 +224,6 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let regular_liveness_per_location: FxHashMap<_, _> = mir\n-        .basic_blocks()\n-        .indices()\n-        .flat_map(|bb| {\n-            let mut results = vec![];\n-            liveness\n-                .regular\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n-                    results.push((location, local_set.clone()));\n-                });\n-            results\n-        })\n-        .collect();\n-\n-    let drop_liveness_per_location: FxHashMap<_, _> = mir\n-        .basic_blocks()\n-        .indices()\n-        .flat_map(|bb| {\n-            let mut results = vec![];\n-            liveness\n-                .drop\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n-                    results.push((location, local_set.clone()));\n-                });\n-            results\n-        })\n-        .collect();\n-\n     mir_util::dump_mir(\n         infcx.tcx,\n         None,\n@@ -283,26 +246,10 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                     }\n                 }\n \n-                PassWhere::BeforeLocation(location) => {\n-                    let s = live_variable_set(\n-                        &regular_liveness_per_location[&location],\n-                        &drop_liveness_per_location[&location],\n-                    );\n-                    writeln!(\n-                        out,\n-                        \"{:ALIGN$} | Live variables on entry to {:?}: {}\",\n-                        \"\",\n-                        location,\n-                        s,\n-                        ALIGN = ALIGN\n-                    )?;\n+                PassWhere::BeforeLocation(_) => {\n                 }\n \n-                // After each basic block, dump out the values\n-                // that are live on exit from the basic block.\n-                PassWhere::AfterTerminator(bb) => {\n-                    let s = live_variable_set(&liveness.regular.outs[bb], &liveness.drop.outs[bb]);\n-                    writeln!(out, \"    | Live variables on exit from {:?}: {}\", bb, s)?;\n+                PassWhere::AfterTerminator(_) => {\n                 }\n \n                 PassWhere::BeforeBlock(_) | PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n@@ -420,33 +367,3 @@ impl ToRegionVid for RegionVid {\n         self\n     }\n }\n-\n-fn live_variable_set(\n-    regular: &LiveVarSet<LocalWithRegion>,\n-    drops: &LiveVarSet<LocalWithRegion>\n-) -> String {\n-    // sort and deduplicate:\n-    let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n-\n-    // construct a string with each local, including `(drop)` if it is\n-    // only dropped, versus a regular use.\n-    let mut string = String::new();\n-    for local in all_locals {\n-        string.push_str(&format!(\"{:?}\", local));\n-\n-        if !regular.contains(&local) {\n-            assert!(drops.contains(&local));\n-            string.push_str(\" (drop)\");\n-        }\n-\n-        string.push_str(\", \");\n-    }\n-\n-    let len = if string.is_empty() {\n-        0\n-    } else {\n-        string.len() - 2\n-    };\n-\n-    format!(\"[{}]\", &string[..len])\n-}"}, {"sha": "ae5d57906739bd8b0be2f684ef993e247a56be40", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 89, "deletions": 37, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::bitvec::SparseBitMatrix;\n+use rustc_data_structures::bitvec::{BitArray, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -20,13 +20,18 @@ use std::rc::Rc;\n crate struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n+\n+    /// Map backward from each point to the basic block that it\n+    /// belongs to.\n+    basic_blocks: IndexVec<PointIndex, BasicBlock>,\n+\n     num_points: usize,\n }\n \n impl RegionValueElements {\n     crate fn new(mir: &Mir<'_>) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block = mir\n+        let statements_before_block: IndexVec<BasicBlock, usize> = mir\n             .basic_blocks()\n             .iter()\n             .map(|block_data| {\n@@ -41,14 +46,25 @@ impl RegionValueElements {\n         );\n         debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n \n+        let mut basic_blocks = IndexVec::with_capacity(num_points);\n+        for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+            basic_blocks.extend((0 .. bb_data.statements.len() + 1).map(|_| bb));\n+        }\n+\n         Self {\n             statements_before_block,\n+            basic_blocks,\n             num_points,\n         }\n     }\n \n+    /// Total number of point indices\n+    crate fn num_points(&self) -> usize {\n+        self.num_points\n+    }\n+\n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    fn point_from_location(&self, location: Location) -> PointIndex {\n+    crate fn point_from_location(&self, location: Location) -> PointIndex {\n         let Location {\n             block,\n             statement_index,\n@@ -57,39 +73,50 @@ impl RegionValueElements {\n         PointIndex::new(start_index + statement_index)\n     }\n \n-    /// Converts a `PointIndex` back to a location. O(N) where N is\n-    /// the number of blocks; could be faster if we ever cared.\n-    crate fn to_location(&self, i: PointIndex) -> Location {\n-        let point_index = i.index();\n-\n-        // Find the basic block. We have a vector with the\n-        // starting index of the statement in each block. Imagine\n-        // we have statement #22, and we have a vector like:\n-        //\n-        // [0, 10, 20]\n-        //\n-        // In that case, this represents point_index 2 of\n-        // basic block BB2. We know this because BB0 accounts for\n-        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n-        // 20...\n-        //\n-        // To compute this, we could do a binary search, but\n-        // because I am lazy we instead iterate through to find\n-        // the last point where the \"first index\" (0, 10, or 20)\n-        // was less than the statement index (22). In our case, this will\n-        // be (BB2, 20).\n-        //\n-        // Nit: we could do a binary search here but I'm too lazy.\n-        let (block, &first_index) = self\n-            .statements_before_block\n-            .iter_enumerated()\n-            .filter(|(_, first_index)| **first_index <= point_index)\n-            .last()\n-            .unwrap();\n-\n-        Location {\n-            block,\n-            statement_index: point_index - first_index,\n+    /// Converts a `Location` into a `PointIndex`. O(1).\n+    crate fn entry_point(&self, block: BasicBlock) -> PointIndex {\n+        let start_index = self.statements_before_block[block];\n+        PointIndex::new(start_index)\n+    }\n+\n+    /// Converts a `PointIndex` back to a location. O(1).\n+    crate fn to_location(&self, index: PointIndex) -> Location {\n+        assert!(index.index() < self.num_points);\n+        let block = self.basic_blocks[index];\n+        let start_index = self.statements_before_block[block];\n+        let statement_index = index.index() - start_index;\n+        Location { block, statement_index }\n+    }\n+\n+    /// Sometimes we get point-indices back from bitsets that may be\n+    /// out of range (because they round up to the nearest 2^N number\n+    /// of bits). Use this function to filter such points out if you\n+    /// like.\n+    crate fn point_in_range(&self, index: PointIndex) -> bool {\n+        index.index() < self.num_points\n+    }\n+\n+    /// Pushes all predecessors of `index` onto `stack`.\n+    crate fn push_predecessors(\n+        &self,\n+        mir: &Mir<'_>,\n+        index: PointIndex,\n+        stack: &mut Vec<PointIndex>,\n+    ) {\n+        let Location { block, statement_index } = self.to_location(index);\n+        if statement_index == 0 {\n+            // If this is a basic block head, then the predecessors are\n+            // the the terminators of other basic blocks\n+            stack.extend(\n+                mir\n+                    .predecessors_for(block)\n+                    .iter()\n+                    .map(|&pred_bb| mir.terminator_loc(pred_bb))\n+                    .map(|pred_loc| self.point_from_location(pred_loc)),\n+            );\n+        } else {\n+            // Otherwise, the pred is just the previous statement\n+            stack.push(PointIndex::new(index.index() - 1));\n         }\n     }\n }\n@@ -151,6 +178,13 @@ impl<N: Idx> LivenessValues<N> {\n         self.points.add(row, index)\n     }\n \n+    /// Adds all the elements in the given bit array into the given\n+    /// region. Returns true if any of them are newly added.\n+    crate fn add_elements(&mut self, row: N, locations: &BitArray<PointIndex>) -> bool {\n+        debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n+        self.points.merge_into(row, locations)\n+    }\n+\n     /// Adds all the control-flow points to the values for `r`.\n     crate fn add_all_points(&mut self, row: N) {\n         self.points.add_all(row);\n@@ -169,6 +203,7 @@ impl<N: Idx> LivenessValues<N> {\n                 .row(r)\n                 .into_iter()\n                 .flat_map(|set| set.iter())\n+                .take_while(|&p| self.elements.point_in_range(p))\n                 .map(|p| self.elements.to_location(p))\n                 .map(RegionElement::Location),\n         )\n@@ -277,7 +312,11 @@ impl<N: Idx> RegionValues<N> {\n         self.points\n             .row(r)\n             .into_iter()\n-            .flat_map(move |set| set.iter().map(move |p| self.elements.to_location(p)))\n+            .flat_map(move |set| {\n+                set.iter()\n+                    .take_while(move |&p| self.elements.point_in_range(p))\n+                    .map(move |p| self.elements.to_location(p))\n+            })\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n@@ -366,6 +405,19 @@ impl ToElementIndex for ty::UniverseIndex {\n     }\n }\n \n+crate fn location_set_str(\n+    elements: &RegionValueElements,\n+    points: impl IntoIterator<Item = PointIndex>,\n+) -> String {\n+    region_value_str(\n+        points\n+            .into_iter()\n+            .take_while(|&p| elements.point_in_range(p))\n+            .map(|p| elements.to_location(p))\n+            .map(RegionElement::Location),\n+    )\n+}\n+\n fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n     let mut result = String::new();\n     result.push_str(\"{\");"}, {"sha": "15affbbc27a20b9468195ef68913de3dee843c1c", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -10,9 +10,9 @@\n \n //! For the NLL computation, we need to compute liveness, but only for those\n //! local variables whose types contain regions. The others are not of interest\n-//! to us. This file defines a new index type (LocalWithRegion) that indexes into\n+//! to us. This file defines a new index type (LiveVar) that indexes into\n //! a list of \"variables whose type contain regions\". It also defines a map from\n-//! Local to LocalWithRegion and vice versa -- this map can be given to the\n+//! Local to LiveVar and vice versa -- this map can be given to the\n //! liveness code so that it only operates over variables with regions in their\n //! types, instead of all variables.\n \n@@ -23,7 +23,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use util::liveness::LiveVariableMap;\n \n-/// Map between Local and LocalWithRegion indices: the purpose of this\n+/// Map between Local and LiveVar indices: the purpose of this\n /// map is to define the subset of local variables for which we need\n /// to do a liveness computation. We only need to compute whether a\n /// variable `X` is live if that variable contains some region `R` in\n@@ -32,18 +32,18 @@ use util::liveness::LiveVariableMap;\n crate struct NllLivenessMap {\n     /// For each local variable, contains `Some(i)` if liveness is\n     /// needed for this variable.\n-    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n+    pub from_local: IndexVec<Local, Option<LiveVar>>,\n \n-    /// For each `LocalWithRegion`, maps back to the original `Local` index.\n-    pub to_local: IndexVec<LocalWithRegion, Local>,\n+    /// For each `LiveVar`, maps back to the original `Local` index.\n+    pub to_local: IndexVec<LiveVar, Local>,\n }\n \n impl LiveVariableMap for NllLivenessMap {\n     fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n         self.from_local[local]\n     }\n \n-    type LiveVar = LocalWithRegion;\n+    type LiveVar = LiveVar;\n \n     fn from_live_var(&self, local: Self::LiveVar) -> Local {\n         self.to_local[local]\n@@ -93,5 +93,10 @@ impl NllLivenessMap {\n     }\n }\n \n-/// Index given to each local variable whose type contains a region.\n-newtype_index!(LocalWithRegion);\n+/// Index given to each local variable for which we need to\n+/// compute liveness information. For many locals, we are able to\n+/// skip liveness information: for example, those variables whose\n+/// types contain no regions.\n+newtype_index!(\n+    LiveVar\n+);"}, {"sha": "73d285c2f2eb846140fadefd6ea97a5f8e61375e", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n+use borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::{Local, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::vec_linked_list as vll;\n+use util::liveness::{categorize, DefUse, LiveVariableMap};\n+\n+/// A map that cross references each local with the locations where it\n+/// is defined (assigned), used, or dropped. Used during liveness\n+/// computation.\n+crate struct LocalUseMap<'me> {\n+    liveness_map: &'me NllLivenessMap,\n+\n+    /// Head of a linked list of **definitions** of each variable --\n+    /// definition in this context means assignment, e.g. `x` is\n+    /// defined in `x = y` but not `y`; that first def is the head of\n+    /// a linked list that lets you enumerate all places the variable\n+    /// is assigned.\n+    first_def_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+\n+    /// Head of a linked list of **uses** of each variable -- use in\n+    /// this context means that the existing value of the variable is\n+    /// read or modified. e.g., `y` is used in `x = y` but not `x`.\n+    /// Note that `DROP(x)` terminators are excluded from this list.\n+    first_use_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+\n+    /// Head of a linked list of **drops** of each variable -- these\n+    /// are a special category of uses corresponding to the drop that\n+    /// we add for each local variable.\n+    first_drop_at: IndexVec<LiveVar, Option<AppearanceIndex>>,\n+\n+    appearances: IndexVec<AppearanceIndex, Appearance>,\n+}\n+\n+struct Appearance {\n+    point_index: PointIndex,\n+    next: Option<AppearanceIndex>,\n+}\n+\n+newtype_index!(AppearanceIndex);\n+\n+impl vll::LinkElem for Appearance {\n+    type LinkIndex = AppearanceIndex;\n+\n+    fn next(elem: &Self) -> Option<AppearanceIndex> {\n+        elem.next\n+    }\n+}\n+\n+impl LocalUseMap<'me> {\n+    crate fn build(\n+        liveness_map: &'me NllLivenessMap,\n+        elements: &RegionValueElements,\n+        mir: &Mir<'_>,\n+    ) -> Self {\n+        let nones = IndexVec::from_elem_n(None, liveness_map.num_variables());\n+        let mut local_use_map = LocalUseMap {\n+            liveness_map,\n+            first_def_at: nones.clone(),\n+            first_use_at: nones.clone(),\n+            first_drop_at: nones,\n+            appearances: IndexVec::new(),\n+        };\n+\n+        LocalUseMapBuild {\n+            local_use_map: &mut local_use_map,\n+            elements,\n+        }.visit_mir(mir);\n+\n+        local_use_map\n+    }\n+\n+    crate fn defs(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_def_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+\n+    crate fn uses(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_use_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+\n+    crate fn drops(&self, local: LiveVar) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_drop_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+}\n+\n+struct LocalUseMapBuild<'me, 'map: 'me> {\n+    local_use_map: &'me mut LocalUseMap<'map>,\n+    elements: &'me RegionValueElements,\n+}\n+\n+impl LocalUseMapBuild<'_, '_> {\n+    fn insert_def(&mut self, local: LiveVar, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_def_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert_use(&mut self, local: LiveVar, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_use_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert_drop(&mut self, local: LiveVar, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_drop_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert(\n+        elements: &RegionValueElements,\n+        first_appearance: &mut Option<AppearanceIndex>,\n+        appearances: &mut IndexVec<AppearanceIndex, Appearance>,\n+        location: Location,\n+    ) {\n+        let point_index = elements.point_from_location(location);\n+        let appearance_index = appearances.push(Appearance {\n+            point_index,\n+            next: *first_appearance,\n+        });\n+        *first_appearance = Some(appearance_index);\n+    }\n+}\n+\n+impl Visitor<'tcx> for LocalUseMapBuild<'_, '_> {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, location: Location) {\n+        if let Some(local_with_region) = self.local_use_map.liveness_map.from_local(local) {\n+            match categorize(context) {\n+                Some(DefUse::Def) => self.insert_def(local_with_region, location),\n+                Some(DefUse::Use) => self.insert_use(local_with_region, location),\n+                Some(DefUse::Drop) => self.insert_drop(local_with_region, location),\n+                _ => (),\n+            }\n+        }\n+    }\n+}"}, {"sha": "b3fc73e9b7be342a11244c9e324fdeaf6a9ff544", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 17, "deletions": 232, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -8,26 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::constraints::ConstraintSet;\n-use borrow_check::nll::type_check::AtLocation;\n-use borrow_check::nll::{LocalWithRegion, NllLivenessMap};\n+use borrow_check::nll::NllLivenessMap;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use dataflow::move_paths::{HasMoveData, MoveData};\n+use dataflow::move_paths::MoveData;\n use dataflow::MaybeInitializedPlaces;\n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n-use rustc::traits::query::type_op::outlives::DropckOutlives;\n-use rustc::traits::query::type_op::TypeOp;\n-use rustc::ty::{RegionVid, Ty, TypeFoldable};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use dataflow::FlowAtLocation;\n+use rustc::mir::Mir;\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n-use util::liveness::{LiveVariableMap, LivenessResults};\n \n use super::TypeChecker;\n \n crate mod liveness_map;\n+mod local_use_map;\n+mod trace;\n \n /// Combines liveness analysis with initialization analysis to\n /// determine which variables are live at which points, both due to\n@@ -38,40 +35,23 @@ crate mod liveness_map;\n /// NB. This computation requires normalization; therefore, it must be\n /// performed before\n pub(super) fn generate<'gcx, 'tcx>(\n-    cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n+    elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) -> (LivenessResults<LocalWithRegion>, NllLivenessMap) {\n+) {\n+    debug!(\"liveness::generate\");\n     let free_regions = {\n-        let borrowck_context = cx.borrowck_context.as_ref().unwrap();\n+        let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n         regions_that_outlive_free_regions(\n-            cx.infcx.num_region_vars(),\n+            typeck.infcx.num_region_vars(),\n             &borrowck_context.universal_regions,\n             &borrowck_context.constraints.outlives_constraints,\n         )\n     };\n-    let liveness_map = NllLivenessMap::compute(cx.tcx(), &free_regions, mir);\n-    let liveness = LivenessResults::compute(mir, &liveness_map);\n-\n-    // For everything else, it is only live where it is actually used.\n-    if !liveness_map.is_empty() {\n-        let mut generator = TypeLivenessGenerator {\n-            cx,\n-            mir,\n-            liveness: &liveness,\n-            flow_inits,\n-            move_data,\n-            drop_data: FxHashMap(),\n-            map: &liveness_map,\n-        };\n-\n-        for bb in mir.basic_blocks().indices() {\n-            generator.add_liveness_constraints(bb);\n-        }\n-    }\n-\n-    (liveness, liveness_map)\n+    let liveness_map = NllLivenessMap::compute(typeck.tcx(), &free_regions, mir);\n+    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map);\n }\n \n /// Compute all regions that are (currently) known to outlive free\n@@ -112,198 +92,3 @@ fn regions_that_outlive_free_regions(\n     // Return the final set of things we visited.\n     outlives_free_region\n }\n-\n-struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n-where\n-    'typeck: 'gen,\n-    'flow: 'gen,\n-    'tcx: 'typeck + 'flow,\n-    'gcx: 'tcx,\n-{\n-    cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n-    mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults<LocalWithRegion>,\n-    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n-    move_data: &'gen MoveData<'tcx>,\n-    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n-    map: &'gen NllLivenessMap,\n-}\n-\n-struct DropData<'tcx> {\n-    dropck_result: DropckOutlivesResult<'tcx>,\n-    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n-}\n-\n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n-    /// Liveness constraints:\n-    ///\n-    /// > If a variable V is live at point P, then all regions R in the type of V\n-    /// > must include the point P.\n-    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n-        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n-\n-        self.liveness\n-            .regular\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n-                for live_local in live_locals.iter() {\n-                    let local = self.map.from_live_var(live_local);\n-                    let live_local_ty = self.mir.local_decls[local].ty;\n-                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n-                }\n-            });\n-\n-        let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n-        self.liveness\n-            .drop\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n-                all_live_locals.push((location, live_locals.iter().collect()));\n-            });\n-        debug!(\n-            \"add_liveness_constraints: all_live_locals={:#?}\",\n-            all_live_locals\n-        );\n-\n-        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n-        self.flow_inits.reset_to_entry_of(bb);\n-        while let Some((location, live_locals)) = all_live_locals.pop() {\n-            for live_local in live_locals {\n-                debug!(\n-                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n-                    location, live_local\n-                );\n-\n-                if log_enabled!(::log::Level::Debug) {\n-                    self.flow_inits.each_state_bit(|mpi_init| {\n-                        debug!(\n-                            \"add_liveness_constraints: location={:?} initialized={:?}\",\n-                            location,\n-                            &self.flow_inits.operator().move_data().move_paths[mpi_init]\n-                        );\n-                    });\n-                }\n-\n-                let local = self.map.from_live_var(live_local);\n-                let mpi = self.move_data.rev_lookup.find_local(local);\n-                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n-                    debug!(\n-                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n-                        self.move_data.move_paths[mpi],\n-                        self.move_data.move_paths[initialized_child]\n-                    );\n-\n-                    let local = self.map.from_live_var(live_local);\n-                    let live_local_ty = self.mir.local_decls[local].ty;\n-                    self.add_drop_live_constraint(live_local, live_local_ty, location);\n-                }\n-            }\n-\n-            if location.statement_index == terminator_index {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_terminator_effect(location);\n-            } else {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_statement_effect(location);\n-            }\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-    }\n-\n-    /// Some variable with type `live_ty` is \"regular live\" at\n-    /// `location` -- i.e., it may be used later. This means that all\n-    /// regions appearing in the type `live_ty` must be live at\n-    /// `location`.\n-    fn push_type_live_constraint<T>(\n-        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-        value: T,\n-        location: Location,\n-    ) where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n-            value, location\n-        );\n-\n-        cx.tcx().for_each_free_region(&value, |live_region| {\n-            if let Some(ref mut borrowck_context) = cx.borrowck_context {\n-                let region_vid = borrowck_context\n-                    .universal_regions\n-                    .to_region_vid(live_region);\n-                borrowck_context\n-                    .constraints\n-                    .liveness_constraints\n-                    .add_element(region_vid, location);\n-\n-                if let Some(all_facts) = borrowck_context.all_facts {\n-                    let start_index = borrowck_context.location_table.start_index(location);\n-                    all_facts.region_live_at.push((region_vid, start_index));\n-\n-                    let mid_index = borrowck_context.location_table.mid_index(location);\n-                    all_facts.region_live_at.push((region_vid, mid_index));\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Some variable with type `live_ty` is \"drop live\" at `location`\n-    /// -- i.e., it may be dropped later. This means that *some* of\n-    /// the regions in its type must be live at `location`. The\n-    /// precise set will depend on the dropck constraints, and in\n-    /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(\n-        &mut self,\n-        dropped_local: LocalWithRegion,\n-        dropped_ty: Ty<'tcx>,\n-        location: Location,\n-    ) {\n-        debug!(\n-            \"add_drop_live_constraint(dropped_local={:?}, dropped_ty={:?}, location={:?})\",\n-            dropped_local, dropped_ty, location\n-        );\n-\n-        let drop_data = self.drop_data.entry(dropped_ty).or_insert_with({\n-            let cx = &mut self.cx;\n-            move || Self::compute_drop_data(cx, dropped_ty)\n-        });\n-\n-        if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx.push_region_constraints(location.boring(), data);\n-        }\n-\n-        drop_data.dropck_result.report_overflows(\n-            self.cx.infcx.tcx,\n-            self.mir.source_info(location).span,\n-            dropped_ty,\n-        );\n-\n-        // All things in the `outlives` array may be touched by\n-        // the destructor and must be live at this point.\n-        for &kind in &drop_data.dropck_result.kinds {\n-            Self::push_type_live_constraint(&mut self.cx, kind, location);\n-        }\n-    }\n-\n-    fn compute_drop_data(\n-        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-        dropped_ty: Ty<'tcx>,\n-    ) -> DropData<'tcx> {\n-        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n-\n-        let param_env = cx.param_env;\n-        let (dropck_result, region_constraint_data) = param_env\n-            .and(DropckOutlives::new(dropped_ty))\n-            .fully_perform(cx.infcx)\n-            .unwrap();\n-\n-        DropData {\n-            dropck_result,\n-            region_constraint_data,\n-        }\n-    }\n-}"}, {"sha": "79589ce973372b551387dd9d9273f7edc8b1bcd6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -0,0 +1,553 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n+use borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n+use borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n+use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::type_check::TypeChecker;\n+use dataflow::move_paths::indexes::MovePathIndex;\n+use dataflow::move_paths::MoveData;\n+use dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n+use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::mir::{BasicBlock, Local, Location, Mir};\n+use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n+use rustc::traits::query::type_op::outlives::DropckOutlives;\n+use rustc::traits::query::type_op::TypeOp;\n+use rustc::ty::{Ty, TypeFoldable};\n+use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::rc::Rc;\n+use util::liveness::LiveVariableMap;\n+\n+/// This is the heart of the liveness computation. For each variable X\n+/// that requires a liveness computation, it walks over all the uses\n+/// of X and does a reverse depth-first search (\"trace\") through the\n+/// MIR. This search stops when we find a definition of that variable.\n+/// The points visited in this search is the USE-LIVE set for the variable;\n+/// of those points is added to all the regions that appear in the variable's\n+/// type.\n+///\n+/// We then also walks through each *drop* of those variables and does\n+/// another search, stopping when we reach a use or definition. This\n+/// is the DROP-LIVE set of points. Each of the points in the\n+/// DROP-LIVE set are to the liveness sets for regions found in the\n+/// `dropck_outlives` result of the variable's type (in particular,\n+/// this respects `#[may_dangle]` annotations).\n+pub(super) fn trace(\n+    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    elements: &Rc<RegionValueElements>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+    liveness_map: &NllLivenessMap,\n+) {\n+    debug!(\"trace()\");\n+\n+    if liveness_map.is_empty() {\n+        return;\n+    }\n+\n+    let local_use_map = &LocalUseMap::build(liveness_map, elements, mir);\n+\n+    let cx = LivenessContext {\n+        typeck,\n+        mir,\n+        flow_inits,\n+        elements,\n+        local_use_map,\n+        move_data,\n+        liveness_map,\n+        drop_data: FxHashMap::default(),\n+    };\n+\n+    LivenessResults::new(cx).compute_for_all_locals();\n+}\n+\n+/// Contextual state for the type-liveness generator.\n+struct LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'me,\n+    'flow: 'me,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    /// Current type-checker, giving us our inference context etc.\n+    typeck: &'me mut TypeChecker<'typeck, 'gcx, 'tcx>,\n+\n+    /// Defines the `PointIndex` mapping\n+    elements: &'me RegionValueElements,\n+\n+    /// MIR we are analyzing.\n+    mir: &'me Mir<'tcx>,\n+\n+    /// Mapping to/from the various indices used for initialization tracking.\n+    move_data: &'me MoveData<'tcx>,\n+\n+    /// Cache for the results of `dropck_outlives` query.\n+    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+\n+    /// Results of dataflow tracking which variables (and paths) have been\n+    /// initialized.\n+    flow_inits: &'me mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n+\n+    /// Index indicating where each variable is assigned, used, or\n+    /// dropped.\n+    local_use_map: &'me LocalUseMap<'me>,\n+\n+    /// Map tracking which variables need liveness computation.\n+    liveness_map: &'me NllLivenessMap,\n+}\n+\n+struct DropData<'tcx> {\n+    dropck_result: DropckOutlivesResult<'tcx>,\n+    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n+}\n+\n+struct LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'me,\n+    'flow: 'me,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n+\n+    /// Set of points that define the current local.\n+    defs: BitArray<PointIndex>,\n+\n+    /// Points where the current variable is \"use live\" -- meaning\n+    /// that there is a future \"full use\" that may use its value.\n+    use_live_at: BitArray<PointIndex>,\n+\n+    /// Points where the current variable is \"drop live\" -- meaning\n+    /// that there is no future \"full use\" that may use its value, but\n+    /// there is a future drop.\n+    drop_live_at: BitArray<PointIndex>,\n+\n+    /// Locations where drops may occur.\n+    drop_locations: Vec<Location>,\n+\n+    /// Stack used when doing (reverse) DFS.\n+    stack: Vec<PointIndex>,\n+}\n+\n+impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n+    fn new(cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>) -> Self {\n+        let num_points = cx.elements.num_points();\n+        LivenessResults {\n+            cx,\n+            defs: BitArray::new(num_points),\n+            use_live_at: BitArray::new(num_points),\n+            drop_live_at: BitArray::new(num_points),\n+            drop_locations: vec![],\n+            stack: vec![],\n+        }\n+    }\n+\n+    fn compute_for_all_locals(&mut self) {\n+        for live_local in self.cx.liveness_map.to_local.indices() {\n+            let local = self.cx.liveness_map.from_live_var(live_local);\n+            debug!(\"local={:?} live_local={:?}\", local, live_local);\n+\n+            self.reset_local_state();\n+            self.add_defs_for(live_local);\n+            self.compute_use_live_points_for(live_local);\n+            self.compute_drop_live_points_for(live_local);\n+\n+            let local_ty = self.cx.mir.local_decls[local].ty;\n+\n+            if !self.use_live_at.is_empty() {\n+                self.cx.add_use_live_facts_for(local_ty, &self.use_live_at);\n+            }\n+\n+            if !self.drop_live_at.is_empty() {\n+                self.cx.add_drop_live_facts_for(\n+                    local,\n+                    local_ty,\n+                    &self.drop_locations,\n+                    &self.drop_live_at,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Clear the value of fields that are \"per local variable\".\n+    fn reset_local_state(&mut self) {\n+        self.defs.clear();\n+        self.use_live_at.clear();\n+        self.drop_live_at.clear();\n+        self.drop_locations.clear();\n+        assert!(self.stack.is_empty());\n+    }\n+\n+    /// Adds the definitions of `local` into `self.defs`.\n+    fn add_defs_for(&mut self, live_local: LiveVar) {\n+        for def in self.cx.local_use_map.defs(live_local) {\n+            debug!(\"- defined at {:?}\", def);\n+            self.defs.insert(def);\n+        }\n+    }\n+\n+    /// Compute all points where local is \"use live\" -- meaning its\n+    /// current value may be used later (except by a drop). This is\n+    /// done by walking backwards from each use of `live_local` until we\n+    /// find a `def` of local.\n+    ///\n+    /// Requires `add_defs_for(live_local)` to have been executed.\n+    fn compute_use_live_points_for(&mut self, live_local: LiveVar) {\n+        debug!(\"compute_use_live_points_for(live_local={:?})\", live_local);\n+\n+        self.stack.extend(self.cx.local_use_map.uses(live_local));\n+        while let Some(p) = self.stack.pop() {\n+            if self.defs.contains(p) {\n+                continue;\n+            }\n+\n+            if self.use_live_at.insert(p) {\n+                self.cx\n+                    .elements\n+                    .push_predecessors(self.cx.mir, p, &mut self.stack)\n+            }\n+        }\n+    }\n+\n+    /// Compute all points where local is \"drop live\" -- meaning its\n+    /// current value may be dropped later (but not used). This is\n+    /// done by iterating over the drops of `local` where `local` (or\n+    /// some subpart of `local`) is initialized. For each such drop,\n+    /// we walk backwards until we find a point where `local` is\n+    /// either defined or use-live.\n+    ///\n+    /// Requires `compute_use_live_points_for` and `add_defs_for` to\n+    /// have been executed.\n+    fn compute_drop_live_points_for(&mut self, live_local: LiveVar) {\n+        debug!(\"compute_drop_live_points_for(live_local={:?})\", live_local);\n+\n+        let local = self.cx.liveness_map.from_live_var(live_local);\n+        let mpi = self.cx.move_data.rev_lookup.find_local(local);\n+        debug!(\"compute_drop_live_points_for: mpi = {:?}\", mpi);\n+\n+        // Find the drops where `local` is initialized.\n+        for drop_point in self.cx.local_use_map.drops(live_local) {\n+            let location = self.cx.elements.to_location(drop_point);\n+            debug_assert_eq!(self.cx.mir.terminator_loc(location.block), location,);\n+\n+            if self.cx.initialized_at_terminator(location.block, mpi) {\n+                if self.drop_live_at.insert(drop_point) {\n+                    self.drop_locations.push(location);\n+                    self.stack.push(drop_point);\n+                }\n+            }\n+        }\n+\n+        debug!(\n+            \"compute_drop_live_points_for: drop_locations={:?}\",\n+            self.drop_locations\n+        );\n+\n+        // Reverse DFS. But for drops, we do it a bit differently.\n+        // The stack only ever stores *terminators of blocks*. Within\n+        // a block, we walk back the statements in an inner loop.\n+        'next_block: while let Some(term_point) = self.stack.pop() {\n+            self.compute_drop_live_points_for_block(mpi, term_point);\n+        }\n+    }\n+\n+    /// Executes one iteration of the drop-live analysis loop.\n+    ///\n+    /// The parameter `mpi` is the `MovePathIndex` of the local variable\n+    /// we are currently analyzing.\n+    ///\n+    /// The point `term_point` represents some terminator in the MIR,\n+    /// where the local `mpi` is drop-live on entry to that terminator.\n+    ///\n+    /// This method adds all drop-live points within the block and --\n+    /// where applicable -- pushes the terminators of preceding blocks\n+    /// onto `self.stack`.\n+    fn compute_drop_live_points_for_block(&mut self, mpi: MovePathIndex, term_point: PointIndex) {\n+        debug!(\n+            \"compute_drop_live_points_for_block(mpi={:?}, term_point={:?})\",\n+            self.cx.move_data.move_paths[mpi].place,\n+            self.cx.elements.to_location(term_point),\n+        );\n+\n+        // We are only invoked with terminators where `mpi` is\n+        // drop-live on entry.\n+        debug_assert!(self.drop_live_at.contains(term_point));\n+\n+        // Otherwise, scan backwards through the statements in the\n+        // block.  One of them may be either a definition or use\n+        // live point.\n+        let term_location = self.cx.elements.to_location(term_point);\n+        debug_assert_eq!(\n+            self.cx.mir.terminator_loc(term_location.block),\n+            term_location,\n+        );\n+        let block = term_location.block;\n+        let entry_point = self.cx.elements.entry_point(term_location.block);\n+        for p in (entry_point..term_point).rev() {\n+            debug!(\n+                \"compute_drop_live_points_for_block: p = {:?}\",\n+                self.cx.elements.to_location(p),\n+            );\n+\n+            if self.defs.contains(p) {\n+                debug!(\"compute_drop_live_points_for_block: def site\");\n+                return;\n+            }\n+\n+            if self.use_live_at.contains(p) {\n+                debug!(\"compute_drop_live_points_for_block: use-live at {:?}\", p);\n+                return;\n+            }\n+\n+            if !self.drop_live_at.insert(p) {\n+                debug!(\"compute_drop_live_points_for_block: already drop-live\");\n+                return;\n+            }\n+        }\n+\n+        for &pred_block in self.cx.mir.predecessors_for(block).iter() {\n+            debug!(\n+                \"compute_drop_live_points_for_block: pred_block = {:?}\",\n+                pred_block,\n+            );\n+\n+            // Check whether the variable is (at least partially)\n+            // initialized at the exit of this predecessor. If so, we\n+            // want to enqueue it on our list. If not, go check the\n+            // next block.\n+            //\n+            // Note that we only need to check whether `live_local`\n+            // became de-initialized at basic block boundaries. If it\n+            // were to become de-initialized within the block, that\n+            // would have been a \"use-live\" transition in the earlier\n+            // loop, and we'd have returned already.\n+            //\n+            // NB. It's possible that the pred-block ends in a call\n+            // which stores to the variable; in that case, the\n+            // variable may be uninitialized \"at exit\" because this\n+            // call only considers the *unconditional effects* of the\n+            // terminator. *But*, in that case, the terminator is also\n+            // a *definition* of the variable, in which case we want\n+            // to stop the search anyhow. (But see Note 1 below.)\n+            if !self.cx.initialized_at_exit(pred_block, mpi) {\n+                debug!(\"compute_drop_live_points_for_block: not initialized\");\n+                continue;\n+            }\n+\n+            let pred_term_loc = self.cx.mir.terminator_loc(pred_block);\n+            let pred_term_point = self.cx.elements.point_from_location(pred_term_loc);\n+\n+            // If the terminator of this predecessor either *assigns*\n+            // our value or is a \"normal use\", then stop.\n+            if self.defs.contains(pred_term_point) {\n+                debug!(\n+                    \"compute_drop_live_points_for_block: defined at {:?}\",\n+                    pred_term_loc\n+                );\n+                continue;\n+            }\n+\n+            if self.use_live_at.contains(pred_term_point) {\n+                debug!(\n+                    \"compute_drop_live_points_for_block: use-live at {:?}\",\n+                    pred_term_loc\n+                );\n+                continue;\n+            }\n+\n+            // Otherwise, we are drop-live on entry to the terminator,\n+            // so walk it.\n+            if self.drop_live_at.insert(pred_term_point) {\n+                debug!(\"compute_drop_live_points_for_block: pushed to stack\");\n+                self.stack.push(pred_term_point);\n+            }\n+        }\n+\n+        // Note 1. There is a weird scenario that you might imagine\n+        // being problematic here, but which actually cannot happen.\n+        // The problem would be if we had a variable that *is* initialized\n+        // (but dead) on entry to the terminator, and where the current value\n+        // will be dropped in the case of unwind. In that case, we ought to\n+        // consider `X` to be drop-live in between the last use and call.\n+        // Here is the example:\n+        //\n+        // ```\n+        // BB0 {\n+        //   X = ...\n+        //   use(X); // last use\n+        //   ...     // <-- X ought to be drop-live here\n+        //   X = call() goto BB1 unwind BB2\n+        // }\n+        //\n+        // BB1 {\n+        //   DROP(X)\n+        // }\n+        //\n+        // BB2 {\n+        //   DROP(X)\n+        // }\n+        // ```\n+        //\n+        // However, the current code would, when walking back from BB2,\n+        // simply stop and never explore BB0. This seems bad! But it turns\n+        // out this code is flawed anyway -- note that the existing value of\n+        // `X` would leak in the case where unwinding did *not* occur.\n+        //\n+        // What we *actually* generate is a store to a temporary\n+        // for the call (`TMP = call()...`) and then a\n+        // `DropAndReplace` to swap that with `X`\n+        // (`DropAndReplace` has very particular semantics).\n+    }\n+}\n+\n+impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n+    /// True if the local variable (or some part of it) is initialized in\n+    /// the terminator of `block`. We need to check this to determine if a\n+    /// DROP of some local variable will have an effect -- note that\n+    /// drops, as they may unwind, are always terminators.\n+    fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n+        // Compute the set of initialized paths at terminator of block\n+        // by resetting to the start of the block and then applying\n+        // the effects of all statements. This is the only way to get\n+        // \"just ahead\" of a terminator.\n+        self.flow_inits.reset_to_entry_of(block);\n+        for statement_index in 0..self.mir[block].statements.len() {\n+            let location = Location {\n+                block,\n+                statement_index,\n+            };\n+            self.flow_inits.reconstruct_statement_effect(location);\n+            self.flow_inits.apply_local_effect(location);\n+        }\n+\n+        self.flow_inits.has_any_child_of(mpi).is_some()\n+    }\n+\n+    /// True if the path `mpi` (or some part of it) is initialized at\n+    /// the exit of `block`.\n+    ///\n+    /// **Warning:** Does not account for the result of `Call`\n+    /// instructions.\n+    fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n+        self.flow_inits.reset_to_exit_of(block);\n+        self.flow_inits.has_any_child_of(mpi).is_some()\n+    }\n+\n+    /// Store the result that all regions in `value` are live for the\n+    /// points `live_at`.\n+    fn add_use_live_facts_for(\n+        &mut self,\n+        value: impl TypeFoldable<'tcx>,\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\"add_use_live_facts_for(value={:?})\", value);\n+\n+        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_facts_for(\n+        &mut self,\n+        dropped_local: Local,\n+        dropped_ty: Ty<'tcx>,\n+        drop_locations: &[Location],\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\n+            \"add_drop_live_constraint(\\\n+             dropped_local={:?}, \\\n+             dropped_ty={:?}, \\\n+             drop_locations={:?}, \\\n+             live_at={:?})\",\n+            dropped_local,\n+            dropped_ty,\n+            drop_locations,\n+            values::location_set_str(self.elements, live_at.iter()),\n+        );\n+\n+        let drop_data = self.drop_data.entry(dropped_ty).or_insert_with({\n+            let typeck = &mut self.typeck;\n+            move || Self::compute_drop_data(typeck, dropped_ty)\n+        });\n+\n+        if let Some(data) = &drop_data.region_constraint_data {\n+            for &drop_location in drop_locations {\n+                self.typeck\n+                    .push_region_constraints(drop_location.boring(), data);\n+            }\n+        }\n+\n+        drop_data.dropck_result.report_overflows(\n+            self.typeck.infcx.tcx,\n+            self.mir.source_info(*drop_locations.first().unwrap()).span,\n+            dropped_ty,\n+        );\n+\n+        // All things in the `outlives` array may be touched by\n+        // the destructor and must be live at this point.\n+        for &kind in &drop_data.dropck_result.kinds {\n+            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n+        }\n+    }\n+\n+    fn make_all_regions_live(\n+        elements: &RegionValueElements,\n+        typeck: &mut TypeChecker<'_, '_, 'tcx>,\n+        value: impl TypeFoldable<'tcx>,\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\"make_all_regions_live(value={:?})\", value);\n+        debug!(\n+            \"make_all_regions_live: live_at={}\",\n+            values::location_set_str(elements, live_at.iter()),\n+        );\n+\n+        let tcx = typeck.tcx();\n+        tcx.for_each_free_region(&value, |live_region| {\n+            let borrowck_context = typeck.borrowck_context.as_mut().unwrap();\n+            let live_region_vid = borrowck_context\n+                .universal_regions\n+                .to_region_vid(live_region);\n+            borrowck_context\n+                .constraints\n+                .liveness_constraints\n+                .add_elements(live_region_vid, live_at);\n+\n+            if let Some(_) = borrowck_context.all_facts {\n+                bug!(\"polonius liveness facts not implemented yet\")\n+            }\n+        });\n+    }\n+\n+    fn compute_drop_data(\n+        typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        dropped_ty: Ty<'tcx>,\n+    ) -> DropData<'tcx> {\n+        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n+\n+        let param_env = typeck.param_env;\n+        let (dropck_result, region_constraint_data) = param_env\n+            .and(DropckOutlives::new(dropped_ty))\n+            .fully_perform(typeck.infcx)\n+            .unwrap();\n+\n+        DropData {\n+            dropck_result,\n+            region_constraint_data,\n+        }\n+    }\n+}"}, {"sha": "3a5857f775fa458b1be915c99cf2130a1fb5aee2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -18,9 +18,7 @@ use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n-use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -43,7 +41,6 @@ use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n-use util::liveness::LivenessResults;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -143,7 +140,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         all_facts,\n     );\n \n-    let (liveness, liveness_map) = {\n+    {\n         let mut borrowck_context = BorrowCheckContext {\n             universal_regions,\n             location_table,\n@@ -169,16 +166,14 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n                     &universal_region_relations,\n                     &normalized_inputs_and_output,\n                 );\n-                liveness::generate(cx, mir, flow_inits, move_data)\n+                liveness::generate(cx, mir, elements, flow_inits, move_data);\n             },\n-        )\n-    };\n+        );\n+    }\n \n     MirTypeckResults {\n         constraints,\n         universal_region_relations,\n-        liveness,\n-        liveness_map,\n     }\n }\n \n@@ -672,8 +667,6 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n-    crate liveness: LivenessResults<LocalWithRegion>,\n-    crate liveness_map: NllLivenessMap,\n }\n \n /// A collection of region constraints that must be satisfied for the"}, {"sha": "d97c0c9b430197a53b800cfc2e6f573b15e9b6d8", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -28,6 +28,15 @@ pub trait FlowsAtLocation {\n     /// Reset the state bitvector to represent the entry to block `bb`.\n     fn reset_to_entry_of(&mut self, bb: BasicBlock);\n \n+    /// Reset the state bitvector to represent the exit of the\n+    /// terminator of block `bb`.\n+    ///\n+    /// **Important:** In the case of a `Call` terminator, these\n+    /// effects do *not* include the result of storing the destination\n+    /// of the call, since that is edge-dependent (in other words, the\n+    /// effects don't apply to the unwind edge).\n+    fn reset_to_exit_of(&mut self, bb: BasicBlock);\n+\n     /// Build gen + kill sets for statement at `loc`.\n     ///\n     /// Note that invoking this method alone does not change the\n@@ -142,6 +151,12 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n         self.curr_state.overwrite(self.base_results.sets().on_entry_set_for(bb.index()));\n     }\n \n+    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n+        self.reset_to_entry_of(bb);\n+        self.curr_state.union(self.base_results.sets().gen_set_for(bb.index()));\n+        self.curr_state.subtract(self.base_results.sets().kill_set_for(bb.index()));\n+    }\n+\n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_gen.clear();\n         self.stmt_kill.clear();"}, {"sha": "fd6569feb5c201910e6e3873f5b64a25f034a887", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -454,14 +454,18 @@ pub struct AllSets<E: Idx> {\n     /// For each block, bits valid on entry to the block.\n     on_entry_sets: Vec<IdxSet<E>>,\n \n-    /// For each block, bits generated by executing the statements in\n-    /// the block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n+    /// For each block, bits generated by executing the statements +\n+    /// terminator in the block -- with one caveat. In particular, for\n+    /// *call terminators*, the effect of storing the destination is\n+    /// not included, since that only takes effect on the **success**\n+    /// edge (and not the unwind edge).\n     gen_sets: Vec<HybridIdxSet<E>>,\n \n-    /// For each block, bits killed by executing the statements in the\n-    /// block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n+    /// For each block, bits killed by executing the statements +\n+    /// terminator in the block -- with one caveat. In particular, for\n+    /// *call terminators*, the effect of storing the destination is\n+    /// not included, since that only takes effect on the **success**\n+    /// edge (and not the unwind edge).\n     kill_sets: Vec<HybridIdxSet<E>>,\n }\n "}, {"sha": "cfa84264b1f5a6a56d9cdffe80b190c7dae829c6", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -17,6 +17,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![cfg_attr(not(stage0), feature(nll))]\n #![cfg_attr(not(stage0), feature(infer_outlives_requirements))]\n #![feature(in_band_lifetimes)]\n+#![feature(impl_header_lifetime_elision)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(box_patterns)]"}, {"sha": "e9afa7df5c4f23d7536c8c445e576e7342c32414", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -66,7 +66,7 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n-use util::liveness::{self, IdentityMap, LivenessMode};\n+use util::liveness::{self, IdentityMap};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSet;\n use std::collections::HashMap;\n@@ -402,10 +402,6 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         mir,\n-        LivenessMode {\n-            include_regular_use: true,\n-            include_drops: true,\n-        },\n         &IdentityMap::new(mir),\n     );\n     liveness::dump_mir("}, {"sha": "3ae470e1d4bbd113f00d04297b60629c352804aa", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 14, "deletions": 179, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -33,7 +33,6 @@\n //! generator yield points, all pre-existing references are invalidated, so this\n //! doesn't matter).\n \n-use rustc::mir::visit::MirVisitable;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::Local;\n use rustc::mir::*;\n@@ -50,17 +49,13 @@ use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n pub type LiveVarSet<V> = IdxSet<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n-/// basic blocks. You can use `simulate_block` to obtain the\n-/// intra-block results.\n+/// basic blocks.\n ///\n /// The `V` type defines the set of variables that we computed\n /// liveness for. This is often `Local`, in which case we computed\n /// liveness for all variables -- but it can also be some other type,\n /// which indicates a subset of the variables within the graph.\n pub struct LivenessResult<V: Idx> {\n-    /// Liveness mode in use when these results were computed.\n-    pub mode: LivenessMode,\n-\n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n     pub outs: IndexVec<BasicBlock, LiveVarSet<V>>,\n@@ -104,76 +99,19 @@ impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct LivenessMode {\n-    /// If true, then we will consider \"regular uses\" of a variable to be live.\n-    /// For example, if the user writes `foo(x)`, then this is a regular use of\n-    /// the variable `x`.\n-    pub include_regular_use: bool,\n-\n-    /// If true, then we will consider (implicit) drops of a variable\n-    /// to be live.  For example, if the user writes `{ let x =\n-    /// vec![...]; .. }`, then the drop at the end of the block is an\n-    /// implicit drop.\n-    ///\n-    /// NB. Despite its name, a call like `::std::mem::drop(x)` is\n-    /// **not** considered a drop for this purposes, but rather a\n-    /// regular use.\n-    pub include_drops: bool,\n-}\n-\n-/// A combination of liveness results, used in NLL.\n-pub struct LivenessResults<V: Idx> {\n-    /// Liveness results where a regular use makes a variable X live,\n-    /// but not a drop.\n-    pub regular: LivenessResult<V>,\n-\n-    /// Liveness results where a drop makes a variable X live,\n-    /// but not a regular use.\n-    pub drop: LivenessResult<V>,\n-}\n-\n-impl<V: Idx> LivenessResults<V> {\n-    pub fn compute<'tcx>(\n-        mir: &Mir<'tcx>,\n-        map: &impl LiveVariableMap<LiveVar = V>,\n-    ) -> LivenessResults<V> {\n-        LivenessResults {\n-            regular: liveness_of_locals(\n-                &mir,\n-                LivenessMode {\n-                    include_regular_use: true,\n-                    include_drops: false,\n-                },\n-                map,\n-            ),\n-\n-            drop: liveness_of_locals(\n-                &mir,\n-                LivenessMode {\n-                    include_regular_use: false,\n-                    include_drops: true,\n-                },\n-                map,\n-            ),\n-        }\n-    }\n-}\n-\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n pub fn liveness_of_locals<'tcx, V: Idx>(\n     mir: &Mir<'tcx>,\n-    mode: LivenessMode,\n     map: &impl LiveVariableMap<LiveVar = V>,\n ) -> LivenessResult<V> {\n     let num_live_vars = map.num_variables();\n \n     let def_use: IndexVec<_, DefsUses<V>> = mir\n         .basic_blocks()\n         .iter()\n-        .map(|b| block(mode, map, b, num_live_vars))\n+        .map(|b| block(map, b, num_live_vars))\n         .collect();\n \n     let mut outs: IndexVec<_, LiveVarSet<V>> = mir\n@@ -208,80 +146,17 @@ pub fn liveness_of_locals<'tcx, V: Idx>(\n         }\n     }\n \n-    LivenessResult { mode, outs }\n-}\n-\n-impl<V: Idx> LivenessResult<V> {\n-    /// Walks backwards through the statements/terminator in the given\n-    /// basic block `block`.  At each point within `block`, invokes\n-    /// the callback `op` with the current location and the set of\n-    /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        block: BasicBlock,\n-        map: &impl LiveVariableMap<LiveVar = V>,\n-        mut callback: OP,\n-    ) where\n-        OP: FnMut(Location, &LiveVarSet<V>),\n-    {\n-        let data = &mir[block];\n-\n-        // Get a copy of the bits on exit from the block.\n-        let mut bits = self.outs[block].clone();\n-\n-        // Start with the maximal statement index -- i.e., right before\n-        // the terminator executes.\n-        let mut statement_index = data.statements.len();\n-\n-        // Compute liveness right before terminator and invoke callback.\n-        let terminator_location = Location {\n-            block,\n-            statement_index,\n-        };\n-        let num_live_vars = map.num_variables();\n-        let mut visitor = DefsUsesVisitor {\n-            mode: self.mode,\n-            map,\n-            defs_uses: DefsUses {\n-                defs: LiveVarSet::new_empty(num_live_vars),\n-                uses: LiveVarSet::new_empty(num_live_vars),\n-            },\n-        };\n-        // Visit the various parts of the basic block in reverse. If we go\n-        // forward, the logic in `add_def` and `add_use` would be wrong.\n-        visitor.update_bits_and_do_callback(\n-            terminator_location,\n-            &data.terminator,\n-            &mut bits,\n-            &mut callback,\n-        );\n-\n-        // Compute liveness before each statement (in rev order) and invoke callback.\n-        for statement in data.statements.iter().rev() {\n-            statement_index -= 1;\n-            let statement_location = Location {\n-                block,\n-                statement_index,\n-            };\n-            visitor.defs_uses.clear();\n-            visitor.update_bits_and_do_callback(\n-                statement_location,\n-                statement,\n-                &mut bits,\n-                &mut callback,\n-            );\n-        }\n-    }\n+    LivenessResult { outs }\n }\n \n #[derive(Eq, PartialEq, Clone)]\n pub enum DefUse {\n     Def,\n     Use,\n+    Drop,\n }\n \n-pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Option<DefUse> {\n+pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n     match context {\n         ///////////////////////////////////////////////////////////////////////////\n         // DEFS\n@@ -322,13 +197,8 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n         PlaceContext::Inspect |\n         PlaceContext::Copy |\n         PlaceContext::Move |\n-        PlaceContext::Validate => {\n-            if mode.include_regular_use {\n-                Some(DefUse::Use)\n-            } else {\n-                None\n-            }\n-        }\n+        PlaceContext::Validate =>\n+            Some(DefUse::Use),\n \n         ///////////////////////////////////////////////////////////////////////////\n         // DROP USES\n@@ -338,13 +208,8 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n         // uses in drop are special because `#[may_dangle]`\n         // attributes can affect whether lifetimes must be live.\n \n-        PlaceContext::Drop => {\n-            if mode.include_drops {\n-                Some(DefUse::Use)\n-            } else {\n-                None\n-            }\n-        }\n+        PlaceContext::Drop =>\n+            Some(DefUse::Drop),\n     }\n }\n \n@@ -353,7 +218,6 @@ where\n     V: Idx,\n     M: LiveVariableMap<LiveVar = V> + 'lv,\n {\n-    mode: LivenessMode,\n     map: &'lv M,\n     defs_uses: DefsUses<V>,\n }\n@@ -365,11 +229,6 @@ struct DefsUses<V: Idx> {\n }\n \n impl<V: Idx> DefsUses<V> {\n-    fn clear(&mut self) {\n-        self.uses.clear();\n-        self.defs.clear();\n-    }\n-\n     fn apply(&self, bits: &mut LiveVarSet<V>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n@@ -404,53 +263,28 @@ impl<V: Idx> DefsUses<V> {\n     }\n }\n \n-impl<'lv, V, M> DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V>,\n-{\n-    /// Update `bits` with the effects of `value` and call `callback`. We\n-    /// should always visit in reverse order. This method assumes that we have\n-    /// not visited anything before; if you have, clear `bits` first.\n-    fn update_bits_and_do_callback<'tcx, OP>(\n-        &mut self,\n-        location: Location,\n-        value: &impl MirVisitable<'tcx>,\n-        bits: &mut LiveVarSet<V>,\n-        callback: &mut OP,\n-    ) where\n-        OP: FnMut(Location, &LiveVarSet<V>),\n-    {\n-        value.apply(location, self);\n-        self.defs_uses.apply(bits);\n-        callback(location, bits);\n-    }\n-}\n-\n impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n where\n     V: Idx,\n     M: LiveVariableMap<LiveVar = V>,\n {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n         if let Some(v_index) = self.map.from_local(local) {\n-            match categorize(context, self.mode) {\n+            match categorize(context) {\n                 Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n-                Some(DefUse::Use) => self.defs_uses.add_use(v_index),\n-                None => (),\n+                Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(v_index),\n+                _ => (),\n             }\n         }\n     }\n }\n \n fn block<'tcx, V: Idx>(\n-    mode: LivenessMode,\n     map: &impl LiveVariableMap<LiveVar = V>,\n     b: &BasicBlockData<'tcx>,\n     locals: usize,\n ) -> DefsUses<V> {\n     let mut visitor = DefsUsesVisitor {\n-        mode,\n         map,\n         defs_uses: DefsUses {\n             defs: LiveVarSet::new_empty(locals),\n@@ -526,7 +360,8 @@ pub fn write_mir_fn<'a, 'tcx, V: Idx>(\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n         let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet<V>>| {\n-            let live: Vec<String> = result[block].iter()\n+            let live: Vec<String> = result[block]\n+                .iter()\n                 .map(|v| map.from_live_var(v))\n                 .map(|local| format!(\"{:?}\", local))\n                 .collect();"}, {"sha": "ffc5603bb1670d68173307baae418846d7eb86d6", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -34,15 +34,15 @@ fn main() {\n // | '_#4r    | Local    | ['_#4r]\n // |\n // | Inferred Region Values\n-// | '_#0r    | U0 | {bb0[0..=127], '_#0r}\n-// | '_#1r    | U0 | {bb0[0..=127], '_#1r}\n-// | '_#2r    | U0 | {bb0[0..=127], '_#2r}\n-// | '_#3r    | U0 | {bb0[0..=127], '_#3r}\n-// | '_#4r    | U0 | {bb0[0..=127], '_#4r}\n-// | '_#5r    | U0 | {bb0[0..=127], '_#1r}\n-// | '_#6r    | U0 | {bb0[0..=127], '_#2r}\n-// | '_#7r    | U0 | {bb0[0..=127], '_#1r}\n-// | '_#8r    | U0 | {bb0[0..=127], '_#3r}\n+// | '_#0r    | U0 | {bb0[0..=1], '_#0r}\n+// | '_#1r    | U0 | {bb0[0..=1], '_#1r}\n+// | '_#2r    | U0 | {bb0[0..=1], '_#2r}\n+// | '_#3r    | U0 | {bb0[0..=1], '_#3r}\n+// | '_#4r    | U0 | {bb0[0..=1], '_#4r}\n+// | '_#5r    | U0 | {bb0[0..=1], '_#1r}\n+// | '_#6r    | U0 | {bb0[0..=1], '_#2r}\n+// | '_#7r    | U0 | {bb0[0..=1], '_#1r}\n+// | '_#8r    | U0 | {bb0[0..=1], '_#3r}\n // |\n // ...\n // fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {"}, {"sha": "808114f3fa9b4f64e900a615a7a27d118107fe17", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir\n-\n-\n #![allow(warnings)]\n+#![feature(nll)]\n \n struct Wrap<'p> { p: &'p mut i32 }\n "}, {"sha": "6fc26d502d30de8b7edea00c4c60ab90c8c2c4ea", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83ddc33347cade429fdb47509818e775a67c1af6/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr?ref=83ddc33347cade429fdb47509818e775a67c1af6", "patch": "@@ -1,5 +1,5 @@\n error[E0506]: cannot assign to `x` because it is borrowed\n-  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:32:5\n+  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:30:5\n    |\n LL |     let wrap = Wrap { p: &mut x };\n    |                          ------ borrow of `x` occurs here"}]}