{"sha": "f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YWU1YmMxYzVhOTg0MjcyNDRhOGIzYWJkN2M3ZTMzNzI2N2ZiMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T06:04:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-13T06:04:54Z"}, "message": "Auto merge of #50622 - eddyb:make-room-for-ghosts, r=nikomatsakis\n\nrustc: leave space for fields of uninhabited types to allow partial initialization.\n\nFixes #49298 by only collapsing uninhabited enum variants, and only if they only have ZST fields.\nFixes #50442 incidentally (@nox's optimization didn't take into account uninhabited variants).", "tree": {"sha": "04a5d07da6284da6470417a715f50eb624025df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04a5d07da6284da6470417a715f50eb624025df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "html_url": "https://github.com/rust-lang/rust/commit/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc409ed0938cd2f501642abcaa675977fa5035a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc409ed0938cd2f501642abcaa675977fa5035a", "html_url": "https://github.com/rust-lang/rust/commit/6fc409ed0938cd2f501642abcaa675977fa5035a"}, {"sha": "9235c9ff462f1ed05e9bcf7b06c1f3c1bbc875e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9235c9ff462f1ed05e9bcf7b06c1f3c1bbc875e2", "html_url": "https://github.com/rust-lang/rust/commit/9235c9ff462f1ed05e9bcf7b06c1f3c1bbc875e2"}], "stats": {"total": 170, "additions": 124, "deletions": 46}, "files": [{"sha": "b22c025e86c0b569365357a91c0f410625236a5a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -325,10 +325,6 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         offsets.len(), ty);\n                 }\n \n-                if field.abi == Abi::Uninhabited {\n-                    return Ok(LayoutDetails::uninhabited(fields.len()));\n-                }\n-\n                 if field.is_unsized() {\n                     sized = false;\n                 }\n@@ -451,6 +447,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n             }\n \n+            if sized && fields.iter().any(|f| f.abi == Abi::Uninhabited) {\n+                abi = Abi::Uninhabited;\n+            }\n+\n             Ok(LayoutDetails {\n                 variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Arbitrary {\n@@ -497,7 +497,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n             // The never type.\n             ty::TyNever => {\n-                tcx.intern_layout(LayoutDetails::uninhabited(0))\n+                tcx.intern_layout(LayoutDetails {\n+                    variants: Variants::Single { index: 0 },\n+                    fields: FieldPlacement::Union(0),\n+                    abi: Abi::Uninhabited,\n+                    align: dl.i8_align,\n+                    size: Size::from_bytes(0)\n+                })\n             }\n \n             // Potentially-fat pointers.\n@@ -711,27 +717,37 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }));\n                 }\n \n-                let (inh_first, inh_second) = {\n-                    let mut inh_variants = (0..variants.len()).filter(|&v| {\n-                        variants[v].iter().all(|f| f.abi != Abi::Uninhabited)\n+                // A variant is absent if it's uninhabited and only has ZST fields.\n+                // Present uninhabited variants only require space for their fields,\n+                // but *not* an encoding of the discriminant (e.g. a tag value).\n+                // See issue #49298 for more details on the need to leave space\n+                // for non-ZST uninhabited data (mostly partial initialization).\n+                let absent = |fields: &[TyLayout]| {\n+                    let uninhabited = fields.iter().any(|f| f.abi == Abi::Uninhabited);\n+                    let is_zst = fields.iter().all(|f| f.is_zst());\n+                    uninhabited && is_zst\n+                };\n+                let (present_first, present_second) = {\n+                    let mut present_variants = (0..variants.len()).filter(|&v| {\n+                        !absent(&variants[v])\n                     });\n-                    (inh_variants.next(), inh_variants.next())\n+                    (present_variants.next(), present_variants.next())\n                 };\n-                if inh_first.is_none() {\n-                    // Uninhabited because it has no variants, or only uninhabited ones.\n-                    return Ok(tcx.intern_layout(LayoutDetails::uninhabited(0)));\n+                if present_first.is_none() {\n+                    // Uninhabited because it has no variants, or only absent ones.\n+                    return tcx.layout_raw(param_env.and(tcx.types.never));\n                 }\n \n                 let is_struct = !def.is_enum() ||\n-                    // Only one variant is inhabited.\n-                    (inh_second.is_none() &&\n+                    // Only one variant is present.\n+                    (present_second.is_none() &&\n                     // Representation optimizations are allowed.\n                      !def.repr.inhibit_enum_layout_opt());\n                 if is_struct {\n                     // Struct, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    let v = inh_first.unwrap();\n+                    let v = present_first.unwrap();\n                     let kind = if def.is_enum() || variants[v].len() == 0 {\n                         StructKind::AlwaysSized\n                     } else {\n@@ -773,7 +789,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                     // Find one non-ZST variant.\n                     'variants: for (v, fields) in variants.iter().enumerate() {\n-                        if fields.iter().any(|f| f.abi == Abi::Uninhabited) {\n+                        if absent(fields) {\n                             continue 'variants;\n                         }\n                         for f in fields {\n@@ -816,7 +832,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             let offset = st[i].fields.offset(field_index) + offset;\n                             let size = st[i].size;\n \n-                            let abi = match st[i].abi {\n+                            let mut abi = match st[i].abi {\n                                 Abi::Scalar(_) => Abi::Scalar(niche.clone()),\n                                 Abi::ScalarPair(ref first, ref second) => {\n                                     // We need to use scalar_unit to reset the\n@@ -833,6 +849,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 _ => Abi::Aggregate { sized: true },\n                             };\n \n+                            if st.iter().all(|v| v.abi == Abi::Uninhabited) {\n+                                abi = Abi::Uninhabited;\n+                            }\n+\n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::NicheFilling {\n                                     dataful_variant: i,\n@@ -959,9 +979,6 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n                     for variant in &mut layout_variants {\n-                        if variant.abi == Abi::Uninhabited {\n-                            continue;\n-                        }\n                         match variant.fields {\n                             FieldPlacement::Arbitrary { ref mut offsets, .. } => {\n                                 for i in offsets {\n@@ -1055,6 +1072,11 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         }\n                     }\n                 }\n+\n+                if layout_variants.iter().all(|v| v.abi == Abi::Uninhabited) {\n+                    abi = Abi::Uninhabited;\n+                }\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n                         tag,\n@@ -1523,9 +1545,14 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     ty::TyAdt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!()\n                 };\n-                let mut details = LayoutDetails::uninhabited(fields);\n-                details.variants = Variants::Single { index: variant_index };\n-                cx.tcx().intern_layout(details)\n+                let tcx = cx.tcx();\n+                tcx.intern_layout(LayoutDetails {\n+                    variants: Variants::Single { index: variant_index },\n+                    fields: FieldPlacement::Union(fields),\n+                    abi: Abi::Uninhabited,\n+                    align: tcx.data_layout.i8_align,\n+                    size: Size::from_bytes(0)\n+                })\n             }\n \n             Variants::NicheFilling { ref variants, .. } |"}, {"sha": "6cd8e267ec5c114e43742f85195061ca18655901", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -761,17 +761,6 @@ impl LayoutDetails {\n             align,\n         }\n     }\n-\n-    pub fn uninhabited(field_count: usize) -> Self {\n-        let align = Align::from_bytes(1, 1).unwrap();\n-        LayoutDetails {\n-            variants: Variants::Single { index: 0 },\n-            fields: FieldPlacement::Union(field_count),\n-            abi: Abi::Uninhabited,\n-            align,\n-            size: Size::from_bytes(0)\n-        }\n-    }\n }\n \n /// The details of the layout of a type, alongside the type itself.\n@@ -826,10 +815,10 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// Returns true if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n-            Abi::Uninhabited => true,\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n             Abi::Vector { .. } => false,\n+            Abi::Uninhabited => self.size.bytes() == 0,\n             Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n         }\n     }"}, {"sha": "d2bf83942968d2c1fcff4b251d3b02b8c5d6c6bf", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -217,12 +217,9 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         let offset = self.layout.fields.offset(i);\n \n         let mut val = match (self.val, &self.layout.abi) {\n-            // If we're uninhabited, or the field is ZST, it has no data.\n-            _ if self.layout.abi == layout::Abi::Uninhabited || field.is_zst() => {\n-                return OperandRef {\n-                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bx.cx))),\n-                    layout: field\n-                };\n+            // If the field is ZST, it has no data.\n+            _ if field.is_zst() => {\n+                return OperandRef::new_zst(bx.cx, field);\n             }\n \n             // Newtype of a scalar, scalar pair or vector."}, {"sha": "32d26052aff5dd7ad36a0a634d020776b93541fe", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -213,10 +213,10 @@ pub trait LayoutLlvmExt<'tcx> {\n impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n-            layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n             layout::Abi::Vector { .. } => true,\n             layout::Abi::ScalarPair(..) => false,\n+            layout::Abi::Uninhabited |\n             layout::Abi::Aggregate { .. } => self.is_zst()\n         }\n     }"}, {"sha": "92f68dcfc349de1a7fbc5a088c57394c78692aa1", "filename": "src/test/run-pass/issue-46845.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-46845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-46845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-46845.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -24,14 +24,16 @@ union Foo {\n }\n \n // If all the variants are uninhabited, however, the union should be uninhabited.\n+// NOTE(#49298) the union being uninhabited shouldn't change its size.\n union Bar {\n     _a: (Never, u64),\n     _b: (u64, Never)\n }\n \n fn main() {\n     assert_eq!(mem::size_of::<Foo>(), 8);\n-    assert_eq!(mem::size_of::<Bar>(), 0);\n+    // See the note on `Bar`'s definition for why this isn't `0`.\n+    assert_eq!(mem::size_of::<Bar>(), 8);\n \n     let f = [Foo { a: 42 }, Foo { a: 10 }];\n     println!(\"{}\", unsafe { f[0].a });"}, {"sha": "0b2169c9476cd37305f4821bfc141d78cd2a9a71", "filename": "src/test/run-pass/issue-49298.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-49298.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-49298.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-49298.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(test)]\n+\n+extern crate test;\n+\n+enum Void {}\n+\n+fn main() {\n+    let mut x: (Void, usize);\n+    let mut y = 42;\n+    x.1 = 13;\n+\n+    // Make sure `y` stays on the stack.\n+    test::black_box(&mut y);\n+\n+    // Check that the write to `x.1` did not overwrite `y`.\n+    // Note that this doesn't fail with optimizations enabled,\n+    // because we can't keep `x.1` on the stack, like we can `y`,\n+    // as we can't borrow partially initialized variables.\n+    assert_eq!(y.to_string(), \"42\");\n+\n+    // Check that `(Void, usize)` has space for the `usize` field.\n+    assert_eq!(std::mem::size_of::<(Void, usize)>(),\n+               std::mem::size_of::<usize>());\n+}"}, {"sha": "1e43bebf5c32cf71c38cdc2a779c691949b50bfc", "filename": "src/test/run-pass/issue-50442.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-50442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Fissue-50442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-50442.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Void {}\n+\n+enum Foo {\n+    A(i32),\n+    B(Void),\n+    C(i32)\n+}\n+\n+fn main() {\n+    let _foo = Foo::A(0);\n+}"}, {"sha": "8f4613d6c373a0c0eae06c81cbeab5740284eac6", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=f9ae5bc1c5a98427244a8b3abd7c7e337267fb1c", "patch": "@@ -68,9 +68,15 @@ enum EnumSingle5 {\n     A = 42 as u8,\n }\n \n-enum NicheFilledEnumWithInhabitedVariant {\n+enum EnumWithMaybeUninhabitedVariant<T> {\n     A(&'static ()),\n-    B(&'static (), !),\n+    B(&'static (), T),\n+    C,\n+}\n+\n+enum NicheFilledEnumWithAbsentVariant {\n+    A(&'static ()),\n+    B((), !),\n     C,\n }\n \n@@ -107,5 +113,7 @@ pub fn main() {\n     assert_eq!(size_of::<EnumSingle4>(), 1);\n     assert_eq!(size_of::<EnumSingle5>(), 1);\n \n-    assert_eq!(size_of::<NicheFilledEnumWithInhabitedVariant>(), size_of::<&'static ()>());\n+    assert_eq!(size_of::<EnumWithMaybeUninhabitedVariant<!>>(),\n+               size_of::<EnumWithMaybeUninhabitedVariant<()>>());\n+    assert_eq!(size_of::<NicheFilledEnumWithAbsentVariant>(), size_of::<&'static ()>());\n }"}]}