{"sha": "55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1Y2I2M2FkZmUwOGEyMmVmY2I2NjhkNGY3ZGQwMmM4OWViNTgzNWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-06-11T04:46:26Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-06-11T05:07:09Z"}, "message": "Bump to 0.0.139", "tree": {"sha": "0a8b2fe12f872d48d9580e1a69f5e557f5a1c849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8b2fe12f872d48d9580e1a69f5e557f5a1c849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "html_url": "https://github.com/rust-lang/rust/commit/55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e151a4eab46757cd27c9dd2045fe3a43c7efde3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e151a4eab46757cd27c9dd2045fe3a43c7efde3", "html_url": "https://github.com/rust-lang/rust/commit/4e151a4eab46757cd27c9dd2045fe3a43c7efde3"}], "stats": {"total": 148, "additions": 67, "deletions": 81}, "files": [{"sha": "c338189cefe040c2feb59a16c2c91391ea39fa65", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -385,10 +385,12 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n-                                       db.span_suggestions(e.span, \"try\", improvements.into_iter().map(|suggestion| {\n-                                           suggest(self.cx, suggestion, &h2q.terminals)\n-                                       }).collect());\n-                                   });\n+                    db.span_suggestions(e.span,\n+                                        \"try\",\n+                                        improvements.into_iter()\n+                                            .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n+                                            .collect());\n+                });\n             }\n         }\n     }"}, {"sha": "8f8bdf472a5c665e0af1d780bfa207aec63df74d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -252,11 +252,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n /// Return the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        pat: &Pat,\n-        map: &mut HashMap<InternedString, Ty<'tcx>>\n-    ) {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, Ty<'tcx>>) {\n         match pat.node {\n             PatKind::Box(ref pat) |\n             PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),"}, {"sha": "10e5f2ba7c05dff64283a9bc58622f269c4cd40c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -98,17 +98,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 multispan_sugg(db,\n                                                \"use the values directly\".to_string(),\n-                                               vec![(left.span, lsnip),\n-                                                    (right.span, rsnip)]);\n+                                               vec![(left.span, lsnip), (right.span, rsnip)]);\n                             })\n-                        } else if lcpy && !rcpy &&\n-                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n+                        } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n-                        } else if !lcpy && rcpy &&\n-                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n+                        } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -123,8 +120,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprAddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n-                        if (requires_ref || lcpy) &&\n-                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n+                        if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n@@ -135,8 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (_, &ExprAddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n-                        if (requires_ref || rcpy) &&\n-                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n+                        if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);"}, {"sha": "c3a3f37fab59cdff48224a603c7f9b7121aa586c", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -71,8 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         };\n \n         let region_maps = &cx.tcx.region_maps(fn_def_id);\n-        ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables)\n-            .consume_body(body);\n+        ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n \n         for node in v.set {\n             span_lint(cx,\n@@ -134,15 +133,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n \n     }\n-    fn borrow(\n-        &mut self,\n-        _: NodeId,\n-        _: Span,\n-        cmt: cmt<'tcx>,\n-        _: ty::Region,\n-        _: ty::BorrowKind,\n-        loan_cause: LoanCause\n-    ) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n                 // x.foo()"}, {"sha": "7bac29f6808fa10cf8fb7ff6d9368bbac0aab24e", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -58,14 +58,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     }\n }\n \n-\n+#[allow(cast_possible_wrap)]\n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n             0 => v.to_u128_unchecked() == 0,\n-            -1 => match v.int_type() {\n-                SignedInt(_) => #[allow(cast_possible_wrap)] (v.to_u128_unchecked() as i128  == -1),\n-                UnsignedInt(_) =>  false\n+            -1 => {\n+                match v.int_type() {\n+                    SignedInt(_) => (v.to_u128_unchecked() as i128 == -1),\n+                    UnsignedInt(_) => false,\n+                }\n             },\n             1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),"}, {"sha": "ba4d24b1d62bdd6017b40ef799738ef9e53e9247", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -2,8 +2,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet, span_help_and_lint,\n-            walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///"}, {"sha": "3e9e2d06d054aba3f782b5bbbab85aca710eb5ce", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -226,14 +226,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     });\n }\n \n-fn check_single_match_opt_like(\n-    cx: &LateContext,\n-    ex: &Expr,\n-    arms: &[Arm],\n-    expr: &Expr,\n-    ty: Ty,\n-    els: Option<&Expr>\n-) {\n+fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[(&paths::COW, \"Borrowed\"),\n                        (&paths::COW, \"Cow::Borrowed\"),"}, {"sha": "08400600bb42844dc83f16c67f25fb6b3ee0ba0c", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -1351,7 +1351,14 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool, generics: &hir::Generics) -> bool {\n+    fn matches(\n+        self,\n+        ty: &hir::Ty,\n+        arg: &hir::Arg,\n+        self_ty: &hir::Ty,\n+        allow_value_for_ref: bool,\n+        generics: &hir::Generics\n+    ) -> bool {\n         // Self types in the HIR are desugared to explicit self types. So it will always be `self:\n         // SomeType`,\n         // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n@@ -1386,7 +1393,7 @@ impl SelfKind {\n                 SelfKind::Value => false,\n                 SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n                 SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                SelfKind::No => true\n+                SelfKind::No => true,\n             }\n         }\n     }\n@@ -1404,19 +1411,18 @@ impl SelfKind {\n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n-            param.name == seg.name && param.bounds.iter().any(|bound| {\n-                if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n-                    let path = &ptr.trait_ref.path;\n-                    match_path_old(path, name) && path.segments.last().map_or(false, |s| {\n-                        if let hir::PathParameters::AngleBracketedParameters(ref data) = s.parameters {\n-                            data.types.len() == 1 && (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n-                        } else {\n-                            false\n-                        }\n-                    })\n+            param.name == seg.name &&\n+            param.bounds.iter().any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                let path = &ptr.trait_ref.path;\n+                match_path_old(path, name) &&\n+                path.segments.last().map_or(false, |s| if let hir::PathParameters::AngleBracketedParameters(ref data) =\n+                    s.parameters {\n+                    data.types.len() == 1 && (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n                 } else {\n                     false\n-                }\n+                })\n+            } else {\n+                false\n             })\n         })\n     })\n@@ -1426,10 +1432,9 @@ fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n     match (&ty.node, &self_ty.node) {\n         (&hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n          &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path))) => {\n-            ty_path.segments.iter().map(|seg| seg.name).eq(\n-                self_ty_path.segments.iter().map(|seg| seg.name))\n-        }\n-        _ => false\n+            ty_path.segments.iter().map(|seg| seg.name).eq(self_ty_path.segments.iter().map(|seg| seg.name))\n+        },\n+        _ => false,\n     }\n }\n "}, {"sha": "02ccdb2d79b80d135385a0c4dd3e7dd2bd6ac118", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -516,7 +516,9 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(def_id) |\n         def::Def::Upvar(def_id, _, _) => {\n-            let id = cx.tcx.hir.as_local_node_id(def_id)\n+            let id = cx.tcx\n+                .hir\n+                .as_local_node_id(def_id)\n                 .expect(\"local variables should be found in the same crate\");\n             !in_macro(cx.tcx.hir.span(id))\n         },"}, {"sha": "b8aacb3b41833feda9c09f6bbb91512cfd507b75", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -91,8 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n             let region_maps = &cx.tcx.region_maps(fn_def_id);\n-            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables)\n-                .consume_body(body);\n+            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n             ctx\n         };\n "}, {"sha": "f608c7808a0be84302bd2481bd7f98c57ac21ec3", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -1107,6 +1107,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     }\n }\n \n+#[allow(cast_possible_wrap)]\n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_val::ConstVal::*;\n     use rustc_const_eval::ConstContext;\n@@ -1115,7 +1116,7 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n                 match const_int.int_type() {\n-                    IntType::SignedInt(_) => #[allow(cast_possible_wrap)] Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n+                    IntType::SignedInt(_) => Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n                     IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n                 }\n             } else {"}, {"sha": "7c7b3b57a11420b23267a8b713e0cf25b4da7b6e", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -76,8 +76,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_STD) ||\n-                      match_path(path, &paths::RANGE_INCLUSIVE) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_STD) || match_path(path, &paths::RANGE_INCLUSIVE) {\n                 Some(Range {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),"}, {"sha": "c2cbd4d4cd0328d0d9042956b2d38b1c4efc8544", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55cb63adfe08a22efcb668d4f7dd02c89eb5835f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "patch": "@@ -314,11 +314,11 @@ pub fn implements_trait<'a, 'tcx>(\n     ty_params: &[Ty<'tcx>]\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let obligation = cx.tcx.predicate_for_trait_def(\n-        cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n-    })\n+    let obligation = cx.tcx\n+        .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n+    cx.tcx\n+        .infer_ctxt()\n+        .enter(|infcx| traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation))\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n@@ -575,7 +575,14 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// replacement. In human-readable format though, it only appears once before the whole suggestion.\n pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(Span, String)>) {\n     let sugg = rustc_errors::CodeSuggestion {\n-        substitution_parts: sugg.into_iter().map(|(span, sub)| rustc_errors::Substitution { span, substitutions: vec![sub] }).collect(),\n+        substitution_parts: sugg.into_iter()\n+            .map(|(span, sub)| {\n+                rustc_errors::Substitution {\n+                    span: span,\n+                    substitutions: vec![sub],\n+                }\n+            })\n+            .collect(),\n         msg: help_msg,\n     };\n     db.suggestions.push(sugg);\n@@ -764,14 +771,8 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'t\n /// Check if two types are the same.\n // FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n // not for type parameters.\n-pub fn same_tys<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    a: Ty<'tcx>,\n-    b: Ty<'tcx>\n-) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        infcx.can_eq(cx.param_env, a, b).is_ok()\n-    })\n+pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    cx.tcx.infer_ctxt().enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n }\n \n /// Return whether the given type is an `unsafe` function."}]}