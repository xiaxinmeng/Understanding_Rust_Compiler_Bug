{"sha": "986f40fab0828257016477174f9a6036a4a7f4d3", "node_id": "C_kwDOAAsO6NoAKDk4NmY0MGZhYjA4MjgyNTcwMTY0NzcxNzRmOWE2MDM2YTRhN2Y0ZDM", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-01-26T15:30:44Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-01-26T15:33:40Z"}, "message": "`invalid_regex`: Show full error when string value doesn't match source", "tree": {"sha": "1c14525e3fb7710f0b043257ac2fd21d8cea1549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c14525e3fb7710f0b043257ac2fd21d8cea1549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986f40fab0828257016477174f9a6036a4a7f4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986f40fab0828257016477174f9a6036a4a7f4d3", "html_url": "https://github.com/rust-lang/rust/commit/986f40fab0828257016477174f9a6036a4a7f4d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986f40fab0828257016477174f9a6036a4a7f4d3/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23ea47b7eb0439a991f69edf8b92ce550bcaffb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ea47b7eb0439a991f69edf8b92ce550bcaffb2", "html_url": "https://github.com/rust-lang/rust/commit/23ea47b7eb0439a991f69edf8b92ce550bcaffb2"}], "stats": {"total": 159, "additions": 97, "deletions": 62}, "files": [{"sha": "9e6c6c73d4fe74cc3b351e03fa50f346bee79497", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/986f40fab0828257016477174f9a6036a4a7f4d3/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f40fab0828257016477174f9a6036a4a7f4d3/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=986f40fab0828257016477174f9a6036a4a7f4d3", "patch": "@@ -1,5 +1,8 @@\n+use std::fmt::Display;\n+\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::source::snippet_opt;\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{LitKind, StrStyle};\n@@ -77,13 +80,45 @@ impl<'tcx> LateLintPass<'tcx> for Regex {\n     }\n }\n \n-#[must_use]\n-fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u8) -> Span {\n-    let offset = u32::from(offset);\n-    let end = base.lo() + BytePos(u32::try_from(c.end.offset).expect(\"offset too large\") + offset);\n-    let start = base.lo() + BytePos(u32::try_from(c.start.offset).expect(\"offset too large\") + offset);\n-    assert!(start <= end);\n-    Span::new(start, end, base.ctxt(), base.parent())\n+fn lint_syntax_error(cx: &LateContext<'_>, error: &regex_syntax::Error, unescaped: &str, base: Span, offset: u8) {\n+    let parts: Option<(_, _, &dyn Display)> = match &error {\n+        regex_syntax::Error::Parse(e) => Some((e.span(), e.auxiliary_span(), e.kind())),\n+        regex_syntax::Error::Translate(e) => Some((e.span(), None, e.kind())),\n+        _ => None,\n+    };\n+\n+    let convert_span = |regex_span: &regex_syntax::ast::Span| {\n+        let offset = u32::from(offset);\n+        let start = base.lo() + BytePos(u32::try_from(regex_span.start.offset).expect(\"offset too large\") + offset);\n+        let end = base.lo() + BytePos(u32::try_from(regex_span.end.offset).expect(\"offset too large\") + offset);\n+\n+        Span::new(start, end, base.ctxt(), base.parent())\n+    };\n+\n+    if let Some((primary, auxiliary, kind)) = parts\n+        && let Some(literal_snippet) = snippet_opt(cx, base)\n+        && let Some(inner) = literal_snippet.get(offset as usize..)\n+        // Only convert to native rustc spans if the parsed regex matches the\n+        // source snippet exactly, to ensure the span offsets are correct\n+        && inner.get(..unescaped.len()) == Some(unescaped)\n+    {\n+        let spans = if let Some(auxiliary) = auxiliary {\n+            vec![convert_span(primary), convert_span(auxiliary)]\n+        } else {\n+            vec![convert_span(primary)]\n+        };\n+\n+        span_lint(cx, INVALID_REGEX, spans, &format!(\"regex syntax error: {kind}\"));\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            INVALID_REGEX,\n+            base,\n+            &error.to_string(),\n+            None,\n+            \"consider using a raw string literal: `r\\\"..\\\"`\",\n+        );\n+    }\n }\n \n fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n@@ -155,25 +190,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                         span_lint_and_help(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", None, repl);\n                     }\n                 },\n-                Err(regex_syntax::Error::Parse(e)) => {\n-                    span_lint(\n-                        cx,\n-                        INVALID_REGEX,\n-                        str_span(expr.span, *e.span(), offset),\n-                        &format!(\"regex syntax error: {}\", e.kind()),\n-                    );\n-                },\n-                Err(regex_syntax::Error::Translate(e)) => {\n-                    span_lint(\n-                        cx,\n-                        INVALID_REGEX,\n-                        str_span(expr.span, *e.span(), offset),\n-                        &format!(\"regex syntax error: {}\", e.kind()),\n-                    );\n-                },\n-                Err(e) => {\n-                    span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n-                },\n+                Err(e) => lint_syntax_error(cx, &e, r, expr.span, offset),\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n@@ -183,25 +200,7 @@ fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n                     span_lint_and_help(cx, TRIVIAL_REGEX, expr.span, \"trivial regex\", None, repl);\n                 }\n             },\n-            Err(regex_syntax::Error::Parse(e)) => {\n-                span_lint(\n-                    cx,\n-                    INVALID_REGEX,\n-                    expr.span,\n-                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n-                );\n-            },\n-            Err(regex_syntax::Error::Translate(e)) => {\n-                span_lint(\n-                    cx,\n-                    INVALID_REGEX,\n-                    expr.span,\n-                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n-                );\n-            },\n-            Err(e) => {\n-                span_lint(cx, INVALID_REGEX, expr.span, &format!(\"regex syntax error: {e}\"));\n-            },\n+            Err(e) => span_lint(cx, INVALID_REGEX, expr.span, &e.to_string()),\n         }\n     }\n }"}, {"sha": "ab8ac97a0e7071575e1361ddb5f07477e22335e5", "filename": "tests/ui/regex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/986f40fab0828257016477174f9a6036a4a7f4d3/tests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f40fab0828257016477174f9a6036a4a7f4d3/tests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.rs?ref=986f40fab0828257016477174f9a6036a4a7f4d3", "patch": "@@ -36,6 +36,10 @@ fn syntax_error() {\n \n     let raw_string_error = Regex::new(r\"[...\\/...]\");\n     let raw_string_error = Regex::new(r#\"[...\\/...]\"#);\n+\n+    let escaped_string_span = Regex::new(\"\\\\b\\\\c\");\n+\n+    let aux_span = Regex::new(\"(?ixi)\");\n }\n \n fn trivial_regex() {"}, {"sha": "c2440f39e0a032229db7de11998f1e8bc1cc4f23", "filename": "tests/ui/regex.stderr", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/986f40fab0828257016477174f9a6036a4a7f4d3/tests%2Fui%2Fregex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/986f40fab0828257016477174f9a6036a4a7f4d3/tests%2Fui%2Fregex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.stderr?ref=986f40fab0828257016477174f9a6036a4a7f4d3", "patch": "@@ -29,7 +29,10 @@ error: regex syntax error: invalid character class range, the start must be <= t\n LL |     let some_unicode = Regex::new(\"[\u00e9-\u00e8]\");\n    |                                     ^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:18:33\n    |\n LL |     let some_regex = Regex::new(OPENING_PAREN);\n@@ -43,25 +46,37 @@ LL |     let binary_pipe_in_wrong_position = BRegex::new(\"|\");\n    |\n    = help: the regex is unlikely to be useful as it is\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:21:41\n    |\n LL |     let some_binary_regex = BRegex::new(OPENING_PAREN);\n    |                                         ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:22:56\n    |\n LL |     let some_binary_regex_builder = BRegexBuilder::new(OPENING_PAREN);\n    |                                                        ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:34:37\n    |\n LL |     let set_error = RegexSet::new(&[OPENING_PAREN, r\"[a-z]+/.(com|org|net)\"]);\n    |                                     ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed group\n+error: regex parse error:\n+           (\n+           ^\n+       error: unclosed group\n   --> $DIR/regex.rs:35:39\n    |\n LL |     let bset_error = BRegexSet::new(&[OPENING_PAREN, r\"[a-z]+/.(com|org|net)\"]);\n@@ -79,93 +94,110 @@ error: regex syntax error: unrecognized escape sequence\n LL |     let raw_string_error = Regex::new(r#\"[...//...]\"#);\n    |                                              ^^\n \n+error: regex parse error:\n+           /b/c\n+             ^^\n+       error: unrecognized escape sequence\n+  --> $DIR/regex.rs:40:42\n+   |\n+LL |     let escaped_string_span = Regex::new(\"/b/c\");\n+   |                                          ^^^^^^^^\n+   |\n+   = help: consider using a raw string literal: `r\"..\"`\n+\n+error: regex syntax error: duplicate flag\n+  --> $DIR/regex.rs:42:34\n+   |\n+LL |     let aux_span = Regex::new(\"(?ixi)\");\n+   |                                  ^ ^\n+\n error: trivial regex\n-  --> $DIR/regex.rs:42:33\n+  --> $DIR/regex.rs:46:33\n    |\n LL |     let trivial_eq = Regex::new(\"^foobar$\");\n    |                                 ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:44:48\n+  --> $DIR/regex.rs:48:48\n    |\n LL |     let trivial_eq_builder = RegexBuilder::new(\"^foobar$\");\n    |                                                ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:46:42\n+  --> $DIR/regex.rs:50:42\n    |\n LL |     let trivial_starts_with = Regex::new(\"^foobar\");\n    |                                          ^^^^^^^^^\n    |\n    = help: consider using `str::starts_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:48:40\n+  --> $DIR/regex.rs:52:40\n    |\n LL |     let trivial_ends_with = Regex::new(\"foobar$\");\n    |                                        ^^^^^^^^^\n    |\n    = help: consider using `str::ends_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:50:39\n+  --> $DIR/regex.rs:54:39\n    |\n LL |     let trivial_contains = Regex::new(\"foobar\");\n    |                                       ^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:52:39\n+  --> $DIR/regex.rs:56:39\n    |\n LL |     let trivial_contains = Regex::new(NOT_A_REAL_REGEX);\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:54:40\n+  --> $DIR/regex.rs:58:40\n    |\n LL |     let trivial_backslash = Regex::new(\"a/.b\");\n    |                                        ^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:57:36\n+  --> $DIR/regex.rs:61:36\n    |\n LL |     let trivial_empty = Regex::new(\"\");\n    |                                    ^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:59:36\n+  --> $DIR/regex.rs:63:36\n    |\n LL |     let trivial_empty = Regex::new(\"^\");\n    |                                    ^^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:61:36\n+  --> $DIR/regex.rs:65:36\n    |\n LL |     let trivial_empty = Regex::new(\"^$\");\n    |                                    ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n error: trivial regex\n-  --> $DIR/regex.rs:63:44\n+  --> $DIR/regex.rs:67:44\n    |\n LL |     let binary_trivial_empty = BRegex::new(\"^$\");\n    |                                            ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 25 previous errors\n "}]}