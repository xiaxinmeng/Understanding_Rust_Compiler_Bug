{"sha": "e17e6af4f0acd692225130a278174047ecb252ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxN2U2YWY0ZjBhY2Q2OTIyMjUxMzBhMjc4MTc0MDQ3ZWNiMjUyYWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T11:50:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T11:50:58Z"}, "message": "Change a number of result-returning functions to return @block_ctxt\n\nThe uniformity doesn't seem to be worth the extra noise and pointless\ncode being generated. If something doesn't produce a value, don't make\nit return one. (For now, trans_[exprtype] things are left in the result-\nreturning form, even when they never return anything useful, since in\nthat case uniformity is arguably helpful.)", "tree": {"sha": "980bcd76de5ffdc9b30481fb8f5a20ce63649451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/980bcd76de5ffdc9b30481fb8f5a20ce63649451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e17e6af4f0acd692225130a278174047ecb252ae", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e17e6af4f0acd692225130a278174047ecb252ae", "html_url": "https://github.com/rust-lang/rust/commit/e17e6af4f0acd692225130a278174047ecb252ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e17e6af4f0acd692225130a278174047ecb252ae/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adec3ecfe0424826b4a55b837dd71fbd8ef4a27c", "url": "https://api.github.com/repos/rust-lang/rust/commits/adec3ecfe0424826b4a55b837dd71fbd8ef4a27c", "html_url": "https://github.com/rust-lang/rust/commit/adec3ecfe0424826b4a55b837dd71fbd8ef4a27c"}], "stats": {"total": 421, "additions": 187, "deletions": 234}, "files": [{"sha": "454a9429eede95bde74e7c1e0c1563d06af03188", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 170, "deletions": 218, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e17e6af4f0acd692225130a278174047ecb252ae", "patch": "@@ -404,17 +404,17 @@ fn trans_native_call(cx: &@block_ctxt, externs: &hashmap<istr, ValueRef>,\n     ret Call(cx, llnative, call_args);\n }\n \n-fn trans_non_gc_free(cx: &@block_ctxt, v: ValueRef) -> result {\n+fn trans_non_gc_free(cx: &@block_ctxt, v: ValueRef) -> @block_ctxt {\n     Call(cx, bcx_ccx(cx).upcalls.free,\n                   [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8())),\n                    C_int(0)]);\n-    ret rslt(cx, C_int(0));\n+    ret cx;\n }\n \n-fn trans_shared_free(cx: &@block_ctxt, v: ValueRef) -> result {\n+fn trans_shared_free(cx: &@block_ctxt, v: ValueRef) -> @block_ctxt {\n     Call(cx, bcx_ccx(cx).upcalls.shared_free,\n                   [cx.fcx.lltaskptr, PointerCast(cx, v, T_ptr(T_i8()))]);\n-    ret rslt(cx, C_int(0));\n+    ret cx;\n }\n \n fn umax(cx: &@block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n@@ -1312,18 +1312,18 @@ fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = cx;\n     // NB: v is an *alias* of type t here, not a direct value.\n     if ty::type_is_boxed(bcx_tcx(bcx), t) {\n-        bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v)).bcx;\n+        bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v));\n     } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n-        bcx = iter_structural_ty(bcx, v, t, take_ty).bcx;\n+        bcx = iter_structural_ty(bcx, v, t, take_ty);\n     } else if ty::type_is_ivec(bcx_tcx(bcx), t) {\n         bcx = ivec::duplicate(bcx, v);\n-        bcx = ivec::iter_ivec(bcx, v, t, take_ty).bcx;\n+        bcx = ivec::iter_ivec(bcx, v, t, take_ty);\n     }\n \n     build_return(bcx);\n }\n \n-fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n+fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     let rc_ptr =\n         GEP(cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n     let rc = Load(cx, rc_ptr);\n@@ -1336,119 +1336,104 @@ fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n     rc = Add(rc_adj_cx, rc, C_int(1));\n     Store(rc_adj_cx, rc, rc_ptr);\n     Br(rc_adj_cx, next_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n-fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n+fn make_free_glue(bcx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let rs =\n-        alt ty::struct(bcx_tcx(cx), t) {\n-          ty::ty_str. {\n-            let v = Load(cx, v0);\n-            if !bcx_ccx(cx).sess.get_opts().do_gc {\n-                trans_non_gc_free(cx, v)\n-            } else { rslt(cx, C_nil()) }\n-          }\n-          ty::ty_box(body_mt) {\n-            let v = Load(cx, v0);\n-            let body =\n-                GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let body_ty = body_mt.ty;\n-            let rs = drop_ty(cx, body, body_ty);\n-            if !bcx_ccx(cx).sess.get_opts().do_gc {\n-                trans_non_gc_free(rs.bcx, v)\n-            } else { rslt(cx, C_nil()) }\n-          }\n-          ty::ty_uniq(_) { fail \"free uniq unimplemented\"; }\n-          ty::ty_obj(_) {\n-            // Call through the obj's own fields-drop glue first.\n-            // Then free the body.\n-            let box_cell =\n-                GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            let b = Load(cx, box_cell);\n-            let ccx = bcx_ccx(cx);\n-            let llbox_ty = T_opaque_obj_ptr(*ccx);\n-            b = PointerCast(cx, b, llbox_ty);\n-            let body =\n-                GEP(cx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let tydescptr =\n-                GEP(cx, body,\n-                             [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n-            let tydesc = Load(cx, tydescptr);\n-            let ti = none::<@tydesc_info>;\n-            call_tydesc_glue_full(cx, body, tydesc,\n-                                  abi::tydesc_field_drop_glue, ti);\n-            if !bcx_ccx(cx).sess.get_opts().do_gc {\n-                trans_non_gc_free(cx, b)\n-            } else { rslt(cx, C_nil()) }\n-          }\n-          ty::ty_fn(_, _, _, _, _) {\n-            // Call through the closure's own fields-drop glue first.\n-            // Then free the body.\n-            let box_cell =\n-                GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            let v = Load(cx, box_cell);\n-            let body =\n-                GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let bindings =\n-                GEP(cx, body,\n-                             [C_int(0), C_int(abi::closure_elt_bindings)]);\n-            let tydescptr =\n-                GEP(cx, body,\n-                             [C_int(0), C_int(abi::closure_elt_tydesc)]);\n-            let ti = none::<@tydesc_info>;\n-            call_tydesc_glue_full(cx, bindings, Load(cx, tydescptr),\n-                                  abi::tydesc_field_drop_glue, ti);\n-            if !bcx_ccx(cx).sess.get_opts().do_gc {\n-                trans_non_gc_free(cx, v)\n-            } else { rslt(cx, C_nil()) }\n-          }\n-          _ { rslt(cx, C_nil()) }\n-        };\n+    let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_str. {\n+        let v = Load(bcx, v0);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, v)\n+        } else { bcx }\n+      }\n+      ty::ty_box(body_mt) {\n+        let v = Load(bcx, v0);\n+        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, v)\n+        } else { bcx }\n+      }\n+      ty::ty_uniq(_) { fail \"free uniq unimplemented\"; }\n+      ty::ty_obj(_) {\n+        // Call through the obj's own fields-drop glue first.\n+        // Then free the body.\n+        let box_cell =\n+            GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n+        let b = Load(bcx, box_cell);\n+        let ccx = bcx_ccx(bcx);\n+        let llbox_ty = T_opaque_obj_ptr(*ccx);\n+        b = PointerCast(bcx, b, llbox_ty);\n+        let body =\n+            GEP(bcx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let tydescptr =\n+            GEP(bcx, body, [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n+        let tydesc = Load(bcx, tydescptr);\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, body, tydesc,\n+                              abi::tydesc_field_drop_glue, ti);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, b)\n+        } else { bcx }\n+      }\n+      ty::ty_fn(_, _, _, _, _) {\n+        // Call through the closure's own fields-drop glue first.\n+        // Then free the body.\n+        let box_cell = GEP(bcx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n+        let v = Load(bcx, box_cell);\n+        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let bindings =\n+            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_bindings)]);\n+        let tydescptr =\n+            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_tydesc)]);\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n+                              abi::tydesc_field_drop_glue, ti);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, v)\n+        } else { bcx }\n+      }\n+      _ { bcx }\n+    };\n \n-    build_return(rs.bcx);\n+    build_return(bcx);\n }\n \n-fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n+fn make_drop_glue(bcx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let ccx = bcx_ccx(cx);\n-    let rs =\n-        alt ty::struct(ccx.tcx, t) {\n-          ty::ty_str. { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_vec(_) {\n-            rslt(ivec::make_drop_glue(cx, v0, t), C_nil())\n-          }\n-          ty::ty_istr. {\n-            rslt(ivec::make_drop_glue(cx, v0, t), C_nil())\n-          }\n-          ty::ty_box(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_uniq(_) { trans_shared_free(cx, Load(cx, v0)) }\n-          ty::ty_obj(_) {\n-            let box_cell =\n-                GEP(cx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            decr_refcnt_maybe_free(cx, box_cell, v0, t)\n-          }\n-          ty::ty_res(did, inner, tps) {\n-            trans_res_drop(cx, v0, did, inner, tps)\n-          }\n-          ty::ty_fn(_, _, _, _, _) {\n-            let box_cell =\n-                GEP(cx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            decr_refcnt_maybe_free(cx, box_cell, v0, t)\n-          }\n-          _ {\n-            if ty::type_has_pointers(ccx.tcx, t) &&\n-               ty::type_is_structural(ccx.tcx, t) {\n-                iter_structural_ty(cx, v0, t, drop_ty)\n-            } else { rslt(cx, C_nil()) }\n-          }\n-        };\n-\n-    build_return(rs.bcx);\n+    let ccx = bcx_ccx(bcx);\n+    let bcx = alt ty::struct(ccx.tcx, t) {\n+      ty::ty_str. { decr_refcnt_maybe_free(bcx, v0, v0, t) }\n+      ty::ty_vec(_) { ivec::make_drop_glue(bcx, v0, t) }\n+      ty::ty_istr. { ivec::make_drop_glue(bcx, v0, t) }\n+      ty::ty_box(_) { decr_refcnt_maybe_free(bcx, v0, v0, t) }\n+      ty::ty_uniq(_) { trans_shared_free(bcx, Load(bcx, v0)) }\n+      ty::ty_obj(_) {\n+        let box_cell =\n+            GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n+        decr_refcnt_maybe_free(bcx, box_cell, v0, t)\n+      }\n+      ty::ty_res(did, inner, tps) {\n+        trans_res_drop(bcx, v0, did, inner, tps)\n+      }\n+      ty::ty_fn(_, _, _, _, _) {\n+        let box_cell = GEP(bcx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n+        decr_refcnt_maybe_free(bcx, box_cell, v0, t)\n+      }\n+      _ {\n+        if ty::type_has_pointers(ccx.tcx, t) &&\n+           ty::type_is_structural(ccx.tcx, t) {\n+            iter_structural_ty(bcx, v0, t, drop_ty)\n+        } else { bcx }\n+      }\n+    };\n+    build_return(bcx);\n }\n \n fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n-                  inner_t: ty::t, tps: &[ty::t]) -> result {\n+                  inner_t: ty::t, tps: &[ty::t]) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     let tup_ty = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n@@ -1488,14 +1473,14 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     let val_cast = BitCast(cx, val.val, val_llty);\n     FastCall(cx, dtor_addr, args + [val_cast]);\n \n-    cx = drop_ty(cx, val.val, inner_t_s).bcx;\n+    cx = drop_ty(cx, val.val, inner_t_s);\n     Store(cx, C_int(0), drop_flag.val);\n     Br(cx, next_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n-                          full_alias: ValueRef, t: ty::t) -> result {\n+                          full_alias: ValueRef, t: ty::t) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     let load_rc_cx = new_sub_block_ctxt(cx, ~\"load rc\");\n     let rc_adj_cx = new_sub_block_ctxt(cx, ~\"rc--\");\n@@ -1518,16 +1503,9 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n     Store(rc_adj_cx, rc, rc_ptr);\n     let zero_test = ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n     CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n-    let free_res =\n-        free_ty(free_cx, full_alias, t);\n-    Br(free_res.bcx, next_cx.llbb);\n-    let t_else = T_nil();\n-    let v_else = C_nil();\n-    let phi =\n-        Phi(next_cx, t_else, [v_else, v_else, v_else, free_res.val],\n-                          [cx.llbb, load_rc_cx.llbb, rc_adj_cx.llbb,\n-                           free_res.bcx.llbb]);\n-    ret rslt(next_cx, phi);\n+    let free_cx = free_ty(free_cx, full_alias, t);\n+    Br(free_cx, next_cx.llbb);\n+    ret next_cx;\n }\n \n \n@@ -1658,10 +1636,8 @@ fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     ret rslt(last_cx, last_result);\n }\n \n-type val_pair_fn = fn(&@block_ctxt, ValueRef, ValueRef) -> result;\n-type val_fn = fn(&@block_ctxt, ValueRef) -> result;\n-type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n-\n+type val_pair_fn = fn(&@block_ctxt, ValueRef, ValueRef) -> @block_ctxt;\n+type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &[ValueRef]) ->\n    ValueRef {\n@@ -1680,28 +1656,26 @@ fn incr_ptr(cx: &@block_ctxt, p: ValueRef, incr: ValueRef, pp: ValueRef) {\n }\n \n // Iterates through the elements of a structural type.\n-fn iter_structural_ty(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n-                      f: &val_and_ty_fn) -> result {\n-    fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: &val_and_ty_fn) ->\n-       result {\n+fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n+                      f: &val_and_ty_fn) -> @block_ctxt {\n+    fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: &val_and_ty_fn)\n+        -> @block_ctxt {\n         let box_ptr = Load(cx, box_cell);\n         let tnil = ty::mk_nil(bcx_tcx(cx));\n         let tbox = ty::mk_imm_box(bcx_tcx(cx), tnil);\n         let inner_cx = new_sub_block_ctxt(cx, ~\"iter box\");\n         let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let null_test = IsNull(cx, box_ptr);\n         CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        let r = f(inner_cx, box_cell, tbox);\n-        Br(r.bcx, next_cx.llbb);\n-        ret rslt(next_cx, C_nil());\n+        let inner_cx = f(inner_cx, box_cell, tbox);\n+        Br(inner_cx, next_cx.llbb);\n+        ret next_cx;\n     }\n \n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: &ty::variant_info, tps: &[ty::t],\n-                    tid: &ast::def_id, f: &val_and_ty_fn) -> result {\n-        if std::vec::len::<ty::t>(variant.args) == 0u {\n-            ret rslt(cx, C_nil());\n-        }\n+                    tid: &ast::def_id, f: &val_and_ty_fn) -> @block_ctxt {\n+        if std::vec::len::<ty::t>(variant.args) == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n         alt ty::struct(ccx.tcx, fn_ty) {\n@@ -1712,32 +1686,28 @@ fn iter_structural_ty(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n-                rslt = f(cx, llfldp_a, ty_subst);\n-                cx = rslt.bcx;\n+                cx = f(cx, llfldp_a, ty_subst);\n                 j += 1;\n             }\n           }\n         }\n-        ret rslt(cx, C_nil());\n+        ret cx;\n     }\n \n-    let r: result = rslt(cx, C_nil());\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let i: int = 0;\n         for fld: ty::field in fields {\n-            r = GEP_tup_like(r.bcx, t, av, [0, i]);\n-            let llfld_a = r.val;\n-            r = f(r.bcx, llfld_a, fld.mt.ty);\n+            let {bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n+            cx = f(bcx, llfld_a, fld.mt.ty);\n             i += 1;\n         }\n       }\n       ty::ty_tup(args) {\n         let i = 0;\n         for arg in args {\n-            r = GEP_tup_like(r.bcx, t, av, [0, i]);\n-            let llfld_a = r.val;\n-            r = f(r.bcx, llfld_a, arg);\n+            let {bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n+            cx = f(bcx, llfld_a, arg);\n             i += 1;\n         }\n       }\n@@ -1746,9 +1716,8 @@ fn iter_structural_ty(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n         let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n         let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n-        r = GEP_tup_like(r.bcx, tup_t, av, [0, 1]);\n-        let llfld_a = r.val;\n-        r = f(r.bcx, llfld_a, inner1);\n+        let {bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n+        ret f(bcx, llfld_a, inner1);\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n@@ -1767,26 +1736,23 @@ fn iter_structural_ty(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n \n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n-        let bcx = cx;\n-        bcx = f(bcx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx))).bcx;\n-        let unr_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-unr\");\n+        cx = f(cx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx)));\n+        let unr_cx = new_sub_block_ctxt(cx, ~\"tag-iter-unr\");\n         Unreachable(unr_cx);\n-        let llswitch = Switch(bcx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-next\");\n+        let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n+        let next_cx = new_sub_block_ctxt(cx, ~\"tag-iter-next\");\n         let i = 0u;\n         for variant: ty::variant_info in variants {\n             let variant_cx =\n-                new_sub_block_ctxt(bcx,\n-                                   ~\"tag-iter-variant-\" +\n-                                                 uint::to_str(i, 10u));\n+                new_sub_block_ctxt(cx, ~\"tag-iter-variant-\" +\n+                                   uint::to_str(i, 10u));\n             llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n-            variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid,\n-                             f).bcx;\n+            variant_cx = iter_variant(variant_cx, llunion_a_ptr, variant,\n+                                      tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n             i += 1u;\n         }\n-        ret rslt(next_cx, C_nil());\n+        ret next_cx;\n       }\n       ty::ty_fn(_, _, _, _, _) {\n         let box_cell_a =\n@@ -1800,21 +1766,14 @@ fn iter_structural_ty(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n       }\n       _ { bcx_ccx(cx).sess.unimpl(~\"type in iter_structural_ty\"); }\n     }\n-    ret r;\n+    ret cx;\n }\n \n \n // Iterates through a pointer range, until the src* hits the src_lim*.\n fn iter_sequence_raw(cx: @block_ctxt, dst: ValueRef,\n-                     src:\n-                         // elt*\n-                         ValueRef,\n-                     src_lim:\n-                         // elt*\n-                         ValueRef,\n-                     elt_sz:\n-                         // elt*\n-                         ValueRef, f: &val_pair_fn) -> result {\n+                     src: ValueRef, src_lim: ValueRef,\n+                     elt_sz: ValueRef, f: &val_pair_fn) -> @block_ctxt {\n     let bcx = cx;\n     let dst_int: ValueRef = vp2i(bcx, dst);\n     let src_int: ValueRef = vp2i(bcx, src);\n@@ -1832,24 +1791,20 @@ fn iter_sequence_raw(cx: @block_ctxt, dst: ValueRef,\n     CondBr(cond_cx, end_test, body_cx.llbb, next_cx.llbb);\n     let dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(T_i8()));\n     let src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n-    let body_res = f(body_cx, dst_curr_ptr, src_curr_ptr);\n-    body_cx = body_res.bcx;\n+    let body_cx = f(body_cx, dst_curr_ptr, src_curr_ptr);\n     let dst_next = Add(body_cx, dst_curr, elt_sz);\n     let src_next = Add(body_cx, src_curr, elt_sz);\n     Br(body_cx, cond_cx.llbb);\n     AddIncomingToPhi(dst_curr, [dst_next], [body_cx.llbb]);\n     AddIncomingToPhi(src_curr, [src_next], [body_cx.llbb]);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n-                       src_lim:\n-                           // elt*\n-                           ValueRef,\n-                       elt_ty: & // elt*\n-                           ty::t, f: &val_and_ty_fn) -> result {\n+                       src_lim: ValueRef,\n+                       elt_ty: &ty::t, f: &val_and_ty_fn) -> @block_ctxt {\n     fn adaptor_fn(f: val_and_ty_fn, elt_ty: ty::t, cx: &@block_ctxt,\n-                  _dst: ValueRef, src: ValueRef) -> result {\n+                  _dst: ValueRef, src: ValueRef) -> @block_ctxt {\n         let llptrty;\n         if !ty::type_has_dynamic_size(bcx_tcx(cx), elt_ty) {\n             let llty = type_of(bcx_ccx(cx), cx.sp, elt_ty);\n@@ -1866,10 +1821,10 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n \n // Iterates through the elements of a vec or str.\n fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n-   -> result {\n+   -> @block_ctxt {\n     fn iter_sequence_body(bcx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n                           f: &val_and_ty_fn, trailing_null: bool,\n-                          interior: bool) -> result {\n+                          interior: bool) -> @block_ctxt {\n         let p0;\n         let len;\n         let llunit_ty = type_of_or_i8(bcx, elt_ty);\n@@ -2057,11 +2012,11 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n }\n \n fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n-   result {\n+    @block_ctxt {\n     let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n-    let td = get_tydesc(cx, t, false, tps_normal, ti).result;\n-    call_tydesc_glue_full(td.bcx, v, td.val, field, ti);\n-    ret rslt(td.bcx, C_nil());\n+    let {bcx, val: td} = get_tydesc(cx, t, false, tps_normal, ti).result;\n+    call_tydesc_glue_full(bcx, v, td, field, ti);\n+    ret bcx;\n }\n \n fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n@@ -2152,25 +2107,25 @@ fn compare(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     ret call_cmp_glue(cx, lhs, rhs, t, llop);\n }\n \n-fn take_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn take_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_has_pointers(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n-    ret rslt(cx, C_nil());\n+    ret cx;\n }\n \n-fn drop_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn drop_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_needs_drop(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n-    ret rslt(cx, C_nil());\n+    ret cx;\n }\n \n-fn free_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn free_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_has_pointers(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n-    ret rslt(cx, C_nil());\n+    ret cx;\n }\n \n fn call_memmove(cx: &@block_ctxt, dst: ValueRef, src: ValueRef,\n@@ -2268,17 +2223,17 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     } else if ty::type_is_boxed(ccx.tcx, t) ||\n               ty::type_is_ivec(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n-            drop_ty(cx, dst, t).bcx\n+            drop_ty(cx, dst, t)\n         } else { cx };\n         Store(bcx, src, dst);\n-        bcx = take_ty(bcx, dst, t).bcx;\n+        bcx = take_ty(bcx, dst, t);\n         ret bcx;\n     } else if type_is_structural_or_param(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n-            drop_ty(cx, dst, t).bcx\n+            drop_ty(cx, dst, t)\n         } else { cx };\n         bcx = memmove_ty(bcx, dst, src, t).bcx;\n-        ret take_ty(bcx, dst, t).bcx;\n+        ret take_ty(bcx, dst, t);\n     }\n     ccx.sess.bug(~\"unexpected type in trans::copy_val_no_check: \" +\n                  ty_to_str(ccx.tcx, t));\n@@ -2305,7 +2260,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n               ty::type_is_boxed(tcx, t) {\n         if src.is_mem { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING {\n-            cx = drop_ty(cx, dst, t).bcx;\n+            cx = drop_ty(cx, dst, t);\n         }\n         Store(cx, src_val, dst);\n         if src.is_mem { ret zero_alloca(cx, src.res.val, t).bcx; }\n@@ -2314,7 +2269,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         revoke_clean(cx, src_val);\n         ret cx;\n     } else if type_is_structural_or_param(tcx, t) {\n-        if action == DROP_EXISTING { cx = drop_ty(cx, dst, t).bcx; }\n+        if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t).bcx;\n         if src.is_mem {\n             ret zero_alloca(cx, src_val, t).bcx;\n@@ -2735,7 +2690,7 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     // FIXME: We bind to an alias here to avoid a segfault... this is\n     // obviously a bug.\n     fn inner(cx: &@block_ctxt, local: @ast::local, curr: ValueRef, t: ty::t,\n-             body: &ast::blk, outer_next_cx: @block_ctxt) -> result {\n+             body: &ast::blk, outer_next_cx: @block_ctxt) -> @block_ctxt {\n         let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let scope_cx =\n             new_loop_scope_block_ctxt(cx,\n@@ -2745,25 +2700,22 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n         let local_res = alloc_local(scope_cx, local);\n         let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n         add_clean(scope_cx, local_res.val, t);\n-        let bcx =\n-            trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n-                                            local_res.val, cx.fcx.lllocals,\n-                                            false);\n+        let bcx = trans_alt::bind_irrefutable_pat\n+            (bcx, local.node.pat, local_res.val, cx.fcx.lllocals, false);\n         bcx = trans_block(bcx, body, return).bcx;\n         if !is_terminated(bcx) {\n             Br(bcx, next_cx.llbb);\n             // otherwise, this code is unreachable\n         }\n-        ret rslt(next_cx, C_nil());\n+        ret next_cx;\n     }\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n     let seq_res = trans_expr(cx, seq);\n-    let it =\n-        iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n-                      bind inner(_, local, _, _, body, next_cx));\n-    Br(it.bcx, next_cx.llbb);\n-    ret rslt(next_cx, it.val);\n+    let bcx = iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n+                            bind inner(_, local, _, _, body, next_cx));\n+    Br(bcx, next_cx.llbb);\n+    ret rslt(next_cx, C_nil());\n }\n \n \n@@ -3821,14 +3773,14 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         } else {\n             if ty::type_is_ivec(ccx.tcx, e_ty) {\n                 let arg_copy = do_spill(bcx, Load(bcx, val));\n-                bcx = take_ty(bcx, arg_copy, e_ty).bcx;\n+                bcx = take_ty(bcx, arg_copy, e_ty);\n                 val = Load(bcx, arg_copy);\n             } else if lv.is_mem {\n-                bcx = take_ty(bcx, val, e_ty).bcx;\n+                bcx = take_ty(bcx, val, e_ty);\n                 val = load_if_immediate(bcx, val, e_ty);\n             } else if is_ext_vec_plus {\n                 let spilled = do_spill(bcx, val);\n-                bcx = take_ty(bcx, spilled, e_ty).bcx;\n+                bcx = take_ty(bcx, spilled, e_ty);\n             }\n             add_clean_temp(bcx, val, e_ty);\n         }\n@@ -4838,8 +4790,8 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n         i -= 1u;\n         let c = cleanup_cx.cleanups[i];\n         alt c {\n-          clean(cfn) { bcx = cfn(bcx).bcx; }\n-          clean_temp(_, cfn) { bcx = cfn(bcx).bcx; }\n+          clean(cfn) { bcx = cfn(bcx); }\n+          clean_temp(_, cfn) { bcx = cfn(bcx); }\n         }\n     }\n     ret bcx;\n@@ -5158,7 +5110,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n                 // Args that are locally assigned to need to do a local\n                 // take/drop\n                 if fcx.lcx.ccx.mut_map.contains_key(aarg.id) {\n-                    bcx = take_ty(bcx, addr, arg_ty).bcx;\n+                    bcx = take_ty(bcx, addr, arg_ty);\n                     add_clean(scope, addr, arg_ty);\n                 }\n             }"}, {"sha": "87dd8f6c97d7e7e8071ed8bed5d19cec092f4078", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e17e6af4f0acd692225130a278174047ecb252ae", "patch": "@@ -297,15 +297,16 @@ type fn_ctxt =\n      lcx: @local_ctxt};\n \n tag cleanup {\n-    clean(fn(&@block_ctxt) -> result);\n-    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n+    clean(fn(&@block_ctxt) -> @block_ctxt);\n+    clean_temp(ValueRef, fn(&@block_ctxt) -> @block_ctxt);\n }\n \n fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n     find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, val, ty))];\n }\n fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    fn spill_and_drop(bcx: &@block_ctxt, val: ValueRef, ty: ty::t) -> result {\n+    fn spill_and_drop(bcx: &@block_ctxt, val: ValueRef, ty: ty::t)\n+        -> @block_ctxt {\n         let spilled = trans::spill_if_immediate(bcx, val, ty);\n         ret drop_ty(bcx, spilled, ty);\n     }"}, {"sha": "6c891f6a6a54aa932d50ed8ba1009a664e481fd1", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e17e6af4f0acd692225130a278174047ecb252ae/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=e17e6af4f0acd692225130a278174047ecb252ae", "patch": "@@ -84,9 +84,9 @@ fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t)\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        drop_cx = iter_ivec(drop_cx, vptrptr, vec_ty, trans::drop_ty).bcx;\n+        drop_cx = iter_ivec(drop_cx, vptrptr, vec_ty, trans::drop_ty);\n     }\n-    drop_cx = trans::trans_shared_free(drop_cx, vptr).bcx;\n+    drop_cx = trans::trans_shared_free(drop_cx, vptr);\n     Br(drop_cx, next_cx.llbb);\n     ret next_cx;\n }\n@@ -170,8 +170,8 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n         } else {\n             incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n         }\n-        ret rslt(bcx, C_nil());\n-    }).bcx;\n+        ret bcx;\n+    });\n     ret rslt(bcx, C_nil());\n }\n \n@@ -215,7 +215,7 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n     let copy_fn = bind fn(bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n                           write_ptr_ptr: ValueRef, unit_ty: ty::t,\n-                          llunitsz: ValueRef) -> result {\n+                          llunitsz: ValueRef) -> @block_ctxt {\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n@@ -225,20 +225,20 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         } else {\n             incr_ptr(bcx, write_ptr, C_int(1), write_ptr_ptr);\n         }\n-        ret rslt(bcx, C_nil());\n+        ret bcx;\n     } (_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n-    let bcx = iter_ivec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn).bcx;\n-    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn).bcx;\n+    let bcx = iter_ivec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n+    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n     ret rslt(bcx, new_vec);\n }\n \n type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n \n-type iter_ivec_block = block(&@block_ctxt, ValueRef, ty::t) -> result;\n+type iter_ivec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n-                 fill: ValueRef, f: &iter_ivec_block) -> result {\n+                 fill: ValueRef, f: &iter_ivec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n@@ -260,18 +260,18 @@ fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let body_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_body\");\n     let next_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n-    body_cx = f(body_cx, data_ptr, unit_ty).bcx;\n+    body_cx = f(body_cx, data_ptr, unit_ty);\n     let increment = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n         unit_sz\n     } else { C_int(1) };\n     incr_ptr(body_cx, data_ptr, increment, data_ptr_ptr);\n     Br(body_cx, header_cx.llbb);\n \n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-             f: &iter_ivec_block) -> result {\n+             f: &iter_ivec_block) -> @block_ctxt {\n     let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n                                      T_ptr(T_ptr(T_opaque_ivec()))));\n     ret iter_ivec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);"}]}