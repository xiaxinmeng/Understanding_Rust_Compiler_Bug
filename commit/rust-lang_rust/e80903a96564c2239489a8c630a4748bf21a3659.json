{"sha": "e80903a96564c2239489a8c630a4748bf21a3659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MDkwM2E5NjU2NGMyMjM5NDg5YThjNjMwYTQ3NDhiZjIxYTM2NTk=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-10T10:31:55Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-10T10:31:55Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer into feat_4348", "tree": {"sha": "12b31a1fd12deb2120065cea5a558425c8c1984f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12b31a1fd12deb2120065cea5a558425c8c1984f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e80903a96564c2239489a8c630a4748bf21a3659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e80903a96564c2239489a8c630a4748bf21a3659", "html_url": "https://github.com/rust-lang/rust/commit/e80903a96564c2239489a8c630a4748bf21a3659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e80903a96564c2239489a8c630a4748bf21a3659/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6203e9c4faee288f16d93dbb7dd0f1f8df487d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/6203e9c4faee288f16d93dbb7dd0f1f8df487d83", "html_url": "https://github.com/rust-lang/rust/commit/6203e9c4faee288f16d93dbb7dd0f1f8df487d83"}, {"sha": "4578154b608fa075595103d0c933da60d55b25c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4578154b608fa075595103d0c933da60d55b25c8", "html_url": "https://github.com/rust-lang/rust/commit/4578154b608fa075595103d0c933da60d55b25c8"}], "stats": {"total": 2978, "additions": 1920, "deletions": 1058}, "files": [{"sha": "41855f22e85d62d6d8c8d282262e6d84c68f16be", "filename": "Cargo.lock", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -68,9 +68,9 @@ dependencies = [\n \n [[package]]\n name = \"base64\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d5ca2cd0adc3f48f9e9ea5a6bbdf9ccc0bfade884847e484d452414c7ccffb3\"\n+checksum = \"53d1ccbaf7d9ec9537465a97bf19edc1a4e158ecb49fc16178202238c569cc42\"\n \n [[package]]\n name = \"bitflags\"\n@@ -342,9 +342,9 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f59efc38004c988e4201d11d263b8171f49a2e7ec0bdbb71773433f271504a5e\"\n+checksum = \"affc17579b132fc2461adf7c575cc6e8b134ebca52c51f5411388965227dc695\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -464,6 +464,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"home\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -610,18 +619,18 @@ checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.1\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3c4f51b790f5bdb65acb4cc94bb81d7b2ee60348a5431ac1467d390b017600b0\"\n+checksum = \"2cadb8e769f070c45df05c78c7520eb4cd17061d4ab262e43cfc68b4d00ac71c\"\n dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"linked-hash-map\"\n-version = \"0.5.2\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n+checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n \n [[package]]\n name = \"lock_api\"\n@@ -824,19 +833,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3c897744f63f34f7ae3a024d9162bb5001f4ad661dd24bea0dc9f075d2de1c6\"\n+checksum = \"0a229b1c58c692edcaa5b9b0948084f130f55d2dcc15b02fcc5340b2b4521476\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"66fd6f92e3594f2dd7b3fc23e42d82e292f7bcda6d8e5dcd167072327234ab89\"\n+checksum = \"2e0bf239e447e67ff6d16a8bb5e4d4bd2343acf5066061c0e8e06ac5ba8ca68c\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -886,9 +895,9 @@ checksum = \"0d659fe7c6d27f25e9d80a1a094c223f5246f6a6596453e09d7229bf42750b63\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.10\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df246d292ff63439fea9bc8c0a270bed0e390d5ebd4db4ba15aba81111b5abe3\"\n+checksum = \"8872cf6f48eee44265156c111456a700ab3483686b3f96df4cf5481c89157319\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -958,6 +967,7 @@ dependencies = [\n  \"jod-thread\",\n  \"log\",\n  \"lsp-types\",\n+ \"ra_toolchain\",\n  \"serde_json\",\n ]\n \n@@ -1163,6 +1173,7 @@ dependencies = [\n  \"ra_cfg\",\n  \"ra_db\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n@@ -1194,6 +1205,13 @@ dependencies = [\n  \"text-size\",\n ]\n \n+[[package]]\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"home\",\n+]\n+\n [[package]]\n name = \"ra_tt\"\n version = \"0.1.0\"\n@@ -1581,9 +1599,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.18\"\n+version = \"1.0.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"410a7488c0a728c7ceb4ad59b9567eb4053d02e8cc7f5c0e0eeeb39518369213\"\n+checksum = \"e8e5aa70697bb26ee62214ae3288465ecec0000f05182f039b477001f08f5ae7\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "a680f752b39c89de110c5692866220466572b863", "filename": "crates/ra_assists/src/assist_context.rs", "status": "renamed", "additions": 113, "deletions": 149, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,4 +1,6 @@\n-//! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n+//! See `AssistContext`\n+\n+use algo::find_covering_element;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n use ra_fmt::{leading_indent, reindent};\n@@ -7,54 +9,25 @@ use ra_ide_db::{\n     RootDatabase,\n };\n use ra_syntax::{\n-    algo::{self, find_covering_element, find_node_at_offset, SyntaxRewriter},\n+    algo::{self, find_node_at_offset, SyntaxRewriter},\n     AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::{AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct AssistInfo {\n-    pub(crate) label: AssistLabel,\n-    pub(crate) group_label: Option<GroupLabel>,\n-    pub(crate) source_change: Option<SourceChange>,\n-}\n-\n-impl AssistInfo {\n-    fn new(label: AssistLabel) -> AssistInfo {\n-        AssistInfo { label, group_label: None, source_change: None }\n-    }\n-\n-    fn resolved(self, source_change: SourceChange) -> AssistInfo {\n-        AssistInfo { source_change: Some(source_change), ..self }\n-    }\n-\n-    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n-        AssistInfo { group_label: Some(group_label), ..self }\n-    }\n-\n-    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n-        let label = self.label;\n-        self.source_change.map(|source_change| ResolvedAssist { label, source_change })\n-    }\n-}\n+use crate::{Assist, AssistId, GroupLabel, ResolvedAssist};\n \n-/// `AssistCtx` allows to apply an assist or check if it could be applied.\n+/// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n-/// Assists use a somewhat over-engineered approach, given the current needs. The\n-/// assists workflow consists of two phases. In the first phase, a user asks for\n-/// the list of available assists. In the second phase, the user picks a\n+/// Assists use a somewhat over-engineered approach, given the current needs.\n+/// The assists workflow consists of two phases. In the first phase, a user asks\n+/// for the list of available assists. In the second phase, the user picks a\n /// particular assist and it gets applied.\n ///\n /// There are two peculiarities here:\n ///\n-/// * first, we ideally avoid computing more things then necessary to answer\n-///   \"is assist applicable\" in the first phase.\n+/// * first, we ideally avoid computing more things then necessary to answer \"is\n+///   assist applicable\" in the first phase.\n /// * second, when we are applying assist, we don't have a guarantee that there\n ///   weren't any changes between the point when user asked for assists and when\n ///   they applied a particular assist. So, when applying assist, we need to do\n@@ -63,152 +36,157 @@ impl AssistInfo {\n /// To avoid repeating the same code twice for both \"check\" and \"apply\"\n /// functions, we use an approach reminiscent of that of Django's function based\n /// views dealing with forms. Each assist receives a runtime parameter,\n-/// `should_compute_edit`. It first check if an edit is applicable (potentially\n-/// computing info required to compute the actual edit). If it is applicable,\n-/// and `should_compute_edit` is `true`, it then computes the actual edit.\n+/// `resolve`. It first check if an edit is applicable (potentially computing\n+/// info required to compute the actual edit). If it is applicable, and\n+/// `resolve` is `true`, it then computes the actual edit.\n ///\n /// So, to implement the original assists workflow, we can first apply each edit\n-/// with `should_compute_edit = false`, and then applying the selected edit\n-/// again, with `should_compute_edit = true` this time.\n+/// with `resolve = false`, and then applying the selected edit again, with\n+/// `resolve = true` this time.\n ///\n /// Note, however, that we don't actually use such two-phase logic at the\n /// moment, because the LSP API is pretty awkward in this place, and it's much\n /// easier to just compute the edit eagerly :-)\n-#[derive(Clone)]\n-pub(crate) struct AssistCtx<'a> {\n-    pub(crate) sema: &'a Semantics<'a, RootDatabase>,\n+pub(crate) struct AssistContext<'a> {\n+    pub(crate) sema: Semantics<'a, RootDatabase>,\n     pub(crate) db: &'a RootDatabase,\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n-    should_compute_edit: bool,\n }\n \n-impl<'a> AssistCtx<'a> {\n-    pub fn new(\n-        sema: &'a Semantics<'a, RootDatabase>,\n-        frange: FileRange,\n-        should_compute_edit: bool,\n-    ) -> AssistCtx<'a> {\n+impl<'a> AssistContext<'a> {\n+    pub fn new(sema: Semantics<'a, RootDatabase>, frange: FileRange) -> AssistContext<'a> {\n         let source_file = sema.parse(frange.file_id);\n-        AssistCtx { sema, db: sema.db, frange, source_file, should_compute_edit }\n+        let db = sema.db;\n+        AssistContext { sema, db, frange, source_file }\n     }\n \n-    pub(crate) fn add_assist(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) -> Option<Assist> {\n-        let label = AssistLabel::new(id, label.into(), None, target);\n-        let change_label = label.label.clone();\n-        let mut info = AssistInfo::new(label);\n-        if self.should_compute_edit {\n-            let source_change = {\n-                let mut edit = ActionBuilder::new(&self);\n-                f(&mut edit);\n-                edit.build(change_label)\n-            };\n-            info = info.resolved(source_change)\n-        };\n-\n-        Some(Assist(vec![info]))\n-    }\n-\n-    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n-        let group = GroupLabel(group_name.into());\n-        AssistGroup { ctx: self, group, assists: Vec::new() }\n+    // NB, this ignores active selection.\n+    pub(crate) fn offset(&self) -> TextSize {\n+        self.frange.range.start()\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n-        self.source_file.syntax().token_at_offset(self.frange.range.start())\n+        self.source_file.syntax().token_at_offset(self.offset())\n     }\n-\n     pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n         self.token_at_offset().find(|it| it.kind() == kind)\n     }\n-\n     pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n-        find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n+        find_node_at_offset(self.source_file.syntax(), self.offset())\n     }\n-\n     pub(crate) fn find_node_at_offset_with_descend<N: AstNode>(&self) -> Option<N> {\n-        self.sema\n-            .find_node_at_offset_with_descend(self.source_file.syntax(), self.frange.range.start())\n+        self.sema.find_node_at_offset_with_descend(self.source_file.syntax(), self.offset())\n     }\n-\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n+    // FIXME: remove\n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)\n     }\n }\n \n-pub(crate) struct AssistGroup<'a> {\n-    ctx: AssistCtx<'a>,\n-    group: GroupLabel,\n-    assists: Vec<AssistInfo>,\n+pub(crate) struct Assists {\n+    resolve: bool,\n+    file: FileId,\n+    buf: Vec<(Assist, Option<SourceChange>)>,\n }\n \n-impl<'a> AssistGroup<'a> {\n-    pub(crate) fn add_assist(\n+impl Assists {\n+    pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: true, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+    pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: false, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+\n+    pub(crate) fn finish_unresolved(self) -> Vec<Assist> {\n+        assert!(!self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| {\n+                assert!(edit.is_none());\n+                label\n+            })\n+            .collect()\n+    }\n+\n+    pub(crate) fn finish_resolved(self) -> Vec<ResolvedAssist> {\n+        assert!(self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| ResolvedAssist { assist: label, source_change: edit.unwrap() })\n+            .collect()\n+    }\n+\n+    pub(crate) fn add(\n         &mut self,\n         id: AssistId,\n         label: impl Into<String>,\n         target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) {\n-        let label = AssistLabel::new(id, label.into(), Some(self.group.clone()), target);\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), None, target);\n+        self.add_impl(label, f)\n+    }\n+    pub(crate) fn add_group(\n+        &mut self,\n+        group: &GroupLabel,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), Some(group.clone()), target);\n+        self.add_impl(label, f)\n+    }\n+    fn add_impl(&mut self, label: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n         let change_label = label.label.clone();\n-        let mut info = AssistInfo::new(label).with_group(self.group.clone());\n-        if self.ctx.should_compute_edit {\n-            let source_change = {\n-                let mut edit = ActionBuilder::new(&self.ctx);\n-                f(&mut edit);\n-                edit.build(change_label)\n-            };\n-            info = info.resolved(source_change)\n+        let source_change = if self.resolve {\n+            let mut builder = AssistBuilder::new(self.file);\n+            f(&mut builder);\n+            Some(builder.finish(change_label))\n+        } else {\n+            None\n         };\n \n-        self.assists.push(info)\n+        self.buf.push((label, source_change));\n+        Some(())\n     }\n \n-    pub(crate) fn finish(self) -> Option<Assist> {\n-        if self.assists.is_empty() {\n-            None\n-        } else {\n-            Some(Assist(self.assists))\n-        }\n+    fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n+        self.buf.sort_by_key(|(label, _edit)| label.target.len());\n+        self.buf\n     }\n }\n \n-pub(crate) struct ActionBuilder<'a, 'b> {\n+pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextSize>,\n     file: FileId,\n-    ctx: &'a AssistCtx<'b>,\n }\n \n-impl<'a, 'b> ActionBuilder<'a, 'b> {\n-    fn new(ctx: &'a AssistCtx<'b>) -> Self {\n-        Self {\n-            edit: TextEditBuilder::default(),\n-            cursor_position: None,\n-            file: ctx.frange.file_id,\n-            ctx,\n-        }\n+impl AssistBuilder {\n+    pub(crate) fn new(file: FileId) -> AssistBuilder {\n+        AssistBuilder { edit: TextEditBuilder::default(), cursor_position: None, file }\n     }\n \n-    pub(crate) fn ctx(&self) -> &AssistCtx<'b> {\n-        &self.ctx\n+    /// Remove specified `range` of text.\n+    pub(crate) fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    /// Append specified `text` at the given `offset`\n+    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n     }\n-\n     /// Replaces specified `range` of text with a given string.\n     pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n         self.edit.replace(range, replace_with.into())\n     }\n-\n+    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n     /// Replaces specified `node` of text with a given string, reindenting the\n     /// string to maintain `node`'s existing indent.\n     // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n@@ -223,42 +201,28 @@ impl<'a, 'b> ActionBuilder<'a, 'b> {\n         }\n         self.replace(node.text_range(), replace_with)\n     }\n-\n-    /// Remove specified `range` of text.\n-    #[allow(unused)]\n-    pub(crate) fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-\n-    /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n+    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n+        let node = rewriter.rewrite_root().unwrap();\n+        let new = rewriter.rewrite(&node);\n+        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n     }\n \n     /// Specify desired position of the cursor after the assist is applied.\n     pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n         self.cursor_position = Some(offset)\n     }\n+    // FIXME: better API\n+    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n+        self.file = assist_file;\n+    }\n \n+    // FIXME: kill this API\n     /// Get access to the raw `TextEditBuilder`.\n     pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n         &mut self.edit\n     }\n \n-    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n-    }\n-    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n-        let node = rewriter.rewrite_root().unwrap();\n-        let new = rewriter.rewrite(&node);\n-        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n-    }\n-\n-    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n-        self.file = assist_file;\n-    }\n-\n-    fn build(self, change_label: String) -> SourceChange {\n+    fn finish(self, change_label: String) -> SourceChange {\n         let edit = self.edit.finish();\n         if edit.is_empty() && self.cursor_position.is_none() {\n             panic!(\"Only call `add_assist` if the assist can be applied\")", "previous_filename": "crates/ra_assists/src/assist_ctx.rs"}, {"sha": "795a225a4d8fc43ab12043c7ad40207a4ce370bf", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n };\n use stdx::SepBy;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: add_custom_impl\n //\n@@ -25,7 +28,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n     let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n \n@@ -49,7 +52,7 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n         format!(\"Add custom impl '{}' for '{}'\", trait_token.text().as_str(), annotated_name);\n \n     let target = attr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_custom_impl\"), label, target, |edit| {\n+    acc.add(AssistId(\"add_custom_impl\"), label, target, |edit| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()"}, {"sha": "fb08c19e936145203eeb5955848434ce96d2a4bb", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_derive\n //\n@@ -24,11 +24,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n+    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n@@ -57,9 +57,10 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn add_derive_new() {\n         check_assist("}, {"sha": "146cc75df2ad1a0c0e860e9c84205509c058f610", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_explicit_type\n //\n@@ -21,8 +21,9 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n+    let module = ctx.sema.scope(stmt.syntax()).module()?;\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n     // Must be a binding\n@@ -57,17 +58,17 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    let db = ctx.db;\n-    let new_type_string = ty.display_truncated(db, None).to_string();\n-    ctx.add_assist(\n+    let inferred_type = ty.display_source_code(ctx.db, module.into()).ok()?;\n+    acc.add(\n         AssistId(\"add_explicit_type\"),\n-        format!(\"Insert explicit type '{}'\", new_type_string),\n+        format!(\"Insert explicit type '{}'\", inferred_type),\n         pat_range,\n-        |edit| {\n-            if let Some(ascribed_ty) = ascribed_ty {\n-                edit.replace(ascribed_ty.syntax().text_range(), new_type_string);\n-            } else {\n-                edit.insert(name_range.end(), format!(\": {}\", new_type_string));\n+        |builder| match ascribed_ty {\n+            Some(ascribed_ty) => {\n+                builder.replace(ascribed_ty.syntax().text_range(), inferred_type);\n+            }\n+            None => {\n+                builder.insert(name_range.end(), format!(\": {}\", inferred_type));\n             }\n         },\n     )\n@@ -208,7 +209,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let test<|>: Test<i32> = Test { t: 23, k: 33 };\n+    let test<|>: Test<i32, u8> = Test { t: 23, k: 33 };\n }\"#,\n         );\n     }"}, {"sha": "6a49b7dbd189e6d98e94c5737a7138d9d504e5a8", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,13 +1,10 @@\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n-    TextSize,\n-};\n+use ra_syntax::ast::{self, AstNode, NameOwner};\n use stdx::format_to;\n-\n-use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n+\n // Assist add_from_impl_for_enum\n //\n // Adds a From impl for an enum variant with one tuple field\n@@ -25,7 +22,7 @@ use test_utils::tested_by;\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n@@ -42,13 +39,13 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n         _ => return None,\n     };\n \n-    if existing_from_impl(ctx.sema, &variant).is_some() {\n+    if existing_from_impl(&ctx.sema, &variant).is_some() {\n         tested_by!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n     let target = variant.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"add_from_impl_for_enum\"),\n         \"Add From impl for this enum variant\",\n         target,\n@@ -69,7 +66,6 @@ impl From<{0}> for {1} {{\n                 variant_name\n             );\n             edit.insert(start_offset, buf);\n-            edit.set_cursor(start_offset + TextSize::of(\"\\n\\n\"));\n         },\n     )\n }\n@@ -97,19 +93,20 @@ fn existing_from_impl(\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n+    use test_utils::covers;\n \n     use crate::tests::{check_assist, check_assist_not_applicable};\n-    use test_utils::covers;\n+\n+    use super::*;\n \n     #[test]\n     fn test_add_from_impl_for_enum() {\n         check_assist(\n             add_from_impl_for_enum,\n             \"enum A { <|>One(u32) }\",\n-            r#\"enum A { One(u32) }\n+            r#\"enum A { <|>One(u32) }\n \n-<|>impl From<u32> for A {\n+impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }\n@@ -121,10 +118,10 @@ mod tests {\n     fn test_add_from_impl_for_enum_complicated_path() {\n         check_assist(\n             add_from_impl_for_enum,\n-            \"enum A { <|>One(foo::bar::baz::Boo) }\",\n-            r#\"enum A { One(foo::bar::baz::Boo) }\n+            r#\"enum A { <|>One(foo::bar::baz::Boo) }\"#,\n+            r#\"enum A { <|>One(foo::bar::baz::Boo) }\n \n-<|>impl From<foo::bar::baz::Boo> for A {\n+impl From<foo::bar::baz::Boo> for A {\n     fn from(v: foo::bar::baz::Boo) -> Self {\n         A::One(v)\n     }\n@@ -184,9 +181,9 @@ impl From<String> for A {\n pub trait From<T> {\n     fn from(T) -> Self;\n }\"#,\n-            r#\"enum A { One(u32), Two(String), }\n+            r#\"enum A { <|>One(u32), Two(String), }\n \n-<|>impl From<u32> for A {\n+impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }"}, {"sha": "de016ae4e1527c82c005b435350f9d2a86cc13f1", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 132, "deletions": 72, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,14 +1,17 @@\n+use hir::HirDisplay;\n+use ra_db::FileId;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        ArgListOwner, AstNode, ModuleItemOwner,\n+    },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n-\n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n-use hir::HirDisplay;\n-use ra_db::FileId;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: add_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n@@ -34,7 +37,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // }\n //\n // ```\n-pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -44,22 +47,18 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    let target_module = if let Some(qualifier) = path.qualifier() {\n-        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) =\n-            ctx.sema.resolve_path(&qualifier)\n-        {\n-            Some(module.definition_source(ctx.sema.db))\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        None\n+    let target_module = match path.qualifier() {\n+        Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n+            _ => return None,\n+        },\n+        None => None,\n     };\n \n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n         let function_template = function_builder.render();\n         edit.set_file(function_template.file);\n         edit.set_cursor(function_template.cursor_offset);\n@@ -84,25 +83,29 @@ struct FunctionBuilder {\n }\n \n impl FunctionBuilder {\n-    /// Prepares a generated function that matches `call` in `generate_in`\n-    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    /// Prepares a generated function that matches `call`.\n+    /// The function is generated in `target_module` or next to `call`\n     fn from_call(\n-        ctx: &AssistCtx,\n+        ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n-        target_module: Option<hir::InFile<hir::ModuleSource>>,\n+        target_module: Option<hir::Module>,\n     ) -> Option<Self> {\n-        let needs_pub = target_module.is_some();\n         let mut file = ctx.frange.file_id;\n-        let target = if let Some(target_module) = target_module {\n-            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n-            file = in_file;\n-            target\n-        } else {\n-            next_space_for_fn_after_call_site(&call)?\n+        let target = match &target_module {\n+            Some(target_module) => {\n+                let module_source = target_module.definition_source(ctx.db);\n+                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+                file = in_file;\n+                target\n+            }\n+            None => next_space_for_fn_after_call_site(&call)?,\n         };\n+        let needs_pub = target_module.is_some();\n+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(&path)?;\n-        let (type_params, params) = fn_args(ctx, &call)?;\n+        let (type_params, params) = fn_args(ctx, target_module, &call)?;\n+\n         Some(Self { target, fn_name, type_params, params, file, needs_pub })\n     }\n \n@@ -117,17 +120,16 @@ impl FunctionBuilder {\n         let (fn_def, insert_offset) = match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n                 let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n-                let indented = IndentLevel::from_node(&it).increase_indent(with_leading_blank_line);\n+                let indented = with_leading_blank_line.indent(IndentLevel::from_node(&it));\n                 (indented, it.text_range().end())\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n                 let indent_once = IndentLevel(1);\n                 let indent = IndentLevel::from_node(it.syntax());\n-\n                 let fn_def = ast::make::add_leading_newlines(1, fn_def);\n-                let fn_def = indent_once.increase_indent(fn_def);\n+                let fn_def = fn_def.indent(indent_once);\n                 let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n-                let fn_def = indent.increase_indent(fn_def);\n+                let fn_def = fn_def.indent(indent);\n                 (fn_def, it.syntax().text_range().start() + TextSize::of('{'))\n             }\n         };\n@@ -145,25 +147,34 @@ enum GeneratedFunctionTarget {\n     InEmptyItemList(ast::ItemList),\n }\n \n+impl GeneratedFunctionTarget {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it,\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n     Some(ast::make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n-    ctx: &AssistCtx,\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n-        let arg_name = match fn_arg_name(&arg) {\n+        arg_names.push(match fn_arg_name(&arg) {\n             Some(name) => name,\n             None => String::from(\"arg\"),\n-        };\n-        arg_names.push(arg_name);\n-        arg_types.push(match fn_arg_type(ctx, &arg) {\n+        });\n+        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n             Some(ty) => ty,\n             None => String::from(\"()\"),\n         });\n@@ -219,12 +230,21 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n     }\n-    Some(ty.display(ctx.sema.db).to_string())\n+\n+    if let Ok(rendered) = ty.display_source_code(ctx.db, target_module.into()) {\n+        Some(rendered)\n+    } else {\n+        None\n+    }\n }\n \n /// Returns the position inside the current mod or file\n@@ -253,10 +273,10 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n \n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n-    module: hir::InFile<hir::ModuleSource>,\n+    module_source: &hir::InFile<hir::ModuleSource>,\n ) -> Option<(FileId, GeneratedFunctionTarget)> {\n-    let file = module.file_id.original_file(db);\n-    let assist_item = match module.value {\n+    let file = module_source.file_id.original_file(db);\n+    let assist_item = match &module_source.value {\n         hir::ModuleSource::SourceFile(it) => {\n             if let Some(last_item) = it.items().last() {\n                 GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n@@ -600,8 +620,33 @@ fn bar(foo: impl Foo) {\n     }\n \n     #[test]\n-    #[ignore]\n-    // FIXME print paths properly to make this test pass\n+    fn borrowed_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar<|>(&baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar(&baz())\n+}\n+\n+fn bar(baz: &Baz) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n             add_function,\n@@ -610,25 +655,21 @@ mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        <|>bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    <|>bar(Baz::baz())\n }\n \",\n             r\"\n mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    bar(Baz::baz())\n+}\n \n-    fn bar(baz: super::Baz::Bof) {\n-        <|>todo!()\n-    }\n+fn bar(baz: Baz::Bof) {\n+    <|>todo!()\n }\n \",\n         )\n@@ -809,6 +850,40 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    #[ignore]\n+    // Ignored until local imports are supported.\n+    // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n+    fn qualified_path_uses_correct_scope() {\n+        check_assist(\n+            add_function,\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz<|>(foo)\n+}\n+\",\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz(foo)\n+}\n+\n+fn baz(foo: foo::Foo) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -920,21 +995,6 @@ fn bar(baz: ()) {}\n         )\n     }\n \n-    #[test]\n-    fn add_function_not_applicable_if_function_path_not_singleton() {\n-        // In the future this assist could be extended to generate functions\n-        // if the path is in the same crate (or even the same workspace).\n-        // For the beginning, I think this is fine.\n-        check_assist_not_applicable(\n-            add_function,\n-            r\"\n-fn foo() {\n-    other_crate::bar<|>();\n-}\n-        \",\n-        )\n-    }\n-\n     #[test]\n     #[ignore]\n     fn create_method_with_no_args() {"}, {"sha": "df114a0d84dd40cfc9791ca3c5760834e6fc7e81", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_impl\n //\n@@ -25,43 +25,36 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"add_impl\"),\n-        format!(\"Implement {}\", name.text().as_str()),\n-        target,\n-        |edit| {\n-            let type_params = nominal.type_param_list();\n-            let start_offset = nominal.syntax().text_range().end();\n-            let mut buf = String::new();\n-            buf.push_str(\"\\n\\nimpl\");\n-            if let Some(type_params) = &type_params {\n-                format_to!(buf, \"{}\", type_params.syntax());\n-            }\n-            buf.push_str(\" \");\n-            buf.push_str(name.text().as_str());\n-            if let Some(type_params) = type_params {\n-                let lifetime_params = type_params\n-                    .lifetime_params()\n-                    .filter_map(|it| it.lifetime_token())\n-                    .map(|it| it.text().clone());\n-                let type_params = type_params\n-                    .type_params()\n-                    .filter_map(|it| it.name())\n-                    .map(|it| it.text().clone());\n+    acc.add(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), target, |edit| {\n+        let type_params = nominal.type_param_list();\n+        let start_offset = nominal.syntax().text_range().end();\n+        let mut buf = String::new();\n+        buf.push_str(\"\\n\\nimpl\");\n+        if let Some(type_params) = &type_params {\n+            format_to!(buf, \"{}\", type_params.syntax());\n+        }\n+        buf.push_str(\" \");\n+        buf.push_str(name.text().as_str());\n+        if let Some(type_params) = type_params {\n+            let lifetime_params = type_params\n+                .lifetime_params()\n+                .filter_map(|it| it.lifetime_token())\n+                .map(|it| it.text().clone());\n+            let type_params =\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n \n-                let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n-                format_to!(buf, \"<{}>\", generic_params)\n-            }\n-            buf.push_str(\" {\\n\");\n-            edit.set_cursor(start_offset + TextSize::of(&buf));\n-            buf.push_str(\"\\n}\");\n-            edit.insert(start_offset, buf);\n-        },\n-    )\n+            let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n+            format_to!(buf, \"<{}>\", generic_params)\n+        }\n+        buf.push_str(\" {\\n\");\n+        edit.set_cursor(start_offset + TextSize::of(&buf));\n+        buf.push_str(\"\\n}\");\n+        edit.insert(start_offset, buf);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "c1ce87914ab2908ac7daa24395905472d46a4d62", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -2,16 +2,17 @@ use hir::HasSource;\n use ra_syntax::{\n     ast::{\n         self,\n-        edit::{self, IndentLevel},\n+        edit::{self, AstNodeEdit, IndentLevel},\n         make, AstNode, NameOwner,\n     },\n     SmolStr,\n };\n \n use crate::{\n+    assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n     utils::{get_missing_assoc_items, resolve_target_trait},\n-    Assist, AssistCtx, AssistId,\n+    AssistId,\n };\n \n #[derive(PartialEq)]\n@@ -50,8 +51,9 @@ enum AddMissingImplMembersMode {\n //\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::NoDefaultMethods,\n         \"add_impl_missing_members\",\n@@ -91,8 +93,9 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n //\n // }\n // ```\n-pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::DefaultMethodsOnly,\n         \"add_impl_default_members\",\n@@ -101,11 +104,12 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn add_missing_impl_members_inner(\n-    ctx: AssistCtx,\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n-) -> Option<Assist> {\n+) -> Option<()> {\n     let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::ImplDef>()?;\n     let impl_item_list = impl_def.item_list()?;\n@@ -142,12 +146,11 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    let sema = ctx.sema;\n     let target = impl_def.syntax().text_range();\n-    ctx.add_assist(AssistId(assist_id), label, target, |edit| {\n+    acc.add(AssistId(assist_id), label, target, |edit| {\n         let n_existing_items = impl_item_list.assoc_items().count();\n-        let source_scope = sema.scope_for_def(trait_);\n-        let target_scope = sema.scope(impl_item_list.syntax());\n+        let source_scope = ctx.sema.scope_for_def(trait_);\n+        let target_scope = ctx.sema.scope(impl_item_list.syntax());\n         let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n             .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def));\n         let items = missing_items\n@@ -170,13 +173,11 @@ fn add_missing_impl_members_inner(\n }\n \n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n-    if fn_def.body().is_none() {\n-        let body = make::block_expr(None, Some(make::expr_todo()));\n-        let body = IndentLevel(1).increase_indent(body);\n-        fn_def.with_body(body)\n-    } else {\n-        fn_def\n+    if fn_def.body().is_some() {\n+        return fn_def;\n     }\n+    let body = make::block_expr(None, Some(make::expr_todo())).indent(IndentLevel(1));\n+    fn_def.with_body(body)\n }\n \n #[cfg(test)]"}, {"sha": "fe7451dcfdf4186835cb677902e5cae522ba340c", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_new\n //\n@@ -29,7 +29,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n //\n // ```\n-pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -42,7 +42,7 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n+    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n@@ -123,7 +123,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n+fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n     let db = ctx.db;\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())"}, {"sha": "0feba5e11f6510a7dd7e78c9530899fb35b17a2c", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, AssistContext, AssistId, Assists};\n \n // Assist: apply_demorgan\n //\n@@ -21,7 +21,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n //     if !(x == 4 && y) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n@@ -39,7 +39,7 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let rhs_range = rhs.syntax().text_range();\n     let not_rhs = invert_boolean_expression(rhs);\n \n-    ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n+    acc.add(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n         edit.replace(op_range, opposite_op);\n         edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n         edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));"}, {"sha": "78d23150d385be1ddc4581da32725da056ea3ef6", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeSet;\n \n+use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n@@ -12,12 +13,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n-use either::Either;\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, GroupLabel};\n \n // Assist: auto_import\n //\n@@ -38,21 +34,27 @@ use either::Either;\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let auto_import_assets = AutoImportAssets::new(&ctx)?;\n     let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n     let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n-    let mut group = ctx.add_assist_group(auto_import_assets.get_import_group_message());\n+    let group = auto_import_assets.get_import_group_message();\n     for import in proposed_imports {\n-        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), range, |edit| {\n-            insert_use_statement(&auto_import_assets.syntax_under_caret, &import, edit);\n-        });\n+        acc.add_group(\n+            &group,\n+            AssistId(\"auto_import\"),\n+            format!(\"Import `{}`\", &import),\n+            range,\n+            |builder| {\n+                insert_use_statement(&auto_import_assets.syntax_under_caret, &import, ctx, builder);\n+            },\n+        );\n     }\n-    group.finish()\n+    Some(())\n }\n \n #[derive(Debug)]\n@@ -63,15 +65,15 @@ struct AutoImportAssets {\n }\n \n impl AutoImportAssets {\n-    fn new(ctx: &AssistCtx) -> Option<Self> {\n+    fn new(ctx: &AssistContext) -> Option<Self> {\n         if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n             Self::for_regular_path(path_under_caret, &ctx)\n         } else {\n             Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n         }\n     }\n \n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = method_call.syntax().to_owned();\n         let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n@@ -81,7 +83,7 @@ impl AutoImportAssets {\n         })\n     }\n \n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = path_under_caret.syntax().to_owned();\n         if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n             return None;\n@@ -104,8 +106,8 @@ impl AutoImportAssets {\n         }\n     }\n \n-    fn get_import_group_message(&self) -> String {\n-        match &self.import_candidate {\n+    fn get_import_group_message(&self) -> GroupLabel {\n+        let name = match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n             ImportCandidate::QualifierStart(qualifier_start) => {\n                 format!(\"Import {}\", qualifier_start)\n@@ -116,7 +118,8 @@ impl AutoImportAssets {\n             ImportCandidate::TraitMethod(_, trait_method_name) => {\n                 format!(\"Import a trait for method {}\", trait_method_name)\n             }\n-        }\n+        };\n+        GroupLabel(name)\n     }\n \n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n@@ -383,7 +386,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            use PubMod1::PubStruct;\n+            use PubMod3::PubStruct;\n \n             PubSt<|>ruct\n "}, {"sha": "5c907097e556a8ba8dbcc757db178a6f1c563632", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,11 +1,11 @@\n use ra_syntax::{\n-    ast, AstNode,\n+    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+    AstNode,\n     SyntaxKind::{COMMENT, WHITESPACE},\n     SyntaxNode, TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::{BlockExpr, Expr, LoopBodyOwner};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: change_return_type_to_result\n //\n@@ -18,7 +18,7 @@ use ast::{BlockExpr, Expr, LoopBodyOwner};\n // ```\n // fn foo() -> Result<i32, > { Ok(42i32) }\n // ```\n-pub(crate) fn change_return_type_to_result(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let fn_def = ctx.find_node_at_offset::<ast::FnDef>();\n     let fn_def = &mut fn_def?;\n     let ret_type = &fn_def.ret_type()?.type_ref()?;\n@@ -33,7 +33,7 @@ pub(crate) fn change_return_type_to_result(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"change_return_type_to_result\"),\n         \"Change return type to Result\",\n         ret_type.syntax().text_range(),"}, {"sha": "e631766eff14ab6ae6ca2720ac033ef423b3026d", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -7,10 +7,10 @@ use ra_syntax::{\n     },\n     SyntaxNode, TextSize, T,\n };\n-\n-use crate::{Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: change_visibility\n //\n // Adds or changes existing visibility specifier.\n@@ -22,14 +22,14 @@ use test_utils::tested_by;\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n-        return change_vis(ctx, vis);\n+        return change_vis(acc, vis);\n     }\n-    add_vis(ctx)\n+    add_vis(acc, ctx)\n }\n \n-fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![const] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -66,15 +66,10 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     };\n \n-    ctx.add_assist(\n-        AssistId(\"change_visibility\"),\n-        \"Change visibility to pub(crate)\",\n-        target,\n-        |edit| {\n-            edit.insert(offset, \"pub(crate) \");\n-            edit.set_cursor(offset);\n-        },\n-    )\n+    acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n+        edit.insert(offset, \"pub(crate) \");\n+        edit.set_cursor(offset);\n+    })\n }\n \n fn vis_offset(node: &SyntaxNode) -> TextSize {\n@@ -88,10 +83,10 @@ fn vis_offset(node: &SyntaxNode) -> TextSize {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change Visibility to pub(crate)\",\n             target,\n@@ -103,7 +98,7 @@ fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change visibility to pub\",\n             target,"}, {"sha": "66b296081d1ee0972d2c6267d00eab7f2a9809e4", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 83, "deletions": 85, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -2,14 +2,18 @@ use std::{iter::once, ops::RangeInclusive};\n \n use ra_syntax::{\n     algo::replace_children,\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n     SyntaxKind::{FN_DEF, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n     SyntaxNode,\n };\n \n use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n+    assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n     AssistId,\n };\n@@ -36,7 +40,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -93,96 +97,90 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n-    let cursor_position = ctx.frange.range.start();\n+    let cursor_position = ctx.offset();\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"convert_to_guarded_return\"),\n-        \"Convert to guarded return\",\n-        target,\n-        |edit| {\n-            let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-            let new_block = match if_let_pat {\n-                None => {\n-                    // If.\n-                    let new_expr = {\n-                        let then_branch =\n-                            make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n-                        let cond = invert_boolean_expression(cond_expr);\n-                        let e = make::expr_if(make::condition(cond, None), then_branch);\n-                        if_indent_level.increase_indent(e)\n-                    };\n-                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-                Some((path, bound_ident)) => {\n-                    // If-let.\n-                    let match_expr = {\n-                        let happy_arm = {\n-                            let pat = make::tuple_struct_pat(\n-                                path,\n-                                once(make::bind_pat(make::name(\"it\")).into()),\n-                            );\n-                            let expr = {\n-                                let name_ref = make::name_ref(\"it\");\n-                                let segment = make::path_segment(name_ref);\n-                                let path = make::path_unqualified(segment);\n-                                make::expr_path(path)\n-                            };\n-                            make::match_arm(once(pat.into()), expr)\n-                        };\n-\n-                        let sad_arm = make::match_arm(\n-                            // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                            once(make::placeholder_pat().into()),\n-                            early_expression,\n+    acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n+        let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n+        let new_block = match if_let_pat {\n+            None => {\n+                // If.\n+                let new_expr = {\n+                    let then_branch =\n+                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                    let cond = invert_boolean_expression(cond_expr);\n+                    make::expr_if(make::condition(cond, None), then_branch).indent(if_indent_level)\n+                };\n+                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+            }\n+            Some((path, bound_ident)) => {\n+                // If-let.\n+                let match_expr = {\n+                    let happy_arm = {\n+                        let pat = make::tuple_struct_pat(\n+                            path,\n+                            once(make::bind_pat(make::name(\"it\")).into()),\n                         );\n-\n-                        make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                        let expr = {\n+                            let name_ref = make::name_ref(\"it\");\n+                            let segment = make::path_segment(name_ref);\n+                            let path = make::path_unqualified(segment);\n+                            make::expr_path(path)\n+                        };\n+                        make::match_arm(once(pat.into()), expr)\n                     };\n \n-                    let let_stmt = make::let_stmt(\n-                        make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n-                        Some(match_expr),\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression,\n                     );\n-                    let let_stmt = if_indent_level.increase_indent(let_stmt);\n-                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-            };\n-            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-            edit.set_cursor(cursor_position);\n-\n-            fn replace(\n-                new_expr: &SyntaxNode,\n-                then_block: &ast::BlockExpr,\n-                parent_block: &ast::BlockExpr,\n-                if_expr: &ast::IfExpr,\n-            ) -> SyntaxNode {\n-                let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-                let end_of_then =\n-                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                        end_of_then.prev_sibling_or_token().unwrap()\n-                    } else {\n-                        end_of_then\n-                    };\n-                let mut then_statements = new_expr.children_with_tokens().chain(\n-                    then_block_items\n-                        .syntax()\n-                        .children_with_tokens()\n-                        .skip(1)\n-                        .take_while(|i| *i != end_of_then),\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr),\n                 );\n-                replace_children(\n-                    &parent_block.syntax(),\n-                    RangeInclusive::new(\n-                        if_expr.clone().syntax().clone().into(),\n-                        if_expr.syntax().clone().into(),\n-                    ),\n-                    &mut then_statements,\n-                )\n+                let let_stmt = let_stmt.indent(if_indent_level);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-        },\n-    )\n+        };\n+        edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n+        edit.set_cursor(cursor_position);\n+\n+        fn replace(\n+            new_expr: &SyntaxNode,\n+            then_block: &ast::BlockExpr,\n+            parent_block: &ast::BlockExpr,\n+            if_expr: &ast::IfExpr,\n+        ) -> SyntaxNode {\n+            let then_block_items = then_block.dedent(IndentLevel::from(1));\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+            let mut then_statements = new_expr.children_with_tokens().chain(\n+                then_block_items\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .skip(1)\n+                    .take_while(|i| *i != end_of_then),\n+            );\n+            replace_children(\n+                &parent_block.syntax(),\n+                RangeInclusive::new(\n+                    if_expr.clone().syntax().clone().into(),\n+                    if_expr.syntax().clone().into(),\n+                ),\n+                &mut then_statements,\n+            )\n+        }\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "13c1e7e8014b1317aeebc4992a44a4261943b784", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: fill_match_arms\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n@@ -93,7 +93,7 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = match_expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n+    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n         let new_arm_list = match_arm_list.remove_placeholder().append_arms(missing_arms);\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);"}, {"sha": "692ba4895cb2e917e428fc1e7355dc65da6cab8c", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_binexpr\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();\n@@ -33,7 +33,7 @@ pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n+    acc.add(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n         if let FlipAction::FlipAndReplaceOp(new_op) = action {\n             edit.replace(op_range, new_op);\n         }"}, {"sha": "dfe2a7fedc0576a5a7adfa6176f9154abc68b95b", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_comma\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n@@ -28,7 +28,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n+    acc.add(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n         edit.replace(prev.text_range(), next.to_string());\n         edit.replace(next.text_range(), prev.to_string());\n     })"}, {"sha": "8a08702ab29caf6694f46ebabccde4bf81c2189c", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     Direction, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_trait_bound\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_at_offset(T![+])?;\n@@ -33,7 +33,7 @@ pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n     );\n \n     let target = plus.text_range();\n-    ctx.add_assist(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n+    acc.add(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n         edit.replace(before.text_range(), after.to_string());\n         edit.replace(after.text_range(), before.to_string());\n     })"}, {"sha": "5b26814d30ad3d66ef847abe5b79fb0e555b1ac6", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -5,7 +5,10 @@ use ra_syntax::{\n };\n use test_utils::tested_by;\n \n-use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: inline_local_variable\n //\n@@ -23,7 +26,7 @@ use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n@@ -33,7 +36,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n         tested_by!(test_not_inline_mut_variable);\n         return None;\n     }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.frange.range.start()) {\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n         tested_by!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n@@ -107,20 +110,14 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     let target = bind_pat.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"inline_local_variable\"),\n-        \"Inline variable\",\n-        target,\n-        move |edit: &mut ActionBuilder| {\n-            edit.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n-                let replacement =\n-                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                edit.replace(desc.file_range.range, replacement)\n-            }\n-            edit.set_cursor(delete_range.start())\n-        },\n-    )\n+    acc.add(AssistId(\"inline_local_variable\"), \"Inline variable\", target, move |builder| {\n+        builder.delete(delete_range);\n+        for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+            builder.replace(desc.file_range.range, replacement)\n+        }\n+        builder.set_cursor(delete_range.start())\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "fdf3ada0d794a8638eeff6ed0f4e9ef92b2401cc", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n use stdx::format_to;\n use test_utils::tested_by;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: introduce_variable\n //\n@@ -27,7 +27,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }\n@@ -43,7 +43,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n     let target = expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n+    acc.add(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n         let mut buf = String::new();\n \n         let cursor_offset = if wrap_in_block {"}, {"sha": "527c7caef1a3bf2c068c17588c4148816b51fa5a", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -3,7 +3,11 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::invert_boolean_expression,\n+    AssistId,\n+};\n \n // Assist: invert_if\n //\n@@ -24,7 +28,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n // }\n // ```\n \n-pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n@@ -40,21 +44,21 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n \n     let cond = expr.condition()?.expr()?;\n     let then_node = expr.then_branch()?.syntax().clone();\n+    let else_block = match expr.else_branch()? {\n+        ast::ElseBranch::Block(it) => it,\n+        ast::ElseBranch::IfExpr(_) => return None,\n+    };\n \n-    if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let cond_range = cond.syntax().text_range();\n-        let flip_cond = invert_boolean_expression(cond);\n-        let else_node = else_block.syntax();\n-        let else_range = else_node.text_range();\n-        let then_range = then_node.text_range();\n-        return ctx.add_assist(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n-            edit.replace(cond_range, flip_cond.syntax().text());\n-            edit.replace(else_range, then_node.text());\n-            edit.replace(then_range, else_node.text());\n-        });\n-    }\n-\n-    None\n+    let cond_range = cond.syntax().text_range();\n+    let flip_cond = invert_boolean_expression(cond);\n+    let else_node = else_block.syntax();\n+    let else_range = else_node.text_range();\n+    let then_range = then_node.text_range();\n+    acc.add(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n+        edit.replace(cond_range, flip_cond.syntax().text());\n+        edit.replace(else_range, then_node.text());\n+        edit.replace(then_range, else_node.text());\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "ac3e53c2734a9f05bb2e604e03d36a6a85507911", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: merge_imports\n //\n@@ -20,10 +23,10 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{fmt::Formatter, io};\n // ```\n-pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let tree: ast::UseTree = ctx.find_node_at_offset()?;\n     let mut rewriter = SyntaxRewriter::default();\n-    let mut offset = ctx.frange.range.start();\n+    let mut offset = ctx.offset();\n \n     if let Some(use_item) = tree.syntax().parent().and_then(ast::UseItem::cast) {\n         let (merged, to_delete) = next_prev()\n@@ -53,10 +56,10 @@ pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = tree.syntax().text_range();\n-    ctx.add_assist(AssistId(\"merge_imports\"), \"Merge imports\", target, |edit| {\n-        edit.rewrite(rewriter);\n+    acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n+        builder.rewrite(rewriter);\n         // FIXME: we only need because our diff is imprecise\n-        edit.set_cursor(offset);\n+        builder.set_cursor(offset);\n     })\n }\n "}, {"sha": "d4e38aa6a592c162bbf4ad1cf20a371ddb9922be", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     Direction, TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId, TextRange};\n+use crate::{AssistContext, AssistId, Assists, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -32,7 +32,7 @@ use crate::{Assist, AssistCtx, AssistId, TextRange};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n     if current_arm.guard().is_some() {\n@@ -45,7 +45,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         InExpr(TextSize),\n         InPat(TextSize),\n     }\n-    let cursor_pos = ctx.frange.range.start();\n+    let cursor_pos = ctx.offset();\n     let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n         CursorPos::InExpr(current_text_range.end() - cursor_pos)\n     } else {\n@@ -70,7 +70,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n+    acc.add(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n         let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {"}, {"sha": "a41aacfc3dc39605282f5dd392692481d14e9ad5", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_bounds_to_where_clause\n //\n@@ -22,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n@@ -50,36 +50,29 @@ pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = type_param_list.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"move_bounds_to_where_clause\"),\n-        \"Move to where clause\",\n-        target,\n-        |edit| {\n-            let new_params = type_param_list\n-                .type_params()\n-                .filter(|it| it.type_bound_list().is_some())\n-                .map(|type_param| {\n-                    let without_bounds = type_param.remove_bounds();\n-                    (type_param, without_bounds)\n-                });\n-\n-            let new_type_param_list = type_param_list.replace_descendants(new_params);\n-            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-            let where_clause = {\n-                let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                make::where_clause(predicates)\n-            };\n-\n-            let to_insert = match anchor.prev_sibling_or_token() {\n-                Some(ref elem) if elem.kind() == WHITESPACE => {\n-                    format!(\"{} \", where_clause.syntax())\n-                }\n-                _ => format!(\" {}\", where_clause.syntax()),\n-            };\n-            edit.insert(anchor.text_range().start(), to_insert);\n-        },\n-    )\n+    acc.add(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", target, |edit| {\n+        let new_params = type_param_list\n+            .type_params()\n+            .filter(|it| it.type_bound_list().is_some())\n+            .map(|type_param| {\n+                let without_bounds = type_param.remove_bounds();\n+                (type_param, without_bounds)\n+            });\n+\n+        let new_type_param_list = type_param_list.replace_descendants(new_params);\n+        edit.replace_ast(type_param_list.clone(), new_type_param_list);\n+\n+        let where_clause = {\n+            let predicates = type_param_list.type_params().filter_map(build_predicate);\n+            make::where_clause(predicates)\n+        };\n+\n+        let to_insert = match anchor.prev_sibling_or_token() {\n+            Some(ref elem) if elem.kind() == WHITESPACE => format!(\"{} \", where_clause.syntax()),\n+            _ => format!(\" {}\", where_clause.syntax()),\n+        };\n+        edit.insert(anchor.text_range().start(), to_insert);\n+    })\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {"}, {"sha": "fc0335b5785d909179f9a6fdb2b4876c76521bee", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_guard_to_arm_body\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n@@ -41,7 +41,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n     let target = guard.syntax().text_range();\n-    ctx.add_assist(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n+    acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n         let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n             Some(tok) => {\n                 if ast::Whitespace::cast(tok.clone()).is_some() {\n@@ -88,7 +88,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let match_pat = match_arm.pat()?;\n \n@@ -109,7 +109,7 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\" if {}\", cond.syntax().text());\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"move_arm_cond_to_match_guard\"),\n         \"Move condition to match guard\",\n         target,"}, {"sha": "c20ffe0b30aba765e97876eb08c18710f0a4fa49", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: make_raw_string\n //\n@@ -22,11 +22,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n+    acc.add(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n         let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n@@ -51,11 +51,11 @@ pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n+    acc.add(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n         // parse inside string to escape `\"`\n         let escaped = value.escape_default().to_string();\n         edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n@@ -77,10 +77,10 @@ pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n+    acc.add(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n         edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n@@ -101,15 +101,15 @@ pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n+    acc.add(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n             // FIXME: this logic is wrong, not only the last has has to handled specially"}, {"sha": "8eef578cf40128ae2fafc658c451ac30150bbe44", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextSize, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_dbg\n //\n@@ -20,7 +20,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {\n@@ -58,7 +58,7 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = macro_call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n+    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n         edit.replace(macro_range, macro_content);\n         edit.set_cursor(cursor_pos);\n     })"}, {"sha": "dce546db79d5607eb7cc1c9d3edf8ef15c98b6f9", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SyntaxKind, TextRange, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_mut\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     fn feed(&self, amount: u32) {}\n // }\n // ```\n-pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let mut_token = ctx.find_token_at_offset(T![mut])?;\n     let delete_from = mut_token.text_range().start();\n     let delete_to = match mut_token.next_token() {\n@@ -26,7 +26,7 @@ pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = mut_token.text_range();\n-    ctx.add_assist(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n+    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n         edit.set_cursor(delete_from);\n         edit.delete(TextRange::new(delete_from, delete_to));\n     })"}, {"sha": "757f6406e9185e7f7c05d4963ae536076fd4b293", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -3,18 +3,9 @@ use std::collections::HashMap;\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, Path, RecordLit, RecordPat},\n-    match_ast, AstNode, SyntaxKind,\n-    SyntaxKind::*,\n-    SyntaxNode,\n-};\n-\n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    AssistId,\n-};\n+use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n+\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: reorder_fields\n //\n@@ -31,13 +22,13 @@ use crate::{\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n //\n-pub(crate) fn reorder_fields(ctx: AssistCtx) -> Option<Assist> {\n-    reorder::<RecordLit>(ctx.clone()).or_else(|| reorder::<RecordPat>(ctx))\n+pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    reorder::<ast::RecordLit>(acc, ctx.clone()).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n-fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n+fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx.find_node_at_offset::<R>()?;\n-    let path = record.syntax().children().find_map(Path::cast)?;\n+    let path = record.syntax().children().find_map(ast::Path::cast)?;\n \n     let ranks = compute_fields_ranks(&path, &ctx)?;\n \n@@ -51,7 +42,7 @@ fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = record.syntax().text_range();\n-    ctx.add_assist(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n+    acc.add(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n         for (old, new) in fields.iter().zip(&sorted_fields) {\n             algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n         }\n@@ -96,9 +87,9 @@ fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option\n     }\n }\n \n-fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String, usize>> {\n+fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<HashMap<String, usize>> {\n     Some(\n-        struct_definition(path, ctx.sema)?\n+        struct_definition(path, &ctx.sema)?\n             .fields(ctx.db)\n             .iter()\n             .enumerate()"}, {"sha": "65f5fc6abec7d58470693ebace5c12297b8bc28d", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,10 +1,14 @@\n use ra_fmt::unwrap_trivial_block;\n use ra_syntax::{\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_if_let_with_match\n //\n@@ -32,7 +36,7 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -43,36 +47,30 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    let sema = ctx.sema;\n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_if_let_with_match\"),\n-        \"Replace with match\",\n-        target,\n-        move |edit| {\n-            let match_expr = {\n-                let then_arm = {\n-                    let then_expr = unwrap_trivial_block(then_block);\n-                    make::match_arm(vec![pat.clone()], then_expr)\n-                };\n-                let else_arm = {\n-                    let pattern = sema\n-                        .type_of_pat(&pat)\n-                        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n-                        .map(|it| it.sad_pattern())\n-                        .unwrap_or_else(|| make::placeholder_pat().into());\n-                    let else_expr = unwrap_trivial_block(else_block);\n-                    make::match_arm(vec![pattern], else_expr)\n-                };\n-                make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+    acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n+        let match_expr = {\n+            let then_arm = {\n+                let then_expr = unwrap_trivial_block(then_block);\n+                make::match_arm(vec![pat.clone()], then_expr)\n             };\n+            let else_arm = {\n+                let pattern = ctx\n+                    .sema\n+                    .type_of_pat(&pat)\n+                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                    .map(|it| it.sad_pattern())\n+                    .unwrap_or_else(|| make::placeholder_pat().into());\n+                let else_expr = unwrap_trivial_block(else_block);\n+                make::match_arm(vec![pattern], else_expr)\n+            };\n+            make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+                .indent(IndentLevel::from_node(if_expr.syntax()))\n+        };\n \n-            let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n-\n-            edit.set_cursor(if_expr.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(if_expr.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "482957dc602934536335792aa93771bcd4e83426", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -9,11 +9,7 @@ use ra_syntax::{\n     AstNode, T,\n };\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::TryEnum,\n-    AssistId,\n-};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_let_with_if_let\n //\n@@ -39,16 +35,16 @@ use crate::{\n //\n // fn compute() -> Option<i32> { None }\n // ```\n-pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_kw = ctx.find_token_at_offset(T![let])?;\n     let let_stmt = let_kw.ancestors().find_map(ast::LetStmt::cast)?;\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty).map(|it| it.happy_case());\n \n     let target = let_kw.text_range();\n-    ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n+    acc.add(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n         let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat(\n@@ -57,8 +53,7 @@ pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n             )\n             .into(),\n         };\n-        let block =\n-            IndentLevel::from_node(let_stmt.syntax()).increase_indent(make::block_expr(None, None));\n+        let block = make::block_expr(None, None).indent(IndentLevel::from_node(let_stmt.syntax()));\n         let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n         let stmt = make::expr_stmt(if_);\n "}, {"sha": "1a81d8a0e0215ce3881642e44c21b5709e707dd8", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,11 +1,7 @@\n use hir;\n use ra_syntax::{ast, AstNode, SmolStr, TextRange};\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists};\n \n // Assist: replace_qualified_name_with_use\n //\n@@ -20,7 +16,10 @@ use crate::{\n //\n // fn process(map: HashMap<String, String>) {}\n // ```\n-pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_qualified_name_with_use(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n@@ -34,18 +33,18 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n     }\n \n     let target = path.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"replace_qualified_name_with_use\"),\n         \"Replace qualified path with use\",\n         target,\n-        |edit| {\n+        |builder| {\n             let path_to_import = hir_path.mod_path().clone();\n-            insert_use_statement(path.syntax(), &path_to_import, edit);\n+            insert_use_statement(path.syntax(), &path_to_import, ctx, builder);\n \n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n                 // so we can delete the path qualifier\n-                edit.delete(TextRange::new(\n+                builder.delete(TextRange::new(\n                     path.syntax().text_range().start(),\n                     last.syntax().text_range().start(),\n                 ));"}, {"sha": "c4b56f6e90ab6ebfc551abb36670e1f7e09e934c", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,11 +1,15 @@\n use std::iter;\n \n use ra_syntax::{\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make,\n+    },\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -29,41 +33,34 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     };\n // }\n // ```\n-pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     let name = method_call.name_ref()?;\n     if name.text() != \"unwrap\" {\n         return None;\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_unwrap_with_match\"),\n-        \"Replace unwrap with match\",\n-        target,\n-        |edit| {\n-            let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-            let it = make::bind_pat(make::name(\"a\")).into();\n-            let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |edit| {\n+        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+        let it = make::bind_pat(make::name(\"a\")).into();\n+        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-            let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-            let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-            let unreachable_call = make::unreachable_macro_call().into();\n-            let err_arm =\n-                make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n+        let unreachable_call = make::unreachable_macro_call().into();\n+        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-            let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-            let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-            let match_expr =\n-                IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n+        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list)\n+            .indent(IndentLevel::from_node(method_call.syntax()));\n \n-            edit.set_cursor(caller.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(caller.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "b2757e50ce709ebe042ccf870eacd5300c43764e", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -2,7 +2,7 @@ use std::iter::successors;\n \n use ra_syntax::{ast, AstNode, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: split_import\n //\n@@ -15,7 +15,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?.qualifier()?;\n     let top_path = successors(Some(path.clone()), |it| it.parent_path()).last()?;\n@@ -26,10 +26,10 @@ pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n     if new_tree == use_tree {\n         return None;\n     }\n-    let cursor = ctx.frange.range.start();\n+    let cursor = ctx.offset();\n \n     let target = colon_colon.text_range();\n-    ctx.add_assist(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n+    acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n         edit.set_cursor(cursor);\n     })"}, {"sha": "eba0631a4c242c9a0d9544162a79774f60e49ef6", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,4 +1,4 @@\n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n use ast::LoopBodyOwner;\n use ra_fmt::unwrap_trivial_block;\n@@ -21,7 +21,7 @@ use ra_syntax::{ast, match_ast, AstNode, TextRange, T};\n //     println!(\"foo\");\n // }\n // ```\n-pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n     let block = ast::BlockExpr::cast(l_curly_token.parent())?;\n     let parent = block.syntax().parent()?;\n@@ -58,7 +58,7 @@ pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = expr_to_unwrap.syntax().text_range();\n-    ctx.add_assist(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n+    acc.add(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n         edit.set_cursor(expr.syntax().text_range().start());\n \n         let pat_start: &[_] = &[' ', '{', '\\n'];"}, {"sha": "b6dc7cb1bfc10166be3900ddfbd4ac9757409d2f", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -10,7 +10,7 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-mod assist_ctx;\n+mod assist_context;\n mod marks;\n #[cfg(test)]\n mod tests;\n@@ -22,15 +22,18 @@ use ra_db::FileRange;\n use ra_ide_db::{source_change::SourceChange, RootDatabase};\n use ra_syntax::TextRange;\n \n-pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n+pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct AssistId(pub &'static str);\n \n+#[derive(Clone, Debug)]\n+pub struct GroupLabel(pub String);\n+\n #[derive(Debug, Clone)]\n-pub struct AssistLabel {\n+pub struct Assist {\n     pub id: AssistId,\n     /// Short description of the assist, as shown in the UI.\n     pub label: String,\n@@ -40,74 +43,69 @@ pub struct AssistLabel {\n     pub target: TextRange,\n }\n \n-#[derive(Clone, Debug)]\n-pub struct GroupLabel(pub String);\n+#[derive(Debug, Clone)]\n+pub struct ResolvedAssist {\n+    pub assist: Assist,\n+    pub source_change: SourceChange,\n+}\n+\n+impl Assist {\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"unresolved\" state, that is only labels are\n+    /// returned, without actual edits.\n+    pub fn unresolved(db: &RootDatabase, range: FileRange) -> Vec<Assist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, range);\n+        let mut acc = Assists::new_unresolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_unresolved()\n+    }\n+\n+    /// Return all the assists applicable at the given position.\n+    ///\n+    /// Assists are returned in the \"resolved\" state, that is with edit fully\n+    /// computed.\n+    pub fn resolved(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n+        let sema = Semantics::new(db);\n+        let ctx = AssistContext::new(sema, range);\n+        let mut acc = Assists::new_resolved(&ctx);\n+        handlers::all().iter().for_each(|handler| {\n+            handler(&mut acc, &ctx);\n+        });\n+        acc.finish_resolved()\n+    }\n \n-impl AssistLabel {\n     pub(crate) fn new(\n         id: AssistId,\n         label: String,\n         group: Option<GroupLabel>,\n         target: TextRange,\n-    ) -> AssistLabel {\n+    ) -> Assist {\n         // FIXME: make fields private, so that this invariant can't be broken\n         assert!(label.starts_with(|c: char| c.is_uppercase()));\n-        AssistLabel { id, label, group, target }\n+        Assist { id, label, group, target }\n     }\n }\n \n-#[derive(Debug, Clone)]\n-pub struct ResolvedAssist {\n-    pub label: AssistLabel,\n-    pub source_change: SourceChange,\n-}\n-\n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"unresolved\" state, that is only labels are\n-/// returned, without actual edits.\n-pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabel> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, false);\n-    handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|a| a.label)\n-        .collect()\n-}\n-\n-/// Return all the assists applicable at the given position.\n-///\n-/// Assists are returned in the \"resolved\" state, that is with edit fully\n-/// computed.\n-pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n-    let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, true);\n-    let mut a = handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|it| it.into_resolved().unwrap())\n-        .collect::<Vec<_>>();\n-    a.sort_by_key(|it| it.label.target.len());\n-    a\n-}\n-\n mod handlers {\n-    use crate::{Assist, AssistCtx};\n+    use crate::{AssistContext, Assists};\n \n-    pub(crate) type Handler = fn(AssistCtx) -> Option<Assist>;\n+    pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_from_impl_for_enum;\n     mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n     mod apply_demorgan;\n     mod auto_import;\n+    mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n@@ -124,14 +122,12 @@ mod handlers {\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n+    mod reorder_fields;\n     mod replace_if_let_with_match;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n-    mod change_return_type_to_result;\n-    mod add_from_impl_for_enum;\n-    mod reorder_fields;\n     mod unwrap_block;\n \n     pub(crate) fn all() -> &'static [Handler] {"}, {"sha": "a3eacb8f11540897e8cda3208325b25710059408", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -11,7 +11,7 @@ use test_utils::{\n     RangeOrOffset,\n };\n \n-use crate::{handlers::Handler, resolved_assists, AssistCtx};\n+use crate::{handlers::Handler, Assist, AssistContext, Assists};\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     let (mut db, file_id) = RootDatabase::with_single_file(text);\n@@ -41,16 +41,16 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let (db, file_id) = crate::tests::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let mut assist = resolved_assists(&db, frange)\n+    let mut assist = Assist::resolved(&db, frange)\n         .into_iter()\n-        .find(|assist| assist.label.id.0 == assist_id)\n+        .find(|assist| assist.assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                resolved_assists(&db, frange)\n+                Assist::resolved(&db, frange)\n                     .into_iter()\n-                    .map(|assist| assist.label.id.0)\n+                    .map(|assist| assist.assist.id.0)\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             )\n@@ -71,7 +71,7 @@ enum ExpectedResult<'a> {\n     Target(&'a str),\n }\n \n-fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n+fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let (text_without_caret, file_with_caret_id, range_or_offset, db) = if before.contains(\"//-\") {\n         let (mut db, position) = RootDatabase::with_position(before);\n         db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n@@ -90,17 +90,20 @@ fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let assist_ctx = AssistCtx::new(&sema, frange, true);\n-\n-    match (assist(assist_ctx), expected) {\n+    let ctx = AssistContext::new(sema, frange);\n+    let mut acc = Assists::new_resolved(&ctx);\n+    handler(&mut acc, &ctx);\n+    let mut res = acc.finish_resolved();\n+    let assist = res.pop();\n+    match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let mut action = assist.0[0].source_change.clone().unwrap();\n-            let change = action.source_file_edits.pop().unwrap();\n+            let mut source_change = assist.source_change;\n+            let change = source_change.source_file_edits.pop().unwrap();\n \n             let mut actual = db.file_text(change.file_id).as_ref().to_owned();\n             change.edit.apply(&mut actual);\n \n-            match action.cursor_position {\n+            match source_change.cursor_position {\n                 None => {\n                     if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {\n                         let off = change\n@@ -116,7 +119,7 @@ fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n             assert_eq_text!(after, &actual);\n         }\n         (Some(assist), ExpectedResult::Target(target)) => {\n-            let range = assist.0[0].label.target;\n+            let range = assist.assist.target;\n             assert_eq_text!(&text_without_caret[range], target);\n         }\n         (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n@@ -133,14 +136,14 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = resolved_assists(&db, frange);\n+    let assists = Assist::resolved(&db, frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(\n-        assists.next().expect(\"expected assist\").label.label,\n+        assists.next().expect(\"expected assist\").assist.label,\n         \"Change visibility to pub(crate)\"\n     );\n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Add `#[derive]`\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Add `#[derive]`\");\n }\n \n #[test]\n@@ -156,9 +159,9 @@ fn assist_order_if_expr() {\n     let (range, before) = extract_range(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range };\n-    let assists = resolved_assists(&db, frange);\n+    let assists = Assist::resolved(&db, frange);\n     let mut assists = assists.iter();\n \n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Extract into variable\");\n-    assert_eq!(assists.next().expect(\"expected assist\").label.label, \"Replace with match\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Extract into variable\");\n+    assert_eq!(assists.next().expect(\"expected assist\").assist.label, \"Replace with match\");\n }"}, {"sha": "1214e3cd47a66492234e0ad9fc1572612f807b37", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -2,7 +2,6 @@\n // FIXME: rewrite according to the plan, outlined in\n // https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n \n-use crate::assist_ctx::ActionBuilder;\n use hir::{self, ModPath};\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -12,17 +11,20 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n+use crate::assist_context::{AssistBuilder, AssistContext};\n+\n /// Creates and inserts a use statement for the given path to import.\n /// The use statement is inserted in the scope most appropriate to the\n /// the cursor position given, additionally merged with the existing use imports.\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     path_to_import: &ModPath,\n-    edit: &mut ActionBuilder,\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n ) {\n     let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = edit.ctx().sema.ancestors_with_macros(position.clone()).find_map(|n| {\n+    let container = ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n             return module.item_list().map(|it| it.syntax().clone());\n         }\n@@ -31,7 +33,7 @@ pub(crate) fn insert_use_statement(\n \n     if let Some(container) = container {\n         let action = best_action_for_target(container, position.clone(), &target);\n-        make_assist(&action, &target, edit.text_edit_builder());\n+        make_assist(&action, &target, builder.text_edit_builder());\n     }\n }\n "}, {"sha": "57feabcb27cb57e981aa2898113716ff94cdb971", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -2,8 +2,6 @@\n \n mod cfg_expr;\n \n-use std::iter::IntoIterator;\n-\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n@@ -48,9 +46,4 @@ impl CfgOptions {\n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n         self.key_values.insert((key, value));\n     }\n-\n-    /// Shortcut to set features\n-    pub fn insert_features(&mut self, iter: impl IntoIterator<Item = SmolStr>) {\n-        iter.into_iter().for_each(|feat| self.insert_key_value(\"feature\".into(), feat));\n-    }\n }"}, {"sha": "03e55714844b1bacc82da7a37c7c80633e3367e4", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -14,6 +14,7 @@ log = \"0.4.8\"\n cargo_metadata = \"0.9.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n+ra_toolchain = { path = \"../ra_toolchain\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "68dcee2851d3191d08ddac39b0eb365f4f946a50", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -4,7 +4,6 @@\n mod conv;\n \n use std::{\n-    env,\n     io::{self, BufRead, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n@@ -216,10 +215,10 @@ impl FlycheckThread {\n \n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n-                let mut cmd = Command::new(cargo_binary());\n+                let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n-                cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }\n@@ -337,7 +336,3 @@ fn run_cargo(\n \n     Ok(())\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "6d84444621ee25952978988231d3a31d9912f191", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -22,8 +22,11 @@ use hir_expand::{\n     MacroDefId, MacroDefKind,\n };\n use hir_ty::{\n-    autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    autoderef,\n+    display::{HirDisplayError, HirFormatter},\n+    expr::ExprValidator,\n+    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, Ty,\n+    TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -1341,7 +1344,7 @@ impl Type {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> std::fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.ty.value.hir_fmt(f)\n     }\n }"}, {"sha": "41ac702724e845ec68845a20b4e8357a32beb65c", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -131,3 +131,31 @@ impl AstDiagnostic for MissingOkInTailExpr {\n         ast::Expr::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct BreakOutsideOfLoop {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for BreakOutsideOfLoop {\n+    fn message(&self) -> String {\n+        \"break outside of loop\".to_string()\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for BreakOutsideOfLoop {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "f5edaea8c80683f49b29a33ff4ea069fbf0f2008", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 140, "deletions": 36, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,28 +6,42 @@ use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n     Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n-use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_def::{\n+    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n+    Lookup, ModuleId,\n+};\n use hir_expand::name::Name;\n \n-pub struct HirFormatter<'a, 'b> {\n+pub struct HirFormatter<'a> {\n     pub db: &'a dyn HirDatabase,\n-    fmt: &'a mut fmt::Formatter<'b>,\n+    fmt: &'a mut dyn fmt::Write,\n     buf: String,\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result;\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n \n+    /// Returns a `Display`able type that is human-readable.\n+    /// Use this for showing types to the user (e.g. diagnostics)\n     fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, None, false)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n     }\n \n+    /// Returns a `Display`able type that is human-readable and tries to be succinct.\n+    /// Use this for showing types to the user where space is constrained (e.g. doc popups)\n     fn display_truncated<'a>(\n         &'a self,\n         db: &'a dyn HirDatabase,\n@@ -36,16 +50,46 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, max_size, true)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types: true,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n+    }\n+\n+    /// Returns a String representation of `self` that can be inserted into the given module.\n+    /// Use this when generating code (e.g. assists)\n+    fn display_source_code<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+        module_id: ModuleId,\n+    ) -> Result<String, DisplaySourceCodeError> {\n+        let mut result = String::new();\n+        match self.hir_fmt(&mut HirFormatter {\n+            db,\n+            fmt: &mut result,\n+            buf: String::with_capacity(20),\n+            curr_size: 0,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::SourceCode { module_id },\n+        }) {\n+            Ok(()) => {}\n+            Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n+            Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),\n+        };\n+        Ok(result)\n     }\n }\n \n-impl<'a, 'b> HirFormatter<'a, 'b> {\n+impl<'a> HirFormatter<'a> {\n     pub fn write_joined<T: HirDisplay>(\n         &mut self,\n         iter: impl IntoIterator<Item = T>,\n         sep: &str,\n-    ) -> fmt::Result {\n+    ) -> Result<(), HirDisplayError> {\n         let mut first = true;\n         for e in iter {\n             if !first {\n@@ -58,14 +102,14 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n-    pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n+    pub fn write_fmt(&mut self, args: fmt::Arguments) -> Result<(), HirDisplayError> {\n         // We write to a buffer first to track output size\n         self.buf.clear();\n         fmt::write(&mut self.buf, args)?;\n         self.curr_size += self.buf.len();\n \n         // Then we write to the internal formatter from the buffer\n-        self.fmt.write_str(&self.buf)\n+        self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)\n     }\n \n     pub fn should_truncate(&self) -> bool {\n@@ -81,34 +125,76 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, T>(&'a dyn HirDatabase, &'a T, Option<usize>, bool);\n+#[derive(Clone, Copy)]\n+enum DisplayTarget {\n+    /// Display types for inlays, doc popups, autocompletion, etc...\n+    /// Showing `{unknown}` or not qualifying paths is fine here.\n+    /// There's no reason for this to fail.\n+    Diagnostics,\n+    /// Display types for inserting them in source files.\n+    /// The generated code should compile, so paths need to be qualified.\n+    SourceCode { module_id: ModuleId },\n+}\n+\n+#[derive(Debug)]\n+pub enum DisplaySourceCodeError {\n+    PathNotFound,\n+}\n+\n+pub enum HirDisplayError {\n+    /// Errors that can occur when generating source code\n+    DisplaySourceCodeError(DisplaySourceCodeError),\n+    /// `FmtError` is required to be compatible with std::fmt::Display\n+    FmtError,\n+}\n+impl From<fmt::Error> for HirDisplayError {\n+    fn from(_: fmt::Error) -> Self {\n+        Self::FmtError\n+    }\n+}\n+\n+pub struct HirDisplayWrapper<'a, T> {\n+    db: &'a dyn HirDatabase,\n+    t: &'a T,\n+    max_size: Option<usize>,\n+    omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n+}\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.1.hir_fmt(&mut HirFormatter {\n-            db: self.0,\n+        match self.t.hir_fmt(&mut HirFormatter {\n+            db: self.db,\n             fmt: f,\n             buf: String::with_capacity(20),\n             curr_size: 0,\n-            max_size: self.2,\n-            omit_verbose_types: self.3,\n-        })\n+            max_size: self.max_size,\n+            omit_verbose_types: self.omit_verbose_types,\n+            display_target: self.display_target,\n+        }) {\n+            Ok(()) => Ok(()),\n+            Err(HirDisplayError::FmtError) => Err(fmt::Error),\n+            Err(HirDisplayError::DisplaySourceCodeError(_)) => {\n+                // This should never happen\n+                panic!(\"HirDisplay failed when calling Display::fmt!\")\n+            }\n+        }\n     }\n }\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -191,12 +277,30 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n+                match f.display_target {\n+                    DisplayTarget::Diagnostics => {\n+                        let name = match def_id {\n+                            AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                            AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                            AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                        };\n+                        write!(f, \"{}\", name)?;\n+                    }\n+                    DisplayTarget::SourceCode { module_id } => {\n+                        if let Some(path) = find_path::find_path(\n+                            f.db.upcast(),\n+                            ItemInNs::Types(def_id.into()),\n+                            module_id,\n+                        ) {\n+                            write!(f, \"{}\", path)?;\n+                        } else {\n+                            return Err(HirDisplayError::DisplaySourceCodeError(\n+                                DisplaySourceCodeError::PathNotFound,\n+                            ));\n+                        }\n+                    }\n+                }\n+\n                 if self.parameters.len() > 0 {\n                     let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n                     let parameters_to_write = if f.omit_verbose_types() {\n@@ -269,7 +373,7 @@ impl HirDisplay for ApplicationTy {\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -287,7 +391,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -332,7 +436,7 @@ impl HirDisplay for Ty {\n fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n-) -> fmt::Result {\n+) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n     // actual Rust. It will have weird results if the predicates\n@@ -394,7 +498,7 @@ fn write_bounds_like_dyn_trait(\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> fmt::Result {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -416,19 +520,19 @@ impl TraitRef {\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.hir_fmt_ext(f, false)\n     }\n }\n \n impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -452,15 +556,15 @@ impl HirDisplay for GenericPredicate {\n }\n \n impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        Ok(match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db))?,\n             Obligation::Projection(proj) => write!(\n                 f,\n                 \"Normalize({} => {})\",\n                 proj.projection_ty.display(f.db),\n                 proj.ty.display(f.db)\n-            ),\n-        }\n+            )?,\n+        })\n     }\n }"}, {"sha": "a21ad8d86416b4dab68c78b7d734bb0e704e693a", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -210,6 +210,13 @@ struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    diverges: Diverges,\n+    breakables: Vec<BreakableContext>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BreakableContext {\n+    pub may_break: bool,\n }\n \n impl<'a> InferenceContext<'a> {\n@@ -224,6 +231,8 @@ impl<'a> InferenceContext<'a> {\n             owner,\n             body: db.body(owner),\n             resolver,\n+            diverges: Diverges::Maybe,\n+            breakables: Vec::new(),\n         }\n     }\n \n@@ -666,15 +675,57 @@ impl Expectation {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    Maybe,\n+    Always,\n+}\n+\n+impl Diverges {\n+    fn is_always(self) -> bool {\n+        self == Diverges::Always\n+    }\n+}\n+\n+impl std::ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        std::cmp::min(self, other)\n+    }\n+}\n+\n+impl std::ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        std::cmp::max(self, other)\n+    }\n+}\n+\n+impl std::ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl std::ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n mod diagnostics {\n     use hir_def::{expr::ExprId, FunctionId};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n+    use crate::{\n+        db::HirDatabase,\n+        diagnostics::{BreakOutsideOfLoop, NoSuchField},\n+    };\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n         NoSuchField { expr: ExprId, field: usize },\n+        BreakOutsideOfLoop { expr: ExprId },\n     }\n \n     impl InferenceDiagnostic {\n@@ -690,6 +741,13 @@ mod diagnostics {\n                     let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file: field.file_id, field: field.value })\n                 }\n+                InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let ptr = source_map\n+                        .expr_syntax(*expr)\n+                        .expect(\"break outside of loop in synthetic syntax\");\n+                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n+                }\n             }\n         }\n     }"}, {"sha": "173ec59edf6ceebb646524a4f5e5a89ca2f68b2a", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -20,21 +20,35 @@ impl<'a> InferenceContext<'a> {\n         self.coerce_inner(from_ty, &to_ty)\n     }\n \n-    /// Merge two types from different branches, with possible implicit coerce.\n+    /// Merge two types from different branches, with possible coercion.\n     ///\n-    /// Note that it is only possible that one type are coerced to another.\n-    /// Coercing both types to another least upper bound type is not possible in rustc,\n-    /// which will simply result in \"incompatible types\" error.\n+    /// Mostly this means trying to coerce one to the other, but\n+    ///  - if we have two function types for different functions, we need to\n+    ///    coerce both to function pointers;\n+    ///  - if we were concerned with lifetime subtyping, we'd need to look for a\n+    ///    least upper bound.\n     pub(super) fn coerce_merge_branch(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n         if self.coerce(ty1, ty2) {\n             ty2.clone()\n         } else if self.coerce(ty2, ty1) {\n             ty1.clone()\n         } else {\n-            tested_by!(coerce_merge_fail_fallback);\n-            // For incompatible types, we use the latter one as result\n-            // to be better recovery for `if` without `else`.\n-            ty2.clone()\n+            if let (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnDef(_))) = (ty1, ty2) {\n+                tested_by!(coerce_fn_reification);\n+                // Special case: two function types. Try to coerce both to\n+                // pointers to have a chance at getting a match. See\n+                // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n+                let sig1 = ty1.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let sig2 = ty2.callable_sig(self.db).expect(\"FnDef without callable sig\");\n+                let ptr_ty1 = Ty::fn_ptr(sig1);\n+                let ptr_ty2 = Ty::fn_ptr(sig2);\n+                self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n+            } else {\n+                tested_by!(coerce_merge_fail_fallback);\n+                // For incompatible types, we use the latter one as result\n+                // to be better recovery for `if` without `else`.\n+                ty2.clone()\n+            }\n         }\n     }\n \n@@ -84,9 +98,7 @@ impl<'a> InferenceContext<'a> {\n                 match from_ty.callable_sig(self.db) {\n                     None => return false,\n                     Some(sig) => {\n-                        let num_args = sig.params_and_return.len() as u16 - 1;\n-                        from_ty =\n-                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                        from_ty = Ty::fn_ptr(sig);\n                     }\n                 }\n             }"}, {"sha": "0b67d216a8bf3ee4570d49a1eace14a775e6315b", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,7 +1,7 @@\n //! Type inference for expressions.\n \n use std::iter::{repeat, repeat_with};\n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n use hir_def::{\n     builtin_type::Signedness,\n@@ -21,11 +21,18 @@ use crate::{\n     Ty, TypeCtor, Uncertain,\n };\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+use super::{\n+    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n+    TypeMismatch,\n+};\n \n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n+        if ty.is_never() {\n+            // Any expression that produces a value of type `!` must have diverged\n+            self.diverges = Diverges::Always;\n+        }\n         let could_unify = self.unify(&ty, &expected.ty);\n         if !could_unify {\n             self.result.type_mismatches.insert(\n@@ -64,11 +71,18 @@ impl<'a> InferenceContext<'a> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n+                let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let mut both_arms_diverge = Diverges::Always;\n+\n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n+                both_arms_diverge &= self.diverges;\n+\n+                self.diverges = condition_diverges | both_arms_diverge;\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n@@ -79,24 +93,43 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+\n+                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                if ctxt.may_break {\n+                    self.diverges = Diverges::Maybe;\n+                }\n                 // FIXME handle break with value\n-                Ty::simple(TypeCtor::Never)\n+                if ctxt.may_break {\n+                    Ty::unit()\n+                } else {\n+                    Ty::simple(TypeCtor::Never)\n+                }\n             }\n             Expr::While { condition, body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n+                self.breakables.push(BreakableContext { may_break: false });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::Lambda { body, args, ret_type, arg_types } => {\n@@ -132,10 +165,12 @@ impl<'a> InferenceContext<'a> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n-                let prev_ret_ty = std::mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n                 self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n \n+                self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n \n                 closure_ty\n@@ -165,7 +200,11 @@ impl<'a> InferenceContext<'a> {\n                     self.table.new_type_var()\n                 };\n \n+                let matchee_diverges = self.diverges;\n+                let mut all_arms_diverge = Diverges::Always;\n+\n                 for arm in arms {\n+                    self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n@@ -175,9 +214,12 @@ impl<'a> InferenceContext<'a> {\n                     }\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    all_arms_diverge &= self.diverges;\n                     result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n+                self.diverges = matchee_diverges | all_arms_diverge;\n+\n                 result_ty\n             }\n             Expr::Path(p) => {\n@@ -191,6 +233,13 @@ impl<'a> InferenceContext<'a> {\n                     // FIXME handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n+                if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.may_break = true;\n+                } else {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                    });\n+                }\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {\n@@ -501,8 +550,8 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 Literal::ByteString(..) => {\n                     let byte_type = Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::u8())));\n-                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n+                    let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n                 Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),\n@@ -522,7 +571,6 @@ impl<'a> InferenceContext<'a> {\n         tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        let mut diverges = false;\n         for stmt in statements {\n             match stmt {\n                 Statement::Let { pat, type_ref, initializer } => {\n@@ -544,24 +592,30 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n-                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n-                        diverges = true;\n-                    }\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n \n         let ty = if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n-            self.coerce(&Ty::unit(), expected.coercion_target());\n-            Ty::unit()\n+            // Citing rustc: if there is no explicit tail expression,\n+            // that is typically equivalent to a tail expression\n+            // of `()` -- except if the block diverges. In that\n+            // case, there is no value supplied from the tail\n+            // expression (assuming there are no other breaks,\n+            // this implies that the type of the block will be\n+            // `!`).\n+            if self.diverges.is_always() {\n+                // we don't even make an attempt at coercion\n+                self.table.new_maybe_never_type_var()\n+            } else {\n+                self.coerce(&Ty::unit(), expected.coercion_target());\n+                Ty::unit()\n+            }\n         };\n-        if diverges {\n-            Ty::simple(TypeCtor::Never)\n-        } else {\n-            ty\n-        }\n+        ty\n     }\n \n     fn infer_method_call("}, {"sha": "e8f3482fe4634fdd54544578ac3bfb560fc70ead", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -683,6 +683,12 @@ impl Ty {\n     pub fn unit() -> Self {\n         Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n+    pub fn fn_ptr(sig: FnSig) -> Self {\n+        Ty::apply(\n+            TypeCtor::FnPtr { num_args: sig.params().len() as u16 },\n+            Substs(sig.params_and_return),\n+        )\n+    }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n@@ -730,6 +736,10 @@ impl Ty {\n         }\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        matches!(self, Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }))\n+    }\n+\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self {"}, {"sha": "a397401434bfc4e3c07ee404b64d08056112fb01", "filename": "crates/ra_hir_ty/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmarks.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -7,5 +7,6 @@ test_utils::marks!(\n     impl_self_type_match_without_receiver\n     match_ergonomics_ref\n     coerce_merge_fail_fallback\n+    coerce_fn_reification\n     trait_self_implements_self\n );"}, {"sha": "1fe05c70c961c02409f2ae349b07db66e2eade25", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,6 +6,7 @@ mod patterns;\n mod traits;\n mod method_resolution;\n mod macros;\n+mod display_source_code;\n \n use std::sync::Arc;\n \n@@ -16,7 +17,7 @@ use hir_def::{\n     item_scope::ItemScope,\n     keys,\n     nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use insta::assert_snapshot;\n@@ -37,6 +38,18 @@ use crate::{\n // update the snapshots.\n \n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n+}\n+\n+fn displayed_source_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, module_id| ty.display_source_code(db, module_id).unwrap())\n+}\n+\n+fn type_at_pos_displayed(\n+    db: &TestDB,\n+    pos: FilePosition,\n+    display_fn: impl FnOnce(&Ty, ModuleId) -> String,\n+) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n@@ -49,7 +62,7 @@ fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n         let infer = db.infer(func.into());\n         let ty = &infer[expr_id];\n-        return ty.display(db).to_string();\n+        return display_fn(ty, module);\n     }\n     panic!(\"Can't find expression\")\n }\n@@ -518,3 +531,21 @@ fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n \n     assert_snapshot!(diagnostics, @\"\");\n }\n+\n+#[test]\n+fn break_outside_of_loop() {\n+    let diagnostics = TestDB::with_files(\n+        r\"\n+        //- /lib.rs\n+        fn foo() {\n+            break;\n+        }\n+        \",\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"break\": break outside of loop\n+    \"###\n+    );\n+}"}, {"sha": "6dc4b2cd1d24f31f826ed00fff1c164f6e35c6dc", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -384,7 +384,7 @@ fn foo() -> u32 {\n }\n \"#, true),\n         @r###\"\n-    17..40 '{     ...own; }': !\n+    17..40 '{     ...own; }': u32\n     23..37 'return unknown': !\n     30..37 'unknown': u32\n     \"###\n@@ -514,7 +514,7 @@ fn foo() {\n     27..103 '{     ...     }': &u32\n     37..82 'if tru...     }': ()\n     40..44 'true': bool\n-    45..82 '{     ...     }': !\n+    45..82 '{     ...     }': ()\n     59..71 'return &1u32': !\n     66..71 '&1u32': &u32\n     67..71 '1u32': u32\n@@ -545,6 +545,48 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_fn_items_in_match_arms() {\n+    covers!(coerce_fn_reification);\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+        2 => foo2,\n+        _ => foo3,\n+    };\n+}\n+\"#, true),\n+        @r###\"\n+    9..10 'x': u32\n+    26..31 '{ 1 }': isize\n+    28..29 '1': isize\n+    40..41 'x': u32\n+    57..62 '{ 2 }': isize\n+    59..60 '2': isize\n+    71..72 'x': u32\n+    88..93 '{ 3 }': isize\n+    90..91 '3': isize\n+    104..193 '{     ...  }; }': ()\n+    114..115 'x': fn(u32) -> isize\n+    118..190 'match ...     }': fn(u32) -> isize\n+    124..125 '1': i32\n+    136..137 '1': i32\n+    136..137 '1': i32\n+    141..145 'foo1': fn foo1(u32) -> isize\n+    155..156 '2': i32\n+    155..156 '2': i32\n+    160..164 'foo2': fn foo2(u32) -> isize\n+    174..175 '_': i32\n+    179..183 'foo3': fn foo3(u32) -> isize\n+    \"###\n+    );\n+}\n+\n #[test]\n fn coerce_closure_to_fn_ptr() {\n     assert_snapshot!("}, {"sha": "ca17486152e2be017b9baa498cdc5c6dc8c3965a", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -0,0 +1,23 @@\n+use super::displayed_source_at_pos;\n+use crate::test_db::TestDB;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn qualify_path_to_submodule() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+\n+mod foo {\n+    pub struct Foo;\n+}\n+\n+fn bar() {\n+    let foo: foo::Foo = foo::Foo;\n+    foo<|>\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"foo::Foo\", displayed_source_at_pos(&db, pos));\n+}"}, {"sha": "4c6099aa230dc2c9ce49b8fc7b22b0f656f00822", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -197,7 +197,7 @@ fn spam() {\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n-    54..457 '{     ...!(); }': !\n+    54..457 '{     ...!(); }': ()\n     88..109 'spam!(...am!())': {unknown}\n     115..134 'for _ ...!() {}': ()\n     119..120 '_': {unknown}"}, {"sha": "67f964ab5d7ac5a32b72eace4bff90be286ff039", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -17,19 +17,20 @@ impl<T> [T] {\n #[lang = \"slice_alloc\"]\n impl<T> [T] {}\n \n-fn test() {\n-    <[_]>::foo(b\"foo\");\n+fn test(x: &[u8]) {\n+    <[_]>::foo(x);\n }\n \"#),\n         @r###\"\n     45..49 'self': &[T]\n     56..79 '{     ...     }': T\n     66..73 'loop {}': !\n     71..73 '{}': ()\n-    133..160 '{     ...o\"); }': ()\n-    139..149 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n-    139..157 '<[_]>:...\"foo\")': u8\n-    150..156 'b\"foo\"': &[u8]\n+    131..132 'x': &[u8]\n+    141..163 '{     ...(x); }': ()\n+    147..157 '<[_]>::foo': fn foo<u8>(&[u8]) -> u8\n+    147..160 '<[_]>::foo(x)': u8\n+    158..159 'x': &[u8]\n     \"###\n     );\n }"}, {"sha": "082c472088488f0db3c29a17e777c617457abe65", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 176, "deletions": 1, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,4 +1,6 @@\n-use super::type_at;\n+use insta::assert_snapshot;\n+\n+use super::{infer_with_mismatches, type_at};\n \n #[test]\n fn infer_never1() {\n@@ -261,3 +263,176 @@ fn test(a: i32) {\n     );\n     assert_eq!(t, \"f64\");\n }\n+\n+#[test]\n+fn diverging_expression_1() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    let x: u32 = return;\n+}\n+fn test2() {\n+    let x: u32 = { return; };\n+}\n+fn test3() {\n+    let x: u32 = loop {};\n+}\n+fn test4() {\n+    let x: u32 = { loop {} };\n+}\n+fn test5() {\n+    let x: u32 = { if true { loop {}; } else { loop {}; } };\n+}\n+fn test6() {\n+    let x: u32 = { let y: u32 = { loop {}; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..53 '{     ...urn; }': ()\n+    35..36 'x': u32\n+    44..50 'return': !\n+    65..98 '{     ...; }; }': ()\n+    75..76 'x': u32\n+    84..95 '{ return; }': u32\n+    86..92 'return': !\n+    110..139 '{     ... {}; }': ()\n+    120..121 'x': u32\n+    129..136 'loop {}': !\n+    134..136 '{}': ()\n+    151..184 '{     ...} }; }': ()\n+    161..162 'x': u32\n+    170..181 '{ loop {} }': u32\n+    172..179 'loop {}': !\n+    177..179 '{}': ()\n+    196..260 '{     ...} }; }': ()\n+    206..207 'x': u32\n+    215..257 '{ if t...}; } }': u32\n+    217..255 'if tru... {}; }': u32\n+    220..224 'true': bool\n+    225..237 '{ loop {}; }': u32\n+    227..234 'loop {}': !\n+    232..234 '{}': ()\n+    243..255 '{ loop {}; }': u32\n+    245..252 'loop {}': !\n+    250..252 '{}': ()\n+    272..324 '{     ...; }; }': ()\n+    282..283 'x': u32\n+    291..321 '{ let ...; }; }': u32\n+    297..298 'y': u32\n+    306..318 '{ loop {}; }': u32\n+    308..315 'loop {}': !\n+    313..315 '{}': ()\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_2() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop {}; \"foo\" };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..98 '{     ...\" }; }': ()\n+    68..69 'x': u32\n+    77..95 '{ loop...foo\" }': &str\n+    79..86 'loop {}': !\n+    84..86 '{}': ()\n+    88..93 '\"foo\"': &str\n+    77..95: expected u32, got &str\n+    88..93: expected u32, got &str\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_3_break() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop { break; } };\n+}\n+fn test2() {\n+    // should give type mismatch\n+    let x: u32 = { for a in b { break; }; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b { return; }; };\n+}\n+fn test3() {\n+    // should give type mismatch\n+    let x: u32 = { while true { break; }; };\n+    // should give type mismatch as well -- there's an implicit break, even if it's never hit\n+    let x: u32 = { while true {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { while true { return; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..99 '{     ...} }; }': ()\n+    68..69 'x': u32\n+    77..96 '{ loop...k; } }': ()\n+    79..94 'loop { break; }': ()\n+    84..94 '{ break; }': ()\n+    86..91 'break': !\n+    77..96: expected u32, got ()\n+    79..94: expected u32, got ()\n+    111..357 '{     ...; }; }': ()\n+    154..155 'x': u32\n+    163..189 '{ for ...; }; }': ()\n+    165..186 'for a ...eak; }': ()\n+    169..170 'a': {unknown}\n+    174..175 'b': {unknown}\n+    176..186 '{ break; }': ()\n+    178..183 'break': !\n+    240..241 'x': u32\n+    249..267 '{ for ... {}; }': ()\n+    251..264 'for a in b {}': ()\n+    255..256 'a': {unknown}\n+    260..261 'b': {unknown}\n+    262..264 '{}': ()\n+    318..319 'x': u32\n+    327..354 '{ for ...; }; }': ()\n+    329..351 'for a ...urn; }': ()\n+    333..334 'a': {unknown}\n+    338..339 'b': {unknown}\n+    340..351 '{ return; }': ()\n+    342..348 'return': !\n+    163..189: expected u32, got ()\n+    249..267: expected u32, got ()\n+    327..354: expected u32, got ()\n+    369..668 '{     ...; }; }': ()\n+    412..413 'x': u32\n+    421..447 '{ whil...; }; }': ()\n+    423..444 'while ...eak; }': ()\n+    429..433 'true': bool\n+    434..444 '{ break; }': ()\n+    436..441 'break': !\n+    551..552 'x': u32\n+    560..578 '{ whil... {}; }': ()\n+    562..575 'while true {}': ()\n+    568..572 'true': bool\n+    573..575 '{}': ()\n+    629..630 'x': u32\n+    638..665 '{ whil...; }; }': ()\n+    640..662 'while ...urn; }': ()\n+    646..650 'true': bool\n+    651..662 '{ return; }': ()\n+    653..659 'return': !\n+    421..447: expected u32, got ()\n+    560..578: expected u32, got ()\n+    638..665: expected u32, got ()\n+    \"###);\n+}"}, {"sha": "3820175f6c20a009c9b1a6558fb2c314a885a67a", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -179,7 +179,7 @@ fn test(a: u32, b: isize, c: !, d: &str) {\n     17..18 'b': isize\n     27..28 'c': !\n     33..34 'd': &str\n-    42..121 '{     ...f32; }': !\n+    42..121 '{     ...f32; }': ()\n     48..49 'a': u32\n     55..56 'b': isize\n     62..63 'c': !\n@@ -414,15 +414,15 @@ fn test() {\n     27..31 '5f32': f32\n     37..41 '5f64': f64\n     47..54 '\"hello\"': &str\n-    60..68 'b\"bytes\"': &[u8]\n+    60..68 'b\"bytes\"': &[u8; _]\n     74..77 ''c'': char\n     83..87 'b'b'': u8\n     93..97 '3.14': f64\n     103..107 '5000': i32\n     113..118 'false': bool\n     124..128 'true': bool\n     134..202 'r#\"   ...    \"#': &str\n-    208..218 'br#\"yolo\"#': &[u8]\n+    208..218 'br#\"yolo\"#': &[u8; _]\n     \"###\n     );\n }\n@@ -935,7 +935,7 @@ fn foo() {\n     29..33 'true': bool\n     34..51 '{     ...     }': i32\n     44..45 '1': i32\n-    57..80 '{     ...     }': !\n+    57..80 '{     ...     }': i32\n     67..73 'return': !\n     90..93 '_x2': i32\n     96..149 'if tru...     }': i32\n@@ -951,7 +951,7 @@ fn foo() {\n     186..190 'true': bool\n     194..195 '3': i32\n     205..206 '_': bool\n-    210..241 '{     ...     }': !\n+    210..241 '{     ...     }': i32\n     224..230 'return': !\n     257..260 '_x4': i32\n     263..320 'match ...     }': i32\n@@ -1687,7 +1687,7 @@ fn foo() -> u32 {\n     17..59 '{     ...; }; }': ()\n     27..28 'x': || -> usize\n     31..56 '|| -> ...n 1; }': || -> usize\n-    43..56 '{ return 1; }': !\n+    43..56 '{ return 1; }': usize\n     45..53 'return 1': !\n     52..53 '1': usize\n     \"###\n@@ -1706,7 +1706,7 @@ fn foo() -> u32 {\n     17..48 '{     ...; }; }': ()\n     27..28 'x': || -> ()\n     31..45 '|| { return; }': || -> ()\n-    34..45 '{ return; }': !\n+    34..45 '{ return; }': ()\n     36..42 'return': !\n     \"###\n     );"}, {"sha": "9572debd822c7983342845a3e7ba763fb92f611c", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,5 +1,7 @@\n //! FIXME: write short doc here\n \n+// FIXME: this modules relies on strings and AST way too much, and it should be\n+// rewritten (matklad 2020-05-07)\n use std::{\n     convert::From,\n     fmt::{self, Display},\n@@ -82,8 +84,8 @@ impl FunctionSignature {\n             let ty = field.signature_ty(db);\n             let raw_param = format!(\"{}\", ty.display(db));\n \n-            if let Some(param_type) = raw_param.split(':').nth(1) {\n-                parameter_types.push(param_type[1..].to_string());\n+            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                parameter_types.push(param_type.to_string());\n             } else {\n                 // useful when you have tuple struct\n                 parameter_types.push(raw_param.clone());\n@@ -127,8 +129,8 @@ impl FunctionSignature {\n         for field in variant.fields(db).into_iter() {\n             let ty = field.signature_ty(db);\n             let raw_param = format!(\"{}\", ty.display(db));\n-            if let Some(param_type) = raw_param.split(':').nth(1) {\n-                parameter_types.push(param_type[1..].to_string());\n+            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                parameter_types.push(param_type.to_string());\n             } else {\n                 // The unwrap_or_else is useful when you have tuple\n                 parameter_types.push(raw_param);\n@@ -195,14 +197,23 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                     let raw_param = self_param.syntax().text().to_string();\n \n                     res_types.push(\n-                        raw_param.split(':').nth(1).unwrap_or_else(|| \" Self\")[1..].to_string(),\n+                        raw_param\n+                            .split(':')\n+                            .nth(1)\n+                            .and_then(|it| it.get(1..))\n+                            .unwrap_or_else(|| \"Self\")\n+                            .to_string(),\n                     );\n                     res.push(raw_param);\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n                 res_types.extend(param_list.params().map(|param| {\n-                    param.syntax().text().to_string().split(':').nth(1).unwrap()[1..].to_string()\n+                    let param_text = param.syntax().text().to_string();\n+                    match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {\n+                        Some(it) => it.to_string(),\n+                        None => param_text,\n+                    }\n                 }));\n             }\n             (has_self_param, res, res_types)"}, {"sha": "915199bd878ac07e5565036657f9b3c1cfea8e07", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -472,12 +472,12 @@ impl Analysis {\n     /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<Assist>> {\n         self.with_db(|db| {\n-            ra_assists::resolved_assists(db, frange)\n+            ra_assists::Assist::resolved(db, frange)\n                 .into_iter()\n                 .map(|assist| Assist {\n-                    id: assist.label.id,\n-                    label: assist.label.label,\n-                    group_label: assist.label.group.map(|it| it.0),\n+                    id: assist.assist.id,\n+                    label: assist.assist.label,\n+                    group_label: assist.assist.group.map(|it| it.0),\n                     source_change: assist.source_change,\n                 })\n                 .collect()"}, {"sha": "2cbb82c1a494b5362b21ef8b7bc757925715bda5", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -712,6 +712,68 @@ mod tests {\n         \"###);\n     }\n \n+    #[test]\n+    fn test_enum_variant_from_module_1() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Bar<|>,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Bar => {}\n+        }\n+    }\n+    \"#,\n+            \"Baz\",\n+            r#\"\n+    mod foo {\n+        pub enum Foo {\n+            Baz,\n+        }\n+    }\n+\n+    fn func(f: foo::Foo) {\n+        match f {\n+            foo::Foo::Baz => {}\n+        }\n+    }\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_enum_variant_from_module_2() {\n+        test_rename(\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub bar<|>: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.bar;\n+    }\n+    \"#,\n+            \"baz\",\n+            r#\"\n+    mod foo {\n+        pub struct Foo {\n+            pub baz: uint,\n+        }\n+    }\n+\n+    fn foo(f: foo::Foo) {\n+        let _ = f.baz;\n+    }\n+    \"#,\n+        );\n+    }\n+\n     fn test_rename(text: &str, new_name: &str, expected: &str) {\n         let (analysis, position) = single_file_with_position(text);\n         let source_change = analysis.rename(position, new_name).unwrap();"}, {"sha": "f990e3bb97da08482d556e252a41276445cc5417", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -6,7 +6,7 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n+    Adt, Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n     Semantics, TypeParam, Visibility,\n };\n use ra_prof::profile;\n@@ -47,7 +47,13 @@ impl Definition {\n         match self {\n             Definition::Macro(_) => None,\n             Definition::Field(sf) => Some(sf.visibility(db)),\n-            Definition::ModuleDef(def) => module?.visibility_of(db, def),\n+            Definition::ModuleDef(def) => match def {\n+                ModuleDef::EnumVariant(id) => {\n+                    let parent = id.parent_enum(db);\n+                    module?.visibility_of(db, &ModuleDef::Adt(Adt::Enum(parent)))\n+                }\n+                _ => module?.visibility_of(db, def),\n+            },\n             Definition::SelfType(_) => None,\n             Definition::Local(_) => None,\n             Definition::TypeParam(_) => None,"}, {"sha": "a32a5daabde3ee180ce7c1e065e577b03b188013", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -14,8 +14,9 @@ rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.9.1\"\n \n ra_arena = { path = \"../ra_arena\" }\n-ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_toolchain = { path = \"../ra_toolchain\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n \n serde = { version = \"1.0.106\", features = [\"derive\"] }"}, {"sha": "082af4f9699d06b5ec86c9d50d9a191b0d25d7fe", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,7 +1,6 @@\n //! FIXME: write short doc here\n \n use std::{\n-    env,\n     ffi::OsStr,\n     ops,\n     path::{Path, PathBuf},\n@@ -87,6 +86,7 @@ pub struct PackageData {\n     pub dependencies: Vec<PackageDependency>,\n     pub edition: Edition,\n     pub features: Vec<String>,\n+    pub cfgs: Vec<String>,\n     pub out_dir: Option<PathBuf>,\n     pub proc_macro_dylib_path: Option<PathBuf>,\n }\n@@ -145,12 +145,8 @@ impl CargoWorkspace {\n         cargo_toml: &Path,\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n-        let _ = Command::new(cargo_binary())\n-            .arg(\"--version\")\n-            .output()\n-            .context(\"failed to run `cargo --version`, is `cargo` in PATH?\")?;\n-\n         let mut meta = MetadataCommand::new();\n+        meta.cargo_path(ra_toolchain::cargo());\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -172,10 +168,12 @@ impl CargoWorkspace {\n         })?;\n \n         let mut out_dir_by_id = FxHashMap::default();\n+        let mut cfgs = FxHashMap::default();\n         let mut proc_macro_dylib_paths = FxHashMap::default();\n         if cargo_features.load_out_dirs_from_check {\n             let resources = load_extern_resources(cargo_toml, cargo_features)?;\n             out_dir_by_id = resources.out_dirs;\n+            cfgs = resources.cfgs;\n             proc_macro_dylib_paths = resources.proc_dylib_paths;\n         }\n \n@@ -201,6 +199,7 @@ impl CargoWorkspace {\n                 edition,\n                 dependencies: Vec::new(),\n                 features: Vec::new(),\n+                cfgs: cfgs.get(&id).cloned().unwrap_or_default(),\n                 out_dir: out_dir_by_id.get(&id).cloned(),\n                 proc_macro_dylib_path: proc_macro_dylib_paths.get(&id).cloned(),\n             });\n@@ -282,13 +281,14 @@ impl CargoWorkspace {\n pub struct ExternResources {\n     out_dirs: FxHashMap<PackageId, PathBuf>,\n     proc_dylib_paths: FxHashMap<PackageId, PathBuf>,\n+    cfgs: FxHashMap<PackageId, Vec<String>>,\n }\n \n pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(cargo_binary());\n+    let mut cmd = Command::new(ra_toolchain::cargo());\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");\n@@ -307,8 +307,14 @@ pub fn load_extern_resources(\n     for message in cargo_metadata::parse_messages(output.stdout.as_slice()) {\n         if let Ok(message) = message {\n             match message {\n-                Message::BuildScriptExecuted(BuildScript { package_id, out_dir, .. }) => {\n-                    res.out_dirs.insert(package_id, out_dir);\n+                Message::BuildScriptExecuted(BuildScript { package_id, out_dir, cfgs, .. }) => {\n+                    res.out_dirs.insert(package_id.clone(), out_dir);\n+                    res.cfgs.insert(\n+                        package_id,\n+                        // FIXME: Current `cargo_metadata` uses `PathBuf` instead of `String`,\n+                        // change when https://github.com/oli-obk/cargo_metadata/pulls/112 reaches crates.io\n+                        cfgs.iter().filter_map(|c| c.to_str().map(|s| s.to_owned())).collect(),\n+                    );\n                 }\n \n                 Message::CompilerArtifact(message) => {\n@@ -336,7 +342,3 @@ fn is_dylib(path: &Path) -> bool {\n         Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n     }\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "4f098b706b66db3e52b9e30ddd569517ff5eb853", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -8,7 +8,7 @@ use std::{\n     fs::{read_dir, File, ReadDir},\n     io::{self, BufReader},\n     path::{Path, PathBuf},\n-    process::Command,\n+    process::{Command, Output},\n };\n \n use anyhow::{bail, Context, Result};\n@@ -88,46 +88,28 @@ impl ProjectRoot {\n     }\n \n     pub fn discover(path: &Path) -> io::Result<Vec<ProjectRoot>> {\n-        if let Some(project_json) = find_rust_project_json(path) {\n+        if let Some(project_json) = find_in_parent_dirs(path, \"rust-project.json\") {\n             return Ok(vec![ProjectRoot::ProjectJson(project_json)]);\n         }\n         return find_cargo_toml(path)\n             .map(|paths| paths.into_iter().map(ProjectRoot::CargoToml).collect());\n \n-        fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n-            if path.ends_with(\"rust-project.json\") {\n-                return Some(path.to_path_buf());\n-            }\n-\n-            let mut curr = Some(path);\n-            while let Some(path) = curr {\n-                let candidate = path.join(\"rust-project.json\");\n-                if candidate.exists() {\n-                    return Some(candidate);\n-                }\n-                curr = path.parent();\n-            }\n-\n-            None\n-        }\n-\n         fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n-            if path.ends_with(\"Cargo.toml\") {\n-                return Ok(vec![path.to_path_buf()]);\n+            match find_in_parent_dirs(path, \"Cargo.toml\") {\n+                Some(it) => Ok(vec![it]),\n+                None => Ok(find_cargo_toml_in_child_dir(read_dir(path)?)),\n             }\n+        }\n \n-            if let Some(p) = find_cargo_toml_in_parent_dir(path) {\n-                return Ok(vec![p]);\n+        fn find_in_parent_dirs(path: &Path, target_file_name: &str) -> Option<PathBuf> {\n+            if path.ends_with(target_file_name) {\n+                return Some(path.to_owned());\n             }\n \n-            let entities = read_dir(path)?;\n-            Ok(find_cargo_toml_in_child_dir(entities))\n-        }\n-\n-        fn find_cargo_toml_in_parent_dir(path: &Path) -> Option<PathBuf> {\n             let mut curr = Some(path);\n+\n             while let Some(path) = curr {\n-                let candidate = path.join(\"Cargo.toml\");\n+                let candidate = path.join(target_file_name);\n                 if candidate.exists() {\n                     return Some(candidate);\n                 }\n@@ -139,14 +121,11 @@ impl ProjectRoot {\n \n         fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n             // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n-            let mut valid_canditates = vec![];\n-            for entity in entities.filter_map(Result::ok) {\n-                let candidate = entity.path().join(\"Cargo.toml\");\n-                if candidate.exists() {\n-                    valid_canditates.push(candidate)\n-                }\n-            }\n-            valid_canditates\n+            entities\n+                .filter_map(Result::ok)\n+                .map(|it| it.path().join(\"Cargo.toml\"))\n+                .filter(|it| it.exists())\n+                .collect()\n         }\n     }\n }\n@@ -398,7 +377,18 @@ impl ProjectWorkspace {\n                             let edition = cargo[pkg].edition;\n                             let cfg_options = {\n                                 let mut opts = default_cfg_options.clone();\n-                                opts.insert_features(cargo[pkg].features.iter().map(Into::into));\n+                                for feature in cargo[pkg].features.iter() {\n+                                    opts.insert_key_value(\"feature\".into(), feature.into());\n+                                }\n+                                for cfg in cargo[pkg].cfgs.iter() {\n+                                    match cfg.find('=') {\n+                                        Some(split) => opts.insert_key_value(\n+                                            cfg[..split].into(),\n+                                            cfg[split + 1..].trim_matches('\"').into(),\n+                                        ),\n+                                        None => opts.insert_atom(cfg.into()),\n+                                    };\n+                                }\n                                 opts\n                             };\n                             let mut env = Env::default();\n@@ -556,25 +546,18 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         }\n     }\n \n-    match (|| -> Result<String> {\n+    let rustc_cfgs = || -> Result<String> {\n         // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n-        let mut cmd = Command::new(\"rustc\");\n+        let mut cmd = Command::new(ra_toolchain::rustc());\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n             cmd.args(&[\"--target\", target.as_str()]);\n         }\n-        let output = cmd.output().context(\"Failed to get output from rustc --print cfg -O\")?;\n-        if !output.status.success() {\n-            bail!(\n-                \"rustc --print cfg -O exited with exit code ({})\",\n-                output\n-                    .status\n-                    .code()\n-                    .map_or(String::from(\"no exit code\"), |code| format!(\"{}\", code))\n-            );\n-        }\n+        let output = output(cmd)?;\n         Ok(String::from_utf8(output.stdout)?)\n-    })() {\n+    }();\n+\n+    match rustc_cfgs {\n         Ok(rustc_cfgs) => {\n             for line in rustc_cfgs.lines() {\n                 match line.find('=') {\n@@ -587,8 +570,21 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n                 }\n             }\n         }\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {}\", e),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n     }\n \n     cfg_options\n }\n+\n+fn output(mut cmd: Command) -> Result<Output> {\n+    let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n+    if !output.status.success() {\n+        match String::from_utf8(output.stderr) {\n+            Ok(stderr) if !stderr.is_empty() => {\n+                bail!(\"{:?} failed, {}\\nstderr:\\n{}\", cmd, output.status, stderr)\n+            }\n+            _ => bail!(\"{:?} failed, {}\", cmd, output.status),\n+        }\n+    }\n+    Ok(output)\n+}"}, {"sha": "a8a196e64c963f68435babe2ec8d703f9b292032", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,14 +1,16 @@\n //! FIXME: write short doc here\n \n-use anyhow::{bail, Context, Result};\n use std::{\n     env, ops,\n     path::{Path, PathBuf},\n-    process::{Command, Output},\n+    process::Command,\n };\n \n+use anyhow::{bail, Result};\n use ra_arena::{Arena, Idx};\n \n+use crate::output;\n+\n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n     crates: Arena<SysrootCrateData>,\n@@ -84,43 +86,22 @@ impl Sysroot {\n     }\n }\n \n-fn create_command_text(program: &str, args: &[&str]) -> String {\n-    format!(\"{} {}\", program, args.join(\" \"))\n-}\n-\n-fn run_command_in_cargo_dir(cargo_toml: &Path, program: &str, args: &[&str]) -> Result<Output> {\n-    let output = Command::new(program)\n-        .current_dir(cargo_toml.parent().unwrap())\n-        .args(args)\n-        .output()\n-        .context(format!(\"{} failed\", create_command_text(program, args)))?;\n-    if !output.status.success() {\n-        match output.status.code() {\n-            Some(code) => bail!(\n-                \"failed to run the command: '{}' exited with code {}\",\n-                create_command_text(program, args),\n-                code\n-            ),\n-            None => bail!(\n-                \"failed to run the command: '{}' terminated by signal\",\n-                create_command_text(program, args)\n-            ),\n-        };\n-    }\n-    Ok(output)\n-}\n-\n fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, \"rustc\", &[\"--print\", \"sysroot\"])?;\n+    let current_dir = cargo_toml.parent().unwrap();\n+    let mut rustc = Command::new(ra_toolchain::rustc());\n+    rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n+    let rustc_output = output(rustc)?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n-        run_command_in_cargo_dir(cargo_toml, \"rustup\", &[\"component\", \"add\", \"rust-src\"])?;\n+        let mut rustup = Command::new(ra_toolchain::rustup());\n+        rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n+        let _output = output(rustup)?;\n     }\n     if !src_path.exists() {\n         bail!("}, {"sha": "24a1e1d9187ca4d36986e60a1c446e5e83590719", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -453,11 +453,7 @@ impl IndentLevel {\n         IndentLevel(0)\n     }\n \n-    pub fn increase_indent<N: AstNode>(self, node: N) -> N {\n-        N::cast(self._increase_indent(node.syntax().clone())).unwrap()\n-    }\n-\n-    fn _increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n+    fn increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n         let mut rewriter = SyntaxRewriter::default();\n         node.descendants_with_tokens()\n             .filter_map(|el| el.into_token())\n@@ -478,11 +474,7 @@ impl IndentLevel {\n         rewriter.rewrite(&node)\n     }\n \n-    pub fn decrease_indent<N: AstNode>(self, node: N) -> N {\n-        N::cast(self._decrease_indent(node.syntax().clone())).unwrap()\n-    }\n-\n-    fn _decrease_indent(self, node: SyntaxNode) -> SyntaxNode {\n+    fn decrease_indent(self, node: SyntaxNode) -> SyntaxNode {\n         let mut rewriter = SyntaxRewriter::default();\n         node.descendants_with_tokens()\n             .filter_map(|el| el.into_token())\n@@ -521,7 +513,7 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n     iter::successors(Some(token), |token| token.prev_token())\n }\n \n-pub trait AstNodeEdit: AstNode + Sized {\n+pub trait AstNodeEdit: AstNode + Clone + Sized {\n     #[must_use]\n     fn insert_children(\n         &self,\n@@ -558,9 +550,17 @@ pub trait AstNodeEdit: AstNode + Sized {\n         }\n         rewriter.rewrite_ast(self)\n     }\n+    #[must_use]\n+    fn indent(&self, indent: IndentLevel) -> Self {\n+        Self::cast(indent.increase_indent(self.syntax().clone())).unwrap()\n+    }\n+    #[must_use]\n+    fn dedent(&self, indent: IndentLevel) -> Self {\n+        Self::cast(indent.decrease_indent(self.syntax().clone())).unwrap()\n+    }\n }\n \n-impl<N: AstNode> AstNodeEdit for N {}\n+impl<N: AstNode + Clone> AstNodeEdit for N {}\n \n fn single_node(element: impl Into<SyntaxElement>) -> RangeInclusive<SyntaxElement> {\n     let element = element.into();\n@@ -580,7 +580,7 @@ fn test_increase_indent() {\n     _ => (),\n }\"\n     );\n-    let indented = IndentLevel(2).increase_indent(arm_list);\n+    let indented = arm_list.indent(IndentLevel(2));\n     assert_eq!(\n         indented.syntax().to_string(),\n         \"{"}, {"sha": "1873fbe16783f8d33523f6d32399137c72e89e01", "filename": "crates/ra_toolchain/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_toolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_toolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2FCargo.toml?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+home = \"0.5.3\""}, {"sha": "3c307a0eace45e4be22bdb2b2eb8de6a91f2695c", "filename": "crates/ra_toolchain/src/lib.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -0,0 +1,64 @@\n+//! This crate contains a single public function\n+//! [`get_path_for_executable`](fn.get_path_for_executable.html).\n+//! See docs there for more information.\n+use std::{env, iter, path::PathBuf};\n+\n+pub fn cargo() -> PathBuf {\n+    get_path_for_executable(\"cargo\")\n+}\n+\n+pub fn rustc() -> PathBuf {\n+    get_path_for_executable(\"rustc\")\n+}\n+\n+pub fn rustup() -> PathBuf {\n+    get_path_for_executable(\"rustup\")\n+}\n+\n+/// Return a `PathBuf` to use for the given executable.\n+///\n+/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n+/// gives a valid Cargo executable; or it may return a full path to a valid\n+/// Cargo.\n+fn get_path_for_executable(executable_name: &'static str) -> PathBuf {\n+    // The current implementation checks three places for an executable to use:\n+    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n+    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n+    // 2) `<executable_name>`\n+    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` is on the $PATH\n+    // 3) `~/.cargo/bin/<executable_name>`\n+    //      example: for cargo, this tries ~/.cargo/bin/cargo\n+    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n+    let env_var = executable_name.to_ascii_uppercase();\n+    if let Some(path) = env::var_os(&env_var) {\n+        return path.into();\n+    }\n+\n+    if lookup_in_path(executable_name) {\n+        return executable_name.into();\n+    }\n+\n+    if let Some(mut path) = home::home_dir() {\n+        path.push(\".cargo\");\n+        path.push(\"bin\");\n+        path.push(executable_name);\n+        if path.is_file() {\n+            return path;\n+        }\n+    }\n+    executable_name.into()\n+}\n+\n+fn lookup_in_path(exec: &str) -> bool {\n+    let paths = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut candidates = env::split_paths(&paths).flat_map(|path| {\n+        let candidate = path.join(&exec);\n+        let with_exe = if env::consts::EXE_EXTENSION == \"\" {\n+            None\n+        } else {\n+            Some(candidate.with_extension(env::consts::EXE_EXTENSION))\n+        };\n+        iter::once(candidate).chain(with_exe)\n+    });\n+    candidates.any(|it| it.is_file())\n+}"}, {"sha": "17b0b95b9dbc8de7db7486161dd28a67a3c3fbd8", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -96,23 +96,21 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     let mut world_state = {\n         let workspaces = {\n             // FIXME: support dynamic workspace loading.\n-            let mut visited = FxHashSet::default();\n-            let project_roots = ws_roots\n+            let project_roots: FxHashSet<_> = ws_roots\n                 .iter()\n                 .filter_map(|it| ra_project_model::ProjectRoot::discover(it).ok())\n                 .flatten()\n-                .filter(|it| visited.insert(it.clone()))\n-                .collect::<Vec<_>>();\n+                .collect();\n \n             if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n-                        req::MessageType::Error,\n-                        format!(\n-                            \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n-                            ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n-                        ),\n-                        &connection.sender,\n-                    );\n+                    req::MessageType::Error,\n+                    format!(\n+                        \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n+                        ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n+                    ),\n+                    &connection.sender,\n+                );\n             };\n \n             project_roots"}, {"sha": "f4353af64703d1f7154714a4397156677729d4f4", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -42,6 +42,7 @@ use crate::{\n     world::WorldSnapshot,\n     LspError, Result,\n };\n+use ra_project_model::TargetKind;\n \n pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n@@ -384,16 +385,27 @@ pub fn handle_runnables(\n     let offset = params.position.map(|it| it.conv_with(&line_index));\n     let mut res = Vec::new();\n     let workspace_root = world.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n     for runnable in world.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.range.contains_inclusive(offset) {\n                 continue;\n             }\n         }\n+        // Do not suggest binary run on other target than binary\n+        if let RunnableKind::Bin = runnable.kind {\n+            if let Some(spec) = &cargo_spec {\n+                match spec.target_kind {\n+                    TargetKind::Bin => {}\n+                    _ => continue,\n+                }\n+            }\n+        }\n         res.push(to_lsp_runnable(&world, file_id, runnable)?);\n     }\n+\n     // Add `cargo check` and `cargo test` for the whole package\n-    match CargoTargetSpec::for_file(&world, file_id)? {\n+    match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n                 res.push(req::Runnable {\n@@ -831,13 +843,23 @@ pub fn handle_code_lens(\n \n     let mut lenses: Vec<CodeLens> = Default::default();\n \n+    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n     // Gather runnables\n     for runnable in world.analysis().runnables(file_id)? {\n         let title = match &runnable.kind {\n             RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => \"\u25b6\ufe0f\\u{fe0e}Run Test\",\n             RunnableKind::DocTest { .. } => \"\u25b6\ufe0f\\u{fe0e}Run Doctest\",\n             RunnableKind::Bench { .. } => \"Run Bench\",\n-            RunnableKind::Bin => \"Run\",\n+            RunnableKind::Bin => {\n+                // Do not suggest binary run on other target than binary\n+                match &cargo_spec {\n+                    Some(spec) => match spec.target_kind {\n+                        TargetKind::Bin => \"Run\",\n+                        _ => continue,\n+                    },\n+                    None => continue,\n+                }\n+            }\n         }\n         .to_string();\n         let mut r = to_lsp_runnable(&world, file_id, runnable)?;"}, {"sha": "e459e3a3cec776d1652af9d6e4651a08f6ce0f80", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -9,7 +9,8 @@ use lsp_types::{\n };\n use rust_analyzer::req::{\n     CodeActionParams, CodeActionRequest, Completion, CompletionParams, DidOpenTextDocument,\n-    Formatting, GotoDefinition, HoverRequest, OnEnter, Runnables, RunnablesParams,\n+    Formatting, GotoDefinition, GotoTypeDefinition, HoverRequest, OnEnter, Runnables,\n+    RunnablesParams,\n };\n use serde_json::json;\n use tempfile::TempDir;\n@@ -574,7 +575,7 @@ version = \\\"0.0.0\\\"\n }\n \n #[test]\n-fn resolve_include_concat_env() {\n+fn out_dirs_check() {\n     if skip_slow_tests() {\n         return;\n     }\n@@ -597,11 +598,28 @@ fn main() {\n         r#\"pub fn message() -> &'static str { \"Hello, World!\" }\"#,\n     )\n     .unwrap();\n+    println!(\"cargo:rustc-cfg=atom_cfg\");\n+    println!(\"cargo:rustc-cfg=featlike=\\\"set\\\"\");\n     println!(\"cargo:rerun-if-changed=build.rs\");\n }\n //- src/main.rs\n include!(concat!(env!(\"OUT_DIR\"), \"/hello.rs\"));\n \n+#[cfg(atom_cfg)]\n+struct A;\n+#[cfg(bad_atom_cfg)]\n+struct A;\n+#[cfg(featlike = \"set\")]\n+struct B;\n+#[cfg(featlike = \"not_set\")]\n+struct B;\n+\n+fn main() {\n+    let va = A;\n+    let vb = B;\n+    message();\n+}\n+\n fn main() { message(); }\n \"###,\n     )\n@@ -613,12 +631,98 @@ fn main() { message(); }\n     let res = server.send_request::<GotoDefinition>(GotoDefinitionParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"src/main.rs\"),\n-            Position::new(2, 15),\n+            Position::new(14, 8),\n         ),\n         work_done_progress_params: Default::default(),\n         partial_result_params: Default::default(),\n     });\n     assert!(format!(\"{}\", res).contains(\"hello.rs\"));\n+    server.request::<GotoTypeDefinition>(\n+        GotoDefinitionParams {\n+            text_document_position_params: TextDocumentPositionParams::new(\n+                server.doc_id(\"src/main.rs\"),\n+                Position::new(12, 9),\n+            ),\n+            work_done_progress_params: Default::default(),\n+            partial_result_params: Default::default(),\n+        },\n+        json!([{\n+            \"originSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 10,\n+                    \"line\": 12\n+                },\n+                \"start\": {\n+                    \"character\": 8,\n+                    \"line\": 12\n+                }\n+            },\n+            \"targetRange\": {\n+                \"end\": {\n+                    \"character\": 9,\n+                    \"line\": 3\n+                },\n+                \"start\": {\n+                    \"character\": 0,\n+                    \"line\": 2\n+                }\n+            },\n+            \"targetSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 8,\n+                    \"line\": 3\n+                },\n+                \"start\": {\n+                    \"character\": 7,\n+                    \"line\": 3\n+                }\n+            },\n+            \"targetUri\": \"file:///[..]src/main.rs\"\n+        }]),\n+    );\n+    server.request::<GotoTypeDefinition>(\n+        GotoDefinitionParams {\n+            text_document_position_params: TextDocumentPositionParams::new(\n+                server.doc_id(\"src/main.rs\"),\n+                Position::new(13, 9),\n+            ),\n+            work_done_progress_params: Default::default(),\n+            partial_result_params: Default::default(),\n+        },\n+        json!([{\n+            \"originSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 10,\n+                    \"line\": 13\n+                },\n+                \"start\": {\n+                    \"character\": 8,\n+                    \"line\":13\n+                }\n+            },\n+            \"targetRange\": {\n+                \"end\": {\n+                    \"character\": 9,\n+                    \"line\": 7\n+                },\n+                \"start\": {\n+                    \"character\": 0,\n+                    \"line\":6\n+                }\n+            },\n+            \"targetSelectionRange\": {\n+                \"end\": {\n+                    \"character\": 8,\n+                    \"line\": 7\n+                },\n+                \"start\": {\n+                    \"character\": 7,\n+                    \"line\": 7\n+                }\n+            },\n+            \"targetUri\": \"file:///[..]src/main.rs\"\n+        }]),\n+    );\n }\n \n #[test]"}, {"sha": "b1e3c328f3c5165a6a0e2ee87620c282ba02e15a", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -270,7 +270,7 @@ fn parse_fixture_checks_further_indented_metadata() {\n }\n \n #[test]\n-fn parse_fixture_can_handle_unindented_first_line() {\n+fn parse_fixture_can_handle_dedented_first_line() {\n     let fixture = \"//- /lib.rs\n                    mod foo;\n                    //- /foo.rs"}, {"sha": "c6fc13519e062b0fa9189ea663a9394acc1b6933", "filename": "editors/code/package.json", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -300,6 +300,11 @@\n                     \"default\": true,\n                     \"markdownDescription\": \"Check with all features (will be passed as `--all-features`)\"\n                 },\n+                \"rust-analyzer.inlayHints.enable\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": true,\n+                    \"description\": \"Disable all inlay hints\"\n+                },\n                 \"rust-analyzer.inlayHints.typeHints\": {\n                     \"type\": \"boolean\",\n                     \"default\": true,\n@@ -418,6 +423,16 @@\n                     \"default\": {\n                         \"/rustc/<id>\": \"${env:USERPROFILE}/.rustup/toolchains/<toolchain-id>/lib/rustlib/src/rust\"\n                     }\n+                },\n+                \"rust-analyzer.debug.openDebugPane\": {\n+                    \"description\": \"Whether to open up the Debug Pane on debugging start.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": false\n+                },\n+                \"rust-analyzer.debug.engineSettings\": {\n+                    \"type\": \"object\",\n+                    \"default\": {},\n+                    \"description\": \"Optional settings passed to the debug engine. Example:\\n{ \\\"lldb\\\": { \\\"terminal\\\":\\\"external\\\"} }\"\n                 }\n             }\n         },\n@@ -589,6 +604,9 @@\n                     \"union\": [\n                         \"entity.name.union\"\n                     ],\n+                    \"struct\": [\n+                        \"entity.name.type.struct\"\n+                    ],\n                     \"keyword.unsafe\": [\n                         \"keyword.other.unsafe\"\n                     ],"}, {"sha": "2a2c2e0e1bb8fc7ebc7824e7490221c43e188c08", "filename": "editors/code/src/cargo.ts", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fcargo.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fcargo.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcargo.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,9 @@\n import * as cp from 'child_process';\n+import * as os from 'os';\n+import * as path from 'path';\n import * as readline from 'readline';\n import { OutputChannel } from 'vscode';\n+import { isValidExecutable } from './util';\n \n interface CompilationArtifact {\n     fileName: string;\n@@ -10,17 +13,9 @@ interface CompilationArtifact {\n }\n \n export class Cargo {\n-    rootFolder: string;\n-    env?: Record<string, string>;\n-    output: OutputChannel;\n-\n-    public constructor(cargoTomlFolder: string, output: OutputChannel, env: Record<string, string> | undefined = undefined) {\n-        this.rootFolder = cargoTomlFolder;\n-        this.output = output;\n-        this.env = env;\n-    }\n+    constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n \n-    public async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n+    private async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n         const artifacts: CompilationArtifact[] = [];\n \n         try {\n@@ -37,27 +32,22 @@ export class Cargo {\n                                 isTest: message.profile.test\n                             });\n                         }\n-                    }\n-                    else if (message.reason === 'compiler-message') {\n+                    } else if (message.reason === 'compiler-message') {\n                         this.output.append(message.message.rendered);\n                     }\n                 },\n-                stderr => {\n-                    this.output.append(stderr);\n-                }\n+                stderr => this.output.append(stderr),\n             );\n-        }\n-        catch (err) {\n+        } catch (err) {\n             this.output.show(true);\n             throw new Error(`Cargo invocation has failed: ${err}`);\n         }\n \n         return artifacts;\n     }\n \n-    public async executableFromArgs(args: string[]): Promise<string> {\n-        const cargoArgs = [...args]; // to remain  args unchanged\n-        cargoArgs.push(\"--message-format=json\");\n+    async executableFromArgs(args: readonly string[]): Promise<string> {\n+        const cargoArgs = [...args, \"--message-format=json\"];\n \n         const artifacts = await this.artifactsFromArgs(cargoArgs);\n \n@@ -70,24 +60,27 @@ export class Cargo {\n         return artifacts[0].fileName;\n     }\n \n-    runCargo(\n+    private runCargo(\n         cargoArgs: string[],\n         onStdoutJson: (obj: any) => void,\n         onStderrString: (data: string) => void\n     ): Promise<number> {\n-        return new Promise<number>((resolve, reject) => {\n-            const cargo = cp.spawn('cargo', cargoArgs, {\n+        return new Promise((resolve, reject) => {\n+            let cargoPath;\n+            try {\n+                cargoPath = getCargoPathOrFail();\n+            } catch (err) {\n+                return reject(err);\n+            }\n+\n+            const cargo = cp.spawn(cargoPath, cargoArgs, {\n                 stdio: ['ignore', 'pipe', 'pipe'],\n-                cwd: this.rootFolder,\n-                env: this.env,\n+                cwd: this.rootFolder\n             });\n \n-            cargo.on('error', err => {\n-                reject(new Error(`could not launch cargo: ${err}`));\n-            });\n-            cargo.stderr.on('data', chunk => {\n-                onStderrString(chunk.toString());\n-            });\n+            cargo.on('error', err => reject(new Error(`could not launch cargo: ${err}`)));\n+\n+            cargo.stderr.on('data', chunk => onStderrString(chunk.toString()));\n \n             const rl = readline.createInterface({ input: cargo.stdout });\n             rl.on('line', line => {\n@@ -103,4 +96,28 @@ export class Cargo {\n             });\n         });\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+// Mirrors `ra_env::get_path_for_executable` implementation\n+function getCargoPathOrFail(): string {\n+    const envVar = process.env.CARGO;\n+    const executableName = \"cargo\";\n+\n+    if (envVar) {\n+        if (isValidExecutable(envVar)) return envVar;\n+\n+        throw new Error(`\\`${envVar}\\` environment variable points to something that's not a valid executable`);\n+    }\n+\n+    if (isValidExecutable(executableName)) return executableName;\n+\n+    const standardLocation = path.join(os.homedir(), '.cargo', 'bin', executableName);\n+\n+    if (isValidExecutable(standardLocation)) return standardLocation;\n+\n+    throw new Error(\n+        `Failed to find \\`${executableName}\\` executable. ` +\n+        `Make sure \\`${executableName}\\` is in \\`$PATH\\`, ` +\n+        `or set \\`${envVar}\\` to point to a valid executable.`\n+    );\n+}"}, {"sha": "ae328d2a427a96e72513dca96a136560e3998942", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -64,29 +64,20 @@ export function runSingle(ctx: Ctx): Cmd {\n     };\n }\n \n-function getLldbDebugConfig(config: ra.Runnable, sourceFileMap: Record<string, string>): vscode.DebugConfiguration {\n+function getLldbDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n     return {\n         type: \"lldb\",\n         request: \"launch\",\n         name: config.label,\n-        cargo: {\n-            args: config.args,\n-        },\n+        program: executable,\n         args: config.extraArgs,\n         cwd: config.cwd,\n-        sourceMap: sourceFileMap\n+        sourceMap: sourceFileMap,\n+        sourceLanguages: [\"rust\"]\n     };\n }\n \n-const debugOutput = vscode.window.createOutputChannel(\"Debug\");\n-\n-async function getCppvsDebugConfig(config: ra.Runnable, sourceFileMap: Record<string, string>): Promise<vscode.DebugConfiguration> {\n-    debugOutput.clear();\n-\n-    const cargo = new Cargo(config.cwd || '.', debugOutput);\n-    const executable = await cargo.executableFromArgs(config.args);\n-\n-    // if we are here, there were no compilation errors.\n+function getCppvsDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n     return {\n         type: (os.platform() === \"win32\") ? \"cppvsdbg\" : 'cppdbg',\n         request: \"launch\",\n@@ -98,36 +89,62 @@ async function getCppvsDebugConfig(config: ra.Runnable, sourceFileMap: Record<st\n     };\n }\n \n+const debugOutput = vscode.window.createOutputChannel(\"Debug\");\n+\n+async function getDebugExecutable(config: ra.Runnable): Promise<string> {\n+    const cargo = new Cargo(config.cwd || '.', debugOutput);\n+    const executable = await cargo.executableFromArgs(config.args);\n+\n+    // if we are here, there were no compilation errors.\n+    return executable;\n+}\n+\n+type DebugConfigProvider = (config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>) => vscode.DebugConfiguration;\n+\n export function debugSingle(ctx: Ctx): Cmd {\n     return async (config: ra.Runnable) => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const lldbId = \"vadimcn.vscode-lldb\";\n-        const cpptoolsId = \"ms-vscode.cpptools\";\n+        const knownEngines: Record<string, DebugConfigProvider> = {\n+            \"vadimcn.vscode-lldb\": getLldbDebugConfig,\n+            \"ms-vscode.cpptools\": getCppvsDebugConfig\n+        };\n+        const debugOptions = ctx.config.debug;\n \n-        const debugEngineId = ctx.config.debug.engine;\n         let debugEngine = null;\n-        if (debugEngineId === \"auto\") {\n-            debugEngine = vscode.extensions.getExtension(lldbId);\n-            if (!debugEngine) {\n-                debugEngine = vscode.extensions.getExtension(cpptoolsId);\n+        if (debugOptions.engine === \"auto\") {\n+            for (var engineId in knownEngines) {\n+                debugEngine = vscode.extensions.getExtension(engineId);\n+                if (debugEngine) break;\n             }\n         }\n         else {\n-            debugEngine = vscode.extensions.getExtension(debugEngineId);\n+            debugEngine = vscode.extensions.getExtension(debugOptions.engine);\n         }\n \n         if (!debugEngine) {\n-            vscode.window.showErrorMessage(`Install [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=${lldbId})`\n-                + ` or [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=${cpptoolsId}) extension for debugging.`);\n+            vscode.window.showErrorMessage(`Install [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)`\n+                + ` or [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) extension for debugging.`);\n             return;\n         }\n \n-        const debugConfig = lldbId === debugEngine.id\n-            ? getLldbDebugConfig(config, ctx.config.debug.sourceFileMap)\n-            : await getCppvsDebugConfig(config, ctx.config.debug.sourceFileMap);\n+        debugOutput.clear();\n+        if (ctx.config.debug.openUpDebugPane) {\n+            debugOutput.show(true);\n+        }\n+\n+        const executable = await getDebugExecutable(config);\n+        const debugConfig = knownEngines[debugEngine.id](config, executable, debugOptions.sourceFileMap);\n+        if (debugConfig.type in debugOptions.engineSettings) {\n+            const settingsMap = (debugOptions.engineSettings as any)[debugConfig.type];\n+            for (var key in settingsMap) {\n+                debugConfig[key] = settingsMap[key];\n+            }\n+        }\n \n+        debugOutput.appendLine(\"Launching debug configuration:\");\n+        debugOutput.appendLine(JSON.stringify(debugConfig, null, 2));\n         return vscode.debug.startDebugging(undefined, debugConfig);\n     };\n }"}, {"sha": "be2e27aeccaa9a67051e88ca5ac9be8abd054498", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -94,6 +94,7 @@ export class Config {\n \n     get inlayHints() {\n         return {\n+            enable: this.get<boolean>(\"inlayHints.enable\"),\n             typeHints: this.get<boolean>(\"inlayHints.typeHints\"),\n             parameterHints: this.get<boolean>(\"inlayHints.parameterHints\"),\n             chainingHints: this.get<boolean>(\"inlayHints.chainingHints\"),\n@@ -108,10 +109,14 @@ export class Config {\n     }\n \n     get debug() {\n+        // \"/rustc/<id>\" used by suggestions only.\n+        const { [\"/rustc/<id>\"]: _, ...sourceFileMap } = this.get<Record<string, string>>(\"debug.sourceFileMap\");\n+\n         return {\n             engine: this.get<string>(\"debug.engine\"),\n-            sourceFileMap: this.get<Record<string, string>>(\"debug.sourceFileMap\"),\n+            engineSettings: this.get<object>(\"debug.engineSettings\"),\n+            openUpDebugPane: this.get<boolean>(\"debug.openUpDebugPane\"),\n+            sourceFileMap: sourceFileMap,\n         };\n     }\n-\n }"}, {"sha": "a2b07d003788d77fd797049298c9060bef2910e7", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -10,13 +10,13 @@ export function activateInlayHints(ctx: Ctx) {\n     const maybeUpdater = {\n         updater: null as null | HintsUpdater,\n         async onConfigChange() {\n-            if (\n-                !ctx.config.inlayHints.typeHints &&\n-                !ctx.config.inlayHints.parameterHints &&\n-                !ctx.config.inlayHints.chainingHints\n-            ) {\n-                return this.dispose();\n-            }\n+            const anyEnabled = ctx.config.inlayHints.typeHints\n+                || ctx.config.inlayHints.parameterHints\n+                || ctx.config.inlayHints.chainingHints;\n+            const enabled = ctx.config.inlayHints.enable && anyEnabled;\n+\n+            if (!enabled) return this.dispose();\n+\n             await sleep(100);\n             if (this.updater) {\n                 this.updater.syncCacheAndRenderHints();"}, {"sha": "9b020d0019a3b49fb5fd18e51d51e8ef8b04fb71", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -8,10 +8,9 @@ import { activateInlayHints } from './inlay_hints';\n import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { Config, NIGHTLY_TAG } from './config';\n-import { log, assert } from './util';\n+import { log, assert, isValidExecutable } from './util';\n import { PersistentState } from './persistent_state';\n import { fetchRelease, download } from './net';\n-import { spawnSync } from 'child_process';\n import { activateTaskProvider } from './tasks';\n \n let ctx: Ctx | undefined;\n@@ -179,10 +178,7 @@ async function bootstrapServer(config: Config, state: PersistentState): Promise<\n \n     log.debug(\"Using server binary at\", path);\n \n-    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n-    log.debug(\"Checked binary availability via --version\", res);\n-    log.debug(res, \"--version output:\", res.output);\n-    if (res.status !== 0) {\n+    if (!isValidExecutable(path)) {\n         throw new Error(`Failed to execute ${path} --version`);\n     }\n "}, {"sha": "127a9e9112499ab357df4b483cb205cea40f83fe", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e80903a96564c2239489a8c630a4748bf21a3659/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=e80903a96564c2239489a8c630a4748bf21a3659", "patch": "@@ -1,6 +1,7 @@\n import * as lc from \"vscode-languageclient\";\n import * as vscode from \"vscode\";\n import { strict as nativeAssert } from \"assert\";\n+import { spawnSync } from \"child_process\";\n \n export function assert(condition: boolean, explanation: string): asserts condition {\n     try {\n@@ -82,3 +83,13 @@ export function isRustDocument(document: vscode.TextDocument): document is RustD\n export function isRustEditor(editor: vscode.TextEditor): editor is RustEditor {\n     return isRustDocument(editor.document);\n }\n+\n+export function isValidExecutable(path: string): boolean {\n+    log.debug(\"Checking availability of a binary at\", path);\n+\n+    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n+\n+    log.debug(res, \"--version output:\", res.output);\n+\n+    return res.status === 0;\n+}"}]}