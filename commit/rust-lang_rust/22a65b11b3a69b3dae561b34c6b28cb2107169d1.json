{"sha": "22a65b11b3a69b3dae561b34c6b28cb2107169d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYTY1YjExYjNhNjliM2RhZTU2MWIzNGM2YjI4Y2IyMTA3MTY5ZDE=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-01-24T13:32:47Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "Introduce TyLoweringContext", "tree": {"sha": "dd4a2174d664267fbfe93f0d737975670d3030d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd4a2174d664267fbfe93f0d737975670d3030d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22a65b11b3a69b3dae561b34c6b28cb2107169d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22a65b11b3a69b3dae561b34c6b28cb2107169d1", "html_url": "https://github.com/rust-lang/rust/commit/22a65b11b3a69b3dae561b34c6b28cb2107169d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22a65b11b3a69b3dae561b34c6b28cb2107169d1/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5397f05bfe7f3b18229a65040c6685e762b2f9a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5397f05bfe7f3b18229a65040c6685e762b2f9a3", "html_url": "https://github.com/rust-lang/rust/commit/5397f05bfe7f3b18229a65040c6685e762b2f9a3"}], "stats": {"total": 296, "additions": 144, "deletions": 152}, "files": [{"sha": "837a3ed6dd7087f12e64dc71044536194ddc3cf2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -733,7 +733,8 @@ impl Local {\n         let ty = infer[self.pat_id].clone();\n         let resolver = def.resolver(db);\n         let krate = def.module(db).krate;\n-        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ctx = hir_ty::TyLoweringContext { db, resolver: &resolver };\n+        let environment = TraitEnvironment::lower(&ctx);\n         Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n@@ -789,8 +790,9 @@ impl ImplBlock {\n     pub fn target_ty(&self, db: &impl HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n         let resolver = self.id.resolver(db);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n-        let ty = Ty::from_hir(db, &resolver, &impl_data.target_type);\n+        let ctx = hir_ty::TyLoweringContext { db, resolver: &resolver };\n+        let environment = TraitEnvironment::lower(&ctx);\n+        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n         Type {\n             krate: self.id.lookup(db).container.module(db).krate,\n             ty: InEnvironment { value: ty, environment },\n@@ -844,7 +846,8 @@ pub struct Type {\n impl Type {\n     fn new(db: &impl HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db);\n-        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ctx = hir_ty::TyLoweringContext { db, resolver: &resolver };\n+        let environment = TraitEnvironment::lower(&ctx);\n         Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n "}, {"sha": "9cfd52856a202bdcdf9ddcf731cef52fed2917ce", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -178,6 +178,11 @@ impl SourceAnalyzer {\n         }\n     }\n \n+    fn trait_env(&self, db: &impl HirDatabase) -> Arc<TraitEnvironment> {\n+        let ctx = hir_ty::TyLoweringContext { db, resolver: &self.resolver };\n+        TraitEnvironment::lower(&ctx)\n+    }\n+\n     pub fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = if let Some(expr) = self.expand_expr(db, InFile::new(self.file_id, expr)) {\n             self.body_source_map.as_ref()?.node_expr(expr.as_ref())?\n@@ -186,14 +191,14 @@ impl SourceAnalyzer {\n         };\n \n         let ty = self.infer.as_ref()?[expr_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n     pub fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n         let ty = self.infer.as_ref()?[pat_id].clone();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        let environment = self.trait_env(db);\n         Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n "}, {"sha": "e27ce6e91755d23baaff7cf886f233308eaf2c11", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -215,12 +215,13 @@ struct InferenceContext<'a, D: HirDatabase> {\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n+        let ctx = crate::lower::TyLoweringContext { db, resolver: &resolver };\n         InferenceContext {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n-            trait_env: TraitEnvironment::lower(db, &resolver),\n+            trait_env: TraitEnvironment::lower(&ctx),\n             coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             owner,\n@@ -272,12 +273,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        let ty = Ty::from_hir(\n-            self.db,\n-            // FIXME use right resolver for block\n-            &self.resolver,\n-            type_ref,\n-        );\n+        // FIXME use right resolver for block\n+        let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &self.resolver };\n+        let ty = Ty::from_hir(&ctx, type_ref);\n         let ty = self.insert_type_vars(ty);\n         self.normalize_associated_types_in(ty)\n     }\n@@ -446,17 +444,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n+        let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &self.resolver };\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n+                let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(strukt.into()))\n             }\n             Some(TypeNs::EnumVariantId(var)) => {\n-                let substs = Ty::substs_from_path(self.db, resolver, path, var.into());\n+                let substs = Ty::substs_from_path(&ctx, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(var.into()))"}, {"sha": "132f3d6f23950246110963c3ab497ef95e3c2c75", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -11,7 +11,7 @@ use hir_expand::name::Name;\n \n use crate::{db::HirDatabase, method_resolution, Substs, Ty, TypeWalk, ValueTyDefId};\n \n-use super::{ExprOrPatId, InferenceContext, TraitEnvironment, TraitRef};\n+use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n@@ -39,7 +39,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n+            let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &resolver };\n+            let ty = Ty::from_type_relative_path(&ctx, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n                 &path.segments().last().expect(\"path had at least one segment\").name,\n@@ -73,7 +74,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         if let Some(self_subst) = self_subst {\n             ty = ty.subst(&self_subst);\n         }\n-        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+        let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &self.resolver };\n+        let substs = Ty::substs_from_path(&ctx, path, typable);\n         let ty = ty.subst(&substs);\n         Some(ty)\n     }\n@@ -98,13 +100,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             (TypeNs::TraitId(trait_), true) => {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n-                let trait_ref = TraitRef::from_resolved_path(\n-                    self.db,\n-                    &self.resolver,\n-                    trait_.into(),\n-                    resolved_segment,\n-                    None,\n-                );\n+                let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &self.resolver };\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(&ctx, trait_.into(), resolved_segment, None);\n                 self.resolve_trait_assoc_item(trait_ref, segment, id)\n             }\n             (def, _) => {\n@@ -114,9 +112,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // as Iterator>::Item::default`)\n                 let remaining_segments_for_ty =\n                     remaining_segments.take(remaining_segments.len() - 1);\n+                let ctx = crate::lower::TyLoweringContext { db: self.db, resolver: &self.resolver };\n                 let ty = Ty::from_partly_resolved_hir_path(\n-                    self.db,\n-                    &self.resolver,\n+                    &ctx,\n                     def,\n                     resolved_segment,\n                     remaining_segments_for_ty,\n@@ -193,14 +191,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n \n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n-        let env = TraitEnvironment::lower(self.db, &self.resolver);\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db);\n \n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n-            env,\n+            self.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n             Some(name),"}, {"sha": "6f0e8b4817a623ebdabd227ffb0805114ee92017", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -60,7 +60,7 @@ use display::{HirDisplay, HirFormatter};\n pub use autoderef::autoderef;\n pub use infer::{do_infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n-pub use lower::{callable_item_sig, TyDefId, ValueTyDefId};\n+pub use lower::{callable_item_sig, TyDefId, TyLoweringContext, ValueTyDefId};\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n /// A type constructor or type name: this might be something like the primitive"}, {"sha": "87c984e3fe206ae71d4f2de38197d18b5c678800", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 110, "deletions": 122, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22a65b11b3a69b3dae561b34c6b28cb2107169d1/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=22a65b11b3a69b3dae561b34c6b28cb2107169d1", "patch": "@@ -31,57 +31,58 @@ use crate::{\n     Ty, TypeCtor, TypeWalk,\n };\n \n+#[derive(Clone, Debug)]\n+pub struct TyLoweringContext<'a, DB: HirDatabase> {\n+    pub db: &'a DB,\n+    pub resolver: &'a Resolver,\n+}\n+\n impl Ty {\n-    pub fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+    pub fn from_hir(ctx: &TyLoweringContext<'_, impl HirDatabase>, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n-                let inner_tys: Arc<[Ty]> =\n-                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect();\n+                let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n                 Ty::apply(\n                     TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n                     Substs(inner_tys),\n                 )\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(ctx, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Array, inner_ty)\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n-                let sig = Substs(params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect());\n+                let sig = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n+                    .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n                     .collect();\n                 Ty::Dyn(predicates)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .flat_map(|b| {\n-                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n-                    })\n+                    .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n                     .collect();\n                 Ty::Opaque(predicates)\n             }\n@@ -93,8 +94,7 @@ impl Ty {\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n     fn from_hir_only_param(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n     ) -> Option<u32> {\n         let path = match type_ref {\n@@ -107,12 +107,12 @@ impl Ty {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+        let resolution = match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n         if let TypeNs::GenericParam(param_id) = resolution {\n-            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+            let generics = generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n             let idx = generics.param_idx(param_id);\n             Some(idx)\n         } else {\n@@ -121,15 +121,14 @@ impl Ty {\n     }\n \n     pub(crate) fn from_type_relative_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         ty: Ty,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            Ty::select_associated_type(db, resolver, ty, segment)\n+            Ty::select_associated_type(ctx, ty, segment)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n             Ty::Unknown\n@@ -139,20 +138,18 @@ impl Ty {\n     }\n \n     pub(crate) fn from_partly_resolved_hir_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref =\n-                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n+                let trait_ref = TraitRef::from_resolved_path(ctx, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n-                        db,\n+                        ctx.db,\n                         trait_ref.trait_,\n                         &segment.name,\n                     );\n@@ -177,37 +174,34 @@ impl Ty {\n                 };\n             }\n             TypeNs::GenericParam(param_id) => {\n-                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+                let generics =\n+                    generics(ctx.db, ctx.resolver.generic_def().expect(\"generics in scope\"));\n                 let idx = generics.param_idx(param_id);\n                 // FIXME: maybe return name in resolution?\n                 let name = generics.param_name(param_id);\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n-            TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n+            TypeNs::SelfType(impl_id) => ctx.db.impl_self_ty(impl_id).clone(),\n+            TypeNs::AdtSelfType(adt) => ctx.db.ty(adt.into()),\n \n-            TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n-            TypeNs::BuiltinType(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n-            }\n-            TypeNs::TypeAliasId(it) => {\n-                Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into())\n-            }\n+            TypeNs::AdtId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::TypeAliasId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return Ty::Unknown,\n         };\n \n-        Ty::from_type_relative_path(db, resolver, ty, remaining_segments)\n+        Ty::from_type_relative_path(ctx, ty, remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n+    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_, impl HirDatabase>, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n-            let ty = Ty::from_hir(db, resolver, &type_ref);\n-            return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n+            let ty = Ty::from_hir(ctx, &type_ref);\n+            return Ty::from_type_relative_path(ctx, ty, path.segments());\n         }\n         let (resolution, remaining_index) =\n-            match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+            match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n                 Some(it) => it,\n                 None => return Ty::Unknown,\n             };\n@@ -218,39 +212,35 @@ impl Ty {\n             ),\n             Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n-        Ty::from_partly_resolved_hir_path(\n-            db,\n-            resolver,\n-            resolution,\n-            resolved_segment,\n-            remaining_segments,\n-        )\n+        Ty::from_partly_resolved_hir_path(ctx, resolution, resolved_segment, remaining_segments)\n     }\n \n     fn select_associated_type(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         self_ty: Ty,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n         let param_idx = match self_ty {\n             Ty::Param { idx, .. } => idx,\n             _ => return Ty::Unknown, // Error: Ambiguous associated type\n         };\n-        let def = match resolver.generic_def() {\n+        let def = match ctx.resolver.generic_def() {\n             Some(def) => def,\n             None => return Ty::Unknown, // this can't actually happen\n         };\n-        let predicates = db.generic_predicates_for_param(def.into(), param_idx);\n+        let predicates = ctx.db.generic_predicates_for_param(def.into(), param_idx);\n         let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(ctx.db, t));\n         for t in traits {\n-            if let Some(associated_ty) = db.trait_data(t).associated_type_by_name(&segment.name) {\n-                let substs =\n-                    Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n+            if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n+            {\n+                let substs = Substs::build_for_def(ctx.db, t)\n+                    .push(self_ty.clone())\n+                    .fill_with_unknown()\n+                    .build();\n                 // FIXME handle type parameters on the segment\n                 return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n@@ -259,8 +249,7 @@ impl Ty {\n     }\n \n     fn from_hir_path_inner(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n@@ -269,15 +258,14 @@ impl Ty {\n             TyDefId::AdtId(it) => Some(it.into()),\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        let substs = substs_from_path_segment(db, resolver, segment, generic_def, false);\n-        db.ty(typable).subst(&substs)\n+        let substs = substs_from_path_segment(ctx, segment, generic_def, false);\n+        ctx.db.ty(typable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     pub(super) fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         // Note that we don't call `db.value_type(resolved)` here,\n         // `ValueTyDefId` is just a convenient way to pass generics and\n@@ -305,19 +293,18 @@ impl Ty {\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        substs_from_path_segment(db, resolver, segment, generic_def, false)\n+        substs_from_path_segment(ctx, segment, generic_def, false)\n     }\n }\n \n pub(super) fn substs_from_path_segment(\n-    db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    ctx: &TyLoweringContext<'_, impl HirDatabase>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| generics(db, def.into()));\n+    let def_generics = def_generic.map(|def| generics(ctx.db, def.into()));\n \n     let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n     substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n@@ -335,7 +322,7 @@ pub(super) fn substs_from_path_segment(\n         for arg in generic_args.args.iter().take(child_len) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n-                    let ty = Ty::from_hir(db, resolver, type_ref);\n+                    let ty = Ty::from_hir(ctx, type_ref);\n                     substs.push(ty);\n                 }\n             }\n@@ -350,7 +337,7 @@ pub(super) fn substs_from_path_segment(\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n-        let default_substs = db.generic_defaults(def_generic.into());\n+        let default_substs = ctx.db.generic_defaults(def_generic.into());\n         assert_eq!(substs.len(), default_substs.len());\n \n         for (i, default_ty) in default_substs.iter().enumerate() {\n@@ -365,99 +352,91 @@ pub(super) fn substs_from_path_segment(\n \n impl TraitRef {\n     fn from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_in_type_ns_fully(db, path.mod_path())? {\n+        let resolved = match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db, path.mod_path())? {\n             TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n+        Some(TraitRef::from_resolved_path(ctx, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         resolved: TraitId,\n         segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n-        let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n+        let mut substs = TraitRef::substs_from_path(ctx, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n         TraitRef { trait_: resolved, substs }\n     }\n \n     fn from_hir(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         type_ref: &TypeRef,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        TraitRef::from_path(db, resolver, path, explicit_self_ty)\n+        TraitRef::from_path(ctx, path, explicit_self_ty)\n     }\n \n     fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n             segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n+        substs_from_path_segment(ctx, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn from_type_bound(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         bound: &TypeBound,\n         self_ty: Ty,\n     ) -> Option<TraitRef> {\n         match bound {\n-            TypeBound::Path(path) => TraitRef::from_path(db, resolver, path, Some(self_ty)),\n+            TypeBound::Path(path) => TraitRef::from_path(ctx, path, Some(self_ty)),\n             TypeBound::Error => None,\n         }\n     }\n }\n \n impl GenericPredicate {\n     pub(crate) fn from_where_predicate<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let self_ty = Ty::from_hir(db, resolver, &where_predicate.type_ref);\n-        GenericPredicate::from_type_bound(db, resolver, &where_predicate.bound, self_ty)\n+        let self_ty = Ty::from_hir(ctx, &where_predicate.type_ref);\n+        GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n     }\n \n     pub(crate) fn from_type_bound<'a>(\n-        db: &'a impl HirDatabase,\n-        resolver: &'a Resolver,\n+        ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         bound: &'a TypeBound,\n         self_ty: Ty,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let trait_ref = TraitRef::from_type_bound(db, &resolver, bound, self_ty);\n+        let trait_ref = TraitRef::from_type_bound(ctx, bound, self_ty);\n         iter::once(trait_ref.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented))\n             .chain(\n-                trait_ref.into_iter().flat_map(move |tr| {\n-                    assoc_type_bindings_from_type_bound(db, resolver, bound, tr)\n-                }),\n+                trait_ref\n+                    .into_iter()\n+                    .flat_map(move |tr| assoc_type_bindings_from_type_bound(ctx, bound, tr)),\n             )\n     }\n }\n \n fn assoc_type_bindings_from_type_bound<'a>(\n-    db: &'a impl HirDatabase,\n-    resolver: &'a Resolver,\n+    ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n     bound: &'a TypeBound,\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n@@ -471,14 +450,14 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n+                associated_type_by_name_including_super_traits(ctx.db, trait_ref.trait_, &name);\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,\n             };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n-            let ty = Ty::from_hir(db, resolver, type_ref);\n+            let ty = Ty::from_hir(ctx, type_ref);\n             let projection_predicate = ProjectionPredicate { projection_ty, ty };\n             GenericPredicate::Projection(projection_predicate)\n         })\n@@ -505,8 +484,9 @@ pub(crate) fn field_types_query(\n         VariantId::EnumVariantId(it) => it.parent.resolver(db),\n     };\n     let mut res = ArenaMap::default();\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Ty::from_hir(db, &resolver, &field_data.type_ref))\n+        res.insert(field_id, Ty::from_hir(&ctx, &field_data.type_ref))\n     }\n     Arc::new(res)\n }\n@@ -525,11 +505,12 @@ pub(crate) fn generic_predicates_for_param_query(\n     param_idx: u32,\n ) -> Arc<[GenericPredicate]> {\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n-        .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .filter(|pred| Ty::from_hir_only_param(&ctx, &pred.type_ref) == Some(param_idx))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n         .collect()\n }\n \n@@ -543,10 +524,11 @@ pub(crate) fn generic_predicates_for_param_recover(\n }\n \n impl TraitEnvironment {\n-    pub fn lower(db: &impl HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n-        let predicates = resolver\n+    pub fn lower(ctx: &TyLoweringContext<'_, impl HirDatabase>) -> Arc<TraitEnvironment> {\n+        let predicates = ctx\n+            .resolver\n             .where_predicates_in_scope()\n-            .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+            .flat_map(|pred| GenericPredicate::from_where_predicate(ctx, pred))\n             .collect::<Vec<_>>();\n \n         Arc::new(TraitEnvironment { predicates })\n@@ -559,20 +541,22 @@ pub(crate) fn generic_predicates_query(\n     def: GenericDefId,\n ) -> Arc<[GenericPredicate]> {\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n         .collect()\n }\n \n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n         .iter()\n-        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(&ctx, t)))\n         .collect();\n \n     Substs(defaults)\n@@ -581,8 +565,9 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -\n fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n     let data = db.function_data(def);\n     let resolver = def.resolver(db);\n-    let params = data.params.iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let ret = Ty::from_hir(db, &resolver, &data.ret_type);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n+    let params = data.params.iter().map(|tr| Ty::from_hir(&ctx, tr)).collect::<Vec<_>>();\n+    let ret = Ty::from_hir(&ctx, &data.ret_type);\n     FnSig::from_params_and_return(params, ret)\n }\n \n@@ -598,16 +583,18 @@ fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Ty {\n     let data = db.const_data(def);\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Ty::from_hir(&ctx, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n fn type_for_static(db: &impl HirDatabase, def: StaticId) -> Ty {\n     let data = db.static_data(def);\n     let resolver = def.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n \n-    Ty::from_hir(db, &resolver, &data.type_ref)\n+    Ty::from_hir(&ctx, &data.type_ref)\n }\n \n /// Build the declared type of a static.\n@@ -625,10 +612,9 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> FnSig\n     let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();\n     let resolver = def.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.into());\n     FnSig::from_params_and_return(params, ret)\n }\n@@ -649,10 +635,9 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n     let var_data = &enum_data.variants[def.local_id];\n     let fields = var_data.variant_data.fields();\n     let resolver = def.parent.resolver(db);\n-    let params = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n+    let params =\n+        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n@@ -679,9 +664,10 @@ fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n     let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);\n-    let inner = Ty::from_hir(db, &resolver, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+    let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n     inner.subst(&substs)\n }\n \n@@ -761,7 +747,8 @@ pub(crate) fn value_ty_query(db: &impl HirDatabase, def: ValueTyDefId) -> Ty {\n pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Ty {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n-    Ty::from_hir(db, &resolver, &impl_data.target_type)\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n+    Ty::from_hir(&ctx, &impl_data.target_type)\n }\n \n pub(crate) fn impl_self_ty_recover(\n@@ -775,7 +762,8 @@ pub(crate) fn impl_self_ty_recover(\n pub(crate) fn impl_trait_query(db: &impl HirDatabase, impl_id: ImplId) -> Option<TraitRef> {\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n+    let ctx = TyLoweringContext { db, resolver: &resolver };\n     let self_ty = db.impl_self_ty(impl_id);\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    TraitRef::from_hir(db, &resolver, target_trait, Some(self_ty.clone()))\n+    TraitRef::from_hir(&ctx, target_trait, Some(self_ty.clone()))\n }"}]}