{"sha": "3fae1b9fc35fc449186e2138bdf8ee75dac78dae", "node_id": "C_kwDOAAsO6NoAKDNmYWUxYjlmYzM1ZmM0NDkxODZlMjEzOGJkZjhlZTc1ZGFjNzhkYWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T15:07:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T15:07:33Z"}, "message": "Auto merge of #111755 - Zoxc:sharded-switch, r=cjgillot\n\nUse only one shard with a single thread\n\nThis changes `Sharded` to only access a single shard using a mask set to `0` when a single thread is used, which leads to cache utilization improvements.\n\nPerformance improvement with 1 thread and `cfg(parallel_compiler)`:\n<table><tr><td rowspan=\"2\">Benchmark</td><td colspan=\"1\"><b>Before</b></th><td colspan=\"2\"><b>After</b></th></tr><tr><td align=\"right\">Time</td><td align=\"right\">Time</td><td align=\"right\">%</th></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check</td><td align=\"right\">1.7402s</td><td align=\"right\">1.7004s</td><td align=\"right\">\ud83d\udc9a  -2.29%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check</td><td align=\"right\">0.2633s</td><td align=\"right\">0.2550s</td><td align=\"right\">\ud83d\udc9a  -3.12%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check</td><td align=\"right\">0.9716s</td><td align=\"right\">0.9482s</td><td align=\"right\">\ud83d\udc9a  -2.41%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check</td><td align=\"right\">1.5679s</td><td align=\"right\">1.5358s</td><td align=\"right\">\ud83d\udc9a  -2.05%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check</td><td align=\"right\">6.0569s</td><td align=\"right\">5.9272s</td><td align=\"right\">\ud83d\udc9a  -2.14%</td></tr><tr><td>Total</td><td align=\"right\">10.5999s</td><td align=\"right\">10.3666s</td><td align=\"right\">\ud83d\udc9a  -2.20%</td></tr><tr><td>Summary</td><td align=\"right\">1.0000s</td><td align=\"right\">0.9760s</td><td align=\"right\">\ud83d\udc9a  -2.40%</td></tr></table>\n\ncc `@SparrowLii`", "tree": {"sha": "acab84593c38bfc65b2a40497eac8772b2438da9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acab84593c38bfc65b2a40497eac8772b2438da9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fae1b9fc35fc449186e2138bdf8ee75dac78dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fae1b9fc35fc449186e2138bdf8ee75dac78dae", "html_url": "https://github.com/rust-lang/rust/commit/3fae1b9fc35fc449186e2138bdf8ee75dac78dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fae1b9fc35fc449186e2138bdf8ee75dac78dae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c03fb65268e3331f381714c664a581a6e86b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c03fb65268e3331f381714c664a581a6e86b8c", "html_url": "https://github.com/rust-lang/rust/commit/39c03fb65268e3331f381714c664a581a6e86b8c"}, {"sha": "8abafd085aab9b703711b49d02b66910c8c2d739", "url": "https://api.github.com/repos/rust-lang/rust/commits/8abafd085aab9b703711b49d02b66910c8c2d739", "html_url": "https://github.com/rust-lang/rust/commit/8abafd085aab9b703711b49d02b66910c8c2d739"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "40cbf14958e77de715935be419a6e6531b757893", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3fae1b9fc35fc449186e2138bdf8ee75dac78dae/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fae1b9fc35fc449186e2138bdf8ee75dac78dae/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=3fae1b9fc35fc449186e2138bdf8ee75dac78dae", "patch": "@@ -1,4 +1,6 @@\n use crate::fx::{FxHashMap, FxHasher};\n+#[cfg(parallel_compiler)]\n+use crate::sync::is_dyn_thread_safe;\n use crate::sync::{CacheAligned, Lock, LockGuard};\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n@@ -18,6 +20,11 @@ pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n pub struct Sharded<T> {\n+    /// This mask is used to ensure that accesses are inbounds of `shards`.\n+    /// When dynamic thread safety is off, this field is set to 0 causing only\n+    /// a single shard to be used for greater cache efficiency.\n+    #[cfg(parallel_compiler)]\n+    mask: usize,\n     shards: [CacheAligned<Lock<T>>; SHARDS],\n }\n \n@@ -31,31 +38,54 @@ impl<T: Default> Default for Sharded<T> {\n impl<T> Sharded<T> {\n     #[inline]\n     pub fn new(mut value: impl FnMut() -> T) -> Self {\n-        Sharded { shards: [(); SHARDS].map(|()| CacheAligned(Lock::new(value()))) }\n+        Sharded {\n+            #[cfg(parallel_compiler)]\n+            mask: if is_dyn_thread_safe() { SHARDS - 1 } else { 0 },\n+            shards: [(); SHARDS].map(|()| CacheAligned(Lock::new(value()))),\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn mask(&self) -> usize {\n+        #[cfg(parallel_compiler)]\n+        {\n+            if SHARDS == 1 { 0 } else { self.mask }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            0\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn count(&self) -> usize {\n+        // `self.mask` is always one below the used shard count\n+        self.mask() + 1\n     }\n \n     /// The shard is selected by hashing `val` with `FxHasher`.\n     #[inline]\n     pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n-        if SHARDS == 1 { &self.shards[0].0 } else { self.get_shard_by_hash(make_hash(val)) }\n+        self.get_shard_by_hash(if SHARDS == 1 { 0 } else { make_hash(val) })\n     }\n \n     #[inline]\n     pub fn get_shard_by_hash(&self, hash: u64) -> &Lock<T> {\n-        &self.shards[get_shard_index_by_hash(hash)].0\n+        self.get_shard_by_index(get_shard_hash(hash))\n     }\n \n     #[inline]\n     pub fn get_shard_by_index(&self, i: usize) -> &Lock<T> {\n-        &self.shards[i].0\n+        // SAFETY: The index get ANDed with the mask, ensuring it is always inbounds.\n+        unsafe { &self.shards.get_unchecked(i & self.mask()).0 }\n     }\n \n     pub fn lock_shards(&self) -> Vec<LockGuard<'_, T>> {\n-        (0..SHARDS).map(|i| self.shards[i].0.lock()).collect()\n+        (0..self.count()).map(|i| self.get_shard_by_index(i).lock()).collect()\n     }\n \n     pub fn try_lock_shards(&self) -> Option<Vec<LockGuard<'_, T>>> {\n-        (0..SHARDS).map(|i| self.shards[i].0.try_lock()).collect()\n+        (0..self.count()).map(|i| self.get_shard_by_index(i).try_lock()).collect()\n     }\n }\n \n@@ -136,11 +166,9 @@ pub fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n /// `hash` can be computed with any hasher, so long as that hasher is used\n /// consistently for each `Sharded` instance.\n #[inline]\n-#[allow(clippy::modulo_one)]\n-pub fn get_shard_index_by_hash(hash: u64) -> usize {\n+fn get_shard_hash(hash: u64) -> usize {\n     let hash_len = mem::size_of::<usize>();\n     // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits.\n     // hashbrown also uses the lowest bits, so we can't use those\n-    let bits = (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize;\n-    bits % SHARDS\n+    (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize\n }"}]}