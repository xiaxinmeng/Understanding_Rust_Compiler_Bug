{"sha": "d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZWU1NmU4NjIwNzFjM2NlYTRjNWZiN2NmMTI0NDQ1OTFlMGIzZjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-12T01:06:24Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "typeck: Turn everything operating on FnCtxt into a method.", "tree": {"sha": "ceb62935ab793fb42b30ea382b5ebb6d4926a188", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceb62935ab793fb42b30ea382b5ebb6d4926a188"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "html_url": "https://github.com/rust-lang/rust/commit/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42", "html_url": "https://github.com/rust-lang/rust/commit/ef2f5f6d8ef51010d060d6f8cff6cac2ef83fd42"}], "stats": {"total": 3979, "additions": 1914, "deletions": 2065}, "files": [{"sha": "8634c8cf9bd095ce22a83727a495dd76f8fa7509", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -154,7 +154,7 @@ impl<'tcx> Callee<'tcx> {\n         let method_item = tcx.impl_or_trait_item(def_id);\n         let trait_id = method_item.container().id();\n         let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-        let trait_ref = infer::normalize_associated_type(tcx, &trait_ref);\n+        let trait_ref = tcx.normalize_associated_type(&trait_ref);\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;"}, {"sha": "8e9138cf7795a8308f2188fea57618c063343db3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 194, "deletions": 197, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -14,50 +14,68 @@ use hir::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use hir::pat_util::pat_is_resolved_const;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n-use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n-use check::{demand, FnCtxt, Expectation};\n-use check::{check_expr_with_lvalue_pref};\n-use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n-use check::coercion;\n+use check::{FnCtxt, Expectation};\n use lint;\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use session::Session;\n \n use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                           pat: &'tcx hir::Pat,\n-                           expected: Ty<'tcx>)\n-{\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n+pub struct PatCtxt<'a, 'tcx: 'a> {\n+    pub fcx: &'a FnCtxt<'a, 'tcx>,\n+    pub map: PatIdMap,\n+}\n+\n+impl<'a, 'tcx> Deref for PatCtxt<'a, 'tcx> {\n+    type Target = FnCtxt<'a, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        self.fcx\n+    }\n+}\n+\n+// This function exists due to the warning \"diagnostic code E0164 already used\"\n+fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n+    let name = pprust::path_to_string(path);\n+    let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\", name);\n+    if lint {\n+        sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                      pat.id,\n+                      pat.span,\n+                      msg);\n+    } else {\n+        span_err!(sess, pat.span, E0164, \"{}\", msg);\n+    }\n+}\n \n-    debug!(\"check_pat(pat={:?},expected={:?})\",\n-           pat,\n-           expected);\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n+    let tcx = self.tcx();\n+\n+    debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n \n     match pat.node {\n         PatKind::Wild => {\n-            fcx.write_ty(pat.id, expected);\n+            self.write_ty(pat.id, expected);\n         }\n         PatKind::Lit(ref lt) => {\n-            check_expr(fcx, &lt);\n-            let expr_ty = fcx.expr_ty(&lt);\n+            self.check_expr(&lt);\n+            let expr_ty = self.expr_ty(&lt);\n \n             // Byte string patterns behave the same way as array patterns\n             // They can denote both statically and dynamically sized byte arrays\n             let mut pat_ty = expr_ty;\n             if let hir::ExprLit(ref lt) = lt.node {\n                 if let ast::LitKind::ByteStr(_) = lt.node {\n-                    let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n+                    let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {\n                             pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n@@ -67,7 +85,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             }\n \n-            fcx.write_ty(pat.id, pat_ty);\n+            self.write_ty(pat.id, pat_ty);\n \n             // somewhat surprising: in this case, the subtyping\n             // relation goes the opposite way as the other\n@@ -81,14 +99,14 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             //     &'static str <: expected\n             //\n             // that's equivalent to there existing a LUB.\n-            demand::suptype(fcx, pat.span, expected, pat_ty);\n+            self.demand_suptype(pat.span, expected, pat_ty);\n         }\n         PatKind::Range(ref begin, ref end) => {\n-            check_expr(fcx, begin);\n-            check_expr(fcx, end);\n+            self.check_expr(begin);\n+            self.check_expr(end);\n \n-            let lhs_ty = fcx.expr_ty(begin);\n-            let rhs_ty = fcx.expr_ty(end);\n+            let lhs_ty = self.expr_ty(begin);\n+            let rhs_ty = self.expr_ty(end);\n \n             // Check that both end-points are of numeric or char type.\n             let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n@@ -108,15 +126,15 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 span_err!(tcx.sess, span, E0029,\n                           \"only char and numeric types are allowed in range patterns\\n \\\n                            start type: {}\\n end type: {}\",\n-                          fcx.infcx().ty_to_string(lhs_ty),\n-                          fcx.infcx().ty_to_string(rhs_ty)\n+                          self.infcx().ty_to_string(lhs_ty),\n+                          self.infcx().ty_to_string(rhs_ty)\n                 );\n                 return;\n             }\n \n             // Check that the types of the end-points can be unified.\n             let types_unify = require_same_types(\n-                fcx.ccx, Some(fcx.infcx()), pat.span, rhs_ty, lhs_ty,\n+                self.ccx, Some(self.infcx()), pat.span, rhs_ty, lhs_ty,\n                 \"mismatched types in range\",\n             );\n \n@@ -127,154 +145,153 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // Now that we know the types can be unified we find the unified type and use\n             // it to type the entire expression.\n-            let common_type = fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+            let common_type = self.infcx().resolve_type_vars_if_possible(&lhs_ty);\n \n-            fcx.write_ty(pat.id, common_type);\n+            self.write_ty(pat.id, common_type);\n \n             // subtyping doesn't matter here, as the value is some kind of scalar\n-            demand::eqtype(fcx, pat.span, expected, lhs_ty);\n+            self.demand_eqtype(pat.span, expected, lhs_ty);\n         }\n         PatKind::Path(..) | PatKind::Ident(..)\n                 if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n             if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n                 let const_did = pat_def.def_id();\n                 let const_scheme = tcx.lookup_item_type(const_did);\n                 assert!(const_scheme.generics.is_empty());\n-                let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n-                                                               &Substs::empty(),\n-                                                               &const_scheme.ty);\n-                fcx.write_ty(pat.id, const_ty);\n+                let const_ty = self.instantiate_type_scheme(pat.span,\n+                                                            &Substs::empty(),\n+                                                            &const_scheme.ty);\n+                self.write_ty(pat.id, const_ty);\n \n                 // FIXME(#20489) -- we should limit the types here to scalars or something!\n \n                 // As with PatKind::Lit, what we really want here is that there\n                 // exist a LUB, but for the cases that can occur, subtype\n                 // is good enough.\n-                demand::suptype(fcx, pat.span, expected, const_ty);\n+                self.demand_suptype(pat.span, expected, const_ty);\n             } else {\n-                fcx.write_error(pat.id);\n+                self.write_error(pat.id);\n             }\n         }\n         PatKind::Ident(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n-            let typ = fcx.local_ty(pat.span, pat.id);\n+            let typ = self.local_ty(pat.span, pat.id);\n             match bm {\n                 hir::BindByRef(mutbl) => {\n                     // if the binding is like\n                     //    ref x | ref const x | ref mut x\n                     // then `x` is assigned a value of type `&M T` where M is the mutability\n                     // and T is the expected type.\n-                    let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    let region_var = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n                     let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n \n                     // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                     // required. However, we use equality, which is stronger. See (*) for\n                     // an explanation.\n-                    demand::eqtype(fcx, pat.span, region_ty, typ);\n+                    self.demand_eqtype(pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n                 hir::BindByValue(_) => {\n                     // As above, `T <: typeof(x)` is required but we\n                     // use equality, see (*) below.\n-                    demand::eqtype(fcx, pat.span, expected, typ);\n+                    self.demand_eqtype(pat.span, expected, typ);\n                 }\n             }\n \n-            fcx.write_ty(pat.id, typ);\n+            self.write_ty(pat.id, typ);\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            if let Some(&canon_id) = pcx.map.get(&path.node.name) {\n+            if let Some(&canon_id) = self.map.get(&path.node.name) {\n                 if canon_id != pat.id {\n-                    let ct = fcx.local_ty(pat.span, canon_id);\n-                    demand::eqtype(fcx, pat.span, ct, typ);\n+                    let ct = self.local_ty(pat.span, canon_id);\n+                    self.demand_eqtype(pat.span, ct, typ);\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    check_pat(pcx, &p, expected);\n+                    self.check_pat(&p, expected);\n                 }\n             }\n         }\n         PatKind::Ident(_, ref path, _) => {\n             let path = hir::Path::from_ident(path.span, path.node);\n-            check_pat_enum(pcx, pat, &path, Some(&[]), expected, false);\n+            self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n         }\n         PatKind::TupleStruct(ref path, ref subpats) => {\n-            check_pat_enum(pcx, pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+            self.check_pat_enum(pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n         }\n         PatKind::Path(ref path) => {\n-            check_pat_enum(pcx, pat, path, Some(&[]), expected, false);\n+            self.check_pat_enum(pat, path, Some(&[]), expected, false);\n         }\n         PatKind::QPath(ref qself, ref path) => {\n-            let self_ty = fcx.to_ty(&qself.ty);\n+            let self_ty = self.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n-                    fcx.infcx().set_tainted_by_errors();\n-                    fcx.write_error(pat.id);\n+                    self.infcx().set_tainted_by_errors();\n+                    self.write_error(pat.id);\n                     return;\n                 }\n                 d\n             } else if qself.position == 0 {\n                 // This is just a sentinel for finish_resolving_def_to_ty.\n-                let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n+                let sentinel = self.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n                     base_def: Def::Mod(sentinel),\n                     depth: path.segments.len()\n                 }\n             } else {\n                 debug!(\"unbound path {:?}\", pat);\n-                fcx.write_error(pat.id);\n+                self.write_error(pat.id);\n                 return;\n             };\n             if let Some((opt_ty, segments, def)) =\n-                    resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n-                                            path, pat.span, pat.id) {\n-                if check_assoc_item_is_const(pcx, def, pat.span) {\n+                    self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n+                                                 path, pat.span, pat.id) {\n+                if self.check_assoc_item_is_const(def, pat.span) {\n                     let scheme = tcx.lookup_item_type(def.def_id());\n                     let predicates = tcx.lookup_predicates(def.def_id());\n-                    instantiate_path(fcx, segments,\n-                                     scheme, &predicates,\n-                                     opt_ty, def, pat.span, pat.id);\n-                    let const_ty = fcx.node_ty(pat.id);\n-                    demand::suptype(fcx, pat.span, expected, const_ty);\n+                    self.instantiate_path(segments, scheme, &predicates,\n+                                          opt_ty, def, pat.span, pat.id);\n+                    let const_ty = self.node_ty(pat.id);\n+                    self.demand_suptype(pat.span, expected, const_ty);\n                 } else {\n-                    fcx.write_error(pat.id)\n+                    self.write_error(pat.id)\n                 }\n             }\n         }\n         PatKind::Struct(ref path, ref fields, etc) => {\n-            check_pat_struct(pcx, pat, path, fields, etc, expected);\n+            self.check_pat_struct(pat, path, fields, etc, expected);\n         }\n         PatKind::Tup(ref elements) => {\n             let element_tys: Vec<_> =\n-                (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n+                (0..elements.len()).map(|_| self.infcx().next_ty_var())\n                                         .collect();\n             let pat_ty = tcx.mk_tup(element_tys.clone());\n-            fcx.write_ty(pat.id, pat_ty);\n-            demand::eqtype(fcx, pat.span, expected, pat_ty);\n+            self.write_ty(pat.id, pat_ty);\n+            self.demand_eqtype(pat.span, expected, pat_ty);\n             for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                check_pat(pcx, &element_pat, element_ty);\n+                self.check_pat(&element_pat, element_ty);\n             }\n         }\n         PatKind::Box(ref inner) => {\n-            let inner_ty = fcx.infcx().next_ty_var();\n+            let inner_ty = self.infcx().next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n-            if check_dereferencable(pcx, pat.span, expected, &inner) {\n+            if self.check_dereferencable(pat.span, expected, &inner) {\n                 // Here, `demand::subtype` is good enough, but I don't\n                 // think any errors can be introduced by using\n                 // `demand::eqtype`.\n-                demand::eqtype(fcx, pat.span, expected, uniq_ty);\n-                fcx.write_ty(pat.id, uniq_ty);\n-                check_pat(pcx, &inner, inner_ty);\n+                self.demand_eqtype(pat.span, expected, uniq_ty);\n+                self.write_ty(pat.id, uniq_ty);\n+                self.check_pat(&inner, inner_ty);\n             } else {\n-                fcx.write_error(pat.id);\n-                check_pat(pcx, &inner, tcx.types.err);\n+                self.write_error(pat.id);\n+                self.check_pat(&inner, tcx.types.err);\n             }\n         }\n         PatKind::Ref(ref inner, mutbl) => {\n-            let expected = fcx.infcx().shallow_resolve(expected);\n-            if check_dereferencable(pcx, pat.span, expected, &inner) {\n+            let expected = self.infcx().shallow_resolve(expected);\n+            if self.check_dereferencable(pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n                 // `eqtype` turns out to be equally general. See (*)\n                 // below for details.\n@@ -288,25 +305,25 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                         (expected, mt.ty)\n                     }\n                     _ => {\n-                        let inner_ty = fcx.infcx().next_ty_var();\n+                        let inner_ty = self.infcx().next_ty_var();\n                         let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                        let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                        let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n                         let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n-                        demand::eqtype(fcx, pat.span, expected, rptr_ty);\n+                        self.demand_eqtype(pat.span, expected, rptr_ty);\n                         (rptr_ty, inner_ty)\n                     }\n                 };\n \n-                fcx.write_ty(pat.id, rptr_ty);\n-                check_pat(pcx, &inner, inner_ty);\n+                self.write_ty(pat.id, rptr_ty);\n+                self.check_pat(&inner, inner_ty);\n             } else {\n-                fcx.write_error(pat.id);\n-                check_pat(pcx, &inner, tcx.types.err);\n+                self.write_error(pat.id);\n+                self.check_pat(&inner, tcx.types.err);\n             }\n         }\n         PatKind::Vec(ref before, ref slice, ref after) => {\n-            let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n-            let inner_ty = fcx.infcx().next_ty_var();\n+            let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+            let inner_ty = self.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {\n                 ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n                     let min_len = before.len() + after.len();\n@@ -316,7 +333,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     }\n                 }),\n                 _ => {\n-                    let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n                         ty: tcx.mk_slice(inner_ty),\n                         mutbl: expected_ty.builtin_deref(true, ty::NoPreference).map(|mt| mt.mutbl)\n@@ -325,29 +342,29 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             };\n \n-            fcx.write_ty(pat.id, pat_ty);\n+            self.write_ty(pat.id, pat_ty);\n \n             // `demand::subtype` would be good enough, but using\n             // `eqtype` turns out to be equally general. See (*)\n             // below for details.\n-            demand::eqtype(fcx, pat.span, expected, pat_ty);\n+            self.demand_eqtype(pat.span, expected, pat_ty);\n \n             for elt in before {\n-                check_pat(pcx, &elt, inner_ty);\n+                self.check_pat(&elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n-                let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n                 let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n                     .map_or(hir::MutImmutable, |mt| mt.mutbl);\n \n                 let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n                     ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n-                check_pat(pcx, &slice, slice_ty);\n+                self.check_pat(&slice, slice_ty);\n             }\n             for elt in after {\n-                check_pat(pcx, &elt, inner_ty);\n+                self.check_pat(&elt, inner_ty);\n             }\n         }\n     }\n@@ -404,11 +421,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // subtyping.\n }\n \n-fn check_assoc_item_is_const(pcx: &pat_ctxt, def: Def, span: Span) -> bool {\n+fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n     match def {\n         Def::AssociatedConst(..) => true,\n         Def::Method(..) => {\n-            span_err!(pcx.fcx.ccx.tcx.sess, span, E0327,\n+            span_err!(self.tcx().sess, span, E0327,\n                       \"associated items in match patterns must be constants\");\n             false\n         }\n@@ -418,20 +435,17 @@ fn check_assoc_item_is_const(pcx: &pat_ctxt, def: Def, span: Span) -> bool {\n     }\n }\n \n-pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                                      span: Span, expected: Ty<'tcx>,\n-                                      inner: &hir::Pat) -> bool {\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n+pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n+    let tcx = self.tcx();\n     if pat_is_binding(&tcx.def_map.borrow(), inner) {\n-        let expected = fcx.infcx().shallow_resolve(expected);\n+        let expected = self.infcx().shallow_resolve(expected);\n         expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n             ty::TyTrait(_) => {\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                 span_err!(tcx.sess, span, E0033,\n                           \"type `{}` cannot be dereferenced\",\n-                          fcx.infcx().ty_to_string(expected));\n+                          self.infcx().ty_to_string(expected));\n                 false\n             }\n             _ => true\n@@ -440,14 +454,16 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         true\n     }\n }\n+}\n \n-pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                             expr: &'tcx hir::Expr,\n-                             discrim: &'tcx hir::Expr,\n-                             arms: &'tcx [hir::Arm],\n-                             expected: Expectation<'tcx>,\n-                             match_src: hir::MatchSource) {\n-    let tcx = fcx.ccx.tcx;\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn check_match(&self,\n+                   expr: &'tcx hir::Expr,\n+                   discrim: &'tcx hir::Expr,\n+                   arms: &'tcx [hir::Arm],\n+                   expected: Expectation<'tcx>,\n+                   match_src: hir::MatchSource) {\n+    let tcx = self.tcx();\n \n     // Not entirely obvious: if matches may create ref bindings, we\n     // want to use the *precise* type of the discriminant, *not* some\n@@ -460,25 +476,25 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     });\n     let discrim_ty;\n     if let Some(m) = contains_ref_bindings {\n-        check_expr_with_lvalue_pref(fcx, discrim, LvaluePreference::from_mutbl(m));\n-        discrim_ty = fcx.expr_ty(discrim);\n+        self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n+        discrim_ty = self.expr_ty(discrim);\n     } else {\n         // ...but otherwise we want to use any supertype of the\n         // discriminant. This is sort of a workaround, see note (*) in\n         // `check_pat` for some details.\n-        discrim_ty = fcx.infcx().next_ty_var();\n-        check_expr_has_type(fcx, discrim, discrim_ty);\n+        discrim_ty = self.infcx().next_ty_var();\n+        self.check_expr_has_type(discrim, discrim_ty);\n     };\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n     for arm in arms {\n-        let mut pcx = pat_ctxt {\n-            fcx: fcx,\n+        let pcx = PatCtxt {\n+            fcx: self,\n             map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n         };\n         for p in &arm.pats {\n-            check_pat(&mut pcx, &p, discrim_ty);\n+            pcx.check_pat(&p, discrim_ty);\n         }\n     }\n \n@@ -491,25 +507,25 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // on any empty type and is therefore unreachable; should the flow\n     // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n-    let expected = expected.adjust_for_branches(fcx);\n-    let mut result_ty = fcx.infcx().next_diverging_ty_var();\n+    let expected = expected.adjust_for_branches(self);\n+    let mut result_ty = self.infcx().next_diverging_ty_var();\n     let coerce_first = match expected {\n         // We don't coerce to `()` so that if the match expression is a\n         // statement it's branches can have any consistent type. That allows\n         // us to give better error messages (pointing to a usually better\n         // arm for inconsistent arms or to the whole match when a `()` type\n         // is required).\n-        Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n+        Expectation::ExpectHasType(ety) if ety != self.tcx().mk_nil() => {\n             ety\n         }\n         _ => result_ty\n     };\n     for (i, arm) in arms.iter().enumerate() {\n         if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, e, tcx.types.bool);\n+            self.check_expr_has_type(e, tcx.types.bool);\n         }\n-        check_expr_with_expectation(fcx, &arm.body, expected);\n-        let arm_ty = fcx.expr_ty(&arm.body);\n+        self.check_expr_with_expectation(&arm.body, expected);\n+        let arm_ty = self.expr_ty(&arm.body);\n \n         if result_ty.references_error() || arm_ty.references_error() {\n             result_ty = tcx.types.err;\n@@ -531,18 +547,18 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         let result = if is_if_let_fallback {\n-            fcx.infcx().eq_types(true, origin, arm_ty, result_ty)\n+            self.infcx().eq_types(true, origin, arm_ty, result_ty)\n                 .map(|InferOk { obligations, .. }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n                     arm_ty\n                 })\n         } else if i == 0 {\n             // Special-case the first arm, as it has no \"previous expressions\".\n-            coercion::try(fcx, &arm.body, coerce_first)\n+            self.try_coerce(&arm.body, coerce_first)\n         } else {\n             let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-            coercion::try_find_lub(fcx, origin, prev_arms, result_ty, &arm.body)\n+            self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body)\n         };\n \n         result_ty = match result {\n@@ -553,98 +569,79 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else {\n                     (result_ty, arm_ty)\n                 };\n-                fcx.infcx().report_mismatched_types(origin, expected, found, e);\n-                fcx.tcx().types.err\n+                self.infcx().report_mismatched_types(origin, expected, found, e);\n+                self.tcx().types.err\n             }\n         };\n     }\n \n-    fcx.write_ty(expr.id, result_ty);\n+    self.write_ty(expr.id, result_ty);\n }\n-\n-pub struct pat_ctxt<'a, 'tcx: 'a> {\n-    pub fcx: &'a FnCtxt<'a, 'tcx>,\n-    pub map: PatIdMap,\n }\n \n-pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx hir::Pat,\n-                                  path: &hir::Path, fields: &'tcx [Spanned<hir::FieldPat>],\n-                                  etc: bool, expected: Ty<'tcx>) {\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n+                        path: &hir::Path, fields: &'tcx [Spanned<hir::FieldPat>],\n+                        etc: bool, expected: Ty<'tcx>) {\n+    let tcx = self.tcx();\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let variant = match fcx.def_struct_variant(def, path.span) {\n+    let variant = match self.def_struct_variant(def, path.span) {\n         Some((_, variant)) => variant,\n         None => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0163,\n                       \"`{}` does not name a struct or a struct variant\", name);\n-            fcx.write_error(pat.id);\n+            self.write_error(pat.id);\n \n             for field in fields {\n-                check_pat(pcx, &field.node.pat, tcx.types.err);\n+                self.check_pat(&field.node.pat, tcx.types.err);\n             }\n             return;\n         }\n     };\n \n-    let pat_ty = pcx.fcx.instantiate_type(def.def_id(), path);\n+    let pat_ty = self.instantiate_type(def.def_id(), path);\n     let item_substs = match pat_ty.sty {\n         ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n         _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n     };\n-    demand::eqtype(fcx, pat.span, expected, pat_ty);\n-    check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);\n+    self.demand_eqtype(pat.span, expected, pat_ty);\n+    self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n \n-    fcx.write_ty(pat.id, pat_ty);\n-    fcx.write_substs(pat.id, ty::ItemSubsts { substs: item_substs.clone() });\n-}\n-\n-// This function exists due to the warning \"diagnostic code E0164 already used\"\n-fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n-    let name = pprust::path_to_string(path);\n-    let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\", name);\n-    if lint {\n-        sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                      pat.id,\n-                      pat.span,\n-                      msg);\n-    } else {\n-        span_err!(sess, pat.span, E0164, \"{}\", msg);\n-    }\n+    self.write_ty(pat.id, pat_ty);\n+    self.write_substs(pat.id, ty::ItemSubsts { substs: item_substs.clone() });\n }\n \n-fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                            pat: &hir::Pat,\n-                            path: &hir::Path,\n-                            subpats: Option<&'tcx [P<hir::Pat>]>,\n-                            expected: Ty<'tcx>,\n-                            is_tuple_struct_pat: bool)\n+fn check_pat_enum(&self,\n+                  pat: &hir::Pat,\n+                  path: &hir::Path,\n+                  subpats: Option<&'tcx [P<hir::Pat>]>,\n+                  expected: Ty<'tcx>,\n+                  is_tuple_struct_pat: bool)\n {\n     // Typecheck the path.\n-    let fcx = pcx.fcx;\n-    let tcx = pcx.fcx.ccx.tcx;\n+    let tcx = self.tcx();\n \n     let path_res = match tcx.def_map.borrow().get(&pat.id) {\n         Some(&path_res) if path_res.base_def != Def::Err => path_res,\n         _ => {\n-            fcx.infcx().set_tainted_by_errors();\n-            fcx.write_error(pat.id);\n+            self.infcx().set_tainted_by_errors();\n+            self.write_error(pat.id);\n \n             if let Some(subpats) = subpats {\n                 for pat in subpats {\n-                    check_pat(pcx, &pat, tcx.types.err);\n+                    self.check_pat(&pat, tcx.types.err);\n                 }\n             }\n \n             return;\n         }\n     };\n \n-    let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n-                                                                None, path,\n-                                                                pat.span, pat.id) {\n+    let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n+                                                                     None, path,\n+                                                                     pat.span, pat.id) {\n         Some(resolution) => resolution,\n         // Error handling done inside resolve_ty_and_def_ufcs, so if\n         // resolution fails just return.\n@@ -653,8 +650,8 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     // Items that were partially resolved before should have been resolved to\n     // associated constants (i.e. not methods).\n-    if path_res.depth != 0 && !check_assoc_item_is_const(pcx, def, pat.span) {\n-        fcx.write_error(pat.id);\n+    if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n+        self.write_error(pat.id);\n         return;\n     }\n \n@@ -672,17 +669,16 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, segments,\n-                     path_scheme, &ctor_predicates,\n-                     opt_ty, def, pat.span, pat.id);\n+    self.instantiate_path(segments, path_scheme, &ctor_predicates,\n+                          opt_ty, def, pat.span, pat.id);\n \n     let report_bad_struct_kind = |is_warning| {\n         bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n         if is_warning { return; }\n-        fcx.write_error(pat.id);\n+        self.write_error(pat.id);\n         if let Some(subpats) = subpats {\n             for pat in subpats {\n-                check_pat(pcx, &pat, tcx.types.err);\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         }\n     };\n@@ -694,16 +690,16 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         if is_tuple_struct_pat {\n             report_bad_struct_kind(false);\n         } else {\n-            let pat_ty = fcx.node_ty(pat.id);\n-            demand::suptype(fcx, pat.span, expected, pat_ty);\n+            let pat_ty = self.node_ty(pat.id);\n+            self.demand_suptype(pat.span, expected, pat_ty);\n         }\n         return;\n     }\n \n-    let pat_ty = fcx.node_ty(pat.id);\n-    demand::eqtype(fcx, pat.span, expected, pat_ty);\n+    let pat_ty = self.node_ty(pat.id);\n+    self.demand_eqtype(pat.span, expected, pat_ty);\n \n-    let real_path_ty = fcx.node_ty(pat.id);\n+    let real_path_ty = self.node_ty(pat.id);\n     let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n         ty::TyEnum(enum_def, expected_substs) => {\n             let variant = enum_def.variant_of_def(def);\n@@ -735,16 +731,16 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     if let Some(subpats) = subpats {\n         if subpats.len() == variant.fields.len() {\n             for (subpat, field) in subpats.iter().zip(&variant.fields) {\n-                let field_ty = fcx.field_ty(subpat.span, field, expected_substs);\n-                check_pat(pcx, &subpat, field_ty);\n+                let field_ty = self.field_ty(subpat.span, field, expected_substs);\n+                self.check_pat(&subpat, field_ty);\n             }\n         } else if variant.fields.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n             for pat in subpats {\n-                check_pat(pcx, &pat, tcx.types.err);\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n@@ -754,7 +750,7 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n \n             for pat in subpats {\n-                check_pat(pcx, &pat, tcx.types.err);\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         }\n     }\n@@ -765,13 +761,13 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n /// `struct_fields` describes the type of each field of the struct.\n /// `struct_id` is the ID of the struct.\n /// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                                         span: Span,\n-                                         fields: &'tcx [Spanned<hir::FieldPat>],\n-                                         variant: ty::VariantDef<'tcx>,\n-                                         substs: &Substs<'tcx>,\n-                                         etc: bool) {\n-    let tcx = pcx.fcx.ccx.tcx;\n+pub fn check_struct_pat_fields(&self,\n+                               span: Span,\n+                               fields: &'tcx [Spanned<hir::FieldPat>],\n+                               variant: ty::VariantDef<'tcx>,\n+                               substs: &Substs<'tcx>,\n+                               etc: bool) {\n+    let tcx = self.tcx();\n \n     // Index the struct fields' types.\n     let field_map = variant.fields\n@@ -798,7 +794,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             Vacant(vacant) => {\n                 vacant.insert(span);\n                 field_map.get(&field.name)\n-                    .map(|f| pcx.fcx.field_ty(span, f, substs))\n+                    .map(|f| self.field_ty(span, f, substs))\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n@@ -809,7 +805,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n         };\n \n-        check_pat(pcx, &field.pat, field_ty);\n+        self.check_pat(&field.pat, field_ty);\n     }\n \n     // Report an error if not all the fields were specified.\n@@ -823,3 +819,4 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n     }\n }\n+}"}, {"sha": "15307864a427c4d7f807d80cc7eba86cfa67fbd3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 130, "deletions": 149, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -8,21 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::autoderef;\n-use super::check_argument_types;\n-use super::check_expr;\n-use super::check_method_argument_types;\n-use super::demand;\n-use super::DeferredCallResolution;\n-use super::err_args;\n-use super::Expectation;\n-use super::expected_types_for_fn_args;\n-use super::FnCtxt;\n-use super::method;\n-use super::structurally_resolved_type;\n-use super::TupleArgumentsFlag;\n-use super::UnresolvedTypeAction;\n-use super::write_call;\n+use super::{DeferredCallResolution, Expectation, FnCtxt,\n+            TupleArgumentsFlag, UnresolvedTypeAction};\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n@@ -70,68 +57,68 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n     }\n }\n \n-pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            call_expr: &'tcx hir::Expr,\n-                            callee_expr: &'tcx hir::Expr,\n-                            arg_exprs: &'tcx [P<hir::Expr>],\n-                            expected: Expectation<'tcx>)\n+enum CallStep<'tcx> {\n+    Builtin,\n+    DeferredClosure(ty::FnSig<'tcx>),\n+    Overloaded(ty::MethodCallee<'tcx>)\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn check_call(&self,\n+                  call_expr: &'tcx hir::Expr,\n+                  callee_expr: &'tcx hir::Expr,\n+                  arg_exprs: &'tcx [P<hir::Expr>],\n+                  expected: Expectation<'tcx>)\n {\n-    check_expr(fcx, callee_expr);\n-    let original_callee_ty = fcx.expr_ty(callee_expr);\n+    self.check_expr(callee_expr);\n+    let original_callee_ty = self.expr_ty(callee_expr);\n     let (callee_ty, _, result) =\n-        autoderef(fcx,\n-                  callee_expr.span,\n-                  original_callee_ty,\n-                  || Some(callee_expr),\n-                  UnresolvedTypeAction::Error,\n-                  LvaluePreference::NoPreference,\n-                  |adj_ty, idx| {\n-                      try_overloaded_call_step(fcx, call_expr, callee_expr, adj_ty, idx)\n-                  });\n+        self.autoderef(callee_expr.span,\n+                       original_callee_ty,\n+                       || Some(callee_expr),\n+                       UnresolvedTypeAction::Error,\n+                       LvaluePreference::NoPreference,\n+                       |adj_ty, idx| {\n+            self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n+    });\n \n     match result {\n         None => {\n             // this will report an error since original_callee_ty is not a fn\n-            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs, expected);\n+            self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::Builtin) => {\n-            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs, expected);\n+            self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::DeferredClosure(fn_sig)) => {\n-            confirm_deferred_closure_call(fcx, call_expr, arg_exprs, expected, fn_sig);\n+            self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig);\n         }\n \n         Some(CallStep::Overloaded(method_callee)) => {\n-            confirm_overloaded_call(fcx, call_expr, callee_expr,\n-                                    arg_exprs, expected, method_callee);\n+            self.confirm_overloaded_call(call_expr, callee_expr,\n+                                         arg_exprs, expected, method_callee);\n         }\n     }\n }\n \n-enum CallStep<'tcx> {\n-    Builtin,\n-    DeferredClosure(ty::FnSig<'tcx>),\n-    Overloaded(ty::MethodCallee<'tcx>)\n-}\n-\n-fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                      call_expr: &'tcx hir::Expr,\n-                                      callee_expr: &'tcx hir::Expr,\n-                                      adjusted_ty: Ty<'tcx>,\n-                                      autoderefs: usize)\n-                                      -> Option<CallStep<'tcx>>\n+fn try_overloaded_call_step(&self,\n+                            call_expr: &'tcx hir::Expr,\n+                            callee_expr: &'tcx hir::Expr,\n+                            adjusted_ty: Ty<'tcx>,\n+                            autoderefs: usize)\n+                            -> Option<CallStep<'tcx>>\n {\n     debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n            call_expr,\n            adjusted_ty,\n            autoderefs);\n \n     // If the callee is a bare function or a closure, then we're all set.\n-    match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n+    match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            fcx.write_autoderef_adjustment(callee_expr.id, autoderefs);\n+            self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n             return Some(CallStep::Builtin);\n         }\n \n@@ -141,14 +128,14 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // Check whether this is a call to a closure where we\n             // haven't yet decided on whether the closure is fn vs\n             // fnmut vs fnonce. If so, we have to defer further processing.\n-            if fcx.infcx().closure_kind(def_id).is_none() {\n+            if self.infcx().closure_kind(def_id).is_none() {\n                 let closure_ty =\n-                    fcx.infcx().closure_type(def_id, substs);\n+                    self.infcx().closure_type(def_id, substs);\n                 let fn_sig =\n-                    fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                          infer::FnCall,\n-                                                                          &closure_ty.sig).0;\n-                fcx.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n+                    self.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                           infer::FnCall,\n+                                                                           &closure_ty.sig).0;\n+                self.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n                     call_expr: call_expr,\n                     callee_expr: callee_expr,\n                     adjusted_ty: adjusted_ty,\n@@ -175,37 +162,36 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         _ => {}\n     }\n \n-    try_overloaded_call_traits(fcx, call_expr, callee_expr, adjusted_ty, autoderefs)\n+    self.try_overloaded_call_traits(call_expr, callee_expr, adjusted_ty, autoderefs)\n         .map(|method_callee| CallStep::Overloaded(method_callee))\n }\n \n-fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                       call_expr: &hir::Expr,\n-                                       callee_expr: &hir::Expr,\n-                                       adjusted_ty: Ty<'tcx>,\n-                                       autoderefs: usize)\n-                                       -> Option<ty::MethodCallee<'tcx>>\n+fn try_overloaded_call_traits(&self,\n+                              call_expr: &hir::Expr,\n+                              callee_expr: &hir::Expr,\n+                              adjusted_ty: Ty<'tcx>,\n+                              autoderefs: usize)\n+                              -> Option<ty::MethodCallee<'tcx>>\n {\n     // Try the options that are least restrictive on the caller first.\n     for &(opt_trait_def_id, method_name) in &[\n-        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n-        (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+        (self.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n+        (self.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+        (self.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n     ] {\n         let trait_def_id = match opt_trait_def_id {\n             Some(def_id) => def_id,\n             None => continue,\n         };\n \n-        match method::lookup_in_trait_adjusted(fcx,\n-                                               call_expr.span,\n-                                               Some(&callee_expr),\n-                                               method_name,\n-                                               trait_def_id,\n-                                               autoderefs,\n-                                               false,\n-                                               adjusted_ty,\n-                                               None) {\n+        match self.lookup_method_in_trait_adjusted(call_expr.span,\n+                                                   Some(&callee_expr),\n+                                                   method_name,\n+                                                   trait_def_id,\n+                                                   autoderefs,\n+                                                   false,\n+                                                   adjusted_ty,\n+                                                   None) {\n             None => continue,\n             Some(method_callee) => {\n                 return Some(method_callee);\n@@ -216,11 +202,11 @@ fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     None\n }\n \n-fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                 call_expr: &hir::Expr,\n-                                 callee_ty: Ty<'tcx>,\n-                                 arg_exprs: &'tcx [P<hir::Expr>],\n-                                 expected: Expectation<'tcx>)\n+fn confirm_builtin_call(&self,\n+                        call_expr: &hir::Expr,\n+                        callee_ty: Ty<'tcx>,\n+                        arg_exprs: &'tcx [P<hir::Expr>],\n+                        expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n \n@@ -230,12 +216,12 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             sig\n         }\n         _ => {\n-            let mut err = fcx.type_error_struct(call_expr.span, |actual| {\n+            let mut err = self.type_error_struct(call_expr.span, |actual| {\n                 format!(\"expected function, found `{}`\", actual)\n             }, callee_ty, None);\n \n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                let tcx = fcx.tcx();\n+                let tcx = self.tcx();\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                     if pr.depth == 0 && pr.base_def != Def::Err {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n@@ -251,8 +237,8 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             // In that case, we check each argument against \"error\" in order to\n             // set up all the node type bindings.\n             error_fn_sig = ty::Binder(ty::FnSig {\n-                inputs: err_args(fcx, arg_exprs.len()),\n-                output: ty::FnConverging(fcx.tcx().types.err),\n+                inputs: self.err_args(arg_exprs.len()),\n+                output: ty::FnConverging(self.tcx().types.err),\n                 variadic: false\n             });\n \n@@ -266,83 +252,79 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // previously appeared within a `Binder<>` and hence would not\n     // have been normalized before.\n     let fn_sig =\n-        fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                              infer::FnCall,\n-                                                              fn_sig).0;\n+        self.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                               infer::FnCall,\n+                                                               fn_sig).0;\n     let fn_sig =\n-        fcx.normalize_associated_types_in(call_expr.span, &fn_sig);\n+        self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n     // Call the generic checker.\n-    let expected_arg_tys = expected_types_for_fn_args(fcx,\n-                                                      call_expr.span,\n-                                                      expected,\n-                                                      fn_sig.output,\n-                                                      &fn_sig.inputs);\n-    check_argument_types(fcx,\n-                         call_expr.span,\n-                         &fn_sig.inputs,\n-                         &expected_arg_tys[..],\n-                         arg_exprs,\n-                         fn_sig.variadic,\n-                         TupleArgumentsFlag::DontTupleArguments);\n-\n-    write_call(fcx, call_expr, fn_sig.output);\n+    let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n+                                                           expected,\n+                                                           fn_sig.output,\n+                                                           &fn_sig.inputs);\n+    self.check_argument_types(call_expr.span,\n+                              &fn_sig.inputs,\n+                              &expected_arg_tys[..],\n+                              arg_exprs,\n+                              fn_sig.variadic,\n+                              TupleArgumentsFlag::DontTupleArguments);\n+\n+    self.write_call(call_expr, fn_sig.output);\n }\n \n-fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                          call_expr: &hir::Expr,\n-                                          arg_exprs: &'tcx [P<hir::Expr>],\n-                                          expected: Expectation<'tcx>,\n-                                          fn_sig: ty::FnSig<'tcx>)\n+fn confirm_deferred_closure_call(&self,\n+                                 call_expr: &hir::Expr,\n+                                 arg_exprs: &'tcx [P<hir::Expr>],\n+                                 expected: Expectation<'tcx>,\n+                                 fn_sig: ty::FnSig<'tcx>)\n {\n     // `fn_sig` is the *signature* of the cosure being called. We\n     // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n     // do know the types expected for each argument and the return\n     // type.\n \n     let expected_arg_tys =\n-        expected_types_for_fn_args(fcx,\n-                                   call_expr.span,\n-                                   expected,\n-                                   fn_sig.output.clone(),\n-                                   &fn_sig.inputs);\n-\n-    check_argument_types(fcx,\n-                         call_expr.span,\n-                         &fn_sig.inputs,\n-                         &expected_arg_tys,\n-                         arg_exprs,\n-                         fn_sig.variadic,\n-                         TupleArgumentsFlag::TupleArguments);\n-\n-    write_call(fcx, call_expr, fn_sig.output);\n+        self.expected_types_for_fn_args(call_expr.span,\n+                                        expected,\n+                                        fn_sig.output.clone(),\n+                                        &fn_sig.inputs);\n+\n+    self.check_argument_types(call_expr.span,\n+                              &fn_sig.inputs,\n+                              &expected_arg_tys,\n+                              arg_exprs,\n+                              fn_sig.variadic,\n+                              TupleArgumentsFlag::TupleArguments);\n+\n+    self.write_call(call_expr, fn_sig.output);\n }\n \n-fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    call_expr: &hir::Expr,\n-                                    callee_expr: &'tcx hir::Expr,\n-                                    arg_exprs: &'tcx [P<hir::Expr>],\n-                                    expected: Expectation<'tcx>,\n-                                    method_callee: ty::MethodCallee<'tcx>)\n+fn confirm_overloaded_call(&self,\n+                           call_expr: &hir::Expr,\n+                           callee_expr: &'tcx hir::Expr,\n+                           arg_exprs: &'tcx [P<hir::Expr>],\n+                           expected: Expectation<'tcx>,\n+                           method_callee: ty::MethodCallee<'tcx>)\n {\n     let output_type =\n-        check_method_argument_types(fcx,\n-                                    call_expr.span,\n-                                    method_callee.ty,\n-                                    callee_expr,\n-                                    arg_exprs,\n-                                    TupleArgumentsFlag::TupleArguments,\n-                                    expected);\n-    write_call(fcx, call_expr, output_type);\n-\n-    write_overloaded_call_method_map(fcx, call_expr, method_callee);\n+        self.check_method_argument_types(call_expr.span,\n+                                         method_callee.ty,\n+                                         callee_expr,\n+                                         arg_exprs,\n+                                         TupleArgumentsFlag::TupleArguments,\n+                                         expected);\n+    self.write_call(call_expr, output_type);\n+\n+    self.write_overloaded_call_method_map(call_expr, method_callee);\n }\n \n-fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                             call_expr: &hir::Expr,\n-                                             method_callee: ty::MethodCallee<'tcx>) {\n+fn write_overloaded_call_method_map(&self,\n+                                    call_expr: &hir::Expr,\n+                                    method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n-    fcx.inh.tables.borrow_mut().method_map.insert(method_call, method_callee);\n+    self.inh.tables.borrow_mut().method_map.insert(method_call, method_callee);\n+}\n }\n \n #[derive(Debug)]\n@@ -365,7 +347,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n         assert!(fcx.infcx().closure_kind(self.closure_def_id).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n-        match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,\n+        match fcx.try_overloaded_call_traits(self.call_expr, self.callee_expr,\n                                          self.adjusted_ty, self.autoderefs) {\n             Some(method_callee) => {\n                 // One problem is that when we get here, we are going\n@@ -385,16 +367,15 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 for (&method_arg_ty, &self_arg_ty) in\n                     method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)\n                 {\n-                    demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n+                    fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n                 let nilty = fcx.tcx().mk_nil();\n-                demand::eqtype(fcx,\n-                               self.call_expr.span,\n-                               method_sig.output.unwrap_or(nilty),\n-                               self.fn_sig.output.unwrap_or(nilty));\n+                fcx.demand_eqtype(self.call_expr.span,\n+                                  method_sig.output.unwrap_or(nilty),\n+                                  self.fn_sig.output.unwrap_or(nilty));\n \n-                write_overloaded_call_method_map(fcx, self.call_expr, method_callee);\n+                fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n             }\n             None => {\n                 span_bug!("}, {"sha": "506347679a4146d0ad2d980ae94a1a26a19b5d64", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 47, "deletions": 53, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -38,10 +38,7 @@\n //! expression, `e as U2` is not necessarily so (in fact it will only be valid if\n //! `U1` coerces to `U2`).\n \n-use super::coercion;\n-use super::demand;\n use super::FnCtxt;\n-use super::structurally_resolved_type;\n \n use lint;\n use hir::def_id::DefId;\n@@ -75,19 +72,18 @@ enum UnsizeKind<'tcx> {\n     OfParam(&'tcx ty::ParamTy)\n }\n \n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Returns the kind of unsize information of t, or None\n /// if t is sized or it is unknown.\n-fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                        t: Ty<'tcx>)\n-                        -> Option<UnsizeKind<'tcx>> {\n+fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n     match t.sty {\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n         ty::TyStruct(def, substs) => {\n             // FIXME(arielb1): do some kind of normalization\n             match def.struct_variant().fields.last() {\n                 None => None,\n-                Some(f) => unsize_kind(fcx, f.ty(fcx.tcx(), substs))\n+                Some(f) => self.unsize_kind(f.ty(self.tcx(), substs))\n             }\n         }\n         // We should really try to normalize here.\n@@ -96,6 +92,7 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         _ => None\n     }\n }\n+}\n \n #[derive(Copy, Clone)]\n enum CastError {\n@@ -112,14 +109,14 @@ enum CastError {\n     NonScalar,\n }\n \n-impl<'tcx> CastCheck<'tcx> {\n-    pub fn new<'a>(fcx: &FnCtxt<'a, 'tcx>,\n-                   expr: &'tcx hir::Expr,\n-                   expr_ty: Ty<'tcx>,\n-                   cast_ty: Ty<'tcx>,\n-                   cast_span: Span,\n-                   span: Span)\n-                   -> Result<CastCheck<'tcx>, ErrorReported> {\n+impl<'a, 'tcx> CastCheck<'tcx> {\n+    pub fn new(fcx: &FnCtxt<'a, 'tcx>,\n+               expr: &'tcx hir::Expr,\n+               expr_ty: Ty<'tcx>,\n+               cast_ty: Ty<'tcx>,\n+               cast_span: Span,\n+               span: Span)\n+               -> Result<CastCheck<'tcx>, ErrorReported> {\n         let check = CastCheck {\n             expr: expr,\n             expr_ty: expr_ty,\n@@ -142,9 +139,7 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_error<'a>(&self,\n-                             fcx: &FnCtxt<'a, 'tcx>,\n-                             e: CastError) {\n+    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx>, e: CastError) {\n         match e {\n             CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |\n@@ -207,8 +202,7 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_to_unsized_type<'a>(&self,\n-                                       fcx: &FnCtxt<'a, 'tcx>) {\n+    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         if\n             self.cast_ty.references_error() ||\n             self.expr_ty.references_error()\n@@ -262,7 +256,7 @@ impl<'tcx> CastCheck<'tcx> {\n         err.emit();\n     }\n \n-    fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n@@ -287,9 +281,9 @@ impl<'tcx> CastCheck<'tcx> {\n \n     }\n \n-    pub fn check<'a>(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n-        self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n-        self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n+    pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n+        self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n+        self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n                self.cast_ty);\n@@ -315,7 +309,7 @@ impl<'tcx> CastCheck<'tcx> {\n     /// Check a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc::ty::cast::IntTy::*;\n         use rustc::ty::cast::CastTy::*;\n \n@@ -326,8 +320,8 @@ impl<'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(_, _, f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = coercion::try(fcx, self.expr,\n-                                            fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n+                    let res = fcx.try_coerce(self.expr,\n+                                             fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -382,11 +376,11 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_ptr_cast<'a>(&self,\n-                              fcx: &FnCtxt<'a, 'tcx>,\n-                              m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                              m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                              -> Result<CastKind, CastError>\n+    fn check_ptr_ptr_cast(&self,\n+                          fcx: &FnCtxt<'a, 'tcx>,\n+                          m_expr: &'tcx ty::TypeAndMut<'tcx>,\n+                          m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                          -> Result<CastKind, CastError>\n     {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\",\n                m_expr, m_cast);\n@@ -403,16 +397,16 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n \n         // vtable kinds must match\n-        match (unsize_kind(fcx, m_cast.ty), unsize_kind(fcx, m_expr.ty)) {\n+        match (fcx.unsize_kind(m_cast.ty), fcx.unsize_kind(m_expr.ty)) {\n             (Some(a), Some(b)) if a == b => Ok(CastKind::PtrPtrCast),\n             _ => Err(CastError::DifferingKinds)\n         }\n     }\n \n-    fn check_fptr_ptr_cast<'a>(&self,\n-                               fcx: &FnCtxt<'a, 'tcx>,\n-                               m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                               -> Result<CastKind, CastError>\n+    fn check_fptr_ptr_cast(&self,\n+                           fcx: &FnCtxt<'a, 'tcx>,\n+                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           -> Result<CastKind, CastError>\n     {\n         // fptr-ptr cast. must be to sized ptr\n \n@@ -423,10 +417,10 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ptr_addr_cast<'a>(&self,\n-                               fcx: &FnCtxt<'a, 'tcx>,\n-                               m_expr: &'tcx ty::TypeAndMut<'tcx>)\n-                               -> Result<CastKind, CastError>\n+    fn check_ptr_addr_cast(&self,\n+                           fcx: &FnCtxt<'a, 'tcx>,\n+                           m_expr: &'tcx ty::TypeAndMut<'tcx>)\n+                           -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. must be from sized ptr\n \n@@ -437,11 +431,11 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn check_ref_cast<'a>(&self,\n-                          fcx: &FnCtxt<'a, 'tcx>,\n-                          m_expr: &'tcx ty::TypeAndMut<'tcx>,\n-                          m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                          -> Result<CastKind, CastError>\n+    fn check_ref_cast(&self,\n+                      fcx: &FnCtxt<'a, 'tcx>,\n+                      m_expr: &'tcx ty::TypeAndMut<'tcx>,\n+                      m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                      -> Result<CastKind, CastError>\n     {\n         // array-ptr-cast.\n \n@@ -455,18 +449,18 @@ impl<'tcx> CastCheck<'tcx> {\n                 // from a region pointer to a vector.\n \n                 // this will report a type mismatch if needed\n-                demand::eqtype(fcx, self.span, ety, m_cast.ty);\n+                fcx.demand_eqtype(self.span, ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);\n             }\n         }\n \n         Err(CastError::IllegalCast)\n     }\n \n-    fn check_addr_ptr_cast<'a>(&self,\n-                               fcx: &FnCtxt<'a, 'tcx>,\n-                               m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                               -> Result<CastKind, CastError>\n+    fn check_addr_ptr_cast(&self,\n+                           fcx: &FnCtxt<'a, 'tcx>,\n+                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n+                           -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. pointer must be thin.\n         if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n@@ -476,8 +470,8 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n-        coercion::try(fcx, self.expr, self.cast_ty).is_ok()\n+    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n+        fcx.try_coerce(self.expr, self.cast_ty).is_ok()\n     }\n \n }"}, {"sha": "7632f58f057a01cdc470bfcbaf67665c06019cac", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 51, "deletions": 67, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -19,39 +19,40 @@ use std::cmp;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                   expr: &hir::Expr,\n-                                   _capture: hir::CaptureClause,\n-                                   decl: &'tcx hir::FnDecl,\n-                                   body: &'tcx hir::Block,\n-                                   expected: Expectation<'tcx>) {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn check_expr_closure(&self,\n+                          expr: &hir::Expr,\n+                          _capture: hir::CaptureClause,\n+                          decl: &'tcx hir::FnDecl,\n+                          body: &'tcx hir::Block,\n+                          expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n            expr,\n            expected);\n \n     // It's always helpful for inference if we know the kind of\n     // closure sooner rather than later, so first examine the expected\n     // type, and see if can glean a closure kind from there.\n-    let (expected_sig,expected_kind) = match expected.to_option(fcx) {\n-        Some(ty) => deduce_expectations_from_expected_type(fcx, ty),\n+    let (expected_sig,expected_kind) = match expected.to_option(self) {\n+        Some(ty) => self.deduce_expectations_from_expected_type(ty),\n         None => (None, None)\n     };\n-    check_closure(fcx, expr, expected_kind, decl, body, expected_sig)\n+    self.check_closure(expr, expected_kind, decl, body, expected_sig)\n }\n \n-fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                          expr: &hir::Expr,\n-                          opt_kind: Option<ty::ClosureKind>,\n-                          decl: &'tcx hir::FnDecl,\n-                          body: &'tcx hir::Block,\n-                          expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = fcx.tcx().map.local_def_id(expr.id);\n+fn check_closure(&self,\n+                 expr: &hir::Expr,\n+                 opt_kind: Option<ty::ClosureKind>,\n+                 decl: &'tcx hir::FnDecl,\n+                 body: &'tcx hir::Block,\n+                 expected_sig: Option<ty::FnSig<'tcx>>) {\n+    let expr_def_id = self.tcx().map.local_def_id(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,\n            expected_sig);\n \n-    let mut fn_ty = astconv::ty_of_closure(fcx,\n+    let mut fn_ty = astconv::ty_of_closure(self,\n                                            hir::Unsafety::Normal,\n                                            decl,\n                                            Abi::RustCall,\n@@ -60,81 +61,75 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // Create type variables (for now) to represent the transformed\n     // types of upvars. These will be unified during the upvar\n     // inference phase (`upvar.rs`).\n-    let num_upvars = fcx.tcx().with_freevars(expr.id, |fv| fv.len());\n-    let upvar_tys = fcx.infcx().next_ty_vars(num_upvars);\n+    let num_upvars = self.tcx().with_freevars(expr.id, |fv| fv.len());\n+    let upvar_tys = self.infcx().next_ty_vars(num_upvars);\n \n     debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n            expr.id, upvar_tys);\n \n-    let closure_type =\n-        fcx.ccx.tcx.mk_closure(\n-            expr_def_id,\n-            fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()),\n-            upvar_tys);\n+    let closure_type = self.tcx().mk_closure(expr_def_id,\n+        self.tcx().mk_substs(self.inh.infcx.parameter_environment.free_substs.clone()),\n+        upvar_tys);\n \n-    fcx.write_ty(expr.id, closure_type);\n+    self.write_ty(expr.id, closure_type);\n \n-    let fn_sig = fcx.tcx().liberate_late_bound_regions(\n-        fcx.tcx().region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n+    let fn_sig = self.tcx().liberate_late_bound_regions(\n+        self.tcx().region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n \n-    check_fn(fcx.ccx,\n+    check_fn(self.ccx,\n              hir::Unsafety::Normal,\n              expr.id,\n              &fn_sig,\n              decl,\n              expr.id,\n              &body,\n-             fcx.inh);\n+             self.inh);\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `closures` table.\n-    fn_ty.sig.0.inputs = vec![fcx.tcx().mk_tup(fn_ty.sig.0.inputs)];\n+    fn_ty.sig.0.inputs = vec![self.tcx().mk_tup(fn_ty.sig.0.inputs)];\n \n     debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n            expr_def_id,\n            fn_ty.sig,\n            opt_kind);\n \n-    fcx.inh.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n+    self.inh.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n     match opt_kind {\n-        Some(kind) => { fcx.inh.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n+        Some(kind) => { self.inh.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n         None => { }\n     }\n }\n \n-fn deduce_expectations_from_expected_type<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected_ty: Ty<'tcx>)\n+fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n     -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n     debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n            expected_ty);\n \n     match expected_ty.sty {\n         ty::TyTrait(ref object_type) => {\n-            let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n-                                                                         fcx.tcx().types.err);\n+            let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx(),\n+                                                                         self.tcx().types.err);\n             let sig = proj_bounds.iter()\n-                                 .filter_map(|pb| deduce_sig_from_projection(fcx, pb))\n+                                 .filter_map(|pb| self.deduce_sig_from_projection(pb))\n                                  .next();\n-            let kind = fcx.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n+            let kind = self.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n             (sig, kind)\n         }\n         ty::TyInfer(ty::TyVar(vid)) => {\n-            deduce_expectations_from_obligations(fcx, vid)\n+            self.deduce_expectations_from_obligations(vid)\n         }\n         _ => {\n             (None, None)\n         }\n     }\n }\n \n-fn deduce_expectations_from_obligations<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected_vid: ty::TyVid)\n+fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n     -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n-    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    let fulfillment_cx = self.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n     let expected_sig =\n@@ -151,8 +146,8 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 // the complete signature.\n                 ty::Predicate::Projection(ref proj_predicate) => {\n                     let trait_ref = proj_predicate.to_poly_trait_ref();\n-                    self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n-                        .and_then(|_| deduce_sig_from_projection(fcx, proj_predicate))\n+                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n+                        .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n                 }\n                 _ => {\n                     None\n@@ -192,32 +187,21 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::ClosureKind(..) => None,\n             };\n             opt_trait_ref\n-                .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n-                .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n+                .and_then(|trait_ref| self.self_type_matches_expected_vid(trait_ref, expected_vid))\n+                .and_then(|trait_ref| self.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n         })\n-        .fold(None, pick_most_restrictive_closure_kind);\n+        .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n     (expected_sig, expected_kind)\n }\n \n-fn pick_most_restrictive_closure_kind(best: Option<ty::ClosureKind>,\n-                                      cur: ty::ClosureKind)\n-                                      -> Option<ty::ClosureKind>\n-{\n-    match best {\n-        None => Some(cur),\n-        Some(best) => Some(cmp::min(best, cur))\n-    }\n-}\n-\n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n /// everything we need to know about a closure.\n-fn deduce_sig_from_projection<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n+fn deduce_sig_from_projection(&self,\n     projection: &ty::PolyProjectionPredicate<'tcx>)\n     -> Option<ty::FnSig<'tcx>>\n {\n-    let tcx = fcx.tcx();\n+    let tcx = self.tcx();\n \n     debug!(\"deduce_sig_from_projection({:?})\",\n            projection);\n@@ -229,7 +213,7 @@ fn deduce_sig_from_projection<'a,'tcx>(\n     }\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n-    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n+    let arg_param_ty = self.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n     debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n     let input_tys = match arg_param_ty.sty {\n@@ -239,7 +223,7 @@ fn deduce_sig_from_projection<'a,'tcx>(\n     debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n     let ret_param_ty = projection.0.ty;\n-    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n+    let ret_param_ty = self.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n     let fn_sig = ty::FnSig {\n@@ -252,13 +236,12 @@ fn deduce_sig_from_projection<'a,'tcx>(\n     Some(fn_sig)\n }\n \n-fn self_type_matches_expected_vid<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n+fn self_type_matches_expected_vid(&self,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n     expected_vid: ty::TyVid)\n     -> Option<ty::PolyTraitRef<'tcx>>\n {\n-    let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+    let self_ty = self.infcx().shallow_resolve(trait_ref.self_ty());\n     debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n            trait_ref,\n            self_ty);\n@@ -267,3 +250,4 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n         _ => None,\n     }\n }\n+}"}, {"sha": "ae23ee79e91ec9ac2a22e6dcbfba75a7b8738f19", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt, UnresolvedTypeAction};\n \n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n@@ -241,10 +241,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n         let mut r_borrow_var = None;\n-        let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n-                                                 UnresolvedTypeAction::Ignore,\n-                                                 lvalue_pref,\n-                                                 |referent_ty, autoderef|\n+        let (_, autoderefs, success) = self.fcx.autoderef(span, a, exprs,\n+                                                          UnresolvedTypeAction::Ignore,\n+                                                          lvalue_pref,\n+                                                          |referent_ty, autoderef|\n         {\n             if autoderef == 0 {\n                 // Don't let this pass, otherwise it would cause\n@@ -616,25 +616,26 @@ fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n     Ok((ty, adjustment))\n }\n \n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Attempt to coerce an expression to a type, and return the\n /// adjusted type of the expression, if successful.\n /// Adjustments are only recorded if the coercion succeeded.\n /// The expressions *must not* have any pre-existing adjustments.\n-pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                     expr: &hir::Expr,\n-                     target: Ty<'tcx>)\n-                     -> RelateResult<'tcx, Ty<'tcx>> {\n-    let source = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n+pub fn try_coerce(&self,\n+                  expr: &hir::Expr,\n+                  target: Ty<'tcx>)\n+                  -> RelateResult<'tcx, Ty<'tcx>> {\n+    let source = self.resolve_type_vars_if_possible(self.expr_ty(expr));\n     debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n-    let mut coerce = Coerce::new(fcx, TypeOrigin::ExprAssignable(expr.span));\n-    fcx.infcx().commit_if_ok(|_| {\n+    let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n+    self.infcx().commit_if_ok(|_| {\n         let (ty, adjustment) =\n             apply(&mut coerce, &|| Some(expr), source, target)?;\n         if !adjustment.is_identity() {\n             debug!(\"Success, coerced with {:?}\", adjustment);\n-            assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n-            fcx.write_adjustment(expr.id, adjustment);\n+            assert!(!self.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+            self.write_adjustment(expr.id, adjustment);\n         }\n         Ok(ty)\n     })\n@@ -643,18 +644,18 @@ pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// Given some expressions, their known unified type and another expression,\n /// tries to unify the types, potentially inserting coercions on any of the\n /// provided expressions and returns their LUB (aka \"common supertype\").\n-pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        origin: TypeOrigin,\n-                                        exprs: E,\n-                                        prev_ty: Ty<'tcx>,\n-                                        new: &'b hir::Expr)\n-                                        -> RelateResult<'tcx, Ty<'tcx>>\n+pub fn try_find_coercion_lub<'b, E, I>(&self,\n+                                       origin: TypeOrigin,\n+                                       exprs: E,\n+                                       prev_ty: Ty<'tcx>,\n+                                       new: &'b hir::Expr)\n+                                       -> RelateResult<'tcx, Ty<'tcx>>\n     // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n     where E: Fn() -> I,\n           I: IntoIterator<Item=&'b hir::Expr> {\n \n-    let prev_ty = fcx.resolve_type_vars_if_possible(prev_ty);\n-    let new_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(new));\n+    let prev_ty = self.resolve_type_vars_if_possible(prev_ty);\n+    let new_ty = self.resolve_type_vars_if_possible(self.expr_ty(new));\n     debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n     let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n@@ -665,7 +666,7 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)\n+            let fty = self.infcx().lub(true, trace.clone(), a_fty, b_fty)\n                 .map(|InferOk { value, obligations }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -674,46 +675,46 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n-                let substs = fcx.infcx().commit_if_ok(|_| {\n-                    fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n+                let substs = self.infcx().commit_if_ok(|_| {\n+                    self.infcx().lub(true, trace.clone(), a_substs, b_substs)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n                             value\n                         })\n-                }).map(|s| fcx.tcx().mk_substs(s));\n+                }).map(|s| self.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n                     // We have a LUB of prev_ty and new_ty, just return it.\n-                    return Ok(fcx.tcx().mk_fn_def(a_def_id, substs, fty));\n+                    return Ok(self.tcx().mk_fn_def(a_def_id, substs, fty));\n                 }\n             }\n \n             // Reify both sides and return the reified fn pointer type.\n             for expr in exprs().into_iter().chain(Some(new)) {\n                 // No adjustments can produce a fn item, so this should never trip.\n-                assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n-                fcx.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                assert!(!self.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+                self.write_adjustment(expr.id, AdjustReifyFnPointer);\n             }\n-            return Ok(fcx.tcx().mk_fn_ptr(fty));\n+            return Ok(self.tcx().mk_fn_ptr(fty));\n         }\n         _ => {}\n     }\n \n-    let mut coerce = Coerce::new(fcx, origin);\n+    let mut coerce = Coerce::new(self, origin);\n     coerce.use_lub = true;\n \n     // First try to coerce the new expression to the type of the previous ones,\n     // but only if the new expression has no coercion already applied to it.\n     let mut first_error = None;\n-    if !fcx.inh.tables.borrow().adjustments.contains_key(&new.id) {\n-        let result = fcx.infcx().commit_if_ok(|_| {\n+    if !self.inh.tables.borrow().adjustments.contains_key(&new.id) {\n+        let result = self.infcx().commit_if_ok(|_| {\n             apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n         });\n         match result {\n             Ok((ty, adjustment)) => {\n                 if !adjustment.is_identity() {\n-                    fcx.write_adjustment(new.id, adjustment);\n+                    self.write_adjustment(new.id, adjustment);\n                 }\n                 return Ok(ty);\n             }\n@@ -725,12 +726,12 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n     // This requires ensuring there are no coercions applied to *any* of the\n     // previous expressions, other than noop reborrows (ignoring lifetimes).\n     for expr in exprs() {\n-        let noop = match fcx.inh.tables.borrow().adjustments.get(&expr.id) {\n+        let noop = match self.inh.tables.borrow().adjustments.get(&expr.id) {\n             Some(&AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n                 autoref: Some(AutoPtr(_, mutbl_adj)),\n                 unsize: None\n-            })) => match fcx.expr_ty(expr).sty {\n+            })) => match self.expr_ty(expr).sty {\n                 ty::TyRef(_, mt_orig) => {\n                     // Reborrow that we can safely ignore.\n                     mutbl_adj == mt_orig.mutbl\n@@ -742,8 +743,8 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         if !noop {\n-            return fcx.infcx().commit_if_ok(|_| {\n-                fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+            return self.infcx().commit_if_ok(|_| {\n+                self.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n                     .map(|InferOk { value, obligations }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -753,14 +754,14 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    match fcx.infcx().commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+    match self.infcx().commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n         Err(_) => {\n             // Avoid giving strange errors on failed attempts.\n             if let Some(e) = first_error {\n                 Err(e)\n             } else {\n-                fcx.infcx().commit_if_ok(|_| {\n-                    fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                self.infcx().commit_if_ok(|_| {\n+                    self.infcx().lub(true, trace, &prev_ty, &new_ty)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n@@ -772,10 +773,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok((ty, adjustment)) => {\n             if !adjustment.is_identity() {\n                 for expr in exprs() {\n-                    fcx.write_adjustment(expr.id, adjustment);\n+                    self.write_adjustment(expr.id, adjustment);\n                 }\n             }\n             Ok(ty)\n         }\n     }\n }\n+}"}, {"sha": "8dfd62e1a6686193567a4684d3f7274a4db1965e", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -9,52 +9,49 @@\n // except according to those terms.\n \n \n-use check::{coercion, FnCtxt};\n+use check::FnCtxt;\n use rustc::ty::Ty;\n use rustc::infer::{InferOk, TypeOrigin};\n \n use syntax::codemap::Span;\n use rustc::hir;\n \n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n // Requires that the two types unify, and prints an error message if\n // they don't.\n-pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    match fcx.infcx().sub_types(false, origin, actual, expected) {\n+    match self.infcx().sub_types(false, origin, actual, expected) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());\n         },\n         Err(e) => {\n-            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+            self.infcx().report_mismatched_types(origin, expected, actual, e);\n         }\n     }\n }\n \n-pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                        expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    match fcx.infcx().eq_types(false, origin, actual, expected) {\n+    match self.infcx().eq_types(false, origin, actual, expected) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());\n         },\n         Err(e) => {\n-            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+            self.infcx().report_mismatched_types(origin, expected, actual, e);\n         }\n     }\n }\n \n // Checks that the type of `expr` can be coerced to `expected`.\n-pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                        sp: Span,\n-                        expected: Ty<'tcx>,\n-                        expr: &hir::Expr) {\n-    let expected = fcx.resolve_type_vars_if_possible(expected);\n-    if let Err(e) = coercion::try(fcx, expr, expected) {\n-        let origin = TypeOrigin::Misc(sp);\n-        let expr_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(expr));\n-        fcx.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n+pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n+    let expected = self.resolve_type_vars_if_possible(expected);\n+    if let Err(e) = self.try_coerce(expr, expected) {\n+        let origin = TypeOrigin::Misc(expr.span);\n+        let expr_ty = self.resolve_type_vars_if_possible(self.expr_ty(expr));\n+        self.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }\n+}"}, {"sha": "77c74078de757f704d36f838b78798db7d7636af", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -10,7 +10,7 @@\n \n use super::probe;\n \n-use check::{self, FnCtxt, callee, demand};\n+use check::{FnCtxt, callee};\n use check::UnresolvedTypeAction;\n use hir::def_id::DefId;\n use rustc::ty::subst::{self};\n@@ -44,23 +44,25 @@ struct InstantiatedMethodSig<'tcx> {\n     method_predicates: ty::InstantiatedPredicates<'tcx>,\n }\n \n-pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                         span: Span,\n-                         self_expr: &'tcx hir::Expr,\n-                         call_expr: &'tcx hir::Expr,\n-                         unadjusted_self_ty: Ty<'tcx>,\n-                         pick: probe::Pick<'tcx>,\n-                         supplied_method_types: Vec<Ty<'tcx>>)\n-                         -> ty::MethodCallee<'tcx>\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn confirm_method(&self,\n+                      span: Span,\n+                      self_expr: &'tcx hir::Expr,\n+                      call_expr: &'tcx hir::Expr,\n+                      unadjusted_self_ty: Ty<'tcx>,\n+                      pick: probe::Pick<'tcx>,\n+                      supplied_method_types: Vec<Ty<'tcx>>)\n+                      -> ty::MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n            unadjusted_self_ty,\n            pick,\n            supplied_method_types);\n \n-    let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr, call_expr);\n+    let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n     confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n }\n+}\n \n impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -155,13 +157,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Commit the autoderefs by calling `autoderef again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) = check::autoderef(self.fcx,\n-                                                          self.span,\n-                                                          unadjusted_self_ty,\n-                                                          || Some(self.self_expr),\n-                                                          UnresolvedTypeAction::Error,\n-                                                          NoPreference,\n-                                                          |_, n| {\n+        let (autoderefd_ty, n, result) = self.fcx.autoderef(self.span,\n+                                                            unadjusted_self_ty,\n+                                                            || Some(self.self_expr),\n+                                                            UnresolvedTypeAction::Error,\n+                                                            NoPreference,\n+                                                            |_, n| {\n             if n == pick.autoderefs {\n                 Some(())\n             } else {\n@@ -205,7 +206,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 let impl_def_id = pick.item.container().id();\n                 assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n-                check::impl_self_ty(self.fcx, self.span, impl_def_id).substs\n+                self.fcx.impl_self_ty(self.span, impl_def_id).substs\n             }\n \n             probe::ObjectPick => {\n@@ -245,7 +246,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // respectively, then we want to return the type\n                 // parameters from the trait ([$A,$B]), not those from\n                 // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n-                let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n+                let impl_polytype = self.fcx.impl_self_ty(self.span, impl_def_id);\n                 let impl_trait_ref =\n                     self.fcx.instantiate_type_scheme(\n                         self.span,\n@@ -284,13 +285,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n-        let (_, _, result) = check::autoderef(self.fcx,\n-                                              self.span,\n-                                              self_ty,\n-                                              || None,\n-                                              UnresolvedTypeAction::Error,\n-                                              NoPreference,\n-                                              |ty, _| {\n+        let (_, _, result) = self.fcx.autoderef(self.span,\n+                                                self_ty,\n+                                                || None,\n+                                                UnresolvedTypeAction::Error,\n+                                                NoPreference,\n+                                                |ty, _| {\n             match ty.sty {\n                 ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n                 _ => None,\n@@ -506,19 +506,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                    i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n-                check::autoderef(self.fcx,\n-                                 expr.span,\n-                                 self.fcx.expr_ty(expr),\n-                                 || Some(expr),\n-                                 UnresolvedTypeAction::Error,\n-                                 PreferMutLvalue,\n-                                 |_, autoderefs| {\n-                                     if autoderefs == autoderef_count + 1 {\n-                                         Some(())\n-                                     } else {\n-                                         None\n-                                     }\n-                                 });\n+                self.fcx.autoderef(expr.span,\n+                                   self.fcx.expr_ty(expr),\n+                                   || Some(expr),\n+                                   UnresolvedTypeAction::Error,\n+                                   PreferMutLvalue,\n+                                   |_, autoderefs| {\n+                    if autoderefs == autoderef_count + 1 {\n+                        Some(())\n+                    } else {\n+                        None\n+                    }\n+                });\n             }\n \n             // Don't retry the first one or we might infinite loop!\n@@ -576,8 +575,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     };\n                     let index_expr_ty = self.fcx.expr_ty(&index_expr);\n \n-                    let result = check::try_index_step(\n-                        self.fcx,\n+                    let result = self.fcx.try_index_step(\n                         ty::MethodCall::expr(expr.id),\n                         expr,\n                         &base_expr,\n@@ -588,20 +586,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         index_expr_ty);\n \n                     if let Some((input_ty, return_ty)) = result {\n-                        demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n+                        self.fcx.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n \n                         let expr_ty = self.fcx.expr_ty(&expr);\n-                        demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n+                        self.fcx.demand_suptype(expr.span, expr_ty, return_ty);\n                     }\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n                     // if this is an overloaded deref, then re-evaluate with\n                     // a preference for mut\n                     let method_call = ty::MethodCall::expr(expr.id);\n                     if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n-                        let method = check::try_overloaded_deref(\n-                            self.fcx,\n-                            expr.span,\n+                        let method = self.fcx.try_overloaded_deref(expr.span,\n                             Some(&base_expr),\n                             self.fcx.expr_ty(&base_expr),\n                             PreferMutLvalue);"}, {"sha": "63df002185241ec98932c0d1a8a633f2811fce68", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -27,7 +27,7 @@ use rustc::hir;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n-pub use self::suggest::{report_error, AllTraitsVec};\n+pub use self::suggest::AllTraitsVec;\n \n mod confirm;\n mod probe;\n@@ -78,16 +78,17 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ DefId),\n }\n \n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n-pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                        span: Span,\n-                        method_name: ast::Name,\n-                        self_ty: ty::Ty<'tcx>,\n-                        call_expr_id: ast::NodeId)\n-                        -> bool\n+pub fn method_exists(&self,\n+                     span: Span,\n+                     method_name: ast::Name,\n+                     self_ty: ty::Ty<'tcx>,\n+                     call_expr_id: ast::NodeId)\n+                     -> bool\n {\n     let mode = probe::Mode::MethodCall;\n-    match probe::probe(fcx, span, mode, method_name, self_ty, call_expr_id) {\n+    match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n         Ok(..) => true,\n         Err(NoMatch(..)) => false,\n         Err(Ambiguity(..)) => true,\n@@ -110,14 +111,14 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// * `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n /// * `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n /// * `self_expr`:             the self expression (`foo`)\n-pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                        span: Span,\n-                        method_name: ast::Name,\n-                        self_ty: ty::Ty<'tcx>,\n-                        supplied_method_types: Vec<ty::Ty<'tcx>>,\n-                        call_expr: &'tcx hir::Expr,\n-                        self_expr: &'tcx hir::Expr)\n-                        -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n+pub fn lookup_method(&self,\n+                     span: Span,\n+                     method_name: ast::Name,\n+                     self_ty: ty::Ty<'tcx>,\n+                     supplied_method_types: Vec<ty::Ty<'tcx>>,\n+                     call_expr: &'tcx hir::Expr,\n+                     self_expr: &'tcx hir::Expr)\n+                     -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n {\n     debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n            method_name,\n@@ -126,27 +127,27 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            self_expr);\n \n     let mode = probe::Mode::MethodCall;\n-    let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n-    let pick = probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id)?;\n+    let self_ty = self.infcx().resolve_type_vars_if_possible(&self_ty);\n+    let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n \n     if let Some(import_id) = pick.import_id {\n-        fcx.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+        self.tcx().used_trait_imports.borrow_mut().insert(import_id);\n     }\n \n-    Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n+    Ok(self.confirm_method(span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n-pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 span: Span,\n-                                 self_expr: Option<&hir::Expr>,\n-                                 m_name: ast::Name,\n-                                 trait_def_id: DefId,\n-                                 self_ty: ty::Ty<'tcx>,\n-                                 opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                 -> Option<ty::MethodCallee<'tcx>>\n+pub fn lookup_method_in_trait(&self,\n+                              span: Span,\n+                              self_expr: Option<&hir::Expr>,\n+                              m_name: ast::Name,\n+                              trait_def_id: DefId,\n+                              self_ty: ty::Ty<'tcx>,\n+                              opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                              -> Option<ty::MethodCallee<'tcx>>\n {\n-    lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n-                             0, false, self_ty, opt_input_types)\n+    self.lookup_method_in_trait_adjusted(span, self_expr, m_name, trait_def_id,\n+                                         0, false, self_ty, opt_input_types)\n }\n \n /// `lookup_in_trait_adjusted` is used for overloaded operators. It does a very narrow slice of\n@@ -158,24 +159,24 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// method-lookup code. In particular, autoderef on index is basically identical to autoderef with\n /// normal probes, except that the test also looks for built-in indexing. Also, the second half of\n /// this method is basically the same as confirmation.\n-pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          self_expr: Option<&hir::Expr>,\n-                                          m_name: ast::Name,\n-                                          trait_def_id: DefId,\n-                                          autoderefs: usize,\n-                                          unsize: bool,\n-                                          self_ty: ty::Ty<'tcx>,\n-                                          opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                          -> Option<ty::MethodCallee<'tcx>>\n+pub fn lookup_method_in_trait_adjusted(&self,\n+                                       span: Span,\n+                                       self_expr: Option<&hir::Expr>,\n+                                       m_name: ast::Name,\n+                                       trait_def_id: DefId,\n+                                       autoderefs: usize,\n+                                       unsize: bool,\n+                                       self_ty: ty::Ty<'tcx>,\n+                                       opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                       -> Option<ty::MethodCallee<'tcx>>\n {\n     debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, m_name={}, trait_def_id={:?})\",\n            self_ty,\n            self_expr,\n            m_name,\n            trait_def_id);\n \n-    let trait_def = fcx.tcx().lookup_trait_def(trait_def_id);\n+    let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n \n     let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n     let expected_number_of_input_types = type_parameter_defs.len();\n@@ -193,33 +194,33 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         None => {\n-            fcx.inh.infcx.type_vars_for_defs(\n+            self.inh.infcx.type_vars_for_defs(\n                 span,\n                 subst::ParamSpace::TypeSpace,\n                 &mut substs,\n                 type_parameter_defs);\n         }\n     }\n \n-    let trait_ref = ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs));\n+    let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs));\n \n     // Construct an obligation\n     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n     let obligation = traits::Obligation::misc(span,\n-                                              fcx.body_id,\n+                                              self.body_id,\n                                               poly_trait_ref.to_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx());\n+    let mut selcx = traits::SelectionContext::new(self.infcx());\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible.\n     }\n \n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n-    let tcx = fcx.tcx();\n-    let method_item = trait_item(fcx, trait_def_id, m_name).unwrap();\n+    let tcx = self.tcx();\n+    let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n     let method_ty = method_item.as_opt_method().unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n@@ -233,10 +234,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // NB: Instantiate late-bound regions first so that\n     // `instantiate_type_scheme` can normalize associated types that\n     // may reference those regions.\n-    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n-                                                                       infer::FnCall,\n-                                                                       &method_ty.fty.sig).0;\n-    let fn_sig = fcx.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n+    let fn_sig = self.infcx().replace_late_bound_regions_with_fresh_var(span,\n+                                                                        infer::FnCall,\n+                                                                        &method_ty.fty.sig).0;\n+    let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n     let def_id = method_item.def_id();\n     let fty = tcx.mk_fn_def(def_id, trait_ref.substs, ty::BareFnTy {\n@@ -257,19 +258,19 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = fcx.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n+    let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n     assert!(!method_bounds.has_escaping_regions());\n-    fcx.add_obligations_for_parameters(\n-        traits::ObligationCause::misc(span, fcx.body_id),\n+    self.add_obligations_for_parameters(\n+        traits::ObligationCause::misc(span, self.body_id),\n         &method_bounds);\n \n     // Also register an obligation for the method type being well-formed.\n-    fcx.register_wf_obligation(fty, span, traits::MiscObligation);\n+    self.register_wf_obligation(fty, span, traits::MiscObligation);\n \n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures.\n-    fcx.select_obligations_where_possible();\n+    self.select_obligations_where_possible();\n \n     // Insert any adjustments needed (always an autoref of some mutability).\n     match self_expr {\n@@ -285,15 +286,15 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 ty::ExplicitSelfCategory::ByValue => {\n                     // Trait method is fn(self), no transformation needed.\n                     assert!(!unsize);\n-                    fcx.write_autoderef_adjustment(self_expr.id, autoderefs);\n+                    self.write_autoderef_adjustment(self_expr.id, autoderefs);\n                 }\n \n                 ty::ExplicitSelfCategory::ByReference(..) => {\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n                     match transformed_self_ty.sty {\n                         ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                            fcx.write_adjustment(self_expr.id,\n+                            self.write_adjustment(self_expr.id,\n                                 AdjustDerefRef(AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(AutoPtr(region, mutbl)),\n@@ -335,52 +336,53 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n-pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                              span: Span,\n-                              method_name: ast::Name,\n-                              self_ty: ty::Ty<'tcx>,\n-                              expr_id: ast::NodeId)\n-                              -> Result<Def, MethodError<'tcx>>\n+pub fn resolve_ufcs(&self,\n+                    span: Span,\n+                    method_name: ast::Name,\n+                    self_ty: ty::Ty<'tcx>,\n+                    expr_id: ast::NodeId)\n+                    -> Result<Def, MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n-    let pick = probe::probe(fcx, span, mode, method_name, self_ty, expr_id)?;\n+    let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n \n     if let Some(import_id) = pick.import_id {\n-        fcx.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+        self.tcx().used_trait_imports.borrow_mut().insert(import_id);\n     }\n \n     let def = pick.item.def();\n     if let probe::InherentImplPick = pick.kind {\n-        if !pick.item.vis().is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n+        if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx().map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n-            fcx.tcx().sess.span_err(span, &msg);\n+            self.tcx().sess.span_err(span, &msg);\n         }\n     }\n     Ok(def)\n }\n \n /// Find item with name `item_name` defined in `trait_def_id`\n /// and return it, or `None`, if no such item.\n-pub fn trait_item<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            trait_def_id: DefId,\n-                            item_name: ast::Name)\n-                            -> Option<ty::ImplOrTraitItem<'tcx>>\n+pub fn trait_item(&self,\n+                  trait_def_id: DefId,\n+                  item_name: ast::Name)\n+                  -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let trait_items = fcx.tcx().trait_items(trait_def_id);\n+    let trait_items = self.tcx().trait_items(trait_def_id);\n     trait_items.iter()\n                .find(|item| item.name() == item_name)\n                .cloned()\n }\n \n-pub fn impl_item<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                           impl_def_id: DefId,\n-                           item_name: ast::Name)\n-                           -> Option<ty::ImplOrTraitItem<'tcx>>\n+pub fn impl_item(&self,\n+                 impl_def_id: DefId,\n+                 item_name: ast::Name)\n+                 -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let impl_items = fcx.tcx().impl_items.borrow();\n+    let impl_items = self.tcx().impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| fcx.tcx().impl_or_trait_item(did.def_id()))\n+        .map(|&did| self.tcx().impl_or_trait_item(did.def_id()))\n         .find(|m| m.name() == item_name)\n }\n+}"}, {"sha": "56f1f4677c60aa20a4ee2190050173d54eb8b0a0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -13,7 +13,6 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check;\n use check::{FnCtxt, UnresolvedTypeAction};\n use hir::def_id::DefId;\n use hir::def::Def;\n@@ -129,13 +128,14 @@ pub enum Mode {\n     Path\n }\n \n-pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                       span: Span,\n-                       mode: Mode,\n-                       item_name: ast::Name,\n-                       self_ty: Ty<'tcx>,\n-                       scope_expr_id: ast::NodeId)\n-                       -> PickResult<'tcx>\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn probe_method(&self,\n+                    span: Span,\n+                    mode: Mode,\n+                    item_name: ast::Name,\n+                    self_ty: Ty<'tcx>,\n+                    scope_expr_id: ast::NodeId)\n+                    -> PickResult<'tcx>\n {\n     debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n            self_ty,\n@@ -148,9 +148,9 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // side-effects. This is a bit of a pain to refactor. So just let\n     // it ride, although it's really not great, and in fact could I\n     // think cause spurious errors. Really though this part should\n-    // take place in the `fcx.infcx().probe` below.\n+    // take place in the `self.infcx().probe` below.\n     let steps = if mode == Mode::MethodCall {\n-        match create_steps(fcx, span, self_ty) {\n+        match self.create_steps(span, self_ty) {\n             Some(steps) => steps,\n             None =>return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(), Vec::new(),\n                                                                     Vec::new(), mode))),\n@@ -166,7 +166,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Create a list of simplified self types, if we can.\n     let mut simplified_steps = Vec::new();\n     for step in &steps {\n-        match ty::fast_reject::simplify_type(fcx.tcx(), step.self_ty, true) {\n+        match ty::fast_reject::simplify_type(self.tcx(), step.self_ty, true) {\n             None => { break; }\n             Some(simplified_type) => { simplified_steps.push(simplified_type); }\n         }\n@@ -184,8 +184,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n-    fcx.infcx().probe(|_| {\n-        let mut probe_cx = ProbeContext::new(fcx,\n+    self.infcx().probe(|_| {\n+        let mut probe_cx = ProbeContext::new(self,\n                                              span,\n                                              mode,\n                                              item_name,\n@@ -197,19 +197,18 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     })\n }\n \n-fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                          span: Span,\n-                          self_ty: Ty<'tcx>)\n-                          -> Option<Vec<CandidateStep<'tcx>>> {\n+fn create_steps(&self,\n+                span: Span,\n+                self_ty: Ty<'tcx>)\n+                -> Option<Vec<CandidateStep<'tcx>>> {\n     let mut steps = Vec::new();\n \n-    let (final_ty, dereferences, _) = check::autoderef(fcx,\n-                                                       span,\n-                                                       self_ty,\n-                                                       || None,\n-                                                       UnresolvedTypeAction::Error,\n-                                                       NoPreference,\n-                                                       |t, d| {\n+    let (final_ty, dereferences, _) = self.autoderef(span,\n+                                                     self_ty,\n+                                                     || None,\n+                                                     UnresolvedTypeAction::Error,\n+                                                     NoPreference,\n+                                                     |t, d| {\n         steps.push(CandidateStep {\n             self_ty: t,\n             autoderefs: d,\n@@ -221,7 +220,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match final_ty.sty {\n         ty::TyArray(elem_ty, _) => {\n             steps.push(CandidateStep {\n-                self_ty: fcx.tcx().mk_slice(elem_ty),\n+                self_ty: self.tcx().mk_slice(elem_ty),\n                 autoderefs: dereferences,\n                 unsize: true\n             });\n@@ -232,6 +231,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     Some(steps)\n }\n+}\n \n impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n@@ -1313,15 +1313,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn impl_item(&self, impl_def_id: DefId)\n                  -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        super::impl_item(self.fcx, impl_def_id, self.item_name)\n+        self.fcx.impl_item(impl_def_id, self.item_name)\n     }\n \n     /// Find item with name `item_name` defined in `trait_def_id`\n     /// and return it, or `None`, if no such item.\n     fn trait_item(&self, trait_def_id: DefId)\n                   -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n-        super::trait_item(self.fcx, trait_def_id, self.item_name)\n+        self.fcx.trait_item(trait_def_id, self.item_name)\n     }\n }\n "}, {"sha": "d9af3552d85fbfb28ddabdd5913e978fe62bde54", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 118, "deletions": 123, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -13,7 +13,7 @@\n \n use CrateCtxt;\n \n-use check::{self, FnCtxt, UnresolvedTypeAction, autoderef};\n+use check::{self, FnCtxt, UnresolvedTypeAction};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore;\n@@ -36,38 +36,36 @@ use rustc::hir::Expr_;\n use std::cell;\n use std::cmp::Ordering;\n \n-use super::{MethodError, NoMatchData, CandidateSource, impl_item, trait_item};\n+use super::{MethodError, NoMatchData, CandidateSource};\n use super::probe::Mode;\n \n-fn is_fn_ty<'a, 'tcx>(ty: &Ty<'tcx>, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> bool {\n-    let cx = fcx.tcx();\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n+    let tcx = self.tcx();\n     match ty.sty {\n         // Not all of these (e.g. unsafe fns) implement FnOnce\n         // so we look for these beforehand\n         ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n         // If it's not a simple function, look for things which implement FnOnce\n         _ => {\n             if let Ok(fn_once_trait_did) =\n-                    cx.lang_items.require(FnOnceTraitLangItem) {\n-                let infcx = fcx.infcx();\n-                let (_, _, opt_is_fn) = autoderef(fcx,\n-                                                  span,\n-                                                  ty,\n-                                                  || None,\n-                                                  UnresolvedTypeAction::Ignore,\n-                                                  LvaluePreference::NoPreference,\n-                                                  |ty, _| {\n+                    tcx.lang_items.require(FnOnceTraitLangItem) {\n+                let infcx = self.infcx();\n+                let (_, _, opt_is_fn) = self.autoderef(span,\n+                                                       ty,\n+                                                       || None,\n+                                                       UnresolvedTypeAction::Ignore,\n+                                                       LvaluePreference::NoPreference,\n+                                                       |ty, _| {\n                     infcx.probe(|_| {\n                         let fn_once_substs =\n-                            Substs::new_trait(vec![infcx.next_ty_var()],\n-                                              Vec::new(),\n-                                              ty);\n+                            Substs::new_trait(vec![infcx.next_ty_var()], vec![], ty);\n                         let trait_ref =\n-                          ty::TraitRef::new(fn_once_trait_did,\n-                                            cx.mk_substs(fn_once_substs));\n+                            ty::TraitRef::new(fn_once_trait_did,\n+                                              tcx.mk_substs(fn_once_substs));\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation = Obligation::misc(span,\n-                                                          fcx.body_id,\n+                                                          self.body_id,\n                                                           poly_trait_ref\n                                                              .to_predicate());\n                         let mut selcx = SelectionContext::new(infcx);\n@@ -87,27 +85,83 @@ fn is_fn_ty<'a, 'tcx>(ty: &Ty<'tcx>, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> bool\n         }\n     }\n }\n-\n-pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                              span: Span,\n-                              rcvr_ty: Ty<'tcx>,\n-                              item_name: ast::Name,\n-                              rcvr_expr: Option<&hir::Expr>,\n-                              error: MethodError<'tcx>)\n+pub fn report_method_error(&self,\n+                           span: Span,\n+                           rcvr_ty: Ty<'tcx>,\n+                           item_name: ast::Name,\n+                           rcvr_expr: Option<&hir::Expr>,\n+                           error: MethodError<'tcx>)\n {\n     // avoid suggestions when we don't know what's going on.\n     if rcvr_ty.references_error() {\n         return\n     }\n \n+    let report_candidates = |err: &mut DiagnosticBuilder,\n+                             mut sources: Vec<CandidateSource>| {\n+\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                CandidateSource::ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the item, if local to crate, else\n+                    // the impl, if local to crate (item may be defaulted), else nothing.\n+                    let item = self.impl_item(impl_did, item_name)\n+                        .or_else(|| {\n+                            self.trait_item(\n+                                self.tcx().impl_trait_ref(impl_did).unwrap().def_id,\n+\n+                                item_name\n+                            )\n+                        }).unwrap();\n+                    let note_span = self.tcx().map.span_if_local(item.def_id()).or_else(|| {\n+                        self.tcx().map.span_if_local(impl_did)\n+                    });\n+\n+                    let impl_ty = self.impl_self_ty(span, impl_did).ty;\n+\n+                    let insertion = match self.tcx().impl_trait_ref(impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => {\n+                            format!(\" of the trait `{}`\",\n+                                    self.tcx().item_path_str(trait_ref.def_id))\n+                        }\n+                    };\n+\n+                    let note_str = format!(\"candidate #{} is defined in an impl{} \\\n+                                            for the type `{}`\",\n+                                           idx + 1,\n+                                           insertion,\n+                                           impl_ty);\n+                    if let Some(note_span) = note_span {\n+                        // We have a span pointing to the method. Show note with snippet.\n+                        err.span_note(note_span, &note_str);\n+                    } else {\n+                        err.note(&note_str);\n+                    }\n+                }\n+                CandidateSource::TraitSource(trait_did) => {\n+                    let item = self.trait_item(trait_did, item_name).unwrap();\n+                    let item_span = self.tcx().map.def_id_span(item.def_id(), span);\n+                    span_note!(err, item_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1,\n+                               self.tcx().item_path_str(trait_did));\n+                }\n+            }\n+        }\n+    };\n+\n     match error {\n         MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                            unsatisfied_predicates,\n                                            out_of_scope_traits,\n                                            mode, .. }) => {\n-            let cx = fcx.tcx();\n+            let tcx = self.tcx();\n \n-            let mut err = fcx.type_error_struct(\n+            let mut err = self.type_error_struct(\n                 span,\n                 |actual| {\n                     format!(\"no {} named `{}` found for type `{}` \\\n@@ -123,16 +177,16 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // If the item has the name of a field, give a help note\n             if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n                 if let Some(field) = def.struct_variant().find_field_named(item_name) {\n-                    let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n+                    let expr_string = match tcx.sess.codemap().span_to_snippet(expr.span) {\n                         Ok(expr_string) => expr_string,\n                         _ => \"s\".into() // Default to a generic placeholder for the\n                                         // expression when we can't generate a string\n                                         // snippet\n                     };\n \n-                    let field_ty = field.ty(cx, substs);\n+                    let field_ty = field.ty(tcx, substs);\n \n-                    if is_fn_ty(&field_ty, &fcx, span) {\n+                    if self.is_fn_ty(&field_ty, span) {\n                         err.span_note(span,\n                                       &format!(\"use `({0}.{1})(...)` if you meant to call \\\n                                                the function stored in the `{1}` field\",\n@@ -144,7 +198,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             }\n \n-            if is_fn_ty(&rcvr_ty, &fcx, span) {\n+            if self.is_fn_ty(&rcvr_ty, span) {\n                 macro_rules! report_function {\n                     ($span:expr, $name:expr) => {\n                         err.note(&format!(\"{} is a function, perhaps you wish to call it\",\n@@ -153,7 +207,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n \n                 if let Some(expr) = rcvr_expr {\n-                    if let Ok (expr_string) = cx.sess.codemap().span_to_snippet(expr.span) {\n+                    if let Ok (expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                         report_function!(expr.span, expr_string);\n                     }\n                     else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n@@ -169,7 +223,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     \"found the following associated functions; to be used as \\\n                      methods, functions must have a `self` parameter\");\n \n-                report_candidates(fcx, &mut err, span, item_name, static_sources);\n+                report_candidates(&mut err, static_sources);\n             }\n \n             if !unsatisfied_predicates.is_empty() {\n@@ -186,16 +240,16 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              bound_list));\n             }\n \n-            suggest_traits_to_import(fcx, &mut err, span, rcvr_ty, item_name,\n-                                     rcvr_expr, out_of_scope_traits);\n+            self.suggest_traits_to_import(&mut err, span, rcvr_ty, item_name,\n+                                          rcvr_expr, out_of_scope_traits);\n             err.emit();\n         }\n \n         MethodError::Ambiguity(sources) => {\n-            let mut err = struct_span_err!(fcx.sess(), span, E0034,\n+            let mut err = struct_span_err!(self.sess(), span, E0034,\n                                            \"multiple applicable items in scope\");\n \n-            report_candidates(fcx, &mut err, span, item_name, sources);\n+            report_candidates(&mut err, sources);\n             err.emit();\n         }\n \n@@ -204,92 +258,30 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n                                item_name,\n-                               fcx.tcx().item_path_str(trait_def_id));\n+                               self.tcx().item_path_str(trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                         msg, pprust::expr_to_string(callee))\n             } else {\n                 msg\n             };\n-            fcx.sess().span_err(span, &msg);\n+            self.sess().span_err(span, &msg);\n         }\n \n         MethodError::PrivateMatch(def) => {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n-            fcx.tcx().sess.span_err(span, &msg);\n-        }\n-    }\n-\n-    fn report_candidates(fcx: &FnCtxt,\n-                         err: &mut DiagnosticBuilder,\n-                         span: Span,\n-                         item_name: ast::Name,\n-                         mut sources: Vec<CandidateSource>) {\n-        sources.sort();\n-        sources.dedup();\n-\n-        for (idx, source) in sources.iter().enumerate() {\n-            match *source {\n-                CandidateSource::ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the item, if local to crate, else\n-                    // the impl, if local to crate (item may be defaulted), else nothing.\n-                    let item = impl_item(fcx, impl_did, item_name)\n-                        .or_else(|| {\n-                            trait_item(\n-                                fcx,\n-                                fcx.tcx().impl_trait_ref(impl_did).unwrap().def_id,\n-                                item_name\n-                            )\n-                        }).unwrap();\n-                    let note_span = fcx.tcx().map.span_if_local(item.def_id()).or_else(|| {\n-                        fcx.tcx().map.span_if_local(impl_did)\n-                    });\n-\n-                    let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n-\n-                    let insertion = match fcx.tcx().impl_trait_ref(impl_did) {\n-                        None => format!(\"\"),\n-                        Some(trait_ref) => {\n-                            format!(\" of the trait `{}`\",\n-                                    fcx.tcx().item_path_str(trait_ref.def_id))\n-                        }\n-                    };\n-\n-                    let note_str = format!(\"candidate #{} is defined in an impl{} \\\n-                                            for the type `{}`\",\n-                                           idx + 1,\n-                                           insertion,\n-                                           impl_ty);\n-                    if let Some(note_span) = note_span {\n-                        // We have a span pointing to the method. Show note with snippet.\n-                        err.span_note(note_span, &note_str);\n-                    } else {\n-                        err.note(&note_str);\n-                    }\n-                }\n-                CandidateSource::TraitSource(trait_did) => {\n-                    let item = trait_item(fcx, trait_did, item_name).unwrap();\n-                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n-                    span_note!(err, item_span,\n-                               \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1,\n-                               fcx.tcx().item_path_str(trait_did));\n-                }\n-            }\n+            self.tcx().sess.span_err(span, &msg);\n         }\n     }\n }\n \n-\n-pub type AllTraitsVec = Vec<TraitInfo>;\n-\n-fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                      err: &mut DiagnosticBuilder,\n-                                      span: Span,\n-                                      rcvr_ty: Ty<'tcx>,\n-                                      item_name: ast::Name,\n-                                      rcvr_expr: Option<&hir::Expr>,\n-                                      valid_out_of_scope_traits: Vec<DefId>)\n+fn suggest_traits_to_import(&self,\n+                            err: &mut DiagnosticBuilder,\n+                            span: Span,\n+                            rcvr_ty: Ty<'tcx>,\n+                            item_name: ast::Name,\n+                            rcvr_expr: Option<&hir::Expr>,\n+                            valid_out_of_scope_traits: Vec<DefId>)\n {\n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n@@ -307,17 +299,17 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         for (i, trait_did) in candidates.iter().enumerate() {\n             err.help(&format!(\"candidate #{}: `use {}`\",\n                               i + 1,\n-                              fcx.tcx().item_path_str(*trait_did)));\n+                              self.tcx().item_path_str(*trait_did)));\n         }\n         return\n     }\n \n-    let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty, rcvr_expr);\n+    let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n \n     // there's no implemented traits, so lets suggest some traits to\n     // implement, by finding ones that have the item name, and are\n     // legal to implement.\n-    let mut candidates = all_traits(fcx.ccx)\n+    let mut candidates = all_traits(self.ccx)\n         .filter(|info| {\n             // we approximate the coherence rules to only suggest\n             // traits that are legal to implement by requiring that\n@@ -326,7 +318,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // implementing a trait would be legal but is rejected\n             // here).\n             (type_is_local || info.def_id.is_local())\n-                && trait_item(fcx, info.def_id, item_name).is_some()\n+                && self.trait_item(info.def_id, item_name).is_some()\n         })\n         .collect::<Vec<_>>();\n \n@@ -351,17 +343,17 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         for (i, trait_info) in candidates.iter().enumerate() {\n             err.help(&format!(\"candidate #{}: `{}`\",\n                               i + 1,\n-                              fcx.tcx().item_path_str(trait_info.def_id)));\n+                              self.tcx().item_path_str(trait_info.def_id)));\n         }\n     }\n }\n \n /// Checks whether there is a local type somewhere in the chain of\n /// autoderefs of `rcvr_ty`.\n-fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  span: Span,\n-                                  rcvr_ty: Ty<'tcx>,\n-                                  rcvr_expr: Option<&hir::Expr>) -> bool {\n+fn type_derefs_to_local(&self,\n+                        span: Span,\n+                        rcvr_ty: Ty<'tcx>,\n+                        rcvr_expr: Option<&hir::Expr>) -> bool {\n     fn is_local(ty: Ty) -> bool {\n         match ty.sty {\n             ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n@@ -381,19 +373,22 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // This occurs for UFCS desugaring of `T::method`, where there is no\n     // receiver expression for the method call, and thus no autoderef.\n     if rcvr_expr.is_none() {\n-        return is_local(fcx.resolve_type_vars_if_possible(rcvr_ty));\n+        return is_local(self.resolve_type_vars_if_possible(rcvr_ty));\n     }\n \n-    check::autoderef(fcx, span, rcvr_ty, || None,\n-                     check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n-                     |ty, _| {\n+    self.autoderef(span, rcvr_ty, || None,\n+                   check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n+                   |ty, _| {\n         if is_local(ty) {\n             Some(())\n         } else {\n             None\n         }\n     }).2.is_some()\n }\n+}\n+\n+pub type AllTraitsVec = Vec<TraitInfo>;\n \n #[derive(Copy, Clone)]\n pub struct TraitInfo {"}, {"sha": "0da41ba41e415a0c9036cd1c2f6cf72c3d9b994e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1002, "deletions": 1081, "changes": 2083, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2"}, {"sha": "d86813e2807f0c1fe96f9d5119d6339bf8c25440", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 96, "deletions": 106, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -10,55 +10,49 @@\n \n //! Code related to processing overloaded binary and unary operators.\n \n-use super::{\n-    check_expr,\n-    check_expr_coercable_to_type,\n-    check_expr_with_lvalue_pref,\n-    demand,\n-    method,\n-    FnCtxt,\n-};\n+use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n use syntax::ast;\n use syntax::parse::token;\n use rustc::hir;\n \n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Check a `a <op>= b`\n-pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                   expr: &'tcx hir::Expr,\n-                                   op: hir::BinOp,\n-                                   lhs_expr: &'tcx hir::Expr,\n-                                   rhs_expr: &'tcx hir::Expr)\n+pub fn check_binop_assign(&self,\n+                          expr: &'tcx hir::Expr,\n+                          op: hir::BinOp,\n+                          lhs_expr: &'tcx hir::Expr,\n+                          rhs_expr: &'tcx hir::Expr)\n {\n-    check_expr_with_lvalue_pref(fcx, lhs_expr, PreferMutLvalue);\n+    self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n-    let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n+    let lhs_ty = self.resolve_type_vars_if_possible(self.expr_ty(lhs_expr));\n     let (rhs_ty, return_ty) =\n-        check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n-    let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n+        self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n+    let rhs_ty = self.resolve_type_vars_if_possible(rhs_ty);\n \n     if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-        enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-        fcx.write_nil(expr.id);\n+        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+        self.write_nil(expr.id);\n     } else {\n-        fcx.write_ty(expr.id, return_ty);\n+        self.write_ty(expr.id, return_ty);\n     }\n \n-    let tcx = fcx.tcx();\n+    let tcx = self.tcx();\n     if !tcx.expr_is_lval(lhs_expr) {\n         span_err!(tcx.sess, lhs_expr.span, E0067, \"invalid left-hand side expression\");\n     }\n }\n \n /// Check a potentially overloaded binary operator.\n-pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                             expr: &'tcx hir::Expr,\n-                             op: hir::BinOp,\n-                             lhs_expr: &'tcx hir::Expr,\n-                             rhs_expr: &'tcx hir::Expr)\n+pub fn check_binop(&self,\n+                   expr: &'tcx hir::Expr,\n+                   op: hir::BinOp,\n+                   lhs_expr: &'tcx hir::Expr,\n+                   rhs_expr: &'tcx hir::Expr)\n {\n-    let tcx = fcx.ccx.tcx;\n+    let tcx = self.tcx();\n \n     debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n            expr.id,\n@@ -67,22 +61,22 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            lhs_expr,\n            rhs_expr);\n \n-    check_expr(fcx, lhs_expr);\n-    let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n+    self.check_expr(lhs_expr);\n+    let lhs_ty = self.resolve_type_vars_if_possible(self.expr_ty(lhs_expr));\n \n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             // && and || are a simple case.\n-            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-            check_expr_coercable_to_type(fcx, rhs_expr, tcx.mk_bool());\n-            fcx.write_ty(expr.id, tcx.mk_bool());\n+            self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+            self.write_ty(expr.id, tcx.mk_bool());\n         }\n         _ => {\n             // Otherwise, we always treat operators as if they are\n             // overloaded. This is the way to be most flexible w/r/t\n             // types that get inferred.\n             let (rhs_ty, return_ty) =\n-                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::No);\n+                self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::No);\n \n             // Supply type inference hints if relevant. Probably these\n             // hints should be enforced during select as part of the\n@@ -96,36 +90,36 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // deduce that the result type should be `u32`, even\n             // though we don't know yet what type 2 has and hence\n             // can't pin this down to a specific impl.\n-            let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n+            let rhs_ty = self.resolve_type_vars_if_possible(rhs_ty);\n             if\n                 !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n                 is_builtin_binop(lhs_ty, rhs_ty, op)\n             {\n                 let builtin_return_ty =\n-                    enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-                demand::suptype(fcx, expr.span, builtin_return_ty, return_ty);\n+                    self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n             }\n \n-            fcx.write_ty(expr.id, return_ty);\n+            self.write_ty(expr.id, return_ty);\n         }\n     }\n }\n \n-fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                         lhs_expr: &'tcx hir::Expr,\n-                                         lhs_ty: Ty<'tcx>,\n-                                         rhs_expr: &'tcx hir::Expr,\n-                                         rhs_ty: Ty<'tcx>,\n-                                         op: hir::BinOp)\n-                                         -> Ty<'tcx>\n+fn enforce_builtin_binop_types(&self,\n+                               lhs_expr: &'tcx hir::Expr,\n+                               lhs_ty: Ty<'tcx>,\n+                               rhs_expr: &'tcx hir::Expr,\n+                               rhs_ty: Ty<'tcx>,\n+                               op: hir::BinOp)\n+                               -> Ty<'tcx>\n {\n     debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n-    let tcx = fcx.tcx();\n+    let tcx = self.tcx();\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n-            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-            demand::suptype(fcx, rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+            self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n             tcx.mk_bool()\n         }\n \n@@ -137,56 +131,56 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         BinOpCategory::Math |\n         BinOpCategory::Bitwise => {\n             // both LHS and RHS and result will have the same type\n-            demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n+            self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n             lhs_ty\n         }\n \n         BinOpCategory::Comparison => {\n             // both LHS and RHS and result will have the same type\n-            demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n+            self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n             tcx.mk_bool()\n         }\n     }\n }\n \n-fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    expr: &'tcx hir::Expr,\n-                                    lhs_expr: &'tcx hir::Expr,\n-                                    lhs_ty: Ty<'tcx>,\n-                                    rhs_expr: &'tcx hir::Expr,\n-                                    op: hir::BinOp,\n-                                    is_assign: IsAssign)\n-                                    -> (Ty<'tcx>, Ty<'tcx>)\n+fn check_overloaded_binop(&self,\n+                          expr: &'tcx hir::Expr,\n+                          lhs_expr: &'tcx hir::Expr,\n+                          lhs_ty: Ty<'tcx>,\n+                          rhs_expr: &'tcx hir::Expr,\n+                          op: hir::BinOp,\n+                          is_assign: IsAssign)\n+                          -> (Ty<'tcx>, Ty<'tcx>)\n {\n     debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, is_assign={:?})\",\n            expr.id,\n            lhs_ty,\n            is_assign);\n \n-    let (name, trait_def_id) = name_and_trait_def_id(fcx, op, is_assign);\n+    let (name, trait_def_id) = self.name_and_trait_def_id(op, is_assign);\n \n     // NB: As we have not yet type-checked the RHS, we don't have the\n     // type at hand. Make a variable to represent it. The whole reason\n     // for this indirection is so that, below, we can check the expr\n     // using this variable as the expected type, which sometimes lets\n     // us do better coercions than we would be able to do otherwise,\n     // particularly for things like `String + &String`.\n-    let rhs_ty_var = fcx.infcx().next_ty_var();\n+    let rhs_ty_var = self.infcx().next_ty_var();\n \n-    let return_ty = match lookup_op_method(fcx, expr, lhs_ty, vec![rhs_ty_var],\n-                                           token::intern(name), trait_def_id,\n-                                           lhs_expr) {\n+    let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n+                                                token::intern(name), trait_def_id,\n+                                                lhs_expr) {\n         Ok(return_ty) => return_ty,\n         Err(()) => {\n             // error types are considered \"builtin\"\n             if !lhs_ty.references_error() {\n                 if let IsAssign::Yes = is_assign {\n-                    span_err!(fcx.tcx().sess, lhs_expr.span, E0368,\n+                    span_err!(self.tcx().sess, lhs_expr.span, E0368,\n                               \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n                               op.node.as_str(),\n                               lhs_ty);\n                 } else {\n-                    let mut err = struct_span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n+                    let mut err = struct_span_err!(self.tcx().sess, lhs_expr.span, E0369,\n                         \"binary operation `{}` cannot be applied to type `{}`\",\n                         op.node.as_str(),\n                         lhs_ty);\n@@ -214,46 +208,46 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     err.emit();\n                 }\n             }\n-            fcx.tcx().types.err\n+            self.tcx().types.err\n         }\n     };\n \n     // see `NB` above\n-    check_expr_coercable_to_type(fcx, rhs_expr, rhs_ty_var);\n+    self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n \n     (rhs_ty_var, return_ty)\n }\n \n-pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 op_str: &str,\n-                                 mname: &str,\n-                                 trait_did: Option<DefId>,\n-                                 ex: &'tcx hir::Expr,\n-                                 operand_expr: &'tcx hir::Expr,\n-                                 operand_ty: Ty<'tcx>,\n-                                 op: hir::UnOp)\n-                                 -> Ty<'tcx>\n+pub fn check_user_unop(&self,\n+                       op_str: &str,\n+                       mname: &str,\n+                       trait_did: Option<DefId>,\n+                       ex: &'tcx hir::Expr,\n+                       operand_expr: &'tcx hir::Expr,\n+                       operand_ty: Ty<'tcx>,\n+                       op: hir::UnOp)\n+                       -> Ty<'tcx>\n {\n     assert!(op.is_by_value());\n-    match lookup_op_method(fcx, ex, operand_ty, vec![],\n-                           token::intern(mname), trait_did,\n-                           operand_expr) {\n+    match self.lookup_op_method(ex, operand_ty, vec![],\n+                                token::intern(mname), trait_did,\n+                                operand_expr) {\n         Ok(t) => t,\n         Err(()) => {\n-            fcx.type_error_message(ex.span, |actual| {\n+            self.type_error_message(ex.span, |actual| {\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n             }, operand_ty, None);\n-            fcx.tcx().types.err\n+            self.tcx().types.err\n         }\n     }\n }\n \n-fn name_and_trait_def_id(fcx: &FnCtxt,\n+fn name_and_trait_def_id(&self,\n                          op: hir::BinOp,\n                          is_assign: IsAssign)\n                          -> (&'static str, Option<DefId>) {\n-    let lang = &fcx.tcx().lang_items;\n+    let lang = &self.tcx().lang_items;\n \n     if let IsAssign::Yes = is_assign {\n         match op.node {\n@@ -299,14 +293,14 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n     }\n }\n \n-fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                              expr: &'tcx hir::Expr,\n-                              lhs_ty: Ty<'tcx>,\n-                              other_tys: Vec<Ty<'tcx>>,\n-                              opname: ast::Name,\n-                              trait_did: Option<DefId>,\n-                              lhs_expr: &'a hir::Expr)\n-                              -> Result<Ty<'tcx>,()>\n+fn lookup_op_method(&self,\n+                    expr: &'tcx hir::Expr,\n+                    lhs_ty: Ty<'tcx>,\n+                    other_tys: Vec<Ty<'tcx>>,\n+                    opname: ast::Name,\n+                    trait_did: Option<DefId>,\n+                    lhs_expr: &'a hir::Expr)\n+                    -> Result<Ty<'tcx>,()>\n {\n     debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, trait_did={:?}, lhs_expr={:?})\",\n            expr,\n@@ -317,15 +311,14 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     let method = match trait_did {\n         Some(trait_did) => {\n-            method::lookup_in_trait_adjusted(fcx,\n-                                             expr.span,\n-                                             Some(lhs_expr),\n-                                             opname,\n-                                             trait_did,\n-                                             0,\n-                                             false,\n-                                             lhs_ty,\n-                                             Some(other_tys))\n+            self.lookup_method_in_trait_adjusted(expr.span,\n+                                                 Some(lhs_expr),\n+                                                 opname,\n+                                                 trait_did,\n+                                                 0,\n+                                                 false,\n+                                                 lhs_ty,\n+                                                 Some(other_tys))\n         }\n         None => None\n     };\n@@ -336,18 +329,19 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n             // HACK(eddyb) Fully qualified path to work around a resolve bug.\n             let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n-            fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+            self.inh.tables.borrow_mut().method_map.insert(method_call, method);\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n             let ret_ty = method_ty.fn_ret();\n-            Ok(fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap())\n+            Ok(self.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap())\n         }\n         None => {\n             Err(())\n         }\n     }\n }\n+}\n \n // Binary operator categories. These categories summarize the behavior\n // with respect to the builtin operationrs supported.\n@@ -428,11 +422,7 @@ enum IsAssign {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/trans after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>,\n-                          rhs: Ty<'tcx>,\n-                          op: hir::BinOp)\n-                          -> bool\n-{\n+fn is_builtin_binop(lhs: Ty, rhs: Ty, op: hir::BinOp) -> bool {\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             true"}, {"sha": "76c387ccc2c8deb34b638b7878a3ca194106d09c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -112,9 +112,10 @@ macro_rules! ignore_err {\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-pub fn regionck_expr(fcx: &FnCtxt, e: &hir::Expr) {\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(e.id), e.id, Subject(e.id));\n-    if fcx.err_count_since_creation() == 0 {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn regionck_expr(&self, e: &hir::Expr) {\n+    let mut rcx = Rcx::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n+    if self.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_expr(e);\n         rcx.visit_region_obligations(e.id);\n@@ -124,43 +125,44 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &hir::Expr) {\n \n /// Region checking during the WF phase for items. `wf_tys` are the\n /// types from which we should derive implied bounds, if any.\n-pub fn regionck_item<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                              item_id: ast::NodeId,\n-                              span: Span,\n-                              wf_tys: &[Ty<'tcx>]) {\n+pub fn regionck_item(&self,\n+                     item_id: ast::NodeId,\n+                     span: Span,\n+                     wf_tys: &[Ty<'tcx>]) {\n     debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(item_id), item_id, Subject(item_id));\n-    let tcx = fcx.tcx();\n-    rcx.free_region_map\n-       .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n+    let mut rcx = Rcx::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n+    let tcx = self.tcx();\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx,\n+        &self.infcx().parameter_environment.caller_bounds);\n     rcx.relate_free_regions(wf_tys, item_id, span);\n     rcx.visit_region_obligations(item_id);\n     rcx.resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_fn(fcx: &FnCtxt,\n+pub fn regionck_fn(&self,\n                    fn_id: ast::NodeId,\n                    fn_span: Span,\n                    decl: &hir::FnDecl,\n                    blk: &hir::Block) {\n     debug!(\"regionck_fn(id={})\", fn_id);\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n+    let mut rcx = Rcx::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n \n-    if fcx.err_count_since_creation() == 0 {\n+    if self.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n     }\n \n-    let tcx = fcx.tcx();\n-    rcx.free_region_map\n-       .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n+    let tcx = self.tcx();\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx,\n+        &self.infcx().parameter_environment.caller_bounds);\n \n     rcx.resolve_regions_and_report_errors();\n \n     // For the top-level fn, store the free-region-map. We don't store\n     // any map for closures; they just share the same map as the\n     // function that created them.\n-    fcx.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n+    self.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n+}\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -207,7 +209,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n-        self.fcx.ccx.tcx\n+        self.fcx.tcx()\n     }\n \n     pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {"}, {"sha": "629b30354043cc06699d5e5b8a81095b9b1b4e34", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -42,7 +42,6 @@\n \n use super::FnCtxt;\n \n-use check::demand;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n@@ -57,34 +56,30 @@ use rustc::hir::intravisit::{self, Visitor};\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-pub fn closure_analyze_fn(fcx: &FnCtxt,\n-                          _id: ast::NodeId,\n-                          _decl: &hir::FnDecl,\n-                          body: &hir::Block)\n-{\n-    let mut seed = SeedBorrowKind::new(fcx);\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn closure_analyze_fn(&self, body: &hir::Block) {\n+    let mut seed = SeedBorrowKind::new(self);\n     seed.visit_block(body);\n     let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-    let mut adjust = AdjustBorrowKind::new(fcx, &closures_with_inferred_kinds);\n+    let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n     adjust.visit_block(body);\n \n     // it's our job to process these.\n-    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n+    assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n }\n \n-pub fn closure_analyze_const(fcx: &FnCtxt,\n-                             body: &hir::Expr)\n-{\n-    let mut seed = SeedBorrowKind::new(fcx);\n+pub fn closure_analyze_const(&self, body: &hir::Expr) {\n+    let mut seed = SeedBorrowKind::new(self);\n     seed.visit_expr(body);\n     let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-    let mut adjust = AdjustBorrowKind::new(fcx, &closures_with_inferred_kinds);\n+    let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n     adjust.visit_expr(body);\n \n     // it's our job to process these.\n-    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n+    assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+}\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -221,7 +216,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n                id, closure_substs, final_upvar_tys);\n         for (&upvar_ty, final_upvar_ty) in closure_substs.upvar_tys.iter().zip(final_upvar_tys) {\n-            demand::eqtype(self.fcx, span, final_upvar_ty, upvar_ty);\n+            self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n         // Now we must process and remove any deferred resolutions,"}, {"sha": "9e8cfa42f4ed945aecf4cc9b73eca93efdcfb6e7", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n+use check::{FnCtxt, Inherited};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use hir::def_id::DefId;\n@@ -108,14 +108,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             hir::ItemStruct(ref struct_def, ref ast_generics) => {\n                 self.check_type_defn(item, |fcx| {\n-                    vec![struct_variant(fcx, struct_def)]\n+                    vec![fcx.struct_variant(struct_def)]\n                 });\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n             hir::ItemEnum(ref enum_def, ref ast_generics) => {\n                 self.check_type_defn(item, |fcx| {\n-                    enum_variants(fcx, enum_def)\n+                    fcx.enum_variants(enum_def)\n                 });\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n@@ -137,7 +137,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             let (mut implied_bounds, self_ty) = match item.container() {\n                 ty::TraitContainer(_) => (vec![], fcx.tcx().mk_self_type()),\n-                ty::ImplContainer(def_id) => (impl_implied_bounds(fcx, def_id, span),\n+                ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                               fcx.tcx().lookup_item_type(def_id).ty)\n             };\n \n@@ -182,10 +182,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n         let tables = RefCell::new(ty::Tables::empty());\n         let inh = Inherited::new(ccx.tcx, &tables, param_env);\n-        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnDiverging, id);\n+        let fcx = FnCtxt::new(ccx, &inh, ty::FnDiverging, id);\n         let wf_tys = f(&fcx, self);\n         fcx.select_all_obligations_or_error();\n-        regionck::regionck_item(&fcx, id, span, &wf_tys);\n+        fcx.regionck_item(id, span, &wf_tys);\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n@@ -229,7 +229,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let trait_def_id = self.tcx().map.local_def_id(item.id);\n \n-        if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n+        if self.tcx().trait_has_default_impl(trait_def_id) {\n             if !items.is_empty() {\n                 error_380(self.ccx, item.span);\n             }\n@@ -327,7 +327,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            impl_implied_bounds(fcx, fcx.tcx().map.local_def_id(item.id), item.span)\n+            fcx.impl_implied_bounds(fcx.tcx().map.local_def_id(item.id), item.span)\n         });\n     }\n \n@@ -554,55 +554,48 @@ struct AdtField<'tcx> {\n     span: Span,\n }\n \n-fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            struct_def: &hir::VariantData)\n-                            -> AdtVariant<'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields().iter()\n         .map(|field| {\n-            let field_ty = fcx.tcx().node_id_to_type(field.id);\n-            let field_ty = fcx.instantiate_type_scheme(field.span,\n-                                                       &fcx.inh\n-                                                           .infcx\n-                                                           .parameter_environment\n-                                                           .free_substs,\n-                                                       &field_ty);\n+            let field_ty = self.tcx().node_id_to_type(field.id);\n+            let field_ty = self.instantiate_type_scheme(field.span,\n+                                                        &self.infcx()\n+                                                             .parameter_environment\n+                                                             .free_substs,\n+                                                        &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n         .collect();\n     AdtVariant { fields: fields }\n }\n \n-fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                           enum_def: &hir::EnumDef)\n-                           -> Vec<AdtVariant<'tcx>> {\n+fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n     enum_def.variants.iter()\n-        .map(|variant| struct_variant(fcx, &variant.node.data))\n+        .map(|variant| self.struct_variant(&variant.node.data))\n         .collect()\n }\n \n-fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n-                                  impl_def_id: DefId,\n-                                  span: Span)\n-                                  -> Vec<Ty<'tcx>>\n-{\n-    let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-    match fcx.tcx().impl_trait_ref(impl_def_id) {\n+fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n+    let free_substs = &self.inh.infcx.parameter_environment.free_substs;\n+    match self.tcx().impl_trait_ref(impl_def_id) {\n         Some(ref trait_ref) => {\n             // Trait impl: take implied bounds from all types that\n             // appear in the trait reference.\n-            let trait_ref = fcx.instantiate_type_scheme(span, free_substs, trait_ref);\n+            let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n             trait_ref.substs.types.as_slice().to_vec()\n         }\n \n         None => {\n             // Inherent impl: take implied bounds from the self type.\n-            let self_ty = fcx.tcx().lookup_item_type(impl_def_id).ty;\n-            let self_ty = fcx.instantiate_type_scheme(span, free_substs, &self_ty);\n+            let self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n+            let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n             vec![self_ty]\n         }\n     }\n }\n+}\n \n fn error_192(ccx: &CrateCtxt, span: Span) {\n     span_err!(ccx.tcx.sess, span, E0192,"}, {"sha": "f8e4cb0eb65b3ca7e6cbad9b4b8ddb08e161fbca", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ee56e862071c3cea4c5fb7cf12444591e0b3f2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d7ee56e862071c3cea4c5fb7cf12444591e0b3f2", "patch": "@@ -34,28 +34,27 @@ use rustc::hir;\n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n \n-pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &hir::Expr) {\n-    assert_eq!(fcx.writeback_errors.get(), false);\n-    let mut wbcx = WritebackCx::new(fcx);\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n+    assert_eq!(self.writeback_errors.get(), false);\n+    let mut wbcx = WritebackCx::new(self);\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n     wbcx.visit_liberated_fn_sigs();\n     wbcx.visit_fru_field_types();\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n-                               decl: &hir::FnDecl,\n-                               blk: &hir::Block) {\n-    assert_eq!(fcx.writeback_errors.get(), false);\n-    let mut wbcx = WritebackCx::new(fcx);\n+pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n+    assert_eq!(self.writeback_errors.get(), false);\n+    let mut wbcx = WritebackCx::new(self);\n     wbcx.visit_block(blk);\n     for arg in &decl.inputs {\n         wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n         wbcx.visit_pat(&arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &arg.pat) {\n+        if !pat_util::pat_is_binding(&self.tcx().def_map.borrow(), &arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }\n@@ -65,6 +64,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_liberated_fn_sigs();\n     wbcx.visit_fru_field_types();\n }\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // The Writerback context. This visitor walks the AST, checking the"}]}