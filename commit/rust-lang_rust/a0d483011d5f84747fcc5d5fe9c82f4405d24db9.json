{"sha": "a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZDQ4MzAxMWQ1Zjg0NzQ3ZmNjNWQ1ZmU5YzgyZjQ0MDVkMjRkYjk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T13:58:41Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T13:58:41Z"}, "message": "Merge #425\n\n425: remove id arena r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "25bc6aab1e4328e73446876b274e7dcaff7aa915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25bc6aab1e4328e73446876b274e7dcaff7aa915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "html_url": "https://github.com/rust-lang/rust/commit/a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "html_url": "https://github.com/rust-lang/rust/commit/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6"}, {"sha": "3fe6f422f9ef13b9171dbeab0c5c427f729f9983", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe6f422f9ef13b9171dbeab0c5c427f729f9983", "html_url": "https://github.com/rust-lang/rust/commit/3fe6f422f9ef13b9171dbeab0c5c427f729f9983"}], "stats": {"total": 354, "additions": 167, "deletions": 187}, "files": [{"sha": "b060586884366d99d3c8891db687e74877bc6051", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -370,11 +370,6 @@ name = \"humansize\"\n version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"id-arena\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"idna\"\n version = \"0.1.5\"\n@@ -683,6 +678,10 @@ dependencies = [\n  \"unicase 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ra_arena\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n@@ -729,9 +728,9 @@ dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_editor 0.1.0\",\n  \"ra_syntax 0.1.0\",\n@@ -808,6 +807,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_arena 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1529,7 +1529,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humansize 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6cab2627acfc432780848602f3f558f7e9dd427352224b0d9324025796d2a5e\"\n-\"checksum id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a7250033feafee46a1cecd2c2616a64aec1d064f38c9ae2bdd297728542843e\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9c7f9bb8aee47fc16d535a705f7867a9fc83bb822e5e1043bb98e77ffeed3c\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\""}, {"sha": "9594e2d0f518d95bfb3f82f29f4d5d2d9218725c", "filename": "crates/ra_arena/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2FCargo.toml?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -0,0 +1,5 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_arena\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]"}, {"sha": "a5eeb4118e0464c7eb56b69dc9bb1d02b29226ef", "filename": "crates/ra_arena/src/lib.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -0,0 +1,97 @@\n+//! Yet another index-based arena.\n+\n+use std::{\n+    fmt,\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct RawId(u32);\n+\n+impl From<RawId> for u32 {\n+    fn from(raw: RawId) -> u32 {\n+        raw.0\n+    }\n+}\n+\n+impl From<u32> for RawId {\n+    fn from(id: u32) -> RawId {\n+        RawId(id)\n+    }\n+}\n+\n+impl fmt::Debug for RawId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Display for RawId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Arena<ID: ArenaId, T> {\n+    data: Vec<T>,\n+    _ty: PhantomData<ID>,\n+}\n+\n+#[macro_export]\n+macro_rules! impl_arena_id {\n+    ($name:ident) => {\n+        impl $crate::ArenaId for $name {\n+            fn from_raw(raw: $crate::RawId) -> Self {\n+                $name(raw)\n+            }\n+            fn into_raw(self) -> $crate::RawId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+pub trait ArenaId {\n+    fn from_raw(raw: RawId) -> Self;\n+    fn into_raw(self) -> RawId;\n+}\n+\n+impl<ID: ArenaId, T> Arena<ID, T> {\n+    pub fn alloc(&mut self, value: T) -> ID {\n+        let id = RawId(self.data.len() as u32);\n+        self.data.push(value);\n+        ID::from_raw(id)\n+    }\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n+        self.data\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, value)| (ID::from_raw(RawId(idx as u32)), value))\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Default for Arena<ID, T> {\n+    fn default() -> Arena<ID, T> {\n+        Arena {\n+            data: Vec::new(),\n+            _ty: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<ID: ArenaId, T> Index<ID> for Arena<ID, T> {\n+    type Output = T;\n+    fn index(&self, idx: ID) -> &T {\n+        let idx = idx.into_raw().0 as usize;\n+        &self.data[idx]\n+    }\n+}\n+\n+impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n+    fn index_mut(&mut self, idx: ID) -> &mut T {\n+        let idx = idx.into_raw().0 as usize;\n+        &mut self.data[idx]\n+    }\n+}"}, {"sha": "8c0cf4b866e2e90c9e7b32ab058b9499362bc2d1", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -11,9 +11,9 @@ relative-path = \"0.4.0\"\n salsa = \"0.9.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.7.0\"\n-id-arena = \"2.0\"\n ena = \"0.11\"\n ra_syntax = { path = \"../ra_syntax\" }\n+ra_arena = { path = \"../ra_arena\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_db = { path = \"../ra_db\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "d4f9d9cb904231c34bb6b28865517def9690639b", "filename": "crates/ra_hir/src/arena.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Farena.rs?ref=821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "patch": "@@ -1,66 +0,0 @@\n-//! A simple id-based arena, similar to https://github.com/fitzgen/id-arena.\n-//! We use our own version for more compact id's and to allow inherent impls\n-//! on Ids.\n-\n-use std::{\n-    fmt,\n-    hash::{Hash, Hasher},\n-    marker::PhantomData,\n-};\n-\n-pub struct Id<T> {\n-    idx: u32,\n-    _ty: PhantomData<fn() -> T>,\n-}\n-\n-impl<T> fmt::Debug for Id<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Id\").field(&self.idx).finish()\n-    }\n-}\n-impl<T> Copy for Id<T> {}\n-impl<T> Clone for Id<T> {\n-    fn clone(&self) -> Id<T> {\n-        *self\n-    }\n-}\n-\n-impl<T> PartialEq for Id<T> {\n-    fn eq(&self, other: &Id<T>) -> bool {\n-        self.idx == other.idx\n-    }\n-}\n-\n-impl<T> Eq for Id<T> {}\n-\n-impl<T> Hash for Id<T> {\n-    fn hash<H: Hasher>(&self, h: &mut H) {\n-        self.idx.hash(h);\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ArenaBehavior<T> {\n-    _ty: PhantomData<T>,\n-}\n-\n-impl<T> id_arena::ArenaBehavior for ArenaBehavior<T> {\n-    type Id = Id<T>;\n-    fn new_arena_id() -> u32 {\n-        0\n-    }\n-    fn new_id(_arena_id: u32, index: usize) -> Id<T> {\n-        Id {\n-            idx: index as u32,\n-            _ty: PhantomData,\n-        }\n-    }\n-    fn index(id: Id<T>) -> usize {\n-        id.idx as usize\n-    }\n-    fn arena_id(_id: Id<T>) -> u32 {\n-        0\n-    }\n-}\n-\n-pub(crate) type Arena<T> = id_arena::Arena<T, ArenaBehavior<T>>;"}, {"sha": "42bfe4f3251670858528dcfd8a4b5ef02146d486", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -5,19 +5,19 @@ use ra_syntax::{\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n };\n+use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::LocalSyntaxPtr;\n \n-use crate::{\n-    arena::{Arena, Id},\n-    Name, AsName,\n-};\n+use crate::{Name, AsName};\n \n-pub(crate) type ScopeId = Id<ScopeData>;\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ScopeId(RawId);\n+impl_arena_id!(ScopeId);\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct FnScopes {\n     pub self_param: Option<LocalSyntaxPtr>,\n-    scopes: Arena<ScopeData>,\n+    scopes: Arena<ScopeId, ScopeData>,\n     scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n }\n "}, {"sha": "66adacc7d4ace54f11dd43ba4d9892df7edf97bb", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -1,10 +1,8 @@\n use ra_db::{SourceRootId, LocationIntener, Cancelable, FileId};\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, SourceFile, AstNode, ast};\n+use ra_arena::{Arena, RawId, impl_arena_id};\n \n-use crate::{\n-    HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum,\n-    arena::{Arena, Id},\n-};\n+use crate::{HirDatabase, PerNs, ModuleId, Module, Def, Function, Struct, Enum};\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -206,7 +204,9 @@ impl DefKind {\n \n /// Identifier of item within a specific file. This is stable over reparses, so\n /// it's OK to use it as a salsa key/value.\n-pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct SourceFileItemId(RawId);\n+impl_arena_id!(SourceFileItemId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SourceItemId {\n@@ -219,7 +219,7 @@ pub struct SourceItemId {\n #[derive(Debug, PartialEq, Eq)]\n pub struct SourceFileItems {\n     file_id: HirFileId,\n-    arena: Arena<SyntaxNode>,\n+    arena: Arena<SourceFileItemId, SyntaxNode>,\n }\n \n impl SourceFileItems {"}, {"sha": "344b543b6e4d319dcac9b3bb7469ff3976ef846e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -19,7 +19,6 @@ pub mod db;\n mod mock;\n mod query_definitions;\n mod path;\n-mod arena;\n pub mod source_binder;\n \n mod ids;"}, {"sha": "c70dc54dd946d07479cd48eda02b673db5b81dcb", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -9,14 +9,14 @@ use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     SyntaxNode,\n };\n+use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n     Def, DefKind, DefLoc, DefId,\n     Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n     HirFileId,\n-    arena::{Arena, Id},\n };\n \n pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n@@ -173,6 +173,14 @@ impl Module {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ModuleId(RawId);\n+impl_arena_id!(ModuleId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct LinkId(RawId);\n+impl_arena_id!(LinkId);\n+\n /// Physically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n /// single module, but it is not nessary the case.\n@@ -182,8 +190,8 @@ impl Module {\n /// always have one parent).\n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ModuleTree {\n-    mods: Arena<ModuleData>,\n-    links: Arena<LinkData>,\n+    mods: Arena<ModuleId, ModuleData>,\n+    links: Arena<LinkId, LinkData>,\n }\n \n impl ModuleTree {\n@@ -210,9 +218,6 @@ pub(crate) enum ModuleSourceNode {\n     Module(ast::ModuleNode),\n }\n \n-pub type ModuleId = Id<ModuleData>;\n-type LinkId = Id<LinkData>;\n-\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Problem {\n     UnresolvedModule {"}, {"sha": "60d9671dee7b139049d7c67c5b5c554802a371ea", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -350,7 +350,7 @@ fn on_notification(\n                 .write()\n                 .add_file_overlay(&path, params.text_document.text)\n             {\n-                subs.add_sub(FileId(file_id.0));\n+                subs.add_sub(FileId(file_id.0.into()));\n             }\n             return Ok(());\n         }\n@@ -379,7 +379,7 @@ fn on_notification(\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n             if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n-                subs.remove_sub(FileId(file_id.0));\n+                subs.remove_sub(FileId(file_id.0.into()));\n             }\n             let params = req::PublishDiagnosticsParams {\n                 uri,"}, {"sha": "4e895a9a9ea0892ce021afedc9065305e5c64e8a", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -337,7 +337,10 @@ pub fn handle_runnables(\n                 None => return Ok(None),\n             };\n             let file_id = world.analysis().crate_root(crate_id)?;\n-            let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0));\n+            let path = world\n+                .vfs\n+                .read()\n+                .file2path(ra_vfs::VfsFile(file_id.0.into()));\n             let res = world.workspaces.iter().find_map(|ws| {\n                 let tgt = ws.target_by_root(&path)?;\n                 let res = CargoTargetSpec {"}, {"sha": "ebf2b15ccd80d120f9c05d0e672d00647e2bc4ec", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -49,7 +49,7 @@ impl ServerWorldState {\n         let (mut vfs, roots) = Vfs::new(roots);\n         for r in roots {\n             let is_local = vfs.root2path(r).starts_with(&root);\n-            change.add_root(SourceRootId(r.0), is_local);\n+            change.add_root(SourceRootId(r.0.into()), is_local);\n         }\n \n         let mut crate_graph = CrateGraph::default();\n@@ -60,7 +60,7 @@ impl ServerWorldState {\n                 for tgt in pkg.targets(ws) {\n                     let root = tgt.root(ws);\n                     if let Some(file_id) = vfs.load(root) {\n-                        let file_id = FileId(file_id.0);\n+                        let file_id = FileId(file_id.0.into());\n                         let crate_id = crate_graph.add_crate_root(file_id);\n                         if tgt.kind(ws) == TargetKind::Lib {\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -113,14 +113,19 @@ impl ServerWorldState {\n                     if root_path.starts_with(&self.root) {\n                         self.roots_to_scan -= 1;\n                         for (file, path, text) in files {\n-                            change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                            change.add_file(\n+                                SourceRootId(root.0.into()),\n+                                FileId(file.0.into()),\n+                                path,\n+                                text,\n+                            );\n                         }\n                     } else {\n                         let files = files\n                             .into_iter()\n-                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0), path, text))\n+                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0.into()), path, text))\n                             .collect();\n-                        libs.push((SourceRootId(root.0), files));\n+                        libs.push((SourceRootId(root.0.into()), files));\n                     }\n                 }\n                 VfsChange::AddFile {\n@@ -129,13 +134,18 @@ impl ServerWorldState {\n                     path,\n                     text,\n                 } => {\n-                    change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                    change.add_file(\n+                        SourceRootId(root.0.into()),\n+                        FileId(file.0.into()),\n+                        path,\n+                        text,\n+                    );\n                 }\n                 VfsChange::RemoveFile { root, file, path } => {\n-                    change.remove_file(SourceRootId(root.0), FileId(file.0), path)\n+                    change.remove_file(SourceRootId(root.0.into()), FileId(file.0.into()), path)\n                 }\n                 VfsChange::ChangeFile { file, text } => {\n-                    change.change_file(FileId(file.0), text);\n+                    change.change_file(FileId(file.0.into()), text);\n                 }\n             }\n         }\n@@ -173,18 +183,18 @@ impl ServerWorld {\n             .read()\n             .path2file(&path)\n             .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))?;\n-        Ok(FileId(file.0))\n+        Ok(FileId(file.0.into()))\n     }\n \n     pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n-        let path = self.vfs.read().file2path(VfsFile(id.0));\n+        let path = self.vfs.read().file2path(VfsFile(id.0.into()));\n         let url = Url::from_file_path(&path)\n             .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;\n         Ok(url)\n     }\n \n     pub fn path_to_uri(&self, root: SourceRootId, path: &RelativePathBuf) -> Result<Url> {\n-        let base = self.vfs.read().root2path(VfsRoot(root.0));\n+        let base = self.vfs.read().root2path(VfsRoot(root.0.into()));\n         let path = path.to_path(base);\n         let url = Url::from_file_path(&path)\n             .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;"}, {"sha": "e637063c97b34d97149edbd5b98a852648f76fe6", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -12,6 +12,7 @@ crossbeam-channel = \"0.3.5\"\n log = \"0.4.6\"\n \n thread_worker = { path = \"../thread_worker\" }\n+ra_arena = { path = \"../ra_arena\" }\n \n [dev-dependencies]\n tempfile = \"3\""}, {"sha": "6b42ae26d22d432d188aa459de45c8ddfc9ac42b", "filename": "crates/ra_vfs/src/arena.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_vfs%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6/crates%2Fra_vfs%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Farena.rs?ref=821fa7a50ab8c4886adc60a2093aa8e06cc3a9d6", "patch": "@@ -1,53 +0,0 @@\n-use std::{\n-    marker::PhantomData,\n-    ops::{Index, IndexMut},\n-};\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct Arena<ID: ArenaId, T> {\n-    data: Vec<T>,\n-    _ty: PhantomData<ID>,\n-}\n-\n-pub(crate) trait ArenaId {\n-    fn from_u32(id: u32) -> Self;\n-    fn to_u32(self) -> u32;\n-}\n-\n-impl<ID: ArenaId, T> Arena<ID, T> {\n-    pub fn alloc(&mut self, value: T) -> ID {\n-        let id = self.data.len() as u32;\n-        self.data.push(value);\n-        ID::from_u32(id)\n-    }\n-    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (ID, &'a T)> {\n-        self.data\n-            .iter()\n-            .enumerate()\n-            .map(|(idx, value)| (ID::from_u32(idx as u32), value))\n-    }\n-}\n-\n-impl<ID: ArenaId, T> Default for Arena<ID, T> {\n-    fn default() -> Arena<ID, T> {\n-        Arena {\n-            data: Vec::new(),\n-            _ty: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<ID: ArenaId, T> Index<ID> for Arena<ID, T> {\n-    type Output = T;\n-    fn index(&self, idx: ID) -> &T {\n-        let idx = idx.to_u32() as usize;\n-        &self.data[idx]\n-    }\n-}\n-\n-impl<ID: ArenaId, T> IndexMut<ID> for Arena<ID, T> {\n-    fn index_mut(&mut self, idx: ID) -> &mut T {\n-        let idx = idx.to_u32() as usize;\n-        &mut self.data[idx]\n-    }\n-}"}, {"sha": "cdea18d734227494429c0a3715a3654c6c1ae2fe", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d483011d5f84747fcc5d5fe9c82f4405d24db9/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=a0d483011d5f84747fcc5d5fe9c82f4405d24db9", "patch": "@@ -13,7 +13,6 @@\n //! VFS is based on a concept of roots: a set of directories on the file system\n //! which are watched for changes. Typically, there will be a root for each\n //! Cargo package.\n-mod arena;\n mod io;\n \n use std::{\n@@ -32,10 +31,7 @@ use relative_path::RelativePathBuf;\n use crossbeam_channel::Receiver;\n use walkdir::DirEntry;\n use thread_worker::WorkerHandle;\n-\n-use crate::{\n-    arena::{ArenaId, Arena},\n-};\n+use ra_arena::{Arena, RawId, impl_arena_id};\n \n pub use crate::io::TaskResult as VfsTask;\n \n@@ -68,29 +64,13 @@ fn has_rs_extension(p: &Path) -> bool {\n     p.extension() == Some(OsStr::new(\"rs\"))\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsRoot(pub u32);\n-\n-impl ArenaId for VfsRoot {\n-    fn from_u32(idx: u32) -> VfsRoot {\n-        VfsRoot(idx)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsFile(pub u32);\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n \n-impl ArenaId for VfsFile {\n-    fn from_u32(idx: u32) -> VfsFile {\n-        VfsFile(idx)\n-    }\n-    fn to_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsFile(pub RawId);\n+impl_arena_id!(VfsFile);\n \n struct VfsFileData {\n     root: VfsRoot,"}]}