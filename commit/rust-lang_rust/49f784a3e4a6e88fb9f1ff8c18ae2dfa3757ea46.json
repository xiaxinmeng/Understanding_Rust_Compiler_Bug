{"sha": "49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Zjc4NGEzZTRhNmU4OGZiOWYxZmY4YzE4YWUyZGZhMzc1N2VhNDY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-27T06:58:01Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-27T07:21:20Z"}, "message": "Remove PrimValKind field from PrimVal.", "tree": {"sha": "bda95fafe8c7ddab6e86f44fb6928c99e3bc4a1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda95fafe8c7ddab6e86f44fb6928c99e3bc4a1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "html_url": "https://github.com/rust-lang/rust/commit/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16f3b590e46062a0db728e7764dc64d23851c4db", "url": "https://api.github.com/repos/rust-lang/rust/commits/16f3b590e46062a0db728e7764dc64d23851c4db", "html_url": "https://github.com/rust-lang/rust/commit/16f3b590e46062a0db728e7764dc64d23851c4db"}], "stats": {"total": 537, "additions": 246, "deletions": 291}, "files": [{"sha": "4b0c91b00ab35d276ca4cc3b1daed2e56832eefe", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -11,17 +11,24 @@ use rustc::ty::Ty;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub(super) fn cast_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn cast_primval(\n+        &self,\n+        val: PrimVal,\n+        src_ty: Ty<'tcx>,\n+        dest_ty: Ty<'tcx>\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        let kind = self.ty_to_primval_kind(src_ty)?;\n+\n         use primval::PrimValKind::*;\n-        match val.kind {\n-            F32 => self.cast_float(val.to_f32() as f64, ty),\n-            F64 => self.cast_float(val.to_f64(), ty),\n+        match kind {\n+            F32 => self.cast_float(val.to_f32() as f64, dest_ty),\n+            F64 => self.cast_float(val.to_f64(), dest_ty),\n \n-            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits as i64, ty),\n+            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits as i64, dest_ty),\n \n-            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, ty, false),\n+            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, dest_ty, false),\n \n-            FnPtr | Ptr => self.cast_ptr(val.to_ptr(), ty),\n+            FnPtr | Ptr => self.cast_ptr(val.to_ptr(), dest_ty),\n         }\n     }\n \n@@ -30,22 +37,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn cast_int(&self, v: u64, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n-        use primval::PrimValKind::*;\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyBool if v == 0 => Ok(PrimVal::from_bool(false)),\n             TyBool if v == 1 => Ok(PrimVal::from_bool(true)),\n             TyBool => Err(EvalError::InvalidBool),\n \n-            TyInt(IntTy::I8)  => Ok(PrimVal::new(v as i64 as i8  as u64, I8)),\n-            TyInt(IntTy::I16) => Ok(PrimVal::new(v as i64 as i16 as u64, I16)),\n-            TyInt(IntTy::I32) => Ok(PrimVal::new(v as i64 as i32 as u64, I32)),\n-            TyInt(IntTy::I64) => Ok(PrimVal::new(v as i64 as i64 as u64, I64)),\n+            TyInt(IntTy::I8)  => Ok(PrimVal::new(v as i64 as i8  as u64)),\n+            TyInt(IntTy::I16) => Ok(PrimVal::new(v as i64 as i16 as u64)),\n+            TyInt(IntTy::I32) => Ok(PrimVal::new(v as i64 as i32 as u64)),\n+            TyInt(IntTy::I64) => Ok(PrimVal::new(v as i64 as i64 as u64)),\n \n-            TyUint(UintTy::U8)  => Ok(PrimVal::new(v as u8  as u64, U8)),\n-            TyUint(UintTy::U16) => Ok(PrimVal::new(v as u16 as u64, U16)),\n-            TyUint(UintTy::U32) => Ok(PrimVal::new(v as u32 as u64, U32)),\n-            TyUint(UintTy::U64) => Ok(PrimVal::new(v, U64)),\n+            TyUint(UintTy::U8)  => Ok(PrimVal::new(v as u8  as u64)),\n+            TyUint(UintTy::U16) => Ok(PrimVal::new(v as u16 as u64)),\n+            TyUint(UintTy::U32) => Ok(PrimVal::new(v as u32 as u64)),\n+            TyUint(UintTy::U64) => Ok(PrimVal::new(v)),\n \n             TyInt(IntTy::Is) => {\n                 let int_ty = self.tcx.sess.target.int_type;\n@@ -64,7 +70,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i64 as f32)),\n             TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n \n-            TyChar if v as u8 as u64 == v => Ok(PrimVal::new(v, Char)),\n+            TyChar if v as u8 as u64 == v => Ok(PrimVal::new(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n             TyRawPtr(_) => Ok(PrimVal::from_ptr(Pointer::from_int(v))),\n@@ -91,8 +97,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n-            TyRef(..) | TyRawPtr(_) => Ok(PrimVal::from_ptr(ptr)),\n-            TyFnPtr(_) => Ok(PrimVal::from_fn_ptr(ptr)),\n+            TyRef(..) | TyRawPtr(_) | TyFnPtr(_) => Ok(PrimVal::from_ptr(ptr)),\n             TyInt(_) | TyUint(_) => self.transmute_primval(PrimVal::from_ptr(ptr), ty),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "82b949d453fb5b8b6efa24efb1416715cb602510", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 55, "deletions": 74, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -222,44 +222,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n-    fn usize_primval(&self, n: u64) -> PrimVal {\n-        PrimVal::from_uint_with_size(n, self.memory.pointer_size())\n-    }\n-\n     fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::from_ptr(ptr), self.usize_primval(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::from_ptr(ptr), PrimVal::from_uint(s.len() as u64)))\n     }\n \n     fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::ConstFloat;\n \n         let primval = match *const_val {\n-            Integral(const_int) => {\n-                use rustc_const_math::ConstInt::*;\n-                use rustc_const_math::ConstIsize::*;\n-                use rustc_const_math::ConstUsize::*;\n-\n-                let kind = match const_int {\n-                    I8(_)                   => PrimValKind::I8,\n-                    I16(_) | Isize(Is16(_)) => PrimValKind::I16,\n-                    I32(_) | Isize(Is32(_)) => PrimValKind::I32,\n-                    I64(_) | Isize(Is64(_)) => PrimValKind::I64,\n-                    U8(_)                   => PrimValKind::U8,\n-                    U16(_) | Usize(Us16(_)) => PrimValKind::U16,\n-                    U32(_) | Usize(Us32(_)) => PrimValKind::U32,\n-                    U64(_) | Usize(Us64(_)) => PrimValKind::U64,\n-\n-                    Infer(_) | InferSigned(_) =>\n-                        bug!(\"uninferred constants only exist before typeck\"),\n-                };\n-\n-                PrimVal::new(const_int.to_u64_unchecked(), kind)\n-            }\n+            Integral(const_int) => PrimVal::new(const_int.to_u64_unchecked()),\n \n             Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n             Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n@@ -306,7 +282,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         let substituted = ty.subst(self.tcx, substs);\n-        self.tcx.normalize_associated_type(&substituted)\n+        let new = self.tcx.normalize_associated_type(&substituted);\n+        new\n     }\n \n     fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n@@ -432,9 +409,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        let left_primval = self.eval_operand_to_primval(left)?;\n-        let right_primval = self.eval_operand_to_primval(right)?;\n-        primval::binary_op(op, left_primval, right_primval)\n+        let left_ty    = self.operand_ty(left);\n+        let right_ty   = self.operand_ty(right);\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        let left_val   = self.eval_operand_to_primval(left)?;\n+        let right_val  = self.eval_operand_to_primval(right)?;\n+        primval::binary_op(op, left_val, left_kind, right_val, right_kind)\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -460,9 +441,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         left: &mir::Operand<'tcx>,\n         right: &mir::Operand<'tcx>,\n         dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        self.write_primval(dest, val)?;\n+        self.write_primval(dest, val, dest_ty)?;\n         Ok(overflowed)\n     }\n \n@@ -506,7 +488,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 // ignore overflow bit, rustc inserts check branches for us\n-                self.intrinsic_overflowing(bin_op, left, right, dest)?;\n+                self.intrinsic_overflowing(bin_op, left, right, dest, dest_ty)?;\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n@@ -515,7 +497,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             UnaryOp(un_op, ref operand) => {\n                 let val = self.eval_operand_to_primval(operand)?;\n-                self.write_primval(dest, primval::unary_op(un_op, val)?)?;\n+                let kind = self.ty_to_primval_kind(dest_ty)?;\n+                self.write_primval(dest, primval::unary_op(un_op, val, kind)?, dest_ty)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -571,9 +554,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let value_size = self.type_size(dest_ty)?.expect(\"pointer types are sized\");\n-                                let zero = PrimVal::from_int_with_size(0, value_size);\n-                                self.write_primval(dest, zero)?;\n+                                self.write_primval(dest, PrimVal::from_int(0), dest_ty)?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -604,19 +585,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n-                    CEnum { discr, signed, .. } => {\n+                    CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n                             let n = adt_def.variants[variant].disr_val.to_u64_unchecked();\n-                            let size = discr.size().bytes();\n-\n-                            let val = if signed {\n-                                PrimVal::from_int_with_size(n as i64, size)\n-                            } else {\n-                                PrimVal::from_uint_with_size(n, size)\n-                            };\n-\n-                            self.write_primval(dest, val)?;\n+                            self.write_primval(dest, PrimVal::new(n), dest_ty)?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::CEnum\", kind);\n                         }\n@@ -655,8 +628,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n-                let len_val = self.usize_primval(len);\n-                self.write_primval(dest, len_val)?;\n+                self.write_primval(dest, PrimVal::from_uint(len), dest_ty)?;\n             }\n \n             Ref(_, _, ref lvalue) => {\n@@ -666,7 +638,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n-                    LvalueExtra::Length(len) => Value::ByValPair(ptr, self.usize_primval(len)),\n+                    LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_uint(len)),\n                     LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::from_ptr(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n@@ -677,7 +649,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::from_ptr(ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(ptr), dest_ty)?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -707,7 +679,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             }\n                         } else {\n                             let src_val = self.value_to_primval(src, src_ty)?;\n-                            let dest_val = self.cast_primval(src_val, dest_ty)?;\n+                            let dest_val = self.cast_primval(src_val, src_ty, dest_ty)?;\n                             self.write_value(Value::ByVal(dest_val), dest, dest_ty)?;\n                         }\n                     }\n@@ -716,7 +688,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnDef(def_id, substs, fn_ty) => {\n                             let fn_ty = self.tcx.erase_regions(&fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::from_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n                     },\n@@ -728,7 +700,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let (def_id, substs, _, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n                             let fn_ptr = self.memory.create_fn_ptr(self.tcx, def_id, substs, unsafe_fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(Value::ByVal(PrimVal::from_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n@@ -1059,8 +1031,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n-                let n = self.value_to_primval(n_ptr, usize)?\n-                    .expect_uint(\"Projection::Index expected usize\");\n+                let n = self.value_to_primval(n_ptr, usize)?.to_u64();\n                 assert!(n < len);\n                 let ptr = base_ptr.offset(n * elem_size);\n                 (ptr, LvalueExtra::None)\n@@ -1124,6 +1095,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n                     opt_val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n+                        let ty = self.monomorphize(ty, self.stack[frame].substs);\n                         let substs = self.stack[frame].substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].set_local(local, Value::ByRef(ptr));\n@@ -1168,7 +1140,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Value::ByVal(primval) => {\n                 let ptr = self.alloc_ptr(ty)?;\n-                self.memory.write_primval(ptr, primval)?;\n+                let kind = self.ty_to_primval_kind(ty)?;\n+                self.memory.write_primval(ptr, primval, kind)?;\n                 Ok(ptr)\n             }\n \n@@ -1202,19 +1175,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn transmute_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        Ok(PrimVal { kind: self.ty_to_primval_kind(ty)?, ..val })\n+    // FIXME(solson): Delete this.\n+    fn transmute_primval(&self, val: PrimVal, _ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        Ok(val)\n     }\n \n     fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: PrimVal,\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.memory.write_primval(ptr, val)\n+                let kind = self.ty_to_primval_kind(dest_ty)?;\n+                self.memory.write_primval(ptr, val, kind)\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].set_local(local, Value::ByVal(val));\n@@ -1319,7 +1295,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         match value {\n             Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n-            Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n+            Value::ByVal(primval) => {\n+                let kind = self.ty_to_primval_kind(dest_ty)?;\n+                self.memory.write_primval(dest, primval, kind)\n+            }\n             Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest, dest_ty),\n         }\n     }\n@@ -1334,8 +1313,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         assert_eq!(self.get_field_count(ty)?, 2);\n         let field_0 = self.get_field_offset(ty, 0)?.bytes();\n         let field_1 = self.get_field_offset(ty, 1)?.bytes();\n-        self.memory.write_primval(ptr.offset(field_0), a)?;\n-        self.memory.write_primval(ptr.offset(field_1), b)?;\n+        let field_0_ty = self.get_field_ty(ty, 0)?;\n+        let field_1_ty = self.get_field_ty(ty, 1)?;\n+        let field_0_kind = self.ty_to_primval_kind(field_0_ty)?;\n+        let field_1_kind = self.ty_to_primval_kind(field_1_ty)?;\n+        self.memory.write_primval(ptr.offset(field_0), a, field_0_kind)?;\n+        self.memory.write_primval(ptr.offset(field_1), b, field_1_kind)?;\n         Ok(())\n     }\n \n@@ -1432,8 +1415,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     I64 => 8,\n                     Is => self.memory.pointer_size(),\n                 };\n-                let n = self.memory.read_int(ptr, size)?;\n-                PrimVal::from_int_with_size(n, size)\n+                PrimVal::from_int(self.memory.read_int(ptr, size)?)\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1445,17 +1427,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     U64 => 8,\n                     Us => self.memory.pointer_size(),\n                 };\n-                let n = self.memory.read_uint(ptr, size)?;\n-                PrimVal::from_uint_with_size(n, size)\n+                PrimVal::from_uint(self.memory.read_uint(ptr, size)?)\n             }\n \n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n+            // TODO(solson): Should this even be here? Fn items aren't primvals, are they?\n             ty::TyFnDef(def_id, substs, fn_ty) => {\n-                PrimVal::from_fn_ptr(self.memory.create_fn_ptr(self.tcx, def_id, substs, fn_ty))\n+                PrimVal::from_ptr(self.memory.create_fn_ptr(self.tcx, def_id, substs, fn_ty))\n             },\n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::from_fn_ptr)?,\n+\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::from_ptr)?,\n             ty::TyBox(ty) |\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -1468,7 +1451,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let extra = match self.tcx.struct_tail(ty).sty {\n                         ty::TyTrait(..) => PrimVal::from_ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n-                        ty::TyStr => self.usize_primval(self.memory.read_usize(extra)?),\n+                        ty::TyStr => PrimVal::from_uint(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n                     return Ok(Value::ByValPair(PrimVal::from_ptr(p), extra));\n@@ -1480,11 +1463,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n                     if signed {\n-                        let n = self.memory.read_int(ptr, size)?;\n-                        PrimVal::from_int_with_size(n, size)\n+                        PrimVal::from_int(self.memory.read_int(ptr, size)?)\n                     } else {\n-                        let n = self.memory.read_uint(ptr, size)?;\n-                        PrimVal::from_uint_with_size(n, size)\n+                        PrimVal::from_uint(self.memory.read_uint(ptr, size)?)\n                     }\n                 } else {\n                     bug!(\"primitive read of non-clike enum: {:?}\", ty);\n@@ -1531,7 +1512,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                     (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                         let ptr = src.read_ptr(&self.memory)?;\n-                        let len = self.usize_primval(length as u64);\n+                        let len = PrimVal::from_uint(length as u64);\n                         let ptr = PrimVal::from_ptr(ptr);\n                         self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n                     }"}, {"sha": "64562ccb9178e42f89bdee7112013a98d47bc90f", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 72, "deletions": 87, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -44,10 +44,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?\n-                    .expect_int(\"arith_offset second arg not isize\");\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n                 let new_ptr = ptr.signed_offset(offset);\n-                self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(new_ptr), dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -85,8 +84,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n-                self.write_primval(dest, old)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), change)?;\n+                self.write_primval(dest, old, ty)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n             }\n \n             \"atomic_cxchg\" => {\n@@ -100,10 +99,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n-                let (val, _) = primval::binary_op(mir::BinOp::Eq, old, expect_old)?;\n+                let kind = self.ty_to_primval_kind(ty)?;\n+                let (val, _) = primval::binary_op(mir::BinOp::Eq, old, kind, expect_old, kind)?;\n                 let dest = self.force_allocation(dest)?.to_ptr();\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), change)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n             }\n \n             \"atomic_xadd_relaxed\" => {\n@@ -116,10 +116,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n-                self.write_primval(dest, old)?;\n+                self.write_primval(dest, old, ty)?;\n+                let kind = self.ty_to_primval_kind(ty)?;\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = primval::binary_op(mir::BinOp::Add, old, change)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), val)?;\n+                let (val, _) = primval::binary_op(mir::BinOp::Add, old, kind, change, kind)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             },\n \n             \"atomic_xsub_rel\" => {\n@@ -132,10 +133,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xsub_rel doesn't work with nonprimitives\"),\n                 };\n-                self.write_primval(dest, old)?;\n+                self.write_primval(dest, old, ty)?;\n+                let kind = self.ty_to_primval_kind(ty)?;\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = primval::binary_op(mir::BinOp::Sub, old, change)?;\n-                self.write_primval(Lvalue::from_ptr(ptr), val)?;\n+                let (val, _) = primval::binary_op(mir::BinOp::Sub, old, kind, change, kind)?;\n+                self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -148,26 +150,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n-                let count = self.value_to_primval(arg_vals[2], usize)?\n-                    .expect_uint(\"arith_offset second arg not isize\");\n+                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64();\n                 self.memory.copy(src, dest, count * elem_size, elem_align)?;\n             }\n \n             \"ctpop\" |\n             \"cttz\" |\n             \"ctlz\" |\n             \"bswap\" => {\n-                let elem_ty = substs.type_at(0);\n-                let num = self.value_to_primval(arg_vals[0], elem_ty)?;\n-                let num = numeric_intrinsic(intrinsic_name, num);\n-                self.write_primval(dest, num)?;\n+                let ty = substs.type_at(0);\n+                let num = self.value_to_primval(arg_vals[0], ty)?;\n+                let kind = self.ty_to_primval_kind(ty)?;\n+                let num = numeric_intrinsic(intrinsic_name, num, kind);\n+                self.write_primval(dest, num, ty)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.write_primval(dest, PrimVal::new(discr_val, PrimValKind::U64))?;\n+                self.write_primval(dest, PrimVal::new(discr_val), dest_ty)?;\n             }\n \n             \"drop_in_place\" => {\n@@ -196,51 +198,49 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"fabsf32\" => {\n-                let f = self.value_to_primval(arg_vals[2], f32)?\n-                    .expect_f32(\"fabsf32 read non f32\");\n-                self.write_primval(dest, PrimVal::from_f32(f.abs()))?;\n+                let f = self.value_to_primval(arg_vals[2], f32)?.to_f32();\n+                self.write_primval(dest, PrimVal::from_f32(f.abs()), dest_ty)?;\n             }\n \n             \"fabsf64\" => {\n-                let f = self.value_to_primval(arg_vals[2], f64)?\n-                    .expect_f64(\"fabsf64 read non f64\");\n-                self.write_primval(dest, PrimVal::from_f64(f.abs()))?;\n+                let f = self.value_to_primval(arg_vals[2], f64)?.to_f64();\n+                self.write_primval(dest, PrimVal::from_f64(f.abs()), dest_ty)?;\n             }\n \n             \"fadd_fast\" => {\n                 let ty = substs.type_at(0);\n+                let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[0], ty)?;\n-                let result = primval::binary_op(mir::BinOp::Add, a, b)?;\n-                self.write_primval(dest, result.0)?;\n+                let result = primval::binary_op(mir::BinOp::Add, a, kind, b, kind)?;\n+                self.write_primval(dest, result.0, dest_ty)?;\n             }\n \n             \"likely\" |\n             \"unlikely\" |\n             \"forget\" => {}\n \n             \"init\" => {\n-                let size = dest_layout.size(&self.tcx.data_layout).bytes();\n+                let size = self.type_size(dest_ty)?.expect(\"cannot init unsized value\");;\n                 let init = |this: &mut Self, val: Option<Value>| {\n-                    match val {\n+                    let zero_val = match val {\n                         Some(Value::ByRef(ptr)) => {\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Ok(Some(Value::ByRef(ptr)))\n+                            Value::ByRef(ptr)\n                         },\n                         None => match this.ty_to_primval_kind(dest_ty) {\n-                            Ok(kind) => Ok(Some(Value::ByVal(PrimVal::new(0, kind)))),\n+                            Ok(_) => Value::ByVal(PrimVal::new(0)),\n                             Err(_) => {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n                                 this.memory.write_repeat(ptr, 0, size)?;\n-                                Ok(Some(Value::ByRef(ptr)))\n+                                Value::ByRef(ptr)\n                             }\n                         },\n-                        Some(Value::ByVal(value)) => Ok(Some(Value::ByVal(PrimVal::new(0, value.kind)))),\n-                        Some(Value::ByValPair(a, b)) => Ok(Some(Value::ByValPair(\n-                            PrimVal::new(0, a.kind),\n-                            PrimVal::new(0, b.kind),\n-                        ))),\n-                    }\n+                        Some(Value::ByVal(_)) => Value::ByVal(PrimVal::new(0)),\n+                        Some(Value::ByValPair(..)) =>\n+                            Value::ByValPair(PrimVal::new(0), PrimVal::new(0)),\n+                    };\n+                    Ok(Some(zero_val))\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n@@ -253,16 +253,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.type_align(elem_ty)?;\n-                let align_val = self.usize_primval(elem_align as u64);\n-                self.write_primval(dest, align_val)?;\n+                let align_val = PrimVal::from_uint(elem_align as u64);\n+                self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n-                let align_val = self.usize_primval(align);\n-                self.write_primval(dest, align_val)?;\n+                let align_val = PrimVal::from_uint(align);\n+                self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"move_val_init\" => {\n@@ -275,59 +275,52 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = substs.type_at(0);\n                 let env = self.tcx.empty_parameter_environment();\n                 let needs_drop = self.tcx.type_needs_drop_given_env(ty, &env);\n-                self.write_primval(dest, PrimVal::from_bool(needs_drop))?;\n+                self.write_primval(dest, PrimVal::from_bool(needs_drop), dest_ty)?;\n             }\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n                 // FIXME: assuming here that type size is < i64::max_value()\n                 let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?\n-                    .expect_int(\"offset second arg not isize\");\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64();\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.signed_offset(offset * pointee_size);\n-                self.write_primval(dest, PrimVal::from_ptr(result_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(result_ptr), dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n             \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n             \"overflowing_add\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest, dest_ty)?;\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?\n-                    .expect_f32(\"powif32 first arg not f32\");\n-                let i = self.value_to_primval(arg_vals[1], i32)?\n-                    .expect_int(\"powif32 second arg not i32\");\n-                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)))?;\n+                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32();\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64();\n+                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?\n-                    .expect_f64(\"powif64 first arg not f64\");\n-                let i = self.value_to_primval(arg_vals[1], i32)?\n-                    .expect_int(\"powif64 second arg not i32\");\n-                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)))?;\n+                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64();\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64();\n+                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"sqrtf32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?\n-                    .expect_f32(\"sqrtf32 first arg not f32\");\n-                self.write_primval(dest, PrimVal::from_f32(f.sqrt()))?;\n+                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32();\n+                self.write_primval(dest, PrimVal::from_f32(f.sqrt()), dest_ty)?;\n             }\n \n             \"sqrtf64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?\n-                    .expect_f64(\"sqrtf64 first arg not f64\");\n-                self.write_primval(dest, PrimVal::from_f64(f.sqrt()))?;\n+                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64();\n+                self.write_primval(dest, PrimVal::from_f64(f.sqrt()), dest_ty)?;\n             }\n \n             \"size_of\" => {\n@@ -337,23 +330,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // .expect(\"size_of intrinsic called on unsized value\")\n                 // see https://github.com/rust-lang/rust/pull/37708\n                 let size = self.type_size(ty)?.unwrap_or(!0) as u64;\n-                let size_val = self.usize_primval(size);\n-                self.write_primval(dest, size_val)?;\n+                self.write_primval(dest, PrimVal::from_uint(size), dest_ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                let size_val = self.usize_primval(size);\n-                self.write_primval(dest, size_val)?;\n+                self.write_primval(dest, PrimVal::from_uint(size), dest_ty)?;\n             }\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                let align_val = self.usize_primval(align);\n-                self.write_primval(dest, align_val)?;\n+                self.write_primval(dest, PrimVal::from_uint(align), dest_ty)?;\n             }\n \n             \"type_name\" => {\n@@ -365,17 +355,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::new(n, PrimValKind::U64))?;\n+                self.write_primval(dest, PrimVal::new(n), dest_ty)?;\n             }\n \n             \"transmute\" => {\n                 let dest_ty = substs.type_at(1);\n-                let val = match arg_vals[0] {\n-                    Value::ByVal(primval) =>\n-                        Value::ByVal(self.transmute_primval(primval, dest_ty)?),\n-                    v => v,\n-                };\n-                self.write_value(val, dest, dest_ty)?;\n+                self.write_value(arg_vals[0], dest, dest_ty)?;\n             }\n \n             \"uninit\" => {\n@@ -511,11 +496,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n macro_rules! integer_intrinsic {\n-    ($name:expr, $val:expr, $method:ident) => ({\n+    ($name:expr, $val:expr, $kind:expr, $method:ident) => ({\n         let val = $val;\n \n         use primval::PrimValKind::*;\n-        let bits = match val.kind {\n+        let bits = match $kind {\n             I8 => (val.bits as i8).$method() as u64,\n             U8 => (val.bits as u8).$method() as u64,\n             I16 => (val.bits as i16).$method() as u64,\n@@ -527,16 +512,16 @@ macro_rules! integer_intrinsic {\n             _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n         };\n \n-        PrimVal::new(bits, val.kind)\n+        PrimVal::new(bits)\n     });\n }\n \n-fn numeric_intrinsic(name: &str, val: PrimVal) -> PrimVal {\n+fn numeric_intrinsic(name: &str, val: PrimVal, kind: PrimValKind) -> PrimVal {\n     match name {\n-        \"bswap\" => integer_intrinsic!(\"bswap\", val, swap_bytes),\n-        \"ctlz\"  => integer_intrinsic!(\"ctlz\", val, leading_zeros),\n-        \"ctpop\" => integer_intrinsic!(\"ctpop\", val, count_ones),\n-        \"cttz\"  => integer_intrinsic!(\"cttz\", val, trailing_zeros),\n+        \"bswap\" => integer_intrinsic!(\"bswap\", val, kind, swap_bytes),\n+        \"ctlz\"  => integer_intrinsic!(\"ctlz\",  val, kind, leading_zeros),\n+        \"ctpop\" => integer_intrinsic!(\"ctpop\", val, kind, count_ones),\n+        \"cttz\"  => integer_intrinsic!(\"cttz\",  val, kind, trailing_zeros),\n         _       => bug!(\"not a numeric intrinsic: {}\", name),\n     }\n }"}, {"sha": "a346b8fafa5c6cb54a659c30d5b3b13d290d15ad", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -100,7 +100,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                           terminator.source_info.span)?\n                     }\n \n-                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n+                    _ => {\n+                        let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n+                        return Err(EvalError::Unimplemented(msg));\n+                    }\n                 }\n             }\n \n@@ -126,11 +129,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return match *msg {\n                         mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n                             let span = terminator.source_info.span;\n-                            let len = self.eval_operand_to_primval(len).expect(\"can't eval len\")\n-                                .expect_uint(\"BoundsCheck len wasn't a uint\");\n+                            let len = self.eval_operand_to_primval(len)\n+                                .expect(\"can't eval len\")\n+                                .to_u64();\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n-                                .expect_uint(\"BoundsCheck index wasn't a uint\");\n+                                .to_u64();\n                             Err(EvalError::ArrayIndexOutOfBounds(span, len, index))\n                         },\n                         mir::AssertMessage::Math(ref err) =>\n@@ -194,9 +198,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n-                let size = self.type_size(ty)?.expect(\"function return type cannot be unsized\");\n                 let (ret, target) = destination.unwrap();\n-                self.call_c_abi(def_id, arg_operands, ret, size)?;\n+                self.call_c_abi(def_id, arg_operands, ret, ty)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n@@ -303,7 +306,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         args: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n-        dest_size: u64,\n+        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n@@ -325,36 +328,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match &link_name[..] {\n             \"__rust_allocate\" => {\n-                let size = self.value_to_primval(args[0], usize)?\n-                    .expect_uint(\"__rust_allocate first arg not usize\");\n-                let align = self.value_to_primval(args[1], usize)?\n-                    .expect_uint(\"__rust_allocate second arg not usize\");\n+                let size = self.value_to_primval(args[0], usize)?.to_u64();\n+                let align = self.value_to_primval(args[1], usize)?.to_u64();\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.write_primval(dest, PrimVal::from_ptr(ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(ptr), dest_ty)?;\n             }\n \n             \"__rust_deallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 // FIXME: insert sanity check for size and align?\n-                let _old_size = self.value_to_primval(args[1], usize)?\n-                    .expect_uint(\"__rust_deallocate second arg not usize\");\n-                let _align = self.value_to_primval(args[2], usize)?\n-                    .expect_uint(\"__rust_deallocate third arg not usize\");\n+                let _old_size = self.value_to_primval(args[1], usize)?.to_u64();\n+                let _align = self.value_to_primval(args[2], usize)?.to_u64();\n                 self.memory.deallocate(ptr)?;\n             },\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n-                let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n-                let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n+                let size = self.value_to_primval(args[2], usize)?.to_u64();\n+                let align = self.value_to_primval(args[3], usize)?.to_u64();\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n-                self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(new_ptr), dest_ty)?;\n             }\n \n             \"memcmp\" => {\n                 let left = args[0].read_ptr(&self.memory)?;\n                 let right = args[1].read_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate first arg not usize\");\n+                let n = self.value_to_primval(args[2], usize)?.to_u64();\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -368,7 +367,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                self.write_primval(dest, PrimVal::from_int_with_size(result, dest_size))?;\n+                self.write_primval(dest, PrimVal::new(result as u64), dest_ty)?;\n             }\n \n             _ => {"}, {"sha": "3d05300f0ab596822fe564ff81e88c26ee64403f", "filename": "src/memory.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::layout::{self, TargetDataLayout};\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n-use primval::PrimVal;\n+use primval::{PrimVal, PrimValKind};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -559,13 +559,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_primval(&mut self, dest: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n+    pub fn write_primval(\n+        &mut self,\n+        dest: Pointer,\n+        val: PrimVal,\n+        kind: PrimValKind,\n+    ) -> EvalResult<'tcx, ()> {\n         if let Some(alloc_id) = val.relocation {\n             return self.write_ptr(dest, Pointer::new(alloc_id, val.bits));\n         }\n \n         use primval::PrimValKind::*;\n-        let (size, bits) = match val.kind {\n+        let (size, bits) = match kind {\n             I8 | U8 | Bool         => (1, val.bits as u8  as u64),\n             I16 | U16              => (2, val.bits as u16 as u64),\n             I32 | U32 | F32 | Char => (4, val.bits as u32 as u64),"}, {"sha": "86bd573518ac4c30fa1e85e9059aed4c2478cbd3", "filename": "src/primval.rs", "status": "modified", "additions": 67, "deletions": 87, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=49f784a3e4a6e88fb9f1ff8c18ae2dfa3757ea46", "patch": "@@ -38,11 +38,6 @@ pub struct PrimVal {\n     /// `Allocation` in the `memory` module has a list of relocations, but a `PrimVal` is only\n     /// large enough to contain one, hence the `Option`.\n     pub relocation: Option<AllocId>,\n-\n-    // FIXME(solson): I think we can make this field unnecessary, or at least move it outside of\n-    // this struct. We can either match over `Ty`s or generate simple `PrimVal`s from `Ty`s and\n-    // match over those to decide which operations to perform on `PrimVal`s.\n-    pub kind: PrimValKind,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n@@ -87,44 +82,40 @@ impl PrimValKind {\n }\n \n impl PrimVal {\n-    pub fn new(bits: u64, kind: PrimValKind) -> Self {\n-        PrimVal { bits: bits, relocation: None, kind: kind }\n+    pub fn new(bits: u64) -> Self {\n+        PrimVal { bits: bits, relocation: None }\n     }\n \n-    pub fn new_with_relocation(bits: u64, kind: PrimValKind, alloc_id: AllocId) -> Self {\n-        PrimVal { bits: bits, relocation: Some(alloc_id), kind: kind }\n+    pub fn new_with_relocation(bits: u64, alloc_id: AllocId) -> Self {\n+        PrimVal { bits: bits, relocation: Some(alloc_id) }\n     }\n \n     pub fn from_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new_with_relocation(ptr.offset as u64, PrimValKind::Ptr, ptr.alloc_id)\n-    }\n-\n-    pub fn from_fn_ptr(ptr: Pointer) -> Self {\n-        PrimVal::new_with_relocation(ptr.offset as u64, PrimValKind::FnPtr, ptr.alloc_id)\n+        PrimVal::new_with_relocation(ptr.offset as u64, ptr.alloc_id)\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        PrimVal::new(b as u64, PrimValKind::Bool)\n+        PrimVal::new(b as u64)\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        PrimVal::new(c as u64, PrimValKind::Char)\n+        PrimVal::new(c as u64)\n     }\n \n     pub fn from_f32(f: f32) -> Self {\n-        PrimVal::new(f32_to_bits(f), PrimValKind::F32)\n+        PrimVal::new(f32_to_bits(f))\n     }\n \n     pub fn from_f64(f: f64) -> Self {\n-        PrimVal::new(f64_to_bits(f), PrimValKind::F64)\n+        PrimVal::new(f64_to_bits(f))\n     }\n \n-    pub fn from_uint_with_size(n: u64, size: u64) -> Self {\n-        PrimVal::new(n, PrimValKind::from_uint_size(size))\n+    pub fn from_uint(n: u64) -> Self {\n+        PrimVal::new(n)\n     }\n \n-    pub fn from_int_with_size(n: i64, size: u64) -> Self {\n-        PrimVal::new(n as u64, PrimValKind::from_int_size(size))\n+    pub fn from_int(n: i64) -> Self {\n+        PrimVal::new(n as u64)\n     }\n \n     pub fn to_f32(self) -> f32 {\n@@ -144,31 +135,27 @@ impl PrimVal {\n     }\n \n     pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n-        self.to_ptr().to_int().map(|val| val as u64)\n+        self.to_ptr().to_int().map(|val| val)\n     }\n \n-    pub fn expect_uint(self, error_msg: &str) -> u64 {\n-        if let Ok(int) = self.try_as_uint() {\n-            return int;\n-        }\n-\n-        use self::PrimValKind::*;\n-        match self.kind {\n-            U8 | U16 | U32 | U64 => self.bits,\n-            _ => bug!(\"{}\", error_msg),\n+    pub fn to_u64(self) -> u64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as u64;\n         }\n+        self.bits\n     }\n \n-    pub fn expect_int(self, error_msg: &str) -> i64 {\n-        if let Ok(int) = self.try_as_uint() {\n-            return int as i64;\n+    pub fn to_i64(self) -> i64 {\n+        if let Some(ptr) = self.try_as_ptr() {\n+            return ptr.to_int().expect(\"non abstract ptr\") as i64;\n         }\n+        self.bits as i64\n+    }\n \n-        use self::PrimValKind::*;\n-        match self.kind {\n-            I8 | I16 | I32 | I64 => self.bits as i64,\n-            _ => bug!(\"{}\", error_msg),\n-        }\n+    pub fn try_as_ptr(self) -> Option<Pointer> {\n+        self.relocation.map(|alloc_id| {\n+            Pointer::new(alloc_id, self.bits)\n+        })\n     }\n \n     pub fn try_as_bool<'tcx>(self) -> EvalResult<'tcx, bool> {\n@@ -179,29 +166,16 @@ impl PrimVal {\n         }\n     }\n \n-    pub fn expect_f32(self, error_msg: &str) -> f32 {\n-        match self.kind {\n-            PrimValKind::F32 => bits_to_f32(self.bits),\n-            _ => bug!(\"{}\", error_msg),\n-        }\n-    }\n-\n-    pub fn expect_f64(self, error_msg: &str) -> f64 {\n-        match self.kind {\n-            PrimValKind::F32 => bits_to_f64(self.bits),\n-            _ => bug!(\"{}\", error_msg),\n-        }\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // MIR operator evaluation\n ////////////////////////////////////////////////////////////////////////////////\n \n macro_rules! overflow {\n-    ($kind:expr, $op:ident, $l:expr, $r:expr) => ({\n+    ($op:ident, $l:expr, $r:expr) => ({\n         let (val, overflowed) = $l.$op($r);\n-        let primval = PrimVal::new(val as u64, $kind);\n+        let primval = PrimVal::new(val as u64);\n         Ok((primval, overflowed))\n     })\n }\n@@ -211,14 +185,14 @@ macro_rules! int_arithmetic {\n         let l = $l;\n         let r = $r;\n         match $kind {\n-            I8  => overflow!(I8,  $int_op, l as i8,  r as i8),\n-            I16 => overflow!(I16, $int_op, l as i16, r as i16),\n-            I32 => overflow!(I32, $int_op, l as i32, r as i32),\n-            I64 => overflow!(I64, $int_op, l as i64, r as i64),\n-            U8  => overflow!(U8,  $int_op, l as u8,  r as u8),\n-            U16 => overflow!(U16, $int_op, l as u16, r as u16),\n-            U32 => overflow!(U32, $int_op, l as u32, r as u32),\n-            U64 => overflow!(U64, $int_op, l as u64, r as u64),\n+            I8  => overflow!($int_op, l as i8,  r as i8),\n+            I16 => overflow!($int_op, l as i16, r as i16),\n+            I32 => overflow!($int_op, l as i32, r as i32),\n+            I64 => overflow!($int_op, l as i64, r as i64),\n+            U8  => overflow!($int_op, l as u8,  r as u8),\n+            U16 => overflow!($int_op, l as u16, r as u16),\n+            U32 => overflow!($int_op, l as u32, r as u32),\n+            U64 => overflow!($int_op, l as u64, r as u64),\n             _ => bug!(\"int_arithmetic should only be called on int primvals\"),\n         }\n     })\n@@ -229,45 +203,47 @@ macro_rules! int_shift {\n         let l = $l;\n         let r = $r;\n         match $kind {\n-            I8  => overflow!(I8,  $int_op, l as i8,  r),\n-            I16 => overflow!(I16, $int_op, l as i16, r),\n-            I32 => overflow!(I32, $int_op, l as i32, r),\n-            I64 => overflow!(I64, $int_op, l as i64, r),\n-            U8  => overflow!(U8,  $int_op, l as u8,  r),\n-            U16 => overflow!(U16, $int_op, l as u16, r),\n-            U32 => overflow!(U32, $int_op, l as u32, r),\n-            U64 => overflow!(U64, $int_op, l as u64, r),\n+            I8  => overflow!($int_op, l as i8,  r),\n+            I16 => overflow!($int_op, l as i16, r),\n+            I32 => overflow!($int_op, l as i32, r),\n+            I64 => overflow!($int_op, l as i64, r),\n+            U8  => overflow!($int_op, l as u8,  r),\n+            U16 => overflow!($int_op, l as u16, r),\n+            U32 => overflow!($int_op, l as u32, r),\n+            U64 => overflow!($int_op, l as u64, r),\n             _ => bug!(\"int_shift should only be called on int primvals\"),\n         }\n     })\n }\n \n macro_rules! float_arithmetic {\n-    ($kind:expr, $from_bits:ident, $to_bits:ident, $float_op:tt, $l:expr, $r:expr) => ({\n+    ($from_bits:ident, $to_bits:ident, $float_op:tt, $l:expr, $r:expr) => ({\n         let l = $from_bits($l);\n         let r = $from_bits($r);\n         let bits = $to_bits(l $float_op r);\n-        PrimVal::new(bits, $kind)\n+        PrimVal::new(bits)\n     })\n }\n \n macro_rules! f32_arithmetic {\n     ($float_op:tt, $l:expr, $r:expr) => (\n-        float_arithmetic!(F32, bits_to_f32, f32_to_bits, $float_op, $l, $r)\n+        float_arithmetic!(bits_to_f32, f32_to_bits, $float_op, $l, $r)\n     )\n }\n \n macro_rules! f64_arithmetic {\n     ($float_op:tt, $l:expr, $r:expr) => (\n-        float_arithmetic!(F64, bits_to_f64, f64_to_bits, $float_op, $l, $r)\n+        float_arithmetic!(bits_to_f64, f64_to_bits, $float_op, $l, $r)\n     )\n }\n \n /// Returns the result of the specified operation and whether it overflowed.\n pub fn binary_op<'tcx>(\n     bin_op: mir::BinOp,\n     left: PrimVal,\n-    right: PrimVal\n+    left_kind: PrimValKind,\n+    right: PrimVal,\n+    right_kind: PrimValKind,\n ) -> EvalResult<'tcx, (PrimVal, bool)> {\n     use rustc::mir::BinOp::*;\n     use self::PrimValKind::*;\n@@ -288,7 +264,7 @@ pub fn binary_op<'tcx>(\n         // These are the maximum values a bitshift RHS could possibly have. For example, u16\n         // can be bitshifted by 0..16, so masking with 0b1111 (16 - 1) will ensure we are in\n         // that range.\n-        let type_bits: u32 = match left.kind {\n+        let type_bits: u32 = match left_kind {\n             I8  | U8  => 8,\n             I16 | U16 => 16,\n             I32 | U32 => 32,\n@@ -301,18 +277,18 @@ pub fn binary_op<'tcx>(\n         let r = (right.bits as u32) & (type_bits - 1);\n \n         return match bin_op {\n-            Shl => int_shift!(left.kind, overflowing_shl, l, r),\n-            Shr => int_shift!(left.kind, overflowing_shr, l, r),\n+            Shl => int_shift!(left_kind, overflowing_shl, l, r),\n+            Shr => int_shift!(left_kind, overflowing_shr, l, r),\n             _ => bug!(\"it has already been checked that this is a shift op\"),\n         };\n     }\n \n-    if left.kind != right.kind {\n+    if left_kind != right_kind {\n         let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n         return Err(EvalError::Unimplemented(msg));\n     }\n \n-    let val = match (bin_op, left.kind) {\n+    let val = match (bin_op, left_kind) {\n         (Eq, F32) => PrimVal::from_bool(bits_to_f32(l) == bits_to_f32(r)),\n         (Ne, F32) => PrimVal::from_bool(bits_to_f32(l) != bits_to_f32(r)),\n         (Lt, F32) => PrimVal::from_bool(bits_to_f32(l) <  bits_to_f32(r)),\n@@ -346,9 +322,9 @@ pub fn binary_op<'tcx>(\n         (Gt, _) => PrimVal::from_bool(l >  r),\n         (Ge, _) => PrimVal::from_bool(l >= r),\n \n-        (BitOr,  k) => PrimVal::new(l | r, k),\n-        (BitAnd, k) => PrimVal::new(l & r, k),\n-        (BitXor, k) => PrimVal::new(l ^ r, k),\n+        (BitOr,  _) => PrimVal::new(l | r),\n+        (BitAnd, _) => PrimVal::new(l & r),\n+        (BitXor, _) => PrimVal::new(l ^ r),\n \n         (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n         (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n@@ -378,11 +354,15 @@ fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) ->\n     }\n }\n \n-pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVal> {\n+pub fn unary_op<'tcx>(\n+    un_op: mir::UnOp,\n+    val: PrimVal,\n+    val_kind: PrimValKind,\n+) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::UnOp::*;\n     use self::PrimValKind::*;\n \n-    let bits = match (un_op, val.kind) {\n+    let bits = match (un_op, val_kind) {\n         (Not, Bool) => !bits_to_bool(val.bits) as u64,\n \n         (Not, U8)  => !(val.bits as u8) as u64,\n@@ -409,5 +389,5 @@ pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVa\n         }\n     };\n \n-    Ok(PrimVal::new(bits, val.kind))\n+    Ok(PrimVal::new(bits))\n }"}]}