{"sha": "b0646e0749db0603c7d4460db6e17e9c27d0afb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNjQ2ZTA3NDlkYjA2MDNjN2Q0NDYwZGI2ZTE3ZTljMjdkMGFmYjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-19T01:51:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-19T02:41:17Z"}, "message": "document liveness a bit better", "tree": {"sha": "760224a921357cfdca6ff9db98f3e7ca6f5ebe6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/760224a921357cfdca6ff9db98f3e7ca6f5ebe6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0646e0749db0603c7d4460db6e17e9c27d0afb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0646e0749db0603c7d4460db6e17e9c27d0afb3", "html_url": "https://github.com/rust-lang/rust/commit/b0646e0749db0603c7d4460db6e17e9c27d0afb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0646e0749db0603c7d4460db6e17e9c27d0afb3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec5a5c635dba820246cbb4c7bea031b6add3b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec5a5c635dba820246cbb4c7bea031b6add3b07", "html_url": "https://github.com/rust-lang/rust/commit/1ec5a5c635dba820246cbb4c7bea031b6add3b07"}], "stats": {"total": 62, "additions": 60, "deletions": 2}, "files": [{"sha": "152623bc6bee6391f925fbe825c7a89dd29af350", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b0646e0749db0603c7d4460db6e17e9c27d0afb3/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0646e0749db0603c7d4460db6e17e9c27d0afb3/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=b0646e0749db0603c7d4460db6e17e9c27d0afb3", "patch": "@@ -1,4 +1,4 @@\n-/*\n+#[doc = \"\n \n A classic liveness analysis based on dataflow over the AST.  Computes,\n for each local variable in a function, whether that variable is live\n@@ -42,7 +42,65 @@ Each field is assigned an index just as with local variables.  A use of\n `self` is considered a use of all fields.  A use of `self.f` is just a use\n of `f`.\n \n-*/\n+# Implementation details\n+\n+The actual implementation contains two (nested) walks over the AST.\n+The outer walk has the job of building up the ir_maps instance for the\n+enclosing function.  On the way down the tree, it identifies those AST\n+nodes and variable IDs that will be needed for the liveness analysis\n+and assigns them contiguous IDs.  The liveness id for an AST node is\n+called a `live_node` (it's a newtype'd uint) and the id for a variable\n+is called a `variable` (another newtype'd uint).\n+\n+On the way back up the tree, as we are about to exit from a function\n+declaration we allocate a `liveness` instance.  Now that we know\n+precisely how many nodes and variables we need, we can allocate all\n+the various arrays that we will need to precisely the right size.  We then\n+perform the actual propagation on the `liveness` instance.\n+\n+This propagation is encoded in the various `propagate_through_*()`\n+methods.  It effectively does a reverse walk of the AST; whenever we\n+reach a loop node, we iterate until a fixed point is reached.\n+\n+## The `users` struct\n+\n+At each live node `N`, we track three pieces of information for each\n+variable `V` (these are encapsulated in the `users` struct):\n+\n+- `reader`: the `live_node` ID of some node which will read the value\n+   that `V` holds on entry to `N`.  Formally: a node `M` such\n+   that there exists a path `P` from `N` to `M` where `P` does not\n+   write `V`.  If the `reader` is `invalid_node()`, then the current\n+   value will never be read (the variable is dead, essentially).\n+\n+- `writer`: the `live_node` ID of some node which will write the\n+   variable `V` and which is reachable from `N`.  Formally: a node `M`\n+   such that there exists a path `P` from `N` to `M` and `M` writes\n+   `V`.  If the `writer` is `invalid_node()`, then there is no writer\n+   of `V` that follows `N`.\n+\n+- `used`: a boolean value indicating whether `V` is *used*.  We\n+  distinguish a *read* from a *use* in that a *use* is some read that\n+  is not just used to generate a new value.  For example, `x += 1` is\n+  a read but not a use.  This is used to generate better warnings.\n+\n+## Special Variables\n+\n+We generate various special variables for various, well, special purposes.\n+These are described in the `specials` struct:\n+\n+- `exit_ln`: a live node that is generated to represent every 'exit' from the\n+  function, whether it be by explicit return, fail, or other means.\n+\n+- `fallthrough_ln`: a live node that represents a fallthrough\n+\n+- `no_ret_var`: a synthetic variable that is only 'read' from, the\n+  fallthrough node.  This allows us to detect functions where we fail\n+  to return explicitly.\n+\n+- `self_var`: a variable representing 'self'\n+\n+\"];\n \n import dvec::{dvec, extensions};\n import std::map::{hashmap, int_hash, str_hash, box_str_hash};"}]}