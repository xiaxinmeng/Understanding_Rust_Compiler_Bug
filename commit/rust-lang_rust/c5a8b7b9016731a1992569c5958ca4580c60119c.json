{"sha": "c5a8b7b9016731a1992569c5958ca4580c60119c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YThiN2I5MDE2NzMxYTE5OTI1NjljNTk1OGNhNDU4MGM2MDExOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T08:54:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T08:54:29Z"}, "message": "Auto merge of #75790 - LeSeulArtichaut:std-intra-doc, r=jyn514\n\nUse intra-doc-links in `std::sync::*`\n\nHelps with #75080.\nr? @jyn514", "tree": {"sha": "be7589688c474886e1ca656e20e7bbf9a1846fe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be7589688c474886e1ca656e20e7bbf9a1846fe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a8b7b9016731a1992569c5958ca4580c60119c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a8b7b9016731a1992569c5958ca4580c60119c", "html_url": "https://github.com/rust-lang/rust/commit/c5a8b7b9016731a1992569c5958ca4580c60119c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a8b7b9016731a1992569c5958ca4580c60119c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1bb8aa3ff3bf3040d9973edeb96b8c9ebf81d31", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1bb8aa3ff3bf3040d9973edeb96b8c9ebf81d31", "html_url": "https://github.com/rust-lang/rust/commit/b1bb8aa3ff3bf3040d9973edeb96b8c9ebf81d31"}, {"sha": "f3a832f4b4cf9040a050caf645eaf57653b6866c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a832f4b4cf9040a050caf645eaf57653b6866c", "html_url": "https://github.com/rust-lang/rust/commit/f3a832f4b4cf9040a050caf645eaf57653b6866c"}], "stats": {"total": 189, "additions": 53, "deletions": 136}, "files": [{"sha": "4efd86aa3ede8c3e7c99c2f845f3c164a3cd57b4", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=c5a8b7b9016731a1992569c5958ca4580c60119c", "patch": "@@ -11,7 +11,7 @@ use crate::time::{Duration, Instant};\n ///\n /// It is returned by the [`wait_timeout`] method.\n ///\n-/// [`wait_timeout`]: struct.Condvar.html#method.wait_timeout\n+/// [`wait_timeout`]: Condvar::wait_timeout\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n pub struct WaitTimeoutResult(bool);\n@@ -161,11 +161,10 @@ impl Condvar {\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n     ///\n-    /// [`notify_one`]: #method.notify_one\n-    /// [`notify_all`]: #method.notify_all\n-    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n-    /// [`Mutex`]: ../sync/struct.Mutex.html\n-    /// [`panic!`]: ../../std/macro.panic.html\n+    /// [`notify_one`]: Self::notify_one\n+    /// [`notify_all`]: Self::notify_all\n+    /// [poisoning]: super::Mutex#poisoning\n+    /// [`Mutex`]: super::Mutex\n     ///\n     /// # Examples\n     ///\n@@ -218,10 +217,10 @@ impl Condvar {\n     /// poisoned when this thread re-acquires the lock. For more information,\n     /// see information about [poisoning] on the [`Mutex`] type.\n     ///\n-    /// [`notify_one`]: #method.notify_one\n-    /// [`notify_all`]: #method.notify_all\n-    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n-    /// [`Mutex`]: ../sync/struct.Mutex.html\n+    /// [`notify_one`]: Self::notify_one\n+    /// [`notify_all`]: Self::notify_all\n+    /// [poisoning]: super::Mutex#poisoning\n+    /// [`Mutex`]: super::Mutex\n     ///\n     /// # Examples\n     ///\n@@ -280,7 +279,7 @@ impl Condvar {\n     /// Like [`wait`], the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n     ///\n-    /// [`wait`]: #method.wait\n+    /// [`wait`]: Self::wait\n     ///\n     /// # Examples\n     ///\n@@ -350,9 +349,8 @@ impl Condvar {\n     /// Like [`wait`], the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n     ///\n-    /// [`wait`]: #method.wait\n-    /// [`wait_timeout_while`]: #method.wait_timeout_while\n-    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n+    /// [`wait`]: Self::wait\n+    /// [`wait_timeout_while`]: Self::wait_timeout_while\n     ///\n     /// # Examples\n     ///\n@@ -420,9 +418,8 @@ impl Condvar {\n     /// Like [`wait_while`], the lock specified will be re-acquired when this\n     /// function returns, regardless of whether the timeout elapsed or not.\n     ///\n-    /// [`wait_while`]: #method.wait_while\n-    /// [`wait_timeout`]: #method.wait_timeout\n-    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n+    /// [`wait_while`]: Self::wait_while\n+    /// [`wait_timeout`]: Self::wait_timeout\n     ///\n     /// # Examples\n     ///\n@@ -485,9 +482,9 @@ impl Condvar {\n     ///\n     /// To wake up all threads, see [`notify_all`].\n     ///\n-    /// [`wait`]: #method.wait\n-    /// [`wait_timeout`]: #method.wait_timeout\n-    /// [`notify_all`]: #method.notify_all\n+    /// [`wait`]: Self::wait\n+    /// [`wait_timeout`]: Self::wait_timeout\n+    /// [`notify_all`]: Self::notify_all\n     ///\n     /// # Examples\n     ///\n@@ -527,7 +524,7 @@ impl Condvar {\n     ///\n     /// To wake up only one thread, see [`notify_one`].\n     ///\n-    /// [`notify_one`]: #method.notify_one\n+    /// [`notify_one`]: Self::notify_one\n     ///\n     /// # Examples\n     ///"}, {"sha": "ac83017d9e1246d35bd28a34618fae72823976c1", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 22, "deletions": 86, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=c5a8b7b9016731a1992569c5958ca4580c60119c", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Multi-producer, single-consumer FIFO queue communication primitives.\n //!\n //! This module provides message-based communication over channels, concretely\n@@ -27,12 +25,7 @@\n //!    that a bound of 0 is allowed, causing the channel to become a \"rendezvous\"\n //!    channel where each sender atomically hands off a message to a receiver.\n //!\n-//! [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n-//! [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n-//! [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n-//! [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n-//! [`channel`]: ../../../std/sync/mpsc/fn.channel.html\n-//! [`sync_channel`]: ../../../std/sync/mpsc/fn.sync_channel.html\n+//! [`send`]: Sender::send\n //!\n //! ## Disconnection\n //!\n@@ -46,9 +39,7 @@\n //! will continue to [`unwrap`] the results returned from this module,\n //! instigating a propagation of failure among threads if one unexpectedly dies.\n //!\n-//! [`Result`]: ../../../std/result/enum.Result.html\n-//! [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-//! [`unwrap`]: ../../../std/result/enum.Result.html#method.unwrap\n+//! [`unwrap`]: Result::unwrap\n //!\n //! # Examples\n //!\n@@ -291,9 +282,7 @@ mod cache_aligned;\n ///\n /// Messages sent to the channel can be retrieved using [`recv`].\n ///\n-/// [`channel`]: fn.channel.html\n-/// [`sync_channel`]: fn.sync_channel.html\n-/// [`recv`]: struct.Receiver.html#method.recv\n+/// [`recv`]: Receiver::recv\n ///\n /// # Examples\n ///\n@@ -333,10 +322,8 @@ impl<T> !Sync for Receiver<T> {}\n /// waiting for a new message, and [`None`] will be returned\n /// when the corresponding channel has hung up.\n ///\n-/// [`iter`]: struct.Receiver.html#method.iter\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n-/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+/// [`iter`]: Receiver::iter\n+/// [`next`]: Iterator::next\n ///\n /// # Examples\n ///\n@@ -371,9 +358,7 @@ pub struct Iter<'a, T: 'a> {\n /// This iterator will never block the caller in order to wait for data to\n /// become available. Instead, it will return [`None`].\n ///\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`try_iter`]: struct.Receiver.html#method.try_iter\n-/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+/// [`try_iter`]: Receiver::try_iter\n ///\n /// # Examples\n ///\n@@ -414,9 +399,7 @@ pub struct TryIter<'a, T: 'a> {\n /// is called, waiting for a new message, and [`None`] will be\n /// returned if the corresponding channel has hung up.\n ///\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n-/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+/// [`next`]: Iterator::next\n ///\n /// # Examples\n ///\n@@ -447,8 +430,7 @@ pub struct IntoIter<T> {\n ///\n /// Messages can be sent through this channel with [`send`].\n ///\n-/// [`channel`]: fn.channel.html\n-/// [`send`]: struct.Sender.html#method.send\n+/// [`send`]: Sender::send\n ///\n /// # Examples\n ///\n@@ -493,9 +475,8 @@ impl<T> !Sync for Sender<T> {}\n ///\n /// [`send`] will block if there is no space in the internal buffer.\n ///\n-/// [`sync_channel`]: fn.sync_channel.html\n-/// [`send`]: struct.SyncSender.html#method.send\n-/// [`try_send`]: struct.SyncSender.html#method.try_send\n+/// [`send`]: SyncSender::send\n+/// [`try_send`]: SyncSender::try_send\n ///\n /// # Examples\n ///\n@@ -549,8 +530,8 @@ unsafe impl<T: Send> Send for SyncSender<T> {}\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n ///\n-/// [`Sender::send`]: struct.Sender.html#method.send\n-/// [`SyncSender::send`]: struct.SyncSender.html#method.send\n+/// [`Sender::send`]: Sender::send\n+/// [`SyncSender::send`]: SyncSender::send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n@@ -561,10 +542,7 @@ pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n /// [`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n /// messages will ever be received.\n ///\n-/// [`recv`]: struct.Receiver.html#method.recv\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`channel`]: fn.channel.html\n-/// [`sync_channel`]: fn.sync_channel.html\n+/// [`recv`]: Receiver::recv\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n@@ -573,9 +551,7 @@ pub struct RecvError;\n /// not return data when called. This can occur with both a [`channel`] and\n /// a [`sync_channel`].\n ///\n-/// [`try_recv`]: struct.Receiver.html#method.try_recv\n-/// [`channel`]: fn.channel.html\n-/// [`sync_channel`]: fn.sync_channel.html\n+/// [`try_recv`]: Receiver::try_recv\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n@@ -594,9 +570,7 @@ pub enum TryRecvError {\n /// unable to return data when called. This can occur with both a [`channel`] and\n /// a [`sync_channel`].\n ///\n-/// [`recv_timeout`]: struct.Receiver.html#method.recv_timeout\n-/// [`channel`]: fn.channel.html\n-/// [`sync_channel`]: fn.sync_channel.html\n+/// [`recv_timeout`]: Receiver::recv_timeout\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n pub enum RecvTimeoutError {\n@@ -613,7 +587,7 @@ pub enum RecvTimeoutError {\n /// This enumeration is the list of the possible error outcomes for the\n /// [`try_send`] method.\n ///\n-/// [`try_send`]: struct.SyncSender.html#method.try_send\n+/// [`try_send`]: SyncSender::try_send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n@@ -623,16 +597,11 @@ pub enum TrySendError<T> {\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no [`Receiver`] available to\n     /// acquire the data.\n-    ///\n-    /// [`sync_channel`]: fn.sync_channel.html\n-    /// [`Receiver`]: struct.Receiver.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Full(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n \n     /// This [`sync_channel`]'s receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    ///\n-    /// [`sync_channel`]: fn.sync_channel.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n@@ -680,13 +649,8 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// [`Sender`] is disconnected while trying to [`recv`], the [`recv`] method will\n /// return a [`RecvError`].\n ///\n-/// [`send`]: struct.Sender.html#method.send\n-/// [`recv`]: struct.Receiver.html#method.recv\n-/// [`Sender`]: struct.Sender.html\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`sync_channel`]: fn.sync_channel.html\n-/// [`SendError`]: struct.SendError.html\n-/// [`RecvError`]: struct.RecvError.html\n+/// [`send`]: Sender::send\n+/// [`recv`]: Receiver::recv\n ///\n /// # Examples\n ///\n@@ -733,13 +697,8 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n /// [`SendError`]. Similarly, If the [`SyncSender`] is disconnected while trying\n /// to [`recv`], the [`recv`] method will return a [`RecvError`].\n ///\n-/// [`channel`]: fn.channel.html\n-/// [`send`]: struct.SyncSender.html#method.send\n-/// [`recv`]: struct.Receiver.html#method.recv\n-/// [`SyncSender`]: struct.SyncSender.html\n-/// [`Receiver`]: struct.Receiver.html\n-/// [`SendError`]: struct.SendError.html\n-/// [`RecvError`]: struct.RecvError.html\n+/// [`send`]: SyncSender::send\n+/// [`recv`]: Receiver::recv\n ///\n /// # Examples\n ///\n@@ -786,9 +745,6 @@ impl<T> Sender<T> {\n     /// will be received. It is possible for the corresponding receiver to\n     /// hang up immediately after this function returns [`Ok`].\n     ///\n-    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok`]: ../../../std/result/enum.Result.html#variant.Ok\n-    ///\n     /// This method will never block the current thread.\n     ///\n     /// # Examples\n@@ -933,9 +889,6 @@ impl<T> SyncSender<T> {\n     /// [`Receiver`] has disconnected and is no longer able to receive\n     /// information.\n     ///\n-    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-    /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n-    ///\n     /// # Examples\n     ///\n     /// ```rust\n@@ -971,7 +924,7 @@ impl<T> SyncSender<T> {\n     /// See [`send`] for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n     ///\n-    /// [`send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+    /// [`send`]: Self::send\n     ///\n     /// # Examples\n     ///\n@@ -1059,7 +1012,7 @@ impl<T> Receiver<T> {\n     /// Compared with [`recv`], this function has two failure cases instead of one\n     /// (one for disconnection, one for an empty buffer).\n     ///\n-    /// [`recv`]: struct.Receiver.html#method.recv\n+    /// [`recv`]: Self::recv\n     ///\n     /// # Examples\n     ///\n@@ -1117,10 +1070,6 @@ impl<T> Receiver<T> {\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// [`Sender`]: struct.Sender.html\n-    /// [`SyncSender`]: struct.SyncSender.html\n-    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1203,10 +1152,6 @@ impl<T> Receiver<T> {\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// [`Sender`]: struct.Sender.html\n-    /// [`SyncSender`]: struct.SyncSender.html\n-    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Known Issues\n     ///\n     /// There is currently a known issue (see [`#39364`]) that causes `recv_timeout`\n@@ -1304,10 +1249,6 @@ impl<T> Receiver<T> {\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// [`Sender`]: struct.Sender.html\n-    /// [`SyncSender`]: struct.SyncSender.html\n-    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// Successfully receiving value before reaching deadline:\n@@ -1397,9 +1338,6 @@ impl<T> Receiver<T> {\n     /// Returns an iterator that will block waiting for messages, but never\n     /// [`panic!`]. It will return [`None`] when the channel has hung up.\n     ///\n-    /// [`panic!`]: ../../../std/macro.panic.html\n-    /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```rust\n@@ -1430,8 +1368,6 @@ impl<T> Receiver<T> {\n     /// channel has hung up. The iterator will never [`panic!`] or block the\n     /// user by waiting for values.\n     ///\n-    /// [`panic!`]: ../../../std/macro.panic.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run"}, {"sha": "d7a4f00305c71a458501a599b3a529652a53bfda", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=c5a8b7b9016731a1992569c5958ca4580c60119c", "patch": "@@ -33,13 +33,12 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n /// the guard that would have otherwise been returned on a successful lock. This\n /// allows access to the data, despite the lock being poisoned.\n ///\n-/// [`new`]: #method.new\n-/// [`lock`]: #method.lock\n-/// [`try_lock`]: #method.try_lock\n-/// [`Result`]: ../../std/result/enum.Result.html\n-/// [`unwrap()`]: ../../std/result/enum.Result.html#method.unwrap\n-/// [`PoisonError`]: ../../std/sync/struct.PoisonError.html\n-/// [`into_inner`]: ../../std/sync/struct.PoisonError.html#method.into_inner\n+/// [`new`]: Self::new\n+/// [`lock`]: Self::lock\n+/// [`try_lock`]: Self::try_lock\n+/// [`unwrap()`]: Result::unwrap\n+/// [`PoisonError`]: super::PoisonError\n+/// [`into_inner`]: super::PoisonError::into_inner\n ///\n /// # Examples\n ///\n@@ -190,11 +189,8 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}\n /// This structure is created by the [`lock`] and [`try_lock`] methods on\n /// [`Mutex`].\n ///\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n-/// [`lock`]: struct.Mutex.html#method.lock\n-/// [`try_lock`]: struct.Mutex.html#method.try_lock\n-/// [`Mutex`]: struct.Mutex.html\n+/// [`lock`]: Mutex::lock\n+/// [`try_lock`]: Mutex::try_lock\n #[must_use = \"if unused the Mutex will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n@@ -289,8 +285,6 @@ impl<T: ?Sized> Mutex<T> {\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -432,8 +426,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n impl<T> From<T> for Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     /// This is equivalent to [`Mutex::new`].\n-    ///\n-    /// [`Mutex::new`]: ../../std/sync/struct.Mutex.html#method.new\n     fn from(t: T) -> Self {\n         Mutex::new(t)\n     }"}, {"sha": "586093c916deabb7f5dfed6626d7a895a7e6d57e", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a8b7b9016731a1992569c5958ca4580c60119c/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=c5a8b7b9016731a1992569c5958ca4580c60119c", "patch": "@@ -58,11 +58,7 @@ use crate::sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n ///\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n-/// [`Send`]: ../../std/marker/trait.Send.html\n-/// [`Sync`]: ../../std/marker/trait.Sync.html\n-/// [`Mutex`]: struct.Mutex.html\n+/// [`Mutex`]: super::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<sys::RWLock>,\n@@ -81,9 +77,8 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n /// This structure is created by the [`read`] and [`try_read`] methods on\n /// [`RwLock`].\n ///\n-/// [`read`]: struct.RwLock.html#method.read\n-/// [`try_read`]: struct.RwLock.html#method.try_read\n-/// [`RwLock`]: struct.RwLock.html\n+/// [`read`]: RwLock::read\n+/// [`try_read`]: RwLock::try_read\n #[must_use = \"if unused the RwLock will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n@@ -102,9 +97,8 @@ unsafe impl<T: ?Sized + Sync> Sync for RwLockReadGuard<'_, T> {}\n /// This structure is created by the [`write`] and [`try_write`] methods\n /// on [`RwLock`].\n ///\n-/// [`write`]: struct.RwLock.html#method.write\n-/// [`try_write`]: struct.RwLock.html#method.try_write\n-/// [`RwLock`]: struct.RwLock.html\n+/// [`write`]: RwLock::write\n+/// [`try_write`]: RwLock::try_write\n #[must_use = \"if unused the RwLock will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n@@ -456,8 +450,6 @@ impl<T: Default> Default for RwLock<T> {\n impl<T> From<T> for RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n     /// This is equivalent to [`RwLock::new`].\n-    ///\n-    /// [`RwLock::new`]: ../../std/sync/struct.RwLock.html#method.new\n     fn from(t: T) -> Self {\n         RwLock::new(t)\n     }"}]}