{"sha": "743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0M2Q5MjZkOWVlNWY4ZDVmMTdhNjZiMWZjMWE5MmUwZjY0OThkZDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:20Z"}, "message": "rollup merge of #20488: ltratt/nondeterministic_tempdir\n\nThe previous scheme made it possible for another user/attacker to cause the\ntemporary directory creation scheme to panic. All you needed to know was the pid\nof the process you wanted to target ('other_pid') and the suffix it was using\n(let's pretend it's 'sfx') and then code such as this would, in essence, DOS it:\n\n    for i in range(0u, 1001) {\n        let tp = &Path::new(format!(\"/tmp/rs-{}-{}-sfx\", other_pid, i));\n        match fs::mkdir(tp, io::USER_RWX) { _ => () }\n    }\n\nSince the scheme only 1000 times to create a temporary directory before dying,\nthe next time the attacked process called TempDir::new(\"sfx\") after that would\ntypically cause a panic. Of course, you don't necessarily need an attacker to\ncause such a DOS: creating 1000 temporary directories without closing any of the\nprevious would be enough to DOS yourself.\n\nThis patch broadly follows the OpenBSD implementation of mkstemp. It uses the\noperating system's random number generator to produce random directory names\nthat are impractical to guess (and, just in case someone manages to do that, it\nretries creating the directory for a long time before giving up; OpenBSD\nretries INT_MAX times, although 1<<31 seems enough to thwart even the most\npatient attacker).\n\nAs a small additional change while the file name is changing, this patch also\nmakes the argument that TempDir::new takes a prefix rather than a suffix.\nThis is because 1) it more closely matches what mkstemp and friends do 2)\nif you're going to have a deterministic part of a filename, you really want it at\nthe beginning so that shell completion is useful.", "tree": {"sha": "9e522baf4bff2b6c344bfa4046cee569b220a42b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e522baf4bff2b6c344bfa4046cee569b220a42b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "html_url": "https://github.com/rust-lang/rust/commit/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca40fe0f5e8085070f1bb678cba1ea85a09942b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca40fe0f5e8085070f1bb678cba1ea85a09942b1", "html_url": "https://github.com/rust-lang/rust/commit/ca40fe0f5e8085070f1bb678cba1ea85a09942b1"}, {"sha": "2c441958959e46fd03c7f2736806d75bebeebd30", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c441958959e46fd03c7f2736806d75bebeebd30", "html_url": "https://github.com/rust-lang/rust/commit/2c441958959e46fd03c7f2736806d75bebeebd30"}], "stats": {"total": 76, "additions": 45, "deletions": 31}, "files": [{"sha": "394686be814f24c593ce5c72080c6164c1fbc6be", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "patch": "@@ -10,16 +10,18 @@\n \n //! Temporary files and directories\n \n-use io::{fs, IoResult};\n+use io::{fs, IoError, IoErrorKind, IoResult};\n use io;\n-use libc;\n+use iter::{IteratorExt, range};\n use ops::Drop;\n use option::Option;\n use option::Option::{None, Some};\n use os;\n use path::{Path, GenericPath};\n+use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n-use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+use str::StrExt;\n+use string::String;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n@@ -31,7 +33,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n ///\n /// {\n ///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///     let tmpdir = match TempDir::new(\"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -46,7 +48,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n /// }\n /// {\n ///     // create a temporary directory, this time using a custom path\n-///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"mysuffix\") {\n+///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -61,7 +63,7 @@ use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n /// }\n /// {\n ///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///     let tmpdir = match TempDir::new(\"myprefix\") {\n ///         Ok(dir) => dir,\n ///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n ///     };\n@@ -78,47 +80,59 @@ pub struct TempDir {\n     disarmed: bool\n }\n \n+// How many times should we (re)try finding an unused random name? It should be\n+// enough that an attacker will run out of luck before we run out of patience.\n+const NUM_RETRIES: u32 = 1 << 31;\n+// How many characters should we include in a random file name? It needs to\n+// be enough to dissuade an attacker from trying to preemptively create names\n+// of that length, but not so huge that we unnecessarily drain the random number\n+// generator of entropy.\n+const NUM_RAND_CHARS: uint = 12;\n+\n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the suffix `suffix`. The directory will be automatically\n+    /// will have the prefix `prefix`. The directory will be automatically\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n-    pub fn new_in(tmpdir: &Path, suffix: &str) -> IoResult<TempDir> {\n+    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n             let abs_tmpdir = try!(os::make_absolute(tmpdir));\n-            return TempDir::new_in(&abs_tmpdir, suffix);\n+            return TempDir::new_in(&abs_tmpdir, prefix);\n         }\n \n-        static CNT: AtomicUint = ATOMIC_UINT_INIT;\n-\n-        let mut attempts = 0u;\n-        loop {\n-            let filename =\n-                format!(\"rs-{}-{}-{}\",\n-                        unsafe { libc::getpid() },\n-                        CNT.fetch_add(1, Ordering::SeqCst),\n-                        suffix);\n-            let p = tmpdir.join(filename);\n-            match fs::mkdir(&p, io::USER_RWX) {\n-                Err(error) => {\n-                    if attempts >= 1000 {\n-                        return Err(error)\n-                    }\n-                    attempts += 1;\n-                }\n-                Ok(()) => return Ok(TempDir { path: Some(p), disarmed: false })\n+        let mut rng = thread_rng();\n+        for _ in range(0, NUM_RETRIES) {\n+            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n+            let leaf = if prefix.len() > 0 {\n+                format!(\"{}.{}\", prefix, suffix)\n+            } else {\n+                // If we're given an empty string for a prefix, then creating a\n+                // directory starting with \".\" would lead to it being\n+                // semi-invisible on some systems.\n+                suffix\n+            };\n+            let path = tmpdir.join(leaf);\n+            match fs::mkdir(&path, io::USER_RWX) {\n+                Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n+                Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n+                Err(e) => return Err(e)\n             }\n         }\n+\n+        return Err(IoError{\n+                       kind: IoErrorKind::PathAlreadyExists,\n+                       desc:\"Exhausted\",\n+                       detail: None});\n     }\n \n     /// Attempts to make a temporary directory inside of `os::tmpdir()` whose\n-    /// name will have the suffix `suffix`. The directory will be automatically\n+    /// name will have the prefix `prefix`. The directory will be automatically\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n-    pub fn new(suffix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&os::tmpdir(), suffix)\n+    pub fn new(prefix: &str) -> IoResult<TempDir> {\n+        TempDir::new_in(&os::tmpdir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "bf108ecd6764a954e681940487786c1e78a21382", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=743d926d9ee5f8d5f17a66b1fc1a92e0f6498dd8", "patch": "@@ -29,7 +29,7 @@ fn test_tempdir() {\n     let path = {\n         let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n-        assert!(p.as_vec().ends_with(b\"foobar\"));\n+        assert!(p.as_str().unwrap().contains(\"foobar\"));\n         p.clone()\n     };\n     assert!(!path.exists());"}]}