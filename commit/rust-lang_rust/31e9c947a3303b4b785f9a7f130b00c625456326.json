{"sha": "31e9c947a3303b4b785f9a7f130b00c625456326", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTljOTQ3YTMzMDNiNGI3ODVmOWE3ZjEzMGIwMGM2MjU0NTYzMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T08:26:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T08:26:34Z"}, "message": "auto merge of #12544 : erickt/rust/hash, r=acrichto\n\nThis PR allows `HashMap`s to work with custom hashers. Also with this patch are:\r\n\r\n* a couple generic implementations of `Hash` for a variety of types.\r\n* added `Default`, `Clone` impls to the hashers.\r\n* added a `HashMap::with_hasher()` constructor.", "tree": {"sha": "8daf10f7d8edc96b76b673f3e357e212f8eb9e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8daf10f7d8edc96b76b673f3e357e212f8eb9e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e9c947a3303b4b785f9a7f130b00c625456326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e9c947a3303b4b785f9a7f130b00c625456326", "html_url": "https://github.com/rust-lang/rust/commit/31e9c947a3303b4b785f9a7f130b00c625456326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e9c947a3303b4b785f9a7f130b00c625456326/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e90c15a6e677f13981b58373f7427384a9188f", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e90c15a6e677f13981b58373f7427384a9188f", "html_url": "https://github.com/rust-lang/rust/commit/53e90c15a6e677f13981b58373f7427384a9188f"}, {"sha": "adeb730c7796156bd5fb63d75e13cab655b10ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/adeb730c7796156bd5fb63d75e13cab655b10ece", "html_url": "https://github.com/rust-lang/rust/commit/adeb730c7796156bd5fb63d75e13cab655b10ece"}], "stats": {"total": 291, "additions": 181, "deletions": 110}, "files": [{"sha": "0ffe7c31bb859ac8f3285c9e604d9a9fea4d1d64", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 101, "deletions": 81, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -55,7 +55,8 @@\n use std::cmp::max;\n use std::default::Default;\n use std::fmt;\n-use std::hash::{Hash, Hasher, sip};\n+use std::hash::{Hash, Hasher};\n+use std::hash::sip::{SipState, SipHasher};\n use std::iter::{FilterMap, Chain, Repeat, Zip};\n use std::iter;\n use std::mem::replace;\n@@ -78,10 +79,10 @@ struct Bucket<K,V> {\n /// hash function for internal state. This means that the order of all hash maps\n /// is randomized by keying each hash map randomly on creation.\n ///\n-/// It is required that the keys implement the `Eq` and `Hash` traits.\n-pub struct HashMap<K,V> {\n-    priv k0: u64,\n-    priv k1: u64,\n+/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// this can frequently be achieved by using `#[deriving(Eq, Hash)]`.\n+pub struct HashMap<K, V, H = SipHasher> {\n+    priv hasher: H,\n     priv resize_at: uint,\n     priv size: uint,\n     priv buckets: Vec<Option<Bucket<K, V>>>\n@@ -98,7 +99,7 @@ fn resize_at(capacity: uint) -> uint {\n     (capacity * 3) / 4\n }\n \n-impl<K:Hash + Eq, V> HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[inline]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n@@ -127,14 +128,13 @@ impl<K:Hash + Eq, V> HashMap<K, V> {\n \n     #[inline]\n     fn bucket_for_key(&self, k: &K) -> SearchResult {\n-        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n+        let hash = self.hasher.hash(k) as uint;\n         self.bucket_for_key_with_hash(hash, k)\n     }\n \n     #[inline]\n-    fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n-                                               -> SearchResult {\n-        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n+    fn bucket_for_key_equiv<Q:Hash<S> + Equiv<K>>(&self, k: &Q) -> SearchResult {\n+        let hash = self.hasher.hash(k) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n \n@@ -285,12 +285,12 @@ impl<K:Hash + Eq, V> HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint { self.size }\n }\n \n-impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         for bkt in self.buckets.as_mut_slice().mut_iter() {\n@@ -300,7 +300,7 @@ impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n@@ -310,7 +310,7 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + Eq,V> MutableMap<K, V> for HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n     /// Return a mutable reference to the value corresponding to the key\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n@@ -335,42 +335,49 @@ impl<K:Hash + Eq,V> MutableMap<K, V> for HashMap<K, V> {\n             self.expand();\n         }\n \n-        let hash = sip::hash_with_keys(self.k0, self.k1, &k) as uint;\n+        let hash = self.hasher.hash(&k) as uint;\n         self.insert_internal(hash, k, v)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     fn pop(&mut self, k: &K) -> Option<V> {\n-        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n+        let hash = self.hasher.hash(k) as uint;\n         self.pop_internal(hash, k)\n     }\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// Create an empty HashMap\n-    pub fn new() -> HashMap<K, V> {\n+    pub fn new() -> HashMap<K, V, SipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashMap with space for at least `capacity`\n     /// elements in the hash table.\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V> {\n         let mut r = rand::task_rng();\n-        HashMap::with_capacity_and_keys(r.gen(), r.gen(), capacity)\n+        let hasher = SipHasher::new_with_keys(r.gen(), r.gen());\n+        HashMap::with_capacity_and_hasher(hasher, capacity)\n+    }\n+}\n+\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n+        HashMap::with_capacity_and_hasher(hasher, INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashMap with space for at least `capacity`\n-    /// elements, using `k0` and `k1` as the keys.\n+    /// elements, using `hasher` to hash the keys.\n     ///\n-    /// Warning: `k0` and `k1` are normally randomly generated, and\n-    /// are designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting them\n+    /// Warning: `hasher` is normally randomly generated, and\n+    /// is designed to allow HashMaps to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n-    pub fn with_capacity_and_keys(k0: u64, k1: u64, capacity: uint) -> HashMap<K, V> {\n+    pub fn with_capacity_and_hasher(hasher: H, capacity: uint) -> HashMap<K, V, H> {\n         let cap = max(INITIAL_CAPACITY, capacity);\n         HashMap {\n-            k0: k0, k1: k1,\n+            hasher: hasher,\n             resize_at: resize_at(cap),\n             size: 0,\n             buckets: Vec::from_fn(cap, |_| None)\n@@ -442,7 +449,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             self.expand();\n         }\n \n-        let hash = sip::hash_with_keys(self.k0, self.k1, &k) as uint;\n+        let hash = self.hasher.hash(&k) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => fail!(\"Internal logic error\"),\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n@@ -502,7 +509,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n-    pub fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n+    pub fn contains_key_equiv<Q:Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         match self.bucket_for_key_equiv(key) {\n             FoundEntry(_) => {true}\n             TableFull | FoundHole(_) => {false}\n@@ -511,8 +518,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n-    pub fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q)\n-                                             -> Option<&'a V> {\n+    pub fn find_equiv<'a, Q:Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n@@ -552,7 +558,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n }\n \n-impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n@@ -564,8 +570,8 @@ impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n-    fn eq(&self, other: &HashMap<K, V>) -> bool {\n+impl<K: Hash<S> + Eq, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n+    fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)| {\n@@ -576,20 +582,20 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n         })\n     }\n \n-    fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &HashMap<K, V, H>) -> bool { !self.eq(other) }\n }\n \n-impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n-    fn clone(&self) -> HashMap<K,V> {\n-        let mut new_map = HashMap::with_capacity(self.len());\n+impl<K: Hash<S> + Eq + Clone, V:Clone, S, H: Hasher<S> + Clone> Clone for HashMap<K, V, H> {\n+    fn clone(&self) -> HashMap<K, V, H> {\n+        let mut new_map = HashMap::with_capacity_and_hasher(self.hasher.clone(), self.len());\n         for (key, value) in self.iter() {\n             new_map.insert((*key).clone(), (*value).clone());\n         }\n         new_map\n     }\n }\n \n-impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for HashMap<A, B> {\n+impl<K: fmt::Show + Hash<S> + Eq, V: fmt::Show, S, H: Hasher<S>> fmt::Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f.buf, r\"\\{\"))\n         let mut first = true;\n@@ -705,71 +711,73 @@ impl<K> Iterator<K> for SetMoveItems<K> {\n     }\n }\n \n-impl<K: Eq + Hash, V> FromIterator<(K, V)> for HashMap<K, V> {\n-    fn from_iterator<T: Iterator<(K, V)>>(iter: &mut T) -> HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n+    fn from_iterator<T: Iterator<(K, V)>>(iter: &mut T) -> HashMap<K, V, H> {\n         let (lower, _) = iter.size_hint();\n-        let mut map = HashMap::with_capacity(lower);\n+        let mut map = HashMap::with_capacity_and_hasher(Default::default(), lower);\n         map.extend(iter);\n         map\n     }\n }\n \n-impl<K: Eq + Hash, V> Extendable<(K, V)> for HashMap<K, V> {\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<(K, V)>>(&mut self, iter: &mut T) {\n         for (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<K: Eq + Hash, V> Default for HashMap<K, V> {\n-    fn default() -> HashMap<K, V> { HashMap::new() }\n+impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n+    fn default() -> HashMap<K, V, H> {\n+        HashMap::with_capacity_and_hasher(Default::default(), INITIAL_CAPACITY)\n+    }\n }\n \n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n-pub struct HashSet<T> {\n-    priv map: HashMap<T, ()>\n+pub struct HashSet<T, H = SipHasher> {\n+    priv map: HashMap<T, (), H>\n }\n \n-impl<T:Hash + Eq> Eq for HashSet<T> {\n-    fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n-    fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> Eq for HashSet<T, H> {\n+    fn eq(&self, other: &HashSet<T, H>) -> bool { self.map == other.map }\n+    fn ne(&self, other: &HashSet<T, H>) -> bool { self.map != other.map }\n }\n \n-impl<T:Hash + Eq> Container for HashSet<T> {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> Container for HashSet<T, H> {\n     /// Return the number of elements in the set\n     fn len(&self) -> uint { self.map.len() }\n }\n \n-impl<T:Hash + Eq> Mutable for HashSet<T> {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Hash + Eq> Set<T> for HashSet<T> {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n+    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n \n     /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &HashSet<T>) -> bool {\n+    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n \n     /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &HashSet<T>) -> bool {\n+    fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n         other.is_subset(self)\n     }\n }\n \n-impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n@@ -779,27 +787,35 @@ impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T:Hash + Eq> HashSet<T> {\n+impl<T: Hash<SipState> + Eq> HashSet<T, SipHasher> {\n     /// Create an empty HashSet\n-    pub fn new() -> HashSet<T> {\n+    pub fn new() -> HashSet<T, SipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashSet<T> {\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, SipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n+}\n+\n+impl<T: Hash<S> + Eq, S, H: Hasher<S>> HashSet<T, H> {\n+    pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n+        HashSet::with_capacity_and_hasher(hasher, INITIAL_CAPACITY)\n+    }\n \n     /// Create an empty HashSet with space for at least `capacity`\n     /// elements in the hash table, using `k0` and `k1` as the keys.\n     ///\n-    /// Warning: `k0` and `k1` are normally randomly generated, and\n+    /// Warning: `hasher` is normally randomly generated, and\n     /// are designed to allow HashSets to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting them\n     /// manually using this function can expose a DoS attack vector.\n-    pub fn with_capacity_and_keys(k0: u64, k1: u64, capacity: uint) -> HashSet<T> {\n-        HashSet { map: HashMap::with_capacity_and_keys(k0, k1, capacity) }\n+    pub fn with_capacity_and_hasher(hasher: H, capacity: uint) -> HashSet<T, H> {\n+        HashSet {\n+            map: HashMap::with_capacity_and_hasher(hasher, capacity)\n+        }\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n@@ -809,7 +825,7 @@ impl<T:Hash + Eq> HashSet<T> {\n \n     /// Returns true if the hash set contains a value equivalent to the\n     /// given query value.\n-    pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n+    pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n \n@@ -827,7 +843,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraItems<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other)\n             .zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -836,14 +852,14 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the symmetric difference\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<SetAlgebraItems<'a, T>, SetAlgebraItems<'a, T>> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n         self.difference(other).chain(other.difference(self))\n     }\n \n     /// Visit the values representing the intersection\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T>)\n-        -> SetAlgebraItems<'a, T> {\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other)\n             .zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -852,22 +868,22 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the union\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T>> {\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))\n     }\n \n }\n \n-impl<T:Hash + Eq + Clone> Clone for HashSet<T> {\n-    fn clone(&self) -> HashSet<T> {\n+impl<T: Hash<S> + Eq + Clone, S, H: Hasher<S> + Clone> Clone for HashSet<T, H> {\n+    fn clone(&self) -> HashSet<T, H> {\n         HashSet {\n             map: self.map.clone()\n         }\n     }\n }\n \n-impl<A: fmt::Show + Hash + Eq> fmt::Show for HashSet<A> {\n+impl<T: fmt::Show + Hash<S> + Eq, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f.buf, r\"\\{\"))\n         let mut first = true;\n@@ -883,33 +899,37 @@ impl<A: fmt::Show + Hash + Eq> fmt::Show for HashSet<A> {\n     }\n }\n \n-impl<K: Eq + Hash> FromIterator<K> for HashSet<K> {\n-    fn from_iterator<T: Iterator<K>>(iter: &mut T) -> HashSet<K> {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+    fn from_iterator<Iter: Iterator<T>>(iter: &mut Iter) -> HashSet<T, H> {\n         let (lower, _) = iter.size_hint();\n-        let mut set = HashSet::with_capacity(lower);\n+        let mut set = HashSet::with_capacity_and_hasher(Default::default(), lower);\n         set.extend(iter);\n         set\n     }\n }\n \n-impl<K: Eq + Hash> Extendable<K> for HashSet<K> {\n-    fn extend<T: Iterator<K>>(&mut self, iter: &mut T) {\n+impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+    fn extend<Iter: Iterator<T>>(&mut self, iter: &mut Iter) {\n         for k in *iter {\n             self.insert(k);\n         }\n     }\n }\n \n-impl<K: Eq + Hash> Default for HashSet<K> {\n-    fn default() -> HashSet<K> { HashSet::new() }\n+impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+    fn default() -> HashSet<T, H> {\n+        HashSet {\n+            map: Default::default(),\n+        }\n+    }\n }\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator\n-pub type SetAlgebraItems<'a, T> =\n-    FilterMap<'static,(&'a HashSet<T>, &'a T), &'a T,\n-              Zip<Repeat<&'a HashSet<T>>,SetItems<'a,T>>>;\n+pub type SetAlgebraItems<'a, T, H> =\n+    FilterMap<'static,(&'a HashSet<T, H>, &'a T), &'a T,\n+              Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "fb8cd61b703883a4632dff4910e31a9974764ee3", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -17,7 +17,11 @@\n #[crate_type = \"dylib\"];\n #[license = \"MIT/ASL2\"];\n \n-#[feature(macro_rules, managed_boxes)];\n+#[feature(macro_rules, managed_boxes, default_type_params)];\n+\n+// NOTE remove the following two attributes after the next snapshot.\n+#[allow(unrecognized_lint)];\n+#[allow(default_type_param_usage)];\n \n #[cfg(test)] extern crate test;\n "}, {"sha": "6b26e268057af11373cf1e671bb63161162d9685", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -4883,7 +4883,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n-    let mut state = sip::SipState::new(0, 0);\n+    let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n "}, {"sha": "4db9134640247e6aa12815198784266b13ce5660", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -11,7 +11,8 @@\n //! Implementations of serialization for structures found in libcollections\n \n use std::uint;\n-use std::hash::Hash;\n+use std::default::Default;\n+use std::hash::{Hash, Hasher};\n \n use {Decodable, Encodable, Decoder, Encoder};\n use collections::{DList, RingBuf, TreeMap, TreeSet, Deque, HashMap, HashSet,\n@@ -164,9 +165,11 @@ impl<\n \n impl<\n     E: Encoder,\n-    K: Encodable<E> + Hash + Eq,\n-    V: Encodable<E>\n-> Encodable<E> for HashMap<K, V> {\n+    K: Encodable<E> + Hash<S> + Eq,\n+    V: Encodable<E>,\n+    S,\n+    H: Hasher<S>\n+> Encodable<E> for HashMap<K, V, H> {\n     fn encode(&self, e: &mut E) {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -181,12 +184,15 @@ impl<\n \n impl<\n     D: Decoder,\n-    K: Decodable<D> + Hash + Eq,\n-    V: Decodable<D>\n-> Decodable<D> for HashMap<K, V> {\n-    fn decode(d: &mut D) -> HashMap<K, V> {\n+    K: Decodable<D> + Hash<S> + Eq,\n+    V: Decodable<D>,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D> for HashMap<K, V, H> {\n+    fn decode(d: &mut D) -> HashMap<K, V, H> {\n         d.read_map(|d, len| {\n-            let mut map = HashMap::with_capacity(len);\n+            let hasher = Default::default();\n+            let mut map = HashMap::with_capacity_and_hasher(hasher, len);\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n@@ -198,10 +204,12 @@ impl<\n }\n \n impl<\n-    S: Encoder,\n-    T: Encodable<S> + Hash + Eq\n-> Encodable<S> for HashSet<T> {\n-    fn encode(&self, s: &mut S) {\n+    E: Encoder,\n+    T: Encodable<E> + Hash<S> + Eq,\n+    S,\n+    H: Hasher<S>\n+> Encodable<E> for HashSet<T, H> {\n+    fn encode(&self, s: &mut E) {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n@@ -214,11 +222,13 @@ impl<\n \n impl<\n     D: Decoder,\n-    T: Decodable<D> + Hash + Eq\n-> Decodable<D> for HashSet<T> {\n-    fn decode(d: &mut D) -> HashSet<T> {\n+    T: Decodable<D> + Hash<S> + Eq,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D> for HashSet<T, H> {\n+    fn decode(d: &mut D) -> HashSet<T, H> {\n         d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity(len);\n+            let mut set = HashSet::with_capacity_and_hasher(Default::default(), len);\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }"}, {"sha": "028e1e742c47ef249f26e7ed20d0e9850ef39ffc", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -20,7 +20,11 @@ Core encoding and decoding interfaces.\n #[license = \"MIT/ASL2\"];\n #[allow(missing_doc)];\n #[forbid(non_camel_case_types)];\n-#[feature(macro_rules,managed_boxes)];\n+#[feature(macro_rules, managed_boxes, default_type_params)];\n+\n+// NOTE remove the following two attributes after the next snapshot.\n+#[allow(unrecognized_lint)];\n+#[allow(default_type_param_usage)];\n \n // test harness access\n #[cfg(test)]"}, {"sha": "d1d4d4c90f93e6d285f64f4cee9b76328ebacbc6", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e9c947a3303b4b785f9a7f130b00c625456326/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=31e9c947a3303b4b785f9a7f130b00c625456326", "patch": "@@ -24,7 +24,9 @@\n  * discouraged.\n  */\n \n+use clone::Clone;\n use container::Container;\n+use default::Default;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use result::Ok;\n@@ -81,7 +83,13 @@ macro_rules! compress (\n impl SipState {\n     /// Create a `SipState` that is keyed off the provided keys.\n     #[inline]\n-    pub fn new(key0: u64, key1: u64) -> SipState {\n+    pub fn new() -> SipState {\n+        SipState::new_with_keys(0, 0)\n+    }\n+\n+    /// Create a `SipState` that is keyed off the provided keys.\n+    #[inline]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipState {\n         let mut state = SipState {\n             k0: key0,\n             k1: key1,\n@@ -206,9 +214,25 @@ impl Writer for SipState {\n     }\n }\n \n-/// `Sip` computes the SipHash algorithm from a stream of bytes.\n+impl Clone for SipState {\n+    #[inline]\n+    fn clone(&self) -> SipState {\n+        *self\n+    }\n+}\n+\n+impl Default for SipState {\n+    #[inline]\n+    fn default() -> SipState {\n+        SipState::new()\n+    }\n+}\n+\n+/// `SipHasher` computes the SipHash algorithm from a stream of bytes.\n+#[deriving(Clone)]\n pub struct SipHasher {\n-    priv state: SipState,\n+    priv k0: u64,\n+    priv k1: u64,\n }\n \n impl SipHasher {\n@@ -222,31 +246,40 @@ impl SipHasher {\n     #[inline]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher {\n-            state: SipState::new(key0, key1),\n+            k0: key0,\n+            k1: key1,\n         }\n     }\n }\n \n impl Hasher<SipState> for SipHasher {\n     #[inline]\n     fn hash<T: Hash<SipState>>(&self, value: &T) -> u64 {\n-        let mut state = self.state; // implicitly copy the state.\n+        let mut state = SipState::new_with_keys(self.k0, self.k1);\n         value.hash(&mut state);\n         state.result()\n     }\n }\n \n+impl Default for SipHasher {\n+    #[inline]\n+    fn default() -> SipHasher {\n+        SipHasher::new()\n+    }\n+}\n \n /// Hash a value using the SipHash algorithm.\n #[inline]\n pub fn hash<T: Hash<SipState>>(value: &T) -> u64 {\n-    hash_with_keys(0, 0, value)\n+    let mut state = SipState::new();\n+    value.hash(&mut state);\n+    state.result()\n }\n \n /// Hash a value with the SipHash algorithm with the provided keys.\n #[inline]\n pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n-    let mut state = SipState::new(k0, k1);\n+    let mut state = SipState::new_with_keys(k0, k1);\n     value.hash(&mut state);\n     state.result()\n }\n@@ -350,8 +383,8 @@ mod tests {\n         let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n         let mut buf : ~[u8] = ~[];\n         let mut t = 0;\n-        let mut state_inc = SipState::new(k0, k1);\n-        let mut state_full = SipState::new(k0, k1);\n+        let mut state_inc = SipState::new_with_keys(k0, k1);\n+        let mut state_full = SipState::new_with_keys(k0, k1);\n \n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";"}]}