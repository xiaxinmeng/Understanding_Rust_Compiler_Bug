{"sha": "b25b6b3355efa33c797f4a37afb2f516531ad581", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWI2YjMzNTVlZmEzM2M3OTdmNGEzN2FmYjJmNTE2NTMxYWQ1ODE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-09T07:30:56Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-14T07:43:26Z"}, "message": "Rustfmt", "tree": {"sha": "40ad547e856bc16b05da4b5c1caa4a9b09366407", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40ad547e856bc16b05da4b5c1caa4a9b09366407"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25b6b3355efa33c797f4a37afb2f516531ad581", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmRVJ4ACgkQpp+NIls6\n19ligw//Y1QdUvNvqSe5ah9a0YBpDrt/aqPHbHBKGGOJYpT34z1s5tnIho7CJgjQ\nXiNbiMqiNkH41wRfPtEzfZyc+zeL8NEmuKjBsZJgtE1aSmQKWbErBKPxXBTbKFqM\nzWdPprun2w7j3DFamBYUkRPubg69HMfonCbCJ75hNnFcq1xrYTCuoIjEvx9gfmLa\nETu3osYg4gGwWD88Ra/41yLOeEbN1DiNyM8VAm9M7XHBLkXy3AOmJkiy1wLPWIon\nZUbrfpg1WP6rsvcmT4fWx55HAfGAzoH4sxw+Zvd6ey6e3dEU4YOij6Um8Eq8Urga\ni6A0MMboWqAoM1FPNAbinThaMG3eN9yZU5ZJ7uLKrzG+pcO76Z8nfNFdooilivmd\nf58LN+7bvrZBlgaDCfAUASelv6+B873SnNBQvP6+JcADF3w5xwMA9vJBcumHdBCX\nU7HIndw1U0htAqbxns1IsxizOfOVdzb6tdJQaX2G/WBWSjEE1qw/38Z6gjbezQbD\nMUI55g4dvSNNRPao4q8Jtag0Wn0nXnXfjnV0A1MJzltfoBlnF544pc6YpwhCKYFq\nI0awJP54XaQl8iI8vanmljNavi4pkWcU7kLSTtNtP3vazArEeGxVkS5knjjkny6p\nY2qCFo8iGZsUIE2moJpmB48mDm55IRG0gfohS4cm6n3mJKCq3/U=\n=gTeK\n-----END PGP SIGNATURE-----", "payload": "tree 40ad547e856bc16b05da4b5c1caa4a9b09366407\nparent 705c6ec2a4bfe3beeb802e51d9b8247b33a62997\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502263856 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502696606 +0200\n\nRustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25b6b3355efa33c797f4a37afb2f516531ad581", "html_url": "https://github.com/rust-lang/rust/commit/b25b6b3355efa33c797f4a37afb2f516531ad581", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25b6b3355efa33c797f4a37afb2f516531ad581/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "705c6ec2a4bfe3beeb802e51d9b8247b33a62997", "url": "https://api.github.com/repos/rust-lang/rust/commits/705c6ec2a4bfe3beeb802e51d9b8247b33a62997", "html_url": "https://github.com/rust-lang/rust/commit/705c6ec2a4bfe3beeb802e51d9b8247b33a62997"}], "stats": {"total": 5118, "additions": 3093, "deletions": 2025}, "files": [{"sha": "cbe12e58119d6e9ea006cc27b0230bc7112ddf66", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -7,9 +7,11 @@ use utils::span_lint;\n \n /// **What it does:** Checks for floating point literals that approximate\n /// constants which are defined in\n-/// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+/// [`std::f32::consts`](https://doc.rust-lang.\n+/// org/stable/std/f32/consts/#constants)\n /// or\n-/// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+/// [`std::f64::consts`](https://doc.rust-lang.\n+/// org/stable/std/f64/consts/#constants),\n /// respectively, suggesting to use the predefined constant.\n ///\n /// **Why is this bad?** Usually, the definition in the standard library is more\n@@ -33,24 +35,26 @@ declare_lint! {\n }\n \n // Tuples are of the form (constant, name, min_digits)\n-const KNOWN_CONSTS: &'static [(f64, &'static str, usize)] = &[(f64::E, \"E\", 4),\n-                                                              (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n-                                                              (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n-                                                              (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n-                                                              (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n-                                                              (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n-                                                              (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n-                                                              (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n-                                                              (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n-                                                              (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n-                                                              (f64::LN_10, \"LN_10\", 5),\n-                                                              (f64::LN_2, \"LN_2\", 5),\n-                                                              (f64::LOG10_E, \"LOG10_E\", 5),\n-                                                              (f64::LOG2_E, \"LOG2_E\", 5),\n-                                                              (f64::PI, \"PI\", 3),\n-                                                              (f64::SQRT_2, \"SQRT_2\", 5)];\n+const KNOWN_CONSTS: &'static [(f64, &'static str, usize)] = &[\n+    (f64::E, \"E\", 4),\n+    (f64::FRAC_1_PI, \"FRAC_1_PI\", 4),\n+    (f64::FRAC_1_SQRT_2, \"FRAC_1_SQRT_2\", 5),\n+    (f64::FRAC_2_PI, \"FRAC_2_PI\", 5),\n+    (f64::FRAC_2_SQRT_PI, \"FRAC_2_SQRT_PI\", 5),\n+    (f64::FRAC_PI_2, \"FRAC_PI_2\", 5),\n+    (f64::FRAC_PI_3, \"FRAC_PI_3\", 5),\n+    (f64::FRAC_PI_4, \"FRAC_PI_4\", 5),\n+    (f64::FRAC_PI_6, \"FRAC_PI_6\", 5),\n+    (f64::FRAC_PI_8, \"FRAC_PI_8\", 5),\n+    (f64::LN_10, \"LN_10\", 5),\n+    (f64::LN_2, \"LN_2\", 5),\n+    (f64::LOG10_E, \"LOG10_E\", 5),\n+    (f64::LOG2_E, \"LOG2_E\", 5),\n+    (f64::PI, \"PI\", 3),\n+    (f64::SQRT_2, \"SQRT_2\", 5),\n+];\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct Pass;\n \n impl LintPass for Pass {\n@@ -81,13 +85,17 @@ fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &s\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {\n             if is_approx_const(constant, &s, min_digits) {\n-                span_lint(cx,\n-                          APPROX_CONSTANT,\n-                          e.span,\n-                          &format!(\"approximate value of `{}::consts::{}` found. \\\n+                span_lint(\n+                    cx,\n+                    APPROX_CONSTANT,\n+                    e.span,\n+                    &format!(\n+                        \"approximate value of `{}::consts::{}` found. \\\n                                     Consider using it directly\",\n-                                   module,\n-                                   &name));\n+                        module,\n+                        &name\n+                    ),\n+                );\n                 return;\n             }\n         }"}, {"sha": "422935fa06724e0ae40bd5128987a24d188efc5f", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -8,7 +8,8 @@ use rustc::hir;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n \n-/// **What it does:** Checks for out of bounds array indexing with a constant index.\n+/// **What it does:** Checks for out of bounds array indexing with a constant\n+/// index.\n ///\n /// **Why is this bad?** This will always panic at runtime.\n ///\n@@ -46,7 +47,7 @@ declare_restriction_lint! {\n     \"indexing/slicing usage\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct ArrayIndexing;\n \n impl LintPass for ArrayIndexing {\n@@ -61,8 +62,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tables.expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n-                let size = ConstInt::Usize(ConstUsize::new(size as u64, cx.sess().target.uint_type)\n-                    .expect(\"array size is invalid\"));\n+                let size = ConstInt::Usize(\n+                    ConstUsize::new(size as u64, cx.sess().target.uint_type).expect(\"array size is invalid\"),\n+                );\n                 let parent_item = cx.tcx.hir.get_parent(e.id);\n                 let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n                 let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n@@ -80,12 +82,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n \n                 // Index is a constant range\n                 if let Some(range) = higher::range(index) {\n-                    let start = range.start\n-                        .map(|start| constcx.eval(start))\n-                        .map(|v| v.ok());\n-                    let end = range.end\n-                        .map(|end| constcx.eval(end))\n-                        .map(|v| v.ok());\n+                    let start = range.start.map(|start| constcx.eval(start)).map(|v| v.ok());\n+                    let end = range.end.map(|end| constcx.eval(end)).map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(&start, &end, range.limits, size) {\n                         if start > size || end > size {\n@@ -111,12 +109,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n     }\n }\n \n-/// Returns an option containing a tuple with the start and end (exclusive) of the range.\n+/// Returns an option containing a tuple with the start and end (exclusive) of\n+/// the range.\n fn to_const_range(\n     start: &Option<Option<ConstVal>>,\n     end: &Option<Option<ConstVal>>,\n     limits: RangeLimits,\n-    array_size: ConstInt\n+    array_size: ConstInt,\n ) -> Option<(ConstInt, ConstInt)> {\n     let start = match *start {\n         Some(Some(ConstVal::Integral(x))) => x,\n@@ -128,24 +127,23 @@ fn to_const_range(\n         Some(Some(ConstVal::Integral(x))) => {\n             if limits == RangeLimits::Closed {\n                 match x {\n-                        ConstInt::U8(_) => (x + ConstInt::U8(1)),\n-                        ConstInt::U16(_) => (x + ConstInt::U16(1)),\n-                        ConstInt::U32(_) => (x + ConstInt::U32(1)),\n-                        ConstInt::U64(_) => (x + ConstInt::U64(1)),\n-                        ConstInt::U128(_) => (x + ConstInt::U128(1)),\n-                        ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n-                        ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n-                        ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n-                        ConstInt::I8(_) => (x + ConstInt::I8(1)),\n-                        ConstInt::I16(_) => (x + ConstInt::I16(1)),\n-                        ConstInt::I32(_) => (x + ConstInt::I32(1)),\n-                        ConstInt::I64(_) => (x + ConstInt::I64(1)),\n-                        ConstInt::I128(_) => (x + ConstInt::I128(1)),\n-                        ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n-                        ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n-                        ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n-                    }\n-                    .expect(\"such a big array is not realistic\")\n+                    ConstInt::U8(_) => (x + ConstInt::U8(1)),\n+                    ConstInt::U16(_) => (x + ConstInt::U16(1)),\n+                    ConstInt::U32(_) => (x + ConstInt::U32(1)),\n+                    ConstInt::U64(_) => (x + ConstInt::U64(1)),\n+                    ConstInt::U128(_) => (x + ConstInt::U128(1)),\n+                    ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n+                    ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n+                    ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n+                    ConstInt::I8(_) => (x + ConstInt::I8(1)),\n+                    ConstInt::I16(_) => (x + ConstInt::I16(1)),\n+                    ConstInt::I32(_) => (x + ConstInt::I32(1)),\n+                    ConstInt::I64(_) => (x + ConstInt::I64(1)),\n+                    ConstInt::I128(_) => (x + ConstInt::I128(1)),\n+                    ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n+                    ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n+                    ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n+                }.expect(\"such a big array is not realistic\")\n             } else {\n                 x\n             }"}, {"sha": "759bb9f12ec1fe24071ecefde7e8ccc5252007fa", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -4,12 +4,14 @@ use syntax::ast;\n use utils::{span_lint_and_then, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n use utils::{higher, sugg};\n \n-/// **What it does:** Checks for compound assignment operations (`+=` and similar).\n+/// **What it does:** Checks for compound assignment operations (`+=` and\n+/// similar).\n ///\n /// **Why is this bad?** Projects with many developers from languages without\n /// those operations may find them unreadable and not worth their weight.\n ///\n-/// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`.\n+/// **Known problems:** Types implementing `OpAssign` don't necessarily\n+/// implement `Op`.\n ///\n /// **Example:**\n /// ```rust\n@@ -20,7 +22,8 @@ declare_restriction_lint! {\n     \"any compound assignment operation\"\n }\n \n-/// **What it does:** Checks for `a = a op b` or `a = b commutative_op a` patterns.\n+/// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n+/// patterns.\n ///\n /// **Why is this bad?** These can be written as the shorter `a op= b`.\n ///\n@@ -41,7 +44,8 @@ declare_lint! {\n \n /// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n ///\n-/// **Why is this bad?** Most likely these are bugs where one meant to write `a op= b`.\n+/// **Why is this bad?** Most likely these are bugs where one meant to write `a\n+/// op= b`.\n ///\n /// **Known problems:** Someone might actually mean `a op= a op b`, but that\n /// should rather be written as `a = (2 * a) op b` where applicable.\n@@ -75,9 +79,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     let lhs = &sugg::Sugg::hir(cx, lhs, \"..\");\n                     let rhs = &sugg::Sugg::hir(cx, rhs, \"..\");\n \n-                    db.span_suggestion(expr.span,\n-                                       \"replace it with\",\n-                                       format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)));\n+                    db.span_suggestion(\n+                        expr.span,\n+                        \"replace it with\",\n+                        format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)),\n+                    );\n                 });\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n@@ -144,35 +150,40 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                 }\n                             }\n                         }\n-                        if ops!(op.node,\n+                        if ops!(\n+                            op.node,\n+                            cx,\n+                            ty,\n+                            rty,\n+                            Add: BiAdd,\n+                            Sub: BiSub,\n+                            Mul: BiMul,\n+                            Div: BiDiv,\n+                            Rem: BiRem,\n+                            And: BiAnd,\n+                            Or: BiOr,\n+                            BitAnd: BiBitAnd,\n+                            BitOr: BiBitOr,\n+                            BitXor: BiBitXor,\n+                            Shr: BiShr,\n+                            Shl: BiShl\n+                        )\n+                        {\n+                            span_lint_and_then(\n                                 cx,\n-                                ty,\n-                                rty,\n-                                Add: BiAdd,\n-                                Sub: BiSub,\n-                                Mul: BiMul,\n-                                Div: BiDiv,\n-                                Rem: BiRem,\n-                                And: BiAnd,\n-                                Or: BiOr,\n-                                BitAnd: BiBitAnd,\n-                                BitOr: BiBitOr,\n-                                BitXor: BiBitXor,\n-                                Shr: BiShr,\n-                                Shl: BiShl) {\n-                            span_lint_and_then(cx,\n-                                               ASSIGN_OP_PATTERN,\n-                                               expr.span,\n-                                               \"manual implementation of an assign operation\",\n-                                               |db| if let (Some(snip_a), Some(snip_r)) =\n-                                                   (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n-                                                   db.span_suggestion(expr.span,\n-                                                                      \"replace it with\",\n-                                                                      format!(\"{} {}= {}\",\n-                                                                              snip_a,\n-                                                                              op.node.as_str(),\n-                                                                              snip_r));\n-                                               });\n+                                ASSIGN_OP_PATTERN,\n+                                expr.span,\n+                                \"manual implementation of an assign operation\",\n+                                |db| if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                                {\n+                                    db.span_suggestion(\n+                                        expr.span,\n+                                        \"replace it with\",\n+                                        format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    );\n+                                },\n+                            );\n                         }\n                     };\n                     // a = a op b"}, {"sha": "a52c4d90aab7ea93cded00a1ae165a5f4aa01078", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -35,12 +35,15 @@ declare_lint! {\n     \"use of `#[inline(always)]`\"\n }\n \n-/// **What it does:** Checks for `extern crate` and `use` items annotated with lint attributes\n+/// **What it does:** Checks for `extern crate` and `use` items annotated with\n+/// lint attributes\n ///\n-/// **Why is this bad?** Lint attributes have no effect on crate imports. Most likely a `!` was\n+/// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n+/// likely a `!` was\n /// forgotten\n ///\n-/// **Known problems:** Technically one might allow `unused_import` on a `use` item,\n+/// **Known problems:** Technically one might allow `unused_import` on a `use`\n+/// item,\n /// but it's easier to remove the unused item.\n ///\n /// **Example:**\n@@ -75,7 +78,7 @@ declare_lint! {\n     \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct AttrPass;\n \n impl LintPass for AttrPass {\n@@ -124,14 +127,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n                                     }\n                                     if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n                                         if sugg.len() > 1 {\n-                                            span_lint_and_then(cx,\n-                                                               USELESS_ATTRIBUTE,\n-                                                               attr.span,\n-                                                               \"useless lint attribute\",\n-                                                               |db| {\n-                                                sugg.insert(1, '!');\n-                                                db.span_suggestion(attr.span, \"if you just forgot a `!`, use\", sugg);\n-                                            });\n+                                            span_lint_and_then(\n+                                                cx,\n+                                                USELESS_ATTRIBUTE,\n+                                                attr.span,\n+                                                \"useless lint attribute\",\n+                                                |db| {\n+                                                    sugg.insert(1, '!');\n+                                                    db.span_suggestion(\n+                                                        attr.span,\n+                                                        \"if you just forgot a `!`, use\",\n+                                                        sugg,\n+                                                    );\n+                                                },\n+                                            );\n                                         }\n                                     }\n                                 },\n@@ -191,7 +200,10 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n             StmtSemi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n         }\n     } else {\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n+        block.expr.as_ref().map_or(\n+            false,\n+            |e| is_relevant_expr(tcx, tables, e),\n+        )\n     }\n }\n \n@@ -224,11 +236,15 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n                 continue;\n             }\n             if is_word(&values[0], \"always\") {\n-                span_lint(cx,\n-                          INLINE_ALWAYS,\n-                          attr.span,\n-                          &format!(\"you have declared `#[inline(always)]` on `{}`. This is usually a bad idea\",\n-                                   name));\n+                span_lint(\n+                    cx,\n+                    INLINE_ALWAYS,\n+                    attr.span,\n+                    &format!(\n+                        \"you have declared `#[inline(always)]` on `{}`. This is usually a bad idea\",\n+                        name\n+                    ),\n+                );\n             }\n         }\n     }\n@@ -240,10 +256,12 @@ fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n             return;\n         }\n     }\n-    span_lint(cx,\n-              DEPRECATED_SEMVER,\n-              span,\n-              \"the since field must contain a semver-compliant version\");\n+    span_lint(\n+        cx,\n+        DEPRECATED_SEMVER,\n+        span,\n+        \"the since field must contain a semver-compliant version\",\n+    );\n }\n \n fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {"}, {"sha": "64f007bf521047b425b1bb188fd75901bece06ae", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 85, "deletions": 52, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -74,7 +74,8 @@ declare_lint! {\n /// **What it does:** Checks for bit masks that can be replaced by a call\n /// to `trailing_zeros`\n ///\n-/// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15 == 0`\n+/// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n+/// == 0`\n ///\n /// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n ///\n@@ -88,7 +89,7 @@ declare_lint! {\n     \"expressions where a bit mask is less readable than the corresponding method call\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct BitMask;\n \n impl LintPass for BitMask {\n@@ -162,25 +163,33 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                 BiBitAnd => {\n                     if mask_value & cmp_value != cmp_value {\n                         if cmp_value != 0 {\n-                            span_lint(cx,\n-                                      BAD_BIT_MASK,\n-                                      *span,\n-                                      &format!(\"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                                               mask_value,\n-                                               cmp_value));\n+                            span_lint(\n+                                cx,\n+                                BAD_BIT_MASK,\n+                                *span,\n+                                &format!(\n+                                    \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n+                                    mask_value,\n+                                    cmp_value\n+                                ),\n+                            );\n                         }\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n                 },\n                 BiBitOr => {\n                     if mask_value | cmp_value != cmp_value {\n-                        span_lint(cx,\n-                                  BAD_BIT_MASK,\n-                                  *span,\n-                                  &format!(\"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                                           mask_value,\n-                                           cmp_value));\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            *span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n+                                mask_value,\n+                                cmp_value\n+                            ),\n+                        );\n                     }\n                 },\n                 _ => (),\n@@ -190,24 +199,32 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             match bit_op {\n                 BiBitAnd => {\n                     if mask_value < cmp_value {\n-                        span_lint(cx,\n-                                  BAD_BIT_MASK,\n-                                  *span,\n-                                  &format!(\"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                                           mask_value,\n-                                           cmp_value));\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            *span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n+                                mask_value,\n+                                cmp_value\n+                            ),\n+                        );\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n                 },\n                 BiBitOr => {\n                     if mask_value >= cmp_value {\n-                        span_lint(cx,\n-                                  BAD_BIT_MASK,\n-                                  *span,\n-                                  &format!(\"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                                           mask_value,\n-                                           cmp_value));\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            *span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n+                                mask_value,\n+                                cmp_value\n+                            ),\n+                        );\n                     } else {\n                         check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n@@ -220,24 +237,32 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             match bit_op {\n                 BiBitAnd => {\n                     if mask_value <= cmp_value {\n-                        span_lint(cx,\n-                                  BAD_BIT_MASK,\n-                                  *span,\n-                                  &format!(\"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                                           mask_value,\n-                                           cmp_value));\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            *span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n+                                mask_value,\n+                                cmp_value\n+                            ),\n+                        );\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n                 },\n                 BiBitOr => {\n                     if mask_value > cmp_value {\n-                        span_lint(cx,\n-                                  BAD_BIT_MASK,\n-                                  *span,\n-                                  &format!(\"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                                           mask_value,\n-                                           cmp_value));\n+                        span_lint(\n+                            cx,\n+                            BAD_BIT_MASK,\n+                            *span,\n+                            &format!(\n+                                \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n+                                mask_value,\n+                                cmp_value\n+                            ),\n+                        );\n                     } else {\n                         check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n                     }\n@@ -252,25 +277,33 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n \n fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n-        span_lint(cx,\n-                  INEFFECTIVE_BIT_MASK,\n-                  span,\n-                  &format!(\"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                           op,\n-                           m,\n-                           c));\n+        span_lint(\n+            cx,\n+            INEFFECTIVE_BIT_MASK,\n+            span,\n+            &format!(\n+                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                op,\n+                m,\n+                c\n+            ),\n+        );\n     }\n }\n \n fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n-        span_lint(cx,\n-                  INEFFECTIVE_BIT_MASK,\n-                  span,\n-                  &format!(\"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n-                           op,\n-                           m,\n-                           c));\n+        span_lint(\n+            cx,\n+            INEFFECTIVE_BIT_MASK,\n+            span,\n+            &format!(\n+                \"ineffective bit mask: `x {} {}` compared to `{}`, is the same as x compared directly\",\n+                op,\n+                m,\n+                c\n+            ),\n+        );\n     }\n }\n "}, {"sha": "e88e4108d3d9887792610972f1ac5eb6134216d5", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -41,10 +41,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n             if self.blacklist.iter().any(|s| ident.node == *s) {\n-                span_lint(cx,\n-                          BLACKLISTED_NAME,\n-                          ident.span,\n-                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node));\n+                span_lint(\n+                    cx,\n+                    BLACKLISTED_NAME,\n+                    ident.span,\n+                    &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node),\n+                );\n             }\n         }\n     }"}, {"sha": "eea44393e3d20702cd90bdb301a9b816d28ac854", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -40,7 +40,7 @@ declare_lint! {\n     \"complex blocks in conditions, e.g. `if { let x = true; x } ...`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct BlockInIfCondition;\n \n impl LintPass for BlockInIfCondition {\n@@ -87,27 +87,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             if in_macro(expr.span) || differing_macro_contexts(expr.span, ex.span) {\n                                 return;\n                             }\n-                            span_help_and_lint(cx,\n-                                               BLOCK_IN_IF_CONDITION_EXPR,\n-                                               check.span,\n-                                               BRACED_EXPR_MESSAGE,\n-                                               &format!(\"try\\nif {} {} ... \",\n+                            span_help_and_lint(\n+                                cx,\n+                                BLOCK_IN_IF_CONDITION_EXPR,\n+                                check.span,\n+                                BRACED_EXPR_MESSAGE,\n+                                &format!(\"try\\nif {} {} ... \",\n                                                         snippet_block(cx, ex.span, \"..\"),\n-                                                        snippet_block(cx, then.span, \"..\")));\n+                                                        snippet_block(cx, then.span, \"..\")),\n+                            );\n                         }\n                     } else {\n-                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(\n+                            || block.stmts[0].span,\n+                            |e| e.span,\n+                        );\n                         if in_macro(span) || differing_macro_contexts(expr.span, span) {\n                             return;\n                         }\n                         // move block higher\n-                        span_help_and_lint(cx,\n-                                           BLOCK_IN_IF_CONDITION_STMT,\n-                                           check.span,\n-                                           COMPLEX_BLOCK_MESSAGE,\n-                                           &format!(\"try\\nlet res = {};\\nif res {} ... \",\n+                        span_help_and_lint(\n+                            cx,\n+                            BLOCK_IN_IF_CONDITION_STMT,\n+                            check.span,\n+                            COMPLEX_BLOCK_MESSAGE,\n+                            &format!(\"try\\nlet res = {};\\nif res {} ... \",\n                                                     snippet_block(cx, block.span, \"..\"),\n-                                                    snippet_block(cx, then.span, \"..\")));\n+                                                    snippet_block(cx, then.span, \"..\")),\n+                        );\n                     }\n                 }\n             } else {"}, {"sha": "4c67b26004678f0575f6bb79170a9dad550bdf8d", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -44,7 +44,7 @@ declare_lint! {\n     \"boolean expressions that contain terminals which can be eliminated\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NonminimalBool;\n \n impl LintPass for NonminimalBool {\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId\n+        _: NodeId,\n     ) {\n         NonminimalBoolVisitor { cx: cx }.visit_body(body)\n     }\n@@ -115,8 +115,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n-                #[allow(cast_possible_truncation)]\n-                return Ok(Bool::Term(n as u8));\n+                #[allow(cast_possible_truncation)] return Ok(Bool::Term(n as u8));\n             }\n             let negated = match e.node {\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n@@ -141,15 +140,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n-                #[allow(cast_possible_truncation)]\n-                return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+                #[allow(cast_possible_truncation)] return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n             }\n         }\n         let n = self.terminals.len();\n         self.terminals.push(e);\n         if n < 32 {\n-            #[allow(cast_possible_truncation)]\n-            Ok(Bool::Term(n as u8))\n+            #[allow(cast_possible_truncation)] Ok(Bool::Term(n as u8))\n         } else {\n             Err(\"too many literals\".to_owned())\n         }\n@@ -353,44 +350,54 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.cx,\n-                                           LOGIC_BUG,\n-                                           e.span,\n-                                           \"this boolean expression contains a logic bug\",\n-                                           |db| {\n-                            db.span_help(h2q.terminals[i].span,\n-                                         \"this expression can be optimized out by applying boolean operations to the \\\n-                                          outer expression\");\n-                            db.span_suggestion(e.span,\n-                                               \"it would look like the following\",\n-                                               suggest(self.cx, suggestion, &h2q.terminals));\n-                        });\n+                        span_lint_and_then(\n+                            self.cx,\n+                            LOGIC_BUG,\n+                            e.span,\n+                            \"this boolean expression contains a logic bug\",\n+                            |db| {\n+                                db.span_help(\n+                                    h2q.terminals[i].span,\n+                                    \"this expression can be optimized out by applying boolean operations to the \\\n+                                          outer expression\",\n+                                );\n+                                db.span_suggestion(\n+                                    e.span,\n+                                    \"it would look like the following\",\n+                                    suggest(self.cx, suggestion, &h2q.terminals),\n+                                );\n+                            },\n+                        );\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n                     }\n                     // if the number of occurrences of a terminal decreases or any of the stats\n                     // decreases while none increases\n                     improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n-                                   (stats.negations > simplified_stats.negations &&\n-                                    stats.ops == simplified_stats.ops) ||\n-                                   (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                        (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops) ||\n+                        (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n                 }\n                 if improvement {\n                     improvements.push(suggestion);\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.cx,\n-                                   NONMINIMAL_BOOL,\n-                                   e.span,\n-                                   \"this boolean expression can be simplified\",\n-                                   |db| {\n-                    db.span_suggestions(e.span,\n-                                        \"try\",\n-                                        improvements.into_iter()\n-                                            .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n-                                            .collect());\n-                });\n+                span_lint_and_then(\n+                    self.cx,\n+                    NONMINIMAL_BOOL,\n+                    e.span,\n+                    \"this boolean expression can be simplified\",\n+                    |db| {\n+                        db.span_suggestions(\n+                            e.span,\n+                            \"try\",\n+                            improvements\n+                                .into_iter()\n+                                .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n+                                .collect(),\n+                        );\n+                    },\n+                );\n             }\n         }\n     }"}, {"sha": "54b6490a18325eedf94fa3ab9ae3ff785855951a", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -19,7 +19,8 @@ use utils::{in_macro, snippet_block, span_lint_and_then, span_lint_and_sugg};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for nested `if` statements which can be collapsed\n-/// by `&&`-combining their conditions and for `else { if ... }` expressions that\n+/// by `&&`-combining their conditions and for `else { if ... }` expressions\n+/// that\n /// can be collapsed to `else if ...`.\n ///\n /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n@@ -67,7 +68,7 @@ declare_lint! {\n     \"`if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct CollapsibleIf;\n \n impl LintPass for CollapsibleIf {"}, {"sha": "095fcf06e0967107ace1e534406d683e2d547543", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -83,7 +83,8 @@ impl PartialEq for Constant {\n \n impl Hash for Constant {\n     fn hash<H>(&self, state: &mut H)\n-        where H: Hasher\n+    where\n+        H: Hasher,\n     {\n         match *self {\n             Constant::Str(ref s, ref k) => {"}, {"sha": "8a37c7a846d44804a60a35569daa272155b82ae7", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -138,12 +138,14 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n     let eq: &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same(blocks, hash, eq) {\n-        span_note_and_lint(cx,\n-                           IF_SAME_THEN_ELSE,\n-                           j.span,\n-                           \"this `if` has identical blocks\",\n-                           i.span,\n-                           \"same as this\");\n+        span_note_and_lint(\n+            cx,\n+            IF_SAME_THEN_ELSE,\n+            j.span,\n+            \"this `if` has identical blocks\",\n+            i.span,\n+            \"same as this\",\n+        );\n     }\n }\n \n@@ -158,12 +160,14 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n     let eq: &Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n \n     if let Some((i, j)) = search_same(conds, hash, eq) {\n-        span_note_and_lint(cx,\n-                           IFS_SAME_COND,\n-                           j.span,\n-                           \"this `if` has the same condition as a previous if\",\n-                           i.span,\n-                           \"same as this\");\n+        span_note_and_lint(\n+            cx,\n+            IFS_SAME_COND,\n+            j.span,\n+            \"this `if` has the same condition as a previous if\",\n+            i.span,\n+            \"same as this\",\n+        );\n     }\n }\n \n@@ -185,40 +189,48 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n \n     if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n         if let Some((i, j)) = search_same(arms, hash, eq) {\n-            span_lint_and_then(cx,\n-                               MATCH_SAME_ARMS,\n-                               j.body.span,\n-                               \"this `match` has identical arm bodies\",\n-                               |db| {\n-                db.span_note(i.body.span, \"same as this\");\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |db| {\n+                    db.span_note(i.body.span, \"same as this\");\n \n-                // Note: this does not use `span_suggestion` on purpose: there is no clean way to\n-                // remove the other arm. Building a span and suggest to replace it to \"\" makes an\n-                // even more confusing error message. Also in order not to make up a span for the\n-                // whole pattern, the suggestion is only shown when there is only one pattern. The\n-                // user should know about `|` if they are already using it\u2026\n+                    // Note: this does not use `span_suggestion` on purpose: there is no clean way\n+                    // to\n+                    // remove the other arm. Building a span and suggest to replace it to \"\" makes\n+                    // an\n+                    // even more confusing error message. Also in order not to make up a span for\n+                    // the\n+                    // whole pattern, the suggestion is only shown when there is only one pattern.\n+                    // The\n+                    // user should know about `|` if they are already using it\u2026\n \n-                if i.pats.len() == 1 && j.pats.len() == 1 {\n-                    let lhs = snippet(cx, i.pats[0].span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pats[0].span, \"<pat2>\");\n+                    if i.pats.len() == 1 && j.pats.len() == 1 {\n+                        let lhs = snippet(cx, i.pats[0].span, \"<pat1>\");\n+                        let rhs = snippet(cx, j.pats[0].span, \"<pat2>\");\n \n-                    if let PatKind::Wild = j.pats[0].node {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pats[0] cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        db.span_note(i.body.span,\n-                                     &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n-                                              lhs));\n-                    } else {\n-                        db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                        if let PatKind::Wild = j.pats[0].node {\n+                            // if the last arm is _, then i could be integrated into _\n+                            // note that i.pats[0] cannot be _, because that would mean that we're\n+                            // hiding all the subsequent arms, and rust won't compile\n+                            db.span_note(\n+                                i.body.span,\n+                                &format!(\"`{}` has the same arm body as the `_` wildcard, consider removing it`\", lhs),\n+                            );\n+                        } else {\n+                            db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                        }\n                     }\n-                }\n-            });\n+                },\n+            );\n         }\n     }\n }\n \n-/// Return the list of condition expressions and the list of blocks in a sequence of `if/else`.\n+/// Return the list of condition expressions and the list of blocks in a\n+/// sequence of `if/else`.\n /// Eg. would return `([a, b], [c, d, e])` for the expression\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n@@ -303,8 +315,9 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n }\n \n fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n-    where Hash: Fn(&T) -> u64,\n-          Eq: Fn(&T, &T) -> bool\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n {\n     // common cases\n     if exprs.len() < 2 {"}, {"sha": "e87e60f9d23a982b44279447c91cfaf9dfa21cfc", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -15,7 +15,8 @@ use utils::{in_macro, LimitStack, span_help_and_lint, paths, match_type};\n /// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly\n /// readable. Also LLVM will usually optimize small methods better.\n ///\n-/// **Known problems:** Sometimes it's hard to find a way to reduce the complexity.\n+/// **Known problems:** Sometimes it's hard to find a way to reduce the\n+/// complexity.\n ///\n /// **Example:** No. You'll see it when you get the warning.\n declare_lint! {\n@@ -63,7 +64,13 @@ impl CyclomaticComplexity {\n             cx: cx,\n         };\n         helper.visit_expr(expr);\n-        let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n+        let CCHelper {\n+            match_arms,\n+            divergence,\n+            short_circuits,\n+            returns,\n+            ..\n+        } = helper;\n         let ret_ty = cx.tables.node_id_to_type(expr.id);\n         let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n             returns\n@@ -80,11 +87,13 @@ impl CyclomaticComplexity {\n                 rust_cc -= ret_adjust;\n             }\n             if rust_cc > self.limit.limit() {\n-                span_help_and_lint(cx,\n-                                   CYCLOMATIC_COMPLEXITY,\n-                                   span,\n-                                   &format!(\"the function has a cyclomatic complexity of {}\", rust_cc),\n-                                   \"you could split it up into multiple smaller functions\");\n+                span_help_and_lint(\n+                    cx,\n+                    CYCLOMATIC_COMPLEXITY,\n+                    span,\n+                    &format!(\"the function has a cyclomatic complexity of {}\", rust_cc),\n+                    \"you could split it up into multiple smaller functions\",\n+                );\n             }\n         }\n     }\n@@ -98,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        node_id: NodeId\n+        node_id: NodeId,\n     ) {\n         let def_id = cx.tcx.hir.local_def_id(node_id);\n         if !cx.tcx.has_attr(def_id, \"test\") {\n@@ -107,10 +116,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     }\n \n     fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.push_attrs(\n+            cx.sess(),\n+            attrs,\n+            \"cyclomatic_complexity\",\n+        );\n     }\n     fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+        self.limit.pop_attrs(\n+            cx.sess(),\n+            attrs,\n+            \"cyclomatic_complexity\",\n+        );\n     }\n }\n \n@@ -162,29 +179,35 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n     }\n }\n \n-#[cfg(feature=\"debugging\")]\n+#[cfg(feature = \"debugging\")]\n fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span) {\n-    span_bug!(span,\n-              \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n+    span_bug!(\n+        span,\n+        \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n                div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n-              cc,\n-              narms,\n-              div,\n-              shorts,\n-              returns);\n+        cc,\n+        narms,\n+        div,\n+        shorts,\n+        returns\n+    );\n }\n-#[cfg(not(feature=\"debugging\"))]\n+#[cfg(not(feature = \"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span) {\n     if cx.current_level(CYCLOMATIC_COMPLEXITY) != Level::Allow {\n-        cx.sess().span_note_without_error(span,\n-                                          &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n+        cx.sess().span_note_without_error(\n+            span,\n+            &format!(\n+                \"Clippy encountered a bug calculating cyclomatic complexity \\\n                                                     (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n                                                     cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n                                                     Please file a bug report.\",\n-                                                   cc,\n-                                                   narms,\n-                                                   div,\n-                                                   shorts,\n-                                                   returns));\n+                cc,\n+                narms,\n+                div,\n+                shorts,\n+                returns\n+            ),\n+        );\n     }\n }"}, {"sha": "e186dd5e4db748704af702720ff87d224c5e0041", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -89,7 +89,7 @@ fn check_hash_peq<'a, 'tcx>(\n     span: Span,\n     trait_ref: &TraitRef,\n     ty: Ty<'tcx>,\n-    hash_is_automatically_derived: bool\n+    hash_is_automatically_derived: bool,\n ) {\n     if_let_chain! {[\n         match_path_old(&trait_ref.path, &paths::HASH),"}, {"sha": "3ca71694bbd3c60b781903831727e2f70c46af2b", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -19,7 +19,8 @@ use utils::span_lint;\n ///\n /// **Examples:**\n /// ```rust\n-/// /// Do something with the foo_bar parameter. See also that::other::module::foo.\n+/// /// Do something with the foo_bar parameter. See also\n+/// that::other::module::foo.\n /// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n /// fn doit(foo_bar) { .. }\n /// ```\n@@ -78,7 +79,8 @@ impl<'a> Iterator for Parser<'a> {\n /// Cleanup documentation decoration (`///` and such).\n ///\n /// We can't use `syntax::attr::AttributeMethods::with_desugared_doc` or\n-/// `syntax::parse::lexer::comments::strip_doc_comment_decoration` because we need to keep track of\n+/// `syntax::parse::lexer::comments::strip_doc_comment_decoration` because we\n+/// need to keep track of\n /// the spans but this function is inspired from the later.\n #[allow(cast_possible_truncation)]\n pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(usize, Span)>) {\n@@ -89,7 +91,18 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n             let doc = &comment[prefix.len()..];\n             let mut doc = doc.to_owned();\n             doc.push('\\n');\n-            return (doc.to_owned(), vec![(doc.len(), Span { lo: span.lo + BytePos(prefix.len() as u32), ..span })]);\n+            return (\n+                doc.to_owned(),\n+                vec![\n+                    (\n+                        doc.len(),\n+                        Span {\n+                            lo: span.lo + BytePos(prefix.len() as u32),\n+                            ..span\n+                        }\n+                    ),\n+                ],\n+            );\n         }\n     }\n \n@@ -102,7 +115,13 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n             debug_assert_eq!(offset as u32 as usize, offset);\n \n             // +1 for the newline\n-            sizes.push((line.len() + 1, Span { lo: span.lo + BytePos(offset as u32), ..span }));\n+            sizes.push((\n+                line.len() + 1,\n+                Span {\n+                    lo: span.lo + BytePos(offset as u32),\n+                    ..span\n+                },\n+            ));\n         }\n \n         return (doc.to_string(), sizes);\n@@ -163,7 +182,7 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n     cx: &EarlyContext,\n     valid_idents: &[String],\n     docs: Events,\n-    spans: &[(usize, Span)]\n+    spans: &[(usize, Span)],\n ) {\n     use pulldown_cmark::Event::*;\n     use pulldown_cmark::Tag::*;\n@@ -192,7 +211,10 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n                     let (begin, span) = spans[index];\n \n                     // Adjust for the begining of the current `Event`\n-                    let span = Span { lo: span.lo + BytePos::from_usize(offset - begin), ..span };\n+                    let span = Span {\n+                        lo: span.lo + BytePos::from_usize(offset - begin),\n+                        ..span\n+                    };\n \n                     check_text(cx, valid_idents, &text, span);\n                 }\n@@ -225,8 +247,10 @@ fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span\n }\n \n fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n-    /// Checks if a string is camel-case, ie. contains at least two uppercase letter (`Clippy` is\n-    /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded (`IDs` is ok).\n+    /// Checks if a string is camel-case, ie. contains at least two uppercase\n+    /// letter (`Clippy` is\n+    /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded\n+    /// (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n         if s.starts_with(|c: char| c.is_digit(10)) {\n             return false;\n@@ -239,17 +263,19 @@ fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n         };\n \n         s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n-        s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n+            s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n     }\n \n     fn has_underscore(s: &str) -> bool {\n         s != \"_\" && !s.contains(\"\\\\_\") && s.contains('_')\n     }\n \n     if has_underscore(word) || word.contains(\"::\") || is_camel_case(word) {\n-        span_lint(cx,\n-                  DOC_MARKDOWN,\n-                  span,\n-                  &format!(\"you should put `{}` between ticks in the documentation\", word));\n+        span_lint(\n+            cx,\n+            DOC_MARKDOWN,\n+            span,\n+            &format!(\"you should put `{}` between ticks in the documentation\", word),\n+        );\n     }\n }"}, {"sha": "b02333b89a082c85572e014ab6fb513389e2dde2", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -16,7 +16,8 @@ use utils::{match_def_path, paths, span_note_and_lint, is_copy};\n /// **Example:**\n /// ```rust\n /// let mut lock_guard = mutex.lock();\n-/// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex still locked\n+/// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+/// still locked\n /// operation_that_requires_mutex_to_be_unlocked();\n /// ```\n declare_lint! {\n@@ -29,7 +30,8 @@ declare_lint! {\n /// instead of an owned value.\n ///\n /// **Why is this bad?** Calling `forget` on a reference will only forget the\n-/// reference itself, which is a no-op. It will not forget the underlying referenced\n+/// reference itself, which is a no-op. It will not forget the underlying\n+/// referenced\n /// value, which is likely what was intended.\n ///\n /// **Known problems:** None.\n@@ -57,7 +59,8 @@ declare_lint! {\n /// **Example:**\n /// ```rust\n /// let x:i32 = 42;   // i32 implements Copy\n-/// std::mem::drop(x) // A copy of x is passed to the function, leaving the original unaffected\n+/// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+/// original unaffected\n /// ```\n declare_lint! {\n     pub DROP_COPY,\n@@ -72,16 +75,19 @@ declare_lint! {\n /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n /// value will be copied and moved into the function on invocation.\n ///\n-/// An alternative, but also valid, explanation is that Copy types do not implement\n-/// the Drop trait, which means they have no destructors. Without a destructor, there\n+/// An alternative, but also valid, explanation is that Copy types do not\n+/// implement\n+/// the Drop trait, which means they have no destructors. Without a destructor,\n+/// there\n /// is nothing for `std::mem::forget` to ignore.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// let x:i32 = 42;     // i32 implements Copy\n-/// std::mem::forget(x) // A copy of x is passed to the function, leaving the original unaffected\n+/// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+/// original unaffected\n /// ```\n declare_lint! {\n     pub FORGET_COPY,"}, {"sha": "7845c85b6872f5e5c60e648796a0f5240727d495", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -6,7 +6,8 @@ use utils::span_lint_and_then;\n \n /// **What it does:** Checks for `enum`s with no variants.\n ///\n-/// **Why is this bad?** Enum's with no variants should be replaced with `!`, the uninhabited type,\n+/// **Why is this bad?** Enum's with no variants should be replaced with `!`,\n+/// the uninhabited type,\n /// or a wrapper around it.\n ///\n /// **Known problems:** None.\n@@ -21,7 +22,7 @@ declare_lint! {\n     \"enum with no variants\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct EmptyEnum;\n \n impl LintPass for EmptyEnum {\n@@ -35,7 +36,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemEnum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+            let adt = ty.ty_adt_def().expect(\n+                \"already checked whether this is an enum\",\n+            );\n             if adt.variants.is_empty() {\n                 span_lint_and_then(cx, EMPTY_ENUM, item.span, \"enum with no variants\", |db| {\n                     db.span_help(item.span, \"consider using the uninhabited type `!` or a wrapper around it\");"}, {"sha": "80288ff22688941fcd1ce85a3b6ad543c09fcd88", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -30,7 +30,7 @@ declare_lint! {\n     \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct HashMapLint;\n \n impl LintPass for HashMapLint {\n@@ -48,11 +48,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                     // we can give a better error message\n                     let sole_expr = {\n                         else_block.is_none() &&\n-                        if let ExprBlock(ref then_block) = then_block.node {\n-                            (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                        } else {\n-                            true\n-                        }\n+                            if let ExprBlock(ref then_block) = then_block.node {\n+                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n+                            } else {\n+                                true\n+                            }\n                     };\n \n                     let mut visitor = InsertVisitor {\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n \n fn check_cond<'a, 'tcx, 'b>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    check: &'b Expr\n+    check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_let_chain! {[\n         let ExprMethodCall(ref path, _, ref params) = check.node,"}, {"sha": "bf2ba847ec873a4e4f533b5e7ac308da2a19cabd", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -1,4 +1,5 @@\n-//! lint on C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\n+//! lint on C-like enums that are `repr(isize/usize)` and have values that\n+//! don't fit into an `i32`\n \n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n@@ -50,16 +51,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                     let did = cx.tcx.hir.body_owner_def_id(body_id);\n                     let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                     let substs = Substs::identity_for_item(cx.tcx.global_tcx(), did);\n-                    let bad = match cx.tcx.at(expr.span).const_eval(param_env.and((did, substs))) {\n+                    let bad = match cx.tcx.at(expr.span).const_eval(\n+                        param_env.and((did, substs)),\n+                    ) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,\n                     };\n                     if bad {\n-                        span_lint(cx,\n-                                  ENUM_CLIKE_UNPORTABLE_VARIANT,\n-                                  var.span,\n-                                  \"Clike enum variant discriminant is not portable to 32-bit targets\");\n+                        span_lint(\n+                            cx,\n+                            ENUM_CLIKE_UNPORTABLE_VARIANT,\n+                            var.span,\n+                            \"Clike enum variant discriminant is not portable to 32-bit targets\",\n+                        );\n                     }\n                 }\n             }"}, {"sha": "6738f5bb63b905de01c4ff7f6147abffa823f773", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -48,9 +48,14 @@ impl EnumGlobUse {\n         }\n         if let ItemUse(ref path, UseKind::Glob) = item.node {\n             // FIXME: ask jseyfried why the qpath.def for `use std::cmp::Ordering::*;`\n-            // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an `Enum`\n+            // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an\n+            // `Enum`\n             // if let Def::Enum(_) = path.def {\n-            if path.segments.last().and_then(|seg| seg.name.as_str().chars().next()).map_or(false, char::is_uppercase) {\n+            if path.segments\n+                .last()\n+                .and_then(|seg| seg.name.as_str().chars().next())\n+                .map_or(false, char::is_uppercase)\n+            {\n                 span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }\n         }"}, {"sha": "1227de69db22e1e26fe6d0132547048bd63071e6", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -68,13 +68,16 @@ declare_lint! {\n     \"type names prefixed/postfixed with their containing module's name\"\n }\n \n-/// **What it does:** Checks for modules that have the same name as their parent module\n+/// **What it does:** Checks for modules that have the same name as their\n+/// parent module\n ///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { ..\n+/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n+/// again `mod foo { ..\n /// }` in `foo.rs`.\n /// The expectation is that items inside the inner `mod foo { .. }` are then\n /// available\n-///                      through `foo::x`, but they are only available through `foo::foo::x`.\n+/// through `foo::x`, but they are only available through\n+/// `foo::foo::x`.\n /// If this is done on purpose, it would be better to choose a more\n /// representative module name.\n ///\n@@ -123,14 +126,21 @@ fn var2str(var: &Variant) -> InternedString {\n fn partial_match(pre: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next_back(); // make sure the name is never fully matched\n-    pre.chars().zip(name_iter).take_while(|&(l, r)| l == r).count()\n+    pre.chars()\n+        .zip(name_iter)\n+        .take_while(|&(l, r)| l == r)\n+        .count()\n }\n \n /// Returns the number of chars that match from the end\n fn partial_rmatch(post: &str, name: &str) -> usize {\n     let mut name_iter = name.chars();\n     let _ = name_iter.next(); // make sure the name is never fully matched\n-    post.chars().rev().zip(name_iter.rev()).take_while(|&(l, r)| l == r).count()\n+    post.chars()\n+        .rev()\n+        .zip(name_iter.rev())\n+        .take_while(|&(l, r)| l == r)\n+        .count()\n }\n \n // FIXME: #600\n@@ -142,7 +152,7 @@ fn check_variant(\n     item_name: &str,\n     item_name_chars: usize,\n     span: Span,\n-    lint: &'static Lint\n+    lint: &'static Lint,\n ) {\n     if (def.variants.len() as u64) < threshold {\n         return;\n@@ -187,13 +197,17 @@ fn check_variant(\n         (false, _) => (\"pre\", pre),\n         (true, false) => (\"post\", post),\n     };\n-    span_help_and_lint(cx,\n-                       lint,\n-                       span,\n-                       &format!(\"All variants have the same {}fix: `{}`\", what, value),\n-                       &format!(\"remove the {}fixes and use full paths to \\\n+    span_help_and_lint(\n+        cx,\n+        lint,\n+        span,\n+        &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+        &format!(\n+            \"remove the {}fixes and use full paths to \\\n                                  the variants instead of glob imports\",\n-                                what));\n+            what\n+        ),\n+    );\n }\n \n fn to_camel_case(item_name: &str) -> String {\n@@ -234,10 +248,12 @@ impl EarlyLintPass for EnumVariantNames {\n                 if !mod_camel.is_empty() {\n                     if *mod_name == item_name {\n                         if let ItemKind::Mod(..) = item.node {\n-                            span_lint(cx,\n-                                      MODULE_INCEPTION,\n-                                      item.span,\n-                                      \"module has the same name as its containing module\");\n+                            span_lint(\n+                                cx,\n+                                MODULE_INCEPTION,\n+                                item.span,\n+                                \"module has the same name as its containing module\",\n+                            );\n                         }\n                     }\n                     if item.vis == Visibility::Public {"}, {"sha": "84a54dd215b7f8bd93add12f7b021e9a578ab67d", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -23,7 +23,8 @@ declare_lint! {\n     \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n }\n \n-/// **What it does:** Checks for arguments to `==` which have their address taken to satisfy a bound\n+/// **What it does:** Checks for arguments to `==` which have their address\n+/// taken to satisfy a bound\n /// and suggests to dereference the other argument instead\n ///\n /// **Why is this bad?** It is more idiomatic to dereference the other argument.\n@@ -40,7 +41,7 @@ declare_lint! {\n     \"taking a reference to satisfy the type constraints on `==`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct EqOp;\n \n impl LintPass for EqOp {\n@@ -53,10 +54,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n-                span_lint(cx,\n-                          EQ_OP,\n-                          e.span,\n-                          &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                span_lint(\n+                    cx,\n+                    EQ_OP,\n+                    e.span,\n+                    &format!(\"equal expressions as operands to `{}`\", op.node.as_str()),\n+                );\n                 return;\n             }\n             let (trait_id, requires_ref) = match op.node {\n@@ -89,31 +92,37 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n                         if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty]) {\n-                            span_lint_and_then(cx,\n-                                               OP_REF,\n-                                               e.span,\n-                                               \"needlessly taken reference of both operands\",\n-                                               |db| {\n-                                let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                multispan_sugg(db,\n-                                               \"use the values directly\".to_string(),\n-                                               vec![(left.span, lsnip), (right.span, rsnip)]);\n-                            })\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of both operands\",\n+                                |db| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(\n+                                        db,\n+                                        \"use the values directly\".to_string(),\n+                                        vec![(left.span, lsnip), (right.span, rsnip)],\n+                                    );\n+                                },\n+                            )\n                         } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n                         } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n-                            span_lint_and_then(cx,\n-                                               OP_REF,\n-                                               e.span,\n-                                               \"needlessly taken reference of right operand\",\n-                                               |db| {\n-                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                db.span_suggestion(right.span, \"use the right value directly\", rsnip);\n-                            })\n+                            span_lint_and_then(\n+                                cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"needlessly taken reference of right operand\",\n+                                |db| {\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    db.span_suggestion(right.span, \"use the right value directly\", rsnip);\n+                                },\n+                            )\n                         }\n                     },\n                     // &foo == bar"}, {"sha": "68f0ede8a6ca0373f5c68177bfb1de1ac9fc0949", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        node_id: NodeId\n+        node_id: NodeId,\n     ) {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let mut v = EscapeDelegate {\n@@ -74,10 +74,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n \n         for node in v.set {\n-            span_lint(cx,\n-                      BOXED_LOCAL,\n-                      cx.tcx.hir.span(node),\n-                      \"local variable doesn't need to be boxed here\");\n+            span_lint(\n+                cx,\n+                BOXED_LOCAL,\n+                cx.tcx.hir.span(node),\n+                \"local variable doesn't need to be boxed here\",\n+            );\n         }\n     }\n }"}, {"sha": "b5667db920cdcb97d350344dc353ab4290f94d47", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -20,7 +20,8 @@ pub struct EtaPass;\n /// ```rust\n /// xs.map(|x| foo(x))\n /// ```\n-/// where `foo(_)` is a plain function that takes the exact argument type of `x`.\n+/// where `foo(_)` is a plain function that takes the exact argument type of\n+/// `x`.\n declare_lint! {\n     pub REDUNDANT_CLOSURE,\n     Warn,\n@@ -91,13 +92,11 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                     return;\n                 }\n             }\n-            span_lint_and_then(cx,\n-                               REDUNDANT_CLOSURE,\n-                               expr.span,\n-                               \"redundant closure found\",\n-                               |db| if let Some(snippet) = snippet_opt(cx, caller.span) {\n-                                   db.span_suggestion(expr.span, \"remove closure as shown\", snippet);\n-                               });\n+            span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n+                if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                    db.span_suggestion(expr.span, \"remove closure as shown\", snippet);\n+                }\n+            });\n         }\n     }\n }"}, {"sha": "81109761ca7872ad45d4d791badb28ca65a0c920", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -27,12 +27,14 @@ declare_lint! {\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n }\n \n-/// **What it does:** Checks for diverging calls that are not match arms or statements.\n+/// **What it does:** Checks for diverging calls that are not match arms or\n+/// statements.\n ///\n /// **Why is this bad?** It is often confusing to read. In addition, the\n /// sub-expression evaluation order for Rust is not well documented.\n ///\n-/// **Known problems:** Someone might want to use `some_bool || panic!()` as a shorthand.\n+/// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n+/// shorthand.\n ///\n /// **Example:**\n /// ```rust\n@@ -47,7 +49,7 @@ declare_lint! {\n     \"whether an expression contains a diverging sub expression\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct EvalOrderDependence;\n \n impl LintPass for EvalOrderDependence {\n@@ -144,7 +146,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             _ => {\n-                // do not lint expressions referencing objects of type `!`, as that required a diverging expression\n+                // do not lint expressions referencing objects of type `!`, as that required a\n+                // diverging expression\n                 // to begin with\n             },\n         }\n@@ -271,8 +274,10 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> St\n                 DeclLocal(ref local) => Some(local),\n                 _ => None,\n             };\n-            local.and_then(|local| local.init.as_ref())\n-                .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr))\n+            local.and_then(|local| local.init.as_ref()).map_or(\n+                StopEarly::KeepGoing,\n+                |expr| check_expr(vis, expr),\n+            )\n         },\n     }\n }"}, {"sha": "16dced957607028b3f6615f0d077766226d34252", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -99,7 +99,8 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n \n /// Checks if the expressions matches\n /// ```rust, ignore\n-/// { static __STATIC_FMTSTR: &'static[&'static str] = &[\"a\", \"b\", c]; __STATIC_FMTSTR }\n+/// { static __STATIC_FMTSTR: &'static[&'static str] = &[\"a\", \"b\", c];\n+/// __STATIC_FMTSTR }\n /// ```\n fn check_static_str(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(expr) = get_argument_fmtstr_parts(cx, expr) {\n@@ -112,7 +113,8 @@ fn check_static_str(cx: &LateContext, expr: &Expr) -> bool {\n /// Checks if the expressions matches\n /// ```rust,ignore\n /// &match (&42,) {\n-///     (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],\n+/// (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0,\n+/// ::std::fmt::Display::fmt)],\n /// }\n /// ```\n fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {"}, {"sha": "c478974a5bd4f985c6aac0e240f230f2d1e56ae3", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -4,9 +4,11 @@ use syntax_pos::{Span, NO_EXPANSION};\n use utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use syntax::ptr::P;\n \n-/// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-` operators.\n+/// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n+/// operators.\n ///\n-/// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or confusing.\n+/// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n+/// confusing.\n ///\n /// **Known problems:** None.\n ///\n@@ -67,12 +69,16 @@ declare_lint! {\n }\n \n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct Formatting;\n \n impl LintPass for Formatting {\n     fn get_lints(&self) -> LintArray {\n-        lint_array![SUSPICIOUS_ASSIGNMENT_FORMATTING, SUSPICIOUS_ELSE_FORMATTING, POSSIBLE_MISSING_COMMA]\n+        lint_array!(\n+            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+            SUSPICIOUS_ELSE_FORMATTING,\n+            POSSIBLE_MISSING_COMMA\n+        )\n     }\n }\n \n@@ -114,14 +120,18 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n                         ctxt: NO_EXPANSION,\n                     };\n                     if eq_snippet.ends_with('=') {\n-                        span_note_and_lint(cx,\n-                                           SUSPICIOUS_ASSIGNMENT_FORMATTING,\n-                                           eqop_span,\n-                                           &format!(\"this looks like you are trying to use `.. {op}= ..`, but you \\\n+                        span_note_and_lint(\n+                            cx,\n+                            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n+                            eqop_span,\n+                            &format!(\n+                                \"this looks like you are trying to use `.. {op}= ..`, but you \\\n                                                      really are doing `.. = ({op} ..)`\",\n-                                                    op = op),\n-                                           eqop_span,\n-                                           &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op = op));\n+                                op = op\n+                            ),\n+                            eqop_span,\n+                            &format!(\"to remove this lint, use either `{op}=` or `= {op}`\", op = op),\n+                        );\n                     }\n                 }\n             }\n@@ -133,7 +143,8 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n-            // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to the\n+            // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to\n+            // the\n             // \u201cif\u201d of the \u201celse if\u201d block (excluding)\n             let else_span = Span {\n                 lo: then.span.hi,\n@@ -144,16 +155,20 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n             // the snippet should look like \" else \\n    \" with maybe comments anywhere\n             // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n             if let Some(else_snippet) = snippet_opt(cx, else_span) {\n-                let else_pos = else_snippet.find(\"else\").expect(\"there must be a `else` here\");\n+                let else_pos = else_snippet.find(\"else\").expect(\n+                    \"there must be a `else` here\",\n+                );\n \n                 if else_snippet[else_pos..].contains('\\n') {\n-                    span_note_and_lint(cx,\n-                                       SUSPICIOUS_ELSE_FORMATTING,\n-                                       else_span,\n-                                       \"this is an `else if` but the formatting might hide it\",\n-                                       else_span,\n-                                       \"to remove this lint, remove the `else` or remove the new line between `else` \\\n-                                        and `if`\");\n+                    span_note_and_lint(\n+                        cx,\n+                        SUSPICIOUS_ELSE_FORMATTING,\n+                        else_span,\n+                        \"this is an `else if` but the formatting might hide it\",\n+                        else_span,\n+                        \"to remove this lint, remove the `else` or remove the new line between `else` \\\n+                                        and `if`\",\n+                    );\n                 }\n             }\n         }\n@@ -178,12 +193,14 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n                             ctxt: NO_EXPANSION,\n                         };\n                         if space_snippet.contains('\\n') {\n-                            span_note_and_lint(cx,\n-                                               POSSIBLE_MISSING_COMMA,\n-                                               lint_span,\n-                                               \"possibly missing a comma here\",\n-                                               lint_span,\n-                                               \"to remove this lint, add a comma or write the expr in a single line\");\n+                            span_note_and_lint(\n+                                cx,\n+                                POSSIBLE_MISSING_COMMA,\n+                                lint_span,\n+                                \"possibly missing a comma here\",\n+                                lint_span,\n+                                \"to remove this lint, add a comma or write the expr in a single line\",\n+                            );\n                         }\n                     }\n                 }\n@@ -195,7 +212,8 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n     if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some() &&\n-       unsugar_if(second).is_some() {\n+        unsugar_if(second).is_some()\n+    {\n         // where the else would be\n         let else_span = Span {\n             lo: first.span.hi,\n@@ -205,13 +223,15 @@ fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Exp\n \n         if let Some(else_snippet) = snippet_opt(cx, else_span) {\n             if !else_snippet.contains('\\n') {\n-                span_note_and_lint(cx,\n-                                   SUSPICIOUS_ELSE_FORMATTING,\n-                                   else_span,\n-                                   \"this looks like an `else if` but the `else` is missing\",\n-                                   else_span,\n-                                   \"to remove this lint, add the missing `else` or add a new line before the second \\\n-                                    `if`\");\n+                span_note_and_lint(\n+                    cx,\n+                    SUSPICIOUS_ELSE_FORMATTING,\n+                    else_span,\n+                    \"this looks like an `else if` but the `else` is missing\",\n+                    else_span,\n+                    \"to remove this lint, add the missing `else` or add a new line before the second \\\n+                                    `if`\",\n+                );\n             }\n         }\n     }"}, {"sha": "e45ab55808995f3c544a19b5e4432222d31b5593", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -17,7 +17,8 @@ use utils::{span_lint, type_is_unsafe_function, iter_input_pats};\n ///\n /// **Example:**\n /// ```rust\n-/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) { .. }\n+/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b:\n+/// f32) { .. }\n /// ```\n declare_lint! {\n     pub TOO_MANY_ARGUMENTS,\n@@ -35,7 +36,8 @@ declare_lint! {\n /// **Known problems:**\n ///\n /// * It does not check functions recursively so if the pointer is passed to a\n-/// private non-`unsafe` function which does the dereferencing, the lint won't trigger.\n+/// private non-`unsafe` function which does the dereferencing, the lint won't\n+/// trigger.\n /// * It only checks for arguments whose type are raw pointers, not raw pointers\n /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n /// `some_argument.get_raw_ptr()`).\n@@ -50,7 +52,7 @@ declare_lint! {\n     \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct Functions {\n     threshold: u64,\n }\n@@ -75,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n         span: Span,\n-        nodeid: ast::NodeId\n+        nodeid: ast::NodeId,\n     ) {\n         use rustc::hir::map::Node::*;\n \n@@ -123,10 +125,12 @@ impl<'a, 'tcx> Functions {\n     fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n-            span_lint(cx,\n-                      TOO_MANY_ARGUMENTS,\n-                      span,\n-                      &format!(\"this function has too many arguments ({}/{})\", args, self.threshold));\n+            span_lint(\n+                cx,\n+                TOO_MANY_ARGUMENTS,\n+                span,\n+                &format!(\"this function has too many arguments ({}/{})\", args, self.threshold),\n+            );\n         }\n     }\n \n@@ -136,7 +140,7 @@ impl<'a, 'tcx> Functions {\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n-        nodeid: ast::NodeId\n+        nodeid: ast::NodeId,\n     ) {\n         let expr = &body.value;\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n@@ -208,10 +212,12 @@ impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n         if let hir::ExprPath(ref qpath) = ptr.node {\n             let def = self.cx.tables.qpath_def(qpath, ptr.id);\n             if self.ptrs.contains(&def.def_id()) {\n-                span_lint(self.cx,\n-                          NOT_UNSAFE_PTR_ARG_DEREF,\n-                          ptr.span,\n-                          \"this public function dereferences a raw pointer but is not marked `unsafe`\");\n+                span_lint(\n+                    self.cx,\n+                    NOT_UNSAFE_PTR_ARG_DEREF,\n+                    ptr.span,\n+                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                );\n             }\n         }\n     }"}, {"sha": "a7c254e1e46405fe96f7c2533f6fa9c67e9bb0a8", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -22,7 +22,7 @@ declare_lint! {\n     \"using identity operations, e.g. `x + 0` or `y / 1`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct IdentityOp;\n \n impl LintPass for IdentityOp {\n@@ -71,12 +71,17 @@ fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n             },\n             1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),\n-        } {\n-            span_lint(cx,\n-                      IDENTITY_OP,\n-                      span,\n-                      &format!(\"the operation is ineffective. Consider reducing it to `{}`\",\n-                               snippet(cx, arg, \"..\")));\n+        }\n+        {\n+            span_lint(\n+                cx,\n+                IDENTITY_OP,\n+                span,\n+                &format!(\n+                    \"the operation is ineffective. Consider reducing it to `{}`\",\n+                    snippet(cx, arg, \"..\")\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "058052769ef6108a784451a5e2d30abe3a713dbf", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -3,9 +3,11 @@ use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::{paths, span_lint_and_then, match_path, snippet};\n \n-/// **What it does:*** Lint for redundant pattern matching over `Result` or `Option`\n+/// **What it does:*** Lint for redundant pattern matching over `Result` or\n+/// `Option`\n ///\n-/// **Why is this bad?** It's more concise and clear to just use the proper utility function\n+/// **Why is this bad?** It's more concise and clear to just use the proper\n+/// utility function\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "66f2778f2159e34873a11f82a6c11d03ffe6e3c7", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -1,4 +1,5 @@\n-//! lint on if branches that could be swapped so no `!` operation is necessary on the condition\n+//! lint on if branches that could be swapped so no `!` operation is necessary\n+//! on the condition\n \n use rustc::lint::*;\n use syntax::ast::*;\n@@ -50,18 +51,22 @@ impl EarlyLintPass for IfNotElse {\n             if let ExprKind::Block(..) = els.node {\n                 match cond.node {\n                     ExprKind::Unary(UnOp::Not, _) => {\n-                        span_help_and_lint(cx,\n-                                           IF_NOT_ELSE,\n-                                           item.span,\n-                                           \"Unnecessary boolean `not` operation\",\n-                                           \"remove the `!` and swap the blocks of the if/else\");\n+                        span_help_and_lint(\n+                            cx,\n+                            IF_NOT_ELSE,\n+                            item.span,\n+                            \"Unnecessary boolean `not` operation\",\n+                            \"remove the `!` and swap the blocks of the if/else\",\n+                        );\n                     },\n                     ExprKind::Binary(ref kind, _, _) if kind.node == BinOpKind::Ne => {\n-                        span_help_and_lint(cx,\n-                                           IF_NOT_ELSE,\n-                                           item.span,\n-                                           \"Unnecessary `!=` operation\",\n-                                           \"change to `==` and swap the blocks of the if/else\");\n+                        span_help_and_lint(\n+                            cx,\n+                            IF_NOT_ELSE,\n+                            item.span,\n+                            \"Unnecessary `!=` operation\",\n+                            \"change to `==` and swap the blocks of the if/else\",\n+                        );\n                     },\n                     _ => (),\n                 }"}, {"sha": "f14c70dc4ddc3ed0d7a1a1f079fa30429ce79557", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -47,10 +47,9 @@ impl EarlyLintPass for ItemsAfterStatements {\n         }\n \n         // skip initial items\n-        let stmts = item.stmts\n-            .iter()\n-            .map(|stmt| &stmt.node)\n-            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n+        let stmts = item.stmts.iter().map(|stmt| &stmt.node).skip_while(|s| {\n+            matches!(**s, StmtKind::Item(..))\n+        });\n \n         // lint on all further items\n         for stmt in stmts {\n@@ -62,11 +61,13 @@ impl EarlyLintPass for ItemsAfterStatements {\n                     // do not lint `macro_rules`, but continue processing further statements\n                     continue;\n                 }\n-                span_lint(cx,\n-                          ITEMS_AFTER_STATEMENTS,\n-                          it.span,\n-                          \"adding items after statements is confusing, since items exist from the \\\n-                           start of the scope\");\n+                span_lint(\n+                    cx,\n+                    ITEMS_AFTER_STATEMENTS,\n+                    it.span,\n+                    \"adding items after statements is confusing, since items exist from the \\\n+                           start of the scope\",\n+                );\n             }\n         }\n     }"}, {"sha": "73a62c97bc84f574c80de4e2e522be37f5a3519e", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -5,9 +5,11 @@ use rustc::hir::*;\n use utils::{span_lint_and_then, snippet_opt, type_size};\n use rustc::ty::TypeFoldable;\n \n-/// **What it does:** Checks for large size differences between variants on `enum`s.\n+/// **What it does:** Checks for large size differences between variants on\n+/// `enum`s.\n ///\n-/// **Why is this bad?** Enum size is bounded by the largest variant. Having a large variant\n+/// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n+/// large variant\n /// can penalize the memory layout of that enum.\n ///\n /// **Known problems:** None.\n@@ -25,7 +27,7 @@ declare_lint! {\n     \"large size difference between variants on an enum\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct LargeEnumVariant {\n     maximum_size_difference_allowed: u64,\n }\n@@ -47,13 +49,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemEnum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+            let adt = ty.ty_adt_def().expect(\n+                \"already checked whether this is an enum\",\n+            );\n \n             let mut smallest_variant: Option<(_, _)> = None;\n             let mut largest_variant: Option<(_, _)> = None;\n \n             for (i, variant) in adt.variants.iter().enumerate() {\n-                let size: u64 = variant.fields\n+                let size: u64 = variant\n+                    .fields\n                     .iter()\n                     .map(|f| {\n                         let ty = cx.tcx.type_of(f.did);\n@@ -77,28 +82,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                 if difference > self.maximum_size_difference_allowed {\n                     let (i, variant) = largest.1;\n \n-                    span_lint_and_then(cx,\n-                                       LARGE_ENUM_VARIANT,\n-                                       def.variants[i].span,\n-                                       \"large size difference between variants\",\n-                                       |db| {\n-                        if variant.fields.len() == 1 {\n-                            let span = match def.variants[i].node.data {\n-                                VariantData::Struct(ref fields, _) |\n-                                VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n-                                VariantData::Unit(_) => unreachable!(),\n-                            };\n-                            if let Some(snip) = snippet_opt(cx, span) {\n-                                db.span_suggestion(span,\n-                                                   \"consider boxing the large fields to reduce the total size of the \\\n+                    span_lint_and_then(\n+                        cx,\n+                        LARGE_ENUM_VARIANT,\n+                        def.variants[i].span,\n+                        \"large size difference between variants\",\n+                        |db| {\n+                            if variant.fields.len() == 1 {\n+                                let span = match def.variants[i].node.data {\n+                                    VariantData::Struct(ref fields, _) |\n+                                    VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n+                                    VariantData::Unit(_) => unreachable!(),\n+                                };\n+                                if let Some(snip) = snippet_opt(cx, span) {\n+                                    db.span_suggestion(\n+                                        span,\n+                                        \"consider boxing the large fields to reduce the total size of the \\\n                                                     enum\",\n-                                                   format!(\"Box<{}>\", snip));\n-                                return;\n+                                        format!(\"Box<{}>\", snip),\n+                                    );\n+                                    return;\n+                                }\n                             }\n-                        }\n-                        db.span_help(def.variants[i].span,\n-                                     \"consider boxing the large fields to reduce the total size of the enum\");\n-                    });\n+                            db.span_help(\n+                                def.variants[i].span,\n+                                \"consider boxing the large fields to reduce the total size of the enum\",\n+                            );\n+                        },\n+                    );\n                 }\n             }\n \n@@ -107,7 +118,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n }\n \n fn update_if<T, F>(old: &mut Option<T>, new: T, f: F)\n-    where F: Fn(&T, &T) -> bool\n+where\n+    F: Fn(&T, &T) -> bool,\n {\n     if let Some(ref mut val) = *old {\n         if f(val, &new) {"}, {"sha": "4e40348facf2467372d8a1ff1d58b64ced3a7faa", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -51,7 +51,7 @@ declare_lint! {\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct LenZero;\n \n impl LintPass for LenZero {\n@@ -91,24 +91,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n         item.name == name &&\n-        if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self &&\n-            {\n-                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+            if let AssociatedItemKind::Method { has_self } = item.kind {\n+                has_self &&\n+                    {\n+                        let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                        cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                    }\n+            } else {\n+                false\n             }\n-        } else {\n-            false\n-        }\n     }\n \n     if !trait_items.iter().any(|i| is_named_self(cx, i, \"is_empty\")) {\n         if let Some(i) = trait_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n             if cx.access_levels.is_exported(i.id.node_id) {\n-                span_lint(cx,\n-                          LEN_WITHOUT_IS_EMPTY,\n-                          item.span,\n-                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\", item.name));\n+                span_lint(\n+                    cx,\n+                    LEN_WITHOUT_IS_EMPTY,\n+                    item.span,\n+                    &format!(\"trait `{}` has a `len` method but no `is_empty` method\", item.name),\n+                );\n             }\n         }\n     }\n@@ -117,15 +119,15 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n         item.name == name &&\n-        if let AssociatedItemKind::Method { has_self } = item.kind {\n-            has_self &&\n-            {\n-                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+            if let AssociatedItemKind::Method { has_self } = item.kind {\n+                has_self &&\n+                    {\n+                        let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                        cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n+                    }\n+            } else {\n+                false\n             }\n-        } else {\n-            false\n-        }\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n@@ -143,10 +145,12 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let ty = cx.tcx.type_of(def_id);\n \n-            span_lint(cx,\n-                      LEN_WITHOUT_IS_EMPTY,\n-                      item.span,\n-                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\", ty, is_empty));\n+            span_lint(\n+                cx,\n+                LEN_WITHOUT_IS_EMPTY,\n+                item.span,\n+                &format!(\"item `{}` has a public `len` method but {} `is_empty` method\", ty, is_empty),\n+            );\n         }\n     }\n }\n@@ -170,12 +174,14 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n         if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n-            span_lint_and_sugg(cx,\n-                               LEN_ZERO,\n-                               span,\n-                               \"length comparison to zero\",\n-                               \"using `is_empty` is more concise\",\n-                               format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")));\n+            span_lint_and_sugg(\n+                cx,\n+                LEN_ZERO,\n+                span,\n+                \"length comparison to zero\",\n+                \"using `is_empty` is more concise\",\n+                format!(\"{}{}.is_empty()\", op, snippet(cx, args[0].span, \"_\")),\n+            );\n         }\n     }\n }\n@@ -199,10 +205,11 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx\n-            .inherent_impls(id)\n-            .iter()\n-            .any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n+        cx.tcx.inherent_impls(id).iter().any(|imp| {\n+            cx.tcx.associated_items(*imp).any(\n+                |item| is_is_empty(cx, &item),\n+            )\n+        })\n     }\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n@@ -212,7 +219,12 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n                 .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n                 .any(|item| is_is_empty(cx, &item))\n         },\n-        ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, id)),\n+        ty::TyProjection(_) => {\n+            ty.ty_to_def_id().map_or(\n+                false,\n+                |id| has_is_empty_impl(cx, id),\n+            )\n+        },\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n         _ => false,"}, {"sha": "ecd18424bd8de1b1a6373a4aa7699d97cb9d81e5", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -49,7 +49,7 @@ declare_lint! {\n     \"unidiomatic `let mut` declaration followed by initialization in `if`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct LetIfSeq;\n \n impl LintPass for LetIfSeq {\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     decl: hir::def_id::DefId,\n-    block: &'tcx hir::Block\n+    block: &'tcx hir::Block,\n ) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n         block.expr.is_none(),"}, {"sha": "dd721db0f09190db69dbdedebad12c46afe0bf32", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -48,7 +48,7 @@ declare_lint! {\n     \"unused lifetimes in function definitions\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct LifetimePass;\n \n impl LintPass for LifetimePass {\n@@ -94,7 +94,7 @@ fn check_fn_inner<'a, 'tcx>(\n     decl: &'tcx FnDecl,\n     body: Option<BodyId>,\n     generics: &'tcx Generics,\n-    span: Span\n+    span: Span,\n ) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n@@ -104,7 +104,8 @@ fn check_fn_inner<'a, 'tcx>(\n     for typ in &generics.ty_params {\n         for bound in &typ.bounds {\n             if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-                let bounds = trait_ref.trait_ref\n+                let bounds = trait_ref\n+                    .trait_ref\n                     .path\n                     .segments\n                     .last()\n@@ -121,10 +122,12 @@ fn check_fn_inner<'a, 'tcx>(\n         }\n     }\n     if could_use_elision(cx, decl, body, &generics.lifetimes, bounds_lts) {\n-        span_lint(cx,\n-                  NEEDLESS_LIFETIMES,\n-                  span,\n-                  \"explicit lifetimes given in parameter types where they could be elided\");\n+        span_lint(\n+            cx,\n+            NEEDLESS_LIFETIMES,\n+            span,\n+            \"explicit lifetimes given in parameter types where they could be elided\",\n+        );\n     }\n     report_extra_lifetimes(cx, decl, generics);\n }\n@@ -134,7 +137,7 @@ fn could_use_elision<'a, 'tcx: 'a>(\n     func: &'tcx FnDecl,\n     body: Option<BodyId>,\n     named_lts: &'tcx [LifetimeDef],\n-    bounds_lts: Vec<&'tcx Lifetime>\n+    bounds_lts: Vec<&'tcx Lifetime>,\n ) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -189,7 +192,10 @@ fn could_use_elision<'a, 'tcx: 'a>(\n         // no output lifetimes, check distinctness of input lifetimes\n \n         // only unnamed and static, ok\n-        if input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static) {\n+        if input_lts.iter().all(|lt| {\n+            *lt == RefLt::Unnamed || *lt == RefLt::Static\n+        })\n+        {\n             return false;\n         }\n         // we have no output reference, so we only need all distinct lifetimes\n@@ -406,7 +412,8 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n }\n \n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n-    let hs = generics.lifetimes\n+    let hs = generics\n+        .lifetimes\n         .iter()\n         .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n         .collect();"}, {"sha": "0da8ffd0a302ca1fd821f99e23726079d4b5689c", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -146,7 +146,8 @@ impl<'a> DigitInfo<'a> {\n         let group_size = self.radix.suggest_grouping();\n         if self.digits.contains('.') {\n             let mut parts = self.digits.split('.');\n-            let int_part_hint = parts.next()\n+            let int_part_hint = parts\n+                .next()\n                 .expect(\"split always returns at least one element\")\n                 .chars()\n                 .rev()\n@@ -157,7 +158,8 @@ impl<'a> DigitInfo<'a> {\n                 .rev()\n                 .collect::<Vec<String>>()\n                 .join(\"_\");\n-            let frac_part_hint = parts.next()\n+            let frac_part_hint = parts\n+                .next()\n                 .expect(\"already checked that there is a `.`\")\n                 .chars()\n                 .filter(|&c| c != '_')\n@@ -194,25 +196,31 @@ impl WarningType {\n     pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: &syntax_pos::Span) {\n         match *self {\n             WarningType::UnreadableLiteral => {\n-                span_help_and_lint(cx,\n-                                   UNREADABLE_LITERAL,\n-                                   *span,\n-                                   \"long literal lacking separators\",\n-                                   &format!(\"consider: {}\", grouping_hint))\n+                span_help_and_lint(\n+                    cx,\n+                    UNREADABLE_LITERAL,\n+                    *span,\n+                    \"long literal lacking separators\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n             },\n             WarningType::LargeDigitGroups => {\n-                span_help_and_lint(cx,\n-                                   LARGE_DIGIT_GROUPS,\n-                                   *span,\n-                                   \"digit groups should be smaller\",\n-                                   &format!(\"consider: {}\", grouping_hint))\n+                span_help_and_lint(\n+                    cx,\n+                    LARGE_DIGIT_GROUPS,\n+                    *span,\n+                    \"digit groups should be smaller\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n             },\n             WarningType::InconsistentDigitGrouping => {\n-                span_help_and_lint(cx,\n-                                   INCONSISTENT_DIGIT_GROUPING,\n-                                   *span,\n-                                   \"digits grouped inconsistently by underscores\",\n-                                   &format!(\"consider: {}\", grouping_hint))\n+                span_help_and_lint(\n+                    cx,\n+                    INCONSISTENT_DIGIT_GROUPING,\n+                    *span,\n+                    \"digits grouped inconsistently by underscores\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n             },\n         };\n     }\n@@ -309,7 +317,8 @@ impl LiteralDigitGrouping {\n     /// size on success or `WarningType` when emitting a warning.\n     fn do_lint(digits: &str) -> Result<usize, WarningType> {\n         // Grab underscore indices with respect to the units digit.\n-        let underscore_positions: Vec<usize> = digits.chars()\n+        let underscore_positions: Vec<usize> = digits\n+            .chars()\n             .rev()\n             .enumerate()\n             .filter_map(|(idx, digit)| if digit == '_' { Some(idx) } else { None })"}, {"sha": "25015cb26bb704c308adbeca7b7c61f52a4fd1e7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 211, "deletions": 126, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -83,7 +83,8 @@ declare_lint! {\n /// implements `IntoIterator`, so that possibly one value will be iterated,\n /// leading to some hard to find bugs. No one will want to write such code\n /// [except to win an Underhanded Rust\n-/// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+/// Contest](https://www.reddit.\n+/// com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n ///\n /// **Known problems:** None.\n ///\n@@ -99,7 +100,8 @@ declare_lint! {\n \n /// **What it does:** Checks for `for` loops over `Option` values.\n ///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if let`.\n+/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+/// let`.\n ///\n /// **Known problems:** None.\n ///\n@@ -120,7 +122,8 @@ declare_lint! {\n \n /// **What it does:** Checks for `for` loops over `Result` values.\n ///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if let`.\n+/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+/// let`.\n ///\n /// **Known problems:** None.\n ///\n@@ -142,7 +145,8 @@ declare_lint! {\n /// **What it does:** Detects `loop + match` combinations that are easier\n /// written as a `while let` loop.\n ///\n-/// **Why is this bad?** The `while let` loop is usually shorter and more readable.\n+/// **Why is this bad?** The `while let` loop is usually shorter and more\n+/// readable.\n ///\n /// **Known problems:** Sometimes the wrong binding is displayed (#383).\n ///\n@@ -309,20 +313,22 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NEEDLESS_RANGE_LOOP,\n-                    EXPLICIT_ITER_LOOP,\n-                    EXPLICIT_INTO_ITER_LOOP,\n-                    ITER_NEXT_LOOP,\n-                    FOR_LOOP_OVER_RESULT,\n-                    FOR_LOOP_OVER_OPTION,\n-                    WHILE_LET_LOOP,\n-                    UNUSED_COLLECT,\n-                    REVERSE_RANGE_LOOP,\n-                    EXPLICIT_COUNTER_LOOP,\n-                    EMPTY_LOOP,\n-                    WHILE_LET_ON_ITERATOR,\n-                    FOR_KV_MAP,\n-                    NEVER_LOOP)\n+        lint_array!(\n+            NEEDLESS_RANGE_LOOP,\n+            EXPLICIT_ITER_LOOP,\n+            EXPLICIT_INTO_ITER_LOOP,\n+            ITER_NEXT_LOOP,\n+            FOR_LOOP_OVER_RESULT,\n+            FOR_LOOP_OVER_OPTION,\n+            WHILE_LET_LOOP,\n+            UNUSED_COLLECT,\n+            REVERSE_RANGE_LOOP,\n+            EXPLICIT_COUNTER_LOOP,\n+            EMPTY_LOOP,\n+            WHILE_LET_ON_ITERATOR,\n+            FOR_KV_MAP,\n+            NEVER_LOOP\n+        )\n     }\n }\n \n@@ -349,11 +355,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let ExprLoop(ref block, _, LoopSource::Loop) = expr.node {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n-                span_lint(cx,\n-                          EMPTY_LOOP,\n-                          expr.span,\n-                          \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n-                           `std::thread::sleep(..);` to the loop body.\");\n+                span_lint(\n+                    cx,\n+                    EMPTY_LOOP,\n+                    expr.span,\n+                    \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n+                           `std::thread::sleep(..);` to the loop body.\",\n+                );\n             }\n \n             // extract the expression from the first statement (if any) in a block\n@@ -366,8 +374,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         MatchSource::Normal |\n                         MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                               arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                               is_break_expr(&arms[1].body) {\n+                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+                                is_break_expr(&arms[1].body)\n+                            {\n                                 if in_external_macro(cx, expr.span) {\n                                     return;\n                                 }\n@@ -377,14 +386,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 // 1) it was ugly with big bodies;\n                                 // 2) it was not indented properly;\n                                 // 3) it wasn\u2019t very smart (see #675).\n-                                span_lint_and_sugg(cx,\n-                                                   WHILE_LET_LOOP,\n-                                                   expr.span,\n-                                                   \"this loop could be written as a `while let` loop\",\n-                                                   \"try\",\n-                                                   format!(\"while let {} = {} {{ .. }}\",\n-                                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                                           snippet(cx, matchexpr.span, \"..\")));\n+                                span_lint_and_sugg(\n+                                    cx,\n+                                    WHILE_LET_LOOP,\n+                                    expr.span,\n+                                    \"this loop could be written as a `while let` loop\",\n+                                    \"try\",\n+                                    format!(\n+                                        \"while let {} = {} {{ .. }}\",\n+                                        snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                        snippet(cx, matchexpr.span, \"..\")\n+                                    ),\n+                                );\n                             }\n                         },\n                         _ => (),\n@@ -395,20 +408,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node) {\n+                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node)\n+            {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n                 if method_path.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                   lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n-                   !is_iterator_used_after_while_let(cx, iter_expr) && !is_nested(cx, expr, &method_args[0]) {\n+                    lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n+                    !is_iterator_used_after_while_let(cx, iter_expr) &&\n+                    !is_nested(cx, expr, &method_args[0])\n+                {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                    span_lint_and_sugg(cx,\n-                                       WHILE_LET_ON_ITERATOR,\n-                                       expr.span,\n-                                       \"this loop could be written as a `for` loop\",\n-                                       \"try\",\n-                                       format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                    span_lint_and_sugg(\n+                        cx,\n+                        WHILE_LET_ON_ITERATOR,\n+                        expr.span,\n+                        \"this loop could be written as a `for` loop\",\n+                        \"try\",\n+                        format!(\"for {} in {} {{ .. }}\", loop_var, iterator),\n+                    );\n                 }\n             }\n         }\n@@ -418,11 +436,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n-                    span_lint(cx,\n-                              UNUSED_COLLECT,\n-                              expr.span,\n-                              \"you are collect()ing an iterator and throwing away the result. \\\n-                               Consider using an explicit for loop to exhaust the iterator\");\n+                    span_lint(\n+                        cx,\n+                        UNUSED_COLLECT,\n+                        expr.span,\n+                        \"you are collect()ing an iterator and throwing away the result. \\\n+                               Consider using an explicit for loop to exhaust the iterator\",\n+                    );\n                 }\n             }\n         }\n@@ -435,7 +455,10 @@ fn never_loop(block: &Block, id: &NodeId) -> bool {\n \n fn contains_continue_block(block: &Block, dest: &NodeId) -> bool {\n     block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n-    block.expr.as_ref().map_or(false, |e| contains_continue_expr(e, dest))\n+        block.expr.as_ref().map_or(\n+            false,\n+            |e| contains_continue_expr(e, dest),\n+        )\n }\n \n fn contains_continue_stmt(stmt: &Stmt, dest: &NodeId) -> bool {\n@@ -448,7 +471,12 @@ fn contains_continue_stmt(stmt: &Stmt, dest: &NodeId) -> bool {\n \n fn contains_continue_decl(decl: &Decl, dest: &NodeId) -> bool {\n     match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map_or(false, |e| contains_continue_expr(e, dest)),\n+        DeclLocal(ref local) => {\n+            local.init.as_ref().map_or(\n+                false,\n+                |e| contains_continue_expr(e, dest),\n+            )\n+        },\n         _ => false,\n     }\n }\n@@ -475,14 +503,21 @@ fn contains_continue_expr(expr: &Expr, dest: &NodeId) -> bool {\n         ExprAssignOp(_, ref e1, ref e2) |\n         ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| contains_continue_expr(e, dest)),\n         ExprIf(ref e, ref e2, ref e3) => {\n-            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| contains_continue_expr(e, dest))\n+            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| {\n+                contains_continue_expr(e, dest)\n+            })\n         },\n         ExprWhile(ref e, ref b, _) => contains_continue_expr(e, dest) || contains_continue_block(b, dest),\n         ExprMatch(ref e, ref arms, _) => {\n             contains_continue_expr(e, dest) || arms.iter().any(|a| contains_continue_expr(&a.body, dest))\n         },\n         ExprBlock(ref block) => contains_continue_block(block, dest),\n-        ExprStruct(_, _, ref base) => base.as_ref().map_or(false, |e| contains_continue_expr(e, dest)),\n+        ExprStruct(_, _, ref base) => {\n+            base.as_ref().map_or(\n+                false,\n+                |e| contains_continue_expr(e, dest),\n+            )\n+        },\n         ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| id == *dest),\n         _ => false,\n     }\n@@ -541,7 +576,7 @@ fn check_for_loop<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr\n+    expr: &'tcx Expr,\n ) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n@@ -557,9 +592,14 @@ fn check_for_loop_range<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr\n+    expr: &'tcx Expr,\n ) {\n-    if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n+    if let Some(higher::Range {\n+                    start: Some(start),\n+                    ref end,\n+                    limits,\n+                }) = higher::range(arg)\n+    {\n         // the var must be a single name\n         if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n@@ -573,10 +613,9 @@ fn check_for_loop_range<'a, 'tcx>(\n \n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n-                let (indexed, indexed_extent) = visitor.indexed\n-                    .into_iter()\n-                    .next()\n-                    .expect(\"already checked that we have exactly 1 element\");\n+                let (indexed, indexed_extent) = visitor.indexed.into_iter().next().expect(\n+                    \"already checked that we have exactly 1 element\",\n+                );\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -589,7 +628,8 @@ fn check_for_loop_range<'a, 'tcx>(\n                     }\n                 }\n \n-                // don't lint if the container that is indexed into is also used without indexing\n+                // don't lint if the container that is indexed into is also used without\n+                // indexing\n                 if visitor.referenced.contains(&indexed) {\n                     return;\n                 }\n@@ -670,7 +710,12 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n+    if let Some(higher::Range {\n+                    start: Some(start),\n+                    end: Some(end),\n+                    limits,\n+                }) = higher::range(arg)\n+    {\n         // ...and both sides are compile-time constant integers...\n         let parent_item = cx.tcx.hir.get_parent(arg.id);\n         let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n@@ -714,10 +759,12 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                 } else if eq && limits != ast::RangeLimits::Closed {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n-                    span_lint(cx,\n-                              REVERSE_RANGE_LOOP,\n-                              expr.span,\n-                              \"this range is empty so this for loop will never run\");\n+                    span_lint(\n+                        cx,\n+                        REVERSE_RANGE_LOOP,\n+                        expr.span,\n+                        \"this range is empty so this for loop will never run\",\n+                    );\n                 }\n             }\n         }\n@@ -731,13 +778,15 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n     } else {\n         \"\"\n     };\n-    span_lint_and_sugg(cx,\n-                       EXPLICIT_ITER_LOOP,\n-                       arg.span,\n-                       \"it is more idiomatic to loop over references to containers instead of using explicit \\\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_ITER_LOOP,\n+        arg.span,\n+        \"it is more idiomatic to loop over references to containers instead of using explicit \\\n                         iteration methods\",\n-                       \"to write this more concisely, try\",\n-                       format!(\"&{}{}\", muta, object))\n+        \"to write this more concisely, try\",\n+        format!(\"&{}{}\", muta, object),\n+    )\n }\n \n fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n@@ -762,20 +811,24 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                     lint_iter_method(cx, args, arg, method_name);\n                 } else {\n                     let object = snippet(cx, args[0].span, \"_\");\n-                    span_lint_and_sugg(cx,\n-                                       EXPLICIT_INTO_ITER_LOOP,\n-                                       arg.span,\n-                                       \"it is more idiomatic to loop over containers instead of using explicit \\\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXPLICIT_INTO_ITER_LOOP,\n+                        arg.span,\n+                        \"it is more idiomatic to loop over containers instead of using explicit \\\n                                         iteration methods`\",\n-                                       \"to write this more concisely, try\",\n-                                       object.to_string());\n+                        \"to write this more concisely, try\",\n+                        object.to_string(),\n+                    );\n                 }\n             } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n-                span_lint(cx,\n-                          ITER_NEXT_LOOP,\n-                          expr.span,\n-                          \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-                           probably not what you want\");\n+                span_lint(\n+                    cx,\n+                    ITER_NEXT_LOOP,\n+                    expr.span,\n+                    \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+                           probably not what you want\",\n+                );\n                 next_loop_linted = true;\n             }\n         }\n@@ -789,33 +842,45 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n-        span_help_and_lint(cx,\n-                           FOR_LOOP_OVER_OPTION,\n-                           arg.span,\n-                           &format!(\"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+        span_help_and_lint(\n+            cx,\n+            FOR_LOOP_OVER_OPTION,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n                                      `if let` statement.\",\n-                                    snippet(cx, arg.span, \"_\")),\n-                           &format!(\"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n-                                    snippet(cx, pat.span, \"_\"),\n-                                    snippet(cx, arg.span, \"_\")));\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n     } else if match_type(cx, ty, &paths::RESULT) {\n-        span_help_and_lint(cx,\n-                           FOR_LOOP_OVER_RESULT,\n-                           arg.span,\n-                           &format!(\"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+        span_help_and_lint(\n+            cx,\n+            FOR_LOOP_OVER_RESULT,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n                                      `if let` statement.\",\n-                                    snippet(cx, arg.span, \"_\")),\n-                           &format!(\"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n-                                    snippet(cx, pat.span, \"_\"),\n-                                    snippet(cx, arg.span, \"_\")));\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n     }\n }\n \n fn check_for_loop_explicit_counter<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr\n+    expr: &'tcx Expr,\n ) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n@@ -829,10 +894,15 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir;\n-    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id));\n+    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| {\n+        map.get_enclosing_scope(id)\n+    });\n     if let Some(parent_id) = parent_scope {\n         if let NodeBlock(block) = map.get(parent_id) {\n-            for (id, _) in visitor.states.iter().filter(|&(_, v)| *v == VarState::IncrOnce) {\n+            for (id, _) in visitor.states.iter().filter(\n+                |&(_, v)| *v == VarState::IncrOnce,\n+            )\n+            {\n                 let mut visitor2 = InitializeVisitor {\n                     cx: cx,\n                     end_expr: expr,\n@@ -846,13 +916,17 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n \n                 if visitor2.state == VarState::Warn {\n                     if let Some(name) = visitor2.name {\n-                        span_lint(cx,\n-                                  EXPLICIT_COUNTER_LOOP,\n-                                  expr.span,\n-                                  &format!(\"the variable `{0}` is used as a loop counter. Consider using `for ({0}, \\\n+                        span_lint(\n+                            cx,\n+                            EXPLICIT_COUNTER_LOOP,\n+                            expr.span,\n+                            &format!(\n+                                \"the variable `{0}` is used as a loop counter. Consider using `for ({0}, \\\n                                             item) in {1}.enumerate()` or similar iterators\",\n-                                           name,\n-                                           snippet(cx, arg.span, \"_\")));\n+                                name,\n+                                snippet(cx, arg.span, \"_\")\n+                            ),\n+                        );\n                     }\n                 }\n             }\n@@ -866,7 +940,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     pat: &'tcx Pat,\n     arg: &'tcx Expr,\n     body: &'tcx Expr,\n-    expr: &'tcx Expr\n+    expr: &'tcx Expr,\n ) {\n     let pat_span = pat.span;\n \n@@ -929,7 +1003,7 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n fn match_var(expr: &Expr, var: Name) -> bool {\n     if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].name == var {\n-            return true\n+            return true;\n         }\n     }\n     false\n@@ -964,7 +1038,8 @@ struct VarVisitor<'a, 'tcx: 'a> {\n     /// Any names that are used outside an index operation.\n     /// Used to detect things like `&mut vec` used together with `vec[i]`\n     referenced: HashSet<Name>,\n-    /// has the loop variable been used in expressions other than the index of an index op?\n+    /// has the loop variable been used in expressions other than the index of\n+    /// an index op?\n     nonindex: bool,\n }\n \n@@ -1095,7 +1170,8 @@ fn is_iterable_array(ty: Ty) -> bool {\n     }\n }\n \n-/// If a block begins with a statement (possibly a `let` binding) and has an expression, return it.\n+/// If a block begins with a statement (possibly a `let` binding) and has an\n+/// expression, return it.\n fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n     if block.stmts.is_empty() {\n         return None;\n@@ -1302,7 +1378,9 @@ fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let ExprPath(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.id);\n         if let Def::Local(def_id) = path_res {\n-            let node_id = cx.tcx.hir.as_local_node_id(def_id).expect(\"That DefId should be valid\");\n+            let node_id = cx.tcx.hir.as_local_node_id(def_id).expect(\n+                \"That DefId should be valid\",\n+            );\n             return Some(node_id);\n         }\n     }\n@@ -1348,17 +1426,18 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n         match cx.tcx.hir.find(parent) {\n             Some(NodeExpr(expr)) => {\n                 match expr.node {\n-                    ExprLoop(..) |\n-                    ExprWhile(..) => { return true; },\n-                    _ => ()\n+                    ExprLoop(..) | ExprWhile(..) => {\n+                        return true;\n+                    },\n+                    _ => (),\n                 }\n             },\n             Some(NodeBlock(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n-                                            id: id,\n-                                            iterator: iter_name,\n-                                            nesting: Unknown\n-                                        };\n+                    id: id,\n+                    iterator: iter_name,\n+                    nesting: Unknown,\n+                };\n                 walk_block(&mut block_visitor, block);\n                 if block_visitor.nesting == RuledOut {\n                     return false;\n@@ -1367,7 +1446,7 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n             Some(NodeStmt(_)) => (),\n             _ => {\n                 return false;\n-            }\n+            },\n         }\n         id = parent;\n     }\n@@ -1377,15 +1456,15 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n enum Nesting {\n     Unknown, // no nesting detected yet\n     RuledOut, // the iterator is initialized or assigned within scope\n-    LookFurther // no nesting detected, no further walk required\n+    LookFurther, // no nesting detected, no further walk required\n }\n \n use self::Nesting::{Unknown, RuledOut, LookFurther};\n \n struct LoopNestVisitor {\n     id: NodeId,\n     iterator: Name,\n-    nesting: Nesting\n+    nesting: Nesting,\n }\n \n impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n@@ -1398,22 +1477,28 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if self.nesting != Unknown { return; }\n+        if self.nesting != Unknown {\n+            return;\n+        }\n         if expr.id == self.id {\n             self.nesting = LookFurther;\n             return;\n         }\n         match expr.node {\n             ExprAssign(ref path, _) |\n-            ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n-                self.nesting = RuledOut;\n+            ExprAssignOp(_, ref path, _) => {\n+                if match_var(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n             },\n-            _ => walk_expr(self, expr)\n+            _ => walk_expr(self, expr),\n         }\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n-        if self.nesting != Unknown { return; }\n+        if self.nesting != Unknown {\n+            return;\n+        }\n         if let PatKind::Binding(_, _, span_name, _) = pat.node {\n             if self.iterator == span_name.node {\n                 self.nesting = RuledOut;"}, {"sha": "457c6cc8d65ef77f25bdbbabf583632339fa3242", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -2,8 +2,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet, span_help_and_lint,\n-            walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -76,13 +76,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     ExprPath(ref path) => {\n                         if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n-                            span_help_and_lint(cx,\n-                                               MAP_CLONE,\n-                                               expr.span,\n-                                               &format!(\"you seem to be using .map() to clone the contents of an \\\n+                            span_help_and_lint(\n+                                cx,\n+                                MAP_CLONE,\n+                                expr.span,\n+                                &format!(\n+                                    \"you seem to be using .map() to clone the contents of an \\\n                                                          {}, consider using `.cloned()`\",\n-                                                        type_name),\n-                                               &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                                    type_name\n+                                ),\n+                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")),\n+                            );\n                         }\n                     },\n                     _ => (),\n@@ -95,10 +99,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprPath(QPath::Resolved(None, ref path)) => {\n-            let arg_segment = [PathSegment {\n-                                   name: id,\n-                                   parameters: PathParameters::none(),\n-                               }];\n+            let arg_segment = [\n+                PathSegment {\n+                    name: id,\n+                    parameters: PathParameters::none(),\n+                },\n+            ];\n             !path.is_global() && path.segments[..] == arg_segment\n         },\n         _ => false,"}, {"sha": "5dba102f6a4105aa17bb254fcde0bf2401025f2b", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 120, "deletions": 91, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -150,12 +150,14 @@ pub struct MatchPass;\n \n impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH,\n-                    MATCH_REF_PATS,\n-                    MATCH_BOOL,\n-                    SINGLE_MATCH_ELSE,\n-                    MATCH_OVERLAPPING_ARM,\n-                    MATCH_WILD_ERR_ARM)\n+        lint_array!(\n+            SINGLE_MATCH,\n+            MATCH_REF_PATS,\n+            MATCH_BOOL,\n+            SINGLE_MATCH_ELSE,\n+            MATCH_OVERLAPPING_ARM,\n+            MATCH_WILD_ERR_ARM\n+        )\n     }\n }\n \n@@ -212,28 +214,34 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n         SINGLE_MATCH\n     };\n     let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-    span_lint_and_sugg(cx,\n-                       lint,\n-                       expr.span,\n-                       \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n+    span_lint_and_sugg(\n+        cx,\n+        lint,\n+        expr.span,\n+        \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n                         let`\",\n-                       \"try this\",\n-                       format!(\"if let {} = {} {}{}\",\n-                               snippet(cx, arms[0].pats[0].span, \"..\"),\n-                               snippet(cx, ex.span, \"..\"),\n-                               expr_block(cx, &arms[0].body, None, \"..\"),\n-                               els_str));\n+        \"try this\",\n+        format!(\n+            \"if let {} = {} {}{}\",\n+            snippet(cx, arms[0].pats[0].span, \"..\"),\n+            snippet(cx, ex.span, \"..\"),\n+            expr_block(cx, &arms[0].body, None, \"..\"),\n+            els_str\n+        ),\n+    );\n }\n \n fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n-    let candidates = &[(&paths::COW, \"Borrowed\"),\n-                       (&paths::COW, \"Cow::Borrowed\"),\n-                       (&paths::COW, \"Cow::Owned\"),\n-                       (&paths::COW, \"Owned\"),\n-                       (&paths::OPTION, \"None\"),\n-                       (&paths::RESULT, \"Err\"),\n-                       (&paths::RESULT, \"Ok\")];\n+    let candidates = &[\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n+    ];\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n@@ -258,52 +266,60 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tables.expr_ty(ex).sty == ty::TyBool {\n-        span_lint_and_then(cx,\n-                           MATCH_BOOL,\n-                           expr.span,\n-                           \"you seem to be trying to match on a boolean expression\",\n-                           move |db| {\n-            if arms.len() == 2 && arms[0].pats.len() == 1 {\n-                // no guards\n-                let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n-                    if let ExprLit(ref lit) = arm_bool.node {\n-                        match lit.node {\n-                            LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                            LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                            _ => None,\n+        span_lint_and_then(\n+            cx,\n+            MATCH_BOOL,\n+            expr.span,\n+            \"you seem to be trying to match on a boolean expression\",\n+            move |db| {\n+                if arms.len() == 2 && arms[0].pats.len() == 1 {\n+                    // no guards\n+                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n+                        if let ExprLit(ref lit) = arm_bool.node {\n+                            match lit.node {\n+                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n                         }\n                     } else {\n                         None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n-                if let Some((true_expr, false_expr)) = exprs {\n-                    let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                        (false, false) => {\n-                            Some(format!(\"if {} {} else {}\",\n-                                         snippet(cx, ex.span, \"b\"),\n-                                         expr_block(cx, true_expr, None, \"..\"),\n-                                         expr_block(cx, false_expr, None, \"..\")))\n-                        },\n-                        (false, true) => {\n-                            Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n-                        },\n-                        (true, false) => {\n-                            let test = Sugg::hir(cx, ex, \"..\");\n-                            Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n-                        },\n-                        (true, true) => None,\n                     };\n \n-                    if let Some(sugg) = sugg {\n-                        db.span_suggestion(expr.span, \"consider using an if/else expression\", sugg);\n+                    if let Some((true_expr, false_expr)) = exprs {\n+                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                            (false, false) => {\n+                                Some(format!(\n+                                    \"if {} {} else {}\",\n+                                    snippet(cx, ex.span, \"b\"),\n+                                    expr_block(cx, true_expr, None, \"..\"),\n+                                    expr_block(cx, false_expr, None, \"..\")\n+                                ))\n+                            },\n+                            (false, true) => {\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    snippet(cx, ex.span, \"b\"),\n+                                    expr_block(cx, true_expr, None, \"..\")\n+                                ))\n+                            },\n+                            (true, false) => {\n+                                let test = Sugg::hir(cx, ex, \"..\");\n+                                Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n+                            },\n+                            (true, true) => None,\n+                        };\n+\n+                        if let Some(sugg) = sugg {\n+                            db.span_suggestion(expr.span, \"consider using an if/else expression\", sugg);\n+                        }\n                     }\n                 }\n-            }\n \n-        });\n+            },\n+        );\n     }\n }\n \n@@ -313,12 +329,14 @@ fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n             if let Some((start, end)) = overlapping(&type_ranges) {\n-                span_note_and_lint(cx,\n-                                   MATCH_OVERLAPPING_ARM,\n-                                   start.span,\n-                                   \"some ranges overlap\",\n-                                   end.span,\n-                                   \"overlaps with this\");\n+                span_note_and_lint(\n+                    cx,\n+                    MATCH_OVERLAPPING_ARM,\n+                    start.span,\n+                    \"some ranges overlap\",\n+                    end.span,\n+                    \"overlaps with this\",\n+                );\n             }\n         }\n     }\n@@ -376,17 +394,21 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n                 db.span_suggestion(expr.span, \"try\", template);\n             });\n         } else {\n-            span_lint_and_then(cx,\n-                               MATCH_REF_PATS,\n-                               expr.span,\n-                               \"you don't need to add `&` to all patterns\",\n-                               |db| {\n-                let ex = Sugg::hir(cx, ex, \"..\");\n-                let template = match_template(expr.span, source, &ex.deref());\n-                db.span_suggestion(expr.span,\n-                                   \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n-                                   template);\n-            });\n+            span_lint_and_then(\n+                cx,\n+                MATCH_REF_PATS,\n+                expr.span,\n+                \"you don't need to add `&` to all patterns\",\n+                |db| {\n+                    let ex = Sugg::hir(cx, ex, \"..\");\n+                    let template = match_template(expr.span, source, &ex.deref());\n+                    db.span_suggestion(\n+                        expr.span,\n+                        \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n+                        template,\n+                    );\n+                },\n+            );\n         }\n     }\n }\n@@ -399,13 +421,17 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &[Arm], id: NodeId) ->\n     let constcx = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables);\n     arms.iter()\n         .flat_map(|arm| {\n-            if let Arm { ref pats, guard: None, .. } = *arm {\n-                    pats.iter()\n-                } else {\n-                    [].iter()\n-                }\n-                .filter_map(|pat| {\n-                    if_let_chain! {[\n+            if let Arm {\n+                ref pats,\n+                guard: None,\n+                ..\n+            } = *arm\n+            {\n+                pats.iter()\n+            } else {\n+                [].iter()\n+            }.filter_map(|pat| {\n+                if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node,\n                     let Ok(lhs) = constcx.eval(lhs),\n                     let Ok(rhs) = constcx.eval(rhs)\n@@ -417,15 +443,15 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &[Arm], id: NodeId) ->\n                     return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                 }}\n \n-                    if_let_chain! {[\n+                if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n                     let Ok(value) = constcx.eval(value)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n                 }}\n \n-                    None\n-                })\n+                None\n+            })\n         })\n         .collect()\n }\n@@ -438,10 +464,12 @@ pub struct SpannedRange<T> {\n \n type TypedRanges = Vec<SpannedRange<ConstInt>>;\n \n-/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n+/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n+/// and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n-    ranges.iter()\n+    ranges\n+        .iter()\n         .filter_map(|range| match range.node {\n             (ConstVal::Integral(start), Bound::Included(ConstVal::Integral(end))) => {\n                 Some(SpannedRange {\n@@ -500,7 +528,8 @@ fn match_template(span: Span, source: MatchSource, expr: &Sugg) -> String {\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-    where T: Copy + Ord\n+where\n+    T: Copy + Ord,\n {\n     #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n     enum Kind<'a, T: 'a> {"}, {"sha": "280b51b23122cdc3cbd1b5f1037b49acca59e20f", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -2,7 +2,8 @@ use rustc::lint::*;\n use rustc::hir::{Expr, ExprCall, ExprPath};\n use utils::{match_def_path, paths, span_lint};\n \n-/// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is `Drop`.\n+/// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n+/// `Drop`.\n ///\n /// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n /// destructor, possibly causing leaks.\n@@ -38,7 +39,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n                     if match forgot_ty.ty_adt_def() {\n                         Some(def) => def.has_dtor(cx.tcx),\n                         _ => false,\n-                    } {\n+                    }\n+                    {\n                         span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");\n                     }\n                 }"}, {"sha": "c04fdde772f312b281e8bb1f1a4134f75bbc4bed", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 231, "deletions": 170, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -65,7 +65,8 @@ declare_lint! {\n /// information) instead of an inherent implementation.\n ///\n /// **Why is this bad?** Implementing the traits improve ergonomics for users of\n-/// the code, often with very little cost. Also people seeing a `mul(...)` method\n+/// the code, often with very little cost. Also people seeing a `mul(...)`\n+/// method\n /// may expect `*` to work equally, so you should have good reason to disappoint\n /// them.\n ///\n@@ -368,7 +369,8 @@ declare_lint! {\n      `_.split(\\\"x\\\")`\"\n }\n \n-/// **What it does:** Checks for getting the inner pointer of a temporary `CString`.\n+/// **What it does:** Checks for getting the inner pointer of a temporary\n+/// `CString`.\n ///\n /// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n /// as the `CString` is alive.\n@@ -500,7 +502,8 @@ declare_lint! {\n     \"using `x.extend(s.chars())` where s is a `&str` or `String`\"\n }\n \n-/// **What it does:** Checks for the use of `.cloned().collect()` on slice to create a `Vec`.\n+/// **What it does:** Checks for the use of `.cloned().collect()` on slice to\n+/// create a `Vec`.\n ///\n /// **Why is this bad?** `.to_vec()` is clearer\n ///\n@@ -524,29 +527,31 @@ declare_lint! {\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_UNWRAP_USED,\n-                    RESULT_UNWRAP_USED,\n-                    SHOULD_IMPLEMENT_TRAIT,\n-                    WRONG_SELF_CONVENTION,\n-                    WRONG_PUB_SELF_CONVENTION,\n-                    OK_EXPECT,\n-                    OPTION_MAP_UNWRAP_OR,\n-                    OPTION_MAP_UNWRAP_OR_ELSE,\n-                    OR_FUN_CALL,\n-                    CHARS_NEXT_CMP,\n-                    CLONE_ON_COPY,\n-                    CLONE_DOUBLE_REF,\n-                    NEW_RET_NO_SELF,\n-                    SINGLE_CHAR_PATTERN,\n-                    SEARCH_IS_SOME,\n-                    TEMPORARY_CSTRING_AS_PTR,\n-                    FILTER_NEXT,\n-                    FILTER_MAP,\n-                    ITER_NTH,\n-                    ITER_SKIP_NEXT,\n-                    GET_UNWRAP,\n-                    STRING_EXTEND_CHARS,\n-                    ITER_CLONED_COLLECT)\n+        lint_array!(\n+            OPTION_UNWRAP_USED,\n+            RESULT_UNWRAP_USED,\n+            SHOULD_IMPLEMENT_TRAIT,\n+            WRONG_SELF_CONVENTION,\n+            WRONG_PUB_SELF_CONVENTION,\n+            OK_EXPECT,\n+            OPTION_MAP_UNWRAP_OR,\n+            OPTION_MAP_UNWRAP_OR_ELSE,\n+            OR_FUN_CALL,\n+            CHARS_NEXT_CMP,\n+            CLONE_ON_COPY,\n+            CLONE_DOUBLE_REF,\n+            NEW_RET_NO_SELF,\n+            SINGLE_CHAR_PATTERN,\n+            SEARCH_IS_SOME,\n+            TEMPORARY_CSTRING_AS_PTR,\n+            FILTER_NEXT,\n+            FILTER_MAP,\n+            ITER_NTH,\n+            ITER_SKIP_NEXT,\n+            GET_UNWRAP,\n+            STRING_EXTEND_CHARS,\n+            ITER_CLONED_COLLECT\n+        )\n     }\n }\n \n@@ -706,7 +711,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         self_expr: &hir::Expr,\n         arg: &hir::Expr,\n         or_has_args: bool,\n-        span: Span\n+        span: Span,\n     ) -> bool {\n         if or_has_args {\n             return false;\n@@ -718,20 +723,22 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) =\n-                        get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n-                        default_trait_id\n-                    } else {\n-                        return false;\n-                    };\n+                    let default_trait_id =\n+                        if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n+                            default_trait_id\n+                        } else {\n+                            return false;\n+                        };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n-                        span_lint_and_sugg(cx,\n-                                           OR_FUN_CALL,\n-                                           span,\n-                                           &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                                           \"try this\",\n-                                           format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")));\n+                        span_lint_and_sugg(\n+                            cx,\n+                            OR_FUN_CALL,\n+                            span,\n+                            &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                            \"try this\",\n+                            format!(\"{}.unwrap_or_default()\", snippet(cx, self_expr.span, \"_\")),\n+                        );\n                         return true;\n                     }\n                 }\n@@ -749,7 +756,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         self_expr: &hir::Expr,\n         arg: &hir::Expr,\n         or_has_args: bool,\n-        span: Span\n+        span: Span,\n     ) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n@@ -765,15 +772,18 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n         // (path, fn_has_argument, methods, suffix)\n         let know_types: &[(&[_], _, &[_], _)] =\n-            &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-              (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-              (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-              (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\")];\n+            &[\n+                (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+                (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+                (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+            ];\n \n         let self_ty = cx.tables.expr_ty(self_expr);\n \n         let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-            know_types.iter().find(|&&i| match_type(cx, self_ty, i.0)) {\n+            know_types.iter().find(|&&i| match_type(cx, self_ty, i.0))\n+        {\n             (fn_has_arguments, poss, suffix)\n         } else {\n             return;\n@@ -789,12 +799,14 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n             (false, true) => snippet(cx, fun_span, \"..\"),\n         };\n \n-        span_lint_and_sugg(cx,\n-                           OR_FUN_CALL,\n-                           span,\n-                           &format!(\"use of `{}` followed by a function call\", name),\n-                           \"try this\",\n-                           format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg));\n+        span_lint_and_sugg(\n+            cx,\n+            OR_FUN_CALL,\n+            span,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"{}.{}_{}({})\", snippet(cx, self_expr.span, \"_\"), name, suffix, sugg),\n+        );\n     }\n \n     if args.len() == 2 {\n@@ -818,32 +830,30 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n-            span_lint_and_then(cx,\n-                               CLONE_DOUBLE_REF,\n-                               expr.span,\n-                               \"using `clone` on a double-reference; \\\n+            span_lint_and_then(\n+                cx,\n+                CLONE_DOUBLE_REF,\n+                expr.span,\n+                \"using `clone` on a double-reference; \\\n                                 this will copy the reference instead of cloning the inner type\",\n-                               |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                                   db.span_suggestion(expr.span,\n-                                                      \"try dereferencing it\",\n-                                                      format!(\"({}).clone()\", snip.deref()));\n-                               });\n+                |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                    db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"({}).clone()\", snip.deref()));\n+                },\n+            );\n             return; // don't report clone_on_copy\n         }\n     }\n \n     if is_copy(cx, ty) {\n-        span_lint_and_then(cx,\n-                           CLONE_ON_COPY,\n-                           expr.span,\n-                           \"using `clone` on a `Copy` type\",\n-                           |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                               if let ty::TyRef(..) = cx.tables.expr_ty(arg).sty {\n-                                   db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"{}\", snip.deref()));\n-                               } else {\n-                                   db.span_suggestion(expr.span, \"try removing the `clone` call\", format!(\"{}\", snip));\n-                               }\n-                           });\n+        span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |db| {\n+            if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                if let ty::TyRef(..) = cx.tables.expr_ty(arg).sty {\n+                    db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"{}\", snip.deref()));\n+                } else {\n+                    db.span_suggestion(expr.span, \"try removing the `clone` call\", format!(\"{}\", snip));\n+                }\n+            }\n+        });\n     }\n }\n \n@@ -860,15 +870,19 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n             return;\n         };\n \n-        span_lint_and_sugg(cx,\n-                           STRING_EXTEND_CHARS,\n-                           expr.span,\n-                           \"calling `.extend(_.chars())`\",\n-                           \"try this\",\n-                           format!(\"{}.push_str({}{})\",\n-                                   snippet(cx, args[0].span, \"_\"),\n-                                   ref_str,\n-                                   snippet(cx, target.span, \"_\")));\n+        span_lint_and_sugg(\n+            cx,\n+            STRING_EXTEND_CHARS,\n+            expr.span,\n+            \"calling `.extend(_.chars())`\",\n+            \"try this\",\n+            format!(\n+                \"{}.push_str({}{})\",\n+                snippet(cx, args[0].span, \"_\"),\n+                ref_str,\n+                snippet(cx, target.span, \"_\")\n+            ),\n+        );\n     }\n }\n \n@@ -898,12 +912,15 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n \n fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) &&\n-       derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n-        span_lint(cx,\n-                  ITER_CLONED_COLLECT,\n-                  expr.span,\n-                  \"called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                   more readable\");\n+        derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n+    {\n+        span_lint(\n+            cx,\n+            ITER_CLONED_COLLECT,\n+            expr.span,\n+            \"called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                   more readable\",\n+        );\n     }\n }\n \n@@ -919,12 +936,16 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is\n         return; // caller is not a type that we want to lint\n     };\n \n-    span_lint(cx,\n-              ITER_NTH,\n-              expr.span,\n-              &format!(\"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n-                       mut_str,\n-                       caller_type));\n+    span_lint(\n+        cx,\n+        ITER_NTH,\n+        expr.span,\n+        &format!(\n+            \"called `.iter{0}().nth()` on a {1}. Calling `.get{0}()` is both faster and more readable\",\n+            mut_str,\n+            caller_type\n+        ),\n+    );\n }\n \n fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n@@ -947,26 +968,34 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n \n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let borrow_str = if is_mut { \"&mut \" } else { \"&\" };\n-    span_lint_and_sugg(cx,\n-                       GET_UNWRAP,\n-                       expr.span,\n-                       &format!(\"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n-                                mut_str,\n-                                caller_type),\n-                       \"try this\",\n-                       format!(\"{}{}[{}]\",\n-                               borrow_str,\n-                               snippet(cx, get_args[0].span, \"_\"),\n-                               snippet(cx, get_args[1].span, \"_\")));\n+    span_lint_and_sugg(\n+        cx,\n+        GET_UNWRAP,\n+        expr.span,\n+        &format!(\n+            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+            mut_str,\n+            caller_type\n+        ),\n+        \"try this\",\n+        format!(\n+            \"{}{}[{}]\",\n+            borrow_str,\n+            snippet(cx, get_args[0].span, \"_\"),\n+            snippet(cx, get_args[1].span, \"_\")\n+        ),\n+    );\n }\n \n fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        span_lint(cx,\n-                  ITER_SKIP_NEXT,\n-                  expr.span,\n-                  \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\");\n+        span_lint(\n+            cx,\n+            ITER_SKIP_NEXT,\n+            expr.span,\n+            \"called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\",\n+        );\n     }\n }\n \n@@ -1017,14 +1046,18 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     };\n \n     if let Some((lint, kind, none_value)) = mess {\n-        span_lint(cx,\n-                  lint,\n-                  expr.span,\n-                  &format!(\"used unwrap() on {} value. If you don't want to handle the {} case gracefully, consider \\\n+        span_lint(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\n+                \"used unwrap() on {} value. If you don't want to handle the {} case gracefully, consider \\\n                             using expect() to provide a better panic \\\n                             message\",\n-                           kind,\n-                           none_value));\n+                kind,\n+                none_value\n+            ),\n+        );\n     }\n }\n \n@@ -1035,10 +1068,12 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type) {\n             if has_debug_impl(error_type, cx) {\n-                span_lint(cx,\n-                          OK_EXPECT,\n-                          expr.span,\n-                          \"called `ok().expect()` on a Result value. You can call `expect` directly on the `Result`\");\n+                span_lint(\n+                    cx,\n+                    OK_EXPECT,\n+                    expr.span,\n+                    \"called `ok().expect()` on a Result value. You can call `expect` directly on the `Result`\",\n+                );\n             }\n         }\n     }\n@@ -1059,14 +1094,18 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.ctxt == unwrap_args[1].span.ctxt;\n         if same_span && !multiline {\n-            span_note_and_lint(cx,\n-                               OPTION_MAP_UNWRAP_OR,\n-                               expr.span,\n-                               msg,\n-                               expr.span,\n-                               &format!(\"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\",\n-                                        map_snippet,\n-                                        unwrap_snippet));\n+            span_note_and_lint(\n+                cx,\n+                OPTION_MAP_UNWRAP_OR,\n+                expr.span,\n+                msg,\n+                expr.span,\n+                &format!(\n+                    \"replace `map({0}).unwrap_or({1})` with `map_or({1}, {0})`\",\n+                    map_snippet,\n+                    unwrap_snippet\n+                ),\n+            );\n         } else if same_span && multiline {\n             span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n         };\n@@ -1088,14 +1127,18 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n         let same_span = map_args[1].span.ctxt == unwrap_args[1].span.ctxt;\n         if same_span && !multiline {\n-            span_note_and_lint(cx,\n-                               OPTION_MAP_UNWRAP_OR_ELSE,\n-                               expr.span,\n-                               msg,\n-                               expr.span,\n-                               &format!(\"replace `map({0}).unwrap_or_else({1})` with `map_or_else({1}, {0})`\",\n-                                        map_snippet,\n-                                        unwrap_snippet));\n+            span_note_and_lint(\n+                cx,\n+                OPTION_MAP_UNWRAP_OR_ELSE,\n+                expr.span,\n+                msg,\n+                expr.span,\n+                &format!(\n+                    \"replace `map({0}).unwrap_or_else({1})` with `map_or_else({1}, {0})`\",\n+                    map_snippet,\n+                    unwrap_snippet\n+                ),\n+            );\n         } else if same_span && multiline {\n             span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n         };\n@@ -1111,12 +1154,14 @@ fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &[hir::Expr\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n             // add note if not multi-line\n-            span_note_and_lint(cx,\n-                               FILTER_NEXT,\n-                               expr.span,\n-                               msg,\n-                               expr.span,\n-                               &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet));\n+            span_note_and_lint(\n+                cx,\n+                FILTER_NEXT,\n+                expr.span,\n+                msg,\n+                expr.span,\n+                &format!(\"replace `filter({0}).next()` with `find({0})`\", filter_snippet),\n+            );\n         } else {\n             span_lint(cx, FILTER_NEXT, expr.span, msg);\n         }\n@@ -1171,22 +1216,26 @@ fn lint_search_is_some(\n     expr: &hir::Expr,\n     search_method: &str,\n     search_args: &[hir::Expr],\n-    is_some_args: &[hir::Expr]\n+    is_some_args: &[hir::Expr],\n ) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n-        let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n+        let msg = format!(\n+            \"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n                            expressed by calling `any()`.\",\n-                          search_method);\n+            search_method\n+        );\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n             // add note if not multi-line\n-            span_note_and_lint(cx,\n-                               SEARCH_IS_SOME,\n-                               expr.span,\n-                               &msg,\n-                               expr.span,\n-                               &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method, search_snippet));\n+            span_note_and_lint(\n+                cx,\n+                SEARCH_IS_SOME,\n+                expr.span,\n+                &msg,\n+                expr.span,\n+                &format!(\"replace `{0}({1}).is_some()` with `any({1})`\", search_method, search_snippet),\n+            );\n         } else {\n             span_lint(cx, SEARCH_IS_SOME, expr.span, &msg);\n         }\n@@ -1233,11 +1282,13 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n     if let Ok(ConstVal::Str(r)) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n-            span_lint_and_then(cx,\n-                               SINGLE_CHAR_PATTERN,\n-                               arg.span,\n-                               \"single-character string constant used as pattern\",\n-                               |db| { db.span_suggestion(expr.span, \"try using a char instead\", hint); });\n+            span_lint_and_then(\n+                cx,\n+                SINGLE_CHAR_PATTERN,\n+                arg.span,\n+                \"single-character string constant used as pattern\",\n+                |db| { db.span_suggestion(expr.span, \"try using a char instead\", hint); },\n+            );\n         }\n     }\n }\n@@ -1349,13 +1400,17 @@ impl SelfKind {\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n         allow_value_for_ref: bool,\n-        generics: &hir::Generics\n+        generics: &hir::Generics,\n     ) -> bool {\n-        // Self types in the HIR are desugared to explicit self types. So it will always be `self:\n+        // Self types in the HIR are desugared to explicit self types. So it will\n+        // always be `self:\n         // SomeType`,\n-        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n-        // Thus, we only need to test equality against the impl self type or if it is an explicit\n-        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`, `Self`, `&mut Self`,\n+        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if\n+        // the impl is on `Foo`)\n+        // Thus, we only need to test equality against the impl self type or if it is\n+        // an explicit\n+        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`,\n+        // `Self`, `&mut Self`,\n         // and `Box<Self>`, including the equivalent types with `Foo`.\n \n         let is_actually_self = |ty| is_self_ty(ty) || ty == self_ty;\n@@ -1404,18 +1459,22 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n             param.name == seg.name &&\n-            param.bounds.iter().any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n-                let path = &ptr.trait_ref.path;\n-                match_path_old(path, name) &&\n-                path.segments.last().map_or(false, |s| if let hir::PathParameters::AngleBracketedParameters(ref data) =\n-                    s.parameters {\n-                    data.types.len() == 1 && (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n-                } else {\n-                    false\n+                param.bounds.iter().any(|bound| {\n+                    if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                        let path = &ptr.trait_ref.path;\n+                        match_path_old(path, name) &&\n+                            path.segments.last().map_or(false, |s| {\n+                                if let hir::PathParameters::AngleBracketedParameters(ref data) = s.parameters {\n+                                    data.types.len() == 1 &&\n+                                        (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                    } else {\n+                        false\n+                    }\n                 })\n-            } else {\n-                false\n-            })\n         })\n     })\n }\n@@ -1424,7 +1483,9 @@ fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n     match (&ty.node, &self_ty.node) {\n         (&hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n          &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path))) => {\n-            ty_path.segments.iter().map(|seg| seg.name).eq(self_ty_path.segments.iter().map(|seg| seg.name))\n+            ty_path.segments.iter().map(|seg| seg.name).eq(\n+                self_ty_path.segments.iter().map(|seg| seg.name),\n+            )\n         },\n         _ => false,\n     }"}, {"sha": "67b0b1e167d332e3d0da571341f00f8434aca0b8", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 103, "deletions": 71, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -14,7 +14,8 @@ use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integ\n use utils::sugg::Sugg;\n use syntax::ast::{LitKind, CRATE_NODE_ID, FloatTy};\n \n-/// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n+/// **What it does:** Checks for function arguments and let bindings denoted as\n+/// `ref`.\n ///\n /// **Why is this bad?** The `ref` declaration makes the function take an owned\n /// value, but turns the argument into a reference (which means that the value\n@@ -118,7 +119,8 @@ declare_lint! {\n \n /// **What it does:** Checks for patterns in the form `name @ _`.\n ///\n-/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n+/// **Why is this bad?** It's almost always more readable to just use direct\n+/// bindings.\n ///\n /// **Known problems:** None.\n ///\n@@ -135,7 +137,8 @@ declare_lint! {\n     \"using `name @ _` in a pattern\"\n }\n \n-/// **What it does:** Checks for the use of bindings with a single leading underscore.\n+/// **What it does:** Checks for the use of bindings with a single leading\n+/// underscore.\n ///\n /// **Why is this bad?** A single leading underscore is usually used to indicate\n /// that a binding will not be used. Using such a binding breaks this\n@@ -147,7 +150,8 @@ declare_lint! {\n /// **Example:**\n /// ```rust\n /// let _x = 0;\n-/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n+/// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n+/// underscore.\n ///                 // We should rename `_x` to `x`\n /// ```\n declare_lint! {\n@@ -156,11 +160,14 @@ declare_lint! {\n     \"using a binding which is prefixed with an underscore\"\n }\n \n-/// **What it does:** Checks for the use of short circuit boolean conditions as a\n+/// **What it does:** Checks for the use of short circuit boolean conditions as\n+/// a\n /// statement.\n ///\n-/// **Why is this bad?** Using a short circuit boolean condition as a statement may\n-/// hide the fact that the second part is executed or not depending on the outcome of\n+/// **Why is this bad?** Using a short circuit boolean condition as a statement\n+/// may\n+/// hide the fact that the second part is executed or not depending on the\n+/// outcome of\n /// the first part.\n ///\n /// **Known problems:** None.\n@@ -198,15 +205,17 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOPLEVEL_REF_ARG,\n-                    CMP_NAN,\n-                    FLOAT_CMP,\n-                    CMP_OWNED,\n-                    MODULO_ONE,\n-                    REDUNDANT_PATTERN,\n-                    USED_UNDERSCORE_BINDING,\n-                    SHORT_CIRCUIT_STATEMENT,\n-                    ZERO_PTR)\n+        lint_array!(\n+            TOPLEVEL_REF_ARG,\n+            CMP_NAN,\n+            FLOAT_CMP,\n+            CMP_OWNED,\n+            MODULO_ONE,\n+            REDUNDANT_PATTERN,\n+            USED_UNDERSCORE_BINDING,\n+            SHORT_CIRCUIT_STATEMENT,\n+            ZERO_PTR\n+        )\n     }\n }\n \n@@ -218,7 +227,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId\n+        _: NodeId,\n     ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n@@ -228,11 +237,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             match arg.pat.node {\n                 PatKind::Binding(BindingAnnotation::Ref, _, _, _) |\n                 PatKind::Binding(BindingAnnotation::RefMut, _, _, _) => {\n-                    span_lint(cx,\n-                              TOPLEVEL_REF_ARG,\n-                              arg.pat.span,\n-                              \"`ref` directly on a function argument is ignored. Consider using a reference type \\\n-                               instead.\");\n+                    span_lint(\n+                        cx,\n+                        TOPLEVEL_REF_ARG,\n+                        arg.pat.span,\n+                        \"`ref` directly on a function argument is ignored. Consider using a reference type \\\n+                               instead.\",\n+                    );\n                 },\n                 _ => {},\n             }\n@@ -316,17 +327,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if let Some(name) = get_item_name(cx, expr) {\n                         let name = name.as_str();\n                         if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                           name.ends_with(\"_eq\") {\n+                            name.ends_with(\"_eq\")\n+                        {\n                             return;\n                         }\n                     }\n                     span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n                         let lhs = Sugg::hir(cx, left, \"..\");\n                         let rhs = Sugg::hir(cx, right, \"..\");\n \n-                        db.span_suggestion(expr.span,\n-                                           \"consider comparing them within some error\",\n-                                           format!(\"({}).abs() < error\", lhs - rhs));\n+                        db.span_suggestion(\n+                            expr.span,\n+                            \"consider comparing them within some error\",\n+                            format!(\"({}).abs() < error\", lhs - rhs),\n+                        );\n                         db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n                     });\n                 } else if op == BiRem && is_integer_literal(right, 1) {\n@@ -347,7 +361,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, &cx.tables.qpath_def(qpath, expr.id)) {\n+                    non_macro_local(cx, &cx.tables.qpath_def(qpath, expr.id))\n+                {\n                     Some(binding)\n                 } else {\n                     None\n@@ -364,22 +379,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             _ => None,\n         };\n         if let Some(binding) = binding {\n-            span_lint(cx,\n-                      USED_UNDERSCORE_BINDING,\n-                      expr.span,\n-                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+            span_lint(\n+                cx,\n+                USED_UNDERSCORE_BINDING,\n+                expr.span,\n+                &format!(\n+                    \"used binding `{}` which is prefixed with an underscore. A leading \\\n                                 underscore signals that a binding will not be used.\",\n-                               binding));\n+                    binding\n+                ),\n+            );\n         }\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n-                span_lint(cx,\n-                          REDUNDANT_PATTERN,\n-                          pat.span,\n-                          &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.node, ident.node));\n+                span_lint(\n+                    cx,\n+                    REDUNDANT_PATTERN,\n+                    pat.span,\n+                    &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.node, ident.node),\n+                );\n             }\n         }\n     }\n@@ -388,10 +409,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n         path.segments.last().map(|seg| if seg.name == \"NAN\" {\n-            span_lint(cx,\n-                      CMP_NAN,\n-                      expr.span,\n-                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+            span_lint(\n+                cx,\n+                CMP_NAN,\n+                expr.span,\n+                \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n+            );\n         });\n     }\n }\n@@ -421,7 +444,7 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n                 };\n \n                 val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                    val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n             },\n             FloatTy::F64 => {\n                 let zero = ConstFloat {\n@@ -440,7 +463,7 @@ fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n                 };\n \n                 val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                    val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n             },\n         }\n     } else {\n@@ -490,37 +513,43 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n         .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty]))\n         // arg impls PartialEq<other>\n-        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty]) {\n+        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty])\n+    {\n         return;\n     }\n \n-    span_lint_and_then(cx,\n-                       CMP_OWNED,\n-                       expr.span,\n-                       \"this creates an owned instance just for comparison\",\n-                       |db| {\n-        // this is as good as our recursion check can get, we can't prove that the current function is\n-        // called by\n-        // PartialEq::eq, but we can at least ensure that this code is not part of it\n-        let parent_fn = cx.tcx.hir.get_parent(expr.id);\n-        let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n-        if parent_impl != CRATE_NODE_ID {\n-            if let map::NodeItem(item) = cx.tcx.hir.get(parent_impl) {\n-                if let ItemImpl(.., Some(ref trait_ref), _, _) = item.node {\n-                    if trait_ref.path.def.def_id() == partial_eq_trait_id {\n-                        // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise we go into\n-                        // recursion\n-                        db.span_label(expr.span, \"try calling implementing the comparison without allocating\");\n-                        return;\n+    span_lint_and_then(\n+        cx,\n+        CMP_OWNED,\n+        expr.span,\n+        \"this creates an owned instance just for comparison\",\n+        |db| {\n+            // this is as good as our recursion check can get, we can't prove that the\n+            // current function is\n+            // called by\n+            // PartialEq::eq, but we can at least ensure that this code is not part of it\n+            let parent_fn = cx.tcx.hir.get_parent(expr.id);\n+            let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n+            if parent_impl != CRATE_NODE_ID {\n+                if let map::NodeItem(item) = cx.tcx.hir.get(parent_impl) {\n+                    if let ItemImpl(.., Some(ref trait_ref), _, _) = item.node {\n+                        if trait_ref.path.def.def_id() == partial_eq_trait_id {\n+                            // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise\n+                            // we go into\n+                            // recursion\n+                            db.span_label(expr.span, \"try calling implementing the comparison without allocating\");\n+                            return;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        db.span_suggestion(expr.span, \"try\", snip.to_string());\n-    });\n+            db.span_suggestion(expr.span, \"try\", snip.to_string());\n+        },\n+    );\n }\n \n-/// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n+/// Heuristic to see if an expression is used. Should be compatible with\n+/// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n@@ -534,21 +563,24 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     }\n }\n \n-/// Test whether an expression is in a macro expansion (e.g. something generated by\n+/// Test whether an expression is in a macro expansion (e.g. something\n+/// generated by\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n-    expr.span.ctxt.outer().expn_info().map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n+    expr.span.ctxt.outer().expn_info().map_or(\n+        false,\n+        |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)),\n+    )\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(def_id) |\n         def::Def::Upvar(def_id, _, _) => {\n-            let id = cx.tcx\n-                .hir\n-                .as_local_node_id(def_id)\n-                .expect(\"local variables should be found in the same crate\");\n+            let id = cx.tcx.hir.as_local_node_id(def_id).expect(\n+                \"local variables should be found in the same crate\",\n+            );\n             !in_macro(cx.tcx.hir.span(id))\n         },\n         _ => false,"}, {"sha": "52a97024e448f64e13b55e2c5982f8bff4aa4058", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 68, "deletions": 44, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -40,9 +40,11 @@ declare_lint! {\n     \"function arguments having names which only differ by an underscore\"\n }\n \n-/// **What it does:** Detects closures called in the same expression where they are defined.\n+/// **What it does:** Detects closures called in the same expression where they\n+/// are defined.\n ///\n-/// **Why is this bad?** It is unnecessarily adding to the expression's complexity.\n+/// **Why is this bad?** It is unnecessarily adding to the expression's\n+/// complexity.\n ///\n /// **Known problems:** None.\n ///\n@@ -73,7 +75,8 @@ declare_lint! {\n     \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n }\n \n-/// **What it does:** Warns on hexadecimal literals with mixed-case letter digits.\n+/// **What it does:** Warns on hexadecimal literals with mixed-case letter\n+/// digits.\n ///\n /// **Why is this bad?** It looks confusing.\n ///\n@@ -89,7 +92,8 @@ declare_lint! {\n     \"hex literals whose letter digits are not consistently upper- or lowercased\"\n }\n \n-/// **What it does:** Warns if literal suffixes are not separated by an underscore.\n+/// **What it does:** Warns if literal suffixes are not separated by an\n+/// underscore.\n ///\n /// **Why is this bad?** It is much less readable.\n ///\n@@ -107,8 +111,10 @@ declare_lint! {\n \n /// **What it does:** Warns if an integral constant literal starts with `0`.\n ///\n-/// **Why is this bad?** In some languages (including the infamous C language and most of its\n-/// family), this marks an octal constant. In Rust however, this is a decimal constant. This could\n+/// **Why is this bad?** In some languages (including the infamous C language\n+/// and most of its\n+/// family), this marks an octal constant. In Rust however, this is a decimal\n+/// constant. This could\n /// be confusing for both the writer and a reader of the constant.\n ///\n /// **Known problems:** None.\n@@ -167,14 +173,16 @@ pub struct MiscEarly;\n \n impl LintPass for MiscEarly {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNEEDED_FIELD_PATTERN,\n-                    DUPLICATE_UNDERSCORE_ARGUMENT,\n-                    REDUNDANT_CLOSURE_CALL,\n-                    DOUBLE_NEG,\n-                    MIXED_CASE_HEX_LITERALS,\n-                    UNSEPARATED_LITERAL_SUFFIX,\n-                    ZERO_PREFIXED_LITERAL,\n-                    BUILTIN_TYPE_SHADOW)\n+        lint_array!(\n+            UNNEEDED_FIELD_PATTERN,\n+            DUPLICATE_UNDERSCORE_ARGUMENT,\n+            REDUNDANT_CLOSURE_CALL,\n+            DOUBLE_NEG,\n+            MIXED_CASE_HEX_LITERALS,\n+            UNSEPARATED_LITERAL_SUFFIX,\n+            ZERO_PREFIXED_LITERAL,\n+            BUILTIN_TYPE_SHADOW\n+        )\n     }\n }\n \n@@ -183,30 +191,38 @@ impl EarlyLintPass for MiscEarly {\n         for ty in &gen.ty_params {\n             let name = ty.ident.name.as_str();\n             if constants::BUILTIN_TYPES.contains(&&*name) {\n-                span_lint(cx,\n-                          BUILTIN_TYPE_SHADOW,\n-                          ty.span,\n-                          &format!(\"This generic shadows the built-in type `{}`\", name));\n+                span_lint(\n+                    cx,\n+                    BUILTIN_TYPE_SHADOW,\n+                    ty.span,\n+                    &format!(\"This generic shadows the built-in type `{}`\", name),\n+                );\n             }\n         }\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext, pat: &Pat) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n-            let type_name = npat.segments.last().expect(\"A path must have at least one segment\").identifier.name;\n+            let type_name = npat.segments\n+                .last()\n+                .expect(\"A path must have at least one segment\")\n+                .identifier\n+                .name;\n \n             for field in pfields {\n                 if field.node.pat.node == PatKind::Wild {\n                     wilds += 1;\n                 }\n             }\n             if !pfields.is_empty() && wilds == pfields.len() {\n-                span_help_and_lint(cx,\n-                                   UNNEEDED_FIELD_PATTERN,\n-                                   pat.span,\n-                                   \"All the struct fields are matched to a wildcard pattern, consider using `..`.\",\n-                                   &format!(\"Try with `{} {{ .. }}` instead\", type_name));\n+                span_help_and_lint(\n+                    cx,\n+                    UNNEEDED_FIELD_PATTERN,\n+                    pat.span,\n+                    \"All the struct fields are matched to a wildcard pattern, consider using `..`.\",\n+                    &format!(\"Try with `{} {{ .. }}` instead\", type_name),\n+                );\n                 return;\n             }\n             if wilds > 0 {\n@@ -223,19 +239,21 @@ impl EarlyLintPass for MiscEarly {\n                     if field.node.pat.node == PatKind::Wild {\n                         wilds -= 1;\n                         if wilds > 0 {\n-                            span_lint(cx,\n-                                      UNNEEDED_FIELD_PATTERN,\n-                                      field.span,\n-                                      \"You matched a field with a wildcard pattern. Consider using `..` instead\");\n+                            span_lint(\n+                                cx,\n+                                UNNEEDED_FIELD_PATTERN,\n+                                field.span,\n+                                \"You matched a field with a wildcard pattern. Consider using `..` instead\",\n+                            );\n                         } else {\n-                            span_help_and_lint(cx,\n-                                               UNNEEDED_FIELD_PATTERN,\n-                                               field.span,\n-                                               \"You matched a field with a wildcard pattern. Consider using `..` \\\n+                            span_help_and_lint(\n+                                cx,\n+                                UNNEEDED_FIELD_PATTERN,\n+                                field.span,\n+                                \"You matched a field with a wildcard pattern. Consider using `..` \\\n                                                 instead\",\n-                                               &format!(\"Try with `{} {{ {}, .. }}`\",\n-                                                        type_name,\n-                                                        normal[..].join(\", \")));\n+                                &format!(\"Try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n+                            );\n                         }\n                     }\n                 }\n@@ -252,12 +270,16 @@ impl EarlyLintPass for MiscEarly {\n \n                 if arg_name.starts_with('_') {\n                     if let Some(correspondence) = registered_names.get(&arg_name[1..]) {\n-                        span_lint(cx,\n-                                  DUPLICATE_UNDERSCORE_ARGUMENT,\n-                                  *correspondence,\n-                                  &format!(\"`{}` already exists, having another argument having almost the same \\\n+                        span_lint(\n+                            cx,\n+                            DUPLICATE_UNDERSCORE_ARGUMENT,\n+                            *correspondence,\n+                            &format!(\n+                                \"`{}` already exists, having another argument having almost the same \\\n                                             name makes code comprehension and documentation more difficult\",\n-                                           arg_name[1..].to_owned()));;\n+                                arg_name[1..].to_owned()\n+                            ),\n+                        );;\n                     }\n                 } else {\n                     registered_names.insert(arg_name, arg.pat.span);\n@@ -287,10 +309,12 @@ impl EarlyLintPass for MiscEarly {\n             },\n             ExprKind::Unary(UnOp::Neg, ref inner) => {\n                 if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n-                    span_lint(cx,\n-                              DOUBLE_NEG,\n-                              expr.span,\n-                              \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\");\n+                    span_lint(\n+                        cx,\n+                        DOUBLE_NEG,\n+                        expr.span,\n+                        \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                    );\n                 }\n             },\n             ExprKind::Lit(ref lit) => self.check_lit(cx, lit),"}, {"sha": "17b3ad4d9e2b890f5609939f1cb51325e36b6703", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -11,12 +11,16 @@\n //   except according to those terms.\n //\n \n-// Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n+// Note: More specifically this lint is largely inspired (aka copied) from\n+// *rustc*'s\n // [`missing_doc`].\n //\n // [`missing_doc`]:\n // https://github.\n // com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.\n+// \n+//\n+//\n // rs#L246\n //\n \n@@ -28,10 +32,13 @@ use syntax::attr;\n use syntax::codemap::Span;\n use utils::in_macro;\n \n-/// **What it does:** Warns if there is missing doc for any documentable item (public or private).\n+/// **What it does:** Warns if there is missing doc for any documentable item\n+/// (public or private).\n ///\n-/// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS` allowed-by-default lint for\n-/// public members, but has no way to enforce documentation of private items. This lint fixes that.\n+/// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS`\n+/// allowed-by-default lint for\n+/// public members, but has no way to enforce documentation of private items.\n+/// This lint fixes that.\n ///\n /// **Known problems:** None.\n declare_lint! {\n@@ -58,7 +65,9 @@ impl MissingDoc {\n     }\n \n     fn doc_hidden(&self) -> bool {\n-        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n+        *self.doc_hidden_stack.last().expect(\n+            \"empty doc_hidden_stack\",\n+        )\n     }\n \n     fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n@@ -77,11 +86,15 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name().map_or(false, |n| n == \"doc\"));\n+        let has_doc = attrs.iter().any(|a| {\n+            a.is_value_str() && a.name().map_or(false, |n| n == \"doc\")\n+        });\n         if !has_doc {\n-            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS,\n-                         sp,\n-                         &format!(\"missing documentation for {}\", desc));\n+            cx.span_lint(\n+                MISSING_DOCS_IN_PRIVATE_ITEMS,\n+                sp,\n+                &format!(\"missing documentation for {}\", desc),\n+            );\n         }\n     }\n }\n@@ -95,13 +108,13 @@ impl LintPass for MissingDoc {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n-                         attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") &&\n-            match attr.meta_item_list() {\n-                None => false,\n-                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n-            }\n-        });\n+            attrs.iter().any(|attr| {\n+                attr.check_name(\"doc\") &&\n+                    match attr.meta_item_list() {\n+                        None => false,\n+                        Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n+                    }\n+            });\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n "}, {"sha": "e81330504758b5e9afba7c4ee37891173ad0f24d", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -22,7 +22,7 @@ declare_lint! {\n     \"usage of double-mut refs, e.g. `&mut &mut ...`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct MutMut;\n \n impl LintPass for MutMut {\n@@ -64,26 +64,37 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             intravisit::walk_expr(self, body);\n         } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n             if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n-                span_lint(self.cx,\n-                          MUT_MUT,\n-                          expr.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(\n+                    self.cx,\n+                    MUT_MUT,\n+                    expr.span,\n+                    \"generally you want to avoid `&mut &mut _` if possible\",\n+                );\n             } else if let ty::TyRef(_, ty::TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n-                span_lint(self.cx,\n-                          MUT_MUT,\n-                          expr.span,\n-                          \"this expression mutably borrows a mutable reference. Consider reborrowing\");\n+                span_lint(\n+                    self.cx,\n+                    MUT_MUT,\n+                    expr.span,\n+                    \"this expression mutably borrows a mutable reference. Consider reborrowing\",\n+                );\n             }\n         }\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n+        if let hir::TyRptr(_,\n+                           hir::MutTy {\n+                               ty: ref pty,\n+                               mutbl: hir::MutMutable,\n+                           }) = ty.node\n+        {\n             if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n-                span_lint(self.cx,\n-                          MUT_MUT,\n-                          ty.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\");\n+                span_lint(\n+                    self.cx,\n+                    MUT_MUT,\n+                    ty.span,\n+                    \"generally you want to avoid `&mut &mut _` if possible\",\n+                );\n             }\n \n         }"}, {"sha": "0c0c8f4061fa2e673bb6651de4e91258ab866381", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -24,7 +24,7 @@ declare_lint! {\n }\n \n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct UnnecessaryMutPassed;\n \n impl LintPass for UnnecessaryMutPassed {\n@@ -38,10 +38,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n                 if let ExprPath(ref path) = fn_expr.node {\n-                    check_arguments(cx,\n-                                    arguments,\n-                                    cx.tables.expr_ty(fn_expr),\n-                                    &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n+                    check_arguments(\n+                        cx,\n+                        arguments,\n+                        cx.tables.expr_ty(fn_expr),\n+                        &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n+                    );\n                 }\n             },\n             ExprMethodCall(ref path, _, ref arguments) => {\n@@ -64,10 +66,12 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n                     ty::TyRef(_, ty::TypeAndMut { mutbl: MutImmutable, .. }) |\n                     ty::TyRawPtr(ty::TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n-                            span_lint(cx,\n-                                      UNNECESSARY_MUT_PASSED,\n-                                      argument.span,\n-                                      &format!(\"The function/method `{}` doesn't need a mutable reference\", name));\n+                            span_lint(\n+                                cx,\n+                                UNNECESSARY_MUT_PASSED,\n+                                argument.span,\n+                                &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n+                            );\n                         }\n                     },\n                     _ => (),"}, {"sha": "25a7118ceda5a12f0374f97d9d7c8fda29d4a33d", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -28,9 +28,11 @@ declare_lint! {\n     \"using a mutex where an atomic value could be used instead\"\n }\n \n-/// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral type.\n+/// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral\n+/// type.\n ///\n-/// **Why is this bad?** Using a mutex just to make access to a plain integer sequential is\n+/// **Why is this bad?** Using a mutex just to make access to a plain integer\n+/// sequential is\n /// shooting flies with cannons. `std::atomic::usize` is leaner and faster.\n ///\n /// **Known problems:** This lint cannot detect if the mutex is actually used\n@@ -61,9 +63,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n             if match_type(cx, ty, &paths::MUTEX) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n-                    let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n+                    let msg = format!(\n+                        \"Consider using an {} instead of a Mutex here. If you just want the locking \\\n                                        behaviour and not the internal type, consider using Mutex<()>.\",\n-                                      atomic_name);\n+                        atomic_name\n+                    );\n                     match mutex_param.sty {\n                         ty::TyUint(t) if t != ast::UintTy::Us => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::TyInt(t) if t != ast::IntTy::Is => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),"}, {"sha": "52f0df12bcdcc850086890de66b091b81f7e8c8d", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -9,7 +9,8 @@ use syntax::codemap::Spanned;\n use utils::{span_lint, span_lint_and_sugg, snippet};\n use utils::sugg::Sugg;\n \n-/// **What it does:** Checks for expressions of the form `if c { true } else { false }`\n+/// **What it does:** Checks for expressions of the form `if c { true } else {\n+/// false }`\n /// (or vice versa) and suggest using the condition directly.\n ///\n /// **Why is this bad?** Redundant code.\n@@ -47,7 +48,7 @@ declare_lint! {\n     \"comparing a variable to a boolean, e.g. `if x == true`\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NeedlessBool;\n \n impl LintPass for NeedlessBool {\n@@ -70,28 +71,34 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     snip.to_string()\n                 };\n \n-                span_lint_and_sugg(cx,\n-                                   NEEDLESS_BOOL,\n-                                   e.span,\n-                                   \"this if-then-else expression returns a bool literal\",\n-                                   \"you can reduce it to\",\n-                                   hint);\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_BOOL,\n+                    e.span,\n+                    \"this if-then-else expression returns a bool literal\",\n+                    \"you can reduce it to\",\n+                    hint,\n+                );\n             };\n             if let ExprBlock(ref then_block) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) |\n                     (Bool(true), Bool(true)) => {\n-                        span_lint(cx,\n-                                  NEEDLESS_BOOL,\n-                                  e.span,\n-                                  \"this if-then-else expression will always return true\");\n+                        span_lint(\n+                            cx,\n+                            NEEDLESS_BOOL,\n+                            e.span,\n+                            \"this if-then-else expression will always return true\",\n+                        );\n                     },\n                     (RetBool(false), RetBool(false)) |\n                     (Bool(false), Bool(false)) => {\n-                        span_lint(cx,\n-                                  NEEDLESS_BOOL,\n-                                  e.span,\n-                                  \"this if-then-else expression will always return false\");\n+                        span_lint(\n+                            cx,\n+                            NEEDLESS_BOOL,\n+                            e.span,\n+                            \"this if-then-else expression will always return false\",\n+                        );\n                     },\n                     (RetBool(true), RetBool(false)) => reduce(true, false),\n                     (Bool(true), Bool(false)) => reduce(false, false),\n@@ -106,7 +113,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n     }\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct BoolComparison;\n \n impl LintPass for BoolComparison {\n@@ -122,39 +129,47 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n-                    span_lint_and_sugg(cx,\n-                                       BOOL_COMPARISON,\n-                                       e.span,\n-                                       \"equality checks against true are unnecessary\",\n-                                       \"try simplifying it as shown\",\n-                                       hint);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BOOL_COMPARISON,\n+                        e.span,\n+                        \"equality checks against true are unnecessary\",\n+                        \"try simplifying it as shown\",\n+                        hint,\n+                    );\n                 },\n                 (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n-                    span_lint_and_sugg(cx,\n-                                       BOOL_COMPARISON,\n-                                       e.span,\n-                                       \"equality checks against true are unnecessary\",\n-                                       \"try simplifying it as shown\",\n-                                       hint);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BOOL_COMPARISON,\n+                        e.span,\n+                        \"equality checks against true are unnecessary\",\n+                        \"try simplifying it as shown\",\n+                        hint,\n+                    );\n                 },\n                 (Bool(false), Other) => {\n                     let hint = Sugg::hir(cx, right_side, \"..\");\n-                    span_lint_and_sugg(cx,\n-                                       BOOL_COMPARISON,\n-                                       e.span,\n-                                       \"equality checks against false can be replaced by a negation\",\n-                                       \"try simplifying it as shown\",\n-                                       (!hint).to_string());\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BOOL_COMPARISON,\n+                        e.span,\n+                        \"equality checks against false can be replaced by a negation\",\n+                        \"try simplifying it as shown\",\n+                        (!hint).to_string(),\n+                    );\n                 },\n                 (Other, Bool(false)) => {\n                     let hint = Sugg::hir(cx, left_side, \"..\");\n-                    span_lint_and_sugg(cx,\n-                                       BOOL_COMPARISON,\n-                                       e.span,\n-                                       \"equality checks against false can be replaced by a negation\",\n-                                       \"try simplifying it as shown\",\n-                                       (!hint).to_string());\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BOOL_COMPARISON,\n+                        e.span,\n+                        \"equality checks against false can be replaced by a negation\",\n+                        \"try simplifying it as shown\",\n+                        (!hint).to_string(),\n+                    );\n                 },\n                 _ => (),\n             }"}, {"sha": "b331d6910a3bfa6ff56cc00ec81edaa35d7a4de2", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -26,7 +26,7 @@ declare_lint! {\n     \"taking a reference that is going to be automatically dereferenced\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NeedlessBorrow;\n \n impl LintPass for NeedlessBorrow {"}, {"sha": "6f81c8114149638ae883a624d98cdb81454a2d1d", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -9,7 +9,8 @@ use utils::{span_lint, in_macro};\n \n /// **What it does:** Checks for useless borrowed references.\n ///\n-/// **Why is this bad?** It is completely useless and make the code look more complex than it\n+/// **Why is this bad?** It is completely useless and make the code look more\n+/// complex than it\n /// actually is.\n ///\n /// **Known problems:** None.\n@@ -19,7 +20,8 @@ use utils::{span_lint, in_macro};\n ///     let mut v = Vec::<String>::new();\n ///     let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n /// ```\n-/// This clojure takes a reference on something that has been matched as a reference and\n+/// This clojure takes a reference on something that has been matched as a\n+/// reference and\n /// de-referenced.\n /// As such, it could just be |a| a.is_empty()\n declare_lint! {"}, {"sha": "692fa19f3ba14d245181323be689859b4928928c", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 69, "deletions": 56, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -99,7 +99,7 @@ declare_lint! {\n     \"`continue` statements that can be replaced by a rearrangement of code\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NeedlessContinue;\n \n impl LintPass for NeedlessContinue {\n@@ -116,59 +116,60 @@ impl EarlyLintPass for NeedlessContinue {\n     }\n }\n \n-/* This lint has to mainly deal with two cases of needless continue statements.\n- *\n- * Case 1 [Continue inside else block]:\n- *\n- *     loop {\n- *         // region A\n- *         if cond {\n- *             // region B\n- *         } else {\n- *             continue;\n- *         }\n- *         // region C\n- *     }\n- *\n- * This code can better be written as follows:\n- *\n- *     loop {\n- *         // region A\n- *         if cond {\n- *             // region B\n- *             // region C\n- *         }\n- *     }\n- *\n- * Case 2 [Continue inside then block]:\n- *\n- *     loop {\n- *       // region A\n- *       if cond {\n- *           continue;\n- *           // potentially more code here.\n- *       } else {\n- *           // region B\n- *       }\n- *       // region C\n- *     }\n- *\n- *\n- * This snippet can be refactored to:\n- *\n- *     loop {\n- *       // region A\n- *       if !cond {\n- *           // region B\n- *           // region C\n- *       }\n- *     }\n- * */\n+/* This lint has to mainly deal with two cases of needless continue\n+ * statements. */\n+// Case 1 [Continue inside else block]:\n+//\n+//     loop {\n+//         // region A\n+//         if cond {\n+//             // region B\n+//         } else {\n+//             continue;\n+//         }\n+//         // region C\n+//     }\n+//\n+// This code can better be written as follows:\n+//\n+//     loop {\n+//         // region A\n+//         if cond {\n+//             // region B\n+//             // region C\n+//         }\n+//     }\n+//\n+// Case 2 [Continue inside then block]:\n+//\n+//     loop {\n+//       // region A\n+//       if cond {\n+//           continue;\n+//           // potentially more code here.\n+//       } else {\n+//           // region B\n+//       }\n+//       // region C\n+//     }\n+//\n+//\n+// This snippet can be refactored to:\n+//\n+//     loop {\n+//       // region A\n+//       if !cond {\n+//           // region B\n+//           // region C\n+//       }\n+//     }\n+//\n \n /// Given an expression, returns true if either of the following is true\n ///\n /// - The expression is a `continue` node.\n-/// - The expression node is a block with the first statement being a `continue`.\n+/// - The expression node is a block with the first statement being a\n+/// `continue`.\n ///\n fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n     match else_expr.node {\n@@ -195,7 +196,8 @@ fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n /// If `expr` is a loop expression (while/while let/for/loop), calls `func` with\n /// the AST object representing the loop block of `expr`.\n fn with_loop_block<F>(expr: &ast::Expr, mut func: F)\n-    where F: FnMut(&ast::Block)\n+where\n+    F: FnMut(&ast::Block),\n {\n     match expr.node {\n         ast::ExprKind::While(_, ref loop_block, _) |\n@@ -206,7 +208,8 @@ fn with_loop_block<F>(expr: &ast::Expr, mut func: F)\n     }\n }\n \n-/// If `stmt` is an if expression node with an `else` branch, calls func with the\n+/// If `stmt` is an if expression node with an `else` branch, calls func with\n+/// the\n /// following:\n ///\n /// - The `if` expression itself,\n@@ -215,7 +218,8 @@ fn with_loop_block<F>(expr: &ast::Expr, mut func: F)\n /// - The `else` expression.\n ///\n fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n-    where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr)\n+where\n+    F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr),\n {\n     match stmt.node {\n         ast::StmtKind::Semi(ref e) |\n@@ -271,10 +275,18 @@ fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: L\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n         LintType::ContinueInsideElseBlock => {\n-            (suggestion_snippet_for_continue_inside_else(ctx, data, header), MSG_REDUNDANT_ELSE_BLOCK, data.else_expr)\n+            (\n+                suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+                MSG_REDUNDANT_ELSE_BLOCK,\n+                data.else_expr,\n+            )\n         },\n         LintType::ContinueInsideThenBlock => {\n-            (suggestion_snippet_for_continue_inside_if(ctx, data, header), MSG_ELSE_BLOCK_NOT_NEEDED, data.if_expr)\n+            (\n+                suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+                MSG_ELSE_BLOCK_NOT_NEEDED,\n+                data.if_expr,\n+            )\n         },\n     };\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n@@ -407,7 +419,8 @@ pub fn erode_from_front(s: &str) -> String {\n }\n \n /// If `s` contains the code for a block, delimited by braces, this function\n-/// tries to get the contents of the block. If there is no closing brace present,\n+/// tries to get the contents of the block. If there is no closing brace\n+/// present,\n /// an empty string is returned.\n pub fn erode_block(s: &str) -> String {\n     erode_from_back(&erode_from_front(s))"}, {"sha": "e4efaf495a895f43e327b6984f48bef4cc8627c7", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -13,10 +13,12 @@ use utils::{in_macro, is_self, is_copy, implements_trait, get_trait_def_id, matc\n             multispan_sugg, paths};\n use std::collections::{HashSet, HashMap};\n \n-/// **What it does:** Checks for functions taking arguments by value, but not consuming them in its\n+/// **What it does:** Checks for functions taking arguments by value, but not\n+/// consuming them in its\n /// body.\n ///\n-/// **Why is this bad?** Taking arguments by reference is more flexible and can sometimes avoid\n+/// **Why is this bad?** Taking arguments by reference is more flexible and can\n+/// sometimes avoid\n /// unnecessary allocations.\n ///\n /// **Known problems:** Hopefully none.\n@@ -53,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         span: Span,\n-        node_id: NodeId\n+        node_id: NodeId,\n     ) {\n         if in_macro(span) {\n             return;\n@@ -87,8 +89,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 .collect()\n         };\n \n-        // Collect moved variables and spans which will need dereferencings from the function body.\n-        let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n+        // Collect moved variables and spans which will need dereferencings from the\n+        // function body.\n+        let MovedVariablesCtxt {\n+            moved_vars,\n+            spans_need_deref,\n+            ..\n+        } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n             let region_maps = &cx.tcx.region_maps(fn_def_id);\n             euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n@@ -102,14 +109,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n             // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n             // This is needed due to the `Borrow<T> for T` blanket impl.\n-            let implements_borrow_trait = preds.iter()\n+            let implements_borrow_trait = preds\n+                .iter()\n                 .filter_map(|pred| if let ty::Predicate::Trait(ref poly_trait_ref) = *pred {\n                     Some(poly_trait_ref.skip_binder())\n                 } else {\n                     None\n                 })\n                 .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n-                .any(|tpred| tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n+                .any(|tpred| {\n+                    tpred.input_types().nth(1).expect(\n+                        \"Borrow trait must have an parameter\",\n+                    ) != ty\n+                });\n \n             if_let_chain! {[\n                 !is_self(arg),\n@@ -177,7 +189,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     moved_vars: HashSet<DefId>,\n-    /// Spans which need to be prefixed with `*` for dereferencing the suggested additional\n+    /// Spans which need to be prefixed with `*` for dereferencing the\n+    /// suggested additional\n     /// reference.\n     spans_need_deref: HashMap<DefId, HashSet<Span>>,\n }"}, {"sha": "d6624411e2f7ee9fb8a281ac14549eb7d8002287", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -36,10 +36,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n-                    span_lint(cx,\n-                              NEEDLESS_UPDATE,\n-                              base.span,\n-                              \"struct update has no effect, all the fields in the struct have already been specified\");\n+                    span_lint(\n+                        cx,\n+                        NEEDLESS_UPDATE,\n+                        base.span,\n+                        \"struct update has no effect, all the fields in the struct have already been specified\",\n+                    );\n                 }\n             }\n         }"}, {"sha": "c6bd91919f5b637ad5a5226db6a7fa832c1fb349", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -80,7 +80,7 @@ declare_lint! {\n     \"`fn new() -> Self` without `#[derive]`able `Default` implementation\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NewWithoutDefault;\n \n impl LintPass for NewWithoutDefault {\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n         decl: &'tcx hir::FnDecl,\n         _: &'tcx hir::Body,\n         span: Span,\n-        id: ast::NodeId\n+        id: ast::NodeId,\n     ) {\n         if in_external_macro(cx, span) {\n             return;\n@@ -109,13 +109,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 return;\n             }\n             if !sig.generics.ty_params.is_empty() {\n-                // when the result of `new()` depends on a type parameter we should not require an\n+                // when the result of `new()` depends on a type parameter we should not require\n+                // an\n                 // impl of `Default`\n                 return;\n             }\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n-                let self_ty = cx.tcx\n-                    .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n+                let self_ty = cx.tcx.type_of(\n+                    cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)),\n+                );\n                 if_let_chain!{[\n                     same_tys(cx, self_ty, return_ty(cx, id)),\n                     let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),"}, {"sha": "c57df468f7cd420a9d07e32509e0a73079336d80", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -62,10 +62,10 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         Expr_::ExprBox(ref inner) => has_no_effect(cx, inner),\n         Expr_::ExprStruct(_, ref fields, ref base) => {\n             fields.iter().all(|field| has_no_effect(cx, &field.expr)) &&\n-            match *base {\n-                Some(ref base) => has_no_effect(cx, base),\n-                None => true,\n-            }\n+                match *base {\n+                    Some(ref base) => has_no_effect(cx, base),\n+                    None => true,\n+                }\n         },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {\n@@ -83,11 +83,11 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         },\n         Expr_::ExprBlock(ref block) => {\n             block.stmts.is_empty() &&\n-            if let Some(ref expr) = block.expr {\n-                has_no_effect(cx, expr)\n-            } else {\n-                false\n-            }\n+                if let Some(ref expr) = block.expr {\n+                    has_no_effect(cx, expr)\n+                } else {\n+                    false\n+                }\n         },\n         _ => false,\n     }\n@@ -120,12 +120,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         return;\n                     }\n                 }\n-                span_lint_and_sugg(cx,\n-                                   UNNECESSARY_OPERATION,\n-                                   stmt.span,\n-                                   \"statement can be reduced\",\n-                                   \"replace it with\",\n-                                   snippet);\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_OPERATION,\n+                    stmt.span,\n+                    \"statement can be reduced\",\n+                    \"replace it with\",\n+                    snippet,\n+                );\n             }\n         }\n     }\n@@ -152,7 +154,14 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprAddrOf(_, ref inner) |\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n         Expr_::ExprStruct(_, ref fields, ref base) => {\n-            Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n+            Some(\n+                fields\n+                    .iter()\n+                    .map(|f| &f.expr)\n+                    .chain(base)\n+                    .map(Deref::deref)\n+                    .collect(),\n+            )\n         },\n         Expr_::ExprCall(ref callee, ref args) => {\n             if let Expr_::ExprPath(ref qpath) = callee.node {"}, {"sha": "fa915e83aed06ab79f1d8ea616f9e3f28f8a2d29", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 71, "deletions": 30, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -113,7 +113,13 @@ fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n             return true;\n         }\n         // *_name\n-        if interned_name.chars().rev().zip(name.chars().rev()).all(|(l, r)| l == r) {\n+        if interned_name.chars().rev().zip(name.chars().rev()).all(\n+            |(l,\n+              r)| {\n+                l == r\n+            },\n+        )\n+        {\n             return true;\n         }\n     }\n@@ -128,10 +134,12 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n         }\n         self.0.single_char_names.push(c);\n         if self.0.single_char_names.len() as u64 >= self.0.lint.single_char_binding_names_threshold {\n-            span_lint(self.0.cx,\n-                      MANY_SINGLE_CHAR_NAMES,\n-                      span,\n-                      &format!(\"{}th binding whose name is just one char\", self.0.single_char_names.len()));\n+            span_lint(\n+                self.0.cx,\n+                MANY_SINGLE_CHAR_NAMES,\n+                span,\n+                &format!(\"{}th binding whose name is just one char\", self.0.single_char_names.len()),\n+            );\n         }\n     }\n     fn check_name(&mut self, span: Span, name: Name) {\n@@ -166,54 +174,86 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             } else {\n                 let mut interned_chars = interned_name.chars();\n                 let mut existing_chars = existing_name.interned.chars();\n-                let first_i = interned_chars.next().expect(\"we know we have at least one char\");\n-                let first_e = existing_chars.next().expect(\"we know we have at least one char\");\n+                let first_i = interned_chars.next().expect(\n+                    \"we know we have at least one char\",\n+                );\n+                let first_e = existing_chars.next().expect(\n+                    \"we know we have at least one char\",\n+                );\n                 let eq_or_numeric = |a: char, b: char| a == b || a.is_numeric() && b.is_numeric();\n \n                 if eq_or_numeric(first_i, first_e) {\n-                    let last_i = interned_chars.next_back().expect(\"we know we have at least two chars\");\n-                    let last_e = existing_chars.next_back().expect(\"we know we have at least two chars\");\n+                    let last_i = interned_chars.next_back().expect(\n+                        \"we know we have at least two chars\",\n+                    );\n+                    let last_e = existing_chars.next_back().expect(\n+                        \"we know we have at least two chars\",\n+                    );\n                     if eq_or_numeric(last_i, last_e) {\n-                        if interned_chars.zip(existing_chars).filter(|&(i, e)| !eq_or_numeric(i, e)).count() != 1 {\n+                        if interned_chars\n+                            .zip(existing_chars)\n+                            .filter(|&(i, e)| !eq_or_numeric(i, e))\n+                            .count() != 1\n+                        {\n                             continue;\n                         }\n                     } else {\n-                        let second_last_i = interned_chars.next_back().expect(\"we know we have at least three chars\");\n-                        let second_last_e = existing_chars.next_back().expect(\"we know we have at least three chars\");\n+                        let second_last_i = interned_chars.next_back().expect(\n+                            \"we know we have at least three chars\",\n+                        );\n+                        let second_last_e = existing_chars.next_back().expect(\n+                            \"we know we have at least three chars\",\n+                        );\n                         if !eq_or_numeric(second_last_i, second_last_e) || second_last_i == '_' ||\n-                           !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                            !interned_chars.zip(existing_chars).all(|(i, e)| {\n+                                eq_or_numeric(i, e)\n+                            })\n+                        {\n                             // allowed similarity foo_x, foo_y\n                             // or too many chars differ (foo_x, boo_y) or (foox, booy)\n                             continue;\n                         }\n                         split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n                     }\n                 } else {\n-                    let second_i = interned_chars.next().expect(\"we know we have at least two chars\");\n-                    let second_e = existing_chars.next().expect(\"we know we have at least two chars\");\n+                    let second_i = interned_chars.next().expect(\n+                        \"we know we have at least two chars\",\n+                    );\n+                    let second_e = existing_chars.next().expect(\n+                        \"we know we have at least two chars\",\n+                    );\n                     if !eq_or_numeric(second_i, second_e) || second_i == '_' ||\n-                       !interned_chars.zip(existing_chars).all(|(i, e)| eq_or_numeric(i, e)) {\n+                        !interned_chars.zip(existing_chars).all(|(i, e)| {\n+                            eq_or_numeric(i, e)\n+                        })\n+                    {\n                         // allowed similarity x_foo, y_foo\n                         // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)\n                         continue;\n                     }\n                     split_at = interned_name.chars().next().map(|c| c.len_utf8());\n                 }\n             }\n-            span_lint_and_then(self.0.cx,\n-                               SIMILAR_NAMES,\n-                               span,\n-                               \"binding's name is too similar to existing binding\",\n-                               |diag| {\n-                diag.span_note(existing_name.span, \"existing binding defined here\");\n-                if let Some(split) = split_at {\n-                    diag.span_help(span,\n-                                   &format!(\"separate the discriminating character by an \\\n+            span_lint_and_then(\n+                self.0.cx,\n+                SIMILAR_NAMES,\n+                span,\n+                \"binding's name is too similar to existing binding\",\n+                |diag| {\n+                    diag.span_note(existing_name.span, \"existing binding defined here\");\n+                    if let Some(split) = split_at {\n+                        diag.span_help(\n+                            span,\n+                            &format!(\n+                                \"separate the discriminating character by an \\\n                                                                 underscore like: `{}_{}`\",\n-                                            &interned_name[..split],\n-                                            &interned_name[split..]));\n-                }\n-            });\n+                                &interned_name[..split],\n+                                &interned_name[split..]\n+                            ),\n+                        );\n+                    }\n+                },\n+            );\n             return;\n         }\n         self.0.names.push(ExistingName {\n@@ -241,7 +281,8 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         if let Some(ref init) = local.init {\n             self.apply(|this| walk_expr(this, &**init));\n         }\n-        // add the pattern after the expression because the bindings aren't available yet in the init\n+        // add the pattern after the expression because the bindings aren't available\n+        // yet in the init\n         // expression\n         SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n     }"}, {"sha": "ee55ea882b082a649a2240f6a2bd37586b30d315", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -4,7 +4,8 @@ use utils::{paths, method_chain_args, span_help_and_lint, match_type, snippet};\n \n /// **What it does:*** Checks for unnecessary `ok()` in if let.\n ///\n-/// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match on `Ok(pat)`\n+/// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n+/// on `Ok(pat)`\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "e67c1f4d1488ec1825abe1d84f7c2754d1f64a7e", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -23,7 +23,7 @@ declare_lint! {\n }\n \n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct NonSensical;\n \n impl LintPass for NonSensical {\n@@ -109,60 +109,71 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n     let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n         (false, false, false, false, false);\n-    // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n+    // This code is almost duplicated (oh, the irony), but I haven't found a way to\n+    // unify it.\n \n     for option in options {\n         match *option {\n             (OpenOption::Create, arg) => {\n                 if create {\n-                    span_lint(cx,\n-                              NONSENSICAL_OPEN_OPTIONS,\n-                              span,\n-                              \"the method \\\"create\\\" is called more than once\");\n+                    span_lint(\n+                        cx,\n+                        NONSENSICAL_OPEN_OPTIONS,\n+                        span,\n+                        \"the method \\\"create\\\" is called more than once\",\n+                    );\n                 } else {\n                     create = true\n                 }\n                 create_arg = create_arg || (arg == Argument::True);;\n             },\n             (OpenOption::Append, arg) => {\n                 if append {\n-                    span_lint(cx,\n-                              NONSENSICAL_OPEN_OPTIONS,\n-                              span,\n-                              \"the method \\\"append\\\" is called more than once\");\n+                    span_lint(\n+                        cx,\n+                        NONSENSICAL_OPEN_OPTIONS,\n+                        span,\n+                        \"the method \\\"append\\\" is called more than once\",\n+                    );\n                 } else {\n                     append = true\n                 }\n                 append_arg = append_arg || (arg == Argument::True);;\n             },\n             (OpenOption::Truncate, arg) => {\n                 if truncate {\n-                    span_lint(cx,\n-                              NONSENSICAL_OPEN_OPTIONS,\n-                              span,\n-                              \"the method \\\"truncate\\\" is called more than once\");\n+                    span_lint(\n+                        cx,\n+                        NONSENSICAL_OPEN_OPTIONS,\n+                        span,\n+                        \"the method \\\"truncate\\\" is called more than once\",\n+                    );\n                 } else {\n                     truncate = true\n                 }\n                 truncate_arg = truncate_arg || (arg == Argument::True);\n             },\n             (OpenOption::Read, arg) => {\n                 if read {\n-                    span_lint(cx,\n-                              NONSENSICAL_OPEN_OPTIONS,\n-                              span,\n-                              \"the method \\\"read\\\" is called more than once\");\n+                    span_lint(\n+                        cx,\n+                        NONSENSICAL_OPEN_OPTIONS,\n+                        span,\n+                        \"the method \\\"read\\\" is called more than once\",\n+                    );\n                 } else {\n                     read = true\n                 }\n                 read_arg = read_arg || (arg == Argument::True);;\n             },\n             (OpenOption::Write, arg) => {\n                 if write {\n-                    span_lint(cx,\n-                              NONSENSICAL_OPEN_OPTIONS,\n-                              span,\n-                              \"the method \\\"write\\\" is called more than once\");\n+                    span_lint(\n+                        cx,\n+                        NONSENSICAL_OPEN_OPTIONS,\n+                        span,\n+                        \"the method \\\"write\\\" is called more than once\",\n+                    );\n                 } else {\n                     write = true\n                 }\n@@ -175,9 +186,11 @@ fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span\n         span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"file opened with \\\"truncate\\\" and \\\"read\\\"\");\n     }\n     if append && truncate && append_arg && truncate_arg {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"file opened with \\\"append\\\" and \\\"truncate\\\"\");\n+        span_lint(\n+            cx,\n+            NONSENSICAL_OPEN_OPTIONS,\n+            span,\n+            \"file opened with \\\"append\\\" and \\\"truncate\\\"\",\n+        );\n     }\n }"}, {"sha": "f5a6833b4b02dc5c8fb255b43d4a0fcd03b8efb6", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -5,8 +5,10 @@ use utils::{span_lint_and_sugg, snippet};\n \n /// **What it does:** Checks for operations where precedence may be unclear\n /// and suggests to add parentheses. Currently it catches the following:\n-/// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n-/// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal)\n+/// * mixed usage of arithmetic and bit shifting/combining operators without\n+/// parentheses\n+/// * a \"negative\" numeric literal (which is really a unary `-` followed by a\n+/// numeric literal)\n ///   followed by a method call\n ///\n /// **Why is this bad?** Not everyone knows the precedence of those operators by\n@@ -24,7 +26,7 @@ declare_lint! {\n     \"operations where precedence may be unclear\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct Precedence;\n \n impl LintPass for Precedence {\n@@ -37,37 +39,45 @@ impl EarlyLintPass for Precedence {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprKind::Binary(Spanned { node: op, .. }, ref left, ref right) = expr.node {\n             let span_sugg = |expr: &Expr, sugg| {\n-                span_lint_and_sugg(cx,\n-                                   PRECEDENCE,\n-                                   expr.span,\n-                                   \"operator precedence can trip the unwary\",\n-                                   \"consider parenthesizing your expression\",\n-                                   sugg);\n+                span_lint_and_sugg(\n+                    cx,\n+                    PRECEDENCE,\n+                    expr.span,\n+                    \"operator precedence can trip the unwary\",\n+                    \"consider parenthesizing your expression\",\n+                    sugg,\n+                );\n             };\n \n             if !is_bit_op(op) {\n                 return;\n             }\n             match (is_arith_expr(left), is_arith_expr(right)) {\n                 (true, true) => {\n-                    let sugg = format!(\"({}) {} ({})\",\n-                                       snippet(cx, left.span, \"..\"),\n-                                       op.to_string(),\n-                                       snippet(cx, right.span, \"..\"));\n+                    let sugg = format!(\n+                        \"({}) {} ({})\",\n+                        snippet(cx, left.span, \"..\"),\n+                        op.to_string(),\n+                        snippet(cx, right.span, \"..\")\n+                    );\n                     span_sugg(expr, sugg);\n                 },\n                 (true, false) => {\n-                    let sugg = format!(\"({}) {} {}\",\n-                                       snippet(cx, left.span, \"..\"),\n-                                       op.to_string(),\n-                                       snippet(cx, right.span, \"..\"));\n+                    let sugg = format!(\n+                        \"({}) {} {}\",\n+                        snippet(cx, left.span, \"..\"),\n+                        op.to_string(),\n+                        snippet(cx, right.span, \"..\")\n+                    );\n                     span_sugg(expr, sugg);\n                 },\n                 (false, true) => {\n-                    let sugg = format!(\"{} {} ({})\",\n-                                       snippet(cx, left.span, \"..\"),\n-                                       op.to_string(),\n-                                       snippet(cx, right.span, \"..\"));\n+                    let sugg = format!(\n+                        \"{} {} ({})\",\n+                        snippet(cx, left.span, \"..\"),\n+                        op.to_string(),\n+                        snippet(cx, right.span, \"..\")\n+                    );\n                     span_sugg(expr, sugg);\n                 },\n                 (false, false) => (),\n@@ -82,12 +92,14 @@ impl EarlyLintPass for Precedence {\n                             LitKind::Int(..) |\n                             LitKind::Float(..) |\n                             LitKind::FloatUnsuffixed(..) => {\n-                                span_lint_and_sugg(cx,\n-                                                   PRECEDENCE,\n-                                                   expr.span,\n-                                                   \"unary minus has lower precedence than method call\",\n-                                                   \"consider adding parentheses to clarify your intent\",\n-                                                   format!(\"-({})\", snippet(cx, rhs.span, \"..\")));\n+                                span_lint_and_sugg(\n+                                    cx,\n+                                    PRECEDENCE,\n+                                    expr.span,\n+                                    \"unary minus has lower precedence than method call\",\n+                                    \"consider adding parentheses to clarify your intent\",\n+                                    format!(\"-({})\", snippet(cx, rhs.span, \"..\")),\n+                                );\n                             },\n                             _ => (),\n                         }"}, {"sha": "bf734cc9c0ea651a6a4679e4e119f697c70c99d9", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -5,10 +5,12 @@ use utils::paths;\n use utils::{is_expn_of, match_def_path, resolve_node, span_lint, match_path_old};\n use format::get_argument_fmtstr_parts;\n \n-/// **What it does:** This lint warns when you using `print!()` with a format string that\n+/// **What it does:** This lint warns when you using `print!()` with a format\n+/// string that\n /// ends in a newline.\n ///\n-/// **Why is this bad?** You should use `println!()` instead, which appends the newline.\n+/// **Why is this bad?** You should use `println!()` instead, which appends the\n+/// newline.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "5b5c63c1aca8053353b0ffb546dbb60ba48a88b0", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -9,11 +9,14 @@ use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n use utils::{match_path, match_type, paths, span_lint, span_lint_and_then};\n \n-/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless\n+/// **What it does:** This lint checks for function arguments of type `&String`\n+/// or `&Vec` unless\n /// the references are mutable.\n ///\n-/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less\n-/// useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be\n+/// **Why is this bad?** Requiring the argument to be of the specific size\n+/// makes the function less\n+/// useful for no benefit; slices in the form of `&[T]` or `&str` usually\n+/// suffice and can be\n /// obtained from other types, too.\n ///\n /// **Known problems:** None.\n@@ -31,7 +34,8 @@ declare_lint! {\n \n /// **What it does:** This lint checks for equality comparisons with `ptr::null`\n ///\n-/// **Why is this bad?** It's easier and more readable to use the inherent `.is_null()`\n+/// **Why is this bad?** It's easier and more readable to use the inherent\n+/// `.is_null()`\n /// method instead\n ///\n /// **Known problems:** None.\n@@ -46,15 +50,20 @@ declare_lint! {\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n }\n \n-/// **What it does:** This lint checks for functions that take immutable references and return\n+/// **What it does:** This lint checks for functions that take immutable\n+/// references and return\n /// mutable ones.\n ///\n-/// **Why is this bad?** This is trivially unsound, as one can create two mutable references\n-/// from the same (immutable!) source. This [error](https://github.com/rust-lang/rust/issues/39465)\n+/// **Why is this bad?** This is trivially unsound, as one can create two\n+/// mutable references\n+/// from the same (immutable!) source. This\n+/// [error](https://github.com/rust-lang/rust/issues/39465)\n /// actually lead to an interim Rust release 1.15.1.\n ///\n-/// **Known problems:** To be on the conservative side, if there's at least one mutable reference\n-/// with the output lifetime, this lint will not trigger. In practice, this case is unlikely anyway.\n+/// **Known problems:** To be on the conservative side, if there's at least one\n+/// mutable reference\n+/// with the output lifetime, this lint will not trigger. In practice, this\n+/// case is unlikely anyway.\n ///\n /// **Example:**\n /// ```rust\n@@ -66,7 +75,7 @@ declare_lint! {\n     \"fns that create mutable refs from immutable ref args\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct PointerPass;\n \n impl LintPass for PointerPass {\n@@ -102,10 +111,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n-                span_lint(cx,\n-                          CMP_NULL,\n-                          expr.span,\n-                          \"Comparing with null is better expressed by the .is_null() method\");\n+                span_lint(\n+                    cx,\n+                    CMP_NULL,\n+                    expr.span,\n+                    \"Comparing with null is better expressed by the .is_null() method\",\n+                );\n             }\n         }\n     }\n@@ -117,19 +128,28 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_ty = sig.skip_binder();\n \n     for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n-        if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n+        if let ty::TyRef(_,\n+                         ty::TypeAndMut {\n+                             ty,\n+                             mutbl: MutImmutable,\n+                         }) = ty.sty\n+        {\n             if match_type(cx, ty, &paths::VEC) {\n-                span_lint(cx,\n-                          PTR_ARG,\n-                          arg.span,\n-                          \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                           with non-Vec-based slices. Consider changing the type to `&[...]`\");\n+                span_lint(\n+                    cx,\n+                    PTR_ARG,\n+                    arg.span,\n+                    \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n+                           with non-Vec-based slices. Consider changing the type to `&[...]`\",\n+                );\n             } else if match_type(cx, ty, &paths::STRING) {\n-                span_lint(cx,\n-                          PTR_ARG,\n-                          arg.span,\n-                          \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n-                           Consider changing the type to `&str`\");\n+                span_lint(\n+                    cx,\n+                    PTR_ARG,\n+                    arg.span,\n+                    \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n+                           Consider changing the type to `&str`\",\n+                );\n             }\n         }\n     }\n@@ -138,10 +158,10 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n         if let Some((out, MutMutable, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n             for (_, ref mutbl, ref argspan) in\n-                decl.inputs\n-                    .iter()\n-                    .filter_map(|ty| get_rptr_lm(ty))\n-                    .filter(|&(lt, _, _)| lt.name == out.name) {\n+                decl.inputs.iter().filter_map(|ty| get_rptr_lm(ty)).filter(\n+                    |&(lt, _, _)| lt.name == out.name,\n+                )\n+            {\n                 if *mutbl == MutMutable {\n                     return;\n                 }"}, {"sha": "aa43fb6b620fcafb817beb717bab0586adf5e4b9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -21,7 +21,8 @@ declare_lint! {\n     \"using `Iterator::step_by(0)`, which produces an infinite iterator\"\n }\n \n-/// **What it does:** Checks for zipping a collection with the range of `0.._.len()`.\n+/// **What it does:** Checks for zipping a collection with the range of\n+/// `0.._.len()`.\n ///\n /// **Why is this bad?** The code is better expressed with `.enumerate()`.\n ///\n@@ -37,7 +38,7 @@ declare_lint! {\n     \"zipping iterator with a range when `enumerate()` would do\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct StepByZero;\n \n impl LintPass for StepByZero {\n@@ -57,10 +58,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                 use rustc_const_math::ConstInt::Usize;\n                 if let Some((Constant::Int(Usize(us)), _)) = constant(cx, &args[1]) {\n                     if us.as_u64(cx.sess().target.uint_type) == 0 {\n-                        span_lint(cx,\n-                                  ITERATOR_STEP_BY_ZERO,\n-                                  expr.span,\n-                                  \"Iterator::step_by(0) will panic at runtime\");\n+                        span_lint(\n+                            cx,\n+                            ITERATOR_STEP_BY_ZERO,\n+                            expr.span,\n+                            \"Iterator::step_by(0) will panic at runtime\",\n+                        );\n                     }\n                 }\n             } else if name == \"zip\" && args.len() == 2 {"}, {"sha": "a8360c71f912ad3e6d69736ed7f94a81c15a0873", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -40,12 +40,14 @@ impl EarlyLintPass for Pass {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n         if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node {\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node {\n-                span_lint_and_sugg(cx,\n-                                   DEREF_ADDROF,\n-                                   e.span,\n-                                   \"immediately dereferencing a reference\",\n-                                   \"try this\",\n-                                   format!(\"{}\", snippet(cx, addrof_target.span, \"_\")));\n+                span_lint_and_sugg(\n+                    cx,\n+                    DEREF_ADDROF,\n+                    e.span,\n+                    \"immediately dereferencing a reference\",\n+                    \"try this\",\n+                    format!(\"{}\", snippet(cx, addrof_target.span, \"_\")),\n+                );\n             }\n         }\n     }"}, {"sha": "4feeb6d09392ed2f69e6d5164da1830ddb7eb61f", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -178,7 +178,8 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n                 },\n                 3 => {\n                     if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) =\n-                        (&exprs[0], &exprs[1], &exprs[2]) {\n+                        (&exprs[0], &exprs[1], &exprs[2])\n+                    {\n                         Some(\"consider using `==` on `str`s\")\n                     } else {\n                         None\n@@ -211,37 +212,45 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n             match builder.parse(r) {\n                 Ok(r) => {\n                     if let Some(repl) = is_trivial_regex(&r) {\n-                        span_help_and_lint(cx,\n-                                           TRIVIAL_REGEX,\n-                                           expr.span,\n-                                           \"trivial regex\",\n-                                           &format!(\"consider using {}\", repl));\n+                        span_help_and_lint(\n+                            cx,\n+                            TRIVIAL_REGEX,\n+                            expr.span,\n+                            \"trivial regex\",\n+                            &format!(\"consider using {}\", repl),\n+                        );\n                     }\n                 },\n                 Err(e) => {\n-                    span_lint(cx,\n-                              INVALID_REGEX,\n-                              str_span(expr.span, r, e.position()),\n-                              &format!(\"regex syntax error: {}\", e.description()));\n+                    span_lint(\n+                        cx,\n+                        INVALID_REGEX,\n+                        str_span(expr.span, r, e.position()),\n+                        &format!(\"regex syntax error: {}\", e.description()),\n+                    );\n                 },\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n         match builder.parse(&r) {\n             Ok(r) => {\n                 if let Some(repl) = is_trivial_regex(&r) {\n-                    span_help_and_lint(cx,\n-                                       TRIVIAL_REGEX,\n-                                       expr.span,\n-                                       \"trivial regex\",\n-                                       &format!(\"consider using {}\", repl));\n+                    span_help_and_lint(\n+                        cx,\n+                        TRIVIAL_REGEX,\n+                        expr.span,\n+                        \"trivial regex\",\n+                        &format!(\"consider using {}\", repl),\n+                    );\n                 }\n             },\n             Err(e) => {\n-                span_lint(cx,\n-                          INVALID_REGEX,\n-                          expr.span,\n-                          &format!(\"regex syntax error on position {}: {}\", e.position(), e.description()));\n+                span_lint(\n+                    cx,\n+                    INVALID_REGEX,\n+                    expr.span,\n+                    &format!(\"regex syntax error on position {}: {}\", e.position(), e.description()),\n+                );\n             },\n         }\n     }"}, {"sha": "b9fcb62de73636d35c3dc7932521e63ebdf435f1", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -23,7 +23,8 @@ declare_lint! {\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-/// **What it does:** Checks for `let`-bindings, which are subsequently returned.\n+/// **What it does:** Checks for `let`-bindings, which are subsequently\n+/// returned.\n ///\n /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n /// more rusty.\n@@ -93,13 +94,11 @@ impl ReturnPass {\n         if in_external_macro(cx, inner_span) || in_macro(inner_span) {\n             return;\n         }\n-        span_lint_and_then(cx,\n-                           NEEDLESS_RETURN,\n-                           ret_span,\n-                           \"unneeded return statement\",\n-                           |db| if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                               db.span_suggestion(ret_span, \"remove `return` as shown\", snippet);\n-                           });\n+        span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded return statement\", |db| {\n+            if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                db.span_suggestion(ret_span, \"remove `return` as shown\", snippet);\n+            }\n+        });\n     }\n \n     // Check for \"let x = EXPR; x\""}, {"sha": "4feaaa192878c091cc9c6ebad7da6036bc126e0d", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -9,7 +9,8 @@ use utils::{span_lint, get_trait_def_id, paths};\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** Implementing `Visitor::visit_string` but not `Visitor::visit_str`.\n+/// **Example:** Implementing `Visitor::visit_string` but not\n+/// `Visitor::visit_str`.\n declare_lint! {\n     pub SERDE_API_MISUSE,\n     Warn,\n@@ -43,10 +44,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n                     }\n                     if let Some(span) = seen_string {\n                         if seen_str.is_none() {\n-                            span_lint(cx,\n-                                      SERDE_API_MISUSE,\n-                                      span,\n-                                      \"you should not implement `visit_string` without also implementing `visit_str`\");\n+                            span_lint(\n+                                cx,\n+                                SERDE_API_MISUSE,\n+                                span,\n+                                \"you should not implement `visit_string` without also implementing `visit_str`\",\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "e80636ca3479166fe763938302002803fb6ddf42", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         decl: &'tcx FnDecl,\n         body: &'tcx Body,\n         _: Span,\n-        _: NodeId\n+        _: NodeId,\n     ) {\n         if in_external_macro(cx, body.value.span) {\n             return;\n@@ -129,7 +129,13 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n         return;\n     }\n     if let DeclLocal(ref local) = decl.node {\n-        let Local { ref pat, ref ty, ref init, span, .. } = **local;\n+        let Local {\n+            ref pat,\n+            ref ty,\n+            ref init,\n+            span,\n+            ..\n+        } = **local;\n         if let Some(ref t) = *ty {\n             check_ty(cx, t, bindings)\n         }\n@@ -155,7 +161,7 @@ fn check_pat<'a, 'tcx>(\n     pat: &'tcx Pat,\n     init: Option<&'tcx Expr>,\n     span: Span,\n-    bindings: &mut Vec<(Name, Span)>\n+    bindings: &mut Vec<(Name, Span)>,\n ) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n@@ -184,9 +190,9 @@ fn check_pat<'a, 'tcx>(\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n-                        let efield = efields.iter()\n-                            .find(|f| f.name.node == name)\n-                            .map(|f| &*f.expr);\n+                        let efield = efields.iter().find(|f| f.name.node == name).map(\n+                            |f| &*f.expr,\n+                        );\n                         check_pat(cx, &field.node.pat, efield, span, bindings);\n                     }\n                 } else {\n@@ -240,39 +246,51 @@ fn lint_shadow<'a, 'tcx: 'a>(\n     span: Span,\n     pattern_span: Span,\n     init: Option<&'tcx Expr>,\n-    prev_span: Span\n+    prev_span: Span,\n ) {\n     if let Some(expr) = init {\n         if is_self_shadow(name, expr) {\n-            span_lint_and_then(cx,\n-                               SHADOW_SAME,\n-                               span,\n-                               &format!(\"`{}` is shadowed by itself in `{}`\",\n-                                        snippet(cx, pattern_span, \"_\"),\n-                                        snippet(cx, expr.span, \"..\")),\n-                               |db| { db.span_note(prev_span, \"previous binding is here\"); });\n+            span_lint_and_then(\n+                cx,\n+                SHADOW_SAME,\n+                span,\n+                &format!(\n+                    \"`{}` is shadowed by itself in `{}`\",\n+                    snippet(cx, pattern_span, \"_\"),\n+                    snippet(cx, expr.span, \"..\")\n+                ),\n+                |db| { db.span_note(prev_span, \"previous binding is here\"); },\n+            );\n         } else if contains_self(name, expr) {\n-            span_lint_and_then(cx,\n-                               SHADOW_REUSE,\n-                               pattern_span,\n-                               &format!(\"`{}` is shadowed by `{}` which reuses the original value\",\n-                                        snippet(cx, pattern_span, \"_\"),\n-                                        snippet(cx, expr.span, \"..\")),\n-                               |db| {\n-                db.span_note(expr.span, \"initialization happens here\");\n-                db.span_note(prev_span, \"previous binding is here\");\n-            });\n+            span_lint_and_then(\n+                cx,\n+                SHADOW_REUSE,\n+                pattern_span,\n+                &format!(\n+                    \"`{}` is shadowed by `{}` which reuses the original value\",\n+                    snippet(cx, pattern_span, \"_\"),\n+                    snippet(cx, expr.span, \"..\")\n+                ),\n+                |db| {\n+                    db.span_note(expr.span, \"initialization happens here\");\n+                    db.span_note(prev_span, \"previous binding is here\");\n+                },\n+            );\n         } else {\n-            span_lint_and_then(cx,\n-                               SHADOW_UNRELATED,\n-                               pattern_span,\n-                               &format!(\"`{}` is shadowed by `{}`\",\n-                                        snippet(cx, pattern_span, \"_\"),\n-                                        snippet(cx, expr.span, \"..\")),\n-                               |db| {\n-                db.span_note(expr.span, \"initialization happens here\");\n-                db.span_note(prev_span, \"previous binding is here\");\n-            });\n+            span_lint_and_then(\n+                cx,\n+                SHADOW_UNRELATED,\n+                pattern_span,\n+                &format!(\n+                    \"`{}` is shadowed by `{}`\",\n+                    snippet(cx, pattern_span, \"_\"),\n+                    snippet(cx, expr.span, \"..\")\n+                ),\n+                |db| {\n+                    db.span_note(expr.span, \"initialization happens here\");\n+                    db.span_note(prev_span, \"previous binding is here\");\n+                },\n+            );\n         }\n \n     } else {\n@@ -357,7 +375,11 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n         ExprBox(ref inner) |\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n+            block.stmts.is_empty() &&\n+                block.expr.as_ref().map_or(\n+                    false,\n+                    |e| is_self_shadow(name, e),\n+                )\n         },\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),"}, {"sha": "ecb2c9c31624fcd34c52327537ebce7c37f56dca", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -2,10 +2,12 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::{is_direct_expn_of, is_expn_of, implements_trait, span_lint};\n \n-/// **What it does:** Checks for `assert!(x == y)` or `assert!(x != y)` which can be better written\n+/// **What it does:** Checks for `assert!(x == y)` or `assert!(x != y)` which\n+/// can be better written\n /// using `assert_eq` or `assert_ne` if `x` and `y` implement `Debug` trait.\n ///\n-/// **Why is this bad?** `assert_eq` and `assert_ne` provide better assertion failure reporting.\n+/// **Why is this bad?** `assert_eq` and `assert_ne` provide better assertion\n+/// failure reporting.\n ///\n /// **Known problems:** Hopefully none.\n ///\n@@ -14,7 +16,8 @@ use utils::{is_direct_expn_of, is_expn_of, implements_trait, span_lint};\n /// let (x, y) = (1, 2);\n ///\n /// assert!(x == y);  // assertion failed: x == y\n-/// assert_eq!(x, y); // assertion failed: `(left == right)` (left: `1`, right: `2`)\n+/// assert_eq!(x, y); // assertion failed: `(left == right)` (left: `1`, right:\n+/// `2`)\n /// ```\n declare_lint! {\n     pub SHOULD_ASSERT_EQ,"}, {"sha": "9b61f902c492c90565e7395afe14870d49e7857a", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -96,18 +96,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                         }\n                     }\n                 }\n-                span_lint(cx,\n-                          STRING_ADD,\n-                          e.span,\n-                          \"you added something to a string. Consider using `String::push_str()` instead\");\n+                span_lint(\n+                    cx,\n+                    STRING_ADD,\n+                    e.span,\n+                    \"you added something to a string. Consider using `String::push_str()` instead\",\n+                );\n             }\n         } else if let ExprAssign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n-                span_lint(cx,\n-                          STRING_ADD_ASSIGN,\n-                          e.span,\n-                          \"you assigned the result of adding something to this string. Consider using \\\n-                           `String::push_str()` instead\");\n+                span_lint(\n+                    cx,\n+                    STRING_ADD_ASSIGN,\n+                    e.span,\n+                    \"you assigned the result of adding something to this string. Consider using \\\n+                           `String::push_str()` instead\",\n+                );\n             }\n         }\n     }\n@@ -121,7 +125,11 @@ fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n         ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n+            block.stmts.is_empty() &&\n+                block.expr.as_ref().map_or(\n+                    false,\n+                    |expr| is_add(cx, expr, target),\n+                )\n         },\n         _ => false,\n     }\n@@ -147,12 +155,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n-                            span_lint_and_sugg(cx,\n-                                               STRING_LIT_AS_BYTES,\n-                                               e.span,\n-                                               \"calling `as_bytes()` on a string literal\",\n-                                               \"consider using a byte string literal instead\",\n-                                               format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#)));\n+                            span_lint_and_sugg(\n+                                cx,\n+                                STRING_LIT_AS_BYTES,\n+                                e.span,\n+                                \"calling `as_bytes()` on a string literal\",\n+                                \"consider using a byte string literal instead\",\n+                                format!(\"b{}\", snippet(cx, args[0].span, r#\"\"foo\"\"#)),\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "e17170db192028c79534d8f7223bf931eb24f2be", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -41,7 +41,7 @@ declare_lint! {\n     \"`foo = bar; bar = foo` sequence\"\n }\n \n-#[derive(Copy,Clone)]\n+#[derive(Copy, Clone)]\n pub struct Swap;\n \n impl LintPass for Swap {"}, {"sha": "13555e3bb05249df611061c75c5375998ec72b0a", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -49,7 +49,8 @@ declare_lint! {\n ///\n /// **Example:**\n /// ```rust\n-/// core::intrinsics::transmute(t)` // where the result type is the same as `*t` or `&t`'s\n+/// core::intrinsics::transmute(t)` // where the result type is the same as\n+/// `*t` or `&t`'s\n /// ```\n declare_lint! {\n     pub CROSSPOINTER_TRANSMUTE,\n@@ -79,7 +80,7 @@ pub struct Transmute;\n \n impl LintPass for Transmute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array![CROSSPOINTER_TRANSMUTE, TRANSMUTE_PTR_TO_REF, USELESS_TRANSMUTE, WRONG_TRANSMUTE]\n+        lint_array!(CROSSPOINTER_TRANSMUTE, TRANSMUTE_PTR_TO_REF, USELESS_TRANSMUTE, WRONG_TRANSMUTE)\n     }\n }\n \n@@ -95,87 +96,101 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n \n                     match (&from_ty.sty, &to_ty.sty) {\n                         _ if from_ty == to_ty => {\n-                            span_lint(cx,\n-                                      USELESS_TRANSMUTE,\n-                                      e.span,\n-                                      &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n+                            span_lint(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+                            )\n                         },\n                         (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => {\n-                            span_lint_and_then(cx,\n-                                               USELESS_TRANSMUTE,\n-                                               e.span,\n-                                               \"transmute from a reference to a pointer\",\n-                                               |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                                   let sugg = if ptr_ty == rty {\n-                                                       arg.as_ty(to_ty)\n-                                                   } else {\n-                                                       arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n-                                                   };\n+                            span_lint_and_then(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                \"transmute from a reference to a pointer\",\n+                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                    let sugg = if ptr_ty == rty {\n+                                        arg.as_ty(to_ty)\n+                                    } else {\n+                                        arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n+                                    };\n \n-                                                   db.span_suggestion(e.span, \"try\", sugg.to_string());\n-                                               })\n+                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n+                                },\n+                            )\n                         },\n                         (&ty::TyInt(_), &ty::TyRawPtr(_)) |\n                         (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n-                            span_lint_and_then(cx,\n-                                               USELESS_TRANSMUTE,\n-                                               e.span,\n-                                               \"transmute from an integer to a pointer\",\n-                                               |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                                   db.span_suggestion(e.span,\n-                                                                      \"try\",\n-                                                                      arg.as_ty(&to_ty.to_string()).to_string());\n-                                               })\n+                            span_lint_and_then(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                \"transmute from an integer to a pointer\",\n+                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                    db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n+                                },\n+                            )\n                         },\n                         (&ty::TyFloat(_), &ty::TyRef(..)) |\n                         (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n                         (&ty::TyChar, &ty::TyRef(..)) |\n                         (&ty::TyChar, &ty::TyRawPtr(_)) => {\n-                            span_lint(cx,\n-                                      WRONG_TRANSMUTE,\n-                                      e.span,\n-                                      &format!(\"transmute from a `{}` to a pointer\", from_ty))\n+                            span_lint(\n+                                cx,\n+                                WRONG_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+                            )\n                         },\n                         (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n-                            span_lint(cx,\n-                                      CROSSPOINTER_TRANSMUTE,\n-                                      e.span,\n-                                      &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                               from_ty,\n-                                               to_ty))\n+                            span_lint(\n+                                cx,\n+                                CROSSPOINTER_TRANSMUTE,\n+                                e.span,\n+                                &format!(\n+                                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                    from_ty,\n+                                    to_ty\n+                                ),\n+                            )\n                         },\n                         (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n-                            span_lint(cx,\n-                                      CROSSPOINTER_TRANSMUTE,\n-                                      e.span,\n-                                      &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                                               from_ty,\n-                                               to_ty))\n+                            span_lint(\n+                                cx,\n+                                CROSSPOINTER_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n+                            )\n                         },\n                         (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => {\n-                            span_lint_and_then(cx,\n-                                               TRANSMUTE_PTR_TO_REF,\n-                                               e.span,\n-                                               &format!(\"transmute from a pointer type (`{}`) to a reference type \\\n+                            span_lint_and_then(\n+                                cx,\n+                                TRANSMUTE_PTR_TO_REF,\n+                                e.span,\n+                                &format!(\n+                                    \"transmute from a pointer type (`{}`) to a reference type \\\n                                                          (`{}`)\",\n-                                                        from_ty,\n-                                                        to_ty),\n-                                               |db| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n-                                    (\"&mut *\", \"*mut\")\n-                                } else {\n-                                    (\"&*\", \"*const\")\n-                                };\n+                                    from_ty,\n+                                    to_ty\n+                                ),\n+                                |db| {\n+                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                                        (\"&mut *\", \"*mut\")\n+                                    } else {\n+                                        (\"&*\", \"*const\")\n+                                    };\n \n-                                let arg = if from_pty.ty == to_rty.ty {\n-                                    arg\n-                                } else {\n-                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n-                                };\n+                                    let arg = if from_pty.ty == to_rty.ty {\n+                                        arg\n+                                    } else {\n+                                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n+                                    };\n \n-                                db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n-                            })\n+                                    db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n+                                },\n+                            )\n                         },\n                         _ => return,\n                     };\n@@ -185,8 +200,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     }\n }\n \n-/// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n-/// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n+/// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// not available , use\n+/// the type's `ToString` implementation. In weird cases it could lead to types\n+/// with invalid `'_`\n /// lifetime, but it should be rare.\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);"}, {"sha": "44e33d40a38764c11566139b215cc2b80883bfa3", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 237, "deletions": 178, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -42,14 +42,21 @@ declare_lint! {\n ///\n /// **Why is this bad?** Gankro says:\n ///\n-/// > The TL;DR of `LinkedList` is that it's built on a massive amount of pointers and indirection.\n-/// > It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while\n-/// > \"only\" amortized for push/pop, should be faster in the general case for almost every possible\n-/// > workload, and isn't even amortized at all if you can predict the capacity you need.\n+/// > The TL;DR of `LinkedList` is that it's built on a massive amount of\n+/// pointers and indirection.\n+/// > It wastes memory, it has terrible cache locality, and is all-around slow.\n+/// `RingBuf`, while\n+/// > \"only\" amortized for push/pop, should be faster in the general case for\n+/// almost every possible\n+/// > workload, and isn't even amortized at all if you can predict the capacity\n+/// you need.\n /// >\n-/// > `LinkedList`s are only really good if you're doing a lot of merging or splitting of lists.\n-/// > This is because they can just mangle some pointers instead of actually copying the data. Even\n-/// > if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better\n+/// > `LinkedList`s are only really good if you're doing a lot of merging or\n+/// splitting of lists.\n+/// > This is because they can just mangle some pointers instead of actually\n+/// copying the data. Even\n+/// > if you're doing a lot of insertion in the middle of the list, `RingBuf`\n+/// can still be better\n /// > because of how expensive it is to seek to the middle of a `LinkedList`.\n ///\n /// **Known problems:** False positives \u2013 the instances where using a\n@@ -68,7 +75,8 @@ declare_lint! {\n \n /// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n ///\n-/// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more general.\n+/// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more\n+/// general.\n ///\n /// **Known problems:** None.\n ///\n@@ -161,11 +169,13 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                         return; // don't recurse into the type\n                     }}\n                 } else if match_def_path(cx.tcx, def_id, &paths::LINKED_LIST) {\n-                    span_help_and_lint(cx,\n-                                       LINKEDLIST,\n-                                       ast_ty.span,\n-                                       \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                       \"a VecDeque might work\");\n+                    span_help_and_lint(\n+                        cx,\n+                        LINKEDLIST,\n+                        ast_ty.span,\n+                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                        \"a VecDeque might work\",\n+                    );\n                     return; // don't recurse into the type\n                 }\n             }\n@@ -268,11 +278,15 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n                 if higher::is_from_for_desugar(decl) {\n                     return;\n                 }\n-                span_lint(cx,\n-                          LET_UNIT_VALUE,\n-                          decl.span,\n-                          &format!(\"this let-binding has unit value. Consider omitting `let {} =`\",\n-                                   snippet(cx, local.pat.span, \"..\")));\n+                span_lint(\n+                    cx,\n+                    LET_UNIT_VALUE,\n+                    decl.span,\n+                    &format!(\n+                        \"this let-binding has unit value. Consider omitting `let {} =`\",\n+                        snippet(cx, local.pat.span, \"..\")\n+                    ),\n+                );\n             },\n             _ => (),\n         }\n@@ -336,12 +350,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n                             BiEq | BiLe | BiGe => \"true\",\n                             _ => \"false\",\n                         };\n-                        span_lint(cx,\n-                                  UNIT_CMP,\n-                                  expr.span,\n-                                  &format!(\"{}-comparison of unit values detected. This will always be {}\",\n-                                           op.as_str(),\n-                                           result));\n+                        span_lint(\n+                            cx,\n+                            UNIT_CMP,\n+                            expr.span,\n+                            &format!(\n+                                \"{}-comparison of unit values detected. This will always be {}\",\n+                                op.as_str(),\n+                                result\n+                            ),\n+                        );\n                     },\n                     _ => (),\n                 }\n@@ -493,20 +511,24 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n     } else {\n         int_ty_to_nbits(cast_from).to_string()\n     };\n-    span_lint(cx,\n-              CAST_PRECISION_LOSS,\n-              expr.span,\n-              &format!(\"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n+    span_lint(\n+        cx,\n+        CAST_PRECISION_LOSS,\n+        expr.span,\n+        &format!(\n+            \"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n                         is only {4} bits wide)\",\n-                       cast_from,\n-                       if cast_to_f64 { \"f64\" } else { \"f32\" },\n-                       if arch_dependent {\n-                           arch_dependent_str\n-                       } else {\n-                           \"\"\n-                       },\n-                       from_nbits_str,\n-                       mantissa_nbits));\n+            cast_from,\n+            if cast_to_f64 { \"f64\" } else { \"f32\" },\n+            if arch_dependent {\n+                arch_dependent_str\n+            } else {\n+                \"\"\n+            },\n+            from_nbits_str,\n+            mantissa_nbits\n+        ),\n+    );\n }\n \n enum ArchSuffix {\n@@ -520,70 +542,86 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, c\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n     let (from_nbits, to_nbits) = (int_ty_to_nbits(cast_from), int_ty_to_nbits(cast_to));\n-    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) = match (is_isize_or_usize(cast_from),\n-                                                                              is_isize_or_usize(cast_to)) {\n-        (true, true) | (false, false) => {\n-            (to_nbits < from_nbits,\n-             ArchSuffix::None,\n-             to_nbits == from_nbits && cast_unsigned_to_signed,\n-             ArchSuffix::None)\n-        },\n-        (true, false) => {\n-            (to_nbits <= 32,\n-             if to_nbits == 32 {\n-                 ArchSuffix::_64\n-             } else {\n-                 ArchSuffix::None\n-             },\n-             to_nbits <= 32 && cast_unsigned_to_signed,\n-             ArchSuffix::_32)\n-        },\n-        (false, true) => {\n-            (from_nbits == 64,\n-             ArchSuffix::_32,\n-             cast_unsigned_to_signed,\n-             if from_nbits == 64 {\n-                 ArchSuffix::_64\n-             } else {\n-                 ArchSuffix::_32\n-             })\n-        },\n-    };\n+    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n+        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+            (true, true) | (false, false) => {\n+                (\n+                    to_nbits < from_nbits,\n+                    ArchSuffix::None,\n+                    to_nbits == from_nbits && cast_unsigned_to_signed,\n+                    ArchSuffix::None,\n+                )\n+            },\n+            (true, false) => {\n+                (\n+                    to_nbits <= 32,\n+                    if to_nbits == 32 {\n+                        ArchSuffix::_64\n+                    } else {\n+                        ArchSuffix::None\n+                    },\n+                    to_nbits <= 32 && cast_unsigned_to_signed,\n+                    ArchSuffix::_32,\n+                )\n+            },\n+            (false, true) => {\n+                (\n+                    from_nbits == 64,\n+                    ArchSuffix::_32,\n+                    cast_unsigned_to_signed,\n+                    if from_nbits == 64 {\n+                        ArchSuffix::_64\n+                    } else {\n+                        ArchSuffix::_32\n+                    },\n+                )\n+            },\n+        };\n     if span_truncation {\n-        span_lint(cx,\n-                  CAST_POSSIBLE_TRUNCATION,\n-                  expr.span,\n-                  &format!(\"casting {} to {} may truncate the value{}\",\n-                           cast_from,\n-                           cast_to,\n-                           match suffix_truncation {\n-                               ArchSuffix::_32 => arch_32_suffix,\n-                               ArchSuffix::_64 => arch_64_suffix,\n-                               ArchSuffix::None => \"\",\n-                           }));\n+        span_lint(\n+            cx,\n+            CAST_POSSIBLE_TRUNCATION,\n+            expr.span,\n+            &format!(\n+                \"casting {} to {} may truncate the value{}\",\n+                cast_from,\n+                cast_to,\n+                match suffix_truncation {\n+                    ArchSuffix::_32 => arch_32_suffix,\n+                    ArchSuffix::_64 => arch_64_suffix,\n+                    ArchSuffix::None => \"\",\n+                }\n+            ),\n+        );\n     }\n     if span_wrap {\n-        span_lint(cx,\n-                  CAST_POSSIBLE_WRAP,\n-                  expr.span,\n-                  &format!(\"casting {} to {} may wrap around the value{}\",\n-                           cast_from,\n-                           cast_to,\n-                           match suffix_wrap {\n-                               ArchSuffix::_32 => arch_32_suffix,\n-                               ArchSuffix::_64 => arch_64_suffix,\n-                               ArchSuffix::None => \"\",\n-                           }));\n+        span_lint(\n+            cx,\n+            CAST_POSSIBLE_WRAP,\n+            expr.span,\n+            &format!(\n+                \"casting {} to {} may wrap around the value{}\",\n+                cast_from,\n+                cast_to,\n+                match suffix_wrap {\n+                    ArchSuffix::_32 => arch_32_suffix,\n+                    ArchSuffix::_64 => arch_64_suffix,\n+                    ArchSuffix::None => \"\",\n+                }\n+            ),\n+        );\n     }\n }\n \n impl LintPass for CastPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(CAST_PRECISION_LOSS,\n-                    CAST_SIGN_LOSS,\n-                    CAST_POSSIBLE_TRUNCATION,\n-                    CAST_POSSIBLE_WRAP,\n-                    UNNECESSARY_CAST)\n+        lint_array!(\n+            CAST_PRECISION_LOSS,\n+            CAST_SIGN_LOSS,\n+            CAST_POSSIBLE_TRUNCATION,\n+            CAST_POSSIBLE_WRAP,\n+            UNNECESSARY_CAST\n+        )\n     }\n }\n \n@@ -598,12 +636,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                     LitKind::FloatUnsuffixed(_) => {},\n                     _ => {\n                         if cast_from.sty == cast_to.sty && !in_external_macro(cx, expr.span) {\n-                            span_lint(cx,\n-                                      UNNECESSARY_CAST,\n-                                      expr.span,\n-                                      &format!(\"casting to the same type is unnecessary (`{}` -> `{}`)\",\n-                                               cast_from,\n-                                               cast_to));\n+                            span_lint(\n+                                cx,\n+                                UNNECESSARY_CAST,\n+                                expr.span,\n+                                &format!(\"casting to the same type is unnecessary (`{}` -> `{}`)\", cast_from, cast_to),\n+                            );\n                         }\n                     },\n                 }\n@@ -622,33 +660,42 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                         }\n                     },\n                     (false, true) => {\n-                        span_lint(cx,\n-                                  CAST_POSSIBLE_TRUNCATION,\n-                                  expr.span,\n-                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n+                        span_lint(\n+                            cx,\n+                            CAST_POSSIBLE_TRUNCATION,\n+                            expr.span,\n+                            &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to),\n+                        );\n                         if !cast_to.is_signed() {\n-                            span_lint(cx,\n-                                      CAST_SIGN_LOSS,\n-                                      expr.span,\n-                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                            span_lint(\n+                                cx,\n+                                CAST_SIGN_LOSS,\n+                                expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to),\n+                            );\n                         }\n                     },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n-                            span_lint(cx,\n-                                      CAST_SIGN_LOSS,\n-                                      expr.span,\n-                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n+                            span_lint(\n+                                cx,\n+                                CAST_SIGN_LOSS,\n+                                expr.span,\n+                                &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to),\n+                            );\n                         }\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     },\n                     (false, false) => {\n                         if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) =\n-                            (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(cx,\n-                                      CAST_POSSIBLE_TRUNCATION,\n-                                      expr.span,\n-                                      \"casting f64 to f32 may truncate the value\");\n+                            (&cast_from.sty, &cast_to.sty)\n+                        {\n+                            span_lint(\n+                                cx,\n+                                CAST_POSSIBLE_TRUNCATION,\n+                                expr.span,\n+                                \"casting f64 to f32 may truncate the value\",\n+                            );\n                         }\n                     },\n                 }\n@@ -700,7 +747,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         decl: &'tcx FnDecl,\n         _: &'tcx Body,\n         _: Span,\n-        _: NodeId\n+        _: NodeId,\n     ) {\n         self.check_fndecl(cx, decl);\n     }\n@@ -760,19 +807,18 @@ impl<'a, 'tcx> TypeComplexityPass {\n             return;\n         }\n         let score = {\n-            let mut visitor = TypeComplexityVisitor {\n-                score: 0,\n-                nest: 1,\n-            };\n+            let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n             visitor.visit_ty(ty);\n             visitor.score\n         };\n \n         if score > self.threshold {\n-            span_lint(cx,\n-                      TYPE_COMPLEXITY,\n-                      ty.span,\n-                      \"very complex type used. Consider factoring parts into `type` definitions\");\n+            span_lint(\n+                cx,\n+                TYPE_COMPLEXITY,\n+                ty.span,\n+                \"very complex type used. Consider factoring parts into `type` definitions\",\n+            );\n         }\n     }\n }\n@@ -798,8 +844,9 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyBareFn(..) => (50 * self.nest, 1),\n \n             TyTraitObject(ref param_bounds, _) => {\n-                let has_lifetime_parameters = param_bounds.iter()\n-                    .any(|bound| !bound.bound_lifetimes.is_empty());\n+                let has_lifetime_parameters = param_bounds.iter().any(\n+                    |bound| !bound.bound_lifetimes.is_empty(),\n+                );\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>\n                     (50 * self.nest, 1)\n@@ -922,7 +969,7 @@ fn detect_absurd_comparison<'a>(\n     cx: &LateContext,\n     op: BinOp_,\n     lhs: &'a Expr,\n-    rhs: &'a Expr\n+    rhs: &'a Expr,\n ) -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n     use types::ExtremeType::*;\n     use types::AbsurdComparisonResult::*;\n@@ -1042,20 +1089,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n                         AlwaysFalse => \"this comparison is always false\".to_owned(),\n                         AlwaysTrue => \"this comparison is always true\".to_owned(),\n                         InequalityImpossible => {\n-                            format!(\"the case where the two sides are not equal never occurs, consider using {} == {} \\\n+                            format!(\n+                                \"the case where the two sides are not equal never occurs, consider using {} == {} \\\n                                      instead\",\n-                                    snippet(cx, lhs.span, \"lhs\"),\n-                                    snippet(cx, rhs.span, \"rhs\"))\n+                                snippet(cx, lhs.span, \"lhs\"),\n+                                snippet(cx, rhs.span, \"rhs\")\n+                            )\n                         },\n                     };\n \n-                    let help = format!(\"because {} is the {} value for this type, {}\",\n-                                       snippet(cx, culprit.expr.span, \"x\"),\n-                                       match culprit.which {\n-                                           Minimum => \"minimum\",\n-                                           Maximum => \"maximum\",\n-                                       },\n-                                       conclusion);\n+                    let help = format!(\n+                        \"because {} is the {} value for this type, {}\",\n+                        snippet(cx, culprit.expr.span, \"x\"),\n+                        match culprit.which {\n+                            Minimum => \"minimum\",\n+                            Maximum => \"maximum\",\n+                        },\n+                        conclusion\n+                    );\n \n                     span_help_and_lint(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, &help);\n                 }\n@@ -1113,7 +1164,9 @@ impl FullInt {\n \n impl PartialEq for FullInt {\n     fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n+        self.partial_cmp(other).expect(\n+            \"partial_cmp only returns Some(_)\",\n+        ) == Ordering::Equal\n     }\n }\n \n@@ -1129,7 +1182,9 @@ impl PartialOrd for FullInt {\n }\n impl Ord for FullInt {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other).expect(\"partial_cmp for FullInt can never return None\")\n+        self.partial_cmp(other).expect(\n+            \"partial_cmp for FullInt can never return None\",\n+        )\n     }\n }\n \n@@ -1198,14 +1253,16 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n \n fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n     if let ExprCast(ref cast_val, _) = expr.node {\n-        span_lint(cx,\n-                  INVALID_UPCAST_COMPARISONS,\n-                  *span,\n-                  &format!(\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            *span,\n+            &format!(\n                 \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n                 snippet(cx, cast_val.span, \"the expression\"),\n                 if always { \"true\" } else { \"false\" },\n-            ));\n+            ),\n+        );\n     }\n }\n \n@@ -1216,7 +1273,7 @@ fn upcast_comparison_bounds_err(\n     lhs_bounds: Option<(FullInt, FullInt)>,\n     lhs: &Expr,\n     rhs: &Expr,\n-    invert: bool\n+    invert: bool,\n ) {\n     use utils::comparisons::*;\n \n@@ -1227,40 +1284,42 @@ fn upcast_comparison_bounds_err(\n                     err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n                 }\n             } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val < lb\n-                    } else {\n-                        ub < norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val <= lb\n-                    } else {\n-                        ub <= norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n+                       Rel::Lt => {\n+                           if invert {\n+                               norm_rhs_val < lb\n+                           } else {\n+                               ub < norm_rhs_val\n+                           }\n+                       },\n+                       Rel::Le => {\n+                           if invert {\n+                               norm_rhs_val <= lb\n+                           } else {\n+                               ub <= norm_rhs_val\n+                           }\n+                       },\n+                       Rel::Eq | Rel::Ne => unreachable!(),\n+                   }\n+            {\n                 err_upcast_comparison(cx, span, lhs, true)\n             } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val >= ub\n-                    } else {\n-                        lb >= norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val > ub\n-                    } else {\n-                        lb > norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n+                       Rel::Lt => {\n+                           if invert {\n+                               norm_rhs_val >= ub\n+                           } else {\n+                               lb >= norm_rhs_val\n+                           }\n+                       },\n+                       Rel::Le => {\n+                           if invert {\n+                               norm_rhs_val > ub\n+                           } else {\n+                               lb > norm_rhs_val\n+                           }\n+                       },\n+                       Rel::Eq | Rel::Ne => unreachable!(),\n+                   }\n+            {\n                 err_upcast_comparison(cx, span, lhs, false)\n             }\n         }"}, {"sha": "ace8ea7558d1ce8ff542f8c0dc647cbb3e8d7675", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -12,7 +12,8 @@ use utils::{snippet, span_help_and_lint};\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** You don't see it, but there may be a zero-width space somewhere in this text.\n+/// **Example:** You don't see it, but there may be a zero-width space\n+/// somewhere in this text.\n declare_lint! {\n     pub ZERO_WIDTH_SPACE,\n     Deny,\n@@ -95,30 +96,40 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n fn check_str(cx: &LateContext, span: Span) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n-        span_help_and_lint(cx,\n-                           ZERO_WIDTH_SPACE,\n-                           span,\n-                           \"zero-width space detected\",\n-                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n-                                    string.replace(\"\\u{200B}\", \"\\\\u{200B}\")));\n+        span_help_and_lint(\n+            cx,\n+            ZERO_WIDTH_SPACE,\n+            span,\n+            \"zero-width space detected\",\n+            &format!(\n+                \"Consider replacing the string with:\\n\\\"{}\\\"\",\n+                string.replace(\"\\u{200B}\", \"\\\\u{200B}\")\n+            ),\n+        );\n     }\n     if string.chars().any(|c| c as u32 > 0x7F) {\n-        span_help_and_lint(cx,\n-                           NON_ASCII_LITERAL,\n-                           span,\n-                           \"literal non-ASCII character detected\",\n-                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\",\n-                                    if cx.current_level(UNICODE_NOT_NFC) == Level::Allow {\n-                                        escape(string.chars())\n-                                    } else {\n-                                        escape(string.nfc())\n-                                    }));\n+        span_help_and_lint(\n+            cx,\n+            NON_ASCII_LITERAL,\n+            span,\n+            \"literal non-ASCII character detected\",\n+            &format!(\n+                \"Consider replacing the string with:\\n\\\"{}\\\"\",\n+                if cx.current_level(UNICODE_NOT_NFC) == Level::Allow {\n+                    escape(string.chars())\n+                } else {\n+                    escape(string.nfc())\n+                }\n+            ),\n+        );\n     }\n     if cx.current_level(NON_ASCII_LITERAL) == Level::Allow && string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n-        span_help_and_lint(cx,\n-                           UNICODE_NOT_NFC,\n-                           span,\n-                           \"non-nfc unicode sequence detected\",\n-                           &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\", string.nfc().collect::<String>()));\n+        span_help_and_lint(\n+            cx,\n+            UNICODE_NOT_NFC,\n+            span,\n+            \"non-nfc unicode sequence detected\",\n+            &format!(\"Consider replacing the string with:\\n\\\"{}\\\"\", string.nfc().collect::<String>()),\n+        );\n     }\n }"}, {"sha": "036e6f0f0e68c3d9008ee42fd361dd7ad202d8c6", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -38,13 +38,15 @@ impl EarlyLintPass for UnsafeNameRemoval {\n         if let ItemKind::Use(ref item_use) = item.node {\n             match item_use.node {\n                 ViewPath_::ViewPathSimple(ref name, ref path) => {\n-                    unsafe_to_safe_check(path.segments\n-                                             .last()\n-                                             .expect(\"use paths cannot be empty\")\n-                                             .identifier,\n-                                         *name,\n-                                         cx,\n-                                         &item.span);\n+                    unsafe_to_safe_check(\n+                        path.segments\n+                            .last()\n+                            .expect(\"use paths cannot be empty\")\n+                            .identifier,\n+                        *name,\n+                        cx,\n+                        &item.span,\n+                    );\n                 },\n                 ViewPath_::ViewPathList(_, ref path_list_items) => {\n                     for path_list_item in path_list_items.iter() {\n@@ -64,10 +66,12 @@ fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, spa\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n-        span_lint(cx,\n-                  UNSAFE_REMOVED_FROM_NAME,\n-                  *span,\n-                  &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str));\n+        span_lint(\n+            cx,\n+            UNSAFE_REMOVED_FROM_NAME,\n+            *span,\n+            &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str),\n+        );\n     }\n }\n "}, {"sha": "ff2148c88a9195301b7fb32bb5d28d0617080dfb", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -4,9 +4,12 @@ use utils::{span_lint, match_path, match_trait_method, is_try, paths};\n \n /// **What it does:** Checks for unused written/read amount.\n ///\n-/// **Why is this bad?** `io::Write::write` and `io::Read::read` are not guaranteed to\n-/// process the entire buffer. They return how many bytes were processed, which might be smaller\n-/// than a given buffer's length. If you don't need to deal with partial-write/read, use\n+/// **Why is this bad?** `io::Write::write` and `io::Read::read` are not\n+/// guaranteed to\n+/// process the entire buffer. They return how many bytes were processed, which\n+/// might be smaller\n+/// than a given buffer's length. If you don't need to deal with\n+/// partial-write/read, use\n /// `write_all`/`read_exact` instead.\n ///\n /// **Known problems:** Detects only common patterns.\n@@ -73,15 +76,19 @@ fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n     if let hir::ExprMethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.name.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n-            span_lint(cx,\n-                      UNUSED_IO_AMOUNT,\n-                      expr.span,\n-                      \"handle read amount returned or use `Read::read_exact` instead\");\n+            span_lint(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"handle read amount returned or use `Read::read_exact` instead\",\n+            );\n         } else if match_trait_method(cx, call, &paths::IO_WRITE) && symbol == \"write\" {\n-            span_lint(cx,\n-                      UNUSED_IO_AMOUNT,\n-                      expr.span,\n-                      \"handle written amount returned or use `Write::write_all` instead\");\n+            span_lint(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"handle written amount returned or use `Write::write_all` instead\",\n+            );\n         }\n     }\n }"}, {"sha": "8a8afe8a377c88b43c29fcbc3547f5d3e3044301", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n         span: Span,\n-        fn_id: ast::NodeId\n+        fn_id: ast::NodeId,\n     ) {\n         if in_macro(span) {\n             return;"}, {"sha": "7466ee9080b23a649ee48ccbc9199d165fe9d2b7", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -7,7 +7,7 @@ use rustc::lint::*;\n use rustc::hir;\n use rustc::hir::{Expr, QPath, Expr_};\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use syntax::ast::{Attribute, NodeId, LitKind, DUMMY_NODE_ID, self};\n+use syntax::ast::{self, Attribute, NodeId, LitKind, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use std::collections::HashMap;\n \n@@ -166,13 +166,14 @@ impl PrintVisitor {\n             Vacant(vac) => {\n                 vac.insert(0);\n                 s.to_owned()\n-            }\n+            },\n         }\n     }\n }\n \n struct PrintVisitor {\n-    /// Fields are the current index that needs to be appended to pattern binding names\n+    /// Fields are the current index that needs to be appended to pattern\n+    /// binding names\n     ids: HashMap<&'static str, usize>,\n     /// the name that needs to be destructured\n     current: String,\n@@ -254,7 +255,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         println!(\"    {}.as_str() == {:?}\", str_pat, &*text.as_str())\n                     },\n                 }\n-            }\n+            },\n             Expr_::ExprCast(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Cast(ref {}, _) = {},\", cast_pat, current);\n@@ -282,7 +283,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.visit_expr(cond);\n                 self.current = then_pat;\n                 self.visit_expr(then);\n-            }\n+            },\n             Expr_::ExprWhile(ref _cond, ref _body, ref _opt_label) => {\n                 println!(\"While(ref cond, ref body, ref opt_label) = {},\", current);\n                 println!(\"    // unimplemented: `ExprWhile` is not further destructured at the moment\");\n@@ -398,7 +399,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let fields_pat = self.next(\"fields\");\n                 if let Some(ref base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n-                    println!(\"Struct(ref {}, ref {}, Some(ref {})) = {},\", path_pat, fields_pat, base_pat, current);\n+                    println!(\n+                        \"Struct(ref {}, ref {}, Some(ref {})) = {},\",\n+                        path_pat,\n+                        fields_pat,\n+                        base_pat,\n+                        current\n+                    );\n                     self.current = base_pat;\n                     self.visit_expr(base);\n                 } else {\n@@ -433,24 +440,27 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n fn has_attr(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n         attr.check_name(\"clippy\") &&\n-        attr.meta_item_list().map_or(false, |list| {\n-            list.len() == 1 && match list[0].node {\n-                ast::NestedMetaItemKind::MetaItem(ref it) => it.name == \"author\",\n-                ast::NestedMetaItemKind::Literal(_) => false,\n-            }\n-        })\n+            attr.meta_item_list().map_or(false, |list| {\n+                list.len() == 1 &&\n+                    match list[0].node {\n+                        ast::NestedMetaItemKind::MetaItem(ref it) => it.name == \"author\",\n+                        ast::NestedMetaItemKind::Literal(_) => false,\n+                    }\n+            })\n     })\n }\n \n fn print_path(path: &QPath, first: &mut bool) {\n     match *path {\n-        QPath::Resolved(_, ref path) => for segment in &path.segments {\n-            if *first {\n-                *first = false;\n-            } else {\n-                print!(\", \");\n+        QPath::Resolved(_, ref path) => {\n+            for segment in &path.segments {\n+                if *first {\n+                    *first = false;\n+                } else {\n+                    print!(\", \");\n+                }\n+                print!(\"{:?}\", segment.name.as_str());\n             }\n-            print!(\"{:?}\", segment.name.as_str());\n         },\n         QPath::TypeRelative(ref ty, ref segment) => {\n             match ty.node {"}, {"sha": "5cb9b50a79d2b0a1cbd1252925c2444c2bb27ad4", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -17,7 +17,8 @@ pub enum Rel {\n     Ne,\n }\n \n-/// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or `lhs != rhs`.\n+/// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or\n+/// `lhs != rhs`.\n pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {\n         BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),"}, {"sha": "ad9e7e201768948b6cf0fa658fb1d4e7bded1e14", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -9,8 +9,9 @@ use toml;\n use std::sync::Mutex;\n \n /// Get the configuration file from arguments.\n-pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>])\n-    -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n+pub fn file_from_args(\n+    args: &[codemap::Spanned<ast::NestedMetaItemKind>],\n+) -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n     for arg in args.iter().filter_map(|a| a.meta_item()) {\n         if arg.name() == \"conf_file\" {\n             return match arg.node {\n@@ -38,12 +39,14 @@ pub enum Error {\n     /// Not valid toml or doesn't fit the expected conf format\n     Toml(String),\n     /// Type error.\n-    Type(/// The name of the key.\n-         &'static str,\n-         /// The expected type.\n-         &'static str,\n-         /// The type we got instead.\n-         &'static str),\n+    Type(\n+        /// The name of the key.\n+        &'static str,\n+        /// The expected type.\n+        &'static str,\n+        /// The type we got instead.\n+        &'static str\n+    ),\n     /// There is an unknown key is the file.\n     UnknownKey(String),\n }\n@@ -234,11 +237,25 @@ pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n         Err(err) => return default(vec![err.into()]),\n     };\n \n-    assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n+    assert!(\n+        ERRORS\n+            .lock()\n+            .expect(\"no threading -> mutex always safe\")\n+            .is_empty()\n+    );\n     match toml::from_str(&file) {\n-        Ok(toml) => (toml, ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0)),\n+        Ok(toml) => (\n+            toml,\n+            ERRORS\n+                .lock()\n+                .expect(\"no threading -> mutex always safe\")\n+                .split_off(0),\n+        ),\n         Err(e) => {\n-            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n+            let mut errors = ERRORS\n+                .lock()\n+                .expect(\"no threading -> mutex always safe\")\n+                .split_off(0);\n             errors.push(Error::Toml(e.to_string()));\n             default(errors)\n         },"}, {"sha": "d47fbd5a043865986902be610b2f90281ec8e585", "filename": "clippy_lints/src/utils/constants.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -7,5 +7,20 @@\n /// See also [the reference][reference-types] for a list of such types.\n ///\n /// [reference-types]: https://doc.rust-lang.org/reference.html#types\n-pub const BUILTIN_TYPES: &'static [&'static str] = &[\"i8\", \"u8\", \"i16\", \"u16\", \"i32\", \"u32\", \"i64\", \"u64\", \"isize\",\n-                                                     \"usize\", \"f32\", \"f64\", \"bool\", \"str\", \"char\"];\n+pub const BUILTIN_TYPES: &'static [&'static str] = &[\n+    \"i8\",\n+    \"u8\",\n+    \"i16\",\n+    \"u16\",\n+    \"i32\",\n+    \"u32\",\n+    \"i64\",\n+    \"u64\",\n+    \"isize\",\n+    \"usize\",\n+    \"f32\",\n+    \"f64\",\n+    \"bool\",\n+    \"str\",\n+    \"char\",\n+];"}, {"sha": "593cbf69f5b31ac2e561276b2b4f8ab9ec90b4d5", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -1,4 +1,5 @@\n-//! This module contains functions for retrieve the original AST from lowered `hir`.\n+//! This module contains functions for retrieve the original AST from lowered\n+//! `hir`.\n \n #![deny(missing_docs_in_private_items)]\n \n@@ -44,17 +45,20 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range(expr: &hir::Expr) -> Option<Range> {\n-    /// Find the field named `name` in the field. Always return `Some` for convenience.\n+    /// Find the field named `name` in the field. Always return `Some` for\n+    /// convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n-        let expr = &fields.iter()\n+        let expr = &fields\n+            .iter()\n             .find(|field| field.name.node == name)\n             .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n             .expr;\n \n         Some(expr)\n     }\n \n-    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n+    // The range syntax is expanded to literal paths starting with `core` or `std`\n+    // depending on\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n     match expr.node {\n@@ -147,7 +151,8 @@ pub enum VecArgs<'a> {\n     Vec(&'a [hir::Expr]),\n }\n \n-/// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`.\n+/// Returns the arguments of the `vec!` macro if this expression was expanded\n+/// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,"}, {"sha": "658a07ca146813df8c4de5936cb74d8365f8ba0c", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -7,14 +7,17 @@ use syntax::ast::Name;\n use syntax::ptr::P;\n use utils::differing_macro_contexts;\n \n-/// Type used to check whether two ast are the same. This is different from the operator\n-/// `==` on ast types as this operator would compare true equality with ID and span.\n+/// Type used to check whether two ast are the same. This is different from the\n+/// operator\n+/// `==` on ast types as this operator would compare true equality with ID and\n+/// span.\n ///\n /// Note that some expressions kinds are not considered but could be added.\n pub struct SpanlessEq<'a, 'tcx: 'a> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,\n-    /// If is true, never consider as equal expressions containing function calls.\n+    /// If is true, never consider as equal expressions containing function\n+    /// calls.\n     ignore_fn: bool,\n }\n \n@@ -52,7 +55,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     /// Check whether two blocks are the same.\n     pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r)) &&\n-        both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+            both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n@@ -78,13 +81,13 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n-                swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n-                    l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n-                })\n+                    swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                        l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                    })\n             },\n             (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n                 both(&li.ident, &ri.ident, |l, r| l.node.name.as_str() == r.node.name.as_str()) &&\n-                both(le, re, |l, r| self.eq_expr(l, r))\n+                    both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n@@ -105,23 +108,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n-                over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n-                    over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n-                })\n+                    over(la, ra, |l, r| {\n+                        self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                            over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                    })\n             },\n             (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n                 !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprRepeat(ref le, ll_id), &ExprRepeat(ref re, rl_id)) => {\n                 self.eq_expr(le, re) &&\n-                self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                    self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n             },\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n-                over(lf, rf, |l, r| self.eq_field(l, r))\n+                    over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n@@ -167,7 +170,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r)) &&\n-                both(li, ri, |l, r| self.eq_pat(l, r))\n+                    both(li, ri, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,\n@@ -188,19 +191,19 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n         left.is_global() == right.is_global() &&\n-        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+            over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n         match (left, right) {\n             (&AngleBracketedParameters(ref left), &AngleBracketedParameters(ref right)) => {\n                 over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n-                over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n-                over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+                    over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n+                    over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n             },\n             (&ParenthesizedParameters(ref left), &ParenthesizedParameters(ref right)) => {\n                 over(&left.inputs, &right.inputs, |l, r| self.eq_ty(l, r)) &&\n-                both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n+                    both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n             },\n             (&AngleBracketedParameters(_), &ParenthesizedParameters(_)) |\n             (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => false,\n@@ -218,7 +221,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyArray(ref lt, ll_id), &TyArray(ref rt, rl_id)) => {\n                 self.eq_ty(lt, rt) &&\n-                self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                    self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n             },\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n@@ -247,22 +250,28 @@ fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_\n     }\n }\n \n-/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n+/// Check if the two `Option`s are both `None` or some equal values as per\n+/// `eq_fn`.\n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n+where\n+    F: FnMut(&X, &X) -> bool,\n {\n-    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n+    l.as_ref().map_or_else(|| r.is_none(), |x| {\n+        r.as_ref().map_or(false, |y| eq_fn(x, y))\n+    })\n }\n \n /// Check if two slices are equal as per `eq_fn`.\n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n+where\n+    F: FnMut(&X, &X) -> bool,\n {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n \n-/// Type used to hash an ast element. This is different from the `Hash` trait on ast types as this\n+/// Type used to hash an ast element. This is different from the `Hash` trait\n+/// on ast types as this\n /// trait would consider IDs and spans.\n ///\n /// All expressions kind are hashed, but some might have a weaker hash."}, {"sha": "ccb2cb7c67f2eed504db20144d35fb538483f898", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -8,7 +8,8 @@ use rustc::hir::print;\n use syntax::ast::Attribute;\n use syntax::attr;\n \n-/// **What it does:** Dumps every ast/hir node which has the `#[clippy_dump]` attribute\n+/// **What it does:** Dumps every ast/hir node which has the `#[clippy_dump]`\n+/// attribute\n ///\n /// **Example:**\n /// ```rust\n@@ -54,8 +55,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             hir::Visibility::Public => println!(\"public\"),\n             hir::Visibility::Crate => println!(\"visible crate wide\"),\n             hir::Visibility::Restricted { ref path, .. } => {\n-                println!(\"visible in module `{}`\",\n-                         print::to_string(print::NO_ANN, |s| s.print_path(path, false)))\n+                println!(\n+                    \"visible in module `{}`\",\n+                    print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n+                )\n             },\n             hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n         }\n@@ -71,20 +74,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n         }\n     }\n-    // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+    // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n+    // hir::TraitItem) {\n     // if !has_attr(&item.attrs) {\n     // return;\n     // }\n     // }\n     //\n-    // fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _:\n+    // fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx\n+    // hir::Variant, _:\n     // &hir::Generics) {\n     // if !has_attr(&var.node.attrs) {\n     // return;\n     // }\n     // }\n     //\n-    // fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n+    // fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx\n+    // hir::StructField) {\n     // if !has_attr(&field.attrs) {\n     // return;\n     // }\n@@ -123,7 +129,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n-    // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n+    // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n+    // hir::ForeignItem) {\n     // if !has_attr(&item.attrs) {\n     // return;\n     // }\n@@ -345,8 +352,10 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n         hir::Visibility::Public => println!(\"public\"),\n         hir::Visibility::Crate => println!(\"visible crate wide\"),\n         hir::Visibility::Restricted { ref path, .. } => {\n-            println!(\"visible in module `{}`\",\n-                     print::to_string(print::NO_ANN, |s| s.print_path(path, false)))\n+            println!(\n+                \"visible in module `{}`\",\n+                print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n+            )\n         },\n         hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n@@ -422,9 +431,11 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::Struct(ref path, ref fields, ignore) => {\n             println!(\"{}Struct\", ind);\n-            println!(\"{}name: {}\",\n-                     ind,\n-                     print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n+            println!(\n+                \"{}name: {}\",\n+                ind,\n+                print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n+            );\n             println!(\"{}ignore leftover fields: {}\", ind, ignore);\n             println!(\"{}fields:\", ind);\n             for field in fields {\n@@ -437,9 +448,11 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::TupleStruct(ref path, ref fields, opt_dots_position) => {\n             println!(\"{}TupleStruct\", ind);\n-            println!(\"{}path: {}\",\n-                     ind,\n-                     print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n+            println!(\n+                \"{}path: {}\",\n+                ind,\n+                print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n+            );\n             if let Some(dot_position) = opt_dots_position {\n                 println!(\"{}dot position: {}\", ind, dot_position);\n             }"}, {"sha": "f81aff24338da3b736e35c67f762999a6e0c9dde", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -63,20 +63,28 @@ impl LintPass for Clippy {\n \n impl EarlyLintPass for Clippy {\n     fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n-        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name == \"utils\") {\n+        if let Some(utils) = krate.module.items.iter().find(\n+            |item| item.ident.name == \"utils\",\n+        )\n+        {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n-                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name == \"paths\") {\n+                if let Some(paths) = utils_mod.items.iter().find(\n+                    |item| item.ident.name == \"paths\",\n+                )\n+                {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<InternedString> = None;\n                         for item in &paths_mod.items {\n                             let name = item.ident.name.as_str();\n                             if let Some(ref last_name) = last_name {\n                                 if **last_name > *name {\n-                                    span_lint(cx,\n-                                              CLIPPY_LINTS_INTERNAL,\n-                                              item.span,\n-                                              \"this constant should be before the previous constant due to lexical \\\n-                                               ordering\");\n+                                    span_lint(\n+                                        cx,\n+                                        CLIPPY_LINTS_INTERNAL,\n+                                        item.span,\n+                                        \"this constant should be before the previous constant due to lexical \\\n+                                               ordering\",\n+                                    );\n                                 }\n                             }\n                             last_name = Some(name);\n@@ -128,21 +136,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n             // not able to capture the error.\n             // Therefore, we need to climb the macro expansion tree and find the\n             // actual span that invoked `declare_lint!`:\n-            let lint_span = lint_span.ctxt.outer().expn_info().map(|ei| ei.call_site).expect(\"unable to get call_site\");\n+            let lint_span = lint_span\n+                .ctxt\n+                .outer()\n+                .expn_info()\n+                .map(|ei| ei.call_site)\n+                .expect(\"unable to get call_site\");\n \n             if !self.registered_lints.contains(lint_name) {\n-                span_lint(cx,\n-                          LINT_WITHOUT_LINT_PASS,\n-                          lint_span,\n-                          &format!(\"the lint `{}` is not added to any `LintPass`\", lint_name));\n+                span_lint(\n+                    cx,\n+                    LINT_WITHOUT_LINT_PASS,\n+                    lint_span,\n+                    &format!(\"the lint `{}` is not added to any `LintPass`\", lint_name),\n+                );\n             }\n         }\n     }\n }\n \n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n-    if let TyRptr(ref lt, MutTy { ty: ref inner, mutbl: MutImmutable }) = ty.node {\n+    if let TyRptr(ref lt,\n+                  MutTy {\n+                      ty: ref inner,\n+                      mutbl: MutImmutable,\n+                  }) = ty.node\n+    {\n         if lt.is_elided() {\n             return false;\n         }"}, {"sha": "43c0eb68d69979c4e8c4d23ad747b17328a69c40", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 137, "deletions": 75, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -93,7 +93,8 @@ macro_rules! if_let_chain {\n \n pub mod higher;\n \n-/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n+/// Returns true if the two spans come from differing expansions (i.e. one is\n+/// from a macro and one\n /// isn't).\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt != lhs.ctxt\n@@ -119,10 +120,12 @@ pub fn in_macro(span: Span) -> bool {\n     })\n }\n \n-/// Returns true if the macro that expanded the crate was outside of the current crate or was a\n+/// Returns true if the macro that expanded the crate was outside of the\n+/// current crate or was a\n /// compiler plugin.\n pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n-    /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n+    /// Invokes `in_macro` with the expansion info of the given span slightly\n+    /// heavy, try to use\n     /// this after other checks have already happened.\n     fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n         // no ExpnInfo = no macro\n@@ -133,11 +136,18 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n         // no span for the callee = external macro\n         info.callee.span.map_or(true, |span| {\n             // no snippet = external macro or compiler-builtin expansion\n-            cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| !code.starts_with(\"macro_rules\"))\n+            cx.sess().codemap().span_to_snippet(span).ok().map_or(\n+                true,\n+                |code| {\n+                    !code.starts_with(\"macro_rules\")\n+                },\n+            )\n         })\n     }\n \n-    span.ctxt.outer().expn_info().map_or(false, |info| in_macro_ext(cx, &info))\n+    span.ctxt.outer().expn_info().map_or(false, |info| {\n+        in_macro_ext(cx, &info)\n+    })\n }\n \n /// Check if a `DefId`'s path matches the given absolute type path usage.\n@@ -170,7 +180,10 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n \n     tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    apb.names.len() == path.len() &&\n+        apb.names.into_iter().zip(path.iter()).all(\n+            |(a, &b)| *a == *b,\n+        )\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -206,9 +219,9 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n         QPath::Resolved(_, ref path) => {\n-            path.segments\n-                .last()\n-                .expect(\"A path must have at least one segment\")\n+            path.segments.last().expect(\n+                \"A path must have at least one segment\",\n+            )\n         },\n         QPath::TypeRelative(_, ref seg) => seg,\n     }\n@@ -235,7 +248,7 @@ pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n             match ty.node {\n                 TyPath(ref inner_path) => {\n                     !segments.is_empty() && match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n-                    segment.name == segments[segments.len() - 1]\n+                        segment.name == segments[segments.len() - 1]\n                 },\n                 _ => false,\n             }\n@@ -244,7 +257,9 @@ pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n }\n \n pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(\n+        |(a, b)| a.name == *b,\n+    )\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g.\n@@ -254,15 +269,19 @@ pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(\n+        |(a, b)| a.identifier.name == *b,\n+    )\n }\n \n /// Get the definition associated to a path.\n pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let cstore = &cx.tcx.sess.cstore;\n \n     let crates = cstore.crates();\n-    let krate = crates.iter().find(|&&krate| cstore.crate_name(krate) == path[0]);\n+    let krate = crates.iter().find(\n+        |&&krate| cstore.crate_name(krate) == path[0],\n+    );\n     if let Some(krate) = krate {\n         let krate = DefId {\n             krate: *krate,\n@@ -312,14 +331,20 @@ pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     ty: Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[Ty<'tcx>]\n+    ty_params: &[Ty<'tcx>],\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let obligation = cx.tcx\n-        .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-    cx.tcx\n-        .infer_ctxt()\n-        .enter(|infcx| traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation))\n+    let obligation = cx.tcx.predicate_for_trait_def(\n+        cx.param_env,\n+        traits::ObligationCause::dummy(),\n+        trait_id,\n+        0,\n+        ty,\n+        ty_params,\n+    );\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n+    })\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n@@ -330,7 +355,8 @@ pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: NodeId) -> def::Def {\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n-/// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec` containing the `Expr`s for\n+/// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n+/// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a [Expr]>> {\n     let mut current = expr;\n@@ -382,8 +408,10 @@ pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String>\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n-/// Convert a span (from a block) to a code snippet if available, otherwise use default.\n-/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n+/// Convert a span (from a block) to a code snippet if available, otherwise use\n+/// default.\n+/// This trims the code of indentation, except for the first line. Use it for\n+/// blocks or block-like\n /// things which need to be printed as such.\n ///\n /// # Example\n@@ -401,7 +429,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     cx: &T,\n     expr: &Expr,\n     option: Option<String>,\n-    default: &'a str\n+    default: &'a str,\n ) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n@@ -414,7 +442,8 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     }\n }\n \n-/// Trim indentation from a multiline string with possibility of ignoring the first line.\n+/// Trim indentation from a multiline string with possibility of ignoring the\n+/// first line.\n pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n@@ -429,24 +458,28 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n                 None\n             } else {\n                 // ignore empty lines\n-                Some(l.char_indices()\n-                    .find(|&(_, x)| x != ch)\n-                    .unwrap_or((l.len(), ch))\n-                    .0)\n+                Some(\n+                    l.char_indices()\n+                        .find(|&(_, x)| x != ch)\n+                        .unwrap_or((l.len(), ch))\n+                        .0,\n+                )\n             }\n         })\n         .min()\n         .unwrap_or(0);\n     if x > 0 {\n-        Cow::Owned(s.lines()\n-            .enumerate()\n-            .map(|(i, l)| if (ignore_first && i == 0) || l.is_empty() {\n-                l\n-            } else {\n-                l.split_at(x).1\n-            })\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\"))\n+        Cow::Owned(\n+            s.lines()\n+                .enumerate()\n+                .map(|(i, l)| if (ignore_first && i == 0) || l.is_empty() {\n+                    l\n+                } else {\n+                    l.split_at(x).1\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n+        )\n     } else {\n         s\n     }\n@@ -460,17 +493,22 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     if node_id == parent_id {\n         return None;\n     }\n-    map.find(parent_id).and_then(|node| if let Node::NodeExpr(parent) = node {\n-        Some(parent)\n-    } else {\n-        None\n-    })\n+    map.find(parent_id).and_then(\n+        |node| if let Node::NodeExpr(parent) =\n+            node\n+        {\n+            Some(parent)\n+        } else {\n+            None\n+        },\n+    )\n }\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir;\n-    let enclosing_node = map.get_enclosing_scope(node)\n-        .and_then(|enclosing_id| map.find(enclosing_id));\n+    let enclosing_node = map.get_enclosing_scope(node).and_then(|enclosing_id| {\n+        map.find(enclosing_id)\n+    });\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n@@ -498,8 +536,10 @@ impl<'a> Drop for DiagnosticWrapper<'a> {\n impl<'a> DiagnosticWrapper<'a> {\n     fn wiki_link(&mut self, lint: &'static Lint) {\n         if env::var(\"CLIPPY_DISABLE_WIKI_LINKS\").is_err() {\n-            self.0.help(&format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-                                 lint.name_lower()));\n+            self.0.help(&format!(\n+                \"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n+                lint.name_lower()\n+            ));\n         }\n     }\n }\n@@ -516,7 +556,7 @@ pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     lint: &'static Lint,\n     span: Span,\n     msg: &str,\n-    help: &str\n+    help: &str,\n ) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -531,7 +571,7 @@ pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     span: Span,\n     msg: &str,\n     note_span: Span,\n-    note: &str\n+    note: &str,\n ) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -549,8 +589,9 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n     lint: &'static Lint,\n     sp: Span,\n     msg: &str,\n-    f: F\n-) where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n+    f: F,\n+) where\n+    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -565,15 +606,17 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     sp: Span,\n     msg: &str,\n     help: &str,\n-    sugg: String\n+    sugg: String,\n ) {\n     span_lint_and_then(cx, lint, sp, msg, |db| { db.span_suggestion(sp, help, sugg); });\n }\n \n /// Create a suggestion made from several `span \u2192 replacement`.\n ///\n-/// Note: in the JSON format (used by `compiletest_rs`), the help message will appear once per\n-/// replacement. In human-readable format though, it only appears once before the whole suggestion.\n+/// Note: in the JSON format (used by `compiletest_rs`), the help message will\n+/// appear once per\n+/// replacement. In human-readable format though, it only appears once before\n+/// the whole suggestion.\n pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(Span, String)>) {\n     let sugg = rustc_errors::CodeSuggestion {\n         substitution_parts: sugg.into_iter()\n@@ -598,7 +641,8 @@ pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n     }\n }\n \n-/// Return the base type for references and raw pointers, and count reference depth.\n+/// Return the base type for references and raw pointers, and count reference\n+/// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n     fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n         match ty.sty {\n@@ -639,7 +683,9 @@ impl LimitStack {\n         LimitStack { stack: vec![limit] }\n     }\n     pub fn limit(&self) -> u64 {\n-        *self.stack.last().expect(\"there should always be a value in the stack\")\n+        *self.stack.last().expect(\n+            \"there should always be a value in the stack\",\n+        )\n     }\n     pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n@@ -669,14 +715,14 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-/// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n+/// Return the pre-expansion span if is this comes from an expansion of the\n+/// macro `name`.\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = span.ctxt\n-            .outer()\n-            .expn_info()\n-            .map(|ei| (ei.callee.name(), ei.call_site));\n+        let span_name_span = span.ctxt.outer().expn_info().map(|ei| {\n+            (ei.callee.name(), ei.call_site)\n+        });\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -686,26 +732,28 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Return the pre-expansion span if is this directly comes from an expansion of the macro `name`.\n+/// Return the pre-expansion span if is this directly comes from an expansion\n+/// of the macro `name`.\n /// The difference with `is_expn_of` is that in\n /// ```rust,ignore\n /// foo!(bar!(42));\n /// ```\n-/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only `bar!` by\n+/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n+/// `bar!` by\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = span.ctxt\n-        .outer()\n-        .expn_info()\n-        .map(|ei| (ei.callee.name(), ei.call_site));\n+    let span_name_span = span.ctxt.outer().expn_info().map(|ei| {\n+        (ei.callee.name(), ei.call_site)\n+    });\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n         _ => None,\n     }\n }\n \n-/// Return the index of the character after the first camel-case component of `s`.\n+/// Return the index of the character after the first camel-case component of\n+/// `s`.\n pub fn camel_case_until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n@@ -771,10 +819,13 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'t\n }\n \n /// Check if two types are the same.\n-// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n+// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for\n+// <'b> Foo<'b>` but\n // not for type parameters.\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx.can_eq(cx.param_env, a, b).is_ok()\n+    })\n }\n \n /// Return whether the given type is an `unsafe` function.\n@@ -792,8 +843,10 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n-        matches!(cx.tables.qpath_def(qpath, did),\n-                 def::Def::Variant(..) | def::Def::VariantCtor(..))\n+        matches!(\n+            cx.tables.qpath_def(qpath, did),\n+            def::Def::Variant(..) | def::Def::VariantCtor(..)\n+        )\n     }\n \n     fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n@@ -824,19 +877,26 @@ pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n             }\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n+            are_refutable(\n+                cx,\n+                head.iter().chain(middle).chain(tail.iter()).map(\n+                    |pat| &**pat,\n+                ),\n+            )\n         },\n     }\n }\n \n-/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d implementations have.\n+/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n+/// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"automatically_derived\")\n }\n \n /// Remove blocks around an expression.\n ///\n-/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return themselves.\n+/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n+/// themselves.\n pub fn remove_blocks(expr: &Expr) -> &Expr {\n     if let ExprBlock(ref block) = expr.node {\n         if block.stmts.is_empty() {\n@@ -948,5 +1008,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n }\n \n pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u64> {\n-    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| layout.size(cx.tcx).bytes())\n+    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| {\n+        layout.size(cx.tcx).bytes()\n+    })\n }"}, {"sha": "675d708781ca354ac50cd1ad881ee08364a8451c", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -1,4 +1,5 @@\n-//! This module contains paths to types and functions Clippy needs to know about.\n+//! This module contains paths to types and functions Clippy needs to know\n+//! about.\n \n pub const ASMUT_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsRef\"];"}, {"sha": "d46a65263958f9fd3cf53afb379900b9fb55a42d", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -20,7 +20,8 @@ pub enum Sugg<'a> {\n     NonParen(Cow<'a, str>),\n     /// An expression that does not fit in other variants.\n     MaybeParen(Cow<'a, str>),\n-    /// A binary operator expression, including `as`-casts and explicit type coercion.\n+    /// A binary operator expression, including `as`-casts and explicit type\n+    /// coercion.\n     BinOp(AssocOp, Cow<'a, str>),\n }\n \n@@ -77,7 +78,8 @@ impl<'a> Sugg<'a> {\n         })\n     }\n \n-    /// Convenience function around `hir_opt` for suggestions with a default text.\n+    /// Convenience function around `hir_opt` for suggestions with a default\n+    /// text.\n     pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Sugg<'a> {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n@@ -156,15 +158,17 @@ impl<'a> Sugg<'a> {\n         make_unop(\"*\", self)\n     }\n \n-    /// Convenience method to create the `<lhs>..<rhs>` or `<lhs>...<rhs>` suggestion.\n+    /// Convenience method to create the `<lhs>..<rhs>` or `<lhs>...<rhs>`\n+    /// suggestion.\n     pub fn range(self, end: Self, limit: ast::RangeLimits) -> Sugg<'static> {\n         match limit {\n             ast::RangeLimits::HalfOpen => make_assoc(AssocOp::DotDot, &self, &end),\n             ast::RangeLimits::Closed => make_assoc(AssocOp::DotDotDot, &self, &end),\n         }\n     }\n \n-    /// Add parenthesis to any expression that might need them. Suitable to the `self` argument of\n+    /// Add parenthesis to any expression that might need them. Suitable to the\n+    /// `self` argument of\n     /// a method call (eg. to build `bar.foo()` or `(1 + 2).foo()`).\n     pub fn maybe_par(self) -> Self {\n         match self {\n@@ -233,15 +237,17 @@ impl<T: Display> Display for ParenHelper<T> {\n \n /// Build the string for `<op><expr>` adding parenthesis when necessary.\n ///\n-/// For convenience, the operator is taken as a string because all unary operators have the same\n+/// For convenience, the operator is taken as a string because all unary\n+/// operators have the same\n /// precedence.\n pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n /// Build the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n ///\n-/// Precedence of shift operator relative to other arithmetic operation is often confusing so\n+/// Precedence of shift operator relative to other arithmetic operation is\n+/// often confusing so\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     /// Whether the operator is a shift operator `<<` or `>>`.\n@@ -251,18 +257,21 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n \n     /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n-        matches!(*op,\n-                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n+        matches!(\n+            *op,\n+            AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n+        )\n     }\n \n-    /// Whether the operator `op` needs parenthesis with the operator `other` in the direction\n+    /// Whether the operator `op` needs parenthesis with the operator `other`\n+    /// in the direction\n     /// `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence() ||\n-        (other.precedence() == op.precedence() &&\n-         ((op != other && associativity(op) != dir) ||\n-          (op == other && associativity(op) != Associativity::Both))) || is_shift(op) && is_arith(other) ||\n-        is_shift(other) && is_arith(op)\n+            (other.precedence() == op.precedence() &&\n+                 ((op != other && associativity(op) != dir) ||\n+                      (op == other && associativity(op) != Associativity::Both))) ||\n+            is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n     }\n \n     let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n@@ -316,11 +325,13 @@ enum Associativity {\n     Right,\n }\n \n-/// Return the associativity/fixity of an operator. The difference with `AssocOp::fixity` is that\n+/// Return the associativity/fixity of an operator. The difference with\n+/// `AssocOp::fixity` is that\n /// an operator can be both left and right associative (such as `+`:\n /// `a + b + c == (a + b) + c == a + (b + c)`.\n ///\n-/// Chained `as` and explicit `:` type coercion never need inner parenthesis so they are considered\n+/// Chained `as` and explicit `:` type coercion never need inner parenthesis so\n+/// they are considered\n /// associative.\n fn associativity(op: &AssocOp) -> Associativity {\n     use syntax::util::parser::AssocOp::*;\n@@ -374,10 +385,14 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n     })\n }\n \n-/// Return the indentation before `span` if there are nothing but `[ \\t]` before it on its line.\n+/// Return the indentation before `span` if there are nothing but `[ \\t]`\n+/// before it on its line.\n fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().codemap().lookup_char_pos(span.lo);\n-    if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n+    if let Some(line) = lo.file.get_line(\n+        lo.line - 1, /* line numbers in `Loc` are 1-based */\n+    )\n+    {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n             // we can mix char and byte positions here because we only consider `[ \\t]`\n             if lo.col == CharPos(pos) {\n@@ -424,18 +439,25 @@ pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n     fn suggest_item_with_attr<D: Display + ?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span { hi: item.lo, ..item };\n+            let span = Span {\n+                hi: item.lo,\n+                ..item\n+            };\n \n             self.span_suggestion(span, msg, format!(\"{}\\n{}\", attr, indent));\n         }\n     }\n \n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str) {\n         if let Some(indent) = indentation(cx, item) {\n-            let span = Span { hi: item.lo, ..item };\n+            let span = Span {\n+                hi: item.lo,\n+                ..item\n+            };\n \n             let mut first = true;\n-            let new_item = new_item.lines()\n+            let new_item = new_item\n+                .lines()\n                 .map(|l| if first {\n                     first = false;\n                     format!(\"{}\\n\", l)"}, {"sha": "c864c9d2aeb7ede1f036a471999ab3d24f36f304", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -63,7 +63,10 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n             let parent_item = cx.tcx.hir.get_parent(len.id);\n             let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n             let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-            if ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(len).is_ok() {\n+            if ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables)\n+                .eval(len)\n+                .is_ok()\n+            {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n             } else {\n                 return;\n@@ -84,12 +87,14 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n         },\n     };\n \n-    span_lint_and_sugg(cx,\n-                       USELESS_VEC,\n-                       span,\n-                       \"useless use of `vec!`\",\n-                       \"you can use a slice directly\",\n-                       snippet);\n+    span_lint_and_sugg(\n+        cx,\n+        USELESS_VEC,\n+        span,\n+        \"useless use of `vec!`\",\n+        \"you can use a slice directly\",\n+        snippet,\n+    );\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`)."}, {"sha": "888cd33909656cf83684cf14d7b2a74babe6b7d6", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -5,7 +5,8 @@ use utils::span_help_and_lint;\n \n /// **What it does:** Checks for `0.0 / 0.0`.\n ///\n-/// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`.\n+/// **Why is this bad?** It's less readable than `std::f32::NAN` or\n+/// `std::f64::NAN`.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "8e92eb55ff09385a6f1bacad20277af6259e5e25", "filename": "src/main.rs", "status": "modified", "additions": 94, "deletions": 65, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -46,8 +46,13 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         descriptions: &rustc_errors::registry::Registry,\n         output: ErrorOutputType,\n     ) -> Compilation {\n-        self.default\n-            .early_callback(matches, sopts, cfg, descriptions, output)\n+        self.default.early_callback(\n+            matches,\n+            sopts,\n+            cfg,\n+            descriptions,\n+            output,\n+        )\n     }\n     fn no_input(\n         &mut self,\n@@ -58,8 +63,14 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         ofile: &Option<PathBuf>,\n         descriptions: &rustc_errors::registry::Registry,\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default\n-            .no_input(matches, sopts, cfg, odir, ofile, descriptions)\n+        self.default.no_input(\n+            matches,\n+            sopts,\n+            cfg,\n+            odir,\n+            ofile,\n+            descriptions,\n+        )\n     }\n     fn late_callback(\n         &mut self,\n@@ -69,8 +80,13 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default\n-            .late_callback(matches, sess, input, odir, ofile)\n+        self.default.late_callback(\n+            matches,\n+            sess,\n+            input,\n+            odir,\n+            ofile,\n+        )\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> driver::CompileController<'a> {\n         let mut control = self.default.build_controller(sess, matches);\n@@ -79,13 +95,17 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n             let old = std::mem::replace(&mut control.after_parse.callback, box |_| {});\n             control.after_parse.callback = Box::new(move |state| {\n                 {\n-                    let mut registry = rustc_plugin::registry::Registry::new(state.session,\n-                                                                             state\n-                                                                                 .krate\n-                                                                                 .as_ref()\n-                                                                                 .expect(\"at this compilation stage \\\n-                                                                                          the krate must be parsed\")\n-                                                                                 .span);\n+                    let mut registry = rustc_plugin::registry::Registry::new(\n+                        state.session,\n+                        state\n+                            .krate\n+                            .as_ref()\n+                            .expect(\n+                                \"at this compilation stage \\\n+                                                                                          the krate must be parsed\",\n+                            )\n+                            .span,\n+                    );\n                     registry.args_hidden = Some(Vec::new());\n                     clippy_lints::register_plugins(&mut registry);\n \n@@ -179,9 +199,9 @@ pub fn main() {\n     if let Some(\"clippy\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n         // this arm is executed on the initial call to `cargo clippy`\n \n-        let manifest_path_arg = std::env::args()\n-            .skip(2)\n-            .find(|val| val.starts_with(\"--manifest-path=\"));\n+        let manifest_path_arg = std::env::args().skip(2).find(|val| {\n+            val.starts_with(\"--manifest-path=\")\n+        });\n \n         let mut metadata =\n             if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n@@ -191,55 +211,59 @@ pub fn main() {\n                 process::exit(101);\n             };\n \n-        let manifest_path = manifest_path_arg.map(|arg| Path::new(&arg[\"--manifest-path=\".len()..])\n-            .canonicalize().expect(\"manifest path could not be canonicalized\"));\n+        let manifest_path = manifest_path_arg.map(|arg| {\n+            Path::new(&arg[\"--manifest-path=\".len()..])\n+                .canonicalize()\n+                .expect(\"manifest path could not be canonicalized\")\n+        });\n \n         let package_index = {\n-                if let Some(manifest_path) = manifest_path {\n-                    metadata.packages.iter().position(|package| {\n+            if let Some(manifest_path) = manifest_path {\n+                metadata.packages.iter().position(|package| {\n+                    let package_manifest_path = Path::new(&package.manifest_path).canonicalize().expect(\n+                        \"package manifest path could not be canonicalized\",\n+                    );\n+                    package_manifest_path == manifest_path\n+                })\n+            } else {\n+                let package_manifest_paths: HashMap<_, _> = metadata\n+                    .packages\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, package)| {\n                         let package_manifest_path = Path::new(&package.manifest_path)\n-                            .canonicalize().expect(\"package manifest path could not be canonicalized\");\n-                        package_manifest_path == manifest_path\n+                            .parent()\n+                            .expect(\"could not find parent directory of package manifest\")\n+                            .canonicalize()\n+                            .expect(\"package directory cannot be canonicalized\");\n+                        (package_manifest_path, i)\n                     })\n-                } else {\n-                    let package_manifest_paths: HashMap<_, _> =\n-                        metadata.packages.iter()\n-                        .enumerate()\n-                        .map(|(i, package)| {\n-                            let package_manifest_path = Path::new(&package.manifest_path)\n-                                .parent()\n-                                .expect(\"could not find parent directory of package manifest\")\n-                                .canonicalize()\n-                                .expect(\"package directory cannot be canonicalized\");\n-                            (package_manifest_path, i)\n-                        })\n-                        .collect();\n-\n-                    let current_dir = std::env::current_dir()\n-                        .expect(\"could not read current directory\")\n-                        .canonicalize()\n-                        .expect(\"current directory cannot be canonicalized\");\n-\n-                    let mut current_path: &Path = &current_dir;\n-\n-                    // This gets the most-recent parent (the one that takes the fewest `cd ..`s to\n-                    // reach).\n-                    loop {\n-                        if let Some(&package_index) = package_manifest_paths.get(current_path) {\n-                            break Some(package_index);\n-                        }\n-                        else {\n-                            // We'll never reach the filesystem root, because to get to this point in the code\n-                            // the call to `cargo_metadata::metadata` must have succeeded. So it's okay to\n-                            // unwrap the current path's parent.\n-                            current_path = current_path\n-                                .parent()\n-                                .unwrap_or_else(|| panic!(\"could not find parent of path {}\", current_path.display()));\n-                        }\n+                    .collect();\n+\n+                let current_dir = std::env::current_dir()\n+                    .expect(\"could not read current directory\")\n+                    .canonicalize()\n+                    .expect(\"current directory cannot be canonicalized\");\n+\n+                let mut current_path: &Path = &current_dir;\n+\n+                // This gets the most-recent parent (the one that takes the fewest `cd ..`s to\n+                // reach).\n+                loop {\n+                    if let Some(&package_index) = package_manifest_paths.get(current_path) {\n+                        break Some(package_index);\n+                    } else {\n+                        // We'll never reach the filesystem root, because to get to this point in the\n+                        // code\n+                        // the call to `cargo_metadata::metadata` must have succeeded. So it's okay to\n+                        // unwrap the current path's parent.\n+                        current_path = current_path.parent().unwrap_or_else(|| {\n+                            panic!(\"could not find parent of path {}\", current_path.display())\n+                        });\n                     }\n                 }\n             }\n-            .expect(\"could not find matching package\");\n+        }.expect(\"could not find matching package\");\n \n         let package = metadata.packages.remove(package_index);\n         for target in package.targets {\n@@ -250,9 +274,12 @@ pub fn main() {\n                         std::process::exit(code);\n                     }\n                 } else if [\"bin\", \"example\", \"test\", \"bench\"].contains(&&**first) {\n-                    if let Err(code) = process(vec![format!(\"--{}\", first), target.name]\n-                                                   .into_iter()\n-                                                   .chain(args)) {\n+                    if let Err(code) = process(\n+                        vec![format!(\"--{}\", first), target.name]\n+                            .into_iter()\n+                            .chain(args),\n+                    )\n+                    {\n                         std::process::exit(code);\n                     }\n                 }\n@@ -280,7 +307,9 @@ pub fn main() {\n                         .and_then(|out| String::from_utf8(out.stdout).ok())\n                         .map(|s| s.trim().to_owned())\n                 })\n-                .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\")\n+                .expect(\n+                    \"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\",\n+                )\n         };\n \n         rustc_driver::in_rustc_thread(|| {\n@@ -310,13 +339,13 @@ pub fn main() {\n             if let Err(CompileIncomplete::Errored(_)) = result {\n                 std::process::exit(1);\n             }\n-        })\n-                .expect(\"rustc_thread failed\");\n+        }).expect(\"rustc_thread failed\");\n     }\n }\n \n fn process<I>(old_args: I) -> Result<(), i32>\n-    where I: Iterator<Item = String>\n+where\n+    I: Iterator<Item = String>,\n {\n \n     let mut args = vec![\"rustc\".to_owned()];"}, {"sha": "363eeced8a2ac720934b4adb2d6dc11dc6a12602", "filename": "tests/compile-test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -29,8 +29,6 @@ fn compile_test() {\n     prepare_env();\n     run_mode(\"run-pass\", \"run-pass\");\n     run_mode(\"ui\", \"ui\");\n-    #[cfg(target_os = \"windows\")]\n-    run_mode(\"ui-windows\", \"ui\");\n-    #[cfg(not(target_os = \"windows\"))]\n-    run_mode(\"ui-posix\", \"ui\");\n+    #[cfg(target_os = \"windows\")] run_mode(\"ui-windows\", \"ui\");\n+    #[cfg(not(target_os = \"windows\"))] run_mode(\"ui-posix\", \"ui\");\n }"}, {"sha": "378d14972aa9e39658d1e2d8cc05563494994a64", "filename": "tests/dogfood.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -24,7 +24,9 @@ fn dogfood() {\n     let mut s = String::new();\n     s.push_str(\" -L target/debug/\");\n     s.push_str(\" -L target/debug/deps\");\n-    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dwarnings -Dclippy_pedantic -Dclippy -Dclippy_internal\");\n+    s.push_str(\n+        \" -Zextra-plugins=clippy -Ltarget_recur/debug -Dwarnings -Dclippy_pedantic -Dclippy -Dclippy_internal\",\n+    );\n     config.target_rustcflags = Some(s);\n     if let Ok(name) = var(\"TESTNAME\") {\n         config.filter = Some(name.to_owned())"}, {"sha": "685715a111c35686e3e062dbec732f1cc1d5478d", "filename": "tests/issue-825.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fissue-825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fissue-825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fissue-825.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -6,9 +6,10 @@\n // this should compile in a reasonable amount of time\n fn rust_type_id(name: &str) {\n     if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] ||\n-       \"u32\" == &name[..] || \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] ||\n-       \"i16\" == &name[..] || \"i32\" == &name[..] ||\n-       \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..] {\n+        \"u32\" == &name[..] || \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] ||\n+        \"i16\" == &name[..] || \"i32\" == &name[..] ||\n+        \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..]\n+    {\n         unreachable!();\n     }\n }"}, {"sha": "2f9a61ed768b95d9ab9152543786e37d8553355a", "filename": "tests/matches.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -19,14 +19,28 @@ fn test_overlapping() {\n     assert_eq!(None, overlapping::<u8>(&[]));\n     assert_eq!(None, overlapping(&[sp(1, Bound::Included(4))]));\n     assert_eq!(None, overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))]));\n-    assert_eq!(None,\n-               overlapping(&[sp(1, Bound::Included(4)),\n-                             sp(5, Bound::Included(6)),\n-                             sp(10, Bound::Included(11))]));\n-    assert_eq!(Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n-               overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))]));\n-    assert_eq!(Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n-               overlapping(&[sp(1, Bound::Included(4)),\n-                             sp(5, Bound::Included(6)),\n-                             sp(6, Bound::Included(11))]));\n+    assert_eq!(\n+        None,\n+        overlapping(\n+            &[\n+                sp(1, Bound::Included(4)),\n+                sp(5, Bound::Included(6)),\n+                sp(10, Bound::Included(11)),\n+            ],\n+        )\n+    );\n+    assert_eq!(\n+        Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n+        overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))])\n+    );\n+    assert_eq!(\n+        Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n+        overlapping(\n+            &[\n+                sp(1, Bound::Included(4)),\n+                sp(5, Bound::Included(6)),\n+                sp(6, Bound::Included(11)),\n+            ],\n+        )\n+    );\n }"}, {"sha": "a669b6f9477685a8df2a2c6a88c7da004bb92c90", "filename": "tests/needless_continue_helpers.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fneedless_continue_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b6b3355efa33c797f4a37afb2f516531ad581/tests%2Fneedless_continue_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fneedless_continue_helpers.rs?ref=b25b6b3355efa33c797f4a37afb2f516531ad581", "patch": "@@ -86,4 +86,3 @@ fn test_erode_block() {\n     println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n     assert_eq!(expected, got);\n }\n-"}]}