{"sha": "97f3eeec8216d7155c24674b9be55e7c672bcae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZjNlZWVjODIxNmQ3MTU1YzI0Njc0YjliZTU1ZTdjNjcyYmNhZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-07T00:03:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-07T00:03:23Z"}, "message": "Auto merge of #55617 - oli-obk:stacker, r=nagisa,oli-obk\n\nPrevent compiler stack overflow for deeply recursive code\n\nI was unable to write a test that\n\n1. runs in under 1s\n2. overflows on my machine without this patch\n\nThe following reproduces the issue, but I don't think it's sensible to include a test that takes 30s to compile. We can now easily squash newly appearing overflows by the strategic insertion of calls to `ensure_sufficient_stack`.\n\n```rust\n// compile-pass\n\n#![recursion_limit=\"1000000\"]\n\nmacro_rules! chain {\n    (EE $e:expr) => {$e.sin()};\n    (RECURSE $i:ident $e:expr) => {chain!($i chain!($i chain!($i chain!($i $e))))};\n    (Z $e:expr) => {chain!(RECURSE EE $e)};\n    (Y $e:expr) => {chain!(RECURSE Z $e)};\n    (X $e:expr) => {chain!(RECURSE Y $e)};\n    (A $e:expr) => {chain!(RECURSE X $e)};\n    (B $e:expr) => {chain!(RECURSE A $e)};\n    (C $e:expr) => {chain!(RECURSE B $e)};\n    // causes overflow on x86_64 linux\n    // less than 1 second until overflow on test machine\n    // after overflow has been fixed, takes 30s to compile :/\n    (D $e:expr) => {chain!(RECURSE C $e)};\n    (E $e:expr) => {chain!(RECURSE D $e)};\n    (F $e:expr) => {chain!(RECURSE E $e)};\n    // more than 10 seconds\n    (G $e:expr) => {chain!(RECURSE F $e)};\n    (H $e:expr) => {chain!(RECURSE G $e)};\n    (I $e:expr) => {chain!(RECURSE H $e)};\n    (J $e:expr) => {chain!(RECURSE I $e)};\n    (K $e:expr) => {chain!(RECURSE J $e)};\n    (L $e:expr) => {chain!(RECURSE L $e)};\n}\n\nfn main() {\n    let x = chain!(D 42.0_f32);\n}\n```\n\nfixes #55471\nfixes #41884\nfixes #40161\nfixes #34844\nfixes #32594\n\ncc @alexcrichton @rust-lang/compiler\n\nI looked at all code that checks the recursion limit and inserted stack growth calls where appropriate.", "tree": {"sha": "5e5b22df21838a464ae5cf900d0b4a27855edc3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e5b22df21838a464ae5cf900d0b4a27855edc3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f3eeec8216d7155c24674b9be55e7c672bcae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f3eeec8216d7155c24674b9be55e7c672bcae3", "html_url": "https://github.com/rust-lang/rust/commit/97f3eeec8216d7155c24674b9be55e7c672bcae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f3eeec8216d7155c24674b9be55e7c672bcae3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29457dd92c5c754027c18b28c9e1307a345aafec", "url": "https://api.github.com/repos/rust-lang/rust/commits/29457dd92c5c754027c18b28c9e1307a345aafec", "html_url": "https://github.com/rust-lang/rust/commit/29457dd92c5c754027c18b28c9e1307a345aafec"}, {"sha": "935a05f1beaa5ed872e66e521e510bba61509b48", "url": "https://api.github.com/repos/rust-lang/rust/commits/935a05f1beaa5ed872e66e521e510bba61509b48", "html_url": "https://github.com/rust-lang/rust/commit/935a05f1beaa5ed872e66e521e510bba61509b48"}], "stats": {"total": 798, "additions": 447, "deletions": 351}, "files": [{"sha": "375e567222965bf24ad219987791de0b8a4126a6", "filename": "Cargo.lock", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -2639,6 +2639,15 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"psm\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"659ecfea2142a458893bb7673134bad50b752fea932349c213d6a23874ce3aa7\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"publicsuffix\"\n version = \"1.5.3\"\n@@ -3708,6 +3717,7 @@ dependencies = [\n  \"serialize\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n+ \"stacker\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -4669,6 +4679,19 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n \n+[[package]]\n+name = \"stacker\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"32c2467b8abbb417e4e62fd62229719b9c9d77714a7fa989f1afad16ba9c9743\"\n+dependencies = [\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"psm\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"std\"\n version = \"0.0.0\""}, {"sha": "251faf6af006d5593da79d0f4d88f53e537e2b89", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 191, "deletions": 176, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -3,6 +3,7 @@ use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericAr\n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -20,192 +21,206 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n-        let kind = match e.kind {\n-            ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n-            ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-            ExprKind::Repeat(ref expr, ref count) => {\n-                let expr = self.lower_expr(expr);\n-                let count = self.lower_anon_const(count);\n-                hir::ExprKind::Repeat(expr, count)\n-            }\n-            ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-            ExprKind::Call(ref f, ref args) => {\n-                let f = self.lower_expr(f);\n-                hir::ExprKind::Call(f, self.lower_exprs(args))\n-            }\n-            ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.arena.alloc(self.lower_path_segment(\n-                    e.span,\n-                    seg,\n-                    ParamMode::Optional,\n-                    0,\n-                    ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::disallowed(),\n-                    None,\n-                ));\n-                let args = self.lower_exprs(args);\n-                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n-            }\n-            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                let binop = self.lower_binop(binop);\n-                let lhs = self.lower_expr(lhs);\n-                let rhs = self.lower_expr(rhs);\n-                hir::ExprKind::Binary(binop, lhs, rhs)\n-            }\n-            ExprKind::Unary(op, ref ohs) => {\n-                let op = self.lower_unop(op);\n-                let ohs = self.lower_expr(ohs);\n-                hir::ExprKind::Unary(op, ohs)\n-            }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n-            ExprKind::Cast(ref expr, ref ty) => {\n-                let expr = self.lower_expr(expr);\n-                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Cast(expr, ty)\n-            }\n-            ExprKind::Type(ref expr, ref ty) => {\n-                let expr = self.lower_expr(expr);\n-                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                hir::ExprKind::Type(expr, ty)\n-            }\n-            ExprKind::AddrOf(k, m, ref ohs) => {\n-                let ohs = self.lower_expr(ohs);\n-                hir::ExprKind::AddrOf(k, m, ohs)\n-            }\n-            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n-            ExprKind::If(ref cond, ref then, ref else_opt) => {\n-                self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n-            }\n-            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n-            }),\n-            ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprKind::Loop(this.lower_block(body, false), opt_label, hir::LoopSource::Loop)\n-            }),\n-            ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n-            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n-                self.lower_expr(expr),\n-                self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n-                hir::MatchSource::Normal,\n-            ),\n-            ExprKind::Async(capture_clause, closure_node_id, ref block) => self.make_async_expr(\n-                capture_clause,\n-                closure_node_id,\n-                None,\n-                block.span,\n-                hir::AsyncGeneratorKind::Block,\n-                |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-            ),\n-            ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n-            ExprKind::Closure(\n-                capture_clause,\n-                asyncness,\n-                movability,\n-                ref decl,\n-                ref body,\n-                fn_decl_span,\n-            ) => {\n-                if let Async::Yes { closure_id, .. } = asyncness {\n-                    self.lower_expr_async_closure(\n-                        capture_clause,\n-                        closure_id,\n-                        decl,\n-                        body,\n-                        fn_decl_span,\n+        ensure_sufficient_stack(|| {\n+            let kind = match e.kind {\n+                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n+                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::Repeat(ref expr, ref count) => {\n+                    let expr = self.lower_expr(expr);\n+                    let count = self.lower_anon_const(count);\n+                    hir::ExprKind::Repeat(expr, count)\n+                }\n+                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(ref f, ref args) => {\n+                    let f = self.lower_expr(f);\n+                    hir::ExprKind::Call(f, self.lower_exprs(args))\n+                }\n+                ExprKind::MethodCall(ref seg, ref args) => {\n+                    let hir_seg = self.arena.alloc(self.lower_path_segment(\n+                        e.span,\n+                        seg,\n+                        ParamMode::Optional,\n+                        0,\n+                        ParenthesizedGenericArgs::Err,\n+                        ImplTraitContext::disallowed(),\n+                        None,\n+                    ));\n+                    let args = self.lower_exprs(args);\n+                    hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n+                }\n+                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                    let binop = self.lower_binop(binop);\n+                    let lhs = self.lower_expr(lhs);\n+                    let rhs = self.lower_expr(rhs);\n+                    hir::ExprKind::Binary(binop, lhs, rhs)\n+                }\n+                ExprKind::Unary(op, ref ohs) => {\n+                    let op = self.lower_unop(op);\n+                    let ohs = self.lower_expr(ohs);\n+                    hir::ExprKind::Unary(op, ohs)\n+                }\n+                ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n+                ExprKind::Cast(ref expr, ref ty) => {\n+                    let expr = self.lower_expr(expr);\n+                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                    hir::ExprKind::Cast(expr, ty)\n+                }\n+                ExprKind::Type(ref expr, ref ty) => {\n+                    let expr = self.lower_expr(expr);\n+                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                    hir::ExprKind::Type(expr, ty)\n+                }\n+                ExprKind::AddrOf(k, m, ref ohs) => {\n+                    let ohs = self.lower_expr(ohs);\n+                    hir::ExprKind::AddrOf(k, m, ohs)\n+                }\n+                ExprKind::Let(ref pat, ref scrutinee) => {\n+                    self.lower_expr_let(e.span, pat, scrutinee)\n+                }\n+                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                    self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n+                }\n+                ExprKind::While(ref cond, ref body, opt_label) => self\n+                    .with_loop_scope(e.id, |this| {\n+                        this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n+                    }),\n+                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    hir::ExprKind::Loop(\n+                        this.lower_block(body, false),\n+                        opt_label,\n+                        hir::LoopSource::Loop,\n                     )\n-                } else {\n-                    self.lower_expr_closure(capture_clause, movability, decl, body, fn_decl_span)\n+                }),\n+                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                    self.lower_expr(expr),\n+                    self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n+                    hir::MatchSource::Normal,\n+                ),\n+                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n+                    .make_async_expr(\n+                        capture_clause,\n+                        closure_node_id,\n+                        None,\n+                        block.span,\n+                        hir::AsyncGeneratorKind::Block,\n+                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                    ),\n+                ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n+                ExprKind::Closure(\n+                    capture_clause,\n+                    asyncness,\n+                    movability,\n+                    ref decl,\n+                    ref body,\n+                    fn_decl_span,\n+                ) => {\n+                    if let Async::Yes { closure_id, .. } = asyncness {\n+                        self.lower_expr_async_closure(\n+                            capture_clause,\n+                            closure_id,\n+                            decl,\n+                            body,\n+                            fn_decl_span,\n+                        )\n+                    } else {\n+                        self.lower_expr_closure(\n+                            capture_clause,\n+                            movability,\n+                            decl,\n+                            body,\n+                            fn_decl_span,\n+                        )\n+                    }\n                 }\n-            }\n-            ExprKind::Block(ref blk, opt_label) => {\n-                hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n-            }\n-            ExprKind::Assign(ref el, ref er, span) => {\n-                hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n-            }\n-            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                self.lower_binop(op),\n-                self.lower_expr(el),\n-                self.lower_expr(er),\n-            ),\n-            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(self.lower_expr(el), ident),\n-            ExprKind::Index(ref el, ref er) => {\n-                hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n-            }\n-            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n-                self.lower_expr_range_closed(e.span, e1, e2)\n-            }\n-            ExprKind::Range(ref e1, ref e2, lims) => {\n-                self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n-            }\n-            ExprKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    e.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::ExprKind::Path(qpath)\n-            }\n-            ExprKind::Break(opt_label, ref opt_expr) => {\n-                let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n-                hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n-            }\n-            ExprKind::Continue(opt_label) => {\n-                hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n-            }\n-            ExprKind::Ret(ref e) => {\n-                let e = e.as_ref().map(|x| self.lower_expr(x));\n-                hir::ExprKind::Ret(e)\n-            }\n-            ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_asm(asm),\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n-                hir::ExprKind::Struct(\n-                    self.arena.alloc(self.lower_qpath(\n+                ExprKind::Block(ref blk, opt_label) => {\n+                    hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n+                }\n+                ExprKind::Assign(ref el, ref er, span) => {\n+                    hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n+                }\n+                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(op),\n+                    self.lower_expr(el),\n+                    self.lower_expr(er),\n+                ),\n+                ExprKind::Field(ref el, ident) => hir::ExprKind::Field(self.lower_expr(el), ident),\n+                ExprKind::Index(ref el, ref er) => {\n+                    hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n+                }\n+                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                    self.lower_expr_range_closed(e.span, e1, e2)\n+                }\n+                ExprKind::Range(ref e1, ref e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                }\n+                ExprKind::Path(ref qself, ref path) => {\n+                    let qpath = self.lower_qpath(\n                         e.id,\n-                        &None,\n+                        qself,\n                         path,\n                         ParamMode::Optional,\n                         ImplTraitContext::disallowed(),\n-                    )),\n-                    self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n-                    maybe_expr,\n-                )\n-            }\n-            ExprKind::Paren(ref ex) => {\n-                let mut ex = self.lower_expr_mut(ex);\n-                // Include parens in span, but only if it is a super-span.\n-                if e.span.contains(ex.span) {\n-                    ex.span = e.span;\n+                    );\n+                    hir::ExprKind::Path(qpath)\n+                }\n+                ExprKind::Break(opt_label, ref opt_expr) => {\n+                    let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                }\n+                ExprKind::Continue(opt_label) => {\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                }\n+                ExprKind::Ret(ref e) => {\n+                    let e = e.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Ret(e)\n+                }\n+                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_asm(asm),\n+                ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n+                    let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Struct(\n+                        self.arena.alloc(self.lower_qpath(\n+                            e.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        )),\n+                        self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n+                        maybe_expr,\n+                    )\n+                }\n+                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Err => hir::ExprKind::Err,\n+                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+                ExprKind::Paren(ref ex) => {\n+                    let mut ex = self.lower_expr_mut(ex);\n+                    // Include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = e.span;\n+                    }\n+                    // Merge attributes into the inner expression.\n+                    let mut attrs = e.attrs.clone();\n+                    attrs.extend::<Vec<_>>(ex.attrs.into());\n+                    ex.attrs = attrs;\n+                    return ex;\n                 }\n-                // Merge attributes into the inner expression.\n-                let mut attrs = e.attrs.clone();\n-                attrs.extend::<Vec<_>>(ex.attrs.into());\n-                ex.attrs = attrs;\n-                return ex;\n-            }\n-\n-            ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n \n-            ExprKind::Err => hir::ExprKind::Err,\n+                // Desugar `ExprForLoop`\n+                // from: `[opt_ident]: for <pat> in <head> <body>`\n+                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                }\n+                ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n+            };\n \n-            // Desugar `ExprForLoop`\n-            // from: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                return self.lower_expr_for(e, pat, head, body, opt_label);\n+            hir::Expr {\n+                hir_id: self.lower_node_id(e.id),\n+                kind,\n+                span: e.span,\n+                attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n             }\n-            ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-            ExprKind::MacCall(_) => panic!(\"Shouldn't exist here\"),\n-        };\n-\n-        hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            kind,\n-            span: e.span,\n-            attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n-        }\n+        })\n     }\n \n     fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {"}, {"sha": "d54ad2036d5c616fe82d8217a105d1fe570a15ed", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -2,83 +2,89 @@ use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        let node = match p.kind {\n-            PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                node\n-            }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-            PatKind::TupleStruct(ref path, ref pats) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-            }\n-            PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n-            }\n-            PatKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::PatKind::Path(qpath)\n-            }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n+        ensure_sufficient_stack(|| {\n+            let node = match p.kind {\n+                PatKind::Wild => hir::PatKind::Wild,\n+                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                    node\n+                }\n+                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+                PatKind::TupleStruct(ref path, ref pats) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n+                }\n+                PatKind::Or(ref pats) => hir::PatKind::Or(\n+                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                ),\n+                PatKind::Path(ref qself, ref path) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        qself,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    hir::PatKind::Path(qpath)\n+                }\n+                PatKind::Struct(ref path, ref fields, etc) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n \n-                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                    hir_id: self.next_id(),\n-                    ident: f.ident,\n-                    pat: self.lower_pat(&f.pat),\n-                    is_shorthand: f.is_shorthand,\n-                    span: f.span,\n-                }));\n-                hir::PatKind::Struct(qpath, fs, etc)\n-            }\n-            PatKind::Tuple(ref pats) => {\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                hir::PatKind::Tuple(pats, ddpos)\n-            }\n-            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                e1.as_deref().map(|e| self.lower_expr(e)),\n-                e2.as_deref().map(|e| self.lower_expr(e)),\n-                self.lower_range_end(end, e2.is_some()),\n-            ),\n-            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-            PatKind::Rest => {\n-                // If we reach here the `..` pattern is not semantically allowed.\n-                self.ban_illegal_rest_pat(p.span)\n-            }\n-            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-            PatKind::MacCall(_) => panic!(\"Shouldn't exist here\"),\n-        };\n+                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat: self.lower_pat(&f.pat),\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n+                    }));\n+                    hir::PatKind::Struct(qpath, fs, etc)\n+                }\n+                PatKind::Tuple(ref pats) => {\n+                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                    hir::PatKind::Tuple(pats, ddpos)\n+                }\n+                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n+                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                    hir::PatKind::Range(\n+                        e1.as_deref().map(|e| self.lower_expr(e)),\n+                        e2.as_deref().map(|e| self.lower_expr(e)),\n+                        self.lower_range_end(end, e2.is_some()),\n+                    )\n+                }\n+                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+                PatKind::Rest => {\n+                    // If we reach here the `..` pattern is not semantically allowed.\n+                    self.ban_illegal_rest_pat(p.span)\n+                }\n+                // FIXME: consider not using recursion to lower this.\n+                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n+            };\n \n-        self.pat_with_node_id_of(p, node)\n+            self.pat_with_node_id_of(p, node)\n+        })\n     }\n \n     fn lower_pat_tuple("}, {"sha": "f543f8051a44b50d2fba1a1cb70f3d0361d344fe", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -28,6 +28,7 @@ rustc_index = { path = \"../librustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n measureme = \"0.7.1\"\n libc = \"0.2\"\n+stacker = \"0.1.6\"\n \n [dependencies.parking_lot]\n version = \"0.10\""}, {"sha": "9164734783c93ad43bf1ce981cc94613208eb001", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -80,6 +80,7 @@ pub mod stable_set;\n #[macro_use]\n pub mod stable_hasher;\n pub mod sharded;\n+pub mod stack;\n pub mod sync;\n pub mod thin_vec;\n pub mod tiny_list;"}, {"sha": "a4964b7aa0cc8c95f72f9f90807beb89da952d98", "filename": "src/librustc_data_structures/stack.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_data_structures%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstack.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -0,0 +1,17 @@\n+// This is the amount of bytes that need to be left on the stack before increasing the size.\n+// It must be at least as large as the stack required by any code that does not call\n+// `ensure_sufficient_stack`.\n+const RED_ZONE: usize = 100 * 1024; // 100k\n+\n+// Only the first stack that is pushed, grows exponentially (2^n * STACK_PER_RECURSION) from then\n+// on. This flag has performance relevant characteristics. Don't set it too high.\n+const STACK_PER_RECURSION: usize = 1 * 1024 * 1024; // 1MB\n+\n+/// Grows the stack on demand to prevent stack overflow. Call this in strategic locations\n+/// to \"break up\" recursive calls. E.g. almost any call to `visit_expr` or equivalent can benefit\n+/// from this.\n+///\n+/// Should not be sprinkled around carelessly, as it causes a little bit of overhead.\n+pub fn ensure_sufficient_stack<R>(f: impl FnOnce() -> R) -> R {\n+    stacker::maybe_grow(RED_ZONE, STACK_PER_RECURSION, f)\n+}"}, {"sha": "0797ab33827fd63e79e4b3ece79bc40a29589742", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -81,14 +81,7 @@ pub fn create_session(\n     (Lrc::new(sess), Lrc::new(codegen_backend), source_map)\n }\n \n-// Temporarily have stack size set to 32MB to deal with various crates with long method\n-// chains or deep syntax trees, except when on Haiku.\n-// FIXME(oli-obk): get https://github.com/rust-lang/rust/pull/55617 the finish line\n-#[cfg(not(target_os = \"haiku\"))]\n-const STACK_SIZE: usize = 32 * 1024 * 1024;\n-\n-#[cfg(target_os = \"haiku\")]\n-const STACK_SIZE: usize = 16 * 1024 * 1024;\n+const STACK_SIZE: usize = 8 * 1024 * 1024;\n \n fn get_stack_size() -> Option<usize> {\n     // FIXME: Hacks on hacks. If the env is trying to override the stack size"}, {"sha": "d1b5eed921bb3fa06992b5dafe3c2456110ebc52", "filename": "src/librustc_middle/ty/inhabitedness/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finhabitedness%2Fmod.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -6,6 +6,7 @@ use crate::ty::TyKind::*;\n use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n \n mod def_id_forest;\n \n@@ -196,7 +197,9 @@ impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n         match self.kind {\n-            Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n+            Adt(def, substs) => {\n+                ensure_sufficient_stack(|| def.uninhabited_from(tcx, substs, param_env))\n+            }\n \n             Never => DefIdForest::full(tcx),\n "}, {"sha": "c711de9476e9d9e0a3ff6dcff495d0c79f34d52b", "filename": "src/librustc_middle/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fplumbing.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -68,7 +68,9 @@ impl QueryContext for TyCtxt<'tcx> {\n             };\n \n             // Use the `ImplicitCtxt` while we execute the query.\n-            tls::enter_context(&new_icx, |_| compute(*self))\n+            tls::enter_context(&new_icx, |_| {\n+                rustc_data_structures::stack::ensure_sufficient_stack(|| compute(*self))\n+            })\n         })\n     }\n }"}, {"sha": "3d79825473588170daf4504f6ebea57c3bd71e77", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -369,7 +369,9 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = Some(check_recursion_limit(tcx, instance, recursion_depths));\n             check_type_length_limit(tcx, instance);\n \n-            collect_neighbours(tcx, instance, &mut neighbors);\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                collect_neighbours(tcx, instance, &mut neighbors);\n+            });\n         }\n         MonoItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n@@ -1146,7 +1148,9 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<Mon\n         Some(GlobalAlloc::Memory(alloc)) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations().values() {\n-                collect_miri(tcx, inner, output);\n+                rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                    collect_miri(tcx, inner, output);\n+                });\n             }\n         }\n         Some(GlobalAlloc::Function(fn_instance)) => {"}, {"sha": "d3304c71e61e8915078fd94b5b21d6897060b988", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -3,6 +3,7 @@\n use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n@@ -21,7 +22,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_temp(block, temp_lifetime, expr, mutability)\n+        //\n+        // this is the only place in mir building that we need to truly need to worry about\n+        // infinite recursion. Everything else does recurse, too, but it always gets broken up\n+        // at some point by inserting an intermediate temporary\n+        ensure_sufficient_stack(|| self.expr_as_temp(block, temp_lifetime, expr, mutability))\n     }\n \n     fn expr_as_temp("}, {"sha": "bf0e1ed7b89c3f065d08d3e32b18e8c07b83486c", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -18,6 +18,7 @@ use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::InferCtxtExt;\n use rustc_ast::ast::Ident;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -261,7 +262,7 @@ where\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n     let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n-    let result = normalizer.fold(value);\n+    let result = ensure_sufficient_stack(|| normalizer.fold(value));\n     debug!(\n         \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n         depth,"}, {"sha": "3b985a4b150faa7b447cb7b764d82b28ac805b46", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -7,6 +7,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_infer::traits::Normalized;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::Subst;\n@@ -131,7 +132,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                                 ty\n                             );\n                         }\n-                        let folded_ty = self.fold_ty(concrete_ty);\n+                        let folded_ty = ensure_sufficient_stack(|| self.fold_ty(concrete_ty));\n                         self.anon_depth -= 1;\n                         folded_ty\n                     }"}, {"sha": "27d3b2ec9cb8651812a934a13f64ca9dfcf7690e", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 104, "deletions": 86, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -37,6 +37,7 @@ use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_ast::attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items;\n@@ -2365,13 +2366,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.infcx.commit_unconditionally(|_| {\n                     let (skol_ty, _) = self.infcx.replace_bound_vars_with_placeholders(&ty);\n                     let Normalized { value: normalized_ty, mut obligations } =\n-                        project::normalize_with_depth(\n-                            self,\n-                            param_env,\n-                            cause.clone(),\n-                            recursion_depth,\n-                            &skol_ty,\n-                        );\n+                        ensure_sufficient_stack(|| {\n+                            project::normalize_with_depth(\n+                                self,\n+                                param_env,\n+                                cause.clone(),\n+                                recursion_depth,\n+                                &skol_ty,\n+                            )\n+                        });\n                     let skol_obligation = predicate_for_trait_def(\n                         self.tcx(),\n                         param_env,\n@@ -2525,13 +2528,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            self.collect_predicates_for_types(\n-                obligation.param_env,\n-                cause,\n-                obligation.recursion_depth + 1,\n-                trait_def,\n-                nested,\n-            )\n+            ensure_sufficient_stack(|| {\n+                self.collect_predicates_for_types(\n+                    obligation.param_env,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    trait_def,\n+                    nested,\n+                )\n+            })\n         } else {\n             vec![]\n         };\n@@ -2568,38 +2573,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         nested: ty::Binder<Vec<Ty<'tcx>>>,\n     ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n         debug!(\"vtable_auto_impl: nested={:?}\", nested);\n+        ensure_sufficient_stack(|| {\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+            let mut obligations = self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def_id,\n+                nested,\n+            );\n \n-        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-        let mut obligations = self.collect_predicates_for_types(\n-            obligation.param_env,\n-            cause,\n-            obligation.recursion_depth + 1,\n-            trait_def_id,\n-            nested,\n-        );\n-\n-        let trait_obligations: Vec<PredicateObligation<'_>> =\n-            self.infcx.commit_unconditionally(|_| {\n-                let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                let (trait_ref, _) =\n-                    self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n-                let cause = obligation.derived_cause(ImplDerivedObligation);\n-                self.impl_or_trait_obligations(\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                    trait_def_id,\n-                    &trait_ref.substs,\n-                )\n-            });\n+            let trait_obligations: Vec<PredicateObligation<'_>> =\n+                self.infcx.commit_unconditionally(|_| {\n+                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+                    let (trait_ref, _) =\n+                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                    let cause = obligation.derived_cause(ImplDerivedObligation);\n+                    self.impl_or_trait_obligations(\n+                        cause,\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        trait_def_id,\n+                        &trait_ref.substs,\n+                    )\n+                });\n \n-        // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n-        // predicate as usual.  It won't have any effect since auto traits are coinductive.\n-        obligations.extend(trait_obligations);\n+            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n+            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n+            obligations.extend(trait_obligations);\n \n-        debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n+            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n \n-        VtableAutoImplData { trait_def_id, nested: obligations }\n+            VtableAutoImplData { trait_def_id, nested: obligations }\n+        })\n     }\n \n     fn confirm_impl_candidate(\n@@ -2615,13 +2621,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            self.vtable_impl(\n-                impl_def_id,\n-                substs,\n-                cause,\n-                obligation.recursion_depth + 1,\n-                obligation.param_env,\n-            )\n+            ensure_sufficient_stack(|| {\n+                self.vtable_impl(\n+                    impl_def_id,\n+                    substs,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                )\n+            })\n         })\n     }\n \n@@ -2734,13 +2742,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         )\n         .map_bound(|(trait_ref, _)| trait_ref);\n \n-        let Normalized { value: trait_ref, obligations } = project::normalize_with_depth(\n-            self,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            &trait_ref,\n-        );\n+        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n+            project::normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n \n         self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n@@ -2798,13 +2808,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n \n         let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = normalize_with_depth(\n-            self,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            &trait_ref,\n-        );\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n \n         debug!(\n             \"confirm_generator_candidate(generator_def_id={:?}, \\\n@@ -2843,13 +2855,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = normalize_with_depth(\n-            self,\n-            obligation.param_env,\n-            obligation.cause.clone(),\n-            obligation.recursion_depth + 1,\n-            &trait_ref,\n-        );\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n \n         debug!(\n             \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n@@ -3139,15 +3153,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(predicate_for_trait_def(\n-                    tcx,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.predicate.def_id(),\n-                    obligation.recursion_depth + 1,\n-                    a_last.expect_ty(),\n-                    &[b_last],\n-                ));\n+                nested.push(ensure_sufficient_stack(|| {\n+                    predicate_for_trait_def(\n+                        tcx,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.predicate.def_id(),\n+                        obligation.recursion_depth + 1,\n+                        a_last.expect_ty(),\n+                        &[b_last],\n+                    )\n+                }));\n             }\n \n             _ => bug!(),\n@@ -3208,13 +3224,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(), impl_substs);\n \n         let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =\n-            project::normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &impl_trait_ref,\n-            );\n+            ensure_sufficient_stack(|| {\n+                project::normalize_with_depth(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &impl_trait_ref,\n+                )\n+            });\n \n         debug!(\n             \"match_impl(impl_def_id={:?}, obligation={:?}, \\"}, {"sha": "76ff58d61a2574deaa44dac3e7d6d3ae5081a37a", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -191,10 +191,12 @@ fn dtorck_constraint_for_ty<'tcx>(\n \n         ty::Array(ety, _) | ty::Slice(ety) => {\n             // single-element containers, behave like their element\n-            dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety, constraints)?;\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety, constraints)\n+            })?;\n         }\n \n-        ty::Tuple(tys) => {\n+        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n             for ty in tys.iter() {\n                 dtorck_constraint_for_ty(\n                     tcx,\n@@ -205,13 +207,15 @@ fn dtorck_constraint_for_ty<'tcx>(\n                     constraints,\n                 )?;\n             }\n-        }\n+            Ok::<_, NoSolution>(())\n+        })?,\n \n-        ty::Closure(_, substs) => {\n+        ty::Closure(_, substs) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n             for ty in substs.as_closure().upvar_tys() {\n                 dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n             }\n-        }\n+            Ok::<_, NoSolution>(())\n+        })?,\n \n         ty::Generator(_, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored"}, {"sha": "1423f1db385fd6f6e9b678d70fe036926c6e3d22", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f3eeec8216d7155c24674b9be55e7c672bcae3/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=97f3eeec8216d7155c24674b9be55e7c672bcae3", "patch": "@@ -131,6 +131,7 @@ const WHITELIST: &[&str] = &[\n     \"polonius-engine\",\n     \"ppv-lite86\",\n     \"proc-macro2\",\n+    \"psm\",\n     \"punycode\",\n     \"quick-error\",\n     \"quote\",\n@@ -160,6 +161,7 @@ const WHITELIST: &[&str] = &[\n     \"sha-1\",\n     \"smallvec\",\n     \"stable_deref_trait\",\n+    \"stacker\",\n     \"syn\",\n     \"synstructure\",\n     \"tempfile\","}]}