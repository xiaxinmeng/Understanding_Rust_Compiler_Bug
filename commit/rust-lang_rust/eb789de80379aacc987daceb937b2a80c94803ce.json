{"sha": "eb789de80379aacc987daceb937b2a80c94803ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNzg5ZGU4MDM3OWFhY2M5ODdkYWNlYjkzN2IyYTgwYzk0ODAzY2U=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-01T17:38:40Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-04T21:40:21Z"}, "message": "Do MTWT resolution during lowering to HIR", "tree": {"sha": "6ea293a244bdddf02b5b8b82dd2fa8bea4d03a40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ea293a244bdddf02b5b8b82dd2fa8bea4d03a40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb789de80379aacc987daceb937b2a80c94803ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb789de80379aacc987daceb937b2a80c94803ce", "html_url": "https://github.com/rust-lang/rust/commit/eb789de80379aacc987daceb937b2a80c94803ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb789de80379aacc987daceb937b2a80c94803ce/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c15be8b5a28297ae58ea030adf49f265e41127", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c15be8b5a28297ae58ea030adf49f265e41127", "html_url": "https://github.com/rust-lang/rust/commit/68c15be8b5a28297ae58ea030adf49f265e41127"}], "stats": {"total": 242, "additions": 156, "deletions": 86}, "files": [{"sha": "676257e3100580af2cd496be1671ddb842da934b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -247,7 +247,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(..)) = def {\n                         if edef.variants.iter().any(|variant|\n-                            variant.name == ident.node.name\n+                            variant.name == ident.node.unhygienic_name\n                                 && variant.kind() == VariantKind::Unit\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,"}, {"sha": "5d4b4d77bbcbc7466fb736fd664079e4a05d7054", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -1596,7 +1596,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 name));\n-                } else {\n+                } else if name != \"self\" {\n                     self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n                         format!(\"unused variable: `{}`\", name));\n                 }"}, {"sha": "23fd1b83e76a7c38a31766f28c4e80e28b696906", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -14,7 +14,6 @@ use middle::ty;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use syntax::ext::mtwt;\n use rustc_front::hir;\n use rustc_front::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n@@ -27,8 +26,8 @@ pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n-    pat_bindings_hygienic(dm, pat, |_bm, p_id, _s, path1| {\n-        map.insert(mtwt::resolve(path1.node), p_id);\n+    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n+        map.insert(path1.node, p_id);\n     });\n     map\n }\n@@ -124,9 +123,8 @@ pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n         true\n     });\n }\n-\n-pub fn pat_bindings_hygienic<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Ident>),\n+pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n+    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<hir::Ident>),\n {\n     walk_pat(pat, |p| {\n         match p.node {\n@@ -214,7 +212,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n     tcx.with_path(id, |path| hir::Path {\n         global: false,\n         segments: path.last().map(|elem| hir::PathSegment {\n-            identifier: ast::Ident::with_empty_ctxt(elem.name()),\n+            identifier: hir::Ident::from_name(elem.name()),\n             parameters: hir::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,"}, {"sha": "b37b30703101a1b2986689529945204ff678aef8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -426,7 +426,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n     fn expression_label(ex: &hir::Expr) -> Option<ast::Name> {\n         match ex.node {\n             hir::ExprWhile(_, _, Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some(label.name),\n+            hir::ExprLoop(_, Some(label)) => Some(label.unhygienic_name),\n             _ => None,\n         }\n     }"}, {"sha": "69e065b3e8f971d1b2f1c5fbc468f3dfa06d8612", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -112,6 +112,13 @@ pub fn compile_input(sess: Session,\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate)));\n+\n+        // Discard MTWT tables that aren't required past lowering to HIR.\n+        if !sess.opts.debugging_opts.keep_mtwt_tables &&\n+           !sess.opts.debugging_opts.save_analysis {\n+            syntax::ext::mtwt::clear_tables();\n+        }\n+\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = make_map(&sess, &mut hir_forest);\n \n@@ -704,12 +711,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"resolution\",\n              || resolve::resolve_crate(sess, &ast_map, make_glob_map));\n \n-    // Discard MTWT tables that aren't required past resolution.\n-    // FIXME: get rid of uses of MTWT tables in typeck, mir and trans and clear them\n-    if !sess.opts.debugging_opts.keep_mtwt_tables {\n-        // syntax::ext::mtwt::clear_tables();\n-    }\n-\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess, krate, &def_map.borrow()));"}, {"sha": "4f580c770f01ad36dd0cdc5b029e33a718c7e96a", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -12,7 +12,7 @@\n //! and returns a piece of the same type.\n \n use hir::*;\n-use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n use syntax::attr::ThinAttributesExt;\n use hir;"}, {"sha": "dd4d7e28444f883540c4ffd3cf9eb86c45c04e62", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -39,7 +39,7 @@ use intravisit::Visitor;\n use std::collections::BTreeMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n-use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n use syntax::attr::ThinAttributes;\n use syntax::owned_slice::OwnedSlice;\n@@ -50,7 +50,59 @@ use print::pprust;\n use util;\n \n use std::fmt;\n-use serialize::{Encodable, Encoder, Decoder};\n+use std::hash::{Hash, Hasher};\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+/// Identifier in HIR\n+#[derive(Clone, Copy, Eq)]\n+pub struct Ident {\n+    /// Hygienic name (renamed), should be used by default\n+    pub name: Name,\n+    /// Unhygienic name (original, not renamed), needed in few places in name resolution\n+    pub unhygienic_name: Name,\n+}\n+\n+impl Ident {\n+    pub fn from_name(name: Name) -> Ident {\n+        Ident { name: name, unhygienic_name: name }\n+    }\n+}\n+\n+impl PartialEq for Ident {\n+    fn eq(&self, other: &Ident) -> bool {\n+        self.name == other.name\n+    }\n+}\n+\n+impl Hash for Ident {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state)\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.name, f)\n+    }\n+}\n+\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, f)\n+    }\n+}\n+\n+impl Encodable for Ident {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.name.encode(s)\n+    }\n+}\n+\n+impl Decodable for Ident {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n+        Ok(Ident::from_name(try!(Name::decode(d))))\n+    }\n+}\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {"}, {"sha": "e93f5cbd0fb63c4f74686dc35e151f3288418ca4", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -26,7 +26,7 @@\n //! property.\n \n use syntax::abi::Abi;\n-use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name, Attribute};\n+use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Span;\n use hir::*;\n "}, {"sha": "62ed8b0416a11846d03c80643acf168ea95b33db", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -67,10 +67,11 @@ use std::collections::BTreeMap;\n use std::collections::HashMap;\n use syntax::ast::*;\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n+use syntax::ext::mtwt;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::parse::token::{self, str_to_ident};\n+use syntax::parse::token;\n use syntax::std_inject;\n use syntax::visit::{self, Visitor};\n \n@@ -86,7 +87,7 @@ pub struct LoweringContext<'a> {\n     // incrementing.\n     cached_id: Cell<u32>,\n     // Keep track of gensym'ed idents.\n-    gensym_cache: RefCell<HashMap<(NodeId, &'static str), Ident>>,\n+    gensym_cache: RefCell<HashMap<(NodeId, &'static str), hir::Ident>>,\n     // A copy of cached_id, but is also set to an id while it is being cached.\n     gensym_key: Cell<u32>,\n }\n@@ -123,23 +124,30 @@ impl<'a, 'hir> LoweringContext<'a> {\n         cached\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> Ident {\n+    fn str_to_ident(&self, s: &'static str) -> hir::Ident {\n         let cached_id = self.gensym_key.get();\n         if cached_id == 0 {\n-            return token::gensym_ident(s);\n+            return hir::Ident::from_name(token::gensym(s));\n         }\n \n         let cached = self.gensym_cache.borrow().contains_key(&(cached_id, s));\n         if cached {\n             self.gensym_cache.borrow()[&(cached_id, s)]\n         } else {\n-            let result = token::gensym_ident(s);\n+            let result = hir::Ident::from_name(token::gensym(s));\n             self.gensym_cache.borrow_mut().insert((cached_id, s), result);\n             result\n         }\n     }\n }\n \n+pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n+    hir::Ident {\n+        name: mtwt::resolve(ident),\n+        unhygienic_name: ident.name,\n+    }\n+}\n+\n pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n@@ -276,14 +284,22 @@ pub fn lower_variant(lctx: &LoweringContext, v: &Variant) -> P<hir::Variant> {\n     })\n }\n \n-pub fn lower_path(lctx: &LoweringContext, p: &Path) -> hir::Path {\n+// Path segments are usually unhygienic, hygienic path segments can occur only in\n+// identifier-like paths originating from `ExprPath`.\n+// Make life simpler for rustc_resolve by renaming only such segments.\n+pub fn lower_path_full(lctx: &LoweringContext, p: &Path, maybe_hygienic: bool) -> hir::Path {\n+    let maybe_hygienic = maybe_hygienic && !p.global && p.segments.len() == 1;\n     hir::Path {\n         global: p.global,\n         segments: p.segments\n                    .iter()\n                    .map(|&PathSegment { identifier, ref parameters }| {\n                        hir::PathSegment {\n-                           identifier: identifier,\n+                           identifier: if maybe_hygienic {\n+                               lower_ident(lctx, identifier)\n+                           } else {\n+                               hir::Ident::from_name(identifier.name)\n+                           },\n                            parameters: lower_path_parameters(lctx, parameters),\n                        }\n                    })\n@@ -292,6 +308,10 @@ pub fn lower_path(lctx: &LoweringContext, p: &Path) -> hir::Path {\n     }\n }\n \n+pub fn lower_path(lctx: &LoweringContext, p: &Path) -> hir::Path {\n+    lower_path_full(lctx, p, false)\n+}\n+\n pub fn lower_path_parameters(lctx: &LoweringContext,\n                              path_parameters: &PathParameters)\n                              -> hir::PathParameters {\n@@ -844,7 +864,7 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n             PatWild => hir::PatWild,\n             PatIdent(ref binding_mode, pth1, ref sub) => {\n                 hir::PatIdent(lower_binding_mode(lctx, binding_mode),\n-                              pth1,\n+                              respan(pth1.span, lower_ident(lctx, pth1.node)),\n                               sub.as_ref().map(|x| lower_pat(lctx, x)))\n             }\n             PatLit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n@@ -1138,10 +1158,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 hir::ExprIf(lower_expr(lctx, cond), lower_block(lctx, blk), else_opt)\n             }\n             ExprWhile(ref cond, ref body, opt_ident) => {\n-                hir::ExprWhile(lower_expr(lctx, cond), lower_block(lctx, body), opt_ident)\n+                hir::ExprWhile(lower_expr(lctx, cond), lower_block(lctx, body),\n+                               opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n             ExprLoop(ref body, opt_ident) => {\n-                hir::ExprLoop(lower_block(lctx, body), opt_ident)\n+                hir::ExprLoop(lower_block(lctx, body),\n+                              opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n             ExprMatch(ref expr, ref arms) => {\n                 hir::ExprMatch(lower_expr(lctx, expr),\n@@ -1176,16 +1198,20 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                e2.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             ExprPath(ref qself, ref path) => {\n-                let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n                         ty: lower_ty(lctx, ty),\n                         position: position,\n                     }\n                 });\n-                hir::ExprPath(qself, lower_path(lctx, path))\n+                hir::ExprPath(hir_qself, lower_path_full(lctx, path, qself.is_none()))\n             }\n-            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n-            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n+            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n+                respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n+            })),\n+            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n+                respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n+            })),\n             ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n             ExprInlineAsm(InlineAsm {\n                     ref inputs,\n@@ -1356,8 +1382,10 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n+                    let loop_expr = hir::ExprLoop(loop_block,\n+                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n                     // add attributes to the outer returned expr node\n-                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident), e.attrs.clone())\n+                    expr(lctx, e.span, loop_expr, e.attrs.clone())\n                 });\n             }\n \n@@ -1434,10 +1462,9 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = expr(lctx,\n-                                         e.span,\n-                                         hir::ExprLoop(loop_block, opt_ident),\n-                                         None);\n+                    let loop_expr = hir::ExprLoop(loop_block,\n+                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n+                    let loop_expr = expr(lctx, e.span, loop_expr, None);\n \n                     // `mut iter => { ... }`\n                     let iter_arm = {\n@@ -1593,7 +1620,7 @@ fn expr_call(lctx: &LoweringContext,\n     expr(lctx, span, hir::ExprCall(e, args), attrs)\n }\n \n-fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident,\n+fn expr_ident(lctx: &LoweringContext, span: Span, id: hir::Ident,\n               attrs: ThinAttributes) -> P<hir::Expr> {\n     expr_path(lctx, path_ident(span, id), attrs)\n }\n@@ -1641,7 +1668,7 @@ fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n fn stmt_let(lctx: &LoweringContext,\n             sp: Span,\n             mutbl: bool,\n-            ident: Ident,\n+            ident: hir::Ident,\n             ex: P<hir::Expr>,\n             attrs: ThinAttributes)\n             -> P<hir::Stmt> {\n@@ -1701,13 +1728,13 @@ fn pat_enum(lctx: &LoweringContext,\n     pat(lctx, span, pt)\n }\n \n-fn pat_ident(lctx: &LoweringContext, span: Span, ident: Ident) -> P<hir::Pat> {\n+fn pat_ident(lctx: &LoweringContext, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n     pat_ident_binding_mode(lctx, span, ident, hir::BindByValue(hir::MutImmutable))\n }\n \n fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           span: Span,\n-                          ident: Ident,\n+                          ident: hir::Ident,\n                           bm: hir::BindingMode)\n                           -> P<hir::Pat> {\n     let pat_ident = hir::PatIdent(bm,\n@@ -1731,21 +1758,21 @@ fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n     })\n }\n \n-fn path_ident(span: Span, id: Ident) -> hir::Path {\n+fn path_ident(span: Span, id: hir::Ident) -> hir::Path {\n     path(span, vec![id])\n }\n \n-fn path(span: Span, strs: Vec<Ident>) -> hir::Path {\n+fn path(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n     path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n }\n \n-fn path_global(span: Span, strs: Vec<Ident>) -> hir::Path {\n+fn path_global(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n     path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n }\n \n fn path_all(sp: Span,\n             global: bool,\n-            mut idents: Vec<Ident>,\n+            mut idents: Vec<hir::Ident>,\n             lifetimes: Vec<hir::Lifetime>,\n             types: Vec<P<hir::Ty>>,\n             bindings: Vec<P<hir::TypeBinding>>)\n@@ -1774,12 +1801,12 @@ fn path_all(sp: Span,\n     }\n }\n \n-fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<Ident> {\n+fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<hir::Ident> {\n     let mut v = Vec::new();\n     if let Some(s) = lctx.crate_root {\n-        v.push(str_to_ident(s));\n+        v.push(hir::Ident::from_name(token::intern(s)));\n     }\n-    v.extend(components.iter().map(|s| str_to_ident(s)));\n+    v.extend(components.iter().map(|s| hir::Ident::from_name(token::intern(s))));\n     return v;\n }\n "}, {"sha": "4dc08f7a0485acdc5c7dbe3fc0d3167efcdf36bd", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -12,7 +12,7 @@ use hir;\n use hir::*;\n use intravisit::{self, Visitor, FnKind};\n use syntax::ast_util;\n-use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::owned_slice::OwnedSlice;"}, {"sha": "90d9bcfffee7279d66094ae5642fe3626ad0f1f4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -170,9 +170,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n             });\n             for fieldpat in field_pats {\n                 if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node.name == fieldpat.node.name {\n-                        // FIXME: should this comparison really be done on the name?\n-                        // doing it on the ident will fail during compilation of libcore\n+                    if ident.node.unhygienic_name == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n                                               be removed\", ident.node))"}, {"sha": "08826013ebc3771a13529832cebea0c8755b1e96", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -21,7 +21,6 @@ use rustc::middle::ty::{self, VariantDef, Ty};\n use rustc::mir::repr::*;\n use rustc_front::hir;\n use rustc_front::util as hir_util;\n-use syntax::ext::mtwt;\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -500,8 +499,8 @@ fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<\n         None\n     } else {\n         map = FnvHashMap();\n-        pat_util::pat_bindings_hygienic(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n-            map.insert(mtwt::resolve(path.node), p_id);\n+        pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n+            map.insert(path.node, p_id);\n         });\n         Some(&map)\n     };"}, {"sha": "74fef6840065627d1db5a9c503a5992c653e584c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_front::hir;\n use syntax::ast;\n-use syntax::ext::mtwt;\n use syntax::ptr::P;\n \n /// When there are multiple patterns in a single arm, each one has its\n@@ -162,7 +161,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             {\n                 let id = match self.binding_map {\n                     None => pat.id,\n-                    Some(ref map) => map[&mtwt::resolve(ident.node)],\n+                    Some(ref map) => map[&ident.node.name],\n                 };\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {"}, {"sha": "d15b3a0ccf7533ca2dd9e92673ae3e10231964b3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -57,7 +57,7 @@ use rustc::lint;\n use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::pat_util::pat_bindings_hygienic;\n+use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n@@ -67,7 +67,6 @@ use syntax::ast;\n use syntax::ast::{CRATE_NODE_ID, Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ext::mtwt;\n use syntax::parse::token::{self, special_names, special_idents};\n use syntax::ptr::P;\n use syntax::codemap::{self, Span, Pos};\n@@ -2315,8 +2314,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        pat_bindings_hygienic(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n-            let name = mtwt::resolve(path1.node);\n+        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n+            let name = path1.node;\n             result.insert(name,\n                           BindingInfo {\n                               span: sp,\n@@ -2520,9 +2519,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let const_ok = mode == RefutableMode && at_rhs.is_none();\n \n                     let ident = path1.node;\n-                    let renamed = mtwt::resolve(ident);\n+                    let renamed = ident.name;\n \n-                    match self.resolve_bare_identifier_pattern(ident.name, pattern.span) {\n+                    match self.resolve_bare_identifier_pattern(ident.unhygienic_name,\n+                                                               pattern.span) {\n                         FoundStructOrEnumVariant(def, lp) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n                                    renamed);\n@@ -2911,15 +2911,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n-                          identifier: Ident,\n+                          identifier: hir::Ident,\n                           namespace: Namespace,\n                           check_ribs: bool)\n                           -> Option<LocalDef> {\n         // First, check to see whether the name is a primitive type.\n         if namespace == TypeNS {\n             if let Some(&prim_ty) = self.primitive_type_table\n                                         .primitive_types\n-                                        .get(&identifier.name) {\n+                                        .get(&identifier.unhygienic_name) {\n                 return Some(LocalDef::from_def(DefPrimTy(prim_ty)));\n             }\n         }\n@@ -2930,7 +2930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        self.resolve_item_by_name_in_lexical_scope(identifier.name, namespace)\n+        self.resolve_item_by_name_in_lexical_scope(identifier.unhygienic_name, namespace)\n             .map(LocalDef::from_def)\n     }\n \n@@ -3144,13 +3144,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_identifier_in_local_ribs(&mut self,\n-                                        ident: Ident,\n+                                        ident: hir::Ident,\n                                         namespace: Namespace)\n                                         -> Option<LocalDef> {\n         // Check the local set of ribs.\n         let (name, ribs) = match namespace {\n-            ValueNS => (mtwt::resolve(ident), &self.value_ribs),\n-            TypeNS => (ident.name, &self.type_ribs),\n+            ValueNS => (ident.name, &self.value_ribs),\n+            TypeNS => (ident.unhygienic_name, &self.type_ribs),\n         };\n \n         for (i, rib) in ribs.iter().enumerate().rev() {\n@@ -3551,17 +3551,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        let renamed = mtwt::resolve(label);\n-                        rib.bindings.insert(renamed, def_like);\n+                        rib.bindings.insert(label.name, def_like);\n                     }\n \n                     intravisit::walk_expr(this, expr);\n                 })\n             }\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                let renamed = mtwt::resolve(label.node);\n-                match self.search_label(renamed) {\n+                match self.search_label(label.node.name) {\n                     None => {\n                         resolve_error(self,\n                                       label.span,"}, {"sha": "b5d8fd71f74847b9190deeb8a3795323bee15fdf", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -228,7 +228,6 @@ use std::fmt;\n use std::rc::Rc;\n use rustc_front::hir;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n-use syntax::ext::mtwt;\n use syntax::codemap::Span;\n use rustc_front::fold::Folder;\n use syntax::ptr::P;\n@@ -478,7 +477,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 hir::PatIdent(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((mtwt::resolve(path.node), val.val));\n+                    bound_ptrs.push((path.node.name, val.val));\n                     &**inner\n                 },\n                 _ => break\n@@ -519,15 +518,15 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(&dm.borrow(), &*this) {\n-                        bound_ptrs.push((mtwt::resolve(path.node), val.val));\n+                        bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n                 hir::PatVec(ref before, Some(ref slice), ref after) => {\n                     if let hir::PatIdent(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n-                        bound_ptrs.push((mtwt::resolve(path.node), subslice_val));\n+                        bound_ptrs.push((path.node.name, subslice_val));\n                     }\n                 }\n                 _ => {}\n@@ -1527,8 +1526,8 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings_hygienic(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n-        let name = mtwt::resolve(path1.node);\n+    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+        let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();"}, {"sha": "d9080b8ae90d582120bad6362113fbbcefe237c2", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -47,9 +47,9 @@ pub fn create_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings_ident(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node) });\n+                                               name: Some(path1.node.unhygienic_name) });\n             scope_map.insert(node_id, fn_metadata);\n         })\n     }\n@@ -169,7 +169,7 @@ fn walk_pattern(cx: &CrateContext,\n             // scope stack and maybe introduce an artificial scope\n             if pat_util::pat_is_binding(&def_map.borrow(), &*pat) {\n \n-                let name = path1.node.name;\n+                let name = path1.node.unhygienic_name;\n \n                 // LLVM does not properly generate 'DW_AT_start_scope' fields\n                 // for variable DIEs. For this reason we have to introduce"}, {"sha": "b17790ac061fbce6a5ee5425a2de3660c20f2e96", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb789de80379aacc987daceb937b2a80c94803ce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=eb789de80379aacc987daceb937b2a80c94803ce", "patch": "@@ -26,7 +26,6 @@ use session::Session;\n use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n-use syntax::ext::mtwt;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n@@ -187,7 +186,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = *pcx.map.get(&mtwt::resolve(path.node)).unwrap();\n+            let canon_id = *pcx.map.get(&path.node.name).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);"}]}