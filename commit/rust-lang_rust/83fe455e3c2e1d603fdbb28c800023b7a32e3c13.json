{"sha": "83fe455e3c2e1d603fdbb28c800023b7a32e3c13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZmU0NTVlM2MyZTFkNjAzZmRiYjI4YzgwMDAyM2I3YTMyZTNjMTM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-07-09T08:18:40Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-07-16T07:27:05Z"}, "message": "debuginfo: Add python formatters that allow LLDB to print values with Rust syntax", "tree": {"sha": "7daa6f33173c92c1ed7286fdd3103481a4d921e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7daa6f33173c92c1ed7286fdd3103481a4d921e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83fe455e3c2e1d603fdbb28c800023b7a32e3c13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83fe455e3c2e1d603fdbb28c800023b7a32e3c13", "html_url": "https://github.com/rust-lang/rust/commit/83fe455e3c2e1d603fdbb28c800023b7a32e3c13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83fe455e3c2e1d603fdbb28c800023b7a32e3c13/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c35d513cea468b30759b4f78becf28f11a123c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c35d513cea468b30759b4f78becf28f11a123c0", "html_url": "https://github.com/rust-lang/rust/commit/6c35d513cea468b30759b4f78becf28f11a123c0"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "aa223019b5481188a90ebbb2dd2140b9a203f2ef", "filename": "src/etc/lldb_rust_formatters.py", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/83fe455e3c2e1d603fdbb28c800023b7a32e3c13/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/83fe455e3c2e1d603fdbb28c800023b7a32e3c13/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=83fe455e3c2e1d603fdbb28c800023b7a32e3c13", "patch": "@@ -0,0 +1,232 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import lldb\n+\n+def print_val(val, internal_dict):\n+  '''Prints the given value with Rust syntax'''\n+  type_class = val.GetType().GetTypeClass()\n+\n+  if type_class == lldb.eTypeClassStruct:\n+    return print_struct_val(val, internal_dict)\n+\n+  if type_class == lldb.eTypeClassUnion:\n+    return print_enum_val(val, internal_dict)\n+\n+  if type_class == lldb.eTypeClassPointer:\n+    return print_pointer_val(val, internal_dict)\n+\n+  if type_class == lldb.eTypeClassArray:\n+    return print_fixed_size_vec_val(val, internal_dict)\n+\n+  return val.GetValue()\n+\n+\n+#=--------------------------------------------------------------------------------------------------\n+# Type-Specialized Printing Functions\n+#=--------------------------------------------------------------------------------------------------\n+\n+def print_struct_val(val, internal_dict):\n+  '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n+  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+\n+  if is_vec_slice(val):\n+    return print_vec_slice_val(val, internal_dict)\n+  else:\n+    return print_struct_val_starting_from(0, val, internal_dict)\n+\n+def print_vec_slice_val(val, internal_dict):\n+  output = \"&[\"\n+\n+  length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n+\n+  data_ptr_val = val.GetChildAtIndex(0)\n+  data_ptr_type = data_ptr_val.GetType()\n+  assert data_ptr_type.IsPointerType()\n+\n+  element_type = data_ptr_type.GetPointeeType()\n+  element_type_size = element_type.GetByteSize()\n+\n+  start_address = data_ptr_val.GetValueAsUnsigned()\n+\n+  for i in range(length):\n+    address = start_address + i * element_type_size\n+    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type )\n+    output += print_val(element_val, internal_dict)\n+\n+    if i != length - 1:\n+      output += \", \"\n+\n+  output += \"]\"\n+  return output\n+\n+def print_struct_val_starting_from(field_start_index, val, internal_dict):\n+  '''\n+  Prints a struct, tuple, or tuple struct value with Rust syntax.\n+  Ignores any fields before field_start_index.\n+  '''\n+  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+\n+  t = val.GetType()\n+  has_field_names = type_has_field_names(t)\n+  type_name = extract_type_name(t.GetName())\n+  output = \"\"\n+\n+  if not type_name.startswith(\"(\"):\n+    # this is a tuple, so don't print the type name\n+    output += type_name\n+\n+  if has_field_names:\n+    output += \" { \\n\"\n+  else:\n+    output += \"(\"\n+\n+  num_children = val.num_children\n+\n+  for child_index in range(field_start_index, num_children):\n+    if has_field_names:\n+      field_name = t.GetFieldAtIndex(child_index).GetName()\n+      output += field_name + \": \"\n+\n+    field_val = val.GetChildAtIndex(child_index)\n+    output += print_val(field_val, internal_dict)\n+\n+    if child_index != num_children - 1:\n+      output += \", \"\n+\n+    if has_field_names:\n+      output += \"\\n\"\n+\n+  if has_field_names:\n+    output += \"}\"\n+  else:\n+    output += \")\"\n+\n+  return output\n+\n+\n+def print_enum_val(val, internal_dict):\n+  '''Prints an enum value with Rust syntax'''\n+\n+  assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n+\n+  if val.num_children == 1:\n+    first_variant_name = val.GetChildAtIndex(0).GetName()\n+    if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n+      # Try to extract the\n+\n+      last_separator_index = first_variant_name.rfind(\"$\")\n+      if last_separator_index == -1:\n+        return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+      second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n+      if second_last_separator_index == -1:\n+        return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+      try:\n+        disr_field_index = first_variant_name[second_last_separator_index + 1 :\n+                                              last_separator_index]\n+        disr_field_index = int(disr_field_index)\n+      except:\n+        return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index).GetValueAsUnsigned()\n+\n+      if disr_val == 0:\n+        null_variant_name = first_variant_name[last_separator_index + 1:]\n+        return null_variant_name\n+      else:\n+        return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+    else:\n+      return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+\n+  # extract the discriminator value by\n+  disr_val = val.GetChildAtIndex(0).GetChildAtIndex(0)\n+  disr_type = disr_val.GetType()\n+\n+  if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n+    return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+\n+  variant_index = disr_val.GetValueAsUnsigned()\n+  return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n+\n+\n+def print_pointer_val(val, internal_dict):\n+  '''Prints a pointer value with Rust syntax'''\n+  assert val.GetType().IsPointerType()\n+  sigil = \"&\"\n+  type_name = extract_type_name(val.GetType().GetName())\n+  if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n+    sigil = type_name[0:1]\n+\n+  return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n+\n+\n+def print_fixed_size_vec_val(val, internal_dict):\n+  assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n+\n+  output = \"[\"\n+\n+  for i in range(val.num_children):\n+    output += print_val(val.GetChildAtIndex(i), internal_dict)\n+    if i != val.num_children - 1:\n+      output += \", \"\n+\n+  output += \"]\"\n+  return output\n+\n+\n+#=--------------------------------------------------------------------------------------------------\n+# Helper Functions\n+#=--------------------------------------------------------------------------------------------------\n+\n+unqualified_type_markers = frozenset([\"(\", \"[\", \"&\", \"*\"])\n+\n+def extract_type_name(qualified_type_name):\n+  '''Extracts the type name from a fully qualified path'''\n+  if qualified_type_name[0] in unqualified_type_markers:\n+    return qualified_type_name\n+\n+  end_of_search = qualified_type_name.find(\"<\")\n+  if end_of_search < 0:\n+    end_of_search = len(qualified_type_name)\n+\n+  index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n+  if index < 0:\n+    return qualified_type_name\n+  else:\n+    return qualified_type_name[index + 2:]\n+\n+\n+def type_has_field_names(ty):\n+  '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n+  # This may also be an enum variant where the first field doesn't have a name but the rest has\n+  if ty.GetNumberOfFields() > 1:\n+    return ty.GetFieldAtIndex(1).GetName() != None\n+  else:\n+    return ty.GetFieldAtIndex(0).GetName() != None\n+\n+\n+def is_vec_slice(val):\n+  ty = val.GetType()\n+  if ty.GetTypeClass() != lldb.eTypeClassStruct:\n+    return False\n+\n+  if ty.GetNumberOfFields() != 2:\n+    return False\n+\n+  if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n+    return False\n+\n+  if ty.GetFieldAtIndex(1).GetName() != \"length\":\n+    return False\n+\n+  type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n+  return type_name.startswith(\"&[\") and type_name.endswith(\"]\")"}]}