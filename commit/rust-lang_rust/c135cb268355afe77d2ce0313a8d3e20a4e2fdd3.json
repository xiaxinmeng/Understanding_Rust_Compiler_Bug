{"sha": "c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzVjYjI2ODM1NWFmZTc3ZDJjZTAzMTNhOGQzZTIwYTRlMmZkZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T21:05:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T21:05:45Z"}, "message": "auto merge of #9235 : olsonjeffery/rust/newrt_file_io_1, r=thestinger\n\nA quick rundown:\r\n\r\n- added `file::{readdir, stat, mkdir, rmdir}`\r\n- Added access-constrained versions of `FileStream`; `FileReader` and `FileWriter` respectively\r\n- big rework in `uv::file` .. most actions are by-val-self methods on `FsRequest`; `FileDescriptor` has gone the way of the dinosaurs\r\n- playing nice w/ homing IO (I just copied ecr's work, hehe), etc\r\n- added `FileInfo` trait, with an impl for `Path`\r\n  - wrapper for file-specific actions, with the file path always implied by self's value\r\n  - has the means to create `FileReader` & `FileWriter` (this isn't exposed in the top-level free function API)\r\n  - has \"safe\" wrappers for `stat()` that won't throw in the event of non-existence/error (in this case, I mean `is_file` and `exists`)\r\n  - actions should fail if done on non-regular-files, as appropriate\r\n- added `DirectoryInfo` trait, with an impl for `Path`\r\n  - pretty much ditto above, but for directories\r\n  - added `readdir` (!!) to iterate over entries in a dir as a `~[Path]` (this was *brutal* to get working)\r\n\r\n...<del>and lots of other stuff</del>not really. Do your worst!", "tree": {"sha": "561787933db67139783cc13d1d2ac276391120f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/561787933db67139783cc13d1d2ac276391120f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "html_url": "https://github.com/rust-lang/rust/commit/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e8fb4ad61cfe97413eb92d764aa6aeeb23d5afa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e8fb4ad61cfe97413eb92d764aa6aeeb23d5afa", "html_url": "https://github.com/rust-lang/rust/commit/9e8fb4ad61cfe97413eb92d764aa6aeeb23d5afa"}, {"sha": "70152ff55722878cde684ee6462c14c65f2c4729", "url": "https://api.github.com/repos/rust-lang/rust/commits/70152ff55722878cde684ee6462c14c65f2c4729", "html_url": "https://github.com/rust-lang/rust/commit/70152ff55722878cde684ee6462c14c65f2c4729"}], "stats": {"total": 1675, "additions": 1444, "deletions": 231}, "files": [{"sha": "215bda264ade00e4974a594549b0e8a6fd725264", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -196,16 +196,7 @@ pub fn env() -> ~[(~str,~str)] {\n             if (ch as uint == 0) {\n                 fail!(\"os::env() failure getting env string from OS: %s\", os::last_os_error());\n             }\n-            let mut curr_ptr: uint = ch as uint;\n-            let mut result = ~[];\n-            while(*(curr_ptr as *libc::c_char) != 0 as libc::c_char) {\n-                let env_pair = str::raw::from_c_str(\n-                    curr_ptr as *libc::c_char);\n-                result.push(env_pair);\n-                curr_ptr +=\n-                    libc::strlen(curr_ptr as *libc::c_char) as uint\n-                    + 1;\n-            }\n+            let result = str::raw::from_c_multistring(ch as *libc::c_char, None);\n             FreeEnvironmentStringsA(ch);\n             result\n         }"}, {"sha": "a884961fd1e0de77d2155988ee3cdaabc19bbd1a", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 659, "deletions": 20, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -8,17 +8,87 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! Synchronous File I/O\n+\n+This module provides a set of functions and traits for working\n+with regular files & directories on a filesystem.\n+\n+At the top-level of the module are a set of freestanding functions,\n+associated with various filesystem operations. They all operate\n+on a `PathLike` object.\n+\n+All operations in this module, including those as part of `FileStream` et al\n+block the task during execution. Most will raise `std::rt::io::{io_error,read_error}`\n+conditions in the event of failure.\n+\n+Also included in this module are the `FileInfo` and `DirectoryInfo` traits. When\n+`use`'d alongside a value whose type implements them (A `std::path::Path` impl is\n+a part of this module), they expose a set of functions for operations against\n+a given file location, depending on whether the path already exists. Whenever\n+possible, the `{FileInfo, DirectoryInfo}` preserve the same semantics as their\n+free function counterparts.\n+*/\n+\n use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n-use super::{SeekSet, SeekCur, SeekEnd, SeekStyle};\n+use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n+            Open, Read, Write, Create, ReadWrite};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n use rt::io::{io_error, read_error, EndOfFile,\n-             FileMode, FileAccess, Open, Read, Create, ReadWrite};\n+            FileMode, FileAccess, FileStat, IoError,\n+            PathAlreadyExists, PathDoesntExist,\n+            MismatchedFileTypeForOperation, ignore_io_error};\n use rt::local::Local;\n-use rt::test::*;\n+use option::{Some, None};\n+use path::Path;\n+use super::super::test::*;\n \n /// Open a file for reading/writing, as indicated by `path`.\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::open;\n+///     use std::rt::io::{FileMode, FileAccess};\n+///\n+///     let p = &Path(\"/some/file/path.txt\");\n+///\n+///     do io_error::cond.trap(|_| {\n+///         // hoo-boy...\n+///     }).inside {\n+///         let stream = match open(p, Create, ReadWrite) {\n+///             Some(s) => s,\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///         }\n+///         // do some stuff with that stream\n+///\n+///         // the file stream will be closed at the end of this block\n+///     }\n+///     // ..\n+///\n+/// `FileMode` and `FileAccess` provide information about the permissions\n+/// context in which a given stream is created. More information about them\n+/// can be found in `std::rt::io`'s docs.\n+///\n+/// Note that, with this function, a `FileStream` is returned regardless of\n+/// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n+/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n+/// desire a more-correctly-constrained interface to files, use the\n+/// `{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n+///\n+/// # Errors\n+///\n+/// This function will raise an `io_error` condition under a number of different circumstances,\n+/// to include but not limited to:\n+///\n+/// * Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n+///   opening a non-existant file with `FileMode` or `Open`)\n+/// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n+///   for\n+/// * Filesystem-level errors (full disk, etc)\n pub fn open<P: PathLike>(path: &P,\n                          mode: FileMode,\n                          access: FileAccess\n@@ -39,8 +109,28 @@ pub fn open<P: PathLike>(path: &P,\n     }\n }\n \n-/// Unlink (remove) a file from the filesystem, as indicated\n-/// by `path`.\n+/// Unlink a file from the underlying filesystem.\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::unlink;\n+///\n+///     let p = &Path(\"/some/file/path.txt\");\n+///     unlink(p);\n+///     // if we made it here without failing, then the\n+///     // unlink operation was successful\n+///\n+/// Note that, just because an unlink call was successful, it is not\n+/// guaranteed that a file is immediately deleted (e.g. depending on\n+/// platform, other open file descriptors may prevent immediate removal)\n+///\n+/// # Errors\n+///\n+/// This function will raise an `io_error` condition if the user lacks permissions to\n+/// remove the file or if some other filesystem-level error occurs\n pub fn unlink<P: PathLike>(path: &P) {\n     let unlink_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -54,26 +144,231 @@ pub fn unlink<P: PathLike>(path: &P) {\n     }\n }\n \n-/// Abstraction representing *positional* access to a file. In this case,\n-/// *positional* refers to it keeping an encounter *cursor* of where in the\n-/// file a subsequent `read` or `write` will begin from. Users of a `FileStream`\n-/// can `seek` to move the cursor to a given location *within the bounds of the\n-/// file* and can ask to have the `FileStream` `tell` them the location, in\n-/// bytes, of the cursor.\n+/// Create a new, empty directory at the provided path\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::mkdir;\n+///\n+///     let p = &Path(\"/some/dir\");\n+///     mkdir(p);\n+///     // If we got here, our directory exists! Horray!\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks permissions to make a\n+/// new directory at the provided path, or if the directory already exists\n+pub fn mkdir<P: PathLike>(path: &P) {\n+    let mkdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_mkdir(path)\n+    };\n+    match mkdir_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n+}\n+\n+/// Remove an existing, empty directory\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::rmdir;\n+///\n+///     let p = &Path(\"/some/dir\");\n+///     rmdir(p);\n+///     // good riddance, you mean ol' directory\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks permissions to remove the\n+/// directory at the provided path, or if the directory isn't empty\n+pub fn rmdir<P: PathLike>(path: &P) {\n+    let rmdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_rmdir(path)\n+    };\n+    match rmdir_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n+}\n+\n+/// Get information on the file, directory, etc at the provided path\n+///\n+/// Given a `rt::io::support::PathLike`, query the file system to get\n+/// information about a file, directory, etc.\n+///\n+/// Returns a `Some(std::rt::io::PathInfo)` on success\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::stat;\n+///\n+///     let p = &Path(\"/some/file/path.txt\");\n+///\n+///     do io_error::cond.trap(|_| {\n+///         // hoo-boy...\n+///     }).inside {\n+///         let info = match stat(p) {\n+///             Some(s) => s,\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///         }\n+///         if stat.is_file {\n+///             // just imagine the possibilities ...\n+///         }\n+///\n+///         // the file stream will be closed at the end of this block\n+///     }\n+///     // ..\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks the requisite\n+/// permissions to perform a `stat` call on the given path or if there is no\n+/// entry in the filesystem at the provided path.\n+pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n+    let open_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_stat(path)\n+    };\n+    match open_result {\n+        Ok(p) => {\n+            Some(p)\n+        },\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n+/// Retrieve a vector containing all entries within a provided directory\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::readdir;\n+///\n+///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///         if dir.is_dir() {\n+///             let contents = dir.readdir();\n+///             for entry in contents.iter() {\n+///                 if entry.is_dir() { visit_dirs(entry, cb); }\n+///                 else { cb(entry); }\n+///             }\n+///         }\n+///         else { fail!(\"nope\"); }\n+///     }\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// the process lacks permissions to view the contents or if the `path` points\n+/// at a non-directory file\n+pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n+    let readdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_readdir(path, 0)\n+    };\n+    match readdir_result {\n+        Ok(p) => {\n+            Some(p)\n+        },\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n+/// Constrained version of `FileStream` that only exposes read-specific operations.\n+///\n+/// Can be retreived via `FileInfo.open_reader()`.\n+pub struct FileReader { priv stream: FileStream }\n+\n+/// a `std::rt::io::Reader` trait impl for file I/O.\n+impl Reader for FileReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        self.stream.read(buf)\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.stream.eof()\n+    }\n+}\n+\n+/// a `std::rt::io::Seek` trait impl for file I/O.\n+impl Seek for FileReader {\n+    fn tell(&self) -> u64 {\n+        self.stream.tell()\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        self.stream.seek(pos, style);\n+    }\n+}\n+\n+/// Constrained version of `FileStream` that only exposes write-specific operations.\n+///\n+/// Can be retreived via `FileInfo.open_writer()`.\n+pub struct FileWriter { priv stream: FileStream }\n+\n+/// a `std::rt::io::Writer` trait impl for file I/O.\n+impl Writer for FileWriter {\n+    fn write(&mut self, buf: &[u8]) {\n+        self.stream.write(buf);\n+    }\n+\n+    fn flush(&mut self) {\n+        self.stream.flush();\n+    }\n+}\n+\n+/// a `std::rt::io::Seek` trait impl for file I/O.\n+impl Seek for FileWriter {\n+    fn tell(&self) -> u64 {\n+        self.stream.tell()\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        self.stream.seek(pos, style);\n+    }\n+}\n+\n+/// Unconstrained file access type that exposes read and write operations\n+///\n+/// Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n+///\n+/// # Errors\n ///\n-/// This abstraction is roughly modeled on the access workflow as represented\n-/// by `open(2)`, `read(2)`, `write(2)` and friends.\n+/// This type will raise an io_error condition if operations are attempted against\n+/// it for which its underlying file descriptor was not configured at creation\n+/// time, via the `FileAccess` parameter to `file::open()`.\n ///\n-/// The `open` and `unlink` static methods are provided to manage creation/removal\n-/// of files. All other methods operatin on an instance of `FileStream`.\n+/// For this reason, it is best to use the access-constrained wrappers that are\n+/// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n pub struct FileStream {\n     fd: ~RtioFileStream,\n     last_nread: int,\n }\n \n-impl FileStream {\n-}\n-\n+/// a `std::rt::io::Reader` trait impl for file I/O.\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {\n@@ -99,6 +394,7 @@ impl Reader for FileStream {\n     }\n }\n \n+/// a `std::rt::io::Writer` trait impl for file I/O.\n impl Writer for FileStream {\n     fn write(&mut self, buf: &[u8]) {\n         match self.fd.write(buf) {\n@@ -119,6 +415,7 @@ impl Writer for FileStream {\n     }\n }\n \n+/// a `std::rt::io:Seek` trait impl for file I/O.\n impl Seek for FileStream {\n     fn tell(&self) -> u64 {\n         let res = self.fd.tell();\n@@ -145,6 +442,242 @@ impl Seek for FileStream {\n     }\n }\n \n+/// Shared functionality between `FileInfo` and `DirectoryInfo`\n+pub trait FileSystemInfo {\n+    /// Get the filesystem path that this instance points at,\n+    /// whether it is valid or not. In this way, it can be used to\n+    /// to specify a path of a non-existent file which it\n+    /// later creates\n+    fn get_path<'a>(&'a self) -> &'a Path;\n+\n+    /// Get information on the file, directory, etc at the provided path\n+    ///\n+    /// Consult the `file::stat` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with `file::stat`\n+    fn stat(&self) -> Option<FileStat> {\n+        stat(self.get_path())\n+    }\n+\n+    /// Boolean value indicator whether the underlying file exists on the filesystem\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    fn exists(&self) -> bool {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(_) => true,\n+            None => false\n+        }\n+    }\n+\n+}\n+\n+/// Represents a file, whose underlying path may or may not be valid\n+///\n+/// # Example\n+///\n+/// * Check if a file exists, reading from it if so\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::file::{FileInfo, FileReader};\n+///\n+///     let f = &Path(\"/some/file/path.txt\");\n+///     if f.exists() {\n+///         let reader = f.open_reader(Open);\n+///         let mut mem = [0u8, 8*64000];\n+///         reader.read(mem);\n+///         // ...\n+///     }\n+///\n+/// * Is the given path a file?\n+///\n+///    let f = get_file_path_from_wherever();\n+///    match f.is_file() {\n+///        true => doing_something_with_a_file(f),\n+///        _ => {}\n+///    }\n+pub trait FileInfo : FileSystemInfo {\n+    /// Whether the underlying implemention (be it a file path,\n+    /// or something else) points at a \"regular file\" on the FS. Will return\n+    /// false for paths to non-existent locations or directories or\n+    /// other non-regular files (named pipes, etc).\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    fn is_file(&self) -> bool {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(s) => s.is_file,\n+            None => false\n+        }\n+    }\n+\n+    /// Attempts to open a regular file for reading/writing based\n+    /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n+    fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(s) => match s.is_file {\n+                true => open(self.get_path(), mode, access),\n+                false => None\n+            },\n+            None => open(self.get_path(), mode, access)\n+        }\n+    }\n+\n+    /// Attempts to open a regular file in read-only mode, based\n+    /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n+    fn open_reader(&self, mode: FileMode) -> Option<FileReader> {\n+        match self.open_stream(mode, Read) {\n+            Some(s) => Some(FileReader { stream: s}),\n+            None => None\n+        }\n+    }\n+\n+    /// Attempts to open a regular file in write-only mode, based\n+    /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n+    fn open_writer(&self, mode: FileMode) -> Option<FileWriter> {\n+        match self.open_stream(mode, Write) {\n+            Some(s) => Some(FileWriter { stream: s}),\n+            None => None\n+        }\n+    }\n+\n+    /// Attempt to remove a file from the filesystem\n+    ///\n+    /// See `file::unlink` for more information on runtime semantics and error conditions\n+    fn unlink(&self) {\n+        unlink(self.get_path());\n+    }\n+}\n+\n+/// `FileSystemInfo` implementation for `Path`s\n+impl FileSystemInfo for Path {\n+    fn get_path<'a>(&'a self) -> &'a Path { self }\n+}\n+\n+/// `FileInfo` implementation for `Path`s\n+impl FileInfo for Path { }\n+\n+/// Represents a directory, whose underlying path may or may not be valid\n+///\n+/// # Example\n+///\n+/// * Check if a directory exists, `mkdir`'ing it if not\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::file::{DirectoryInfo};\n+///\n+///     let dir = &Path(\"/some/dir\");\n+///     if !dir.exists() {\n+///         dir.mkdir();\n+///     }\n+///\n+/// * Is the given path a directory? If so, iterate on its contents\n+///\n+///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///         if dir.is_dir() {\n+///             let contents = dir.readdir();\n+///             for entry in contents.iter() {\n+///                 if entry.is_dir() { visit_dirs(entry, cb); }\n+///                 else { cb(entry); }\n+///             }\n+///         }\n+///         else { fail!(\"nope\"); }\n+///     }\n+trait DirectoryInfo : FileSystemInfo {\n+    /// Whether the underlying implemention (be it a file path,\n+    /// or something else) is pointing at a directory in the underlying FS.\n+    /// Will return false for paths to non-existent locations or if the item is\n+    /// not a directory (eg files, named pipes, links, etc)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    fn is_dir(&self) -> bool {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(s) => s.is_dir,\n+            None => false\n+        }\n+    }\n+\n+    /// Create a directory at the location pointed to by the\n+    /// type underlying the given `DirectoryInfo`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will raise a `PathAlreadyExists` kind of `io_error` condition\n+    /// if the provided path exists\n+    ///\n+    /// See `file::mkdir` for more information on runtime semantics and error conditions\n+    fn mkdir(&self) {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(_) => {\n+                io_error::cond.raise(IoError {\n+                    kind: PathAlreadyExists,\n+                    desc: \"Path already exists\",\n+                    detail:\n+                        Some(fmt!(\"%s already exists; can't mkdir it\", self.get_path().to_str()))\n+                })\n+            },\n+            None => mkdir(self.get_path())\n+        }\n+    }\n+\n+    /// Remove a directory at the given location.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will raise a `PathDoesntExist` kind of `io_error` condition\n+    /// if the provided path exists. It will raise a `MismatchedFileTypeForOperation`\n+    /// kind of `io_error` condition if the provided path points at any\n+    /// non-directory file type\n+    ///\n+    /// See `file::rmdir` for more information on runtime semantics and error conditions\n+    fn rmdir(&self) {\n+        match ignore_io_error(|| self.stat()) {\n+            Some(s) => {\n+                match s.is_dir {\n+                    true => rmdir(self.get_path()),\n+                    false => {\n+                        let ioerr = IoError {\n+                            kind: MismatchedFileTypeForOperation,\n+                            desc: \"Cannot do rmdir() on a non-directory\",\n+                            detail: Some(fmt!(\n+                                \"%s is a non-directory; can't rmdir it\",\n+                                self.get_path().to_str()))\n+                        };\n+                        io_error::cond.raise(ioerr);\n+                    }\n+                }\n+            },\n+            None =>\n+                io_error::cond.raise(IoError {\n+                    kind: PathDoesntExist,\n+                    desc: \"Path doesn't exist\",\n+                    detail: Some(fmt!(\"%s doesn't exist; can't rmdir it\", self.get_path().to_str()))\n+                })\n+        }\n+    }\n+\n+    // Get a collection of all entries at the given\n+    // directory\n+    fn readdir(&self) -> Option<~[Path]> {\n+        readdir(self.get_path())\n+    }\n+}\n+\n+/// `DirectoryInfo` impl for `path::Path`\n+impl DirectoryInfo for Path { }\n+\n fn file_test_smoke_test_impl() {\n     do run_in_mt_newsched_task {\n         let message = \"it's alright. have a good time\";\n@@ -273,7 +806,6 @@ fn file_test_io_seek_and_tell_smoke_test() {\n }\n \n fn file_test_io_seek_and_write_impl() {\n-    use io;\n     do run_in_mt_newsched_task {\n         use str;\n         let initial_msg =   \"food-is-yummy\";\n@@ -294,7 +826,6 @@ fn file_test_io_seek_and_write_impl() {\n         }\n         unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n-        io::println(fmt!(\"read_str: '%?' final_msg: '%?'\", read_str, final_msg));\n         assert!(read_str == final_msg.to_owned());\n     }\n }\n@@ -343,3 +874,111 @@ fn file_test_io_seek_shakedown_impl() {\n fn file_test_io_seek_shakedown() {\n     file_test_io_seek_shakedown_impl();\n }\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_file() {\n+    do run_in_mt_newsched_task {\n+        let filename = &Path(\"./tmp/file_stat_correct_on_is_file.txt\");\n+        {\n+            let mut fs = open(filename, Create, ReadWrite).unwrap();\n+            let msg = \"hw\";\n+            fs.write(msg.as_bytes());\n+        }\n+        let stat_res = match stat(filename) {\n+            Some(s) => s,\n+            None => fail!(\"shouldn't happen\")\n+        };\n+        assert!(stat_res.is_file);\n+        unlink(filename);\n+    }\n+}\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_dir() {\n+    do run_in_mt_newsched_task {\n+        let filename = &Path(\"./tmp/file_stat_correct_on_is_dir\");\n+        mkdir(filename);\n+        let stat_res = match stat(filename) {\n+            Some(s) => s,\n+            None => fail!(\"shouldn't happen\")\n+        };\n+        assert!(stat_res.is_dir);\n+        rmdir(filename);\n+    }\n+}\n+\n+#[test]\n+fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/fileinfo_false_on_dir\");\n+        mkdir(dir);\n+        assert!(dir.is_file() == false);\n+        rmdir(dir);\n+    }\n+}\n+\n+#[test]\n+fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    do run_in_mt_newsched_task {\n+        let file = &Path(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+        {\n+            let msg = \"foo\".as_bytes();\n+            let mut w = file.open_writer(Create);\n+            w.write(msg);\n+        }\n+        assert!(file.exists());\n+        file.unlink();\n+        assert!(!file.exists());\n+    }\n+}\n+\n+#[test]\n+fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/before_and_after_dir\");\n+        assert!(!dir.exists());\n+        dir.mkdir();\n+        assert!(dir.exists());\n+        assert!(dir.is_dir());\n+        dir.rmdir();\n+        assert!(!dir.exists());\n+    }\n+}\n+\n+#[test]\n+fn file_test_directoryinfo_readdir() {\n+    use str;\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/di_readdir\");\n+        dir.mkdir();\n+        let prefix = \"foo\";\n+        for n in range(0,3) {\n+            let f = dir.push(fmt!(\"%d.txt\", n));\n+            let mut w = f.open_writer(Create);\n+            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n+            let msg = msg_str.as_bytes();\n+            w.write(msg);\n+        }\n+        match dir.readdir() {\n+            Some(files) => {\n+                let mut mem = [0u8, .. 4];\n+                for f in files.iter() {\n+                    {\n+                        let n = f.filestem();\n+                        let mut r = f.open_reader(Open);\n+                        r.read(mem);\n+                        let read_str = str::from_utf8(mem);\n+                        let expected = match n {\n+                            Some(n) => prefix+n,\n+                            None => fail!(\"really shouldn't happen..\")\n+                        };\n+                        assert!(expected == read_str);\n+                    }\n+                    f.unlink();\n+                }\n+            },\n+            None => fail!(\"shouldn't happen\")\n+        }\n+        dir.rmdir();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "871b41039d1cec2fe405ab84fc3760fffac9ef54", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -245,6 +245,7 @@ Out of scope\n use prelude::*;\n use to_str::ToStr;\n use str::{StrSlice, OwnedStr};\n+use path::Path;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -357,7 +358,10 @@ pub enum IoErrorKind {\n     Closed,\n     ConnectionRefused,\n     ConnectionReset,\n-    BrokenPipe\n+    BrokenPipe,\n+    PathAlreadyExists,\n+    PathDoesntExist,\n+    MismatchedFileTypeForOperation\n }\n \n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n@@ -373,7 +377,10 @@ impl ToStr for IoErrorKind {\n             Closed => ~\"Closed\",\n             ConnectionRefused => ~\"ConnectionRefused\",\n             ConnectionReset => ~\"ConnectionReset\",\n-            BrokenPipe => ~\"BrokenPipe\"\n+            BrokenPipe => ~\"BrokenPipe\",\n+            PathAlreadyExists => ~\"PathAlreadyExists\",\n+            PathDoesntExist => ~\"PathDoesntExist\",\n+            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\"\n         }\n     }\n }\n@@ -394,6 +401,18 @@ condition! {\n     pub read_error: super::IoError -> ();\n }\n \n+/// Helper for wrapper calls where you want to\n+/// ignore any io_errors that might be raised\n+pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n+    do io_error::cond.trap(|_| {\n+        // just swallow the error.. downstream users\n+        // who can make a decision based on a None result\n+        // won't care\n+    }).inside {\n+        cb()\n+    }\n+}\n+\n pub trait Reader {\n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n     /// Returns the number of bytes read. The number of bytes read my\n@@ -596,3 +615,22 @@ pub enum FileAccess {\n     Write,\n     ReadWrite\n }\n+\n+pub struct FileStat {\n+    /// A `Path` object containing information about the `PathInfo`'s location\n+    path: Path,\n+    /// `true` if the file pointed at by the `PathInfo` is a regular file\n+    is_file: bool,\n+    /// `true` if the file pointed at by the `PathInfo` is a directory\n+    is_dir: bool,\n+    /// The file pointed at by the `PathInfo`'s size in bytes\n+    size: u64,\n+    /// The file pointed at by the `PathInfo`'s creation time\n+    created: u64,\n+    /// The file pointed at by the `PathInfo`'s last-modification time in\n+    /// platform-dependent msecs\n+    modified: u64,\n+    /// The file pointed at by the `PathInfo`'s last-accessd time (e.g. read) in\n+    /// platform-dependent msecs\n+    accessed: u64,\n+}"}, {"sha": "d05a3a26169b1d1c1993b7fc374614af7b90b71d", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -18,7 +18,7 @@ use rt::uv::uvio;\n use path::Path;\n use super::io::support::PathLike;\n use super::io::{SeekStyle};\n-use super::io::{FileMode, FileAccess};\n+use super::io::{FileMode, FileAccess, FileStat};\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -74,6 +74,11 @@ pub trait IoFactory {\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n+    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n+    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+        Result<~[Path], IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {"}, {"sha": "ada558036cfeae2419768e52878eb73a9ead533b", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 401, "deletions": 181, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -17,84 +17,238 @@ use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n use cast::transmute;\n+use libc;\n use libc::{c_int};\n use option::{None, Some, Option};\n \n pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n \n pub struct RequestData {\n-    complete_cb: Option<FsCallback>,\n-    raw_fd: Option<c_int>\n+    complete_cb: Option<FsCallback>\n }\n \n impl FsRequest {\n-    pub fn new(cb: Option<FsCallback>) -> FsRequest {\n+    pub fn new() -> FsRequest {\n         let fs_req = unsafe { malloc_req(UV_FS) };\n         assert!(fs_req.is_not_null());\n         let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n-        fs_req.install_req_data(cb);\n         fs_req\n     }\n \n-    fn open_common<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n+    pub fn open<P: PathLike>(self, loop_: &Loop, path: &P, flags: int, mode: int,\n+               cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n         };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = path.path_as_str(|p| {\n+        path.path_as_str(|p| {\n             p.to_c_str().with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n-                          req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+                          self.native_handle(), p, flags, mode, complete_cb_ptr)\n             })\n         });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n     }\n-    pub fn open<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) {\n-        FsRequest::open_common(loop_, path, flags, mode, Some(cb));\n+\n+    pub fn open_sync<P: PathLike>(self, loop_: &Loop, path: &P,\n+                                  flags: int, mode: int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_open(loop_.native_handle(),\n+                    self.native_handle(), p, flags, mode, complete_cb_ptr)\n+            })\n+        });\n+        self.sync_cleanup(result)\n     }\n \n-    pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n-          -> Result<int, UvError> {\n-        let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(result)\n+    pub fn unlink<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_unlink(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n     }\n \n-    fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n+    pub fn unlink_sync<P: PathLike>(self, loop_: &Loop, path: &P)\n+      -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n         };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n         let result = path.path_as_str(|p| {\n             p.to_c_str().with_ref(|p| unsafe {\n                 uvll::fs_unlink(loop_.native_handle(),\n-                              req.native_handle(), p, complete_cb_ptr) as int\n+                              self.native_handle(), p, complete_cb_ptr)\n             })\n         });\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn stat<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_stat(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n+    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n     }\n-    pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n-        let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(result);\n+    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let base_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n+                           fd, base_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n     }\n-    pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n-        let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(result)\n+    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+          -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let buf_ptr = buf.base as *c_void;\n+        let len = buf.len as uint;\n+        let result = unsafe {\n+            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n+                           fd, buf_ptr,\n+                           len, offset, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n     }\n \n-    pub fn install_req_data(&self, cb: Option<FsCallback>) {\n+    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+    }\n+    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(None)\n+        };\n+        let result = unsafe {\n+            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n+                           fd, complete_cb_ptr)\n+        };\n+        self.sync_cleanup(result)\n+    }\n+\n+    pub fn mkdir<P: PathLike>(self, loop_: &Loop, path: &P, mode: int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_mkdir(loop_.native_handle(),\n+                          self.native_handle(), p, mode, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n+    pub fn rmdir<P: PathLike>(self, loop_: &Loop, path: &P, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_rmdir(loop_.native_handle(),\n+                          self.native_handle(), p, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n+    pub fn readdir<P: PathLike>(self, loop_: &Loop, path: &P,\n+                                flags: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_readdir(loop_.native_handle(),\n+                          self.native_handle(), p, flags, complete_cb_ptr)\n+            })\n+        });\n+    }\n+\n+    // accessors/utility funcs\n+    fn sync_cleanup(self, result: c_int)\n+          -> Result<c_int, UvError> {\n+        self.cleanup_and_delete();\n+        match status_to_maybe_uv_error(result as i32) {\n+            Some(err) => Err(err),\n+            None => Ok(result)\n+        }\n+    }\n+    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> *u8 {\n+        let result = match cb {\n+            Some(_) => {\n+                compl_cb as *u8\n+            },\n+            None => 0 as *u8\n+        };\n+        self.install_req_data(cb);\n+        result\n+    }\n+    pub fn install_req_data(&mut self, cb: Option<FsCallback>) {\n         let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n         let data = ~RequestData {\n-            complete_cb: cb,\n-            raw_fd: None\n+            complete_cb: cb\n         };\n         unsafe {\n             let data = transmute::<~RequestData, *c_void>(data);\n@@ -106,7 +260,7 @@ impl FsRequest {\n         unsafe {\n             let data = uvll::get_data_for_req((self.native_handle()));\n             let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            return &mut **data;\n+            &mut **data\n         }\n     }\n \n@@ -120,6 +274,42 @@ impl FsRequest {\n         unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n     }\n \n+    pub fn get_stat(&self) -> uv_stat_t {\n+        let stat = uv_stat_t::new();\n+        unsafe { uvll::populate_stat(self.native_handle(), &stat); }\n+        stat\n+    }\n+\n+    pub fn get_ptr(&self) -> *libc::c_void {\n+        unsafe {\n+            uvll::get_ptr_from_fs_req(self.native_handle())\n+        }\n+    }\n+\n+    pub fn get_paths(&mut self) -> ~[~str] {\n+        use str;\n+        let ptr = self.get_ptr();\n+        match self.get_result() {\n+            n if (n <= 0) => {\n+                ~[]\n+            },\n+            n => {\n+                let n_len = n as uint;\n+                // we pass in the len that uv tells us is there\n+                // for the entries and we don't continue past that..\n+                // it appears that sometimes the multistring isn't\n+                // correctly delimited and we stray into garbage memory?\n+                // in any case, passing Some(n_len) fixes it and ensures\n+                // good results\n+                let raw_path_strs = unsafe {\n+                    str::raw::from_c_multistring(ptr as *libc::c_char, Some(n_len)) };\n+                let raw_len = raw_path_strs.len();\n+                assert_eq!(raw_len, n_len);\n+                raw_path_strs\n+            }\n+        }\n+    }\n+\n     fn cleanup_and_delete(self) {\n         unsafe {\n             let data = uvll::get_data_for_req(self.native_handle());\n@@ -148,97 +338,6 @@ fn sync_cleanup(result: int)\n     }\n }\n \n-pub struct FileDescriptor(c_int);\n-\n-impl FileDescriptor {\n-    fn new(fd: c_int) -> FileDescriptor {\n-        FileDescriptor(fd)\n-    }\n-\n-\n-    pub fn from_open_req(req: &mut FsRequest) -> FileDescriptor {\n-        FileDescriptor::new(req.get_result())\n-    }\n-\n-    // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n-    fn write_common(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n-          -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let mut req = FsRequest::new(cb);\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        req.get_req_data().raw_fd = Some(self.native_handle());\n-        let result = unsafe {\n-            uvll::fs_write(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), base_ptr,\n-                           len, offset, complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn write(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n-        self.write_common(loop_, buf, offset, Some(cb));\n-    }\n-    pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n-          -> Result<int, UvError> {\n-        let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n-    }\n-\n-    fn read_common(&mut self, loop_: &Loop, buf: Buf,\n-                   offset: i64, cb: Option<FsCallback>)\n-          -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let mut req = FsRequest::new(cb);\n-        req.get_req_data().raw_fd = Some(self.native_handle());\n-        let buf_ptr = buf.base as *c_void;\n-        let result = unsafe {\n-            uvll::fs_read(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), buf_ptr,\n-                           buf.len as uint, offset, complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn read(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n-        self.read_common(loop_, buf, offset, Some(cb));\n-    }\n-    pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n-          -> Result<int, UvError> {\n-        let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n-    }\n-\n-    fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n-        let complete_cb_ptr = match cb {\n-            Some(_) => compl_cb as *u8,\n-            None => 0 as *u8\n-        };\n-        let is_sync = cb.is_none();\n-        let req = FsRequest::new(cb);\n-        let result = unsafe {\n-            uvll::fs_close(loop_.native_handle(), req.native_handle(),\n-                           self.native_handle(), complete_cb_ptr) as int\n-        };\n-        if is_sync { req.cleanup_and_delete(); }\n-        result\n-    }\n-    pub fn close(self, loop_: &Loop, cb: FsCallback) {\n-        self.close_common(loop_, Some(cb));\n-    }\n-    pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n-        let result = self.close_common(loop_, None);\n-        sync_cleanup(result)\n-    }\n-}\n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n     // pull the user cb out of the req data\n@@ -261,15 +360,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n     req.cleanup_and_delete();\n }\n \n-impl NativeHandle<c_int> for FileDescriptor {\n-    fn from_native_handle(handle: c_int) -> FileDescriptor {\n-        FileDescriptor(handle)\n-    }\n-    fn native_handle(&self) -> c_int {\n-        match self { &FileDescriptor(ptr) => ptr }\n-    }\n-}\n-\n+#[cfg(test)]\n mod test {\n     use super::*;\n     //use rt::test::*;\n@@ -279,11 +370,11 @@ mod test {\n     use unstable::run_in_bare_thread;\n     use path::Path;\n     use rt::uv::{Loop, Buf, slice_to_uv_buf};\n-    use libc::{O_CREAT, O_RDWR, O_RDONLY,\n-               S_IWUSR, S_IRUSR}; //NOTE: need defs for S_**GRP|S_**OTH in libc:: ...\n-               //S_IRGRP, S_IROTH};\n+    use libc::{c_int, O_CREAT, O_RDWR, O_RDONLY,\n+               S_IWUSR, S_IRUSR};\n \n-    fn file_test_full_simple_impl() {\n+    #[test]\n+    fn file_test_full_simple() {\n         do run_in_bare_thread {\n             let mut loop_ = Loop::new();\n             let create_flags = O_RDWR | O_CREAT;\n@@ -302,25 +393,27 @@ mod test {\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n             let p = Path(path_str);\n-            do FsRequest::open(&loop_, &p, create_flags as int, mode as int)\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n                 assert!(uverr.is_none());\n-                let mut fd = FileDescriptor::from_open_req(req);\n-                let raw_fd = fd.native_handle();\n+                let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n-                do fd.write(&req.get_loop(), buf, -1) |req, uverr| {\n-                    let fd = FileDescriptor(raw_fd);\n-                    do fd.close(&req.get_loop()) |req, _| {\n-                        let loop_ = req.get_loop();\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, -1) |req, uverr| {\n+                    let close_req = FsRequest::new();\n+                    do close_req.close(&req.get_loop(), fd) |req, _| {\n                         assert!(uverr.is_none());\n-                        do FsRequest::open(&loop_, &Path(path_str), read_flags as int,0)\n+                        let loop_ = req.get_loop();\n+                        let open_req = FsRequest::new();\n+                        do open_req.open(&loop_, &Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n-                            let mut fd = FileDescriptor::from_open_req(req);\n-                            let raw_fd = fd.native_handle();\n+                            let fd = req.get_result();\n                             let read_buf = unsafe { *read_buf_ptr };\n-                            do fd.read(&loop_, read_buf, 0) |req, uverr| {\n+                            let read_req = FsRequest::new();\n+                            do read_req.read(&loop_, fd, read_buf, 0) |req, uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 // we know nread >=0 because uverr is none..\n@@ -334,15 +427,17 @@ mod test {\n                                                 read_buf.base, nread))\n                                     };\n                                     assert!(read_str == ~\"hello\");\n-                                    do FileDescriptor(raw_fd).close(&loop_) |req,uverr| {\n+                                    let close_req = FsRequest::new();\n+                                    do close_req.close(&loop_, fd) |req,uverr| {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n-                                        do FsRequest::unlink(loop_, &Path(path_str))\n+                                        let unlink_req = FsRequest::new();\n+                                        do unlink_req.unlink(loop_, &Path(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n                                     };\n-                                }\n+                                };\n                             };\n                         };\n                     };\n@@ -352,7 +447,9 @@ mod test {\n             loop_.close();\n         }\n     }\n-    fn file_test_full_simple_impl_sync() {\n+\n+    #[test]\n+    fn file_test_full_simple_sync() {\n         do run_in_bare_thread {\n             // setup\n             let mut loop_ = Loop::new();\n@@ -368,26 +465,31 @@ mod test {\n             let write_val = \"hello\".as_bytes().to_owned();\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n-            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            let fd = result.unwrap();\n             // write\n-            let result = fd.write_sync(&loop_, write_buf, -1);\n+            let write_req = FsRequest::new();\n+            let result = write_req.write_sync(&loop_, fd, write_buf, -1);\n             assert!(result.is_ok());\n             // close\n-            let result = fd.close_sync(&loop_);\n+            let close_req = FsRequest::new();\n+            let result = close_req.close_sync(&loop_, fd);\n             assert!(result.is_ok());\n             // re-open\n-            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n+            let open_req = FsRequest::new();\n+            let result = open_req.open_sync(&loop_, &Path(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n-            let mut fd = FileDescriptor(result.unwrap() as i32);\n+            let fd = result.unwrap();\n             // read\n             let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n             let buf = slice_to_uv_buf(read_mem);\n-            let result = fd.read_sync(&loop_, buf, 0);\n+            let read_req = FsRequest::new();\n+            let result = read_req.read_sync(&loop_, fd, buf, 0);\n             assert!(result.is_ok());\n             let nread = result.unwrap();\n             // nread == 0 would be EOF.. we know it's >= zero because otherwise\n@@ -397,31 +499,23 @@ mod test {\n                     read_mem.slice(0, nread as uint));\n                 assert!(read_str == ~\"hello\");\n                 // close\n-                let result = fd.close_sync(&loop_);\n+                let close_req = FsRequest::new();\n+                let result = close_req.close_sync(&loop_, fd);\n                 assert!(result.is_ok());\n                 // unlink\n-                let result = FsRequest::unlink_sync(&loop_, &Path(path_str));\n+                let unlink_req = FsRequest::new();\n+                let result = unlink_req.unlink_sync(&loop_, &Path(path_str));\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n         }\n     }\n \n-    #[test]\n-    fn file_test_full_simple() {\n-        file_test_full_simple_impl();\n-    }\n-\n-    #[test]\n-    fn file_test_full_simple_sync() {\n-        file_test_full_simple_impl_sync();\n-    }\n-\n     fn naive_print(loop_: &Loop, input: &str) {\n-        let mut stdout = FileDescriptor(STDOUT_FILENO);\n         let write_val = input.as_bytes();\n         let write_buf = slice_to_uv_buf(write_val);\n-        stdout.write_sync(loop_, write_buf, -1);\n+        let write_req = FsRequest::new();\n+        write_req.write_sync(loop_, STDOUT_FILENO, write_buf, -1);\n     }\n \n     #[test]\n@@ -433,4 +527,130 @@ mod test {\n             loop_.close();\n         };\n     }\n+    #[test]\n+    fn file_test_stat_simple() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/file_test_stat_simple.txt\";\n+            let create_flags = O_RDWR |\n+                O_CREAT;\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let write_val = \"hello\".as_bytes().to_owned();\n+            let write_buf  = slice_to_uv_buf(write_val);\n+            let write_buf_ptr: *Buf = &write_buf;\n+            let open_req = FsRequest::new();\n+            do open_req.open(&loop_, &path, create_flags as int, mode as int)\n+            |req, uverr| {\n+                assert!(uverr.is_none());\n+                let fd = req.get_result();\n+                let buf = unsafe { *write_buf_ptr };\n+                let write_req = FsRequest::new();\n+                do write_req.write(&req.get_loop(), fd, buf, 0) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat_req = FsRequest::new();\n+                    do stat_req.stat(&loop_, &path) |req, uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat = req.get_stat();\n+                        let sz: uint = stat.st_size as uint;\n+                        assert!(sz > 0);\n+                        let close_req = FsRequest::new();\n+                        do close_req.close(&loop_, fd) |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let unlink_req = FsRequest::new();\n+                            do unlink_req.unlink(&loop_, &path) |req,uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                let stat_req = FsRequest::new();\n+                                do stat_req.stat(&loop_, &path) |_, uverr| {\n+                                    // should cause an error because the\n+                                    // file doesn't exist anymore\n+                                    assert!(uverr.is_some());\n+                                };\n+                            };\n+                        };\n+                    };\n+                };\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_mk_rm_dir() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/mk_rm_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let stat_req = FsRequest::new();\n+                do stat_req.stat(&loop_, &path) |req, uverr| {\n+                    assert!(uverr.is_none());\n+                    let loop_ = req.get_loop();\n+                    let stat = req.get_stat();\n+                    naive_print(&loop_, fmt!(\"%?\", stat));\n+                    assert!(stat.is_dir());\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                        let stat_req = FsRequest::new();\n+                        do stat_req.stat(&loop_, &path) |req, uverr| {\n+                            assert!(uverr.is_some());\n+                        }\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_mkdir_chokes_on_double_create() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/double_create_dir\";\n+            let mode = S_IWUSR |\n+                S_IRUSR;\n+            let mkdir_req = FsRequest::new();\n+            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                assert!(uverr.is_none());\n+                let loop_ = req.get_loop();\n+                let mkdir_req = FsRequest::new();\n+                do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                    assert!(uverr.is_some());\n+                    let loop_ = req.get_loop();\n+                    let stat = req.get_stat();\n+                    let rmdir_req = FsRequest::new();\n+                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                        assert!(uverr.is_none());\n+                        let loop_ = req.get_loop();\n+                    }\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+    #[test]\n+    fn file_test_rmdir_chokes_on_nonexistant_path() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let path = \"./tmp/never_existed_dir\";\n+            let rmdir_req = FsRequest::new();\n+            do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                assert!(uverr.is_some());\n+            }\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n }"}, {"sha": "76dcf6daae681c9b35bd2c19e820abf789ebcf25", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 130, "deletions": 17, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -32,11 +32,13 @@ use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n use rt::uv::addrinfo::GetAddrInfoRequest;\n use unstable::sync::Exclusive;\n+use path::Path;\n use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n-          S_IRUSR, S_IWUSR};\n+          S_IRUSR, S_IWUSR, S_IRWXU};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-            CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite};\n+             CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n+             FileStat};\n use task;\n \n #[cfg(test)] use container::Container;\n@@ -407,6 +409,36 @@ impl UvIoFactory {\n     }\n }\n \n+/// Helper for a variety of simple uv_fs_* functions that\n+/// have no ret val\n+fn uv_fs_helper<P: PathLike>(loop_: &mut Loop, path: &P,\n+                             cb: ~fn(&mut FsRequest, &mut Loop, &P,\n+                                     ~fn(&FsRequest, Option<UvError>)))\n+        -> Result<(), IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+    let path_cell = Cell::new(path);\n+    do task::unkillable { // FIXME(#8674)\n+        let scheduler: ~Scheduler = Local::take();\n+        let mut new_req = FsRequest::new();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do cb(&mut new_req, loop_, path) |_, err| {\n+                let res = match err {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        }\n+    }\n+    assert!(!result_cell.is_empty());\n+    return result_cell.take();\n+}\n+\n impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n@@ -512,7 +544,6 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n-        let fd = file::FileDescriptor(fd);\n         let home = get_handle_to_current_scheduler!();\n         ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n     }\n@@ -543,15 +574,16 @@ impl IoFactory for UvIoFactory {\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n+            let open_req = file::FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                do file::FsRequest::open(self.uv_loop(), path, flags as int, create_mode as int)\n+                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n                       |req,err| {\n                     if err.is_none() {\n                         let loop_ = Loop {handle: req.get_loop().native_handle()};\n                         let home = get_handle_to_current_scheduler!();\n-                        let fd = file::FileDescriptor(req.get_result());\n+                        let fd = req.get_result() as c_int;\n                         let fs = ~UvFileStream::new(\n                             loop_, fd, true, home) as ~RtioFileStream;\n                         let res = Ok(fs);\n@@ -566,31 +598,56 @@ impl IoFactory for UvIoFactory {\n                     }\n                 };\n             };\n-        }\n+        };\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n+            do unlink_req.unlink(l, p) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError> {\n+        use str::StrSlice;\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<FileStat,\n+                                           IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n+                let path_str = path.path_as_str(|p| p.to_owned());\n+                do stat_req.stat(self.uv_loop(), path)\n+                      |req,err| {\n                     let res = match err {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n+                        None => {\n+                            let stat = req.get_stat();\n+                            Ok(FileStat {\n+                                path: Path(path_str),\n+                                is_file: stat.is_file(),\n+                                is_dir: stat.is_dir(),\n+                                size: stat.st_size,\n+                                created: stat.st_ctim.tv_sec as u64,\n+                                modified: stat.st_mtim.tv_sec as u64,\n+                                accessed: stat.st_atim.tv_sec as u64\n+                            })\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n                     };\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n             };\n-        }\n+        };\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n@@ -625,6 +682,59 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        let mode = S_IRWXU as int;\n+        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n+            do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n+            do rmdir_req.rmdir(l, p) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n+        Result<~[Path], IoError> {\n+        use str::StrSlice;\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[Path],\n+                                           IoError>> = &result_cell;\n+        let path_cell = Cell::new(path);\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            let stat_req = file::FsRequest::new();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let path = path_cell.take();\n+                let path_str = path.path_as_str(|p| p.to_owned());\n+                do stat_req.readdir(self.uv_loop(), path, flags)\n+                      |req,err| {\n+                    let res = match err {\n+                        None => {\n+                            let rel_paths = req.get_paths();\n+                            let mut paths = ~[];\n+                            for r in rel_paths.iter() {\n+                                paths.push(Path(path_str+\"/\"+*r));\n+                            }\n+                            Ok(paths)\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                };\n+            };\n+        };\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -1163,7 +1273,7 @@ impl RtioTimer for UvTimer {\n \n pub struct UvFileStream {\n     loop_: Loop,\n-    fd: file::FileDescriptor,\n+    fd: c_int,\n     close_on_drop: bool,\n     home: SchedHandle\n }\n@@ -1173,7 +1283,7 @@ impl HomingIO for UvFileStream {\n }\n \n impl UvFileStream {\n-    fn new(loop_: Loop, fd: file::FileDescriptor, close_on_drop: bool,\n+    fn new(loop_: Loop, fd: c_int, close_on_drop: bool,\n            home: SchedHandle) -> UvFileStream {\n         UvFileStream {\n             loop_: loop_,\n@@ -1190,7 +1300,8 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.read(&self_.loop_, buf, offset) |req, uverr| {\n+                let read_req = file::FsRequest::new();\n+                do read_req.read(&self_.loop_, self_.fd, buf, offset) |req, uverr| {\n                     let res = match uverr  {\n                         None => Ok(req.get_result() as int),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1211,7 +1322,8 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.write(&self_.loop_, buf, offset) |_, uverr| {\n+                let write_req = file::FsRequest::new();\n+                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n                     let res = match uverr  {\n                         None => Ok(()),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1228,7 +1340,7 @@ impl UvFileStream {\n         Result<u64, IoError>{\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n-            match lseek((*self.fd), pos as off_t, whence) {\n+            match lseek(self.fd, pos as off_t, whence) {\n                 -1 => {\n                     Err(IoError {\n                         kind: OtherIoError,\n@@ -1249,7 +1361,8 @@ impl Drop for UvFileStream {\n             do self_.home_for_io_with_sched |self_, scheduler| {\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n-                    do self_.fd.close(&self.loop_) |_,_| {\n+                    let close_req = file::FsRequest::new();\n+                    do close_req.close(&self.loop_, self_.fd) |_,_| {\n                         let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     };"}, {"sha": "42102a52e2e356a74bdcdeffe7414a1305ba9c46", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -96,6 +96,59 @@ pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n pub type uv_getaddrinfo_t = c_void;\n \n+pub struct uv_timespec_t {\n+    tv_sec: libc::c_long,\n+    tv_nsec: libc::c_long\n+}\n+\n+pub struct uv_stat_t {\n+    st_dev: libc::uint64_t,\n+    st_mode: libc::uint64_t,\n+    st_nlink: libc::uint64_t,\n+    st_uid: libc::uint64_t,\n+    st_gid: libc::uint64_t,\n+    st_rdev: libc::uint64_t,\n+    st_ino: libc::uint64_t,\n+    st_size: libc::uint64_t,\n+    st_blksize: libc::uint64_t,\n+    st_blocks: libc::uint64_t,\n+    st_flags: libc::uint64_t,\n+    st_gen: libc::uint64_t,\n+    st_atim: uv_timespec_t,\n+    st_mtim: uv_timespec_t,\n+    st_ctim: uv_timespec_t,\n+    st_birthtim: uv_timespec_t\n+}\n+\n+impl uv_stat_t {\n+    pub fn new() -> uv_stat_t {\n+        uv_stat_t {\n+            st_dev: 0,\n+            st_mode: 0,\n+            st_nlink: 0,\n+            st_uid: 0,\n+            st_gid: 0,\n+            st_rdev: 0,\n+            st_ino: 0,\n+            st_size: 0,\n+            st_blksize: 0,\n+            st_blocks: 0,\n+            st_flags: 0,\n+            st_gen: 0,\n+            st_atim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_mtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_ctim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n+            st_birthtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 }\n+        }\n+    }\n+    pub fn is_file(&self) -> bool {\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFREG as libc::uint64_t\n+    }\n+    pub fn is_dir(&self) -> bool {\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFDIR as libc::uint64_t\n+    }\n+}\n+\n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n #[cfg(stage0)]\n@@ -736,6 +789,39 @@ pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n \n     rust_uv_fs_close(loop_ptr, req, fd, cb)\n }\n+pub unsafe fn fs_stat(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_stat(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n+}\n+pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n+}\n+pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n+}\n+pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                flags: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_readdir(loop_ptr, req, path, flags, cb)\n+}\n+pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_populate_uv_stat(req_in, stat_out)\n+}\n pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -748,6 +834,11 @@ pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n \n     rust_uv_get_result_from_fs_req(req)\n }\n+pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_ptr_from_fs_req(req)\n+}\n pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -928,8 +1019,18 @@ extern {\n                        buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n     fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                         cb: *u8) -> c_int;\n+    fn rust_uv_fs_stat(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int;\n+    fn rust_uv_fs_fstat(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_mkdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        cb: *u8) -> c_int;\n+    fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        flags: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n+    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n+    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n "}, {"sha": "93cac8797bb75faeef9768dadb1045325125fdd8", "filename": "src/libstd/str.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -938,6 +938,7 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n+    use option::{Option, Some};\n     use cast;\n     use libc;\n     use ptr;\n@@ -1091,6 +1092,34 @@ pub mod raw {\n         vec::raw::set_len(as_owned_vec(s), new_len)\n     }\n \n+    /// Parses a C \"multistring\", eg windows env values or\n+    /// the req->ptr result in a uv_fs_readdir() call.\n+    /// Optionally, a `count` can be passed in, limiting the\n+    /// parsing to only being done `count`-times.\n+    #[inline]\n+    pub unsafe fn from_c_multistring(buf: *libc::c_char, count: Option<uint>) -> ~[~str] {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        let mut curr_ptr: uint = buf as uint;\n+        let mut result = ~[];\n+        let mut ctr = 0;\n+        let (limited_count, limit) = match count {\n+            Some(limit) => (true, limit),\n+            None => (false, 0)\n+        };\n+        while(*(curr_ptr as *libc::c_char) != 0 as libc::c_char\n+             && ((limited_count && ctr < limit) || !limited_count)) {\n+            let env_pair = from_c_str(\n+                curr_ptr as *libc::c_char);\n+            result.push(env_pair);\n+            curr_ptr +=\n+                libc::strlen(curr_ptr as *libc::c_char) as uint\n+                + 1;\n+            ctr += 1;\n+        }\n+        result\n+    }\n+\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n@@ -1106,6 +1135,25 @@ pub mod raw {\n         }\n     }\n \n+    #[test]\n+    fn test_str_multistring_parsing() {\n+        use option::None;\n+        unsafe {\n+            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n+            let ptr = vec::raw::to_ptr(input);\n+            let mut result = from_c_multistring(ptr as *libc::c_char, None);\n+            assert!(result.len() == 2);\n+            let mut ctr = 0;\n+            for x in result.iter() {\n+                match ctr {\n+                    0 => assert_eq!(x, &~\"zero\"),\n+                    1 => assert_eq!(x, &~\"one\"),\n+                    _ => fail!(\"shouldn't happen!\")\n+                }\n+                ctr += 1;\n+            }\n+        }\n+    }\n }\n \n /*"}, {"sha": "9b460cffd747c920f062a99e4429f23c0864bf83", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -542,6 +542,10 @@ extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }\n+extern \"C\" void*\n+rust_uv_get_ptr_from_fs_req(uv_fs_t* req) {\n+  return req->ptr;\n+}\n extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n@@ -551,3 +555,50 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n   return req->loop;\n }\n+\n+extern \"C\" int\n+rust_uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_stat(loop, req, path, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n+  return uv_fs_fstat(loop, req, file, cb);\n+}\n+\n+extern \"C\" void\n+rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n+  stat_out->st_dev = req_in->statbuf.st_dev;\n+  stat_out->st_mode = req_in->statbuf.st_mode;\n+  stat_out->st_nlink = req_in->statbuf.st_nlink;\n+  stat_out->st_uid = req_in->statbuf.st_uid;\n+  stat_out->st_gid = req_in->statbuf.st_gid;\n+  stat_out->st_rdev = req_in->statbuf.st_rdev;\n+  stat_out->st_ino = req_in->statbuf.st_ino;\n+  stat_out->st_size = req_in->statbuf.st_size;\n+  stat_out->st_blksize = req_in->statbuf.st_blksize;\n+  stat_out->st_blocks = req_in->statbuf.st_blocks;\n+  stat_out->st_flags = req_in->statbuf.st_flags;\n+  stat_out->st_gen = req_in->statbuf.st_gen;\n+  stat_out->st_atim.tv_sec = req_in->statbuf.st_atim.tv_sec;\n+  stat_out->st_atim.tv_nsec = req_in->statbuf.st_atim.tv_nsec;\n+  stat_out->st_mtim.tv_sec = req_in->statbuf.st_mtim.tv_sec;\n+  stat_out->st_mtim.tv_nsec = req_in->statbuf.st_mtim.tv_nsec;\n+  stat_out->st_ctim.tv_sec = req_in->statbuf.st_ctim.tv_sec;\n+  stat_out->st_ctim.tv_nsec = req_in->statbuf.st_ctim.tv_nsec;\n+  stat_out->st_birthtim.tv_sec = req_in->statbuf.st_birthtim.tv_sec;\n+  stat_out->st_birthtim.tv_nsec = req_in->statbuf.st_birthtim.tv_nsec;\n+}\n+\n+extern \"C\" int\n+rust_uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n+  return uv_fs_mkdir(loop, req, path, mode, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_rmdir(loop, req, path, cb);\n+}\n+\n+extern \"C\" int\n+rust_uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {\n+  return uv_fs_readdir(loop, req, path, flags, cb);\n+}"}, {"sha": "3be958837dc4b8fd3a74ff2f5364265d1f18a874", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/c135cb268355afe77d2ce0313a8d3e20a4e2fdd3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=c135cb268355afe77d2ce0313a8d3e20a4e2fdd3", "patch": "@@ -113,8 +113,15 @@ rust_uv_fs_write\n rust_uv_fs_read\n rust_uv_fs_close\n rust_uv_get_result_from_fs_req\n+rust_uv_get_ptr_from_fs_req\n rust_uv_get_loop_from_fs_req\n+rust_uv_fs_stat\n+rust_uv_fs_fstat\n rust_uv_fs_req_cleanup\n+rust_uv_populate_uv_stat\n+rust_uv_fs_mkdir\n+rust_uv_fs_rmdir\n+rust_uv_fs_readdir\n rust_dbg_lock_create\n rust_dbg_lock_destroy\n rust_dbg_lock_lock"}]}