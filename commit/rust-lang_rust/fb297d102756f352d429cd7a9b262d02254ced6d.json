{"sha": "fb297d102756f352d429cd7a9b262d02254ced6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMjk3ZDEwMjc1NmYzNTJkNDI5Y2Q3YTliMjYyZDAyMjU0Y2VkNmQ=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-03-10T11:06:44Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-03-10T11:57:05Z"}, "message": "Remove unneeded macro witchery", "tree": {"sha": "0c70af361041f44e7d275c9b39df8779d7d544d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c70af361041f44e7d275c9b39df8779d7d544d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb297d102756f352d429cd7a9b262d02254ced6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb297d102756f352d429cd7a9b262d02254ced6d", "html_url": "https://github.com/rust-lang/rust/commit/fb297d102756f352d429cd7a9b262d02254ced6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb297d102756f352d429cd7a9b262d02254ced6d/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "html_url": "https://github.com/rust-lang/rust/commit/1cc8b6ec664f30b43f75551e95299d943c8a4e6a"}], "stats": {"total": 81, "additions": 40, "deletions": 41}, "files": [{"sha": "c516bd54129c867cc0de85d69c8ab5d6db6ad39f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb297d102756f352d429cd7a9b262d02254ced6d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb297d102756f352d429cd7a9b262d02254ced6d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fb297d102756f352d429cd7a9b262d02254ced6d", "patch": "@@ -324,21 +324,20 @@ pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte {\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-}\n+/// Return the initial codepoint accumulator for the first byte.\n+/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+/// for width 3, and 3 bits for width 4.\n+#[inline]\n+fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }\n \n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte {\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & CONT_MASK) as u32)\n-}\n+/// Return the value of `ch` updated with continuation byte `byte`.\n+#[inline]\n+fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n \n-macro_rules! utf8_is_cont_byte {\n-    ($byte:expr) => (($byte & !CONT_MASK) == TAG_CONT_U8)\n-}\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e. starts with the\n+/// bits `10`).\n+#[inline]\n+fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }\n \n #[inline]\n fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n@@ -363,20 +362,20 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Multibyte case follows\n     // Decode from a byte combination out of: [[[x y] z] w]\n     // NOTE: Performance is sensitive to the exact formulation here\n-    let init = utf8_first_byte!(x, 2);\n+    let init = utf8_first_byte(x, 2);\n     let y = unwrap_or_0(bytes.next());\n-    let mut ch = utf8_acc_cont_byte!(init, y);\n+    let mut ch = utf8_acc_cont_byte(init, y);\n     if x >= 0xE0 {\n         // [[x y z] w] case\n         // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n         let z = unwrap_or_0(bytes.next());\n-        let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n         ch = init << 12 | y_z;\n         if x >= 0xF0 {\n             // [x y z w] case\n             // use only the lower 3 bits of `init`\n             let w = unwrap_or_0(bytes.next());\n-            ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n         }\n     }\n \n@@ -399,18 +398,18 @@ pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode from a byte combination out of: [x [y [z w]]]\n     let mut ch;\n     let z = unwrap_or_0(bytes.next_back());\n-    ch = utf8_first_byte!(z, 2);\n-    if utf8_is_cont_byte!(z) {\n+    ch = utf8_first_byte(z, 2);\n+    if utf8_is_cont_byte(z) {\n         let y = unwrap_or_0(bytes.next_back());\n-        ch = utf8_first_byte!(y, 3);\n-        if utf8_is_cont_byte!(y) {\n+        ch = utf8_first_byte(y, 3);\n+        if utf8_is_cont_byte(y) {\n             let x = unwrap_or_0(bytes.next_back());\n-            ch = utf8_first_byte!(x, 4);\n-            ch = utf8_acc_cont_byte!(ch, y);\n+            ch = utf8_first_byte(x, 4);\n+            ch = utf8_acc_cont_byte(ch, y);\n         }\n-        ch = utf8_acc_cont_byte!(ch, z);\n+        ch = utf8_acc_cont_byte(ch, z);\n     }\n-    ch = utf8_acc_cont_byte!(ch, w);\n+    ch = utf8_acc_cont_byte(ch, w);\n \n     Some(ch)\n }\n@@ -1027,7 +1026,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1580,14 +1579,14 @@ impl StrExt for str {\n                 i -= 1;\n             }\n \n-            let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n-            assert!((w != 0));\n+            let first= s.as_bytes()[i];\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n+            assert!(w != 0);\n \n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n+            let mut val = utf8_first_byte(first, w as u32);\n+            val = utf8_acc_cont_byte(val, s.as_bytes()[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 3]); }\n \n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }\n@@ -1672,16 +1671,16 @@ pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n     fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n-        let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n-        assert!((w != 0));\n+        let first = bytes[i];\n+        let w = UTF8_CHAR_WIDTH[first as usize];\n+        assert!(w != 0);\n \n-        val = utf8_first_byte!(val, w);\n-        val = utf8_acc_cont_byte!(val, bytes[i + 1]);\n-        if w > 2 { val = utf8_acc_cont_byte!(val, bytes[i + 2]); }\n-        if w > 3 { val = utf8_acc_cont_byte!(val, bytes[i + 3]); }\n+        let mut val = utf8_first_byte(first, w as u32);\n+        val = utf8_acc_cont_byte(val, bytes[i + 1]);\n+        if w > 2 { val = utf8_acc_cont_byte(val, bytes[i + 2]); }\n+        if w > 3 { val = utf8_acc_cont_byte(val, bytes[i + 3]); }\n \n-        return (val, i + w);\n+        return (val, i + w as usize);\n     }\n \n     multibyte_char_range_at(bytes, i)"}]}