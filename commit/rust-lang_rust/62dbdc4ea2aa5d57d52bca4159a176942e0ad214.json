{"sha": "62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZGJkYzRlYTJhYTVkNTdkNTJiY2E0MTU5YTE3Njk0MmUwYWQyMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-07T04:05:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-07T04:05:11Z"}, "message": "auto merge of #8287 : sfackler/rust/hex, r=alexcrichton\n\nFromHex ignores whitespace and parses either upper or lower case hex\r\ndigits. ToHex outputs lower case hex digits with no whitespace. Unlike\r\nToBase64, ToHex doesn't allow you to configure the output format. I\r\ndon't feel that it's super useful in this case.", "tree": {"sha": "cc4a68a6bf92c5844d98d3f7d43c2c659a6b35f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc4a68a6bf92c5844d98d3f7d43c2c659a6b35f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "html_url": "https://github.com/rust-lang/rust/commit/62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b4244d917cc9341b1ec04c4e245d5f841d3facc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4244d917cc9341b1ec04c4e245d5f841d3facc", "html_url": "https://github.com/rust-lang/rust/commit/5b4244d917cc9341b1ec04c4e245d5f841d3facc"}, {"sha": "3b441c485f10722e58f71957b78e5950c53757d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b441c485f10722e58f71957b78e5950c53757d4", "html_url": "https://github.com/rust-lang/rust/commit/3b441c485f10722e58f71957b78e5950c53757d4"}], "stats": {"total": 378, "additions": 264, "deletions": 114}, "files": [{"sha": "b4431004bd74cff0dd38693c5093d4b590c479be", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 70, "deletions": 114, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! Base64 binary-to-text encoding\n+use std::str;\n \n /// Available encoding character sets\n pub enum CharacterSet {\n@@ -40,21 +41,13 @@ pub static URL_SAFE: Config =\n pub static MIME: Config =\n     Config {char_set: Standard, pad: true, line_length: Some(76)};\n \n-static STANDARD_CHARS: [char, ..64] = [\n-    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n-];\n-\n-static URLSAFE_CHARS: [char, ..64] = [\n-    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n-];\n+static STANDARD_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n+                                             \"abcdefghijklmnopqrstuvwxyz\",\n+                                             \"0123456789+/\");\n+\n+static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n+                                            \"abcdefghijklmnopqrstuvwxyz\",\n+                                            \"0123456789-_\");\n \n /// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n@@ -80,20 +73,21 @@ impl<'self> ToBase64 for &'self [u8] {\n      * ~~~\n      */\n     fn to_base64(&self, config: Config) -> ~str {\n-        let chars = match config.char_set {\n+        let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut s = ~\"\";\n+        let mut v: ~[u8] = ~[];\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n         while i < len - (len % 3) {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        s.push_str(\"\\r\\n\");\n+                        v.push('\\r' as u8);\n+                        v.push('\\n' as u8);\n                         cur_length = 0;\n                     },\n                 None => ()\n@@ -104,10 +98,10 @@ impl<'self> ToBase64 for &'self [u8] {\n                     (self[i + 2] as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            s.push_char(chars[(n >> 18) & 63]);\n-            s.push_char(chars[(n >> 12) & 63]);\n-            s.push_char(chars[(n >> 6 ) & 63]);\n-            s.push_char(chars[n & 63]);\n+            v.push(bytes[(n >> 18) & 63]);\n+            v.push(bytes[(n >> 12) & 63]);\n+            v.push(bytes[(n >> 6 ) & 63]);\n+            v.push(bytes[n & 63]);\n \n             cur_length += 4;\n             i += 3;\n@@ -117,7 +111,8 @@ impl<'self> ToBase64 for &'self [u8] {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        s.push_str(\"\\r\\n\");\n+                        v.push('\\r' as u8);\n+                        v.push('\\n' as u8);\n                     },\n                 None => ()\n             }\n@@ -129,48 +124,29 @@ impl<'self> ToBase64 for &'self [u8] {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n-                s.push_char(chars[(n >> 18) & 63]);\n-                s.push_char(chars[(n >> 12) & 63]);\n+                v.push(bytes[(n >> 18) & 63]);\n+                v.push(bytes[(n >> 12) & 63]);\n                 if config.pad {\n-                    s.push_str(\"==\");\n+                    v.push('=' as u8);\n+                    v.push('=' as u8);\n                 }\n             }\n             2 => {\n                 let n = (self[i] as u32) << 16 |\n                     (self[i + 1u] as u32) << 8;\n-                s.push_char(chars[(n >> 18) & 63]);\n-                s.push_char(chars[(n >> 12) & 63]);\n-                s.push_char(chars[(n >> 6 ) & 63]);\n+                v.push(bytes[(n >> 18) & 63]);\n+                v.push(bytes[(n >> 12) & 63]);\n+                v.push(bytes[(n >> 6 ) & 63]);\n                 if config.pad {\n-                    s.push_char('=');\n+                    v.push('=' as u8);\n                 }\n             }\n             _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n-        s\n-    }\n-}\n \n-impl<'self> ToBase64 for &'self str {\n-    /**\n-     * Convert any string (literal, `@`, `&`, or `~`) to base64 encoding.\n-     *\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, standard};\n-     *\n-     * fn main () {\n-     *     let str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     * }\n-     * ~~~\n-     *\n-     */\n-    fn to_base64(&self, config: Config) -> ~str {\n-        self.as_bytes().to_base64(config)\n+        unsafe {\n+            str::raw::from_bytes_owned(v)\n+        }\n     }\n }\n \n@@ -181,22 +157,31 @@ pub trait FromBase64 {\n     fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromBase64 for &'self [u8] {\n+impl<'self> FromBase64 for &'self str {\n     /**\n-     * Convert base64 `u8` vector into u8 byte values.\n-     * Every 4 encoded characters is converted into 3 octets, modulo padding.\n+     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n+     * This converts a string literal to base64 and back.\n+     *\n      * ~~~ {.rust}\n      * extern mod extra;\n      * use extra::base64::{ToBase64, FromBase64, standard};\n+     * use std::str;\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     *     let bytes = str.from_base64();\n+     *     let hello_str = \"Hello, World\".to_base64(standard);\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_base64();\n      *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n      * }\n      * ~~~\n      */\n@@ -205,20 +190,20 @@ impl<'self> FromBase64 for &'self [u8] {\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n-        let mut it = self.iter();\n-        for &byte in it {\n-            let ch = byte as char;\n+        let mut it = self.byte_iter().enumerate();\n+        for (idx, byte) in it {\n             let val = byte as u32;\n \n-            match ch {\n+            match byte as char {\n                 'A'..'Z' => buf |= val - 0x41,\n                 'a'..'z' => buf |= val - 0x47,\n                 '0'..'9' => buf |= val + 0x04,\n                 '+'|'-' => buf |= 0x3E,\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '=' => break,\n-                _ => return Err(~\"Invalid Base64 character\")\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n             }\n \n             buf <<= 6;\n@@ -231,8 +216,11 @@ impl<'self> FromBase64 for &'self [u8] {\n             }\n         }\n \n-        if !it.all(|&byte| {byte as char == '='}) {\n-            return Err(~\"Invalid Base64 character\");\n+        for (idx, byte) in it {\n+            if (byte as char) != '=' {\n+                return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                self.char_at(idx), idx));\n+            }\n         }\n \n         match modulus {\n@@ -251,67 +239,35 @@ impl<'self> FromBase64 for &'self [u8] {\n     }\n }\n \n-impl<'self> FromBase64 for &'self str {\n-    /**\n-     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those\n-     * values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to base64 and back.\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, FromBase64, standard};\n-     * use std::str;\n-     *\n-     * fn main () {\n-     *     let hello_str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", hello_str);\n-     *     let bytes = hello_str.from_base64();\n-     *     printfln!(\"%?\", bytes);\n-     *     let result_str = str::from_bytes(bytes);\n-     *     printfln!(\"%s\", result_str);\n-     * }\n-     * ~~~\n-     */\n-    fn from_base64(&self) -> Result<~[u8], ~str> {\n-        self.as_bytes().from_base64()\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use test::BenchHarness;\n     use base64::*;\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n-        assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n-        assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n-        assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n-        assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), ~\"\");\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), ~\"Zg==\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), ~\"Zm8=\");\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), ~\"Zm9v\");\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), ~\"Zm9vYg==\");\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmE=\");\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n                 .contains(\"\\r\\n\"));\n-        assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n+        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n+                                                         ..STANDARD}),\n                    ~\"Zm9v\\r\\nYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n-        assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n     }\n \n     #[test]\n@@ -345,7 +301,7 @@ mod test {\n     #[test]\n     fn test_from_base64_invalid_char() {\n         assert!(\"Zm$=\".from_base64().is_err())\n-            assert!(\"Zg==$\".from_base64().is_err());\n+        assert!(\"Zg==$\".from_base64().is_err());\n     }\n \n     #[test]\n@@ -369,20 +325,20 @@ mod test {\n     }\n \n     #[bench]\n-    pub fn to_base64(bh: & mut BenchHarness) {\n+    pub fn bench_to_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         do bh.iter {\n-            s.to_base64(STANDARD);\n+            s.as_bytes().to_base64(STANDARD);\n         }\n         bh.bytes = s.len() as u64;\n     }\n \n     #[bench]\n-    pub fn from_base64(bh: & mut BenchHarness) {\n+    pub fn bench_from_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let b = s.to_base64(STANDARD);\n+        let b = s.as_bytes().to_base64(STANDARD);\n         do bh.iter {\n             b.from_base64();\n         }"}, {"sha": "44781a1fd19b632f0794802ae3d9ee8cbae167ce", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "patch": "@@ -102,6 +102,7 @@ pub mod stats;\n pub mod semver;\n pub mod fileinput;\n pub mod flate;\n+pub mod hex;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "d5345cb956b8f2004eb6d7571b27af9d7f7465b3", "filename": "src/libextra/hex.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62dbdc4ea2aa5d57d52bca4159a176942e0ad214/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=62dbdc4ea2aa5d57d52bca4159a176942e0ad214", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hex binary-to-text encoding\n+use std::str;\n+use std::vec;\n+\n+/// A trait for converting a value to hexadecimal encoding\n+pub trait ToHex {\n+    /// Converts the value of `self` to a hex value, returning the owned\n+    /// string.\n+    fn to_hex(&self) -> ~str;\n+}\n+\n+static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n+\n+impl<'self> ToHex for &'self [u8] {\n+    /**\n+     * Turn a vector of `u8` bytes into a hexadecimal string.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::ToHex;\n+     *\n+     * fn main () {\n+     *     let str = [52,32].to_hex();\n+     *     printfln!(\"%s\", str);\n+     * }\n+     * ~~~\n+     */\n+    fn to_hex(&self) -> ~str {\n+        let mut v = vec::with_capacity(self.len() * 2);\n+        for &byte in self.iter() {\n+            v.push(CHARS[byte >> 4]);\n+            v.push(CHARS[byte & 0xf]);\n+        }\n+\n+        unsafe {\n+            str::raw::from_bytes_owned(v)\n+        }\n+    }\n+}\n+\n+/// A trait for converting hexadecimal encoded values\n+pub trait FromHex {\n+    /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n+    /// into an owned vector of bytes, returning the vector.\n+    fn from_hex(&self) -> Result<~[u8], ~str>;\n+}\n+\n+impl<'self> FromHex for &'self str {\n+    /**\n+     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n+     *\n+     * # Example\n+     *\n+     * This converts a string literal to hexadecimal and back.\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::{FromHex, ToHex};\n+     * use std::str;\n+     *\n+     * fn main () {\n+     *     let hello_str = \"Hello, World\".to_hex();\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_hex().unwrap();\n+     *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n+     * }\n+     * ~~~\n+     */\n+    fn from_hex(&self) -> Result<~[u8], ~str> {\n+        // This may be an overestimate if there is any whitespace\n+        let mut b = vec::with_capacity(self.len() / 2);\n+        let mut modulus = 0;\n+        let mut buf = 0u8;\n+\n+        for (idx, byte) in self.byte_iter().enumerate() {\n+            buf <<= 4;\n+\n+            match byte as char {\n+                'A'..'F' => buf |= byte - ('A' as u8) + 10,\n+                'a'..'f' => buf |= byte - ('a' as u8) + 10,\n+                '0'..'9' => buf |= byte - ('0' as u8),\n+                ' '|'\\r'|'\\n'|'\\t' => {\n+                    buf >>= 4;\n+                    loop\n+                }\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n+            }\n+\n+            modulus += 1;\n+            if modulus == 2 {\n+                modulus = 0;\n+                b.push(buf);\n+            }\n+        }\n+\n+        match modulus {\n+            0 => Ok(b),\n+            _ => Err(~\"Invalid input length\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test::BenchHarness;\n+    use hex::*;\n+\n+    #[test]\n+    pub fn test_to_hex() {\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), ~\"666f6f626172\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_okay() {\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_odd_len() {\n+        assert!(\"666\".from_hex().is_err());\n+        assert!(\"66 6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_invalid_char() {\n+        assert!(\"66y6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_ignores_whitespace() {\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_to_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!([i as u8].to_hex(), fmt!(\"%02x\", i as uint));\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!(fmt!(\"%02x\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(fmt!(\"%02X\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_to_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        do bh.iter {\n+            s.as_bytes().to_hex();\n+        }\n+        bh.bytes = s.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn bench_from_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        let b = s.as_bytes().to_hex();\n+        do bh.iter {\n+            b.from_hex();\n+        }\n+        bh.bytes = b.len() as u64;\n+    }\n+}"}]}