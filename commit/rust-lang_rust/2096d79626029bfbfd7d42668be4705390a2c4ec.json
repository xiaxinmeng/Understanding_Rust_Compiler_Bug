{"sha": "2096d79626029bfbfd7d42668be4705390a2c4ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTZkNzk2MjYwMjliZmJmZDdkNDI2NjhiZTQ3MDUzOTBhMmM0ZWM=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-08T00:37:17Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-08T01:27:48Z"}, "message": "Avoid unnecessary allocations in the metadata decoder", "tree": {"sha": "199aff08c367889d8a5657a7d774838598223d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/199aff08c367889d8a5657a7d774838598223d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2096d79626029bfbfd7d42668be4705390a2c4ec", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2096d79626029bfbfd7d42668be4705390a2c4ec", "html_url": "https://github.com/rust-lang/rust/commit/2096d79626029bfbfd7d42668be4705390a2c4ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2096d79626029bfbfd7d42668be4705390a2c4ec/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e5aa09427ce9f0c17e367f680d671268009ede", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e5aa09427ce9f0c17e367f680d671268009ede", "html_url": "https://github.com/rust-lang/rust/commit/29e5aa09427ce9f0c17e367f680d671268009ede"}], "stats": {"total": 79, "additions": 40, "deletions": 39}, "files": [{"sha": "09e6a849f98b5e05ad4f7c1f61327d8ea5438a56", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2096d79626029bfbfd7d42668be4705390a2c4ec/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2096d79626029bfbfd7d42668be4705390a2c4ec/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=2096d79626029bfbfd7d42668be4705390a2c4ec", "patch": "@@ -93,6 +93,14 @@ pub mod reader {\n         pub fn get(&self, tag: uint) -> Doc {\n             get_doc(*self, tag)\n         }\n+\n+        pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+            str::from_bytes_slice(self.data.slice(self.start, self.end))\n+        }\n+\n+        pub fn as_str(&self) -> ~str {\n+            self.as_str_slice().to_owned()\n+        }\n     }\n \n     struct Res {\n@@ -239,15 +247,10 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn doc_data(d: Doc) -> ~[u8] {\n-        vec::slice::<u8>(*d.data, d.start, d.end).to_vec()\n-    }\n-\n     pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n         f(vec::slice(*d.data, d.start, d.end))\n     }\n \n-    pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n@@ -294,7 +297,7 @@ pub mod reader {\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n-                    let str = doc_as_str(r_doc);\n+                    let str = r_doc.as_str_slice();\n                     if lbl != str {\n                         fail!(\"Expected label %s but found %s\", lbl, str);\n                     }\n@@ -415,7 +418,9 @@ pub mod reader {\n         fn read_char(&mut self) -> char {\n             doc_as_u32(self.next_doc(EsChar)) as char\n         }\n-        fn read_str(&mut self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+        fn read_str(&mut self) -> ~str {\n+            self.next_doc(EsStr).as_str()\n+        }\n \n         // Compound types:\n         fn read_enum<T>(&mut self,"}, {"sha": "81c1560f18bd49a05823bc4c7c3d84eb0f89fd79", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2096d79626029bfbfd7d42668be4705390a2c4ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2096d79626029bfbfd7d42668be4705390a2c4ec/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2096d79626029bfbfd7d42668be4705390a2c4ec", "patch": "@@ -162,14 +162,13 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n \n fn item_method_sort(item: ebml::Doc) -> char {\n     for reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n-        return str::from_bytes(reader::doc_data(doc))[0] as char;\n+        return doc.as_str_slice()[0] as char;\n     }\n     return 'r';\n }\n \n fn item_symbol(item: ebml::Doc) -> ~str {\n-    let sym = reader::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(reader::doc_data(sym));\n+    reader::get_doc(item, tag_items_data_item_symbol).as_str()\n }\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n@@ -209,7 +208,7 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n-        int::parse_bytes(reader::doc_data(val_doc), 10u)\n+        do reader::with_doc_data(val_doc) |data| { int::parse_bytes(data, 10u) }\n     }\n }\n \n@@ -296,10 +295,10 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let mut result = vec::with_capacity(len);\n     for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = reader::doc_as_str(elt_doc);\n+            let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_mod(token::str_to_ident(str)));\n         } else if tag == tag_path_elt_name {\n-            let str = reader::doc_as_str(elt_doc);\n+            let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_name(token::str_to_ident(str)));\n         } else {\n             // ignore tag_path_len element\n@@ -311,12 +310,10 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n \n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n-    do reader::with_doc_data(name) |data| {\n-        let string = str::from_bytes_slice(data);\n-        match intr.find_equiv(&StringRef(string)) {\n-            None => token::str_to_ident(string),\n-            Some(val) => ast::new_ident(val),\n-        }\n+    let string = name.as_str_slice();\n+    match intr.find_equiv(&StringRef(string)) {\n+        None => token::str_to_ident(string),\n+        Some(val) => ast::new_ident(val),\n     }\n }\n \n@@ -506,19 +503,17 @@ pub fn each_path(intr: @ident_interner,\n             let def_id_doc =\n                 reader::get_doc(reexport_doc,\n                                 tag_items_data_item_reexport_def_id);\n-            let def_id =\n-                reader::with_doc_data(def_id_doc,\n-                                      |d| parse_def_id(d));\n+            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n             let def_id = translate_def_id(cdata, def_id);\n \n             let reexport_name_doc =\n                 reader::get_doc(reexport_doc,\n                                 tag_items_data_item_reexport_name);\n-            let reexport_name = reader::doc_as_str(reexport_name_doc);\n+            let reexport_name = reexport_name_doc.as_str_slice();\n \n             let reexport_path;\n             if path_is_empty {\n-                reexport_path = reexport_name;\n+                reexport_path = reexport_name.to_owned();\n             } else {\n                 reexport_path = path + \"::\" + reexport_name;\n             }\n@@ -639,7 +634,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     }\n \n     let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n-    let string = reader::doc_as_str(explicit_self_doc);\n+    let string = explicit_self_doc.as_str_slice();\n \n     let explicit_self_kind = string[0];\n     match explicit_self_kind as char {\n@@ -824,7 +819,7 @@ pub fn get_type_name_if_impl(cdata: cmd,\n     }\n \n     for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(token::str_to_ident(str::from_bytes(reader::doc_data(doc))));\n+        return Some(token::str_to_ident(doc.as_str_slice()));\n     }\n \n     return None;\n@@ -846,7 +841,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n     let mut impl_method_ids = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n-        impl_method_ids.push(parse_def_id(reader::doc_data(impl_method_doc)));\n+        impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n     }\n \n     let mut static_impl_methods = ~[];\n@@ -943,12 +938,13 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n-    let desc = reader::doc_data(d);\n-    let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n-    let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = str::from_bytes(pathbytes);\n+    do reader::with_doc_data(d) |desc| {\n+        let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n+        let pathbytes = desc.slice(4u, desc.len());\n+        let path = str::from_bytes(pathbytes);\n \n-    (path, pos)\n+        (path, pos)\n+    }\n }\n \n fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n@@ -989,21 +985,21 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(reader::doc_data(nd));\n+        let n = nd.as_str();\n         items.push(attr::mk_word_item(@n));\n     };\n     for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(reader::doc_data(nd));\n-        let v = str::from_bytes(reader::doc_data(vd));\n+        let n = nd.as_str();\n+        let v = vd.as_str();\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(@n, @v));\n     };\n     for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(reader::doc_data(nd));\n+        let n = nd.as_str();\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(@n, subitems));\n     };\n@@ -1072,7 +1068,7 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n     fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(reader::doc_data(reader::get_doc(doc, tag_)))\n+        reader::get_doc(doc, tag_).as_str()\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n@@ -1099,7 +1095,7 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n pub fn get_crate_hash(data: @~[u8]) -> @~str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    @str::from_bytes(reader::doc_data(hashdoc))\n+    @hashdoc.as_str()\n }\n \n pub fn get_crate_vers(data: @~[u8]) -> @~str {\n@@ -1154,7 +1150,7 @@ pub fn get_link_args_for_crate(cdata: cmd) -> ~[~str] {\n     let link_args = reader::get_doc(reader::Doc(cdata.data), tag_link_args);\n     let mut result = ~[];\n     for reader::tagged_docs(link_args, tag_link_args_arg) |arg_doc| {\n-        result.push(reader::doc_as_str(arg_doc));\n+        result.push(arg_doc.as_str());\n     }\n     result\n }"}]}