{"sha": "7ed27b5531ef25a366ab9e0fe537b7053244b947", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDI3YjU1MzFlZjI1YTM2NmFiOWUwZmU1MzdiNzA1MzI0NGI5NDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2013-11-27T05:02:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2013-11-27T05:02:25Z"}, "message": "Shink NodeId, CrateNum, Name and Mrk down to 32 bits on x64.", "tree": {"sha": "928cf9739748c77c26ae7e4c0580b287536c4fe9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928cf9739748c77c26ae7e4c0580b287536c4fe9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed27b5531ef25a366ab9e0fe537b7053244b947", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed27b5531ef25a366ab9e0fe537b7053244b947", "html_url": "https://github.com/rust-lang/rust/commit/7ed27b5531ef25a366ab9e0fe537b7053244b947", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed27b5531ef25a366ab9e0fe537b7053244b947/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b42c4388927db75f9a38edbeafbfe13775b1773d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b42c4388927db75f9a38edbeafbfe13775b1773d", "html_url": "https://github.com/rust-lang/rust/commit/b42c4388927db75f9a38edbeafbfe13775b1773d"}], "stats": {"total": 152, "additions": 74, "deletions": 78}, "files": [{"sha": "e497caa494604cd9232be437de824a262dc95337", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -28,7 +28,6 @@ use syntax::abi;\n use syntax::parse::token;\n use syntax;\n \n-use std::int;\n use std::hashmap::{HashMap,HashSet};\n \n #[deriving(Clone)]\n@@ -209,7 +208,7 @@ pub struct Session_ {\n     building_library: @mut bool,\n     working_dir: Path,\n     lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n-    node_id: @mut uint,\n+    node_id: @mut ast::NodeId,\n }\n \n pub type Session = @Session_;\n@@ -274,13 +273,15 @@ impl Session_ {\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)\n     }\n-    pub fn reserve_node_ids(&self, count: uint) -> ast::NodeId {\n+    pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n         let v = *self.node_id;\n-        *self.node_id += count;\n-        if v > (int::max_value as uint) {\n-            self.bug(\"Input too large, ran out of node ids!\");\n+\n+        match v.checked_add(&count) {\n+            Some(next) => { *self.node_id = next; }\n+            None => self.bug(\"Input too large, ran out of node ids!\")\n         }\n-        v as int\n+\n+        v\n     }\n     pub fn diagnostic(&self) -> @mut diagnostic::span_handler {\n         self.span_diagnostic"}, {"sha": "e71db97628347d1edf7ddb30ee9d2f974fa889fc", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -67,7 +67,7 @@ impl visit::Visitor<()> for ReadCrateVisitor {\n \n #[deriving(Clone)]\n struct cache_entry {\n-    cnum: int,\n+    cnum: ast::CrateNum,\n     span: Span,\n     hash: @str,\n     metas: @~[@ast::MetaItem]\n@@ -242,7 +242,7 @@ fn metas_with_ident(ident: @str, metas: ~[@ast::MetaItem])\n }\n \n fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n-               -> Option<int> {\n+               -> Option<ast::CrateNum> {\n     for c in e.crate_cache.iter() {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash.as_slice() == hash) {"}, {"sha": "ff53dda6f72f389e1add14f482e8c5e06c5b2199", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -76,18 +76,18 @@ fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n \n pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n \n-pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n-    fn eq_item(bytes: &[u8], item_id: int) -> bool {\n+pub fn maybe_find_item(item_id: ast::NodeId, items: ebml::Doc) -> Option<ebml::Doc> {\n+    fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes.slice(0u, 4u), 0u, 4u) as int\n+            bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n                 (item_id as i64).hash())\n }\n \n-fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n+fn find_item(item_id: ast::NodeId, items: ebml::Doc) -> ebml::Doc {\n     match maybe_find_item(item_id, items) {\n        None => fail!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n@@ -96,7 +96,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-pub fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n+pub fn lookup_item(item_id: ast::NodeId, data: @~[u8]) -> ebml::Doc {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     find_item(item_id, items)\n }\n@@ -343,7 +343,7 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::Ident {\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n         None => token::str_to_ident(string),\n-        Some(val) => ast::Ident::new(val),\n+        Some(val) => ast::Ident::new(val as ast::Name),\n     }\n }\n "}, {"sha": "a595e50115bbce64e93ffa969f11d01ac5716d0a", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -58,7 +58,7 @@ type conv_did<'self> =\n \n pub struct PState<'self> {\n     data: &'self [u8],\n-    crate: int,\n+    crate: ast::CrateNum,\n     pos: uint,\n     tcx: ty::ctxt\n }\n@@ -101,7 +101,7 @@ fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     return st.tcx.sess.ident_of(rslt);\n }\n \n-pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: int,\n+pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n                              pos: uint, tcx: ty::ctxt) -> PState<'a> {\n     PState {\n         data: data,\n@@ -111,19 +111,19 @@ pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: int,\n     }\n }\n \n-pub fn parse_ty_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n                      conv: conv_did) -> ty::t {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n+pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n@@ -251,15 +251,15 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n-        let id = parse_uint(st) as int;\n+        let id = parse_uint(st) as ast::NodeId;\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         ty::ReLateBound(id, br)\n       }\n       'B' => {\n         assert_eq!(next(st), '[');\n-        let node_id = parse_uint(st) as int;\n+        let node_id = parse_uint(st) as ast::NodeId;\n         assert_eq!(next(st), '|');\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n@@ -268,15 +268,15 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n-        let id = parse_uint(st) as int;\n+        let id = parse_uint(st) as ast::NodeId;\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         ty::ReFree(ty::FreeRegion {scope_id: id,\n                                     bound_region: br})\n       }\n       's' => {\n-        let id = parse_uint(st) as int;\n+        let id = parse_uint(st) as ast::NodeId;\n         assert_eq!(next(st), '|');\n         ty::ReScope(id)\n       }\n@@ -539,7 +539,7 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n-    let id = parse_uint(st) as int;\n+    let id = parse_uint(st) as ast::NodeId;\n     assert_eq!(next(st), '|');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n@@ -572,20 +572,20 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n-       Some(cn) => cn as int,\n+       Some(cn) => cn as ast::CrateNum,\n        None => fail!(\"internal error: parse_def_id: crate number expected, but found {:?}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n-       Some(dn) => dn as int,\n+       Some(dn) => dn as ast::NodeId,\n        None => fail!(\"internal error: parse_def_id: id expected, but found {:?}\",\n                      def_part)\n     };\n     ast::DefId { crate: crate_num, node: def_num }\n }\n \n pub fn parse_type_param_def_data(data: &[u8], start: uint,\n-                                 crate_num: int, tcx: ty::ctxt,\n+                                 crate_num: ast::CrateNum, tcx: ty::ctxt,\n                                  conv: conv_did) -> ty::TypeParameterDef\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);"}, {"sha": "5eb1bbab423e6025255708008c46c03c895367b5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -161,8 +161,7 @@ fn reserve_id_range(sess: Session,\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n-    assert!(cnt >= 0);\n-    let to_id_min = sess.reserve_node_ids(cnt as uint);\n+    let to_id_min = sess.reserve_node_ids(cnt);\n     let to_id_max = to_id_min + cnt;\n     ast_util::id_range { min: to_id_min, max: to_id_max }\n }\n@@ -1210,7 +1209,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     do reader::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n-        let id = xcx.tr_id(id0);\n+        let id = xcx.tr_id(id0 as ast::NodeId);\n \n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\","}, {"sha": "359af9a0bf29ce5d79c69ef97a650555757413c2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -169,7 +169,7 @@ pub struct field_ty {\n // the types of AST nodes.\n #[deriving(Eq,IterBytes)]\n pub struct creader_cache_key {\n-    cnum: int,\n+    cnum: CrateNum,\n     pos: uint,\n     len: uint\n }"}, {"sha": "b888c8772d0d3b83b042e904910f28a7d3f04c28", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -69,7 +69,7 @@ impl Eq for Ident {\n \n // this uint is a reference to a table stored in thread-local\n // storage.\n-pub type SyntaxContext = uint;\n+pub type SyntaxContext = u32;\n \n // the SCTable contains a table of SyntaxContext_'s. It\n // represents a flattened tree structure, to avoid having\n@@ -87,8 +87,8 @@ pub struct SCTable {\n }\n \n // NB: these must be placed in any SCTable...\n-pub static EMPTY_CTXT : uint = 0;\n-pub static ILLEGAL_CTXT : uint = 1;\n+pub static EMPTY_CTXT : SyntaxContext = 0;\n+pub static ILLEGAL_CTXT : SyntaxContext = 1;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum SyntaxContext_ {\n@@ -109,10 +109,10 @@ pub enum SyntaxContext_ {\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n-pub type Name = uint;\n+pub type Name = u32;\n \n /// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = uint;\n+pub type Mrk = u32;\n \n impl<S:Encoder> Encodable<S> for Ident {\n     fn encode(&self, s: &mut S) {\n@@ -163,9 +163,9 @@ pub struct PathSegment {\n     types: OptVec<Ty>,\n }\n \n-pub type CrateNum = int;\n+pub type CrateNum = u32;\n \n-pub type NodeId = int;\n+pub type NodeId = u32;\n \n #[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct DefId {"}, {"sha": "cc74754cecbc59b7682f8d34d356462234df80b3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -18,7 +18,7 @@ use visit::Visitor;\n use visit;\n \n use std::hashmap::HashMap;\n-use std::int;\n+use std::u32;\n use std::local_data;\n use std::num;\n use std::option;\n@@ -382,8 +382,8 @@ pub struct id_range {\n impl id_range {\n     pub fn max() -> id_range {\n         id_range {\n-            min: int::max_value,\n-            max: int::min_value,\n+            min: u32::max_value,\n+            max: u32::min_value,\n         }\n     }\n \n@@ -803,9 +803,9 @@ pub fn display_sctable(table : &SCTable) {\n \n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n+fn idx_push<T>(vec: &mut ~[T], val: T) -> u32 {\n     vec.push(val);\n-    vec.len() - 1\n+    (vec.len() - 1) as u32\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n@@ -917,7 +917,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n \n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n-pub fn xorPush(marks: &mut ~[uint], mark: uint) {\n+pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n     if ((marks.len() > 0) && (getLast(marks) == mark)) {\n         marks.pop();\n     } else {\n@@ -927,7 +927,7 @@ pub fn xorPush(marks: &mut ~[uint], mark: uint) {\n \n // get the last element of a mutable array.\n // FIXME #4903: , must be a separate procedure for now.\n-pub fn getLast(arr: &~[Mrk]) -> uint {\n+pub fn getLast(arr: &~[Mrk]) -> Mrk {\n     *arr.last()\n }\n \n@@ -1000,14 +1000,8 @@ mod test {\n         assert_eq!(s.clone(),~[14]);\n     }\n \n-    // convert a list of uints to an @[ident]\n-    // (ignores the interner completely)\n-    fn uints_to_idents (uints: &~[uint]) -> @~[Ident] {\n-        @uints.map(|u| Ident {name:*u, ctxt: EMPTY_CTXT})\n-    }\n-\n-    fn id (u : uint, s: SyntaxContext) -> Ident {\n-        Ident{name:u, ctxt: s}\n+    fn id(n: Name, s: SyntaxContext) -> Ident {\n+        Ident {name: n, ctxt: s}\n     }\n \n     // because of the SCTable, I now need a tidy way of"}, {"sha": "768c65ee6f9f3eb76b80570ab8d7920bf8806357", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -502,12 +502,12 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n     @interner::StrInterner::prefill(init_vec)\n }\n \n-static SELF_KEYWORD_NAME: uint = 8;\n-static STATIC_KEYWORD_NAME: uint = 27;\n-static STRICT_KEYWORD_START: uint = 32;\n-static STRICT_KEYWORD_FINAL: uint = 65;\n-static RESERVED_KEYWORD_START: uint = 66;\n-static RESERVED_KEYWORD_FINAL: uint = 72;\n+static SELF_KEYWORD_NAME: Name = 8;\n+static STATIC_KEYWORD_NAME: Name = 27;\n+static STRICT_KEYWORD_START: Name = 32;\n+static STRICT_KEYWORD_FINAL: Name = 65;\n+static RESERVED_KEYWORD_START: Name = 66;\n+static RESERVED_KEYWORD_FINAL: Name = 72;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one."}, {"sha": "c144b36a86f5b782c3a098ae335966263d29fcf4", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed27b5531ef25a366ab9e0fe537b7053244b947/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7ed27b5531ef25a366ab9e0fe537b7053244b947", "patch": "@@ -12,15 +12,17 @@\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n \n+use ast::Name;\n+\n use std::cmp::Equiv;\n use std::hashmap::HashMap;\n \n pub struct Interner<T> {\n-    priv map: @mut HashMap<T, uint>,\n+    priv map: @mut HashMap<T, Name>,\n     priv vect: @mut ~[T],\n }\n \n-// when traits can extend traits, we should extend index<uint,T> to get []\n+// when traits can extend traits, we should extend index<Name,T> to get []\n impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n@@ -37,37 +39,37 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n         rv\n     }\n \n-    pub fn intern(&self, val: T) -> uint {\n+    pub fn intern(&self, val: T) -> Name {\n         match self.map.find(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n         let vect = &mut *self.vect;\n-        let new_idx = vect.len();\n+        let new_idx = vect.len() as Name;\n         self.map.insert(val.clone(), new_idx);\n         vect.push(val);\n         new_idx\n     }\n \n-    pub fn gensym(&self, val: T) -> uint {\n+    pub fn gensym(&self, val: T) -> Name {\n         let new_idx = {\n             let vect = &*self.vect;\n-            vect.len()\n+            vect.len() as Name\n         };\n         // leave out of .map to avoid colliding\n         self.vect.push(val);\n         new_idx\n     }\n \n-    pub fn get(&self, idx: uint) -> T {\n+    pub fn get(&self, idx: Name) -> T {\n         self.vect[idx].clone()\n     }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n \n     pub fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n-                                              -> Option<uint> {\n+                                              -> Option<Name> {\n         match self.map.find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,\n@@ -78,11 +80,11 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n // A StrInterner differs from Interner<String> in that it accepts\n // borrowed pointers rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @mut HashMap<@str, uint>,\n+    priv map: @mut HashMap<@str, Name>,\n     priv vect: @mut ~[@str],\n }\n \n-// when traits can extend traits, we should extend index<uint,T> to get []\n+// when traits can extend traits, we should extend index<Name,T> to get []\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {\n@@ -97,21 +99,21 @@ impl StrInterner {\n         rv\n     }\n \n-    pub fn intern(&self, val: &str) -> uint {\n+    pub fn intern(&self, val: &str) -> Name {\n         match self.map.find_equiv(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n-        let new_idx = self.len();\n+        let new_idx = self.len() as Name;\n         let val = val.to_managed();\n         self.map.insert(val, new_idx);\n         self.vect.push(val);\n         new_idx\n     }\n \n-    pub fn gensym(&self, val: &str) -> uint {\n-        let new_idx = self.len();\n+    pub fn gensym(&self, val: &str) -> Name {\n+        let new_idx = self.len() as Name;\n         // leave out of .map to avoid colliding\n         self.vect.push(val.to_managed());\n         new_idx\n@@ -127,19 +129,19 @@ impl StrInterner {\n \n     // create a gensym with the same name as an existing\n     // entry.\n-    pub fn gensym_copy(&self, idx : uint) -> uint {\n-        let new_idx = self.len();\n+    pub fn gensym_copy(&self, idx : Name) -> Name {\n+        let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n         self.vect.push(self.vect[idx]);\n         new_idx\n     }\n \n-    pub fn get(&self, idx: uint) -> @str { self.vect[idx] }\n+    pub fn get(&self, idx: Name) -> @str { self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n \n     pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n-                                                         -> Option<uint> {\n+                                                         -> Option<Name> {\n         match self.map.find_equiv(val) {\n             Some(v) => Some(*v),\n             None => None,"}]}