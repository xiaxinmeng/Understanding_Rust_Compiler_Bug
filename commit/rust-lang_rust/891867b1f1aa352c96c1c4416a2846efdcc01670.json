{"sha": "891867b1f1aa352c96c1c4416a2846efdcc01670", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MTg2N2IxZjFhYTM1MmM5NmMxYzQ0MTZhMjg0NmVmZGNjMDE2NzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-26T18:18:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-26T18:22:06Z"}, "message": "fix: correctly update diagnostics when files are opened and closed\n\nBasically, this tracks the changes to `subscriptions` we use when\nissuing a publish_diagnostics.", "tree": {"sha": "d8f5d97aabd28103caa89bf790b5e95628b27109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8f5d97aabd28103caa89bf790b5e95628b27109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/891867b1f1aa352c96c1c4416a2846efdcc01670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/891867b1f1aa352c96c1c4416a2846efdcc01670", "html_url": "https://github.com/rust-lang/rust/commit/891867b1f1aa352c96c1c4416a2846efdcc01670", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/891867b1f1aa352c96c1c4416a2846efdcc01670/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410679285b3dcad6e4610813a74615f8dc11d74d", "url": "https://api.github.com/repos/rust-lang/rust/commits/410679285b3dcad6e4610813a74615f8dc11d74d", "html_url": "https://github.com/rust-lang/rust/commit/410679285b3dcad6e4610813a74615f8dc11d74d"}], "stats": {"total": 149, "additions": 76, "deletions": 73}, "files": [{"sha": "35fce79f5eb6a4dafaa1baf4e9c53d36e3bc7249", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 66, "deletions": 72, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/891867b1f1aa352c96c1c4416a2846efdcc01670/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891867b1f1aa352c96c1c4416a2846efdcc01670/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=891867b1f1aa352c96c1c4416a2846efdcc01670", "patch": "@@ -406,25 +406,49 @@ impl GlobalState {\n         }\n \n         let state_changed = self.process_changes();\n+        let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n-        if self.is_quiescent() && !was_quiescent {\n-            for flycheck in &self.flycheck {\n-                flycheck.update();\n+        if self.is_quiescent() {\n+            if !was_quiescent {\n+                for flycheck in &self.flycheck {\n+                    flycheck.update();\n+                }\n             }\n-        }\n \n-        if self.is_quiescent() && (!was_quiescent || state_changed) {\n-            self.update_file_notifications_on_threadpool();\n+            if !was_quiescent || state_changed {\n+                // Ensure that only one cache priming task can run at a time\n+                self.prime_caches_queue.request_op();\n+                if self.prime_caches_queue.should_start_op() {\n+                    self.task_pool.handle.spawn_with_sender({\n+                        let snap = self.snapshot();\n+                        move |sender| {\n+                            let cb = |progress| {\n+                                sender.send(Task::PrimeCaches(progress)).unwrap();\n+                            };\n+                            match snap.analysis.prime_caches(cb) {\n+                                Ok(()) => (),\n+                                Err(_canceled) => (),\n+                            }\n+                        }\n+                    });\n+                }\n \n-            // Refresh semantic tokens if the client supports it.\n-            if self.config.semantic_tokens_refresh() {\n-                self.semantic_tokens_cache.lock().clear();\n-                self.send_request::<lsp_types::request::SemanticTokensRefesh>((), |_, _| ());\n+                // Refresh semantic tokens if the client supports it.\n+                if self.config.semantic_tokens_refresh() {\n+                    self.semantic_tokens_cache.lock().clear();\n+                    self.send_request::<lsp_types::request::SemanticTokensRefesh>((), |_, _| ());\n+                }\n+\n+                // Refresh code lens if the client supports it.\n+                if self.config.code_lens_refresh() {\n+                    self.send_request::<lsp_types::request::CodeLensRefresh>((), |_, _| ());\n+                }\n             }\n \n-            // Refresh code lens if the client supports it.\n-            if self.config.code_lens_refresh() {\n-                self.send_request::<lsp_types::request::CodeLensRefresh>((), |_, _| ());\n+            if !was_quiescent || state_changed || memdocs_added_or_removed {\n+                if self.config.publish_diagnostics() {\n+                    self.update_diagnostics()\n+                }\n             }\n         }\n \n@@ -586,42 +610,32 @@ impl GlobalState {\n                     {\n                         log::error!(\"duplicate DidOpenTextDocument: {}\", path)\n                     }\n-                    let changed = this\n-                        .vfs\n+                    this.vfs\n                         .write()\n                         .0\n                         .set_file_contents(path, Some(params.text_document.text.into_bytes()));\n-\n-                    // If the VFS contents are unchanged, update diagnostics, since `handle_event`\n-                    // won't see any changes. This avoids missing diagnostics when opening a file.\n-                    //\n-                    // If the file *was* changed, `handle_event` will already recompute and send\n-                    // diagnostics. We can't do it here, since the *current* file contents might be\n-                    // unset in salsa, since the VFS change hasn't been applied to the database yet.\n-                    if !changed {\n-                        this.maybe_update_diagnostics();\n-                    }\n                 }\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidChangeTextDocument>(|this, params| {\n                 if let Ok(path) = from_proto::vfs_path(&params.text_document.uri) {\n-                    let doc = match this.mem_docs.get_mut(&path) {\n-                        Some(doc) => doc,\n+                    match this.mem_docs.get_mut(&path) {\n+                        Some(doc) => {\n+                            // The version passed in DidChangeTextDocument is the version after all edits are applied\n+                            // so we should apply it before the vfs is notified.\n+                            doc.version = params.text_document.version;\n+                        }\n                         None => {\n                             log::error!(\"expected DidChangeTextDocument: {}\", path);\n                             return Ok(());\n                         }\n                     };\n+\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n                     apply_document_changes(&mut text, params.content_changes);\n \n-                    // The version passed in DidChangeTextDocument is the version after all edits are applied\n-                    // so we should apply it before the vfs is notified.\n-                    doc.version = params.text_document.version;\n-\n                     vfs.set_file_contents(path.clone(), Some(text.into_bytes()));\n                 }\n                 Ok(())\n@@ -696,53 +710,33 @@ impl GlobalState {\n             .finish();\n         Ok(())\n     }\n-    fn update_file_notifications_on_threadpool(&mut self) {\n-        self.maybe_update_diagnostics();\n-\n-        // Ensure that only one cache priming task can run at a time\n-        self.prime_caches_queue.request_op();\n-        if self.prime_caches_queue.should_start_op() {\n-            self.task_pool.handle.spawn_with_sender({\n-                let snap = self.snapshot();\n-                move |sender| {\n-                    let cb = |progress| {\n-                        sender.send(Task::PrimeCaches(progress)).unwrap();\n-                    };\n-                    match snap.analysis.prime_caches(cb) {\n-                        Ok(()) => (),\n-                        Err(_canceled) => (),\n-                    }\n-                }\n-            });\n-        }\n-    }\n-    fn maybe_update_diagnostics(&mut self) {\n+\n+    fn update_diagnostics(&mut self) {\n         let subscriptions = self\n             .mem_docs\n             .iter()\n             .map(|path| self.vfs.read().0.file_id(path).unwrap())\n             .collect::<Vec<_>>();\n \n         log::trace!(\"updating notifications for {:?}\", subscriptions);\n-        if self.config.publish_diagnostics() {\n-            let snapshot = self.snapshot();\n-            self.task_pool.handle.spawn(move || {\n-                let diagnostics = subscriptions\n-                    .into_iter()\n-                    .filter_map(|file_id| {\n-                        handlers::publish_diagnostics(&snapshot, file_id)\n-                            .map_err(|err| {\n-                                if !is_cancelled(&*err) {\n-                                    log::error!(\"failed to compute diagnostics: {:?}\", err);\n-                                }\n-                                ()\n-                            })\n-                            .ok()\n-                            .map(|diags| (file_id, diags))\n-                    })\n-                    .collect::<Vec<_>>();\n-                Task::Diagnostics(diagnostics)\n-            })\n-        }\n+\n+        let snapshot = self.snapshot();\n+        self.task_pool.handle.spawn(move || {\n+            let diagnostics = subscriptions\n+                .into_iter()\n+                .filter_map(|file_id| {\n+                    handlers::publish_diagnostics(&snapshot, file_id)\n+                        .map_err(|err| {\n+                            if !is_cancelled(&*err) {\n+                                log::error!(\"failed to compute diagnostics: {:?}\", err);\n+                            }\n+                            ()\n+                        })\n+                        .ok()\n+                        .map(|diags| (file_id, diags))\n+                })\n+                .collect::<Vec<_>>();\n+            Task::Diagnostics(diagnostics)\n+        })\n     }\n }"}, {"sha": "f86a0f66ad8d6b6de7b0339ca7fdf06a882d907d", "filename": "crates/rust-analyzer/src/mem_docs.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/891867b1f1aa352c96c1c4416a2846efdcc01670/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891867b1f1aa352c96c1c4416a2846efdcc01670/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmem_docs.rs?ref=891867b1f1aa352c96c1c4416a2846efdcc01670", "patch": "@@ -1,5 +1,7 @@\n //! In-memory document information.\n \n+use std::mem;\n+\n use rustc_hash::FxHashMap;\n use vfs::VfsPath;\n \n@@ -10,19 +12,22 @@ use vfs::VfsPath;\n #[derive(Default, Clone)]\n pub(crate) struct MemDocs {\n     mem_docs: FxHashMap<VfsPath, DocumentData>,\n+    added_or_removed: bool,\n }\n \n impl MemDocs {\n     pub(crate) fn contains(&self, path: &VfsPath) -> bool {\n         self.mem_docs.contains_key(path)\n     }\n     pub(crate) fn insert(&mut self, path: VfsPath, data: DocumentData) -> Result<(), ()> {\n+        self.added_or_removed = true;\n         match self.mem_docs.insert(path, data) {\n             Some(_) => Err(()),\n             None => Ok(()),\n         }\n     }\n     pub(crate) fn remove(&mut self, path: &VfsPath) -> Result<(), ()> {\n+        self.added_or_removed = true;\n         match self.mem_docs.remove(path) {\n             Some(_) => Ok(()),\n             None => Err(()),\n@@ -32,12 +37,16 @@ impl MemDocs {\n         self.mem_docs.get(path)\n     }\n     pub(crate) fn get_mut(&mut self, path: &VfsPath) -> Option<&mut DocumentData> {\n+        // NB: don't set `self.added_or_removed` here, as that purposefully only\n+        // tracks changes to the key set.\n         self.mem_docs.get_mut(path)\n     }\n-\n     pub(crate) fn iter(&self) -> impl Iterator<Item = &VfsPath> {\n         self.mem_docs.keys()\n     }\n+    pub(crate) fn take_changes(&mut self) -> bool {\n+        mem::replace(&mut self.added_or_removed, false)\n+    }\n }\n \n /// Information about a document that the Language Client"}]}