{"sha": "6f5e455c2de007a12ed632f84b986369ae43a504", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNWU0NTVjMmRlMDA3YTEyZWQ2MzJmODRiOTg2MzY5YWU0M2E1MDQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-11T06:19:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: split GenericPredicates of a method from its parent predicates.", "tree": {"sha": "fde2abba72dab2f73a4e82bbd78a0330391984ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fde2abba72dab2f73a4e82bbd78a0330391984ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f5e455c2de007a12ed632f84b986369ae43a504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5e455c2de007a12ed632f84b986369ae43a504", "html_url": "https://github.com/rust-lang/rust/commit/6f5e455c2de007a12ed632f84b986369ae43a504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f5e455c2de007a12ed632f84b986369ae43a504/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e74e5bffe14ead921646d41bab436f8e6a69d33", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e74e5bffe14ead921646d41bab436f8e6a69d33", "html_url": "https://github.com/rust-lang/rust/commit/3e74e5bffe14ead921646d41bab436f8e6a69d33"}], "stats": {"total": 286, "additions": 136, "deletions": 150}, "files": [{"sha": "bf6aad98db1a8c4764513e3adac1573db7bc3338", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -2897,20 +2897,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx\n-            .lookup_predicates(def_id)\n-            .predicates.iter()\n-            .flat_map(|predicate| {\n-                let predicate =\n-                    normalize_with_depth(self, cause.clone(), recursion_depth,\n-                                         &predicate.subst(tcx, substs));\n-                predicate.obligations.into_iter().chain(\n-                    Some(Obligation {\n-                        cause: cause.clone(),\n-                        recursion_depth: recursion_depth,\n-                        predicate: predicate.value\n-                    }))\n-            }).collect();\n+        let predicates = tcx.lookup_predicates(def_id);\n+        assert_eq!(predicates.parent, None);\n+        let predicates = predicates.predicates.iter().flat_map(|predicate| {\n+            let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,\n+                                                 &predicate.subst(tcx, substs));\n+            predicate.obligations.into_iter().chain(\n+                Some(Obligation {\n+                    cause: cause.clone(),\n+                    recursion_depth: recursion_depth,\n+                    predicate: predicate.value\n+                }))\n+        }).collect();\n         self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n }"}, {"sha": "b2b8286be2fba041624aebdaaf8efd07debbfa01", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -768,27 +768,38 @@ pub struct Generics<'tcx> {\n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n+    pub parent: Option<DefId>,\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn empty() -> GenericPredicates<'tcx> {\n-        GenericPredicates {\n-            predicates: vec![]\n-        }\n-    }\n-\n     pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_into(tcx, &mut instantiated, substs);\n+        instantiated\n+    }\n+    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n+                           -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n-            predicates: self.predicates.subst(tcx, substs),\n+            predicates: self.predicates.subst(tcx, substs)\n+        }\n+    }\n+\n+    fn instantiate_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        instantiated: &mut InstantiatedPredicates<'tcx>,\n+                        substs: &Substs<'tcx>) {\n+        if let Some(def_id) = self.parent {\n+            tcx.lookup_predicates(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n+        instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n \n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n+        assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|pred| {\n                 pred.subst_supertrait(tcx, poly_trait_ref)"}, {"sha": "021ae820b87c5c340893e8cf69fb5b3b7730a734", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -832,18 +832,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GenericPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicates.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "5488f114db32ff610576f227ed063a70bdda421a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -1591,6 +1591,7 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n     let doc = reader::get_doc(base_doc, tag);\n \n     ty::GenericPredicates {\n+        parent: item_parent_item(cdata, doc),\n         predicates: reader::tagged_docs(doc, tag_predicate).map(|predicate_doc| {\n             doc_predicate(cdata, predicate_doc, tcx)\n         }).collect()"}, {"sha": "320ba3c8d9dc863c9344c800cc6228cf6a247097", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -525,6 +525,9 @@ fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               tag: usize)\n {\n     rbml_w.start_tag(tag);\n+    if let Some(def_id) = predicates.parent {\n+        rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(def_id));\n+    }\n     for predicate in &predicates.predicates {\n         rbml_w.wr_tagged_u32(tag_predicate,\n             index.add_xref(XRef::Predicate(predicate.clone())));"}, {"sha": "aec8f8245da5ed62b1f1b766eefcc45da6b1f1cb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -1726,6 +1726,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n                     tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+                        parent: None,\n                         predicates: predicates\n                     });\n "}, {"sha": "4cbb2d7f09f022d18f1c544c90d271ee5b4ebb97", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -211,29 +211,18 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return;\n     }\n \n-    // Depend on trait/impl predicates always being before method's own predicates,\n-    // to be able to split method predicates into \"inherited\" and method-specific.\n-    let trait_predicates = tcx.lookup_predicates(trait_m.container_id()).predicates;\n-    let impl_predicates = tcx.lookup_predicates(impl_m.container_id()).predicates;\n-    let trait_method_start = trait_predicates.len();\n-    let impl_method_start = impl_predicates.len();\n-    assert_eq!(&trait_predicates[..], &trait_m.predicates.predicates[..trait_method_start]);\n-    assert_eq!(&impl_predicates[..], &impl_m.predicates.predicates[..impl_method_start]);\n-\n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n-        // Normalize the associated types in the trait_bounds.\n-        let trait_bounds = trait_m.predicates.instantiate(tcx, trait_to_skol_substs);\n-\n         // Create obligations for each predicate declared by the impl\n         // definition in the context of the trait's parameter\n         // environment. We can't just use `impl_env.caller_bounds`,\n         // however, because we want to replace all late-bound regions with\n         // region variables.\n-        let impl_bounds = impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n+        let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+        let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n \n-        debug!(\"compare_impl_method: impl_bounds={:?}\", impl_bounds);\n+        debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n \n         // This is the only tricky bit of the new way we check implementation methods\n         // We need to build a set of predicates where only the FnSpace bounds\n@@ -242,14 +231,14 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         //\n         // We then register the obligations from the impl_m and check to see\n         // if all constraints hold.\n-        let hybrid_preds = impl_bounds.predicates[..impl_method_start].iter()\n-                    .chain(trait_bounds.predicates[trait_method_start..].iter());\n+        hybrid_preds.predicates.extend(\n+            trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n         // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n         // The key step here is to update the caller_bounds's predicates to be\n         // the new hybrid bounds we computed.\n         let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.cloned().collect());\n+        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n         let trait_param_env = traits::normalize_param_env_or_error(tcx,\n                                                                    trait_param_env,\n                                                                    normalize_cause.clone());\n@@ -261,12 +250,13 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let (impl_pred_fns, _) =\n+        let impl_m_own_bounds = impl_m.predicates.instantiate_own(tcx, impl_to_skol_substs);\n+        let (impl_m_own_bounds, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(\n                 impl_m_span,\n                 infer::HigherRankedType,\n-                &ty::Binder(impl_bounds.predicates[impl_method_start..].to_vec()));\n-        for predicate in impl_pred_fns {\n+                &ty::Binder(impl_m_own_bounds.predicates));\n+        for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n "}, {"sha": "d1da95f39df40f37f273b9cc1c048522251ee8ea", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -184,6 +184,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // 'a:'b and T:'b into region inference constraints. It is simpler\n     // just to look for all the predicates directly.\n \n+    assert_eq!(dtor_predicates.parent, None);\n     for predicate in &dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced"}, {"sha": "8c4ec8453177e4598722ac45a06f0a411d3d8aa8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -1612,8 +1612,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           bounds: &ty::GenericPredicates<'tcx>)\n                           -> ty::InstantiatedPredicates<'tcx>\n     {\n+        let result = bounds.instantiate(self.tcx, substs);\n+        let result = self.normalize_associated_types_in(span, &result.predicates);\n+        debug!(\"instantiate_bounds(bounds={:?}, substs={:?}) = {:?}\",\n+               bounds,\n+               substs,\n+               result);\n         ty::InstantiatedPredicates {\n-            predicates: self.instantiate_type_scheme(span, substs, &bounds.predicates)\n+            predicates: result\n         }\n     }\n \n@@ -4210,8 +4216,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             _ => {}\n         }\n-        let scheme = self.tcx.lookup_item_type(def.def_id());\n-        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n \n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n@@ -4296,6 +4300,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n+        let scheme = self.tcx.lookup_item_type(def.def_id());\n+        let type_predicates = self.tcx.lookup_predicates(def.def_id());\n         assert!(!substs.has_escaping_regions());\n         assert!(!scheme.ty.has_escaping_regions());\n "}, {"sha": "f6ffbc60c2836cd19c4b16b0ab0b95487f75309a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -1754,6 +1754,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         //\n         // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n         let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+        assert_eq!(trait_predicates.parent, None);\n         let predicates = trait_predicates.predicates.as_slice().to_vec();\n         traits::elaborate_predicates(self.tcx, predicates)\n             .filter_map(|predicate| {"}, {"sha": "ef5e1a26f415034b4dda716dce52cfc66ca0aa1c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -454,6 +454,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> ="}, {"sha": "939f8ac50a6c6502fc169289e38ba65e1dbd1883", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 76, "deletions": 82, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -459,35 +459,38 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n     fn get_type_parameter_bounds(&self,\n                                  astconv: &AstConv<'tcx, 'tcx>,\n-                                 _span: Span,\n+                                 span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n     {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n-        self.predicates\n-            .iter()\n-            .filter(|predicate| {\n-                match **predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        data.skip_binder().self_ty().is_param(def.space, def.index)\n-                    }\n-                    ty::Predicate::TypeOutlives(ref data) => {\n-                        data.skip_binder().0.is_param(def.space, def.index)\n-                    }\n-                    ty::Predicate::Rfc1592(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        false\n-                    }\n+        let mut results = self.parent.map_or(vec![], |def_id| {\n+            let parent = astconv.tcx().lookup_predicates(def_id);\n+            parent.get_type_parameter_bounds(astconv, span, node_id)\n+        });\n+\n+        results.extend(self.predicates.iter().filter(|predicate| {\n+            match **predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    data.skip_binder().self_ty().is_param(def.space, def.index)\n+                }\n+                ty::Predicate::TypeOutlives(ref data) => {\n+                    data.skip_binder().0.is_param(def.space, def.index)\n                 }\n-            })\n-            .cloned()\n-            .collect()\n+                ty::Predicate::Rfc1592(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n+                ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::Projection(..) => {\n+                    false\n+                }\n+            }\n+        }).cloned());\n+\n+        results\n     }\n }\n \n@@ -568,7 +571,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n-        ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n+        ty_generic_predicates(ccx, FnSpace, &sig.generics, ty_generics.parent, vec![], false);\n \n     let (fty, explicit_self_category) = {\n         let anon_scope = match container {\n@@ -634,8 +637,12 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n {\n+    let predicates = ty::GenericPredicates {\n+        parent: Some(container.id()),\n+        predicates: vec![]\n+    };\n     ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n-                                           ty::GenericPredicates::empty());\n+                                           predicates);\n \n     write_ty_to_tcx(ccx, id, ty);\n \n@@ -744,7 +751,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty_generics = generics_of_def_id(ccx, def_id);\n-            let mut ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n+            let mut ty_predicates =\n+                ty_generic_predicates(ccx, TypeSpace, generics, None, vec![], false);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n@@ -1187,6 +1195,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // generic types:\n         let trait_def = trait_def_of_item(ccx, item);\n         let self_predicate = ty::GenericPredicates {\n+            parent: None,\n             predicates: vec![trait_def.trait_ref.to_predicate()]\n         };\n         let scope = &(generics, &self_predicate);\n@@ -1209,6 +1218,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // Combine the two lists to form the complete set of superbounds:\n         let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n         let superpredicates = ty::GenericPredicates {\n+            parent: None,\n             predicates: superbounds\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n@@ -1327,16 +1337,16 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n     // associated types.\n-    let mut base_predicates = super_predicates;\n+    let mut base_predicates = super_predicates.predicates;\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n     let self_predicate = trait_def.trait_ref.to_poly_trait_ref().to_predicate();\n-    base_predicates.predicates.push(self_predicate);\n+    base_predicates.push(self_predicate);\n \n     // add in the explicit where-clauses\n     let mut trait_predicates =\n-        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates, true);\n+        ty_generic_predicates(ccx, TypeSpace, generics, None, base_predicates, true);\n \n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n@@ -1619,32 +1629,17 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item)\n                                 -> ty::GenericPredicates<'tcx> {\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n-    let predicates = match it.node {\n-        hir::ItemStatic(..) | hir::ItemConst(..) => {\n-            ty::GenericPredicates::empty()\n-        }\n-        hir::ItemFn(_, _, _, _, ref ast_generics, _) => {\n-            ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n-        }\n+\n+    let no_generics = hir::Generics::empty();\n+    let (space, generics) = match it.node {\n+        hir::ItemFn(_, _, _, _, ref generics, _) => (FnSpace, generics),\n         hir::ItemTy(_, ref generics) |\n         hir::ItemEnum(_, ref generics) |\n-        hir::ItemStruct(_, ref generics) => {\n-            ty_generic_predicates_for_type_or_impl(ccx, generics)\n-        }\n-        hir::ItemDefaultImpl(..) |\n-        hir::ItemTrait(..) |\n-        hir::ItemExternCrate(..) |\n-        hir::ItemUse(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemMod(..) |\n-        hir::ItemForeignMod(..) => {\n-            span_bug!(\n-                it.span,\n-                \"predicates_of_item: unexpected item type: {:?}\",\n-                it.node);\n-        }\n+        hir::ItemStruct(_, ref generics) => (TypeSpace, generics),\n+        _ => (TypeSpace, &no_generics)\n     };\n \n+    let predicates = ty_generic_predicates(ccx, space, generics, None, vec![], false);\n     let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n                                                                  predicates.clone());\n     assert!(prev_predicates.is_none());\n@@ -1662,34 +1657,17 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n     type_scheme_of_def_id(ccx, def_id);\n \n-    let predicates = match it.node {\n-        hir::ForeignItemFn(_, ref generics) => {\n-            ty_generic_predicates_for_fn(ccx, generics, &ty::GenericPredicates::empty())\n-        }\n-        hir::ForeignItemStatic(..) => {\n-            ty::GenericPredicates::empty()\n-        }\n+    let no_generics = hir::Generics::empty();\n+    let (space, generics) = match it.node {\n+        hir::ForeignItemFn(_, ref generics) => (FnSpace, generics),\n+        hir::ForeignItemStatic(..) => (TypeSpace, &no_generics)\n     };\n \n+    let predicates = ty_generic_predicates(ccx, space, generics, None, vec![], false);\n     let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n     assert!(prev_predicates.is_none());\n }\n \n-fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                                   generics: &hir::Generics)\n-                                                   -> ty::GenericPredicates<'tcx>\n-{\n-    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty(), false)\n-}\n-\n-fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                         generics: &hir::Generics,\n-                                         base_predicates: &ty::GenericPredicates<'tcx>)\n-                                         -> ty::GenericPredicates<'tcx>\n-{\n-    ty_generic_predicates(ccx, FnSpace, generics, base_predicates, false)\n-}\n-\n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                        bounds: &mut ty::BuiltinBounds,\n@@ -1757,12 +1735,25 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx, 'hir>(\n fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   space: ParamSpace,\n                                   ast_generics: &hir::Generics,\n-                                  base_predicates: &ty::GenericPredicates<'tcx>,\n+                                  parent: Option<DefId>,\n+                                  super_predicates: Vec<ty::Predicate<'tcx>>,\n                                   has_self: bool)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base_predicates.clone();\n+    let ref base_predicates = match parent {\n+        Some(def_id) => {\n+            assert_eq!(super_predicates, vec![]);\n+            tcx.lookup_predicates(def_id)\n+        }\n+        None => {\n+            ty::GenericPredicates {\n+                parent: None,\n+                predicates: super_predicates.clone()\n+            }\n+        }\n+    };\n+    let mut predicates = super_predicates;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n@@ -1775,7 +1766,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     SizedByDefault::Yes,\n                                     None,\n                                     param.span);\n-        result.predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n+        predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n \n     // Collect the region predicates that were declared inline as\n@@ -1793,7 +1784,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         for bound in &param.bounds {\n             let bound_region = ast_region_to_region(ccx.tcx, bound);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n-            result.predicates.push(outlives.to_predicate());\n+            predicates.push(outlives.to_predicate());\n         }\n     }\n \n@@ -1819,17 +1810,17 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                                     ty,\n                                                                     &mut projections);\n \n-                            result.predicates.push(trait_ref.to_predicate());\n+                            predicates.push(trait_ref.to_predicate());\n \n                             for projection in &projections {\n-                                result.predicates.push(projection.to_predicate());\n+                                predicates.push(projection.to_predicate());\n                             }\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n                             let region = ast_region_to_region(tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n-                            result.predicates.push(ty::Predicate::TypeOutlives(pred))\n+                            predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n                     }\n                 }\n@@ -1840,7 +1831,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 for bound in &region_pred.bounds {\n                     let r2 = ast_region_to_region(tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n-                    result.predicates.push(ty::Predicate::RegionOutlives(pred))\n+                    predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n@@ -1853,7 +1844,10 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    result\n+    ty::GenericPredicates {\n+        parent: parent,\n+        predicates: predicates\n+    }\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,"}, {"sha": "90288b17dfcce32d4524dffcb77711c9f546f85b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -1348,17 +1348,7 @@ impl Clean<Item> for hir::ImplItem {\n \n impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        // Depend on trait/impl predicates always being before method's own predicates,\n-        // to be able to split method predicates into \"inherited\" and method-specific.\n-        let outer_predicates = cx.tcx().lookup_predicates(self.container_id()).predicates;\n-        let method_start = outer_predicates.len();\n-        assert_eq!(&outer_predicates[..], &self.predicates.predicates[..method_start]);\n-\n-        let method_predicates = ty::GenericPredicates {\n-            predicates: self.predicates.predicates[method_start..].to_vec()\n-        };\n-\n-        let generics = (self.generics, &method_predicates).clean(cx);\n+        let generics = (self.generics, &self.predicates).clean(cx);\n         let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n         match self.explicit_self {\n             ty::ExplicitSelfCategory::ByValue => {"}, {"sha": "ddf16a2278e5bd140cca704c6992e27dafb09f8e", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f5e455c2de007a12ed632f84b986369ae43a504/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=6f5e455c2de007a12ed632f84b986369ae43a504", "patch": "@@ -25,7 +25,8 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array: [u32; <A as Foo>::Y]; //~ error: the parameter type\n+    let _array: [u32; <A as Foo>::Y];\n+    //~^ ERROR the trait bound `A: Foo` is not satisfied\n }\n \n fn main() {"}]}