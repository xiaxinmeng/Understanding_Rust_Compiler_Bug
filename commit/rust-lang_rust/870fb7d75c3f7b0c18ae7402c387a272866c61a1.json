{"sha": "870fb7d75c3f7b0c18ae7402c387a272866c61a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MGZiN2Q3NWMzZjdiMGMxOGFlNzQwMmMzODdhMjcyODY2YzYxYTE=", "commit": {"author": {"name": "Philipp Br\u00fcschweiler", "email": "blei42@gmail.com", "date": "2013-12-02T20:53:23Z"}, "committer": {"name": "Philipp Br\u00fcschweiler", "email": "blei42@gmail.com", "date": "2013-12-02T20:53:23Z"}, "message": "c_vec: Modernize\n\nGenerally use more modern constructs (such as using `CVec::new()` as\nconstructor and move to more method usage).\n\nPotentially controversial changes:\n* change `get()` to return a reference instead of cloning\n* remove `set()`, add `get_mut()` instead\n* add an `unwrap()` method that destroys the CVec without running any\n  associated destructor", "tree": {"sha": "43a8c9f66f2a80c5601882599399797f6584e988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43a8c9f66f2a80c5601882599399797f6584e988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/870fb7d75c3f7b0c18ae7402c387a272866c61a1", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/870fb7d75c3f7b0c18ae7402c387a272866c61a1", "html_url": "https://github.com/rust-lang/rust/commit/870fb7d75c3f7b0c18ae7402c387a272866c61a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/870fb7d75c3f7b0c18ae7402c387a272866c61a1/comments", "author": {"login": "Blei", "id": 52674, "node_id": "MDQ6VXNlcjUyNjc0", "avatar_url": "https://avatars.githubusercontent.com/u/52674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blei", "html_url": "https://github.com/Blei", "followers_url": "https://api.github.com/users/Blei/followers", "following_url": "https://api.github.com/users/Blei/following{/other_user}", "gists_url": "https://api.github.com/users/Blei/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blei/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blei/subscriptions", "organizations_url": "https://api.github.com/users/Blei/orgs", "repos_url": "https://api.github.com/users/Blei/repos", "events_url": "https://api.github.com/users/Blei/events{/privacy}", "received_events_url": "https://api.github.com/users/Blei/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Blei", "id": 52674, "node_id": "MDQ6VXNlcjUyNjc0", "avatar_url": "https://avatars.githubusercontent.com/u/52674?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blei", "html_url": "https://github.com/Blei", "followers_url": "https://api.github.com/users/Blei/followers", "following_url": "https://api.github.com/users/Blei/following{/other_user}", "gists_url": "https://api.github.com/users/Blei/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blei/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blei/subscriptions", "organizations_url": "https://api.github.com/users/Blei/orgs", "repos_url": "https://api.github.com/users/Blei/repos", "events_url": "https://api.github.com/users/Blei/events{/privacy}", "received_events_url": "https://api.github.com/users/Blei/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61443dc1f5089df637edba83587b9f3020063266", "url": "https://api.github.com/repos/rust-lang/rust/commits/61443dc1f5089df637edba83587b9f3020063266", "html_url": "https://github.com/rust-lang/rust/commit/61443dc1f5089df637edba83587b9f3020063266"}], "stats": {"total": 226, "additions": 122, "deletions": 104}, "files": [{"sha": "68499cf7032616d7d8b18dbdaf29abd9773701af", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 122, "deletions": 104, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/870fb7d75c3f7b0c18ae7402c387a272866c61a1/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870fb7d75c3f7b0c18ae7402c387a272866c61a1/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=870fb7d75c3f7b0c18ae7402c387a272866c61a1", "patch": "@@ -24,28 +24,26 @@\n  * closure is provided.  Safety is ensured by bounds-checking accesses, which\n  * are marshalled through get and set functions.\n  *\n- * There are three unsafe functions: the two introduction forms, and the\n- * pointer elimination form.  The introduction forms are unsafe for the\n+ * There are three unsafe functions: the two constructors, and the\n+ * unwrap method. The constructors are unsafe for the\n  * obvious reason (they act on a pointer that cannot be checked inside the\n- * method), but the elimination form is somewhat more subtle in its unsafety.\n- * By using a pointer taken from a c_vec::t without keeping a reference to the\n- * c_vec::t itself around, the CVec could be garbage collected, and the\n- * memory within could be destroyed.  There are legitimate uses for the\n- * pointer elimination form -- for instance, to pass memory back into C -- but\n- * great care must be taken to ensure that a reference to the c_vec::t is\n- * still held if needed.\n+ * method), but `unwrap()` is somewhat more subtle in its unsafety.\n+ * It returns the contained pointer, but at the same time destroys the CVec\n+ * without running its destructor. This can be used to pass memory back to\n+ * C, but care must be taken that the ownership of underlying resources are\n+ * handled correctly, i.e. that allocated memory is eventually freed\n+ * if necessary.\n  */\n \n use std::ptr;\n-use std::util;\n \n /**\n  * The type representing a foreign chunk of memory\n  */\n pub struct CVec<T> {\n     priv base: *mut T,\n     priv len: uint,\n-    priv rsrc: @DtorRes,\n+    priv rsrc: DtorRes,\n }\n \n struct DtorRes {\n@@ -55,7 +53,7 @@ struct DtorRes {\n #[unsafe_destructor]\n impl Drop for DtorRes {\n     fn drop(&mut self) {\n-        let dtor = util::replace(&mut self.dtor, None);\n+        let dtor = self.dtor.take();\n         match dtor {\n             None => (),\n             Some(f) => f()\n@@ -71,138 +69,158 @@ impl DtorRes {\n     }\n }\n \n-/*\n- Section: Introduction forms\n- */\n+impl <T> CVec<T> {\n+    /**\n+     * Create a `CVec` from a raw pointer to a buffer with a given length.\n+     *\n+     * Fails if the given pointer is null.\n+     *\n+     * # Arguments\n+     *\n+     * * base - A raw pointer to a buffer\n+     * * len - The number of elements in the buffer\n+     */\n+    pub unsafe fn new(base: *mut T, len: uint) -> CVec<T> {\n+        assert!(base != ptr::mut_null());\n+        CVec {\n+            base: base,\n+            len: len,\n+            rsrc: DtorRes::new(None)\n+        }\n+    }\n \n-/**\n- * Create a `CVec` from a foreign buffer with a given length.\n- *\n- * # Arguments\n- *\n- * * base - A foreign pointer to a buffer\n- * * len - The number of elements in the buffer\n- */\n-pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n-    return CVec {\n-        base: base,\n-        len: len,\n-        rsrc: @DtorRes::new(None)\n-    };\n-}\n+    /**\n+     * Create a `CVec` from a foreign buffer, with a given length,\n+     * and a function to run upon destruction.\n+     *\n+     * Fails if the given pointer is null.\n+     *\n+     * # Arguments\n+     *\n+     * * base - A foreign pointer to a buffer\n+     * * len - The number of elements in the buffer\n+     * * dtor - A proc to run when the value is destructed, useful\n+     *          for freeing the buffer, etc.\n+     */\n+    pub unsafe fn new_with_dtor(base: *mut T, len: uint, dtor: proc()) -> CVec<T> {\n+        assert!(base != ptr::mut_null());\n+        CVec {\n+            base: base,\n+            len: len,\n+            rsrc: DtorRes::new(Some(dtor))\n+        }\n+    }\n \n-/**\n- * Create a `CVec` from a foreign buffer, with a given length,\n- * and a function to run upon destruction.\n- *\n- * # Arguments\n- *\n- * * base - A foreign pointer to a buffer\n- * * len - The number of elements in the buffer\n- * * dtor - A function to run when the value is destructed, useful\n- *          for freeing the buffer, etc.\n- */\n-pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: proc())\n-                                 -> CVec<T> {\n-    return CVec{\n-        base: base,\n-        len: len,\n-        rsrc: @DtorRes::new(Some(dtor))\n-    };\n-}\n+    /**\n+     * Retrieves an element at a given index\n+     *\n+     * Fails if `ofs` is greater or equal to the length of the vector\n+     */\n+    pub fn get<'a>(&'a self, ofs: uint) -> &'a T {\n+        assert!(ofs < self.len);\n+        unsafe {\n+            &*ptr::mut_offset(self.base, ofs as int)\n+        }\n+    }\n \n-/*\n- Section: Operations\n- */\n+    /**\n+     * Retrieves a mutable element at a given index\n+     *\n+     * Fails if `ofs` is greater or equal to the length of the vector\n+     */\n+    pub fn get_mut<'a>(&'a mut self, ofs: uint) -> &'a mut T {\n+        assert!(ofs < self.len);\n+        unsafe {\n+            &mut *ptr::mut_offset(self.base, ofs as int)\n+        }\n+    }\n \n-/**\n- * Retrieves an element at a given index\n- *\n- * Fails if `ofs` is greater or equal to the length of the vector\n- */\n-pub fn get<T:Clone>(t: CVec<T>, ofs: uint) -> T {\n-    assert!(ofs < len(t));\n-    return unsafe {\n-        (*ptr::mut_offset(t.base, ofs as int)).clone()\n-    };\n+    /**\n+     * Unwrap the pointer without running the destructor\n+     *\n+     * This method retrieves the underlying pointer, and in the process\n+     * destroys the CVec but without running the destructor. A use case\n+     * would be transferring ownership of the buffer to a C function, as\n+     * in this case you would not want to run the destructor.\n+     *\n+     * Note that if you want to access the underlying pointer without\n+     * cancelling the destructor, you can simply call `transmute` on the return\n+     * value of `get(0)`.\n+     */\n+    pub unsafe fn unwrap(mut self) -> *mut T {\n+        self.rsrc.dtor = None;\n+        self.base\n+    }\n }\n \n-/**\n- * Sets the value of an element at a given index\n- *\n- * Fails if `ofs` is greater or equal to the length of the vector\n- */\n-pub fn set<T>(t: CVec<T>, ofs: uint, v: T) {\n-    assert!(ofs < len(t));\n-    unsafe { *ptr::mut_offset(t.base, ofs as int) = v };\n+impl <T> Container for CVec<T> {\n+    /// Returns the length of the vector\n+    fn len(&self) -> uint { self.len }\n }\n \n-/*\n- Section: Elimination forms\n- */\n-\n-/// Returns the length of the vector\n-pub fn len<T>(t: CVec<T>) -> uint { t.len }\n-\n-/// Returns a pointer to the first element of the vector\n-pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n-\n #[cfg(test)]\n mod tests {\n \n-    use c_vec::*;\n+    use super::*;\n \n     use std::libc::*;\n     use std::libc;\n+    use std::ptr;\n \n-    fn malloc(n: size_t) -> CVec<u8> {\n+    fn malloc(n: uint) -> CVec<u8> {\n         unsafe {\n-            let mem = libc::malloc(n);\n+            let mem = libc::malloc(n as size_t);\n \n             assert!(mem as int != 0);\n \n-            return c_vec_with_dtor(mem as *mut u8,\n-                                   n as uint,\n-                                   proc() unsafe { libc::free(mem); });\n+            CVec::new_with_dtor(mem as *mut u8, n,\n+                proc() { libc::free(mem); })\n         }\n     }\n \n     #[test]\n     fn test_basic() {\n-        let cv = malloc(16u as size_t);\n+        let mut cv = malloc(16);\n \n-        set(cv, 3u, 8u8);\n-        set(cv, 4u, 9u8);\n-        assert_eq!(get(cv, 3u), 8u8);\n-        assert_eq!(get(cv, 4u), 9u8);\n-        assert_eq!(len(cv), 16u);\n+        *cv.get_mut(3) = 8;\n+        *cv.get_mut(4) = 9;\n+        assert_eq!(*cv.get(3), 8);\n+        assert_eq!(*cv.get(4), 9);\n+        assert_eq!(cv.len(), 16);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_fail_at_null() {\n+        unsafe {\n+            CVec::new(ptr::mut_null::<u8>(), 9);\n+        }\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_overrun_get() {\n-        let cv = malloc(16u as size_t);\n+        let cv = malloc(16);\n \n-        get(cv, 17u);\n+        cv.get(17);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_overrun_set() {\n-        let cv = malloc(16u as size_t);\n+        let mut cv = malloc(16);\n \n-        set(cv, 17u, 0u8);\n+        *cv.get_mut(17) =  0;\n     }\n \n     #[test]\n-    fn test_and_I_mean_it() {\n-        let cv = malloc(16u as size_t);\n-        let p = unsafe { ptr(cv) };\n-\n-        set(cv, 0u, 32u8);\n-        set(cv, 1u, 33u8);\n-        assert_eq!(unsafe { *p }, 32u8);\n-        set(cv, 2u, 34u8); /* safety */\n+    fn test_unwrap() {\n+        unsafe {\n+            let cv = CVec::new_with_dtor(1 as *mut int, 0,\n+                proc() { fail!(\"Don't run this destructor!\") });\n+            let p = cv.unwrap();\n+            assert_eq!(p, 1 as *mut int);\n+        }\n     }\n \n }"}]}