{"sha": "444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NGZmOWZiZmIxZjJhOGU2NjQ1ZjY3Njg0ZjhhOWFkOTliMzQzZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-06T12:02:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-06T12:02:16Z"}, "message": "Auto merge of #35407 - eddyb:rollup, r=eddyb\n\nRollup of 21 pull requests\n\n- Successful merges: #33951, #34916, #35287, #35288, #35351, #35353, #35356, #35362, #35363, #35364, #35366, #35368, #35370, #35372, #35373, #35374, #35375, #35376, #35380, #35393, #35394\n- Failed merges: #35331, #35395", "tree": {"sha": "dad9595deade059b82952d7c38ccef3140686537", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dad9595deade059b82952d7c38ccef3140686537"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "html_url": "https://github.com/rust-lang/rust/commit/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa", "html_url": "https://github.com/rust-lang/rust/commit/ecdd51b7bb7fd993acd2ff5dbd72209244b1e4aa"}, {"sha": "67f082287d49320af9042678b861437cd8d0224c", "url": "https://api.github.com/repos/rust-lang/rust/commits/67f082287d49320af9042678b861437cd8d0224c", "html_url": "https://github.com/rust-lang/rust/commit/67f082287d49320af9042678b861437cd8d0224c"}], "stats": {"total": 961, "additions": 701, "deletions": 260}, "files": [{"sha": "edbc6cea0266499c582036320c4b954489dd328f", "filename": "man/rustc.1", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTC \"1\" \"August 2015\" \"rustc 1.2.0\" \"User Commands\"\n+.TH RUSTC \"1\" \"August 2016\" \"rustc 1.12.0\" \"User Commands\"\n .SH NAME\n rustc \\- The Rust compiler\n .SH SYNOPSIS\n@@ -299,7 +299,7 @@ To build an executable with debug info:\n See https://github.com/rust\\-lang/rust/issues for issues.\n \n .SH \"AUTHOR\"\n-See \\fIAUTHORS.txt\\fR in the Rust source distribution.\n+See https://github.com/rust\\-lang/rust/graphs/contributors or use `git log --all --format='%cN <%cE>' | sort -u` in the rust source distribution.\n \n .SH \"COPYRIGHT\"\n This work is dual\\[hy]licensed under Apache\\ 2.0 and MIT terms."}, {"sha": "3fb5757f4ff24be21f2cac4ea3312fef2d257b23", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTDOC \"1\" \"August 2015\" \"rustdoc 1.2.0\" \"User Commands\"\n+.TH RUSTDOC \"1\" \"August 2016\" \"rustdoc 1.12.0\" \"User Commands\"\n .SH NAME\n rustdoc \\- generate documentation from Rust source code\n .SH SYNOPSIS"}, {"sha": "a7d0d3899b181d2dd3add95f7bbb46c2bb83ced3", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -34,12 +34,13 @@\n /// only designed to be used by unsafe code that needs to manipulate\n /// the low-level details.\n ///\n-/// There is no `Repr` implementation for `TraitObject` because there\n-/// is no way to refer to all trait objects generically, so the only\n+/// There is no way to refer to all trait objects generically, so the only\n /// way to create values of this type is with functions like\n-/// `std::mem::transmute`. Similarly, the only way to create a true\n+/// [`std::mem::transmute`][transmute]. Similarly, the only way to create a true\n /// trait object from a `TraitObject` value is with `transmute`.\n ///\n+/// [transmute]: ../intrinsics/fn.transmute.html\n+///\n /// Synthesizing a trait object with mismatched types\u2014one where the\n /// vtable does not correspond to the type of the value to which the\n /// data pointer points\u2014is highly likely to lead to undefined\n@@ -50,13 +51,13 @@\n /// ```\n /// #![feature(raw)]\n ///\n-/// use std::mem;\n-/// use std::raw;\n+/// use std::{mem, raw};\n ///\n /// // an example trait\n /// trait Foo {\n ///     fn bar(&self) -> i32;\n /// }\n+///\n /// impl Foo for i32 {\n ///     fn bar(&self) -> i32 {\n ///          *self + 1\n@@ -74,19 +75,18 @@\n /// // the data pointer is the address of `value`\n /// assert_eq!(raw_object.data as *const i32, &value as *const _);\n ///\n-///\n /// let other_value: i32 = 456;\n ///\n /// // construct a new object, pointing to a different `i32`, being\n /// // careful to use the `i32` vtable from `object`\n /// let synthesized: &Foo = unsafe {\n ///      mem::transmute(raw::TraitObject {\n ///          data: &other_value as *const _ as *mut (),\n-///          vtable: raw_object.vtable\n+///          vtable: raw_object.vtable,\n ///      })\n /// };\n ///\n-/// // it should work just like we constructed a trait object out of\n+/// // it should work just as if we had constructed a trait object out of\n /// // `other_value` directly\n /// assert_eq!(synthesized.bar(), 457);\n /// ```"}, {"sha": "86422835c8cbd0b8d5f1583827eec4503874b17a", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -47,8 +47,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn prohibit_projection(self, span: Span)\n     {\n-        span_err!(self.sess, span, E0229,\n-                  \"associated type bindings are not allowed here\");\n+        let mut err = struct_span_err!(self.sess, span, E0229,\n+                                       \"associated type bindings are not allowed here\");\n+        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n     }\n \n     pub fn prim_ty_to_ty(self,"}, {"sha": "9115fd42be870e02aec87792b163d02ca5657720", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -942,9 +942,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                           but it borrows {}, \\\n                           which is owned by the current function\",\n                          cmt_path_or_string)\n-            .span_note(capture_span,\n+            .span_label(capture_span,\n                        &format!(\"{} is borrowed here\",\n                                 cmt_path_or_string))\n+            .span_label(err.span,\n+                       &format!(\"may outlive borrowed value {}\",\n+                                cmt_path_or_string))\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "2fe4ae627c1dc7be3ea12168369e8df3cb17939f", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -424,10 +424,15 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                             format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n                         }\n                     };\n-                    span_err!(cx.tcx.sess, sp, E0004,\n+\n+                    let label_text = match pattern_strings.len(){\n+                        1 => format!(\"pattern {} not covered\", joined_patterns),\n+                        _ => format!(\"patterns {} not covered\", joined_patterns)\n+                    };\n+                    struct_span_err!(cx.tcx.sess, sp, E0004,\n                         \"non-exhaustive patterns: {} not covered\",\n                         joined_patterns\n-                    );\n+                    ).span_label(sp, &label_text).emit();\n                 },\n             }\n         }"}, {"sha": "43d9725baaf004e9e970fb466452d714186a1c87", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -1337,10 +1337,13 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Ok(val as usize)\n         },\n         Ok(const_val) => {\n-            span_err!(tcx.sess, count_expr.span, E0306,\n-                      \"expected usize for {}, found {}\",\n-                      reason,\n-                      const_val.description());\n+            struct_span_err!(tcx.sess, count_expr.span, E0306,\n+                             \"expected `usize` for {}, found {}\",\n+                             reason,\n+                             const_val.description())\n+                .span_label(count_expr.span, &format!(\"expected `usize`\"))\n+                .emit();\n+\n             Err(ErrorReported)\n         }\n         Err(err) => {"}, {"sha": "91d2500564fd3b7d246f406fcb8d117fb0fede0b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -38,16 +38,18 @@ impl<'a> AstValidator<'a> {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n         if label.name.as_str() == \"'_\" {\n-            self.session.add_lint(\n-                lint::builtin::LIFETIME_UNDERSCORE, id, span,\n-                format!(\"invalid label name `{}`\", label.name)\n-            );\n+            self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n+                                  id,\n+                                  span,\n+                                  format!(\"invalid label name `{}`\", label.name));\n         }\n     }\n \n     fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n         if vis != &Visibility::Inherited {\n-            let mut err = struct_span_err!(self.session, span, E0449,\n+            let mut err = struct_span_err!(self.session,\n+                                           span,\n+                                           E0449,\n                                            \"unnecessary visibility qualifier\");\n             if let Some(note) = note {\n                 err.span_note(span, note);\n@@ -71,20 +73,23 @@ impl<'a> AstValidator<'a> {\n impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n         if lt.name.as_str() == \"'_\" {\n-            self.session.add_lint(\n-                lint::builtin::LIFETIME_UNDERSCORE, lt.id, lt.span,\n-                format!(\"invalid lifetime name `{}`\", lt.name)\n-            );\n+            self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n+                                  lt.id,\n+                                  lt.span,\n+                                  format!(\"invalid lifetime name `{}`\", lt.name));\n         }\n \n         visit::walk_lifetime(self, lt)\n     }\n \n     fn visit_expr(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprKind::While(_, _, Some(ident)) | ExprKind::Loop(_, Some(ident)) |\n-            ExprKind::WhileLet(_, _, _, Some(ident)) | ExprKind::ForLoop(_, _, _, Some(ident)) |\n-            ExprKind::Break(Some(ident)) | ExprKind::Continue(Some(ident)) => {\n+            ExprKind::While(_, _, Some(ident)) |\n+            ExprKind::Loop(_, Some(ident)) |\n+            ExprKind::WhileLet(_, _, _, Some(ident)) |\n+            ExprKind::ForLoop(_, _, _, Some(ident)) |\n+            ExprKind::Break(Some(ident)) |\n+            ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }\n             _ => {}\n@@ -97,10 +102,13 @@ impl<'a> Visitor for AstValidator<'a> {\n         match ty.node {\n             TyKind::BareFn(ref bfty) => {\n                 self.check_decl_no_pat(&bfty.decl, |span, _| {\n-                    let mut err = struct_span_err!(self.session, span, E0561,\n-                                            \"patterns aren't allowed in function pointer types\");\n-                    err.span_note(span, \"this is a recent error, see \\\n-                                         issue #35203 for more details\");\n+                    let mut err = struct_span_err!(self.session,\n+                                                   span,\n+                                                   E0561,\n+                                                   \"patterns aren't allowed in function pointer \\\n+                                                    types\");\n+                    err.span_note(span,\n+                                  \"this is a recent error, see issue #35203 for more details\");\n                     err.emit();\n                 });\n             }\n@@ -114,10 +122,10 @@ impl<'a> Visitor for AstValidator<'a> {\n         if path.global && path.segments.len() > 0 {\n             let ident = path.segments[0].identifier;\n             if token::Ident(ident).is_path_segment_keyword() {\n-                self.session.add_lint(\n-                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n-                    format!(\"global paths cannot start with `{}`\", ident)\n-                );\n+                self.session.add_lint(lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n+                                      id,\n+                                      path.span,\n+                                      format!(\"global paths cannot start with `{}`\", ident));\n             }\n         }\n \n@@ -129,8 +137,8 @@ impl<'a> Visitor for AstValidator<'a> {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n                 if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n-                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n-                                                            in import path\");\n+                    self.err_handler()\n+                        .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n             }\n             ItemKind::Impl(_, _, _, Some(..), _, ref impl_items) => {\n@@ -140,15 +148,18 @@ impl<'a> Visitor for AstValidator<'a> {\n                 }\n             }\n             ItemKind::Impl(_, _, _, None, _, _) => {\n-                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n-                                                                    impl items instead\"));\n+                self.invalid_visibility(&item.vis,\n+                                        item.span,\n+                                        Some(\"place qualifiers on individual impl items instead\"));\n             }\n             ItemKind::DefaultImpl(..) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n             }\n             ItemKind::ForeignMod(..) => {\n-                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n-                                                                    foreign items instead\"));\n+                self.invalid_visibility(&item.vis,\n+                                        item.span,\n+                                        Some(\"place qualifiers on individual foreign items \\\n+                                              instead\"));\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n@@ -167,11 +178,14 @@ impl<'a> Visitor for AstValidator<'a> {\n         match fi.node {\n             ForeignItemKind::Fn(ref decl, _) => {\n                 self.check_decl_no_pat(decl, |span, is_recent| {\n-                    let mut err = struct_span_err!(self.session, span, E0130,\n-                                        \"patterns aren't allowed in foreign function declarations\");\n+                    let mut err = struct_span_err!(self.session,\n+                                                   span,\n+                                                   E0130,\n+                                                   \"patterns aren't allowed in foreign function \\\n+                                                    declarations\");\n                     if is_recent {\n-                        err.span_note(span, \"this is a recent error, see \\\n-                                             issue #35203 for more details\");\n+                        err.span_note(span,\n+                                      \"this is a recent error, see issue #35203 for more details\");\n                     }\n                     err.emit();\n                 });\n@@ -182,16 +196,21 @@ impl<'a> Visitor for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n-    fn visit_variant_data(&mut self, vdata: &VariantData, _: Ident,\n-                          _: &Generics, _: NodeId, span: Span) {\n+    fn visit_variant_data(&mut self,\n+                          vdata: &VariantData,\n+                          _: Ident,\n+                          _: &Generics,\n+                          _: NodeId,\n+                          span: Span) {\n         if vdata.fields().is_empty() {\n             if vdata.is_tuple() {\n-                self.err_handler().struct_span_err(span, \"empty tuple structs and enum variants \\\n-                                                          are not allowed, use unit structs and \\\n-                                                          enum variants instead\")\n-                                         .span_help(span, \"remove trailing `()` to make a unit \\\n-                                                           struct or unit enum variant\")\n-                                         .emit();\n+                self.err_handler()\n+                    .struct_span_err(span,\n+                                     \"empty tuple structs and enum variants are not allowed, use \\\n+                                      unit structs and enum variants instead\")\n+                    .span_help(span,\n+                               \"remove trailing `()` to make a unit struct or unit enum variant\")\n+                    .emit();\n             }\n         }\n \n@@ -200,10 +219,10 @@ impl<'a> Visitor for AstValidator<'a> {\n \n     fn visit_vis(&mut self, vis: &Visibility) {\n         match *vis {\n-            Visibility::Restricted{ref path, ..} => {\n+            Visibility::Restricted { ref path, .. } => {\n                 if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n-                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n-                                                            in visibility path\");\n+                    self.err_handler()\n+                        .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }\n             }\n             _ => {}"}, {"sha": "fc55118c9f4c518ed0fa989067cf40f95f580f9e", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 70, "deletions": 78, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -25,7 +25,7 @@\n // by borrowck::gather_loans\n \n use rustc::dep_graph::DepNode;\n-use rustc::ty::cast::{CastKind};\n+use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n@@ -71,12 +71,12 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n-    rvalue_borrows: NodeMap<hir::Mutability>\n+    rvalue_borrows: NodeMap<hir::Mutability>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R,\n+    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R\n+        where F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n@@ -87,17 +87,17 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         r\n     }\n \n-    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R,\n+    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R\n+        where F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => self.tcx.empty_parameter_environment()\n+            None => self.tcx.empty_parameter_environment(),\n         };\n \n-        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n-            f(&mut euv::ExprUseVisitor::new(self, &infcx))\n-        })\n+        self.tcx\n+            .infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal)\n+            .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {\n@@ -111,13 +111,17 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n         if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n             match err.kind {\n-                UnimplementedConstVal(_) => {},\n-                IndexOpFeatureGated => {},\n-                ErroneousReferencedConstant(_) => {},\n-                _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n-                                         format!(\"constant evaluation error: {}. This will \\\n-                                                 become a HARD ERROR in the future\",\n-                                                 err.description().into_oneline())),\n+                UnimplementedConstVal(_) => {}\n+                IndexOpFeatureGated => {}\n+                ErroneousReferencedConstant(_) => {}\n+                _ => {\n+                    self.tcx.sess.add_lint(CONST_ERR,\n+                                           expr.id,\n+                                           expr.span,\n+                                           format!(\"constant evaluation error: {}. This will \\\n+                                                    become a HARD ERROR in the future\",\n+                                                   err.description().into_oneline()))\n+                }\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -143,17 +147,15 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n \n         let mode = match fk {\n-            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => {\n-                Mode::ConstFn\n-            }\n+            FnKind::ItemFn(_, _, _, hir::Constness::Const, _, _, _) => Mode::ConstFn,\n             FnKind::Method(_, m, _, _) => {\n                 if m.constness == hir::Constness::Const {\n                     Mode::ConstFn\n                 } else {\n                     Mode::Var\n                 }\n             }\n-            _ => Mode::Var\n+            _ => Mode::Var,\n         };\n \n         let qualif = self.with_mode(mode, |this| {\n@@ -175,11 +177,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n \n     /// Returns true if the call is to a const fn or method.\n-    fn handle_const_fn_call(&mut self,\n-                            _expr: &hir::Expr,\n-                            def_id: DefId,\n-                            ret_ty: Ty<'gcx>)\n-                            -> bool {\n+    fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n             let qualif = self.fn_like(fn_like.kind(),\n                                       fn_like.decl(),\n@@ -285,13 +283,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n-                        span_err!(self.tcx.sess, start.span, E0030,\n-                            \"lower range bound must be less than or equal to upper\");\n+                        span_err!(self.tcx.sess,\n+                                  start.span,\n+                                  E0030,\n+                                  \"lower range bound must be less than or equal to upper\");\n                     }\n                     Err(ErrorReported) => {}\n                 }\n             }\n-            _ => intravisit::walk_pat(self, p)\n+            _ => intravisit::walk_pat(self, p),\n         }\n     }\n \n@@ -301,13 +301,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             match stmt.node {\n                 hir::StmtDecl(ref decl, _) => {\n                     match decl.node {\n-                        hir::DeclLocal(_) => {},\n+                        hir::DeclLocal(_) => {}\n                         // Item statements are allowed\n-                        hir::DeclItem(_) => continue\n+                        hir::DeclItem(_) => continue,\n                     }\n                 }\n-                hir::StmtExpr(_, _) => {},\n-                hir::StmtSemi(_, _) => {},\n+                hir::StmtExpr(_, _) => {}\n+                hir::StmtSemi(_, _) => {}\n             }\n             self.add_qualif(ConstQualif::NOT_CONST);\n         }\n@@ -340,7 +340,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n                     ty::TyArray(_, n) => n,\n-                    _ => bug!()\n+                    _ => bug!(),\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n@@ -354,7 +354,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 for pat in arms.iter().flat_map(|arm| &arm.pats) {\n                     let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n                     match (borrow, pat_borrow) {\n-                        (None, _) | (_, Some(hir::MutMutable)) => {\n+                        (None, _) |\n+                        (_, Some(hir::MutMutable)) => {\n                             borrow = pat_borrow;\n                         }\n                         _ => {}\n@@ -365,7 +366,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n                 intravisit::walk_expr(self, ex);\n             }\n-            _ => intravisit::walk_expr(self, ex)\n+            _ => intravisit::walk_expr(self, ex),\n         }\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n@@ -405,17 +406,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         if self.mode == Mode::Var && !self.qualif.intersects(ConstQualif::NOT_CONST) {\n             match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n                 Ok(_) => {}\n-                Err(ConstEvalErr { kind: UnimplementedConstVal(_), ..}) |\n-                Err(ConstEvalErr { kind: MiscCatchAll, ..}) |\n-                Err(ConstEvalErr { kind: MiscBinaryOp, ..}) |\n-                Err(ConstEvalErr { kind: NonConstPath, ..}) |\n-                Err(ConstEvalErr { kind: UnresolvedPath, ..}) |\n-                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), ..}) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), ..}) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), ..}) |\n-                Err(ConstEvalErr { kind: IndexOpFeatureGated, ..}) => {},\n+                Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n+                Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n+                Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n+                Err(ConstEvalErr { kind: NonConstPath, .. }) |\n+                Err(ConstEvalErr { kind: UnresolvedPath, .. }) |\n+                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n+                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n+                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n+                Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n                 Err(msg) => {\n-                    self.tcx.sess.add_lint(CONST_ERR, ex.id,\n+                    self.tcx.sess.add_lint(CONST_ERR,\n+                                           ex.id,\n                                            msg.span,\n                                            msg.description().into_oneline().into_owned())\n                 }\n@@ -434,8 +436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n /// every nested expression. If the expression is not part\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n-fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n-                        e: &hir::Expr, node_ty: Ty<'tcx>) {\n+fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n@@ -635,25 +636,23 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n         Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n         Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(\n-            ty::adjustment::AutoDerefRef { autoderefs, .. }\n-        )) => {\n-            if (0..autoderefs as u32).any(|autoderef| {\n-                    v.tcx.is_overloaded_autoderef(e.id, autoderef)\n-            }) {\n+        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+            if (0..autoderefs as u32)\n+                .any(|autoderef| v.tcx.is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }\n     }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n-        tcx: tcx,\n-        mode: Mode::Var,\n-        qualif: ConstQualif::NOT_CONST,\n-        rvalue_borrows: NodeMap()\n-    });\n+    tcx.visit_all_items_in_krate(DepNode::CheckConst,\n+                                 &mut CheckCrateVisitor {\n+                                     tcx: tcx,\n+                                     mode: Mode::Var,\n+                                     qualif: ConstQualif::NOT_CONST,\n+                                     rvalue_borrows: NodeMap(),\n+                                 });\n     tcx.sess.abort_if_errors();\n }\n \n@@ -675,7 +674,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n \n                 Categorization::Rvalue(..) |\n                 Categorization::Upvar(..) |\n-                Categorization::Local(..) => break\n+                Categorization::Local(..) => break,\n             }\n         }\n     }\n@@ -685,8 +684,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n               bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n+              loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants.\n         // These occur when we convert a &T or *T to a *U, as well as\n         // when making a thin pointer (e.g., `*T`) into a fat pointer\n@@ -695,7 +693,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n             euv::LoanCause::AutoUnsafe => {\n                 return;\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         let mut cur = &cmt;\n@@ -715,7 +713,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                         // type of the expression.  `&mut [1]` has exactly the\n                         // same representation as &mut 1.\n                         match cmt.ty.sty {\n-                            ty::TyArray(_, _) | ty::TySlice(_) => break,\n+                            ty::TyArray(_, _) |\n+                            ty::TySlice(_) => break,\n                             _ => {}\n                         }\n                     }\n@@ -732,27 +731,20 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                 }\n \n                 Categorization::Upvar(..) |\n-                Categorization::Local(..) => break\n+                Categorization::Local(..) => break,\n             }\n         }\n     }\n \n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {}\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n     fn mutate(&mut self,\n               _assignment_id: ast::NodeId,\n               _assignment_span: Span,\n               _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {}\n+              _mode: euv::MutateMode) {\n+    }\n \n-    fn matched_pat(&mut self,\n-                   _: &hir::Pat,\n-                   _: mc::cmt,\n-                   _: euv::MatchMode) {}\n+    fn matched_pat(&mut self, _: &hir::Pat, _: mc::cmt, _: euv::MatchMode) {}\n \n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {}\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, _cmt: mc::cmt, _mode: euv::ConsumeMode) {}\n }"}, {"sha": "7049040678e39f706499e9a7cc920dfe89f797aa", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -121,11 +121,11 @@ All statics and constants need to resolve to a value in an acyclic manner.\n \n For example, neither of the following can be sensibly compiled:\n \n-```compile_fail\n+```compile_fail,E0265\n const X: u32 = X;\n ```\n \n-```compile_fail\n+```compile_fail,E0265\n const X: u32 = Y;\n const Y: u32 = X;\n ```\n@@ -135,7 +135,7 @@ E0267: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) inside a\n closure but outside of any loop. Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0267\n let w = || { break; }; // error: `break` inside of a closure\n ```\n \n@@ -159,7 +159,7 @@ This error indicates the use of a loop keyword (`break` or `continue`) outside\n of a loop. Without a loop to break out of or continue in, no sensible action can\n be taken. Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0268\n fn some_func() {\n     break; // error: `break` outside of loop\n }"}, {"sha": "e59c4a6fc4186bfbb9664dcf7042a630ce574de9", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -28,12 +28,15 @@\n #![feature(rustc_private)]\n \n extern crate core;\n-#[macro_use] extern crate rustc;\n+#[macro_use]\n+extern crate rustc;\n extern crate rustc_const_eval;\n extern crate rustc_const_math;\n \n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n "}, {"sha": "4e251793f6917ae645fc6c14c7581aa26c3f658d", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -19,19 +19,24 @@ use syntax_pos::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n-    Normal, Loop, Closure\n+    Normal,\n+    Loop,\n+    Closure,\n }\n \n #[derive(Copy, Clone)]\n struct CheckLoopVisitor<'a> {\n     sess: &'a Session,\n-    cx: Context\n+    cx: Context,\n }\n \n pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n-    krate.visit_all_items(&mut CheckLoopVisitor { sess: sess, cx: Normal });\n+    krate.visit_all_items(&mut CheckLoopVisitor {\n+        sess: sess,\n+        cx: Normal,\n+    });\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n@@ -53,14 +58,14 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n-            _ => intravisit::walk_expr(self, e)\n+            _ => intravisit::walk_expr(self, e),\n         }\n     }\n }\n \n impl<'a> CheckLoopVisitor<'a> {\n-    fn with_context<F>(&mut self, cx: Context, f: F) where\n-        F: FnOnce(&mut CheckLoopVisitor<'a>),\n+    fn with_context<F>(&mut self, cx: Context, f: F)\n+        where F: FnOnce(&mut CheckLoopVisitor<'a>)\n     {\n         let old_cx = self.cx;\n         self.cx = cx;\n@@ -72,12 +77,10 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                span_err!(self.sess, span, E0267,\n-                                   \"`{}` inside of a closure\", name);\n+                span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                span_err!(self.sess, span, E0268,\n-                                   \"`{}` outside of loop\", name);\n+                span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "af3065d64e8db08bc7fd8ee36cca33a93971fff3", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -19,9 +19,11 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    if sess.target.target.options.allow_asm { return; }\n+    if sess.target.target.options.allow_asm {\n+        return;\n+    }\n \n-    visit::walk_crate(&mut CheckNoAsm { sess: sess, }, krate);\n+    visit::walk_crate(&mut CheckNoAsm { sess: sess }, krate);\n }\n \n #[derive(Copy, Clone)]\n@@ -32,9 +34,13 @@ struct CheckNoAsm<'a> {\n impl<'a> Visitor for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,\n-                                                     \"asm! is unsupported on this target\"),\n-            _ => {},\n+            ast::ExprKind::InlineAsm(_) => {\n+                span_err!(self.sess,\n+                          e.span,\n+                          E0472,\n+                          \"asm! is unsupported on this target\")\n+            }\n+            _ => {}\n         }\n         visit::walk_expr(self, e)\n     }"}, {"sha": "8b2943a33c006aaced7fd7cee377a241ff187467", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -13,11 +13,11 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n-use rustc::session::{Session, CompileResult};\n+use rustc::session::{CompileResult, Session};\n use rustc::hir::def::{Def, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n-use syntax::{ast};\n+use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor};\n@@ -41,18 +41,17 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         match it.node {\n             hir::ItemStatic(..) |\n             hir::ItemConst(..) => {\n-                let mut recursion_visitor =\n-                    CheckItemRecursionVisitor::new(self, &it.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &it.span);\n                 recursion_visitor.visit_item(it);\n-            },\n+            }\n             hir::ItemEnum(ref enum_def, ref generics) => {\n                 // We could process the whole enum, but handling the variants\n                 // with discriminant expressions one by one gives more specific,\n                 // less redundant output.\n                 for variant in &enum_def.variants {\n                     if let Some(_) = variant.node.disr_expr {\n-                        let mut recursion_visitor =\n-                            CheckItemRecursionVisitor::new(self, &variant.span);\n+                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self,\n+                                                                                   &variant.span);\n                         recursion_visitor.populate_enum_discriminants(enum_def);\n                         recursion_visitor.visit_variant(variant, generics, it.id);\n                     }\n@@ -67,8 +66,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n         match ti.node {\n             hir::ConstTraitItem(_, ref default) => {\n                 if let Some(_) = *default {\n-                    let mut recursion_visitor =\n-                        CheckItemRecursionVisitor::new(self, &ti.span);\n+                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ti.span);\n                     recursion_visitor.visit_trait_item(ti);\n                 }\n             }\n@@ -80,8 +78,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n     fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                let mut recursion_visitor =\n-                    CheckItemRecursionVisitor::new(self, &ii.span);\n+                let mut recursion_visitor = CheckItemRecursionVisitor::new(self, &ii.span);\n                 recursion_visitor.visit_impl_item(ii);\n             }\n             _ => {}\n@@ -117,7 +114,8 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n }\n \n impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n-    fn new(v: &'a CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+    fn new(v: &'a CheckCrateVisitor<'a, 'ast>,\n+           span: &'a Span)\n            -> CheckItemRecursionVisitor<'a, 'ast> {\n         CheckItemRecursionVisitor {\n             root_span: span,\n@@ -129,7 +127,8 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         }\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n-          where F: Fn(&mut Self) {\n+        where F: Fn(&mut Self)\n+    {\n         if self.idstack.iter().any(|&x| x == id) {\n             let any_static = self.idstack.iter().any(|&x| {\n                 if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n@@ -146,7 +145,9 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n                 if !self.sess.features.borrow().static_recursion {\n                     emit_feature_err(&self.sess.parse_sess.span_diagnostic,\n                                      \"static_recursion\",\n-                                     *self.root_span, GateIssue::Language, \"recursive static\");\n+                                     *self.root_span,\n+                                     GateIssue::Language,\n+                                     \"recursive static\");\n                 }\n             } else {\n                 span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n@@ -170,7 +171,9 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n         // has no variants.\n         let mut discriminant_map = self.discriminant_map.borrow_mut();\n         match enum_definition.variants.first() {\n-            None => { return; }\n+            None => {\n+                return;\n+            }\n             Some(variant) if discriminant_map.contains_key(&variant.node.data.id()) => {\n                 return;\n             }\n@@ -203,14 +206,19 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it));\n     }\n \n-    fn visit_enum_def(&mut self, enum_definition: &'ast hir::EnumDef,\n-                      generics: &'ast hir::Generics, item_id: ast::NodeId, _: Span) {\n+    fn visit_enum_def(&mut self,\n+                      enum_definition: &'ast hir::EnumDef,\n+                      generics: &'ast hir::Generics,\n+                      item_id: ast::NodeId,\n+                      _: Span) {\n         self.populate_enum_discriminants(enum_definition);\n         intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n     }\n \n-    fn visit_variant(&mut self, variant: &'ast hir::Variant,\n-                     _: &'ast hir::Generics, _: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     variant: &'ast hir::Variant,\n+                     _: &'ast hir::Generics,\n+                     _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n         let maybe_expr;\n         if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n@@ -246,18 +254,14 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     Some(Def::Const(def_id)) => {\n                         if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n                             match self.ast_map.get(node_id) {\n-                                ast_map::NodeItem(item) =>\n-                                    self.visit_item(item),\n-                                ast_map::NodeTraitItem(item) =>\n-                                    self.visit_trait_item(item),\n-                                ast_map::NodeImplItem(item) =>\n-                                    self.visit_impl_item(item),\n-                                ast_map::NodeForeignItem(_) => {},\n+                                ast_map::NodeItem(item) => self.visit_item(item),\n+                                ast_map::NodeTraitItem(item) => self.visit_trait_item(item),\n+                                ast_map::NodeImplItem(item) => self.visit_impl_item(item),\n+                                ast_map::NodeForeignItem(_) => {}\n                                 _ => {\n-                                    span_bug!(\n-                                        e.span,\n-                                        \"expected item, found {}\",\n-                                        self.ast_map.node_to_string(node_id));\n+                                    span_bug!(e.span,\n+                                              \"expected item, found {}\",\n+                                              self.ast_map.node_to_string(node_id));\n                                 }\n                             }\n                         }\n@@ -268,9 +272,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // might be (if any).\n                     Some(Def::Variant(enum_id, variant_id)) => {\n                         if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n-                            if let hir::ItemEnum(ref enum_def, ref generics) =\n-                                self.ast_map.expect_item(enum_node_id).node\n-                            {\n+                            if let hir::ItemEnum(ref enum_def, ref generics) = self.ast_map\n+                                .expect_item(enum_node_id)\n+                                .node {\n                                 self.populate_enum_discriminants(enum_def);\n                                 let enum_id = self.ast_map.as_local_node_id(enum_id).unwrap();\n                                 let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n@@ -283,10 +287,10 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                             }\n                         }\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n-            },\n-            _ => ()\n+            }\n+            _ => (),\n         }\n         intravisit::walk_expr(self, e);\n     }"}, {"sha": "11ef75ee6a8fc4fcc90596feebccca7687c16fb0", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -146,13 +146,53 @@ mod foo {\n }\n \n use foo::MyTrait::do_something;\n+// error: `do_something` is not directly importable\n \n fn main() {}\n ```\n \n It's invalid to directly import methods belonging to a trait or concrete type.\n \"##,\n \n+E0254: r##\"\n+Attempt was made to import an item whereas an extern crate with this name has\n+already been imported.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0254\n+extern crate collections;\n+\n+mod foo {\n+    pub trait collections {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::collections; // error: an extern crate named `collections` has already\n+                      //        been imported in this module\n+\n+fn main() {}\n+```\n+\n+To fix issue issue, you have to rename at least one of the two imports.\n+Example:\n+\n+```ignore\n+extern crate collections as libcollections; // ok!\n+\n+mod foo {\n+    pub trait collections {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::collections;\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0255: r##\"\n You can't import a value whose name is the same as another value defined in the\n module.\n@@ -1237,7 +1277,6 @@ impl Foo for i32 {}\n register_diagnostics! {\n //  E0153, unused error code\n //  E0157, unused error code\n-    E0254, // import conflicts with imported crate in this module\n //  E0257,\n //  E0258,\n     E0402, // cannot use an outer type parameter in this context"}, {"sha": "50ffa52e88ba497e5c6833635470a78a7ed6a4b8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -310,8 +310,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             None => match rscope.anon_regions(default_span, 1) {\n                 Ok(rs) => rs[0],\n                 Err(params) => {\n-                    let mut err = struct_span_err!(self.tcx().sess, default_span, E0106,\n-                                                   \"missing lifetime specifier\");\n+                    let ampersand_span = Span { hi: default_span.lo, ..default_span};\n+\n+                    let mut err = struct_span_err!(self.tcx().sess, ampersand_span, E0106,\n+                                                 \"missing lifetime specifier\");\n+                    err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n+\n                     if let Some(params) = params {\n                         report_elision_failure(&mut err, params);\n                     }\n@@ -2269,9 +2273,25 @@ fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n }\n \n fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected: usize) {\n-    span_err!(tcx.sess, span, E0107,\n-              \"wrong number of lifetime parameters: expected {}, found {}\",\n-              expected, number);\n+    let label = if number < expected {\n+        if expected == 1 {\n+            format!(\"expected {} lifetime parameter\", expected)\n+        } else {\n+            format!(\"expected {} lifetime parameters\", expected)\n+        }\n+    } else {\n+        let additional = number - expected;\n+        if additional == 1 {\n+            \"unexpected lifetime parameter\".to_string()\n+        } else {\n+            format!(\"{} unexpected lifetime parameters\", additional)\n+        }\n+    };\n+    struct_span_err!(tcx.sess, span, E0107,\n+                     \"wrong number of lifetime parameters: expected {}, found {}\",\n+                     expected, number)\n+        .span_label(span, &label)\n+        .emit();\n }\n \n // A helper struct for conveniently grouping a set of bounds which we pass to"}, {"sha": "8da061208730fc85dfd52f5d9cc43300495e5e73", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -847,7 +847,9 @@ fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // good\n         }\n         hir::Constness::Const => {\n-            span_err!(ccx.tcx.sess, span, E0379, \"trait fns cannot be declared const\");\n+            struct_span_err!(ccx.tcx.sess, span, E0379, \"trait fns cannot be declared const\")\n+                .span_label(span, &format!(\"trait fns cannot be const\"))\n+                .emit()\n         }\n     }\n }\n@@ -993,7 +995,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n+        let ty_impl_item = tcx.impl_or_trait_item(tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name());\n \n@@ -1014,11 +1016,18 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_const,\n                                            &impl_trait_ref);\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0323,\n+                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_const.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         // We can only get the spans from local trait definition\n+                         // Same for E0324 and E0325\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n@@ -1037,11 +1046,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             &trait_method,\n                                             &impl_trait_ref);\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0324,\n+                        let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_method.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::Type(_) => {\n@@ -1055,11 +1069,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n-                        span_err!(tcx.sess, impl_item.span, E0325,\n+                        let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{:?}`\",\n                                   impl_type.name,\n-                                  impl_trait_ref)\n+                                  impl_trait_ref);\n+                         err.span_label(impl_item.span, &format!(\"does not match trait\"));\n+                         if let Some(trait_span) = tcx.map.span_if_local(ty_trait_item.def_id()) {\n+                            err.span_label(trait_span, &format!(\"original trait requirement\"));\n+                         }\n+                         err.emit()\n                     }\n                 }\n             }\n@@ -1251,8 +1270,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0081,\n                     \"discriminant value `{}` already exists\", disr_vals[i]);\n                 let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                span_note!(&mut err, ccx.tcx.map.span(variant_i_node_id),\n-                    \"conflicting discriminant here\");\n+                err.span_label(ccx.tcx.map.span(variant_i_node_id),\n+                               &format!(\"first use of `{}`\", disr_vals[i]));\n+                err.span_label(v.span , &format!(\"enum already has `{}`\", disr_vals[i]));\n                 err.emit();\n             }\n             disr_vals.push(current_disr_val);\n@@ -3406,17 +3426,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // FIXME(#32730) propagate obligations\n                             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n                         if eq_result.is_err() {\n-                            span_err!(tcx.sess, expr.span, E0069,\n-                                      \"`return;` in a function whose return type is not `()`\");\n+                            struct_span_err!(tcx.sess, expr.span, E0069,\n+                                     \"`return;` in a function whose return type is not `()`\")\n+                                .span_label(expr.span, &format!(\"return type is not ()\"))\n+                                .emit();\n                         }\n                     }\n                 }\n                 ty::FnDiverging => {\n                     if let Some(ref e) = *expr_opt {\n                         self.check_expr(&e);\n                     }\n-                    span_err!(tcx.sess, expr.span, E0166,\n-                        \"`return` in a function declared as diverging\");\n+                    struct_span_err!(tcx.sess, expr.span, E0166,\n+                        \"`return` in a function declared as diverging\")\n+                        .span_label(expr.span, &format!(\"diverging function cannot return\"))\n+                        .emit();\n                 }\n             }\n             self.write_ty(id, self.next_diverging_ty_var());"}, {"sha": "92b91028b98b0b1401cc32faed14763e25b75ffd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -2317,8 +2317,12 @@ fn report_unused_parameter(ccx: &CrateCtxt,\n                            kind: &str,\n                            name: &str)\n {\n-    span_err!(ccx.tcx.sess, span, E0207,\n-              \"the {} parameter `{}` is not constrained by the \\\n-               impl trait, self type, or predicates\",\n-              kind, name);\n+    struct_span_err!(\n+        ccx.tcx.sess, span, E0207,\n+        \"the {} parameter `{}` is not constrained by the \\\n+        impl trait, self type, or predicates\",\n+        kind, name)\n+        .span_label(span, &format!(\"unconstrained lifetime parameter\"))\n+        .emit();\n+\n }"}, {"sha": "3b132744f7055ce176e0f0689aca601b53a454c6", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -27,7 +27,7 @@ use sys_common::{AsInner, FromInner};\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n use libc::{stat64, fstat64, lstat64, off64_t, ftruncate64, lseek64, dirent64, readdir64_r, open64};\n #[cfg(target_os = \"android\")]\n-use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off64_t, lseek64,\n+use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, lseek64,\n            dirent as dirent64, open as open64};\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"emscripten\",\n@@ -485,9 +485,11 @@ impl File {\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n-            SeekFrom::Start(off) => (libc::SEEK_SET, off as off64_t),\n-            SeekFrom::End(off) => (libc::SEEK_END, off as off64_t),\n-            SeekFrom::Current(off) => (libc::SEEK_CUR, off as off64_t),\n+            // Casting to `i64` is fine, too large values will end up as\n+            // negative which will cause an error in `lseek64`.\n+            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (libc::SEEK_END, off),\n+            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n         };\n         let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n         Ok(n as u64)"}, {"sha": "4e6cef9a28d8f32147d5db051c5e95c2f5469a69", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -324,6 +324,8 @@ impl File {\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, pos) = match pos {\n+            // Casting to `i64` is fine, `SetFilePointerEx` reinterprets this\n+            // integer as `u64`.\n             SeekFrom::Start(n) => (c::FILE_BEGIN, n as i64),\n             SeekFrom::End(n) => (c::FILE_END, n),\n             SeekFrom::Current(n) => (c::FILE_CURRENT, n),"}, {"sha": "00facc91728027608eb85702b2517cd21e561ca1", "filename": "src/test/compile-fail/E0069.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0069.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n fn foo() -> u8 {\n-    return; //~ ERROR E0069\n+    return;\n+    //~^ ERROR `return;` in a function whose return type is not `()`\n+    //~| NOTE return type is not ()\n }\n \n fn main() {"}, {"sha": "dab03f0bccfd0b88befcaa5d581470af50a530a1", "filename": "src/test/compile-fail/E0106.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0106.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -9,13 +9,19 @@\n // except according to those terms.\n \n struct Foo {\n-    x: &bool, //~ ERROR E0106\n+    x: &bool,\n+    //~^ ERROR E0106\n+    //~| NOTE expected lifetime parameter\n }\n enum Bar {\n     A(u8),\n-    B(&bool), //~ ERROR E0106\n+    B(&bool),\n+   //~^ ERROR E0106\n+   //~| NOTE expected lifetime parameter\n }\n-type MyStr = &str; //~ ERROR E0106\n+type MyStr = &str;\n+        //~^ ERROR E0106\n+        //~| NOTE expected lifetime parameter\n \n fn main() {\n }"}, {"sha": "5f333e17c478efeabaeec150842e1bd4530df4ff", "filename": "src/test/compile-fail/E0107.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0107.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -9,16 +9,27 @@\n // except according to those terms.\n \n struct Foo<'a>(&'a str);\n+struct Buzz<'a, 'b>(&'a str, &'b str);\n \n enum Bar {\n     A,\n     B,\n     C,\n }\n \n-struct Baz<'a> {\n-    foo: Foo, //~ ERROR E0107\n-    bar: Bar<'a>, //~ ERROR E0107\n+struct Baz<'a, 'b, 'c> {\n+    foo: Foo,\n+    //~^ ERROR E0107\n+    //~| expected 1 lifetime parameter\n+    buzz: Buzz<'a>,\n+    //~^ ERROR E0107\n+    //~| expected 2 lifetime parameters\n+    bar: Bar<'a>,\n+    //~^ ERROR E0107\n+    //~| unexpected lifetime parameter\n+    foo2: Foo<'a, 'b, 'c>,\n+    //~^ ERROR E0107\n+    //~| 2 unexpected lifetime parameters\n }\n \n fn main() {"}, {"sha": "f8585d71b402a080c052a5d09a79a45542b5079f", "filename": "src/test/compile-fail/E0166.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0166.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0166.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0166.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo() -> ! { return; } //~ ERROR E0166\n+fn foo() -> ! { return; }\n+    //~^ ERROR E0166\n+    //~| NOTE diverging function cannot return\n \n fn main() {\n }"}, {"sha": "43ff085a4fa8e36c49c7d26447fbdc8629ad96fa", "filename": "src/test/compile-fail/E0207.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0207.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -11,6 +11,7 @@\n struct Foo;\n \n impl<T: Default> Foo { //~ ERROR E0207\n+                       //~| NOTE unconstrained lifetime parameter\n     fn get(&self) -> T {\n         <T as Default>::default()\n     }"}, {"sha": "6ff0baeeb4d4bd25c16e420febcebf7f2fb41af3", "filename": "src/test/compile-fail/E0229.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0229.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0229.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0229.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -20,7 +20,9 @@ impl Foo for isize {\n     fn boo(&self) -> usize { 42 }\n }\n \n-fn baz<I>(x: &<I as Foo<A=Bar>>::A) {} //~ ERROR E0229\n+fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n+//~^ ERROR associated type bindings are not allowed here [E0229]\n+//~| NOTE associate type not allowed here\n \n fn main() {\n }"}, {"sha": "28fcf4452b3e85766629dd1a5f4f7789ffbf099b", "filename": "src/test/compile-fail/E0253.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0253.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub trait MyTrait {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::MyTrait::do_something; //~ ERROR E0253\n+\n+fn main() {}"}, {"sha": "28f9aea96572cfd53b86c56697d011750b53c562", "filename": "src/test/compile-fail/E0254.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0254.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate collections;\n+\n+mod foo {\n+    pub trait collections {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::collections; //~ ERROR E0254\n+\n+fn main() {}"}, {"sha": "e05c6bede7e046943c1e4682251cc5126ee6977c", "filename": "src/test/compile-fail/E0255.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0255.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use bar::foo;\n+\n+fn foo() {} //~ ERROR E0255\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}"}, {"sha": "6b7e86138594be7898d38b28a2b260495437c665", "filename": "src/test/compile-fail/E0259.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0259.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate collections;\n+extern crate libc as collections; //~ ERROR E0259\n+\n+fn main() {}"}, {"sha": "d20829bf4d415165e59e170e185a2938fcfd221e", "filename": "src/test/compile-fail/E0260.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0260.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate collections;\n+\n+mod collections { //~ ERROR E0260\n+    pub trait MyTrait {\n+        fn do_something();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4196ad370b8871eec05832bba7b77d44bdd53801", "filename": "src/test/compile-fail/E0261.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0261.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(x: &'a str) { } //~ ERROR E0261\n+\n+struct Foo {\n+    x: &'a str, //~ ERROR E0261\n+}\n+\n+fn main() {}"}, {"sha": "e09e4766d51744ebf1f05e75d1f9646aa4b03e2a", "filename": "src/test/compile-fail/E0262.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0262.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0262.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0262.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'static>(x: &'static str) { } //~ ERROR E0262\n+\n+fn main() {}"}, {"sha": "09f654c368c62471c5224bd25fb4741afb4eb48c", "filename": "src/test/compile-fail/E0263.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0263.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0263.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0263.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { } //~ ERROR E0263\n+\n+fn main() {}"}, {"sha": "92332977e767609b37e6729823fb4de06c3b2005", "filename": "src/test/compile-fail/E0264.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0264.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(lang_items)]\n+\n+extern \"C\" {\n+    #[lang = \"cake\"]\n+    fn cake(); //~ ERROR E0264\n+}\n+\n+fn main() {}"}, {"sha": "6287256e866c9e948cc79d1291188979c932f372", "filename": "src/test/compile-fail/E0267.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0267.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let w = || { break; }; //~ ERROR E0267\n+}"}, {"sha": "41e88e2f492a9c77a8441ddcaaa368dc07c1faff", "filename": "src/test/compile-fail/E0268.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0268.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    break; //~ ERROR E0268\n+}"}, {"sha": "9ffaef7472b7830d4c5b259589c4109cd66350ff", "filename": "src/test/compile-fail/E0306.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0306.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2FE0306.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0306.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -8,9 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: [u32; \"hello\"] = []; //~ ERROR E0306\n-const B: [u32; true] = []; //~ ERROR E0306\n-const C: [u32; 0.0] = []; //~ ERROR E0306\n+const A: [u32; \"hello\"] = [];\n+//~^ ERROR expected `usize` for array length, found string literal [E0306]\n+//~| NOTE expected `usize`\n+\n+const B: [u32; true] = [];\n+//~^ ERROR expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n+const C: [u32; 0.0] = [];\n+//~^ ERROR expected `usize` for array length, found float [E0306]\n+//~| NOTE expected `usize`\n \n fn main() {\n }"}, {"sha": "1a5496f0551507354ffcb5219f7fbca94911b742", "filename": "src/test/compile-fail/bad-bang-ann-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -11,7 +11,9 @@\n // Tests that a function with a ! annotation always actually fails\n \n fn bad_bang(i: usize) -> ! {\n-    return 7; //~ ERROR `return` in a function declared as diverging [E0166]\n+    return 7;\n+    //~^ ERROR `return` in a function declared as diverging [E0166]\n+    //~| NOTE diverging function cannot return\n }\n \n fn main() { bad_bang(5); }"}, {"sha": "ec330247f238b07c77a7f6a6b955dcaced8651b0", "filename": "src/test/compile-fail/borrowck/borrowck-escaping-closure-error-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-1.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -22,4 +22,6 @@ fn main() {\n     let mut books = vec![1,2,3];\n     spawn(|| books.push(4));\n     //~^ ERROR E0373\n+    //~| NOTE `books` is borrowed here\n+    //~| NOTE may outlive borrowed value `books`\n }"}, {"sha": "81685c32f2f29b6285b5fdadd05532746cc4c5b0", "filename": "src/test/compile-fail/borrowck/borrowck-escaping-closure-error-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-escaping-closure-error-2.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -20,6 +20,8 @@ fn foo<'a>(x: &'a i32) -> Box<FnMut()+'a> {\n     let mut books = vec![1,2,3];\n     Box::new(|| books.push(4))\n     //~^ ERROR E0373\n+    //~| NOTE `books` is borrowed here\n+    //~| NOTE may outlive borrowed value `books`\n }\n \n fn main() { }"}, {"sha": "92568b27f7c1da143e24a4fd2a982f3df13026d7", "filename": "src/test/compile-fail/const-fn-mismatch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -20,7 +20,9 @@ trait Foo {\n }\n \n impl Foo for u32 {\n-    const fn f() -> u32 { 22 } //~ ERROR E0379\n+    const fn f() -> u32 { 22 }\n+    //~^ ERROR E0379\n+    //~| NOTE trait fns cannot be const\n }\n \n fn main() { }"}, {"sha": "398dc2f22150cc8c90fc1daf0ee9030990b00c86", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -25,17 +25,35 @@ const X3: usize = -42 && -39; //~ ERROR E0080\n const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n \n const Y: usize = 42.0 == 42.0;\n-const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n+const ARRR: [i32; Y] = [99; 1];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n+const ARRR1: [i32; Y] = [99; 1];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n+const ARRR2: [i32; Y] = [99; 1];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n+const ARRR3: [i32; Y] = [99; 0];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n+const ARRR4: [i32; Y] = [99; 0];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n+const ARRR5: [i32; Y] = [99; 0];\n+//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n+//~| NOTE expected `usize`\n+\n \n fn main() {\n     let _ = ARR;"}, {"sha": "d48433ee928f1eb2b7c84d6133045766b3e14f3e", "filename": "src/test/compile-fail/impl-unused-rps-in-assoc-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-unused-rps-in-assoc-type.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -19,6 +19,7 @@ trait Fun {\n struct Holder { x: String }\n \n impl<'a> Fun for Holder { //~ ERROR E0207\n+                          //~| NOTE unconstrained lifetime parameter\n     type Output = &'a str;\n     fn call<'b>(&'b self) -> &'b str {\n         &self.x[..]"}, {"sha": "6452e50d0893ea9b3bc44ea22f1857eeb435b0c0", "filename": "src/test/compile-fail/impl-wrong-item-for-trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -12,7 +12,9 @@\n \n trait Foo {\n     fn bar(&self);\n-    const MY_CONST: u32;\n+    //~^ NOTE original trait requirement\n+    //~| NOTE original trait requirement\n+    const MY_CONST: u32; //~ NOTE original trait requirement\n }\n \n pub struct FooConstForMethod;\n@@ -21,6 +23,7 @@ impl Foo for FooConstForMethod {\n     //~^ ERROR E0046\n     const bar: u64 = 1;\n     //~^ ERROR E0323\n+    //~| NOTE does not match trait\n     const MY_CONST: u32 = 1;\n }\n \n@@ -31,6 +34,7 @@ impl Foo for FooMethodForConst {\n     fn bar(&self) {}\n     fn MY_CONST() {}\n     //~^ ERROR E0324\n+    //~| NOTE does not match trait\n }\n \n pub struct FooTypeForMethod;\n@@ -39,6 +43,7 @@ impl Foo for FooTypeForMethod {\n     //~^ ERROR E0046\n     type bar = u64;\n     //~^ ERROR E0325\n+    //~| NOTE does not match trait\n     const MY_CONST: u32 = 1;\n }\n "}, {"sha": "3d6f224c249040a1c1d168d0b5357ba9af7c06de", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -12,13 +12,18 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    B = 1, //~ ERROR discriminant value `1isize` already exists\n-    //~^^ NOTE conflicting\n+    //~^ NOTE first use\n+    //~| NOTE first use\n+    //~| NOTE first use\n+    B = 1, //~ ERROR discriminant value\n+    //~^ NOTE enum already\n     C = 0,\n-    D, //~ ERROR discriminant value `1isize` already exists\n-    //~^^^^^ NOTE conflicting\n-    E = N, //~ ERROR discriminant value `1isize` already exists\n-    //~^^^^^^^ NOTE conflicting\n+    D, //~ ERROR discriminant value\n+    //~^ NOTE enum already\n+\n+    E = N, //~ ERROR discriminant value\n+    //~^ NOTE enum already\n+\n }\n \n fn main() {}"}, {"sha": "d258a4a8b3325b18149d8dd641a3c6d49534a46b", "filename": "src/test/compile-fail/issue-22886.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22886.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -21,6 +21,7 @@ fn crash_please() {\n struct Newtype(Option<Box<usize>>);\n \n impl<'a> Iterator for Newtype { //~ ERROR E0207\n+                                //~| NOTE unconstrained lifetime parameter\n     type Item = &'a Box<usize>;\n \n     fn next(&mut self) -> Option<&Box<usize>> {"}, {"sha": "f1c559b6b889f207cdc7e4542cd60de3895775a3", "filename": "src/test/compile-fail/issue-23543.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-23543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-23543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23543.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -16,6 +16,7 @@ pub trait D {\n     fn f<T>(self)\n         where T<Bogus = Foo>: A;\n         //~^ ERROR associated type bindings are not allowed here [E0229]\n+        //~| NOTE associate type not allowed here\n }\n \n fn main() {}"}, {"sha": "3959c22d1d489384a9baccac9b838ad467fcd2af", "filename": "src/test/compile-fail/issue-23544.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-23544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-23544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23544.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -14,6 +14,7 @@ pub trait D {\n     fn f<T>(self)\n         where T<Bogus = Self::AlsoBogus>: A;\n         //~^ ERROR associated type bindings are not allowed here [E0229]\n+        //~| NOTE associate type not allowed here\n }\n \n fn main() {}"}, {"sha": "e89bff025e006bf6fed83b4939302027ecadf66f", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -16,5 +16,6 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `S`\n     //~| expected usize, found struct `S`\n-    //~| ERROR expected usize for repeat count, found struct\n+    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n+    //~| expected `usize`\n }"}, {"sha": "5c4f161a5004ed9c20c190da2fe38468d8a98eac", "filename": "src/test/compile-fail/issue-35139.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35139.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -17,6 +17,7 @@ pub trait MethodType {\n pub struct MTFn;\n \n impl<'a> MethodType for MTFn { //~ ERROR E0207\n+                               //~| NOTE unconstrained lifetime parameter\n     type GetProp = fmt::Debug + 'a;\n }\n "}, {"sha": "09371fbafcb560f98e91acab4a483709a4745a6b", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -14,7 +14,10 @@ fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     id(Box::new(|| *v))\n         //~^ ERROR E0373\n-        //~| ERROR cannot move out of borrowed content\n+        //~| NOTE `v` is borrowed here\n+        //~| NOTE may outlive borrowed value `v`\n+        //~| ERROR E0507\n+        //~| NOTE cannot move out of borrowed content\n }\n \n fn main() {"}, {"sha": "eba61ede8cb20e673e945fbe6c19e8c6043f0422", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -19,6 +19,7 @@ struct Foo {\n fn struct_with_a_nested_enum_and_vector() {\n     match (Foo { first: true, second: None }) {\n //~^ ERROR non-exhaustive patterns: `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n+//~| NOTE pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n         Foo { first: true, second: None } => (),\n         Foo { first: true, second: Some(_) } => (),\n         Foo { first: false, second: None } => (),\n@@ -35,6 +36,7 @@ enum Color {\n fn enum_with_single_missing_variant() {\n     match Color::Red {\n     //~^ ERROR non-exhaustive patterns: `Red` not covered\n+    //~| NOTE pattern `Red` not covered\n         Color::CustomRGBA { .. } => (),\n         Color::Green => ()\n     }\n@@ -47,6 +49,7 @@ enum Direction {\n fn enum_with_multiple_missing_variants() {\n     match Direction::North {\n     //~^ ERROR non-exhaustive patterns: `East`, `South` and `West` not covered\n+    //~| NOTE patterns `East`, `South` and `West` not covered\n         Direction::North => ()\n     }\n }\n@@ -58,6 +61,7 @@ enum ExcessiveEnum {\n fn enum_with_excessive_missing_variants() {\n     match ExcessiveEnum::First {\n     //~^ ERROR `Second`, `Third`, `Fourth` and 8 more not covered\n+    //~| NOTE patterns `Second`, `Third`, `Fourth` and 8 more not covered\n \n         ExcessiveEnum::First => ()\n     }\n@@ -66,6 +70,7 @@ fn enum_with_excessive_missing_variants() {\n fn enum_struct_variant() {\n     match Color::Red {\n     //~^ ERROR non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n+    //~| NOTE pattern `CustomRGBA { a: true, .. }` not covered\n         Color::Red => (),\n         Color::Green => (),\n         Color::CustomRGBA { a: false, r: _, g: _, b: 0 } => (),\n@@ -82,6 +87,7 @@ fn vectors_with_nested_enums() {\n     let x: &'static [Enum] = &[Enum::First, Enum::Second(false)];\n     match *x {\n     //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n+    //~| NOTE pattern `[Second(true), Second(false)]` not covered\n         [] => (),\n         [_] => (),\n         [Enum::First, _] => (),\n@@ -95,6 +101,7 @@ fn vectors_with_nested_enums() {\n fn missing_nil() {\n     match ((), false) {\n     //~^ ERROR non-exhaustive patterns: `((), false)` not covered\n+    //~| NOTE pattern `((), false)` not covered\n         ((), true) => ()\n     }\n }"}, {"sha": "6be2adbe2a0d1ac0eb200159b11af647bc1f875b", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-small.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -16,6 +16,10 @@\n \n fn escaping_borrow_of_closure_params_1() {\n     let g = |x: usize, y:usize| {\n+        //~^ NOTE reference must be valid for the scope of call-site for function\n+        //~| NOTE ...but borrowed value is only valid for the scope of function body\n+        //~| NOTE reference must be valid for the scope of call-site for function\n+        //~| NOTE ...but borrowed value is only valid for the scope of function body\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR `x` does not live long enough\n         //~| ERROR `y` does not live long enough\n@@ -31,6 +35,10 @@ fn escaping_borrow_of_closure_params_1() {\n \n fn escaping_borrow_of_closure_params_2() {\n     let g = |x: usize, y:usize| {\n+        //~^ NOTE reference must be valid for the scope of call-site for function\n+        //~| NOTE ...but borrowed value is only valid for the scope of function body\n+        //~| NOTE reference must be valid for the scope of call-site for function\n+        //~| NOTE ...but borrowed value is only valid for the scope of function body\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR `x` does not live long enough\n         //~| ERROR `y` does not live long enough\n@@ -64,7 +72,11 @@ fn escaping_borrow_of_fn_params_1() {\n     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR E0373\n+        //~| NOTE `x` is borrowed here\n+        //~| NOTE may outlive borrowed value `x`\n         //~| ERROR E0373\n+        //~| NOTE `y` is borrowed here\n+        //~| NOTE may outlive borrowed value `y`\n         return Box::new(f);\n     };\n \n@@ -75,7 +87,11 @@ fn escaping_borrow_of_fn_params_2() {\n     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR E0373\n+        //~| NOTE `x` is borrowed here\n+        //~| NOTE may outlive borrowed value `x`\n         //~| ERROR E0373\n+        //~| NOTE `y` is borrowed here\n+        //~| NOTE may outlive borrowed value `y`\n         Box::new(f)\n     };\n \n@@ -99,7 +115,11 @@ fn escaping_borrow_of_method_params_1() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             return Box::new(f);\n         }\n     }\n@@ -113,7 +133,11 @@ fn escaping_borrow_of_method_params_2() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             Box::new(f)\n         }\n     }\n@@ -141,7 +165,11 @@ fn escaping_borrow_of_trait_impl_params_1() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             return Box::new(f);\n         }\n     }\n@@ -156,7 +184,11 @@ fn escaping_borrow_of_trait_impl_params_2() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             Box::new(f)\n         }\n     }\n@@ -184,7 +216,11 @@ fn escaping_borrow_of_trait_default_params_1() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             return Box::new(f);\n         }\n     }\n@@ -198,7 +234,11 @@ fn escaping_borrow_of_trait_default_params_2() {\n         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n             //~^ ERROR E0373\n+            //~| NOTE `x` is borrowed here\n+            //~| NOTE may outlive borrowed value `x`\n             //~| ERROR E0373\n+            //~| NOTE `y` is borrowed here\n+            //~| NOTE may outlive borrowed value `y`\n             Box::new(f)\n         }\n     }"}, {"sha": "40ba34b26ede673a1c0fb4f88e34f3d8b68e627e", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -13,8 +13,11 @@ fn ignore<F>(_f: F) where F: for<'z> FnOnce(&'z isize) -> &'z isize {}\n fn nested() {\n     let y = 3;\n     ignore(\n-        |z| { //~ ERROR E0373\n+        |z| {\n+            //~^ ERROR E0373\n+            //~| NOTE may outlive borrowed value `y`\n             if false { &y } else { z }\n+            //~^ NOTE `y` is borrowed here\n         });\n }\n "}, {"sha": "555dd0f0c3945fd52c15de1690550b973f2cb1e7", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=444ff9fbfb1f2a8e6645f67684f8a9ad99b343d3", "patch": "@@ -20,23 +20,27 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `()`\n     //~| expected usize, found ()\n-    //~| ERROR expected usize for repeat count, found tuple [E0306]\n+    //~| ERROR expected `usize` for repeat count, found tuple [E0306]\n+    //~| expected `usize`\n     let c = [0; true];\n     //~^ ERROR mismatched types\n     //~| expected usize, found bool\n-    //~| ERROR expected usize for repeat count, found boolean [E0306]\n+    //~| ERROR expected `usize` for repeat count, found boolean [E0306]\n+    //~| expected `usize`\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `{float}`\n     //~| expected usize, found floating-point variable\n-    //~| ERROR expected usize for repeat count, found float [E0306]\n+    //~| ERROR expected `usize` for repeat count, found float [E0306]\n+    //~| expected `usize`\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `&'static str`\n     //~| expected usize, found &-ptr\n-    //~| ERROR expected usize for repeat count, found string literal [E0306]\n+    //~| ERROR expected `usize` for repeat count, found string literal [E0306]\n+    //~| expected `usize`\n     let f = [0; -4_isize];\n     //~^ ERROR constant evaluation error\n     //~| expected usize, found isize\n@@ -55,5 +59,6 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `main::G`\n     //~| expected usize, found struct `main::G`\n-    //~| ERROR expected usize for repeat count, found struct [E0306]\n+    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n+    //~| expected `usize`\n }"}]}