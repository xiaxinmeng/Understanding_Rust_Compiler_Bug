{"sha": "8f349be27815d43d462a32faeb270a22a68486b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMzQ5YmUyNzgxNWQ0M2Q0NjJhMzJmYWViMjcwYTIyYTY4NDg2YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T14:59:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T14:59:20Z"}, "message": "Auto merge of #82896 - Dylan-DPC:rollup-9setmme, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #82047 (bypass auto_da_alloc for metadata files)\n - #82415 (expand: Refactor module loading)\n - #82557 (Add natvis for Result, NonNull, CString, CStr, and Cow)\n - #82613 (Remove Item::kind, use tagged enum. Rename variants to match)\n - #82642 (Fix jemalloc usage on OSX)\n - #82682 (Implement built-in attribute macro `#[cfg_eval]` + some refactoring)\n - #82684 (Disable destination propagation on all mir-opt-levels)\n - #82755 (Refactor confirm_builtin_call, remove partial if)\n - #82857 (Edit ructc_ast_lowering docs)\n - #82862 (Generalize Write impl for Vec<u8> to Vec<u8, A>)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "37413af1348b05c9f8e65925c614ee369c16a3f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37413af1348b05c9f8e65925c614ee369c16a3f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f349be27815d43d462a32faeb270a22a68486b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f349be27815d43d462a32faeb270a22a68486b6", "html_url": "https://github.com/rust-lang/rust/commit/8f349be27815d43d462a32faeb270a22a68486b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f349be27815d43d462a32faeb270a22a68486b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6b0f626aad4ee9f2eaec4d5582f45620ccab80", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6b0f626aad4ee9f2eaec4d5582f45620ccab80", "html_url": "https://github.com/rust-lang/rust/commit/1d6b0f626aad4ee9f2eaec4d5582f45620ccab80"}, {"sha": "3b0a02a26b6db7a2f997cd32ca352e141ec795eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0a02a26b6db7a2f997cd32ca352e141ec795eb", "html_url": "https://github.com/rust-lang/rust/commit/3b0a02a26b6db7a2f997cd32ca352e141ec795eb"}], "stats": {"total": 2223, "additions": 1365, "deletions": 858}, "files": [{"sha": "328a220430601b11d9119cdf3baad16a3cf703f4", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -4568,6 +4568,7 @@ name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]"}, {"sha": "859028957db5607c42bdb250560ed570048d709e", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -24,6 +24,20 @@ fn main() {\n         static _F5: unsafe extern \"C\" fn(*mut c_void, usize) -> *mut c_void = jemalloc_sys::realloc;\n         #[used]\n         static _F6: unsafe extern \"C\" fn(*mut c_void) = jemalloc_sys::free;\n+\n+        // On OSX, jemalloc doesn't directly override malloc/free, but instead\n+        // registers itself with the allocator's zone APIs in a ctor. However,\n+        // the linker doesn't seem to consider ctors as \"used\" when statically\n+        // linking, so we need to explicitly depend on the function.\n+        #[cfg(target_os = \"macos\")]\n+        {\n+            extern \"C\" {\n+                fn _rjem_je_zone_register();\n+            }\n+\n+            #[used]\n+            static _F7: unsafe extern \"C\" fn() = _rjem_je_zone_register;\n+        }\n     }\n \n     rustc_driver::set_sigpipe_handler();"}, {"sha": "99196210e004b1ff2cbf71808d9991b0dce70fc8", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -915,16 +915,6 @@ impl Stmt {\n         }\n     }\n \n-    pub fn tokens_mut(&mut self) -> Option<&mut LazyTokenStream> {\n-        match self.kind {\n-            StmtKind::Local(ref mut local) => local.tokens.as_mut(),\n-            StmtKind::Item(ref mut item) => item.tokens.as_mut(),\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens.as_mut(),\n-            StmtKind::Empty => None,\n-            StmtKind::MacCall(ref mut mac) => mac.tokens.as_mut(),\n-        }\n-    }\n-\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,"}, {"sha": "a71f2ac9815012389303ed77e4284dd6db61ebc0", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -11,13 +11,7 @@ use super::{AttrVec, Attribute, Stmt, StmtKind};\n pub trait AstLike: Sized {\n     fn attrs(&self) -> &[Attribute];\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-    /// Called by `Parser::collect_tokens` to store the collected\n-    /// tokens inside an AST node\n-    fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {\n-        // This default impl makes this trait easier to implement\n-        // in tools like `rust-analyzer`\n-        panic!(\"`finalize_tokens` is not supported!\")\n-    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n }\n \n impl<T: AstLike + 'static> AstLike for P<T> {\n@@ -27,8 +21,8 @@ impl<T: AstLike + 'static> AstLike for P<T> {\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         (**self).visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        (**self).finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        (**self).tokens_mut()\n     }\n }\n \n@@ -42,12 +36,12 @@ fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n \n impl AstLike for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n+        match self {\n+            StmtKind::Local(local) => local.attrs(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n+            StmtKind::Item(item) => item.attrs(),\n             StmtKind::Empty => &[],\n-            StmtKind::MacCall(ref mac) => &*mac.attrs,\n+            StmtKind::MacCall(mac) => &mac.attrs,\n         }\n     }\n \n@@ -60,17 +54,14 @@ impl AstLike for StmtKind {\n             StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        let stmt_tokens = match self {\n-            StmtKind::Local(ref mut local) => &mut local.tokens,\n-            StmtKind::Item(ref mut item) => &mut item.tokens,\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n-            StmtKind::Empty => return,\n-            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n-        };\n-        if stmt_tokens.is_none() {\n-            *stmt_tokens = Some(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match self {\n+            StmtKind::Local(local) => &mut local.tokens,\n+            StmtKind::Item(item) => &mut item.tokens,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => &mut expr.tokens,\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => &mut mac.tokens,\n+        })\n     }\n }\n \n@@ -82,8 +73,8 @@ impl AstLike for Stmt {\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         self.kind.visit_attrs(f);\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        self.kind.finalize_tokens(tokens)\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.kind.tokens_mut()\n     }\n }\n \n@@ -92,17 +83,13 @@ impl AstLike for Attribute {\n         &[]\n     }\n     fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        match &mut self.kind {\n-            AttrKind::Normal(_, attr_tokens) => {\n-                if attr_tokens.is_none() {\n-                    *attr_tokens = Some(tokens);\n-                }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match &mut self.kind {\n+            AttrKind::Normal(_, tokens) => tokens,\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n             }\n-            AttrKind::DocComment(..) => {\n-                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n-            }\n-        }\n+        })\n     }\n }\n \n@@ -115,10 +102,8 @@ impl<T: AstLike> AstLike for Option<T> {\n             inner.visit_attrs(f);\n         }\n     }\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        if let Some(inner) = self {\n-            inner.finalize_tokens(tokens);\n-        }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.as_mut().and_then(|inner| inner.tokens_mut())\n     }\n }\n \n@@ -152,11 +137,8 @@ macro_rules! derive_has_tokens_and_attrs {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n         }\n     )* }\n@@ -173,7 +155,9 @@ macro_rules! derive_has_attrs_no_tokens {\n                 VecOrAttrVec::visit(&mut self.attrs, f)\n             }\n \n-            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                None\n+            }\n         }\n     )* }\n }\n@@ -185,14 +169,10 @@ macro_rules! derive_has_tokens_no_attrs {\n                 &[]\n             }\n \n-            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {\n-            }\n-\n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n+            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n \n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n             }\n         }\n     )* }"}, {"sha": "756caf18ec5ebb37b856ed34ad0836fc8f64e092", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -12,7 +12,7 @@\n //! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new ID using `next_id()`.\n+//! \"folding\" an existing one), create a new ID using `next_id()`.\n //!\n //! You must ensure that IDs are unique. That means that you should only use the\n //! ID from an AST node in a single HIR node (you can assume that AST node-IDs\n@@ -26,7 +26,7 @@\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n //! by lowering, it should have the same span as in the AST. Where HIR nodes are\n //! new it is probably best to give a span for the whole AST node being lowered.\n-//! All nodes should have real spans, don't use dummy spans. Tools are likely to\n+//! All nodes should have real spans; don't use dummy spans. Tools are likely to\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n@@ -95,7 +95,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// librustc_middle is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n-    /// Used to allocate HIR nodes\n+    /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n@@ -128,7 +128,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// What to do when we encounter either an \"anonymous lifetime\n+    /// What to do when we encounter an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n     /// `'_` lifetimes as well as fully elided cases where nothing is\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n@@ -238,11 +238,13 @@ enum ImplTraitContext<'b, 'a> {\n     OtherOpaqueTy {\n         /// Set of lifetimes that this opaque type can capture, if it uses\n         /// them. This includes lifetimes bound since we entered this context.\n-        /// For example, in\n+        /// For example:\n         ///\n+        /// ```\n         /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        /// ```\n         ///\n-        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// Here the inner opaque type captures `'a` because it uses it. It doesn't\n         /// need to capture `'b` because it already inherits the lifetime\n         /// parameter from `A`.\n         // FIXME(impl_trait): but `required_region_bounds` will ICE later\n@@ -2110,7 +2112,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n-    /// Transforms `-> T` into `Future<Output = T>`\n+    /// Transforms `-> T` into `Future<Output = T>`.\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,"}, {"sha": "eea4d785dee069943941709d79c5b34f468b073d", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,157 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, AstLike};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_expand::config::StripUnconfigured;\n+use rustc_expand::configure;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+crate fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    annotatable: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n+    cfg_eval(ecx, annotatable)\n+}\n+\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n+    let mut visitor = CfgEval {\n+        cfg: StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false },\n+    };\n+    let mut annotatable = visitor.configure_annotatable(annotatable);\n+    if visitor.cfg.modified {\n+        // Erase the tokens if cfg-stripping modified the item\n+        // This will cause us to synthesize fake tokens\n+        // when `nt_to_tokenstream` is called on this item.\n+        if let Some(tokens) = annotatable.tokens_mut() {\n+            *tokens = None;\n+        }\n+    }\n+    vec![annotatable]\n+}\n+\n+struct CfgEval<'a> {\n+    cfg: StripUnconfigured<'a>,\n+}\n+\n+impl CfgEval<'_> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n+\n+    fn configure_annotatable(&mut self, annotatable: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match annotatable {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n+}\n+\n+impl MutVisitor for CfgEval<'_> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        mut_visit::noop_visit_expr(&mut expr, self);\n+        Some(expr)\n+    }\n+\n+    fn flat_map_generic_param(\n+        &mut self,\n+        param: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        mut_visit::noop_flat_map_generic_param(configure!(self, param), self)\n+    }\n+\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        mut_visit::noop_flat_map_stmt(configure!(self, stmt), self)\n+    }\n+\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        mut_visit::noop_flat_map_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        foreign_item: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        mut_visit::noop_flat_map_foreign_item(configure!(self, foreign_item), self)\n+    }\n+\n+    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        mut_visit::noop_flat_map_arm(configure!(self, arm), self)\n+    }\n+\n+    fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n+        mut_visit::noop_flat_map_field(configure!(self, field), self)\n+    }\n+\n+    fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n+        mut_visit::noop_flat_map_field_pattern(configure!(self, fp), self)\n+    }\n+\n+    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        mut_visit::noop_flat_map_param(configure!(self, p), self)\n+    }\n+\n+    fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n+        mut_visit::noop_flat_map_struct_field(configure!(self, sf), self)\n+    }\n+\n+    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        mut_visit::noop_flat_map_variant(configure!(self, variant), self)\n+    }\n+}"}, {"sha": "0da2c1c1021f33224b1f79a2987a7e849830d531", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,7 +1,8 @@\n+use crate::cfg_eval::cfg_eval;\n+\n use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n-use rustc_expand::config::StripUnconfigured;\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_session::Session;\n@@ -51,26 +52,7 @@ impl MultiItemModifier for Expander {\n \n         // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n         match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n-            Ok(()) => {\n-                let mut visitor =\n-                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n-                let mut item = visitor.fully_configure(item);\n-                if visitor.modified {\n-                    // Erase the tokens if cfg-stripping modified the item\n-                    // This will cause us to synthesize fake tokens\n-                    // when `nt_to_tokenstream` is called on this item.\n-                    match &mut item {\n-                        Annotatable::Item(item) => item,\n-                        Annotatable::Stmt(stmt) => match &mut stmt.kind {\n-                            StmtKind::Item(item) => item,\n-                            _ => unreachable!(),\n-                        },\n-                        _ => unreachable!(),\n-                    }\n-                    .tokens = None;\n-                }\n-                ExpandResult::Ready(vec![item])\n-            }\n+            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "1017b23e5675a2d6513f2b167b24da12b6754117", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -24,6 +24,7 @@ mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n+mod cfg_eval;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -89,6 +90,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     register_attr! {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n+        cfg_eval: cfg_eval::expand,\n         derive: derive::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,"}, {"sha": "4aafcb2fb6dfea067783c635dacaad92d0d9f67e", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n-use rustc_expand::module::DirectoryOwnership;\n+use rustc_expand::module::DirOwnership;\n use rustc_parse::parser::{ForceCollect, Parser};\n use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n@@ -101,7 +101,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut file = match cx.resolve_path(file, sp) {\n+    let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -114,10 +114,9 @@ pub fn expand_include<'cx>(\n     // then the path of `bar.rs` should be relative to the directory of `file`.\n     // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n-    file.pop();\n-    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let mod_path = cx.current_expansion.module.mod_path.clone();\n-    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n+    let dir_path = file.parent().unwrap_or(&file).to_owned();\n+    cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n+    cx.current_expansion.dir_ownership = DirOwnership::Owned { relative: None };\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "666065efdfb43e331c663b13444028a184912555", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,11 +1,11 @@\n use crate::expand::{self, AstFragment, Invocation};\n-use crate::module::DirectoryOwnership;\n+use crate::module::DirOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, AstLike, Attribute, NodeId, PatKind};\n+use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -81,8 +81,22 @@ impl AstLike for Annotatable {\n         }\n     }\n \n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        panic!(\"Called finalize_tokens on an Annotatable: {:?}\", tokens);\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Annotatable::Item(item) => item.tokens_mut(),\n+            Annotatable::TraitItem(trait_item) => trait_item.tokens_mut(),\n+            Annotatable::ImplItem(impl_item) => impl_item.tokens_mut(),\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.tokens_mut(),\n+            Annotatable::Stmt(stmt) => stmt.tokens_mut(),\n+            Annotatable::Expr(expr) => expr.tokens_mut(),\n+            Annotatable::Arm(arm) => arm.tokens_mut(),\n+            Annotatable::Field(field) => field.tokens_mut(),\n+            Annotatable::FieldPat(fp) => fp.tokens_mut(),\n+            Annotatable::GenericParam(gp) => gp.tokens_mut(),\n+            Annotatable::Param(p) => p.tokens_mut(),\n+            Annotatable::StructField(sf) => sf.tokens_mut(),\n+            Annotatable::Variant(v) => v.tokens_mut(),\n+        }\n     }\n }\n \n@@ -900,21 +914,40 @@ pub trait ResolverExpand {\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct ModuleData {\n+    /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n     pub mod_path: Vec<Ident>,\n-    pub directory: PathBuf,\n+    /// Stack of paths to files loaded by out-of-line module items,\n+    /// used to detect and report recursive module inclusions.\n+    pub file_path_stack: Vec<PathBuf>,\n+    /// Directory to search child module files in,\n+    /// often (but not necessarily) the parent of the top file path on the `file_path_stack`.\n+    pub dir_path: PathBuf,\n+}\n+\n+impl ModuleData {\n+    pub fn with_dir_path(&self, dir_path: PathBuf) -> ModuleData {\n+        ModuleData {\n+            mod_path: self.mod_path.clone(),\n+            file_path_stack: self.file_path_stack.clone(),\n+            dir_path,\n+        }\n+    }\n }\n \n #[derive(Clone)]\n pub struct ExpansionData {\n     pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n-    pub directory_ownership: DirectoryOwnership,\n+    pub dir_ownership: DirOwnership,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n+type OnExternModLoaded<'a> =\n+    Option<&'a dyn Fn(Ident, Vec<Attribute>, Vec<P<Item>>, Span) -> (Vec<Attribute>, Vec<P<Item>>)>;\n+\n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n@@ -932,15 +965,15 @@ pub struct ExtCtxt<'a> {\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     ///\n     /// `Ident` is the module name.\n-    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+    pub(super) extern_mod_loaded: OnExternModLoaded<'a>,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n         sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n-        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+        extern_mod_loaded: OnExternModLoaded<'a>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,\n@@ -952,8 +985,8 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 id: ExpnId::root(),\n                 depth: 0,\n-                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n+                module: Default::default(),\n+                dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n             force_mode: false,"}, {"sha": "a23731cf309a41a7749ad778779e5c31a6013d56", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 6, "deletions": 169, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,8 +1,5 @@\n //! Conditional compilation stripping.\n \n-use crate::base::Annotatable;\n-\n-use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n@@ -22,8 +19,6 @@ use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use smallvec::SmallVec;\n-\n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n@@ -272,7 +267,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -387,7 +382,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n+    fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(self.sess, attr) {\n                 return true;\n@@ -427,16 +422,8 @@ impl<'a> StripUnconfigured<'a> {\n         })\n     }\n \n-    /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n-        // flag the offending attributes\n-        for attr in attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n-        }\n-    }\n-\n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,\n@@ -453,49 +440,10 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n-        items.flat_map_in_place(|item| self.configure(item));\n-    }\n-\n-    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n-        match vdata {\n-            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) => {\n-                fields.flat_map_in_place(|field| self.configure(field))\n-            }\n-            ast::VariantData::Unit(_) => {}\n-        }\n-    }\n-\n-    pub fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        match item {\n-            ast::ItemKind::Struct(def, _generics) | ast::ItemKind::Union(def, _generics) => {\n-                self.configure_variant_data(def)\n-            }\n-            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n-                variants.flat_map_in_place(|variant| self.configure(variant));\n-                for variant in variants {\n-                    self.configure_variant_data(&mut variant.data);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    pub fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n-        match expr_kind {\n-            ast::ExprKind::Match(_m, arms) => {\n-                arms.flat_map_in_place(|arm| self.configure(arm));\n-            }\n-            ast::ExprKind::Struct(_path, fields, _base) => {\n-                fields.flat_map_in_place(|field| self.configure(field));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.visit_expr_attrs(expr.attrs());\n+        for attr in expr.attrs.iter() {\n+            self.maybe_emit_expr_attr_err(attr);\n+        }\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -511,117 +459,6 @@ impl<'a> StripUnconfigured<'a> {\n \n         self.process_cfg_attrs(expr)\n     }\n-\n-    pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n-            fields.flat_map_in_place(|field| self.configure(field));\n-        }\n-    }\n-\n-    pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n-        fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n-    }\n-\n-    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                self.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => {\n-                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> MutVisitor for StripUnconfigured<'a> {\n-    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        self.configure_foreign_mod(foreign_mod);\n-        noop_visit_foreign_mod(foreign_mod, self);\n-    }\n-\n-    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        self.configure_item_kind(item);\n-        noop_visit_item_kind(item, self);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(expr, self);\n-    }\n-\n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(&mut expr, self);\n-        Some(expr)\n-    }\n-\n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        noop_flat_map_generic_param(configure!(self, param), self)\n-    }\n-\n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        noop_flat_map_stmt(configure!(self, stmt), self)\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        noop_flat_map_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        self.configure_pat(pat);\n-        noop_visit_pat(pat, self)\n-    }\n-\n-    fn visit_fn_decl(&mut self, mut fn_decl: &mut P<ast::FnDecl>) {\n-        self.configure_fn_decl(&mut fn_decl);\n-        noop_visit_fn_decl(fn_decl, self);\n-    }\n }\n \n fn is_cfg(sess: &Session, attr: &Attribute) -> bool {"}, {"sha": "dd2eaa0f3d53c5db05197b8f5512e51b941ec5c3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -3,7 +3,7 @@ use crate::config::StripUnconfigured;\n use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n-use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n+use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n use rustc_ast as ast;\n@@ -355,16 +355,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // FIXME: Avoid visiting the crate as a `Mod` item,\n     // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let mut module = ModuleData {\n-            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(name) => name.into_local_path(),\n-                other => PathBuf::from(other.to_string()),\n-            },\n+        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n+            FileName::Real(name) => name.into_local_path(),\n+            other => PathBuf::from(other.to_string()),\n         };\n-        module.directory.pop();\n-        self.cx.root_path = module.directory.clone();\n-        self.cx.current_expansion.module = Rc::new(module);\n+        let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n+        self.cx.root_path = dir_path.clone();\n+        self.cx.current_expansion.module = Rc::new(ModuleData {\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n+            file_path_stack: vec![file_path],\n+            dir_path,\n+        });\n \n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n@@ -1245,10 +1246,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &mut P<Block>) {\n-        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n-        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n         noop_visit_block(block, self);\n-        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -1276,63 +1279,76 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n-                let sess = &self.cx.sess.parse_sess;\n-                let orig_ownership = self.cx.current_expansion.directory_ownership;\n-                let mut module = (*self.cx.current_expansion.module).clone();\n-\n-                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n-                let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = match mod_kind {\n-                    ModKind::Loaded(_, Inline::Yes, _) => {\n+                let (file_path, dir_path, dir_ownership) = match mod_kind {\n+                    ModKind::Loaded(_, inline, _) => {\n                         // Inline `mod foo { ... }`, but we still need to push directories.\n+                        assert!(\n+                            *inline == Inline::Yes,\n+                            \"`mod` item is loaded from a file for the second time\"\n+                        );\n+                        let (dir_path, dir_ownership) = mod_dir_path(\n+                            &self.cx.sess,\n+                            ident,\n+                            &attrs,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                        );\n                         item.attrs = attrs;\n-                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                    }\n-                    ModKind::Loaded(_, Inline::No, _) => {\n-                        panic!(\"`mod` item is loaded from a file for the second time\")\n+                        (None, dir_path, dir_ownership)\n                     }\n                     ModKind::Unloaded => {\n                         // We have an outline `mod foo;` so we need to parse the file.\n-                        let (items, inner_span, dir) =\n-                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+                        let old_attrs_len = attrs.len();\n+                        let ParsedExternalMod {\n+                            mut items,\n+                            inner_span,\n+                            file_path,\n+                            dir_path,\n+                            dir_ownership,\n+                        } = parse_external_mod(\n+                            &self.cx.sess,\n+                            ident,\n+                            span,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                            &mut attrs,\n+                        );\n \n-                        let krate =\n-                            ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n                         if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                            extern_mod_loaded(&krate, ident);\n+                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n                         }\n \n-                        *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n-                        item.attrs = krate.attrs;\n-                        // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                        item = match self.configure(item) {\n-                            Some(node) => node,\n-                            None => {\n-                                if *pushed {\n-                                    sess.included_mod_stack.borrow_mut().pop();\n-                                }\n-                                return Default::default();\n-                            }\n-                        };\n-                        dir\n+                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                        item.attrs = attrs;\n+                        if item.attrs.len() > old_attrs_len {\n+                            // If we loaded an out-of-line module and added some inner attributes,\n+                            // then we need to re-configure it.\n+                            // FIXME: Attributes also need to be recollected\n+                            // for resolution and expansion.\n+                            item = configure!(self, item);\n+                        }\n+                        (Some(file_path), dir_path, dir_ownership)\n                     }\n                 };\n \n                 // Set the module info before we flat map.\n-                self.cx.current_expansion.directory_ownership = ownership;\n-                module.directory = path;\n+                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n                 module.mod_path.push(ident);\n+                if let Some(file_path) = file_path {\n+                    module.file_path_stack.push(file_path);\n+                }\n+\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+                let orig_dir_ownership =\n+                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n \n                 let result = noop_flat_map_item(item, self);\n \n                 // Restore the module info.\n+                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_ownership;\n-                if *pushed {\n-                    sess.included_mod_stack.borrow_mut().pop();\n-                }\n+\n                 result\n             }\n             _ => {"}, {"sha": "1a93975533de03bbafc3c72e1c2fef3c3e55808b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,7 @@\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(destructuring_assignment)]\n #![feature(or_patterns)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "2ec656d4895e7f0d960741bdf49cc6c934dc9a51", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 159, "deletions": 207, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,232 +1,155 @@\n+use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n use rustc_ast::{token, Attribute, Item};\n-use rustc_errors::{struct_span_err, PResult};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n-use rustc_span::source_map::{FileName, Span};\n use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n \n use std::path::{self, Path, PathBuf};\n \n-#[derive(Clone)]\n-pub struct Directory {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n-}\n-\n #[derive(Copy, Clone)]\n-pub enum DirectoryOwnership {\n+pub enum DirOwnership {\n     Owned {\n         // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n         relative: Option<Ident>,\n     },\n     UnownedViaBlock,\n-    UnownedViaMod,\n }\n \n-/// Information about the path to a module.\n // Public for rustfmt usage.\n-pub struct ModulePath<'a> {\n-    name: String,\n-    path_exists: bool,\n-    pub result: PResult<'a, ModulePathSuccess>,\n+pub struct ModulePathSuccess {\n+    pub file_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n }\n \n-// Public for rustfmt usage.\n-pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n+crate struct ParsedExternalMod {\n+    pub items: Vec<P<Item>>,\n+    pub inner_span: Span,\n+    pub file_path: PathBuf,\n+    pub dir_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n+}\n+\n+pub enum ModError<'a> {\n+    CircularInclusion(Vec<PathBuf>),\n+    ModInBlock(Option<Ident>),\n+    FileNotFound(Ident, PathBuf),\n+    MultipleCandidates(Ident, String, String),\n+    ParserError(DiagnosticBuilder<'a>),\n }\n \n crate fn parse_external_mod(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     span: Span, // The span to blame on errors.\n-    Directory { mut ownership, path }: Directory,\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n     attrs: &mut Vec<Attribute>,\n-    pop_mod_stack: &mut bool,\n-) -> (Vec<P<Item>>, Span, Directory) {\n+) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n-    let result: PResult<'_, _> = try {\n+    let result: Result<_, ModError<'_>> = try {\n         // Extract the file path and the new ownership.\n-        let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n-        ownership = mp.ownership;\n+        let mp = mod_file_path(sess, ident, &attrs, &module.dir_path, dir_ownership)?;\n+        dir_ownership = mp.dir_ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n-        included_mod_stack.push(mp.path.clone());\n-        *pop_mod_stack = true; // We have pushed, so notify caller.\n-        drop(included_mod_stack);\n+        if let Some(pos) = module.file_path_stack.iter().position(|p| p == &mp.file_path) {\n+            Err(ModError::CircularInclusion(module.file_path_stack[pos..].to_vec()))?;\n+        }\n \n         // Actually parse the external file as a module.\n-        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n+        let (mut inner_attrs, items, inner_span) =\n+            parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n         attrs.append(&mut inner_attrs);\n-        (items, inner_span)\n+        (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (items, inner_span, file_path) =\n+        result.map_err(|err| err.report(sess, span)).unwrap_or_default();\n \n-    // Extract the directory path for submodules of  the module.\n-    let path = sess.source_map().span_to_unmapped_path(inner_span);\n-    let mut path = match path {\n-        FileName::Real(name) => name.into_local_path(),\n-        other => PathBuf::from(other.to_string()),\n-    };\n-    path.pop();\n+    // Extract the directory path for submodules of the module.\n+    let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n \n-    (items, inner_span, Directory { ownership, path })\n+    ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership }\n }\n \n-fn error_on_circular_module<'a>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path: &Path,\n-    included_mod_stack: &[PathBuf],\n-) -> PResult<'a, ()> {\n-    if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n-        let mut err = String::from(\"circular modules: \");\n-        for p in &included_mod_stack[i..] {\n-            err.push_str(&p.to_string_lossy());\n-            err.push_str(\" -> \");\n-        }\n-        err.push_str(&path.to_string_lossy());\n-        return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n-    }\n-    Ok(())\n-}\n-\n-crate fn push_directory(\n+crate fn mod_dir_path(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     attrs: &[Attribute],\n-    Directory { mut ownership, mut path }: Directory,\n-) -> Directory {\n-    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n-        path.push(&*filename.as_str());\n-        ownership = DirectoryOwnership::Owned { relative: None };\n-    } else {\n-        // We have to push on the current module name in the case of relative\n-        // paths in order to ensure that any additional module paths from inline\n-        // `mod x { ... }` come after the relative extension.\n-        //\n-        // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n-        // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n-            if let Some(ident) = relative.take() {\n-                // Remove the relative offset.\n-                path.push(&*ident.as_str());\n-            }\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n+) -> (PathBuf, DirOwnership) {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, &module.dir_path) {\n+        // For inline modules file path from `#[path]` is actually the directory path\n+        // for historical reasons, so we don't pop the last segment here.\n+        return (file_path, DirOwnership::Owned { relative: None });\n+    }\n+\n+    // We have to push on the current module name in the case of relative\n+    // paths in order to ensure that any additional module paths from inline\n+    // `mod x { ... }` come after the relative extension.\n+    //\n+    // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+    // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+    let mut dir_path = module.dir_path.clone();\n+    if let DirOwnership::Owned { relative } = &mut dir_ownership {\n+        if let Some(ident) = relative.take() {\n+            // Remove the relative offset.\n+            dir_path.push(&*ident.as_str());\n         }\n-        path.push(&*id.as_str());\n     }\n-    Directory { ownership, path }\n+    dir_path.push(&*ident.as_str());\n+\n+    (dir_path, dir_ownership)\n }\n \n-fn submod_path<'a>(\n+fn mod_file_path<'a>(\n     sess: &'a Session,\n-    id: Ident,\n-    span: Span,\n+    ident: Ident,\n     attrs: &[Attribute],\n-    ownership: DirectoryOwnership,\n     dir_path: &Path,\n-) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n-        let ownership = match path.file_name().and_then(|s| s.to_str()) {\n-            // All `#[path]` files are treated as though they are a `mod.rs` file.\n-            // This means that `mod foo;` declarations inside `#[path]`-included\n-            // files are siblings,\n-            //\n-            // Note that this will produce weirdness when a file named `foo.rs` is\n-            // `#[path]` included and contains a `mod foo;` declaration.\n-            // If you encounter this, it's your own darn fault :P\n-            Some(_) => DirectoryOwnership::Owned { relative: None },\n-            _ => DirectoryOwnership::UnownedViaMod,\n-        };\n-        return Ok(ModulePathSuccess { ownership, path });\n+    dir_ownership: DirOwnership,\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, dir_path) {\n+        // All `#[path]` files are treated as though they are a `mod.rs` file.\n+        // This means that `mod foo;` declarations inside `#[path]`-included\n+        // files are siblings,\n+        //\n+        // Note that this will produce weirdness when a file named `foo.rs` is\n+        // `#[path]` included and contains a `mod foo;` declaration.\n+        // If you encounter this, it's your own darn fault :P\n+        let dir_ownership = DirOwnership::Owned { relative: None };\n+        return Ok(ModulePathSuccess { file_path, dir_ownership });\n     }\n \n-    let relative = match ownership {\n-        DirectoryOwnership::Owned { relative } => relative,\n-        DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n+    let relative = match dir_ownership {\n+        DirOwnership::Owned { relative } => relative,\n+        DirOwnership::UnownedViaBlock => None,\n     };\n-    let ModulePath { path_exists, name, result } =\n-        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n-    match ownership {\n-        DirectoryOwnership::Owned { .. } => Ok(result?),\n-        DirectoryOwnership::UnownedViaBlock => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n-        }\n-        DirectoryOwnership::UnownedViaMod => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_cannot_declare_mod_here(&sess.parse_sess, span, path_exists, &name)\n-        }\n+    let result = default_submod_path(&sess.parse_sess, ident, relative, dir_path);\n+    match dir_ownership {\n+        DirOwnership::Owned { .. } => result,\n+        DirOwnership::UnownedViaBlock => Err(ModError::ModInBlock(match result {\n+            Ok(_) | Err(ModError::MultipleCandidates(..)) => Some(ident),\n+            _ => None,\n+        })),\n     }\n }\n \n-fn error_decl_mod_in_block<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n-    let mut err = sess.span_diagnostic.struct_span_err(span, msg);\n-    if path_exists {\n-        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n-        err.span_note(span, &msg);\n-    }\n-    Err(err)\n-}\n-\n-fn error_cannot_declare_mod_here<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let mut err =\n-        sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n-    if !span.is_dummy() {\n-        if let FileName::Real(src_name) = sess.source_map().span_to_filename(span) {\n-            let src_path = src_name.into_local_path();\n-            if let Some(stem) = src_path.file_stem() {\n-                let mut dest_path = src_path.clone();\n-                dest_path.set_file_name(stem);\n-                dest_path.push(\"mod.rs\");\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"maybe move this module `{}` to its own directory via `{}`\",\n-                        src_path.display(),\n-                        dest_path.display()\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-    if path_exists {\n-        err.span_note(\n-            span,\n-            &format!(\"... or maybe `use` the module `{}` instead of possibly redeclaring it\", name),\n-        );\n-    }\n-    Err(err)\n-}\n-\n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n-pub(super) fn submod_path_from_attr(\n+fn mod_file_path_from_attr(\n     sess: &Session,\n     attrs: &[Attribute],\n     dir_path: &Path,\n ) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n-    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?;\n-    let path_string = path_string.as_str();\n+    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?.as_str();\n \n     // On windows, the base path might have the form\n     // `\\\\?\\foo\\bar` in which case it does not tolerate\n@@ -242,15 +165,14 @@ pub(super) fn submod_path_from_attr(\n // Public for rustfmt usage.\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: Ident,\n-    span: Span,\n+    ident: Ident,\n     relative: Option<Ident>,\n     dir_path: &Path,\n-) -> ModulePath<'a> {\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n     // If we're in a foo.rs file instead of a mod.rs file,\n     // we need to look for submodules in\n-    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-    // `./<id>.rs` and `./<id>/mod.rs`.\n+    // `./foo/<ident>.rs` and `./foo/<ident>/mod.rs` rather than\n+    // `./<ident>.rs` and `./<ident>/mod.rs`.\n     let relative_prefix_string;\n     let relative_prefix = if let Some(ident) = relative {\n         relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n@@ -259,7 +181,7 @@ pub fn default_submod_path<'a>(\n         \"\"\n     };\n \n-    let mod_name = id.name.to_string();\n+    let mod_name = ident.name.to_string();\n     let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n     let secondary_path_str =\n         format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n@@ -268,44 +190,74 @@ pub fn default_submod_path<'a>(\n     let default_exists = sess.source_map().file_exists(&default_path);\n     let secondary_exists = sess.source_map().file_exists(&secondary_path);\n \n-    let result = match (default_exists, secondary_exists) {\n+    match (default_exists, secondary_exists) {\n         (true, false) => Ok(ModulePathSuccess {\n-            path: default_path,\n-            ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+            file_path: default_path,\n+            dir_ownership: DirOwnership::Owned { relative: Some(ident) },\n         }),\n         (false, true) => Ok(ModulePathSuccess {\n-            path: secondary_path,\n-            ownership: DirectoryOwnership::Owned { relative: None },\n+            file_path: secondary_path,\n+            dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n-        (false, false) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0583,\n-                \"file not found for module `{}`\",\n-                mod_name,\n-            );\n-            err.help(&format!(\n-                \"to create the module `{}`, create file \\\"{}\\\"\",\n-                mod_name,\n-                default_path.display(),\n-            ));\n-            Err(err)\n-        }\n+        (false, false) => Err(ModError::FileNotFound(ident, default_path)),\n         (true, true) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0761,\n-                \"file for module `{}` found at both {} and {}\",\n-                mod_name,\n-                default_path_str,\n-                secondary_path_str,\n-            );\n-            err.help(\"delete or rename one of them to remove the ambiguity\");\n-            Err(err)\n+            Err(ModError::MultipleCandidates(ident, default_path_str, secondary_path_str))\n         }\n-    };\n+    }\n+}\n \n-    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+impl ModError<'_> {\n+    fn report(self, sess: &Session, span: Span) {\n+        let diag = &sess.parse_sess.span_diagnostic;\n+        match self {\n+            ModError::CircularInclusion(file_paths) => {\n+                let mut msg = String::from(\"circular modules: \");\n+                for file_path in &file_paths {\n+                    msg.push_str(&file_path.display().to_string());\n+                    msg.push_str(\" -> \");\n+                }\n+                msg.push_str(&file_paths[0].display().to_string());\n+                diag.struct_span_err(span, &msg)\n+            }\n+            ModError::ModInBlock(ident) => {\n+                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n+                let mut err = diag.struct_span_err(span, msg);\n+                if let Some(ident) = ident {\n+                    let note =\n+                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n+                    err.span_note(span, &note);\n+                }\n+                err\n+            }\n+            ModError::FileNotFound(ident, default_path) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    ident,\n+                );\n+                err.help(&format!(\n+                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    ident,\n+                    default_path.display(),\n+                ));\n+                err\n+            }\n+            ModError::MultipleCandidates(ident, default_path_short, secondary_path_short) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0761,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    ident,\n+                    default_path_short,\n+                    secondary_path_short,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            ModError::ParserError(err) => err,\n+        }.emit()\n+    }\n }"}, {"sha": "94be7a03a932b854e099f165037032b3fc4a4800", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -302,8 +302,10 @@ fn configure_and_expand_inner<'a>(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let extern_mod_loaded = |k: &ast::Crate, ident: Ident| {\n-            pre_expansion_lint(sess, lint_store, k, &*ident.name.as_str())\n+        let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n+            let krate = ast::Crate { attrs, items, span, proc_macros: vec![] };\n+            pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n+            (krate.attrs, krate.items)\n         };\n         let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n@@ -988,7 +990,7 @@ fn encode_and_write_metadata(\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n         let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n-        if let Err(e) = fs::rename(&metadata_filename, &out_filename) {\n+        if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }\n         if tcx.sess.opts.json_artifact_notifications {"}, {"sha": "0a30eda1ec4069404467ab5d38de93dd7e8318a7", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -694,6 +694,24 @@ pub fn build_output_filenames(\n     }\n }\n \n+#[cfg(not(target_os = \"linux\"))]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    std::fs::rename(src, dst)\n+}\n+\n+/// This function attempts to bypass the auto_da_alloc heuristic implemented by some filesystems\n+/// such as btrfs and ext4. When renaming over a file that already exists then they will \"helpfully\"\n+/// write back the source file before committing the rename in case a developer forgot some of\n+/// the fsyncs in the open/write/fsync(file)/rename/fsync(dir) dance for atomic file updates.\n+///\n+/// To avoid triggering this heuristic we delete the destination first, if it exists.\n+/// The cost of an extra syscall is much lower than getting descheduled for the sync IO.\n+#[cfg(target_os = \"linux\")]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    let _ = std::fs::remove_file(dst);\n+    std::fs::rename(src, dst)\n+}\n+\n // Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n //\n // FIXME: Currently the `everybody_loops` transformation is not applied to:"}, {"sha": "f7568e1d929ddd2b9807bd5687f6c3838efac9dd", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -127,6 +127,11 @@ pub struct DestinationPropagation;\n \n impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        //  FIXME(#79191, #82678)\n+        if !tcx.sess.opts.debugging_opts.unsound_mir_opts {\n+            return;\n+        }\n+\n         // Only run at mir-opt-level=3 or higher for now (we don't fix up debuginfo and remove\n         // storage statements at the moment).\n         if tcx.sess.mir_opt_level() < 3 {"}, {"sha": "7512f46988c918cd27389694a279b41e03663502", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -72,6 +72,10 @@ impl<'a> Parser<'a> {\n         let cursor_snapshot = self.token_cursor.clone();\n \n         let (mut ret, trailing_token) = f(self, attrs.attrs)?;\n+        let tokens = match ret.tokens_mut() {\n+            Some(tokens) if tokens.is_none() => tokens,\n+            _ => return Ok(ret),\n+        };\n \n         // Produces a `TokenStream` on-demand. Using `cursor_snapshot`\n         // and `num_calls`, we can reconstruct the `TokenStream` seen\n@@ -128,14 +132,14 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let lazy_impl = LazyTokenStreamImpl {\n+        *tokens = Some(LazyTokenStream::new(LazyTokenStreamImpl {\n             start_token,\n             num_calls,\n             cursor_snapshot,\n             desugar_doc_comments: self.desugar_doc_comments,\n             append_unglued_token: self.token_cursor.append_unglued_token.clone(),\n-        };\n-        ret.finalize_tokens(LazyTokenStream::new(lazy_impl));\n+        }));\n+\n         Ok(ret)\n     }\n }"}, {"sha": "592773bfe1b440920df5b8bcceb5838994453f32", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -13,7 +13,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{MultiSpan, Span, Symbol};\n \n-use std::path::PathBuf;\n use std::str;\n \n /// The set of keys (and, optionally, values) that define the compilation\n@@ -122,8 +121,6 @@ pub struct ParseSess {\n     pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n-    /// Used to determine and report recursive module inclusions.\n-    pub included_mod_stack: Lock<Vec<PathBuf>>,\n     source_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n     /// Contains the spans of block expressions that could have been incomplete based on the\n@@ -157,7 +154,6 @@ impl ParseSess {\n             edition: ExpnId::root().expn_data().edition,\n             missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n-            included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),"}, {"sha": "507eb1e1cbe8912129129d5b9717c4212ef00f17", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -344,6 +344,7 @@ symbols! {\n         cfg_attr,\n         cfg_attr_multi,\n         cfg_doctest,\n+        cfg_eval,\n         cfg_panic,\n         cfg_sanitize,\n         cfg_target_feature,"}, {"sha": "a29f55180098a27bba6426c34b3510fb03209b48", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -77,11 +77,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let output = match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n-                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n+                self.confirm_builtin_call(\n+                    call_expr,\n+                    callee_expr,\n+                    original_callee_ty,\n+                    arg_exprs,\n+                    expected,\n+                )\n             }\n \n             Some(CallStep::Builtin(callee_ty)) => {\n-                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n+                self.confirm_builtin_call(call_expr, callee_expr, callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::DeferredClosure(fn_sig)) => {\n@@ -281,6 +287,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn confirm_builtin_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n         callee_ty: Ty<'tcx>,\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n@@ -299,110 +306,104 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let hir::ExprKind::Call(callee, _) = call_expr.kind {\n-                    let mut err = type_error_struct!(\n-                        self.tcx.sess,\n-                        callee.span,\n-                        callee_ty,\n-                        E0618,\n-                        \"expected function, found {}\",\n-                        match unit_variant {\n-                            Some(ref path) => format!(\"enum variant `{}`\", path),\n-                            None => format!(\"`{}`\", callee_ty),\n-                        }\n-                    );\n+                let mut err = type_error_struct!(\n+                    self.tcx.sess,\n+                    callee_expr.span,\n+                    callee_ty,\n+                    E0618,\n+                    \"expected function, found {}\",\n+                    match unit_variant {\n+                        Some(ref path) => format!(\"enum variant `{}`\", path),\n+                        None => format!(\"`{}`\", callee_ty),\n+                    }\n+                );\n \n-                    self.identify_bad_closure_def_and_call(\n-                        &mut err,\n-                        call_expr.hir_id,\n-                        &callee.kind,\n-                        callee.span,\n-                    );\n+                self.identify_bad_closure_def_and_call(\n+                    &mut err,\n+                    call_expr.hir_id,\n+                    &callee_expr.kind,\n+                    callee_expr.span,\n+                );\n \n-                    if let Some(ref path) = unit_variant {\n-                        err.span_suggestion(\n-                            call_expr.span,\n-                            &format!(\n-                                \"`{}` is a unit variant, you need to write it \\\n+                if let Some(ref path) = unit_variant {\n+                    err.span_suggestion(\n+                        call_expr.span,\n+                        &format!(\n+                            \"`{}` is a unit variant, you need to write it \\\n                                  without the parenthesis\",\n-                                path\n-                            ),\n-                            path.to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                            path\n+                        ),\n+                        path.to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n \n-                    let mut inner_callee_path = None;\n-                    let def = match callee.kind {\n-                        hir::ExprKind::Path(ref qpath) => {\n-                            self.typeck_results.borrow().qpath_res(qpath, callee.hir_id)\n+                let mut inner_callee_path = None;\n+                let def = match callee_expr.kind {\n+                    hir::ExprKind::Path(ref qpath) => {\n+                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+                    }\n+                    hir::ExprKind::Call(ref inner_callee, _) => {\n+                        // If the call spans more than one line and the callee kind is\n+                        // itself another `ExprCall`, that's a clue that we might just be\n+                        // missing a semicolon (Issue #51055)\n+                        let call_is_multiline =\n+                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                        if call_is_multiline {\n+                            err.span_suggestion(\n+                                callee_expr.span.shrink_to_hi(),\n+                                \"consider using a semicolon here\",\n+                                \";\".to_owned(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n-                        hir::ExprKind::Call(ref inner_callee, _) => {\n-                            // If the call spans more than one line and the callee kind is\n-                            // itself another `ExprCall`, that's a clue that we might just be\n-                            // missing a semicolon (Issue #51055)\n-                            let call_is_multiline =\n-                                self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                            if call_is_multiline {\n-                                err.span_suggestion(\n-                                    callee.span.shrink_to_hi(),\n-                                    \"consider using a semicolon here\",\n-                                    \";\".to_owned(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                                inner_callee_path = Some(inner_qpath);\n-                                self.typeck_results\n-                                    .borrow()\n-                                    .qpath_res(inner_qpath, inner_callee.hir_id)\n-                            } else {\n-                                Res::Err\n-                            }\n+                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                            inner_callee_path = Some(inner_qpath);\n+                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                        } else {\n+                            Res::Err\n                         }\n-                        _ => Res::Err,\n-                    };\n-\n-                    err.span_label(call_expr.span, \"call expression requires function\");\n-\n-                    if let Some(span) = self.tcx.hir().res_span(def) {\n-                        let callee_ty = callee_ty.to_string();\n-                        let label = match (unit_variant, inner_callee_path) {\n-                            (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n-                            (_, Some(hir::QPath::Resolved(_, path))) => {\n-                                self.tcx.sess.source_map().span_to_snippet(path.span).ok().map(\n-                                    |p| format!(\"`{}` defined here returns `{}`\", p, callee_ty),\n-                                )\n-                            }\n-                            _ => {\n-                                match def {\n-                                    // Emit a different diagnostic for local variables, as they are not\n-                                    // type definitions themselves, but rather variables *of* that type.\n-                                    Res::Local(hir_id) => Some(format!(\n-                                        \"`{}` has type `{}`\",\n-                                        self.tcx.hir().name(hir_id),\n-                                        callee_ty\n-                                    )),\n-                                    Res::Def(kind, def_id)\n-                                        if kind.ns() == Some(Namespace::ValueNS) =>\n-                                    {\n-                                        Some(format!(\n-                                            \"`{}` defined here\",\n-                                            self.tcx.def_path_str(def_id),\n-                                        ))\n-                                    }\n-                                    _ => Some(format!(\"`{}` defined here\", callee_ty)),\n+                    }\n+                    _ => Res::Err,\n+                };\n+\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+\n+                if let Some(span) = self.tcx.hir().res_span(def) {\n+                    let callee_ty = callee_ty.to_string();\n+                    let label = match (unit_variant, inner_callee_path) {\n+                        (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                        (_, Some(hir::QPath::Resolved(_, path))) => self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(path.span)\n+                            .ok()\n+                            .map(|p| format!(\"`{}` defined here returns `{}`\", p, callee_ty)),\n+                        _ => {\n+                            match def {\n+                                // Emit a different diagnostic for local variables, as they are not\n+                                // type definitions themselves, but rather variables *of* that type.\n+                                Res::Local(hir_id) => Some(format!(\n+                                    \"`{}` has type `{}`\",\n+                                    self.tcx.hir().name(hir_id),\n+                                    callee_ty\n+                                )),\n+                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                                    Some(format!(\n+                                        \"`{}` defined here\",\n+                                        self.tcx.def_path_str(def_id),\n+                                    ))\n                                 }\n+                                _ => Some(format!(\"`{}` defined here\", callee_ty)),\n                             }\n-                        };\n-                        if let Some(label) = label {\n-                            err.span_label(span, label);\n                         }\n+                    };\n+                    if let Some(label) = label {\n+                        err.span_label(span, label);\n                     }\n-                    err.emit();\n-                } else {\n-                    bug!(\"call_expr.kind should be an ExprKind::Call, got {:?}\", call_expr.kind);\n                 }\n+                err.emit();\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to"}, {"sha": "28fed9b8a14cd3886b1bfc75ac0ec2f5fcd2bed8", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1452,6 +1452,18 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Expands all `#[cfg]` and `#[cfg_attr]` attributes in the code fragment it's applied to.\n+    #[cfg(not(bootstrap))]\n+    #[unstable(\n+        feature = \"cfg_eval\",\n+        issue = \"82679\",\n+        reason = \"`cfg_eval` is a recently implemented feature\"\n+    )]\n+    #[rustc_builtin_macro]\n+    pub macro cfg_eval($($tt:tt)*) {\n+        /* compiler built-in */\n+    }\n+\n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5e8a8d252a23883c32ae7f72a0af520922c26e90", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -81,3 +81,12 @@ pub use crate::macros::builtin::derive;\n )]\n #[doc(no_inline)]\n pub use crate::macros::builtin::cfg_accessible;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_eval\",\n+    issue = \"82679\",\n+    reason = \"`cfg_eval` is a recently implemented feature\"\n+)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::cfg_eval;"}, {"sha": "9870cfc4c95c361a24d8f3d0e700b6c9fa42a670", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,6 +1,7 @@\n #[cfg(test)]\n mod tests;\n \n+use crate::alloc::Allocator;\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n@@ -357,7 +358,7 @@ impl Write for &mut [u8] {\n /// Write is implemented for `Vec<u8>` by appending to the vector.\n /// The vector will grow as needed.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Write for Vec<u8> {\n+impl<A: Allocator> Write for Vec<u8, A> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.extend_from_slice(buf);"}, {"sha": "acdf7550fe71d358adbc7c0b961cb8bcb1ee0c7a", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -234,6 +234,7 @@\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]\n+#![cfg_attr(not(bootstrap), feature(cfg_eval))]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]"}, {"sha": "7181dc6e710e4e33d74fde17bb2e76d0bc172743", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -67,6 +67,15 @@ pub use core::prelude::v1::derive;\n #[doc(hidden)]\n pub use core::prelude::v1::cfg_accessible;\n \n+#[cfg(not(bootstrap))]\n+#[unstable(\n+    feature = \"cfg_eval\",\n+    issue = \"82679\",\n+    reason = \"`cfg_eval` is a recently implemented feature\"\n+)]\n+#[doc(hidden)]\n+pub use core::prelude::v1::cfg_eval;\n+\n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports"}, {"sha": "22a1eb63702357d5ceb0aab2c459ebdd5feba64b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -397,6 +397,7 @@ impl<'a> Builder<'a> {\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n+                test::CrateRustdocJsonTypes,\n                 test::Linkcheck,\n                 test::TierCheck,\n                 test::Cargotest,"}, {"sha": "03ae684e23fedb0a23d765824769f5484b24f93b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1922,6 +1922,77 @@ impl Step for CrateRustdoc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateRustdocJsonTypes {\n+    host: TargetSelection,\n+    test_kind: TestKind,\n+}\n+\n+impl Step for CrateRustdocJsonTypes {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/rustdoc-json-types\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        let builder = run.builder;\n+\n+        let test_kind = builder.kind.into();\n+\n+        builder.ensure(CrateRustdocJsonTypes { host: run.target, test_kind });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let test_kind = self.test_kind;\n+        let target = self.host;\n+\n+        // Use the previous stage compiler to reuse the artifacts that are\n+        // created when running compiletest for src/test/rustdoc. If this used\n+        // `compiler`, then it would cause rustdoc to be built *again*, which\n+        // isn't really necessary.\n+        let compiler = builder.compiler_for(builder.top_stage, target, target);\n+        builder.ensure(compile::Rustc { compiler, target });\n+\n+        let mut cargo = tool::prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            target,\n+            test_kind.subcommand(),\n+            \"src/rustdoc-json-types\",\n+            SourceType::InTree,\n+            &[],\n+        );\n+        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        cargo.arg(\"-p\").arg(\"rustdoc-json-types\");\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&builder.config.cmd.test_args());\n+\n+        if self.host.contains(\"musl\") {\n+            cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n+        }\n+\n+        if !builder.config.verbose_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        builder.info(&format!(\n+            \"{} rustdoc-json-types stage{} ({} -> {})\",\n+            test_kind, compiler.stage, &compiler.host, target\n+        ));\n+        let _time = util::timeit(&builder);\n+\n+        try_run(builder, &mut cargo.into());\n+    }\n+}\n+\n /// Some test suites are run inside emulators or on remote devices, and most\n /// of our test binaries are linked dynamically which means we need to ship\n /// the standard library and such to the emulator ahead of time. This step"}, {"sha": "9cc60fc7b47e557e57b0f4b4f7efa056b020a2ab", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -75,4 +75,11 @@\n       <ExpandedItem>ptr.pointer->data</ExpandedItem>\n     </Expand>\n   </Type>\n+  <Type Name=\"alloc::borrow::Cow&lt;*&gt;\">\n+    <DisplayString Condition=\"RUST$ENUM$DISR == 0x0\">Borrowed({__0})</DisplayString>\n+    <DisplayString Condition=\"RUST$ENUM$DISR == 0x1\">Owned({__0})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[value]\" ExcludeView=\"simple\">__0</Item>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>"}, {"sha": "9c3c26f597838de041c1b427186d1b52f610162a", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -30,4 +30,19 @@\n     </Expand>\n   </Type>\n \n+  <Type Name=\"core::result::Result&lt;*&gt;\">\n+    <DisplayString Condition=\"RUST$ENUM$DISR == 0x0\">Ok({__0})</DisplayString>\n+    <DisplayString Condition=\"RUST$ENUM$DISR == 0x1\">Err({(*($T2*) &amp;__0)})</DisplayString>\n+    <Expand>\n+      <Item Name=\"[value]\" Condition=\"RUST$ENUM$DISR == 0x0\">__0</Item>\n+      <Item Name=\"[value]\" Condition=\"RUST$ENUM$DISR == 0x1\">(*($T2*) &amp;__0)</Item>\n+    </Expand>\n+  </Type>\n+\n+  <Type Name=\"core::ptr::non_null::NonNull&lt;*&gt;\">\n+    <DisplayString>{(void*) pointer}</DisplayString>\n+    <Expand>\n+      <Item Name=\"[value]\">*pointer</Item>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>\n\\ No newline at end of file"}, {"sha": "b0542b0c633032d39fac245e79e855a72899a612", "filename": "src/etc/natvis/libstd.natvis", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -72,4 +72,33 @@\n       </CustomListItems>\n     </Expand>\n   </Type>\n+\n+  <Type Name=\"std::ffi::c_str::CString\">\n+    <DisplayString>{inner.data_ptr,s}</DisplayString>\n+    <Expand>\n+      <Synthetic Name=\"[chars]\">\n+        <Expand>\n+          <ArrayItems>\n+            <Size>inner.length</Size>\n+            <ValuePointer>(char*)inner.data_ptr</ValuePointer>\n+          </ArrayItems>\n+        </Expand>\n+      </Synthetic>\n+    </Expand>\n+  </Type>\n+\n+  <Type Name=\"std::ffi::c_str::CStr\">\n+    <DisplayString>{(char*) inner}</DisplayString>\n+    <Expand>\n+      <Synthetic Name=\"[chars]\">\n+        <DisplayString>{(char*) inner}</DisplayString>\n+        <Expand>\n+          <ArrayItems>\n+            <Size>strlen((char *) inner) + 1</Size>\n+            <ValuePointer>(char*)inner</ValuePointer>\n+          </ArrayItems>\n+        </Expand>\n+      </Synthetic>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>"}, {"sha": "063d8aab1ec3e4206f1de8b5d04e3f6cd734b8c8", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -23,7 +23,6 @@ use std::collections::HashSet;\n \n impl JsonRenderer<'_> {\n     pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n-        let item_type = ItemType::from(&item);\n         let deprecation = item.deprecation(self.tcx);\n         let clean::Item { source, name, attrs, kind, visibility, def_id } = item;\n         let inner = match *kind {\n@@ -50,7 +49,6 @@ impl JsonRenderer<'_> {\n                 .map(rustc_ast_pretty::pprust::attribute_to_string)\n                 .collect(),\n             deprecation: deprecation.map(from_deprecation),\n-            kind: item_type.into(),\n             inner,\n         })\n     }\n@@ -154,38 +152,38 @@ crate fn from_def_id(did: DefId) -> Id {\n fn from_clean_item_kind(item: clean::ItemKind, tcx: TyCtxt<'_>, name: &Option<Symbol>) -> ItemEnum {\n     use clean::ItemKind::*;\n     match item {\n-        ModuleItem(m) => ItemEnum::ModuleItem(m.into()),\n-        ImportItem(i) => ItemEnum::ImportItem(i.into()),\n-        StructItem(s) => ItemEnum::StructItem(s.into()),\n-        UnionItem(u) => ItemEnum::UnionItem(u.into()),\n-        StructFieldItem(f) => ItemEnum::StructFieldItem(f.into()),\n-        EnumItem(e) => ItemEnum::EnumItem(e.into()),\n-        VariantItem(v) => ItemEnum::VariantItem(v.into()),\n-        FunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n-        ForeignFunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n-        TraitItem(t) => ItemEnum::TraitItem(t.into()),\n-        TraitAliasItem(t) => ItemEnum::TraitAliasItem(t.into()),\n-        MethodItem(m, _) => ItemEnum::MethodItem(from_function_method(m, true)),\n-        TyMethodItem(m) => ItemEnum::MethodItem(from_function_method(m, false)),\n-        ImplItem(i) => ItemEnum::ImplItem(i.into()),\n-        StaticItem(s) => ItemEnum::StaticItem(from_clean_static(s, tcx)),\n-        ForeignStaticItem(s) => ItemEnum::StaticItem(from_clean_static(s, tcx)),\n-        ForeignTypeItem => ItemEnum::ForeignTypeItem,\n-        TypedefItem(t, _) => ItemEnum::TypedefItem(t.into()),\n-        OpaqueTyItem(t) => ItemEnum::OpaqueTyItem(t.into()),\n-        ConstantItem(c) => ItemEnum::ConstantItem(c.into()),\n-        MacroItem(m) => ItemEnum::MacroItem(m.source),\n-        ProcMacroItem(m) => ItemEnum::ProcMacroItem(m.into()),\n-        AssocConstItem(t, s) => ItemEnum::AssocConstItem { type_: t.into(), default: s },\n-        AssocTypeItem(g, t) => ItemEnum::AssocTypeItem {\n+        ModuleItem(m) => ItemEnum::Module(m.into()),\n+        ImportItem(i) => ItemEnum::Import(i.into()),\n+        StructItem(s) => ItemEnum::Struct(s.into()),\n+        UnionItem(u) => ItemEnum::Union(u.into()),\n+        StructFieldItem(f) => ItemEnum::StructField(f.into()),\n+        EnumItem(e) => ItemEnum::Enum(e.into()),\n+        VariantItem(v) => ItemEnum::Variant(v.into()),\n+        FunctionItem(f) => ItemEnum::Function(f.into()),\n+        ForeignFunctionItem(f) => ItemEnum::Function(f.into()),\n+        TraitItem(t) => ItemEnum::Trait(t.into()),\n+        TraitAliasItem(t) => ItemEnum::TraitAlias(t.into()),\n+        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true)),\n+        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false)),\n+        ImplItem(i) => ItemEnum::Impl(i.into()),\n+        StaticItem(s) => ItemEnum::Static(from_clean_static(s, tcx)),\n+        ForeignStaticItem(s) => ItemEnum::Static(from_clean_static(s, tcx)),\n+        ForeignTypeItem => ItemEnum::ForeignType,\n+        TypedefItem(t, _) => ItemEnum::Typedef(t.into()),\n+        OpaqueTyItem(t) => ItemEnum::OpaqueTy(t.into()),\n+        ConstantItem(c) => ItemEnum::Constant(c.into()),\n+        MacroItem(m) => ItemEnum::Macro(m.source),\n+        ProcMacroItem(m) => ItemEnum::ProcMacro(m.into()),\n+        AssocConstItem(t, s) => ItemEnum::AssocConst { type_: t.into(), default: s },\n+        AssocTypeItem(g, t) => ItemEnum::AssocType {\n             bounds: g.into_iter().map(Into::into).collect(),\n             default: t.map(Into::into),\n         },\n         StrippedItem(inner) => from_clean_item_kind(*inner, tcx, name),\n         PrimitiveItem(_) | KeywordItem(_) => {\n             panic!(\"{:?} is not supported for JSON output\", item)\n         }\n-        ExternCrateItem { ref src } => ItemEnum::ExternCrateItem {\n+        ExternCrateItem { ref src } => ItemEnum::ExternCrate {\n             name: name.as_ref().unwrap().to_string(),\n             rename: src.map(|x| x.to_string()),\n         },"}, {"sha": "8b0c049c05bc7186962364946b0355d45f2c1e7a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -108,8 +108,7 @@ impl JsonRenderer<'tcx> {\n                                 .last()\n                                 .map(Clone::clone),\n                             visibility: types::Visibility::Public,\n-                            kind: types::ItemKind::Trait,\n-                            inner: types::ItemEnum::TraitItem(trait_item.clone().into()),\n+                            inner: types::ItemEnum::Trait(trait_item.clone().into()),\n                             source: None,\n                             docs: Default::default(),\n                             links: Default::default(),\n@@ -158,11 +157,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n \n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n-            if let types::ItemEnum::TraitItem(ref mut t) = new_item.inner {\n+            if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n                 t.implementors = self.get_trait_implementors(id)\n-            } else if let types::ItemEnum::StructItem(ref mut s) = new_item.inner {\n+            } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n                 s.impls = self.get_impls(id)\n-            } else if let types::ItemEnum::EnumItem(ref mut e) = new_item.inner {\n+            } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n                 e.impls = self.get_impls(id)\n             }\n             let removed = self.index.borrow_mut().insert(from_def_id(id), new_item.clone());"}, {"sha": "9c02d5e645bfe405b5346dcc37e877d88f986d39", "filename": "src/rustdoc-json-types/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2FCargo.toml?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -9,3 +9,6 @@ path = \"lib.rs\"\n \n [dependencies]\n serde = { version = \"1.0\", features = [\"derive\"] }\n+\n+[dev-dependencies]\n+serde_json = \"1.0\""}, {"sha": "4e7794fe610646e43e577aa42a044fa9624a4456", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -76,7 +76,7 @@ pub struct Item {\n     /// Stringified versions of the attributes on this item (e.g. `\"#[inline]\"`)\n     pub attrs: Vec<String>,\n     pub deprecation: Option<Deprecation>,\n-    pub kind: ItemKind,\n+    #[serde(flatten)]\n     pub inner: ItemEnum,\n }\n \n@@ -185,48 +185,48 @@ pub enum ItemKind {\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n-#[serde(untagged)]\n+#[serde(tag = \"kind\", content = \"inner\", rename_all = \"snake_case\")]\n pub enum ItemEnum {\n-    ModuleItem(Module),\n-    ExternCrateItem {\n+    Module(Module),\n+    ExternCrate {\n         name: String,\n         rename: Option<String>,\n     },\n-    ImportItem(Import),\n+    Import(Import),\n \n-    UnionItem(Union),\n-    StructItem(Struct),\n-    StructFieldItem(Type),\n-    EnumItem(Enum),\n-    VariantItem(Variant),\n+    Union(Union),\n+    Struct(Struct),\n+    StructField(Type),\n+    Enum(Enum),\n+    Variant(Variant),\n \n-    FunctionItem(Function),\n+    Function(Function),\n \n-    TraitItem(Trait),\n-    TraitAliasItem(TraitAlias),\n-    MethodItem(Method),\n-    ImplItem(Impl),\n+    Trait(Trait),\n+    TraitAlias(TraitAlias),\n+    Method(Method),\n+    Impl(Impl),\n \n-    TypedefItem(Typedef),\n-    OpaqueTyItem(OpaqueTy),\n-    ConstantItem(Constant),\n+    Typedef(Typedef),\n+    OpaqueTy(OpaqueTy),\n+    Constant(Constant),\n \n-    StaticItem(Static),\n+    Static(Static),\n \n     /// `type`s from an extern block\n-    ForeignTypeItem,\n+    ForeignType,\n \n     /// Declarative macro_rules! macro\n-    MacroItem(String),\n-    ProcMacroItem(ProcMacro),\n+    Macro(String),\n+    ProcMacro(ProcMacro),\n \n-    AssocConstItem {\n+    AssocConst {\n         #[serde(rename = \"type\")]\n         type_: Type,\n         /// e.g. `const X: usize = 5;`\n         default: Option<String>,\n     },\n-    AssocTypeItem {\n+    AssocType {\n         bounds: Vec<GenericBound>,\n         /// e.g. `type X = usize;`\n         default: Option<Type>,\n@@ -508,3 +508,6 @@ pub struct Static {\n     pub mutable: bool,\n     pub expr: String,\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "e7f6447ed87531dc944188e5a3fdf24ba90023ca", "filename": "src/rustdoc-json-types/tests.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Frustdoc-json-types%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Ftests.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,34 @@\n+use super::*;\n+\n+#[test]\n+fn test_struct_info_roundtrip() {\n+    let s = ItemEnum::Struct(Struct {\n+        struct_type: StructType::Plain,\n+        generics: Generics { params: vec![], where_predicates: vec![] },\n+        fields_stripped: false,\n+        fields: vec![],\n+        impls: vec![],\n+    });\n+\n+    let struct_json = serde_json::to_string(&s).unwrap();\n+\n+    let de_s = serde_json::from_str(&struct_json).unwrap();\n+\n+    assert_eq!(s, de_s);\n+}\n+\n+#[test]\n+fn test_union_info_roundtrip() {\n+    let u = ItemEnum::Union(Union {\n+        generics: Generics { params: vec![], where_predicates: vec![] },\n+        fields_stripped: false,\n+        fields: vec![],\n+        impls: vec![],\n+    });\n+\n+    let union_json = serde_json::to_string(&u).unwrap();\n+\n+    let de_u = serde_json::from_str(&union_json).unwrap();\n+\n+    assert_eq!(u, de_u);\n+}"}, {"sha": "b0c97f423781876ac0ffe0d6264494400fecd6f4", "filename": "src/test/mir-opt/deduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -5,22 +5,26 @@\n       debug s => _1;                       // in scope 0 at $DIR/deduplicate_blocks.rs:2:36: 2:37\n       let mut _0: bool;                    // return place in scope 0 at $DIR/deduplicate_blocks.rs:2:48: 2:52\n       let mut _2: &[u8];                   // in scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n-      let mut _3: usize;                   // in scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n-      let mut _4: bool;                    // in scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n-      let mut _5: usize;                   // in scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n-      let mut _6: bool;                    // in scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n+      let mut _3: &str;                    // in scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:12\n+      let mut _4: usize;                   // in scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n+      let mut _5: bool;                    // in scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n+      let mut _6: usize;                   // in scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n+      let mut _7: bool;                    // in scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n       scope 1 (inlined core::str::<impl str>::as_bytes) { // at $DIR/deduplicate_blocks.rs:3:11: 3:23\n-          debug self => _7;                // in scope 1 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n-          let mut _7: &str;                // in scope 1 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+          debug self => _3;                // in scope 1 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+          let mut _8: &str;                // in scope 1 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n           scope 2 {\n           }\n       }\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n-          _7 = _1;                         // scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:12\n--         _2 = transmute::<&str, &[u8]>(move _7) -> bb14; // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n-+         _2 = transmute::<&str, &[u8]>(move _7) -> bb12; // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+          StorageLive(_3);                 // scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:12\n+          _3 = _1;                         // scope 0 at $DIR/deduplicate_blocks.rs:3:11: 3:12\n+          StorageLive(_8);                 // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+          _8 = _3;                         // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+-         _2 = transmute::<&str, &[u8]>(move _8) -> bb14; // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n++         _2 = transmute::<&str, &[u8]>(move _8) -> bb12; // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n                                            // mir::Constant\n                                            // + span: $DIR/deduplicate_blocks.rs:3:11: 3:23\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&str) -> &[u8] {std::intrinsics::transmute::<&str, &[u8]>}, val: Value(Scalar(<ZST>)) }\n@@ -44,9 +48,9 @@\n       }\n   \n       bb5: {\n-          _3 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n-          _4 = Ge(move _3, const 3_usize); // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n-          switchInt(move _4) -> [false: bb9, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n+          _4 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n+          _5 = Ge(move _4, const 3_usize); // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n+          switchInt(move _5) -> [false: bb9, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:5:9: 5:31\n       }\n   \n       bb6: {\n@@ -93,9 +97,11 @@\n   \n -     bb14: {\n +     bb12: {\n-          _5 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n-          _6 = Ge(move _5, const 4_usize); // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n-          switchInt(move _6) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n+          StorageDead(_8);                 // scope 2 at $DIR/deduplicate_blocks.rs:3:11: 3:23\n+          StorageDead(_3);                 // scope 0 at $DIR/deduplicate_blocks.rs:3:22: 3:23\n+          _6 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n+          _7 = Ge(move _6, const 4_usize); // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n+          switchInt(move _7) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/deduplicate_blocks.rs:4:9: 4:37\n       }\n   }\n   "}, {"sha": "fffcf82b3f1d8f32d087bdc7b75ee2f60dc3efd3", "filename": "src/test/mir-opt/dest-prop/branch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,5 @@\n //! Tests that assignment in both branches of an `if` are eliminated.\n-\n+// compile-flags: -Zunsound-mir-opts\n fn val() -> i32 {\n     1\n }"}, {"sha": "41796247789aa33e2e2b4692dbc58a045ff9098b", "filename": "src/test/mir-opt/dest-prop/copy_propagation_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcopy_propagation_arg.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,6 +1,6 @@\n // Check that DestinationPropagation does not propagate an assignment to a function argument\n // (doing so can break usages of the original argument value)\n-\n+// compile-flags: -Zunsound-mir-opts\n fn dummy(x: u8) -> u8 {\n     x\n }"}, {"sha": "c9187d408675cb2bcdcfeb6b18fe5a57c5c0d061", "filename": "src/test/mir-opt/dest-prop/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,5 @@\n //! Tests that cyclic assignments don't hang DestinationPropagation, and result in reasonable code.\n-\n+// compile-flags: -Zunsound-mir-opts\n fn val() -> i32 {\n     1\n }"}, {"sha": "3627d479a9aa30708f223fda4bfe4ff5acb7e5f9", "filename": "src/test/mir-opt/dest-prop/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,5 @@\n //! Copy of `nrvo-simple.rs`, to ensure that full dest-prop handles it too.\n-\n+// compile-flags: -Zunsound-mir-opts\n // EMIT_MIR simple.nrvo.DestinationPropagation.diff\n fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n     let mut buf = [0; 1024];"}, {"sha": "0ac9661a66a31d291c49b58fad860654b936d5be", "filename": "src/test/mir-opt/dest-prop/union.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,5 @@\n //! Tests that projections through unions cancel `DestinationPropagation`.\n-\n+// compile-flags: -Zunsound-mir-opts\n fn val() -> u32 {\n     1\n }"}, {"sha": "a7c2c93aad23ac9f82da502317fcf09a78766f37", "filename": "src/test/mir-opt/inline/inline_closure_captures.foo.Inline.after.mir", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -17,7 +17,8 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n             debug _q => _9;              // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n             debug q => (*((*_6).0: &i32)); // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n             debug t => (*((*_6).1: &T)); // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-            let mut _10: T;              // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+            let mut _10: i32;            // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+            let mut _11: T;              // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         }\n     }\n \n@@ -39,10 +40,13 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         (_7.0: i32) = move _8;           // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageLive(_9);                 // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         _9 = move (_7.0: i32);           // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        (_0.0: i32) = (*((*_6).0: &i32)); // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageLive(_10);                // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        _10 = (*((*_6).1: &T));          // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        (_0.1: T) = move _10;            // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        _10 = (*((*_6).0: &i32));        // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        StorageLive(_11);                // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        _11 = (*((*_6).1: &T));          // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        (_0.0: i32) = move _10;          // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        (_0.1: T) = move _11;            // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        StorageDead(_11);                // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageDead(_10);                // scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageDead(_9);                 // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageDead(_8);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9"}, {"sha": "e2fad5b60ebfaf49ff0cda071d872b44783ae58f", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -5,18 +5,20 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n       let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _7: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _8: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _9: ();                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _10: ();                     // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         let mut _6: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _6: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _7: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         let mut _8: !;                   // in scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         scope 2 {\n +             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n++             let _5: !;                   // in scope 2 at $DIR/inline-diverging.rs:22:5: 22:22\n +             scope 3 {\n-+                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n++                 debug b => _5;           // in scope 3 at $DIR/inline-diverging.rs:22:5: 22:22\n +             }\n +             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:22:5: 22:22\n +                 scope 7 (inlined sleep) { // at $DIR/inline-diverging.rs:22:5: 22:22\n@@ -40,12 +42,11 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline-diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n-+         StorageLive(_6);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         StorageLive(_7);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         _7 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_9);                 // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _9 = const ();                   // scope 1 at $DIR/inline-diverging.rs:22:5: 22:22\n +         goto -> bb1;                     // scope 4 at $DIR/inline-diverging.rs:22:5: 22:22\n       }\n   "}, {"sha": "fba88c83eb4f39bb27b9878eb8ff85116b167a1d", "filename": "src/test/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -24,9 +24,12 @@\n +         }\n +     }\n +     scope 6 (inlined g::{closure#0}) {   // at $DIR/inline-generator.rs:9:14: 9:46\n-+         debug a => _8;                   // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n-+         let mut _8: bool;                // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n-+         let mut _9: u32;                 // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         debug a => _11;                  // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _8: i32;                 // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _9: bool;                // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _10: bool;               // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let _11: bool;                   // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         let mut _12: u32;                // in scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +     }\n   \n       bb0: {\n@@ -65,16 +68,18 @@\n -                                          // + literal: Const { ty: for<'r> fn(std::pin::Pin<&'r mut impl std::ops::Generator<bool>>, bool) -> std::ops::GeneratorState<<impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Yield, <impl std::ops::Generator<bool> as std::ops::Generator<bool>>::Return> {<impl std::ops::Generator<bool> as std::ops::Generator<bool>>::resume}, val: Value(Scalar(<ZST>)) }\n +         StorageLive(_7);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n +         _7 = const false;                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n-+         StorageLive(_8);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n-+         StorageLive(_9);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n-+         _9 = discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))); // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n-+         switchInt(move _9) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_10);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_11);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_12);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         _12 = discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))); // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         switchInt(move _12) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n       }\n   \n -     bb3: {\n +     bb1: {\n-+         StorageDead(_9);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n-+         StorageDead(_8);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageDead(_12);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageDead(_11);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageDead(_10);                // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n +         StorageDead(_7);                 // scope 0 at $DIR/inline-generator.rs:9:14: 9:46\n           StorageDead(_2);                 // scope 0 at $DIR/inline-generator.rs:9:45: 9:46\n           StorageDead(_4);                 // scope 0 at $DIR/inline-generator.rs:9:46: 9:47\n@@ -89,28 +94,36 @@\n +     }\n + \n +     bb3: {\n-+         _8 = move _7;                    // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n-+         switchInt(move _8) -> [false: bb5, otherwise: bb4]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         _11 = move _7;                   // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_8);                 // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_9);                 // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         _9 = _11;                        // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         switchInt(move _9) -> [false: bb5, otherwise: bb4]; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +     }\n + \n +     bb4: {\n-+         ((_1 as Yielded).0: i32) = const 7_i32; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         _8 = const 7_i32;                // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         goto -> bb6;                     // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +     }\n + \n +     bb5: {\n-+         ((_1 as Yielded).0: i32) = const 13_i32; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         _8 = const 13_i32;               // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         goto -> bb6;                     // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +     }\n + \n +     bb6: {\n++         StorageDead(_9);                 // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         ((_1 as Yielded).0: i32) = move _8; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         discriminant(_1) = 0;            // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))) = 3; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         goto -> bb1;                     // scope 0 at $DIR/inline-generator.rs:15:11: 15:39\n +     }\n + \n +     bb7: {\n-+         ((_1 as Complete).0: bool) = move _7; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageLive(_8);                 // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         _10 = move _7;                   // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         StorageDead(_8);                 // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n++         ((_1 as Complete).0: bool) = move _10; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         discriminant(_1) = 1;            // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         discriminant((*(_2.0: &mut [generator@$DIR/inline-generator.rs:15:5: 15:41 {bool, i32}]))) = 1; // scope 6 at $DIR/inline-generator.rs:9:14: 9:46\n +         goto -> bb1;                     // scope 0 at $DIR/inline-generator.rs:15:41: 15:41"}, {"sha": "e2ec0e82ebf0990d5361f66eee12c84011549a59", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.32bit.diff", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -6,25 +6,32 @@\n       let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n       let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n       let _3: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-      let mut _5: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _7: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _8: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _9: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _11: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _12: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _13: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _5: i32;                     // in scope 0 at $DIR/issue-73223.rs:7:22: 7:27\n+      let mut _6: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _11: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _12: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _13: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _15: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _16: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _17: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _18: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _19: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       scope 1 {\n           debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _4: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _4;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n+              let _9: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let _10: &i32;               // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let mut _20: &i32;           // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _11;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _12;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _10: core::panicking::AssertKind; // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _9;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _10;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  let _14: core::panicking::AssertKind; // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug kind => _10;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug kind => _14;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   }\n               }\n           }\n@@ -43,36 +50,57 @@\n           _1 = _3;                         // scope 2 at $DIR/issue-73223.rs:3:20: 3:21\n           StorageDead(_3);                 // scope 0 at $DIR/issue-73223.rs:3:20: 3:21\n           StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          ((_4 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          StorageLive(_4);                 // scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n+          StorageLive(_5);                 // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          _5 = _1;                         // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          ((_4 as Some).0: i32) = move _5; // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n           discriminant(_4) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          (_5.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = const main::promoted[0];    // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 1 at $DIR/issue-73223.rs:7:27: 7:28\n+          StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = &_1;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _20 = const main::promoted[0];   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main), const_param_did: None }, [], Some(promoted[0])) }\n-          (_5.1: &i32) = move _6;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _11 = (_5.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _12 = (_5.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _9 = (*_11);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _8 = Eq(move _9, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = Not(move _8);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(move _7) -> [false: bb2, otherwise: bb1]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _8 = _20;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_6.0: &i32) = move _7;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_6.1: &i32) = move _8;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _9 = (_6.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _10 = (_6.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _13 = (*_9);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _12 = Eq(move _13, const 1_i32); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _11 = Not(move _12);             // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(move _11) -> [false: bb2, otherwise: bb1]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_10) = 0;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_13);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_13) = 0;           // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          core::panicking::assert_failed::<i32, i32>(const core::panicking::AssertKind::Eq, move _11, move _12, move _13); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          discriminant(_14) = 0;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_15);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_16);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _16 = _9;                        // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = _16;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_17);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _18 = _10;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _17 = _18;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_19);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          discriminant(_19) = 0;           // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          core::panicking::assert_failed::<i32, i32>(const core::panicking::AssertKind::Eq, move _15, move _17, move _19); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(core::panicking::AssertKind, &'r i32, &'s i32, std::option::Option<std::fmt::Arguments<'t0>>) -> ! {core::panicking::assert_failed::<i32, i32>}, val: Value(Scalar(<ZST>)) }\n@@ -85,8 +113,12 @@\n       }\n   \n       bb2: {\n-          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n+          StorageDead(_4);                 // scope 1 at $DIR/issue-73223.rs:9:1: 9:2\n           StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:9:1: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }"}, {"sha": "e2ec0e82ebf0990d5361f66eee12c84011549a59", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.64bit.diff", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -6,25 +6,32 @@\n       let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n       let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n       let _3: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-      let mut _5: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _7: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _8: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _9: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _11: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _12: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _13: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _5: i32;                     // in scope 0 at $DIR/issue-73223.rs:7:22: 7:27\n+      let mut _6: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _11: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _12: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _13: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _15: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _16: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _17: &i32;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _18: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _19: std::option::Option<std::fmt::Arguments>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       scope 1 {\n           debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _4: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _4;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n+              let _9: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let _10: &i32;               // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let mut _20: &i32;           // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _11;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _12;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _10: core::panicking::AssertKind; // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _9;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _10;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  let _14: core::panicking::AssertKind; // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug kind => _10;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug kind => _14;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   }\n               }\n           }\n@@ -43,36 +50,57 @@\n           _1 = _3;                         // scope 2 at $DIR/issue-73223.rs:3:20: 3:21\n           StorageDead(_3);                 // scope 0 at $DIR/issue-73223.rs:3:20: 3:21\n           StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          ((_4 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          StorageLive(_4);                 // scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n+          StorageLive(_5);                 // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          _5 = _1;                         // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          ((_4 as Some).0: i32) = move _5; // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n           discriminant(_4) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          (_5.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = const main::promoted[0];    // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 1 at $DIR/issue-73223.rs:7:27: 7:28\n+          StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = &_1;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _20 = const main::promoted[0];   // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main), const_param_did: None }, [], Some(promoted[0])) }\n-          (_5.1: &i32) = move _6;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _11 = (_5.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _12 = (_5.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _9 = (*_11);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _8 = Eq(move _9, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = Not(move _8);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(move _7) -> [false: bb2, otherwise: bb1]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _8 = _20;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_6.0: &i32) = move _7;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_6.1: &i32) = move _8;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_8);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _9 = (_6.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _10 = (_6.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _13 = (*_9);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _12 = Eq(move _13, const 1_i32); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _11 = Not(move _12);             // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(move _11) -> [false: bb2, otherwise: bb1]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_10) = 0;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_13);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          discriminant(_13) = 0;           // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          core::panicking::assert_failed::<i32, i32>(const core::panicking::AssertKind::Eq, move _11, move _12, move _13); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          discriminant(_14) = 0;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_15);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_16);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _16 = _9;                        // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = _16;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_17);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _18 = _10;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _17 = _18;                       // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_19);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          discriminant(_19) = 0;           // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          core::panicking::assert_failed::<i32, i32>(const core::panicking::AssertKind::Eq, move _15, move _17, move _19); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(core::panicking::AssertKind, &'r i32, &'s i32, std::option::Option<std::fmt::Arguments<'t0>>) -> ! {core::panicking::assert_failed::<i32, i32>}, val: Value(Scalar(<ZST>)) }\n@@ -85,8 +113,12 @@\n       }\n   \n       bb2: {\n-          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_10);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_9);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n+          StorageDead(_4);                 // scope 1 at $DIR/issue-73223.rs:9:1: 9:2\n           StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:9:1: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }"}, {"sha": "19d161ac2b1039c3f7f1bce445ba602de1d53e10", "filename": "src/test/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -3,73 +3,86 @@\n fn num_to_digit(_1: char) -> u32 {\n     debug num => _1;                     // in scope 0 at $DIR/issue-59352.rs:12:21: 12:24\n     let mut _0: u32;                     // return place in scope 0 at $DIR/issue-59352.rs:12:35: 12:38\n-    let mut _2: std::option::Option<u32>; // in scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n-    let mut _3: char;                    // in scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n-    let mut _4: u32;                     // in scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n-    let mut _9: isize;                   // in scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n+    let mut _2: char;                    // in scope 0 at $DIR/issue-59352.rs:14:8: 14:11\n+    let mut _3: std::option::Option<u32>; // in scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n+    let mut _4: char;                    // in scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n+    let mut _5: u32;                     // in scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n+    let mut _11: isize;                  // in scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n     scope 1 (inlined char::methods::<impl char>::is_digit) { // at $DIR/issue-59352.rs:14:8: 14:23\n-        debug self => _7;                // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        debug radix => _4;               // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        let mut _5: &std::option::Option<u32>; // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        let _6: std::option::Option<u32>; // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        let mut _7: char;                // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        debug self => _2;                // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        debug radix => _5;               // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        let mut _6: &std::option::Option<u32>; // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        let _7: std::option::Option<u32>; // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        let mut _8: char;                // in scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n         scope 2 (inlined Option::<u32>::is_some) { // at $DIR/issue-59352.rs:14:8: 14:23\n-            debug self => _5;            // in scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n+            debug self => _6;            // in scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n+            let mut _9: isize;           // in scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n         }\n     }\n     scope 3 (inlined #[track_caller] Option::<u32>::unwrap) { // at $DIR/issue-59352.rs:14:26: 14:50\n-        debug self => _2;                // in scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n-        let mut _8: isize;               // in scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n+        debug self => _3;                // in scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n+        let mut _10: isize;              // in scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n         scope 4 {\n             debug val => _0;             // in scope 4 at $DIR/issue-59352.rs:14:26: 14:50\n         }\n     }\n \n     bb0: {\n-        _7 = _1;                         // scope 0 at $DIR/issue-59352.rs:14:8: 14:11\n-        StorageLive(_4);                 // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n-        _4 = const 8_u32;                // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n-        StorageLive(_5);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageLive(_2);                 // scope 0 at $DIR/issue-59352.rs:14:8: 14:11\n+        _2 = _1;                         // scope 0 at $DIR/issue-59352.rs:14:8: 14:11\n+        StorageLive(_5);                 // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n+        _5 = const 8_u32;                // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n         StorageLive(_6);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        _6 = char::methods::<impl char>::to_digit(move _7, const 8_u32) -> bb5; // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageLive(_7);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageLive(_8);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        _8 = _2;                         // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        _7 = char::methods::<impl char>::to_digit(move _8, const 8_u32) -> bb5; // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n                                          // mir::Constant\n                                          // + span: $DIR/issue-59352.rs:14:8: 14:23\n                                          // + literal: Const { ty: fn(char, u32) -> std::option::Option<u32> {std::char::methods::<impl char>::to_digit}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb1: {\n-        StorageLive(_2);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n-        StorageLive(_3);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n-        _3 = _1;                         // scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n-        _2 = char::methods::<impl char>::to_digit(move _3, const 8_u32) -> bb3; // scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n+        StorageDead(_11);                // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n+        StorageLive(_3);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n+        StorageLive(_4);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n+        _4 = _1;                         // scope 0 at $DIR/issue-59352.rs:14:26: 14:29\n+        _3 = char::methods::<impl char>::to_digit(move _4, const 8_u32) -> bb3; // scope 0 at $DIR/issue-59352.rs:14:26: 14:41\n                                          // mir::Constant\n                                          // + span: $DIR/issue-59352.rs:14:30: 14:38\n                                          // + literal: Const { ty: fn(char, u32) -> std::option::Option<u32> {std::char::methods::<impl char>::to_digit}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb2: {\n+        StorageDead(_11);                // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n         _0 = const 0_u32;                // scope 0 at $DIR/issue-59352.rs:14:60: 14:61\n         goto -> bb4;                     // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n     }\n \n     bb3: {\n-        StorageDead(_3);                 // scope 0 at $DIR/issue-59352.rs:14:40: 14:41\n-        StorageLive(_8);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:50\n-        _8 = discriminant(_2);           // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n-        switchInt(move _8) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n+        StorageDead(_4);                 // scope 0 at $DIR/issue-59352.rs:14:40: 14:41\n+        StorageLive(_10);                // scope 0 at $DIR/issue-59352.rs:14:26: 14:50\n+        _10 = discriminant(_3);          // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n+        switchInt(move _10) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n     }\n \n     bb4: {\n         return;                          // scope 0 at $DIR/issue-59352.rs:15:2: 15:2\n     }\n \n     bb5: {\n-        _5 = &_6;                        // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        _9 = discriminant((*_5));        // scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n-        StorageDead(_5);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        _6 = &_7;                        // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageDead(_8);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageLive(_9);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        _9 = discriminant((*_6));        // scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageLive(_11);                // scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n+        _11 = move _9;                   // scope 2 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageDead(_9);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n         StorageDead(_6);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n-        StorageDead(_4);                 // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n-        switchInt(move _9) -> [1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n+        StorageDead(_7);                 // scope 1 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageDead(_5);                 // scope 0 at $DIR/issue-59352.rs:14:8: 14:23\n+        StorageDead(_2);                 // scope 0 at $DIR/issue-59352.rs:14:22: 14:23\n+        switchInt(move _11) -> [1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n     }\n \n     bb6: {\n@@ -90,9 +103,9 @@ fn num_to_digit(_1: char) -> u32 {\n     }\n \n     bb8: {\n-        _0 = move ((_2 as Some).0: u32); // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n-        StorageDead(_8);                 // scope 0 at $DIR/issue-59352.rs:14:26: 14:50\n-        StorageDead(_2);                 // scope 0 at $DIR/issue-59352.rs:14:49: 14:50\n+        _0 = move ((_3 as Some).0: u32); // scope 3 at $DIR/issue-59352.rs:14:26: 14:50\n+        StorageDead(_10);                // scope 0 at $DIR/issue-59352.rs:14:26: 14:50\n+        StorageDead(_3);                 // scope 0 at $DIR/issue-59352.rs:14:49: 14:50\n         goto -> bb4;                     // scope 0 at $DIR/issue-59352.rs:14:5: 14:63\n     }\n }"}, {"sha": "a87d5e1f0ff8b5a112eb5f9357b4852f6ae8df2b", "filename": "src/test/mir-opt/lower_intrinsics.f_u64.PreCodegen.before.mir", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Flower_intrinsics.f_u64.PreCodegen.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Flower_intrinsics.f_u64.PreCodegen.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.f_u64.PreCodegen.before.mir?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -2,16 +2,17 @@\n \n fn f_u64() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:34:16: 34:16\n+    let mut _1: u64;                     // in scope 0 at $DIR/lower_intrinsics.rs:35:5: 35:21\n     scope 1 (inlined f_dispatch::<u64>) { // at $DIR/lower_intrinsics.rs:35:5: 35:21\n         debug t => _1;                   // in scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n-        let mut _1: u64;                 // in scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         let _2: ();                      // in scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         let mut _3: u64;                 // in scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         scope 2 (inlined std::mem::size_of::<u64>) { // at $DIR/lower_intrinsics.rs:35:5: 35:21\n         }\n     }\n \n     bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         _1 = const 0_u64;                // scope 0 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n@@ -25,6 +26,7 @@ fn f_u64() -> () {\n     bb1: {\n         StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:35:5: 35:21\n+        StorageDead(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:35:5: 35:21\n         _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:34:16: 36:2\n         return;                          // scope 0 at $DIR/lower_intrinsics.rs:36:2: 36:2\n     }"}, {"sha": "f1718c5752c1cabb8a6b0b7c7566dfd48feb9fe5", "filename": "src/test/mir-opt/simplify_locals.c.SimplifyLocals.diff", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fsimplify_locals.c.SimplifyLocals.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fmir-opt%2Fsimplify_locals.c.SimplifyLocals.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_locals.c.SimplifyLocals.diff?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -17,8 +17,13 @@\n           StorageLive(_1);                 // scope 0 at $DIR/simplify-locals.rs:14:9: 14:14\n           _1 = [const 0_u8; 10];           // scope 0 at $DIR/simplify-locals.rs:14:17: 14:26\n -         StorageLive(_2);                 // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n--         _3 = &_1;                        // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n+-         StorageLive(_3);                 // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n+-         StorageLive(_4);                 // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n+-         _4 = &_1;                        // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n+-         _3 = _4;                         // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n -         _2 = move _3 as &[u8] (Pointer(Unsize)); // scope 1 at $DIR/simplify-locals.rs:16:20: 16:26\n+-         StorageDead(_3);                 // scope 1 at $DIR/simplify-locals.rs:16:25: 16:26\n+-         StorageDead(_4);                 // scope 1 at $DIR/simplify-locals.rs:16:26: 16:27\n -         StorageDead(_2);                 // scope 1 at $DIR/simplify-locals.rs:16:26: 16:27\n           _0 = const ();                   // scope 0 at $DIR/simplify-locals.rs:13:8: 17:2\n           StorageDead(_1);                 // scope 0 at $DIR/simplify-locals.rs:17:1: 17:2"}, {"sha": "fa81769e5a80021380f77c36d8fb66f45351c28b", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -2,7 +2,7 @@\n \n macro_rules! mod_decl {\n     ($i:ident) => {\n-        mod $i; //~ ERROR Cannot declare a non-inline module inside a block\n+        mod $i; //~ ERROR cannot declare a non-inline module inside a block\n     };\n }\n "}, {"sha": "4039728e18ac384c22fef6784a6559e52969349c", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/macro-expanded-mod.rs:5:9\n    |\n LL |         mod $i;"}, {"sha": "de4f816656cc477b21c913e831c54f41b943849a", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,5 +1,5 @@\n // Test that non-inline modules are not allowed inside blocks.\n \n fn main() {\n-    mod foo; //~ ERROR Cannot declare a non-inline module inside a block\n+    mod foo; //~ ERROR cannot declare a non-inline module inside a block\n }"}, {"sha": "64189bee43f6ebc07f1db8e02340d7d789c86a0c", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/non-inline-mod-restriction.rs:4:5\n    |\n LL |     mod foo;"}, {"sha": "f62cd2a9eb4e42e6a2b60a481b4e21b46535b76b", "filename": "src/test/ui/modules/path-no-file-name.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,7 @@\n+// normalize-stderr-test: \"\\.:.*\\(\" -> \".: $$ACCESS_DENIED_MSG (\"\n+// normalize-stderr-test: \"os error \\d+\" -> \"os error $$ACCESS_DENIED_CODE\"\n+\n+#[path = \".\"]\n+mod m; //~ ERROR couldn't read\n+\n+fn main() {}"}, {"sha": "32a213c68f654c2754d944a263c23919f6b161db", "filename": "src/test/ui/modules/path-no-file-name.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,8 @@\n+error: couldn't read $DIR/.: $ACCESS_DENIED_MSG (os error $ACCESS_DENIED_CODE)\n+  --> $DIR/path-no-file-name.rs:5:1\n+   |\n+LL | mod m;\n+   | ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d4b47efe681580fa2f97d9c92f16780ec8a10812", "filename": "src/test/ui/parser/circular_modules_main.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,10 +1,12 @@\n+// error-pattern: circular modules\n+\n #[path = \"circular_modules_hello.rs\"]\n-mod circular_modules_hello; //~ ERROR: circular modules\n+mod circular_modules_hello;\n \n pub fn hi_str() -> String {\n     \"Hi!\".to_string()\n }\n \n fn main() {\n-    circular_modules_hello::say_hello(); //~ ERROR cannot find function `say_hello` in module\n+    circular_modules_hello::say_hello();\n }"}, {"sha": "ee45f65a3bd5ad1b079e3161e5f843b64f76cef3", "filename": "src/test/ui/parser/circular_modules_main.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -1,18 +1,18 @@\n-error: circular modules: $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs\n-  --> $DIR/circular_modules_main.rs:2:1\n+error: circular modules: $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs\n+  --> $DIR/circular_modules_hello.rs:4:1\n    |\n-LL | mod circular_modules_hello;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | mod circular_modules_main;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0425]: cannot find function `say_hello` in module `circular_modules_hello`\n-  --> $DIR/circular_modules_main.rs:9:29\n+error[E0425]: cannot find function `hi_str` in module `circular_modules_main`\n+  --> $DIR/circular_modules_hello.rs:7:43\n    |\n-LL |     circular_modules_hello::say_hello();\n-   |                             ^^^^^^^^^ not found in `circular_modules_hello`\n+LL |     println!(\"{}\", circular_modules_main::hi_str());\n+   |                                           ^^^^^^ not found in `circular_modules_main`\n    |\n help: consider importing this function\n    |\n-LL | use circular_modules_hello::say_hello;\n+LL | use hi_str;\n    |\n \n error: aborting due to 2 previous errors"}, {"sha": "379491f3126b06e0e978a035e74a87f492284454", "filename": "src/test/ui/proc-macro/cfg-eval-fail.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,9 @@\n+#![feature(cfg_eval)]\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() {\n+    let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+    //~^ ERROR removing an expression is not supported in this position\n+    //~| ERROR removing an expression is not supported in this position\n+    //~| ERROR removing an expression is not supported in this position\n+}"}, {"sha": "010ac006b0bee3b8e69eb8135c234d9d9d98190e", "filename": "src/test/ui/proc-macro/cfg-eval-fail.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval-fail.stderr?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,20 @@\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/cfg-eval-fail.rs:5:25\n+   |\n+LL |     let _ = #[cfg_eval] #[cfg(FALSE)] 0;\n+   |                         ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "ea397df545265510905871f8812d0cb80fdd88b6", "filename": "src/test/ui/proc-macro/cfg-eval.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.rs?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// compile-flags: -Z span-debug\n+// aux-build:test-macros.rs\n+\n+#![feature(cfg_eval)]\n+#![feature(proc_macro_hygiene)]\n+#![feature(stmt_expr_attributes)]\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[cfg_eval]\n+#[print_attr]\n+struct S1 {\n+    #[cfg(FALSE)]\n+    field_false: u8,\n+    #[cfg(all(/*true*/))]\n+    #[cfg_attr(FALSE, unknown_attr)]\n+    #[cfg_attr(all(/*true*/), allow())]\n+    field_true: u8,\n+}\n+\n+#[cfg_eval]\n+#[cfg(FALSE)]\n+struct S2 {}\n+\n+fn main() {\n+    let _ = #[cfg_eval] #[print_attr](#[cfg(FALSE)] 0, #[cfg(all(/*true*/))] 1);\n+}"}, {"sha": "b98e8961bfea712063544b3bc5a9690b41e75a91", "filename": "src/test/ui/proc-macro/cfg-eval.stdout", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8f349be27815d43d462a32faeb270a22a68486b6/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcfg-eval.stdout?ref=8f349be27815d43d462a32faeb270a22a68486b6", "patch": "@@ -0,0 +1,135 @@\n+PRINT-ATTR INPUT (DISPLAY): struct S1 { #[cfg(all())] #[allow()] field_true : u8, }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+    Ident {\n+        ident: \"S1\",\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"cfg\",\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [\n+                            Ident {\n+                                ident: \"all\",\n+                                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                            },\n+                            Group {\n+                                delimiter: Parenthesis,\n+                                stream: TokenStream [],\n+                                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"allow\",\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [],\n+                        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Ident {\n+                ident: \"field_true\",\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Ident {\n+                ident: \"u8\",\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+            Punct {\n+                ch: ',',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+            },\n+        ],\n+        span: $DIR/cfg-eval.rs:17:1: 24:2 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): (#[cfg(all())] 1,)\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Punct {\n+                ch: '#',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Group {\n+                delimiter: Bracket,\n+                stream: TokenStream [\n+                    Ident {\n+                        ident: \"cfg\",\n+                        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                    },\n+                    Group {\n+                        delimiter: Parenthesis,\n+                        stream: TokenStream [\n+                            Ident {\n+                                ident: \"all\",\n+                                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                            },\n+                            Group {\n+                                delimiter: Parenthesis,\n+                                stream: TokenStream [],\n+                                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                            },\n+                        ],\n+                        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+                    },\n+                ],\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+            Punct {\n+                ch: ',',\n+                spacing: Alone,\n+                span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+            },\n+        ],\n+        span: $DIR/cfg-eval.rs:31:38: 31:80 (#0),\n+    },\n+]"}]}