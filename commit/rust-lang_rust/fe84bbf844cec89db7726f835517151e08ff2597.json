{"sha": "fe84bbf844cec89db7726f835517151e08ff2597", "node_id": "C_kwDOAAsO6NoAKGZlODRiYmY4NDRjZWM4OWRiNzcyNmY4MzU1MTcxNTFlMDhmZjI1OTc", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-09-02T12:41:27Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:13Z"}, "message": "Add tracking of unreachability", "tree": {"sha": "d0ca21ca6393dac755cfab98a6ce99207e269a27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0ca21ca6393dac755cfab98a6ce99207e269a27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe84bbf844cec89db7726f835517151e08ff2597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe84bbf844cec89db7726f835517151e08ff2597", "html_url": "https://github.com/rust-lang/rust/commit/fe84bbf844cec89db7726f835517151e08ff2597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe84bbf844cec89db7726f835517151e08ff2597/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16dedba1c80e96e7b0481191d4ae16e2d8cb0016", "url": "https://api.github.com/repos/rust-lang/rust/commits/16dedba1c80e96e7b0481191d4ae16e2d8cb0016", "html_url": "https://github.com/rust-lang/rust/commit/16dedba1c80e96e7b0481191d4ae16e2d8cb0016"}], "stats": {"total": 112, "additions": 82, "deletions": 30}, "files": [{"sha": "40d8aaea94dc9f90b6a10fcf5c9f4e166f104303", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fe84bbf844cec89db7726f835517151e08ff2597/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe84bbf844cec89db7726f835517151e08ff2597/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=fe84bbf844cec89db7726f835517151e08ff2597", "patch": "@@ -263,10 +263,13 @@ impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper\n     const NAME: &'static str = T::NAME;\n \n     fn bottom_value(&self, _body: &Body<'tcx>) -> Self::Domain {\n-        State(IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count))\n+        State(StateData::Unreachable)\n     }\n \n     fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n+        assert!(matches!(state.0, StateData::Unreachable));\n+        let values = IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count);\n+        *state = State(StateData::Reachable(values));\n         for arg in body.args_iter() {\n             state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map());\n         }\n@@ -283,7 +286,9 @@ where\n         statement: &Statement<'tcx>,\n         _location: Location,\n     ) {\n-        self.0.handle_statement(statement, state);\n+        if state.is_reachable() {\n+            self.0.handle_statement(statement, state);\n+        }\n     }\n \n     fn apply_terminator_effect(\n@@ -292,7 +297,9 @@ where\n         terminator: &Terminator<'tcx>,\n         _location: Location,\n     ) {\n-        self.0.handle_terminator(terminator, state);\n+        if state.is_reachable() {\n+            self.0.handle_terminator(terminator, state);\n+        }\n     }\n \n     fn apply_call_return_effect(\n@@ -301,7 +308,9 @@ where\n         _block: BasicBlock,\n         return_places: crate::CallReturnPlaces<'_, 'tcx>,\n     ) {\n-        self.0.handle_call_return(return_places, state)\n+        if state.is_reachable() {\n+            self.0.handle_call_return(return_places, state)\n+        }\n     }\n \n     fn apply_switch_int_edge_effects(\n@@ -310,6 +319,7 @@ where\n         discr: &Operand<'tcx>,\n         apply_edge_effects: &mut impl SwitchIntEdgeEffects<Self::Domain>,\n     ) {\n+        // FIXME: Dataflow framework provides no access to current state here.\n         self.0.handle_switch_int(discr, apply_edge_effects)\n     }\n }\n@@ -323,15 +333,31 @@ rustc_index::newtype_index!(\n );\n \n #[derive(PartialEq, Eq, Clone, Debug)]\n-pub struct State<V>(IndexVec<ValueIndex, V>);\n+enum StateData<V> {\n+    Reachable(IndexVec<ValueIndex, V>),\n+    Unreachable,\n+}\n+\n+/// All operations on unreachable states are ignored.\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+pub struct State<V>(StateData<V>);\n \n impl<V: Clone + HasTop> State<V> {\n+    pub fn is_reachable(&self) -> bool {\n+        matches!(&self.0, StateData::Reachable(_))\n+    }\n+\n+    pub fn mark_unreachable(&mut self) {\n+        self.0 = StateData::Unreachable;\n+    }\n+\n     pub fn flood_all(&mut self) {\n         self.flood_all_with(V::top())\n     }\n \n     pub fn flood_all_with(&mut self, value: V) {\n-        self.0.raw.fill(value);\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        values.raw.fill(value);\n     }\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n@@ -345,9 +371,10 @@ impl<V: Clone + HasTop> State<V> {\n     }\n \n     pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n         map.preorder_invoke(place, &mut |place| {\n             if let Some(vi) = map.places[place].value_index {\n-                self.0[vi] = value.clone();\n+                values[vi] = value.clone();\n             }\n         });\n     }\n@@ -357,11 +384,12 @@ impl<V: Clone + HasTop> State<V> {\n     }\n \n     pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n-                self.0[target_value] = self.0[source_value].clone();\n+                values[target_value] = values[source_value].clone();\n             } else {\n-                self.0[target_value] = V::top();\n+                values[target_value] = V::top();\n             }\n         }\n         for target_child in map.children(target) {\n@@ -389,14 +417,16 @@ impl<V: Clone + HasTop> State<V> {\n                 // First flood the target place in case we also track any projections (although\n                 // this scenario is currently not well-supported by the API).\n                 self.flood_idx(target, map);\n+                let StateData::Reachable(values) = &mut self.0 else { return };\n                 if let Some(value_index) = map.places[target].value_index {\n-                    self.0[value_index] = value;\n+                    values[value_index] = value;\n                 }\n             }\n             ValueOrPlaceOrRef::Place(source) => self.assign_place_idx(target, source, map),\n             ValueOrPlaceOrRef::Ref(source) => {\n+                let StateData::Reachable(values) = &mut self.0 else { return };\n                 if let Some(value_index) = map.places[target].value_index {\n-                    self.0[value_index] = V::top();\n+                    values[value_index] = V::top();\n                 }\n                 if let Some(target_deref) = map.apply_elem(target, ProjElem::Deref) {\n                     self.assign_place_idx(target_deref, source, map);\n@@ -413,13 +443,25 @@ impl<V: Clone + HasTop> State<V> {\n     }\n \n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n-        map.places[place].value_index.map(|v| self.0[v].clone()).unwrap_or(V::top())\n+        match &self.0 {\n+            StateData::Reachable(values) => {\n+                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::top())\n+            }\n+            StateData::Unreachable => V::top(),\n+        }\n     }\n }\n \n-impl<V: JoinSemiLattice> JoinSemiLattice for State<V> {\n+impl<V: JoinSemiLattice + Clone> JoinSemiLattice for State<V> {\n     fn join(&mut self, other: &Self) -> bool {\n-        self.0.join(&other.0)\n+        match (&mut self.0, &other.0) {\n+            (_, StateData::Unreachable) => false,\n+            (StateData::Unreachable, _) => {\n+                *self = other.clone();\n+                true\n+            }\n+            (StateData::Reachable(this), StateData::Reachable(other)) => this.join(other),\n+        }\n     }\n }\n \n@@ -692,18 +734,18 @@ fn iter_fields<'tcx>(\n fn debug_with_context_rec<V: Debug + Eq>(\n     place: PlaceIndex,\n     place_str: &str,\n-    new: &State<V>,\n-    old: Option<&State<V>>,\n+    new: &IndexVec<ValueIndex, V>,\n+    old: Option<&IndexVec<ValueIndex, V>>,\n     map: &Map,\n     f: &mut Formatter<'_>,\n ) -> std::fmt::Result {\n     if let Some(value) = map.places[place].value_index {\n         match old {\n-            None => writeln!(f, \"{}: {:?}\", place_str, new.0[value])?,\n+            None => writeln!(f, \"{}: {:?}\", place_str, new[value])?,\n             Some(old) => {\n-                if new.0[value] != old.0[value] {\n-                    writeln!(f, \"\\u{001f}-{}: {:?}\", place_str, old.0[value])?;\n-                    writeln!(f, \"\\u{001f}+{}: {:?}\", place_str, new.0[value])?;\n+                if new[value] != old[value] {\n+                    writeln!(f, \"\\u{001f}-{}: {:?}\", place_str, old[value])?;\n+                    writeln!(f, \"\\u{001f}+{}: {:?}\", place_str, new[value])?;\n                 }\n             }\n         }\n@@ -729,8 +771,8 @@ fn debug_with_context_rec<V: Debug + Eq>(\n }\n \n fn debug_with_context<V: Debug + Eq>(\n-    new: &State<V>,\n-    old: Option<&State<V>>,\n+    new: &IndexVec<ValueIndex, V>,\n+    old: Option<&IndexVec<ValueIndex, V>>,\n     map: &Map,\n     f: &mut Formatter<'_>,\n ) -> std::fmt::Result {\n@@ -748,7 +790,10 @@ where\n     T::Value: Debug,\n {\n     fn fmt_with(&self, ctxt: &ValueAnalysisWrapper<T>, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        debug_with_context(self, None, ctxt.0.map(), f)\n+        match &self.0 {\n+            StateData::Reachable(values) => debug_with_context(values, None, ctxt.0.map(), f),\n+            StateData::Unreachable => write!(f, \"unreachable\"),\n+        }\n     }\n \n     fn fmt_diff_with(\n@@ -757,6 +802,11 @@ where\n         ctxt: &ValueAnalysisWrapper<T>,\n         f: &mut Formatter<'_>,\n     ) -> std::fmt::Result {\n-        debug_with_context(self, Some(old), ctxt.0.map(), f)\n+        match (&self.0, &old.0) {\n+            (StateData::Reachable(this), StateData::Reachable(old)) => {\n+                debug_with_context(this, Some(old), ctxt.0.map(), f)\n+            }\n+            _ => Ok(()), // Consider printing something here.\n+        }\n     }\n }"}, {"sha": "1cc4201a94982f5ee66a32df557e2b5704f8c560", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe84bbf844cec89db7726f835517151e08ff2597/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe84bbf844cec89db7726f835517151e08ff2597/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=fe84bbf844cec89db7726f835517151e08ff2597", "patch": "@@ -148,7 +148,6 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n     ) {\n         // FIXME: The dataflow framework only provides the state if we call `apply()`, which makes\n         // this more inefficient than it has to be.\n-        // FIXME: Perhaps we rather need a proper unreachability flag for every block.\n         let mut discr_value = None;\n         let mut handled = false;\n         apply_edge_effects.apply(|state, target| {\n@@ -181,8 +180,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                 // Branch is taken. Has no effect on state.\n                 handled = true;\n             } else {\n-                // Branch is not taken, we can flood everything with bottom.\n-                state.flood_all_with(FlatSet::Bottom);\n+                // Branch is not taken.\n+                state.mark_unreachable();\n             }\n         })\n     }"}, {"sha": "b2c2ba6fa5c635423e4c056d8c8c43d5c84f3f9b", "filename": "src/test/mir-opt/dataflow-const-prop/if.main.DataflowConstProp.diff", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe84bbf844cec89db7726f835517151e08ff2597/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe84bbf844cec89db7726f835517151e08ff2597/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff?ref=fe84bbf844cec89db7726f835517151e08ff2597", "patch": "@@ -65,8 +65,10 @@\n           StorageDead(_3);                 // scope 1 at $DIR/if.rs:+3:40: +3:41\n           StorageLive(_6);                 // scope 2 at $DIR/if.rs:+4:9: +4:10\n           StorageLive(_7);                 // scope 2 at $DIR/if.rs:+4:13: +4:14\n-          _7 = _2;                         // scope 2 at $DIR/if.rs:+4:13: +4:14\n-          _6 = Add(move _7, const 1_i32);  // scope 2 at $DIR/if.rs:+4:13: +4:18\n+-         _7 = _2;                         // scope 2 at $DIR/if.rs:+4:13: +4:14\n+-         _6 = Add(move _7, const 1_i32);  // scope 2 at $DIR/if.rs:+4:13: +4:18\n++         _7 = const 2_i32;                // scope 2 at $DIR/if.rs:+4:13: +4:14\n++         _6 = const 3_i32;                // scope 2 at $DIR/if.rs:+4:13: +4:18\n           StorageDead(_7);                 // scope 2 at $DIR/if.rs:+4:17: +4:18\n           StorageLive(_8);                 // scope 3 at $DIR/if.rs:+6:9: +6:10\n           StorageLive(_9);                 // scope 3 at $DIR/if.rs:+6:16: +6:24"}, {"sha": "881d80f7c032606fa969eddf7adc8d4db00b2e89", "filename": "src/test/mir-opt/dataflow-const-prop/issue_81605.f.DataflowConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe84bbf844cec89db7726f835517151e08ff2597/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe84bbf844cec89db7726f835517151e08ff2597/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff?ref=fe84bbf844cec89db7726f835517151e08ff2597", "patch": "@@ -26,7 +26,8 @@\n   \n       bb3: {\n           StorageDead(_2);                 // scope 0 at $DIR/issue_81605.rs:+1:32: +1:33\n-          _0 = Add(const 1_usize, move _1); // scope 0 at $DIR/issue_81605.rs:+1:5: +1:33\n+-         _0 = Add(const 1_usize, move _1); // scope 0 at $DIR/issue_81605.rs:+1:5: +1:33\n++         _0 = const 2_usize;              // scope 0 at $DIR/issue_81605.rs:+1:5: +1:33\n           StorageDead(_1);                 // scope 0 at $DIR/issue_81605.rs:+1:32: +1:33\n           return;                          // scope 0 at $DIR/issue_81605.rs:+2:2: +2:2\n       }"}]}