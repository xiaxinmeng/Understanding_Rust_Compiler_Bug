{"sha": "3c17903c36320646aedf6ba7e13f7623703b2e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMTc5MDNjMzYzMjA2NDZhZWRmNmJhN2UxM2Y3NjIzNzAzYjJlOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T13:06:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T13:06:04Z"}, "message": "auto merge of #9131 : Dretch/rust/glob-range-patterns, r=alexcrichton\n\nThis feature was overlooked in the original pull request (#8914).\r\n\r\nr? @alexcrichton", "tree": {"sha": "d11f9d6aa123dbc4cd3c222c322e5137284ba819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d11f9d6aa123dbc4cd3c222c322e5137284ba819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c17903c36320646aedf6ba7e13f7623703b2e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c17903c36320646aedf6ba7e13f7623703b2e9d", "html_url": "https://github.com/rust-lang/rust/commit/3c17903c36320646aedf6ba7e13f7623703b2e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c17903c36320646aedf6ba7e13f7623703b2e9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "html_url": "https://github.com/rust-lang/rust/commit/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73"}, {"sha": "ef08b2339db40b12b7061da1b18a406fd1b94983", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef08b2339db40b12b7061da1b18a406fd1b94983", "html_url": "https://github.com/rust-lang/rust/commit/ef08b2339db40b12b7061da1b18a406fd1b94983"}], "stats": {"total": 140, "additions": 126, "deletions": 14}, "files": [{"sha": "07386b41caac0bac312c0ddcafee8e9c6572184e", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 126, "deletions": 14, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3c17903c36320646aedf6ba7e13f7623703b2e9d/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c17903c36320646aedf6ba7e13f7623703b2e9d/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=3c17903c36320646aedf6ba7e13f7623703b2e9d", "patch": "@@ -147,8 +147,14 @@ enum PatternToken {\n     Char(char),\n     AnyChar,\n     AnySequence,\n-    AnyWithin(~[char]),\n-    AnyExcept(~[char])\n+    AnyWithin(~[CharSpecifier]),\n+    AnyExcept(~[CharSpecifier])\n+}\n+\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+enum CharSpecifier {\n+    SingleChar(char),\n+    CharRange(char, char)\n }\n \n #[deriving(Eq)]\n@@ -164,12 +170,15 @@ impl Pattern {\n      * This function compiles Unix shell style patterns: `?` matches any single character,\n      * `*` matches any (possibly empty) sequence of characters and `[...]` matches any character\n      * inside the brackets, unless the first character is `!` in which case it matches any\n-     * character except those between the `!` and the `]`.\n+     * character except those between the `!` and the `]`. Character sequences can also specify\n+     * ranges of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any character\n+     * between 0 and 9 inclusive.\n      *\n      * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`).\n      * When a `]` occurs immediately following `[` or `[!` then it is interpreted as\n      * being part of, rather then ending, the character set, so `]` and NOT `]` can be\n-     * matched by `[]]` and `[!]]` respectively.\n+     * matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a\n+     * character sequence pattern by placing it at the start or the end, e.g. `[abc-]`.\n      *\n      * When a `[` does not have a closing `]` before the end of the string then the `[` will\n      * be treated literally.\n@@ -199,7 +208,8 @@ impl Pattern {\n                         match chars.slice_from(i + 3).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n-                                tokens.push(AnyExcept(chars.slice(i + 2, i + 3 + j).to_owned()));\n+                                let cs = parse_char_specifiers(chars.slice(i + 2, i + 3 + j));\n+                                tokens.push(AnyExcept(cs));\n                                 i += j + 4;\n                                 loop;\n                             }\n@@ -209,7 +219,8 @@ impl Pattern {\n                         match chars.slice_from(i + 2).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n-                                tokens.push(AnyWithin(chars.slice(i + 1, i + 2 + j).to_owned()));\n+                                let cs = parse_char_specifiers(chars.slice(i + 1, i + 2 + j));\n+                                tokens.push(AnyWithin(cs));\n                                 i += j + 3;\n                                 loop;\n                             }\n@@ -335,15 +346,11 @@ impl Pattern {\n                         AnyChar => {\n                             !require_literal(c)\n                         }\n-                        AnyWithin(ref chars) => {\n-                            !require_literal(c) &&\n-                            chars.iter()\n-                                .rposition(|&e| chars_eq(e, c, options.case_sensitive)).is_some()\n+                        AnyWithin(ref specifiers) => {\n+                            !require_literal(c) && in_char_specifiers(*specifiers, c, options)\n                         }\n-                        AnyExcept(ref chars) => {\n-                            !require_literal(c) &&\n-                            chars.iter()\n-                                .rposition(|&e| chars_eq(e, c, options.case_sensitive)).is_none()\n+                        AnyExcept(ref specifiers) => {\n+                            !require_literal(c) && !in_char_specifiers(*specifiers, c, options)\n                         }\n                         Char(c2) => {\n                             chars_eq(c, c2, options.case_sensitive)\n@@ -370,6 +377,63 @@ impl Pattern {\n \n }\n \n+fn parse_char_specifiers(s: &[char]) -> ~[CharSpecifier] {\n+    let mut cs = ~[];\n+    let mut i = 0;\n+    while i < s.len() {\n+        if i + 3 <= s.len() && s[i + 1] == '-' {\n+            cs.push(CharRange(s[i], s[i + 2]));\n+            i += 3;\n+        } else {\n+            cs.push(SingleChar(s[i]));\n+            i += 1;\n+        }\n+    }\n+    cs\n+}\n+\n+fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool {\n+\n+    for &specifier in specifiers.iter() {\n+        match specifier {\n+            SingleChar(sc) => {\n+                if chars_eq(c, sc, options.case_sensitive) {\n+                    return true;\n+                }\n+            }\n+            CharRange(start, end) => {\n+\n+                // FIXME: work with non-ascii chars properly (issue #1347)\n+                if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii() {\n+\n+                    let start = start.to_ascii().to_lower();\n+                    let end = end.to_ascii().to_lower();\n+\n+                    let start_up = start.to_upper();\n+                    let end_up = end.to_upper();\n+\n+                    // only allow case insensitive matching when\n+                    // both start and end are within a-z or A-Z\n+                    if start != start_up && end != end_up {\n+                        let start = start.to_char();\n+                        let end = end.to_char();\n+                        let c = c.to_ascii().to_lower().to_char();\n+                        if c >= start && c <= end {\n+                            return true;\n+                        }\n+                    }\n+                }\n+\n+                if c >= start && c <= end {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n /// A helper function to determine if two chars are (possibly case-insensitively) equal.\n fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n     if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n@@ -672,6 +736,54 @@ mod test {\n         glob(\"/*/*/*/*\").skip(10000).next();\n     }\n \n+    #[test]\n+    fn test_range_pattern() {\n+\n+        let pat = Pattern::new(\"a[0-9]b\");\n+        for i in range(0, 10) {\n+            assert!(pat.matches(fmt!(\"a%db\", i)));\n+        }\n+        assert!(!pat.matches(\"a_b\"));\n+\n+        let pat = Pattern::new(\"a[!0-9]b\");\n+        for i in range(0, 10) {\n+            assert!(!pat.matches(fmt!(\"a%db\", i)));\n+        }\n+        assert!(pat.matches(\"a_b\"));\n+\n+        let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"];\n+        for &p in pats.iter() {\n+            let pat = Pattern::new(p);\n+            for c in \"abcdefghijklmnopqrstuvwxyz\".iter() {\n+                assert!(pat.matches(c.to_str()));\n+            }\n+            for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".iter() {\n+                let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n+                assert!(pat.matches_with(c.to_str(), options));\n+            }\n+            assert!(pat.matches(\"1\"));\n+            assert!(pat.matches(\"2\"));\n+            assert!(pat.matches(\"3\"));\n+        }\n+\n+        let pats = [\"[abc-]\", \"[-abc]\", \"[a-c-]\"];\n+        for &p in pats.iter() {\n+            let pat = Pattern::new(p);\n+            assert!(pat.matches(\"a\"));\n+            assert!(pat.matches(\"b\"));\n+            assert!(pat.matches(\"c\"));\n+            assert!(pat.matches(\"-\"));\n+            assert!(!pat.matches(\"d\"));\n+        }\n+\n+        let pat = Pattern::new(\"[2-1]\");\n+        assert!(!pat.matches(\"1\"));\n+        assert!(!pat.matches(\"2\"));\n+\n+        assert!(Pattern::new(\"[-]\").matches(\"-\"));\n+        assert!(!Pattern::new(\"[!-]\").matches(\"-\"));\n+    }\n+\n     #[test]\n     fn test_unclosed_bracket() {\n         // unclosed `[` should be treated literally"}]}