{"sha": "c24946e9c68e4543686cf11c392837d4cffea361", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNDk0NmU5YzY4ZTQ1NDM2ODZjZjExYzM5MjgzN2Q0Y2ZmZWEzNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-25T21:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-25T21:01:42Z"}, "message": "auto merge of #12493 : eddyb/rust/saner-overloads, r=nikomatsakis\n\nFixes #12402.", "tree": {"sha": "44eeb36ec03907aa08dd39050f5d66657a3f351c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44eeb36ec03907aa08dd39050f5d66657a3f351c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c24946e9c68e4543686cf11c392837d4cffea361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c24946e9c68e4543686cf11c392837d4cffea361", "html_url": "https://github.com/rust-lang/rust/commit/c24946e9c68e4543686cf11c392837d4cffea361", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c24946e9c68e4543686cf11c392837d4cffea361/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc1c06d7b1202a0cc7c09bcfeca88ada3fbfb091", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc1c06d7b1202a0cc7c09bcfeca88ada3fbfb091", "html_url": "https://github.com/rust-lang/rust/commit/fc1c06d7b1202a0cc7c09bcfeca88ada3fbfb091"}, {"sha": "39504719b4226f1257b28f33ab626348e9d01409", "url": "https://api.github.com/repos/rust-lang/rust/commits/39504719b4226f1257b28f33ab626348e9d01409", "html_url": "https://github.com/rust-lang/rust/commit/39504719b4226f1257b28f33ab626348e9d01409"}], "stats": {"total": 470, "additions": 193, "deletions": 277}, "files": [{"sha": "5dc18bc08f18eb92f3b67664373f295407388653", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 75, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c24946e9c68e4543686cf11c392837d4cffea361", "patch": "@@ -46,7 +46,7 @@ struct binding_info {\n type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = HashMap<NodeId,@RefCell<~[DefId]>>;\n+pub type TraitMap = HashMap<NodeId, ~[DefId]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n@@ -5255,75 +5255,14 @@ impl Resolver {\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, @RefCell::new(traits));\n+                self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(_, ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, @RefCell::new(traits));\n-            }\n-            ExprBinary(_, BiAdd, _, _) | ExprAssignOp(_, BiAdd, _, _) => {\n-                let i = self.lang_items.add_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiSub, _, _) | ExprAssignOp(_, BiSub, _, _) => {\n-                let i = self.lang_items.sub_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiMul, _, _) | ExprAssignOp(_, BiMul, _, _) => {\n-                let i = self.lang_items.mul_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiDiv, _, _) | ExprAssignOp(_, BiDiv, _, _) => {\n-                let i = self.lang_items.div_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiRem, _, _) | ExprAssignOp(_, BiRem, _, _) => {\n-                let i = self.lang_items.rem_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiBitXor, _, _) | ExprAssignOp(_, BiBitXor, _, _) => {\n-                let i = self.lang_items.bitxor_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiBitAnd, _, _) | ExprAssignOp(_, BiBitAnd, _, _) => {\n-                let i = self.lang_items.bitand_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiBitOr, _, _) | ExprAssignOp(_, BiBitOr, _, _) => {\n-                let i = self.lang_items.bitor_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiShl, _, _) | ExprAssignOp(_, BiShl, _, _) => {\n-                let i = self.lang_items.shl_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiShr, _, _) | ExprAssignOp(_, BiShr, _, _) => {\n-                let i = self.lang_items.shr_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiLt, _, _) | ExprBinary(_, BiLe, _, _) |\n-            ExprBinary(_, BiGe, _, _) | ExprBinary(_, BiGt, _, _) => {\n-                let i = self.lang_items.ord_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprBinary(_, BiEq, _, _) | ExprBinary(_, BiNe, _, _) => {\n-                let i = self.lang_items.eq_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprUnary(_, UnNeg, _) => {\n-                let i = self.lang_items.neg_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprUnary(_, UnNot, _) => {\n-                let i = self.lang_items.not_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n-            }\n-            ExprIndex(..) => {\n-                let i = self.lang_items.index_trait();\n-                self.add_fixed_trait_for_expr(expr.id, i);\n+                self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n                 // Nothing to do.\n@@ -5417,17 +5356,6 @@ impl Resolver {\n         found_traits.push(trait_def_id);\n     }\n \n-    fn add_fixed_trait_for_expr(&mut self,\n-                                    expr_id: NodeId,\n-                                    trait_id: Option<DefId>) {\n-        match trait_id {\n-            Some(trait_id) => {\n-                self.trait_map.insert(expr_id, @RefCell::new(~[trait_id]));\n-            }\n-            None => {}\n-        }\n-    }\n-\n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n         debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n                 def, node_id, lp);"}, {"sha": "4695521d0d91c76764f7ba3f46ead6b1bd1a1cde", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c24946e9c68e4543686cf11c392837d4cffea361", "patch": "@@ -81,7 +81,6 @@ obtained the type `Foo`, we would never match this method.\n \n \n use middle::subst::Subst;\n-use middle::resolve;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n@@ -134,15 +133,14 @@ pub fn lookup(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<method_origin> {\n-    let impl_dups = @RefCell::new(HashSet::new());\n     let lcx = LookupContext {\n         fcx: fcx,\n         expr: expr,\n         self_expr: self_expr,\n         callee_id: callee_id,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: impl_dups,\n+        impl_dups: @RefCell::new(HashSet::new()),\n         inherent_candidates: @RefCell::new(~[]),\n         extension_candidates: @RefCell::new(~[]),\n         deref_args: deref_args,\n@@ -164,11 +162,50 @@ pub fn lookup(\n \n     debug!(\"searching extension candidates\");\n     lcx.reset_candidates();\n-    lcx.push_bound_candidates(self_ty);\n+    lcx.push_bound_candidates(self_ty, None);\n     lcx.push_extension_candidates();\n     return lcx.search(self_ty);\n }\n \n+pub fn lookup_in_trait(\n+        fcx: @FnCtxt,\n+\n+        // In a call `a.b::<X, Y, ...>(...)`:\n+        expr: &ast::Expr,                   // The expression `a.b(...)`.\n+        self_expr: &ast::Expr,              // The expression `a`.\n+        callee_id: NodeId,                  /* Where to store `a.b`'s type,\n+                                             * also the scope of the call */\n+        m_name: ast::Name,                  // The name `b`.\n+        trait_did: DefId,                   // The trait to limit the lookup to.\n+        self_ty: ty::t,                     // The type of `a`.\n+        supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+        autoderef_receiver: AutoderefReceiverFlag)\n+     -> Option<method_origin> {\n+    let lcx = LookupContext {\n+        fcx: fcx,\n+        expr: expr,\n+        self_expr: self_expr,\n+        callee_id: callee_id,\n+        m_name: m_name,\n+        supplied_tps: supplied_tps,\n+        impl_dups: @RefCell::new(HashSet::new()),\n+        inherent_candidates: @RefCell::new(~[]),\n+        extension_candidates: @RefCell::new(~[]),\n+        deref_args: check::DoDerefArgs,\n+        check_traits: CheckTraitsOnly,\n+        autoderef_receiver: autoderef_receiver,\n+    };\n+\n+    let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n+    debug!(\"method lookup_in_trait(self_ty={}, expr={}, self_expr={})\",\n+           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()));\n+\n+    lcx.push_bound_candidates(self_ty, Some(trait_did));\n+    lcx.push_extension_candidate(trait_did);\n+    lcx.search(self_ty)\n+}\n+\n pub struct LookupContext<'a> {\n     fcx: @FnCtxt,\n     expr: &'a ast::Expr,\n@@ -319,17 +356,17 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn push_bound_candidates(&self, self_ty: ty::t) {\n+    fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(self_ty, p);\n+                    self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n                 ty_self(..) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(self_ty);\n+                    self.push_inherent_candidates_from_self(self_ty, restrict_to);\n                 }\n                 _ => { /* No bound methods in these types */ }\n             }\n@@ -341,32 +378,27 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n+    fn push_extension_candidate(&self, trait_did: DefId) {\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n+\n+        // Look for explicit implementations.\n+        let trait_impls = self.tcx().trait_impls.borrow();\n+        for impl_infos in trait_impls.get().find(&trait_did).iter() {\n+            for impl_info in impl_infos.borrow().get().iter() {\n+                self.push_candidates_from_impl(\n+                    self.extension_candidates.borrow_mut().get(), *impl_info);\n+            }\n+        }\n+    }\n+\n     fn push_extension_candidates(&self) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let trait_map: &resolve::TraitMap = &self.fcx.ccx.trait_map;\n-        let opt_applicable_traits = trait_map.find(&self.expr.id);\n-        for applicable_traits in opt_applicable_traits.iter() {\n-            let applicable_traits = applicable_traits.borrow();\n-            for trait_did in applicable_traits.get().iter() {\n-                ty::populate_implementations_for_trait_if_necessary(\n-                    self.tcx(),\n-                    *trait_did);\n-\n-                // Look for explicit implementations.\n-                let trait_impls = self.tcx().trait_impls.borrow();\n-                let opt_impl_infos = trait_impls.get().find(trait_did);\n-                for impl_infos in opt_impl_infos.iter() {\n-                    let impl_infos = impl_infos.borrow();\n-                    for impl_info in impl_infos.get().iter() {\n-                        let mut extension_candidates =\n-                            self.extension_candidates.borrow_mut();\n-                        self.push_candidates_from_impl(\n-                            extension_candidates.get(), *impl_info);\n-\n-                    }\n-                }\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&self.expr.id);\n+        for applicable_traits in opt_applicable_traits.move_iter() {\n+            for trait_did in applicable_traits.iter() {\n+                self.push_extension_candidate(*trait_did);\n             }\n         }\n     }\n@@ -428,7 +460,7 @@ impl<'a> LookupContext<'a> {\n                 self.construct_transformed_self_ty_for_object(\n                     did, &rcvr_substs, &m);\n \n-            Candidate {\n+            Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n                 rcvr_substs: new_trait_ref.substs.clone(),\n                 method_ty: @m,\n@@ -438,49 +470,61 @@ impl<'a> LookupContext<'a> {\n                         method_num: method_num,\n                         real_index: vtable_index\n                     })\n-            }\n+            })\n         });\n     }\n \n     fn push_inherent_candidates_from_param(&self,\n                                            rcvr_ty: ty::t,\n+                                           restrict_to: Option<DefId>,\n                                            param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n             self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n+            restrict_to,\n             param_numbered(param_ty.idx));\n     }\n \n \n     fn push_inherent_candidates_from_self(&self,\n-                                          rcvr_ty: ty::t) {\n+                                          rcvr_ty: ty::t,\n+                                          restrict_to: Option<DefId>) {\n         debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n             [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            restrict_to,\n             param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&self,\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n+                                            restrict_to: Option<DefId>,\n                                             param: param_index) {\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n             |trait_ref, m, method_num, bound_num| {\n-            Candidate {\n-                rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n-                rcvr_substs: trait_ref.substs.clone(),\n-                method_ty: m,\n-                origin: method_param(\n-                                     method_param {\n+                match restrict_to {\n+                    Some(trait_did) => {\n+                        if trait_did != trait_ref.def_id {\n+                            return None;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                Some(Candidate {\n+                    rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n+                    rcvr_substs: trait_ref.substs.clone(),\n+                    method_ty: m,\n+                    origin: method_param(method_param {\n                         trait_id: trait_ref.def_id,\n                         method_num: method_num,\n                         param_num: param,\n                         bound_num: bound_num,\n                     })\n-            }\n+                })\n         })\n     }\n \n@@ -492,7 +536,7 @@ impl<'a> LookupContext<'a> {\n                                                             m: @ty::Method,\n                                                             method_num: uint,\n                                                             bound_num: uint|\n-                                                            -> Candidate) {\n+                                                            -> Option<Candidate>) {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -508,17 +552,17 @@ impl<'a> LookupContext<'a> {\n                 Some(pos) => {\n                     let method = trait_methods[pos];\n \n-                    let cand = mk_cand(bound_trait_ref, method,\n-                                       pos, this_bound_idx);\n-\n-                    debug!(\"pushing inherent candidate for param: {:?}\", cand);\n-                    let mut inherent_candidates = self.inherent_candidates\n-                                                      .borrow_mut();\n-                    inherent_candidates.get().push(cand);\n+                    match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n+                        Some(cand) => {\n+                            debug!(\"pushing inherent candidate for param: {:?}\", cand);\n+                            self.inherent_candidates.borrow_mut().get().push(cand);\n+                        }\n+                        None => {}\n+                    }\n                 }\n                 None => {\n                     debug!(\"trait doesn't contain method: {:?}\",\n-                    bound_trait_ref.def_id);\n+                        bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n             }"}, {"sha": "0b26bb1b218229248e78bea9d60b1ffd95a833e6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 70, "deletions": 106, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c24946e9c68e4543686cf11c392837d4cffea361", "patch": "@@ -96,7 +96,7 @@ use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n-use middle::typeck::check::method::{CheckTraitsOnly, DontAutoderefReceiver};\n+use middle::typeck::check::method::{DontAutoderefReceiver};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n@@ -1936,35 +1936,34 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         op_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n+                        trait_did: Option<ast::DefId>,\n                         args: &[@ast::Expr],\n-                        deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: ||,\n-                        _expected_result: Option<ty::t>\n-                       )\n-                     -> ty::t {\n-        match method::lookup(fcx, op_ex, args[0],\n-                             callee_id, opname, self_t, [],\n-                             deref_args, CheckTraitsOnly, autoderef_receiver) {\n-            Some(ref origin) => {\n+                        unbound_method: ||) -> ty::t {\n+        let origin = match trait_did {\n+            Some(trait_did) => {\n+                method::lookup_in_trait(fcx, op_ex, args[0], callee_id, opname,\n+                                        trait_did, self_t, [], autoderef_receiver)\n+            }\n+            None => None\n+        };\n+        match origin {\n+            Some(origin) => {\n                 let method_ty = fcx.node_ty(callee_id);\n                 let method_map = fcx.inh.method_map;\n-                {\n-                    let mut method_map = method_map.borrow_mut();\n-                    method_map.get().insert(op_ex.id, *origin);\n-                }\n+                method_map.borrow_mut().get().insert(op_ex.id, origin);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n-                                            args, deref_args)\n+                                            args, DoDerefArgs)\n             }\n-            _ => {\n+            None => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err();\n                 check_method_argument_types(fcx, op_ex.span,\n                                             expected_ty, op_ex,\n-                                            args, deref_args);\n+                                            args, DoDerefArgs);\n                 ty::mk_err()\n             }\n         }\n@@ -1977,10 +1976,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                    op: ast::BinOp,\n                    lhs: @ast::Expr,\n                    rhs: @ast::Expr,\n-                   // Used only in the error case\n-                   expected_result: Option<ty::t>,\n-                   is_binop_assignment: IsBinopAssignment\n-                  ) {\n+                   is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         check_expr(fcx, lhs);\n@@ -2004,12 +2000,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n-                ast::BiGt => {\n-                    ty::mk_bool()\n-                }\n-                _ => {\n-                    lhs_t\n-                }\n+                ast::BiGt => ty::mk_bool(),\n+                _ => lhs_t\n             };\n \n             fcx.write_ty(expr.id, result_t);\n@@ -2030,16 +2022,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n \n         // Check for overloaded operators if not an assignment.\n-        let result_t;\n-        if is_binop_assignment == SimpleBinop {\n-            result_t = check_user_binop(fcx,\n-                                        callee_id,\n-                                        expr,\n-                                        lhs,\n-                                        lhs_t,\n-                                        op,\n-                                        rhs,\n-                                        expected_result);\n+        let result_t = if is_binop_assignment == SimpleBinop {\n+            check_user_binop(fcx, callee_id, expr, lhs, lhs_t, op, rhs)\n         } else {\n             fcx.type_error_message(expr.span,\n                                    |actual| {\n@@ -2051,8 +2035,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                    lhs_t,\n                                    None);\n             check_expr(fcx, rhs);\n-            result_t = ty::mk_err();\n-        }\n+            ty::mk_err()\n+        };\n \n         fcx.write_ty(expr.id, result_t);\n         if ty::type_is_error(result_t) {\n@@ -2066,60 +2050,54 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: @ast::Expr,\n-                       expected_result: Option<ty::t>) -> ty::t {\n+                        rhs: @ast::Expr) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n-        match ast_util::binop_to_method_name(op) {\n-            Some(ref name) => {\n-                let if_op_unbound = || {\n-                    fcx.type_error_message(ex.span, |actual| {\n-                        format!(\"binary operation `{}` cannot be applied \\\n-                              to type `{}`\",\n-                             ast_util::binop_to_str(op), actual)},\n-                            lhs_resolved_t, None)\n-                };\n-                return lookup_op_method(fcx, callee_id, ex, lhs_resolved_t,\n-                                        token::intern(*name), [lhs_expr, rhs],\n-                                        DoDerefArgs,DontAutoderefReceiver,\n-                                        if_op_unbound, expected_result);\n+        let lang = tcx.lang_items;\n+        let (name, trait_did) = match op {\n+            ast::BiAdd => (\"add\", lang.add_trait()),\n+            ast::BiSub => (\"sub\", lang.sub_trait()),\n+            ast::BiMul => (\"mul\", lang.mul_trait()),\n+            ast::BiDiv => (\"div\", lang.div_trait()),\n+            ast::BiRem => (\"rem\", lang.rem_trait()),\n+            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+            ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+            ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+            ast::BiShl => (\"shl\", lang.shl_trait()),\n+            ast::BiShr => (\"shr\", lang.shr_trait()),\n+            ast::BiLt => (\"lt\", lang.ord_trait()),\n+            ast::BiLe => (\"le\", lang.ord_trait()),\n+            ast::BiGe => (\"ge\", lang.ord_trait()),\n+            ast::BiGt => (\"gt\", lang.ord_trait()),\n+            ast::BiEq => (\"eq\", lang.eq_trait()),\n+            ast::BiNe => (\"ne\", lang.eq_trait()),\n+            ast::BiAnd | ast::BiOr => {\n+                check_expr(fcx, rhs);\n+                return ty::mk_err();\n             }\n-            None => ()\n         };\n-        check_expr(fcx, rhs);\n-\n-        // If the or operator is used it might be that the user forgot to\n-        // supply the do keyword.  Let's be more helpful in that situation.\n-        if op == ast::BiOr {\n-            match ty::get(lhs_resolved_t).sty {\n-                ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n-                    tcx.sess.span_note(\n-                        ex.span, \"did you forget the `do` keyword for the call?\");\n-                }\n-                _ => ()\n-            }\n-        }\n-\n-        ty::mk_err()\n+        lookup_op_method(fcx, callee_id, ex, lhs_resolved_t, token::intern(name),\n+                         trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n+            fcx.type_error_message(ex.span, |actual| {\n+                format!(\"binary operation `{}` cannot be applied to type `{}`\",\n+                    ast_util::binop_to_str(op), actual)\n+            }, lhs_resolved_t, None)\n+        })\n     }\n \n     fn check_user_unop(fcx: @FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n+                       trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n                        rhs_expr: @ast::Expr,\n-                       rhs_t: ty::t,\n-                       expected_t: Option<ty::t>)\n-                    -> ty::t {\n-       lookup_op_method(\n-            fcx, callee_id, ex, rhs_t, token::intern(mname),\n-            [rhs_expr], DoDerefArgs, DontAutoderefReceiver,\n-            || {\n-                fcx.type_error_message(ex.span, |actual| {\n-                    format!(\"cannot apply unary operator `{}` to type `{}`\",\n-                         op_str, actual)\n-                }, rhs_t, None);\n-            }, expected_t)\n+                       rhs_t: ty::t) -> ty::t {\n+       lookup_op_method(fcx, callee_id, ex, rhs_t, token::intern(mname),\n+                        trait_did, [rhs_expr], DontAutoderefReceiver, || {\n+            fcx.type_error_message(ex.span, |actual| {\n+                format!(\"cannot apply unary operator `{}` to type `{}`\", op_str, actual)\n+            }, rhs_t, None);\n+        })\n     }\n \n     // Resolves `expected` by a single level if it is a variable and passes it\n@@ -2643,14 +2621,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx,\n-                    callee_id,\n-                    expr,\n-                    op,\n-                    lhs,\n-                    rhs,\n-                    expected,\n-                    SimpleBinop);\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, SimpleBinop);\n \n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n@@ -2664,14 +2635,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprAssignOp(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx,\n-                    callee_id,\n-                    expr,\n-                    op,\n-                    lhs,\n-                    rhs,\n-                    expected,\n-                    BinopAssignment);\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, BinopAssignment);\n \n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -2746,18 +2710,19 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n-                        oprnd_t = check_user_unop(fcx, callee_id,\n-                            \"!\", \"not\", expr, oprnd, oprnd_t,\n-                                                  expected);\n+                        oprnd_t = check_user_unop(fcx, callee_id, \"!\", \"not\",\n+                                                  tcx.lang_items.not_trait(),\n+                                                  expr, oprnd, oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n-                        oprnd_t = check_user_unop(fcx, callee_id,\n-                            \"-\", \"neg\", expr, oprnd, oprnd_t, expected);\n+                        oprnd_t = check_user_unop(fcx, callee_id, \"-\", \"neg\",\n+                                                  tcx.lang_items.neg_trait(),\n+                                                  expr, oprnd, oprnd_t);\n                     }\n                 }\n             }\n@@ -3172,11 +3137,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                     expr,\n                                                     resolved,\n                                                     token::intern(\"index\"),\n+                                                    tcx.lang_items.index_trait(),\n                                                     [base, idx],\n-                                                    DoDerefArgs,\n                                                     AutoderefReceiver,\n-                                                    error_message,\n-                                                    expected);\n+                                                    error_message);\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }"}, {"sha": "f6066e5385d6ccfd6bde09417cfef8c43c13b9fe", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24946e9c68e4543686cf11c392837d4cffea361/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c24946e9c68e4543686cf11c392837d4cffea361", "patch": "@@ -79,48 +79,26 @@ pub fn def_id_of_def(d: Def) -> DefId {\n     }\n }\n \n-pub fn binop_to_str(op: BinOp) -> ~str {\n+pub fn binop_to_str(op: BinOp) -> &'static str {\n     match op {\n-      BiAdd => return ~\"+\",\n-      BiSub => return ~\"-\",\n-      BiMul => return ~\"*\",\n-      BiDiv => return ~\"/\",\n-      BiRem => return ~\"%\",\n-      BiAnd => return ~\"&&\",\n-      BiOr => return ~\"||\",\n-      BiBitXor => return ~\"^\",\n-      BiBitAnd => return ~\"&\",\n-      BiBitOr => return ~\"|\",\n-      BiShl => return ~\"<<\",\n-      BiShr => return ~\">>\",\n-      BiEq => return ~\"==\",\n-      BiLt => return ~\"<\",\n-      BiLe => return ~\"<=\",\n-      BiNe => return ~\"!=\",\n-      BiGe => return ~\">=\",\n-      BiGt => return ~\">\"\n-    }\n-}\n-\n-pub fn binop_to_method_name(op: BinOp) -> Option<~str> {\n-    match op {\n-      BiAdd => return Some(~\"add\"),\n-      BiSub => return Some(~\"sub\"),\n-      BiMul => return Some(~\"mul\"),\n-      BiDiv => return Some(~\"div\"),\n-      BiRem => return Some(~\"rem\"),\n-      BiBitXor => return Some(~\"bitxor\"),\n-      BiBitAnd => return Some(~\"bitand\"),\n-      BiBitOr => return Some(~\"bitor\"),\n-      BiShl => return Some(~\"shl\"),\n-      BiShr => return Some(~\"shr\"),\n-      BiLt => return Some(~\"lt\"),\n-      BiLe => return Some(~\"le\"),\n-      BiGe => return Some(~\"ge\"),\n-      BiGt => return Some(~\"gt\"),\n-      BiEq => return Some(~\"eq\"),\n-      BiNe => return Some(~\"ne\"),\n-      BiAnd | BiOr => return None\n+        BiAdd => \"+\",\n+        BiSub => \"-\",\n+        BiMul => \"*\",\n+        BiDiv => \"/\",\n+        BiRem => \"%\",\n+        BiAnd => \"&&\",\n+        BiOr => \"||\",\n+        BiBitXor => \"^\",\n+        BiBitAnd => \"&\",\n+        BiBitOr => \"|\",\n+        BiShl => \"<<\",\n+        BiShr => \">>\",\n+        BiEq => \"==\",\n+        BiLt => \"<\",\n+        BiLe => \"<=\",\n+        BiNe => \"!=\",\n+        BiGe => \">=\",\n+        BiGt => \">\"\n     }\n }\n "}, {"sha": "1f57c4cf93a28a098b888c17518c8efc534ab91d", "filename": "src/test/compile-fail/trait-resolution-in-overloaded-op.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c24946e9c68e4543686cf11c392837d4cffea361/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24946e9c68e4543686cf11c392837d4cffea361/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-resolution-in-overloaded-op.rs?ref=c24946e9c68e4543686cf11c392837d4cffea361", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regression test for issue #2783\n+// #12402 Operator overloading only considers the method name, not which trait is implemented\n \n-fn foo(f: ||) { f() }\n+trait MyMul<Rhs, Res> {\n+    fn mul(&self, rhs: &Rhs) -> Res;\n+}\n \n-fn main() {\n-    ~\"\" || 42; //~ ERROR binary operation `||` cannot be applied to type\n-    foo || {}; //~ ERROR binary operation `||` cannot be applied to type\n-    //~^ NOTE did you forget the `do` keyword for the call?\n+fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 {\n+    a * b //~ ERROR binary operation `*` cannot be applied to type `&T`\n }\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/missing-do.rs"}]}