{"sha": "b0de1e9b9521fe86c94dabd6e21c8dface68379d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZGUxZTliOTUyMWZlODZjOTRkYWJkNmUyMWM4ZGZhY2U2ODM3OWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-02T14:16:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-02T14:16:43Z"}, "message": "Auto merge of #973 - christianpoveda:write-shim, r=oli-obk\n\nEnable file writing\n\nr? @oli-obk", "tree": {"sha": "2eb6ccb5d82fa875df79962501db281ddd890b02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eb6ccb5d82fa875df79962501db281ddd890b02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0de1e9b9521fe86c94dabd6e21c8dface68379d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0de1e9b9521fe86c94dabd6e21c8dface68379d", "html_url": "https://github.com/rust-lang/rust/commit/b0de1e9b9521fe86c94dabd6e21c8dface68379d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0de1e9b9521fe86c94dabd6e21c8dface68379d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "html_url": "https://github.com/rust-lang/rust/commit/1037f69bf6dcf73dfbe06453336eeae61ba7c51f"}, {"sha": "6c36a8c949a3e506b48481d746df85e6596d097d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c36a8c949a3e506b48481d746df85e6596d097d", "html_url": "https://github.com/rust-lang/rust/commit/6c36a8c949a3e506b48481d746df85e6596d097d"}], "stats": {"total": 154, "additions": 110, "deletions": 44}, "files": [{"sha": "847169f38dca6bbac31c3eb89745f2dccd88c138", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0de1e9b9521fe86c94dabd6e21c8dface68379d/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0de1e9b9521fe86c94dabd6e21c8dface68379d/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=b0de1e9b9521fe86c94dabd6e21c8dface68379d", "patch": "@@ -494,9 +494,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Err(_) => -1,\n                     }\n                 } else {\n-                    eprintln!(\"Miri: Ignored output to FD {}\", fd);\n-                    // Pretend it all went well.\n-                    n as i64\n+                    this.write(args[0], args[1], args[2])?\n                 };\n                 // Now, `result` is the value we return back to the program.\n                 this.write_scalar("}, {"sha": "74b8dde5c7fcbfff9ccde03764ebea7247a19a42", "filename": "src/shims/io.rs", "status": "modified", "additions": 91, "deletions": 34, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b0de1e9b9521fe86c94dabd6e21c8dface68379d/src%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0de1e9b9521fe86c94dabd6e21c8dface68379d/src%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fio.rs?ref=b0de1e9b9521fe86c94dabd6e21c8dface68379d", "patch": "@@ -1,6 +1,6 @@\n use std::collections::HashMap;\n-use std::fs::File;\n-use std::io::Read;\n+use std::fs::{File, OpenOptions};\n+use std::io::{Read, Write};\n \n use rustc::ty::layout::Size;\n \n@@ -42,16 +42,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let flag = this.read_scalar(flag_op)?.to_i32()?;\n \n-        if flag != this.eval_libc_i32(\"O_RDONLY\")? && flag != this.eval_libc_i32(\"O_CLOEXEC\")? {\n-            throw_unsup_format!(\"Unsupported flag {:#x}\", flag);\n+        let mut options = OpenOptions::new();\n+\n+        // The first two bits of the flag correspond to the access mode of the file in linux.\n+        let access_mode = flag & 0b11;\n+\n+        if access_mode == this.eval_libc_i32(\"O_RDONLY\")? {\n+            options.read(true);\n+        } else if access_mode == this.eval_libc_i32(\"O_WRONLY\")? {\n+            options.write(true);\n+        } else if access_mode == this.eval_libc_i32(\"O_RDWR\")? {\n+            options.read(true).write(true);\n+        } else {\n+            throw_unsup_format!(\"Unsupported access mode {:#x}\", access_mode);\n+        }\n+\n+        if flag & this.eval_libc_i32(\"O_APPEND\")? != 0 {\n+            options.append(true);\n+        }\n+        if flag & this.eval_libc_i32(\"O_TRUNC\")? != 0 {\n+            options.truncate(true);\n+        }\n+        if flag & this.eval_libc_i32(\"O_CREAT\")? != 0 {\n+            options.create(true);\n         }\n \n         let path_bytes = this\n             .memory()\n             .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n         let path = std::str::from_utf8(path_bytes)\n             .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;\n-        let fd = File::open(path).map(|file| {\n+\n+        let fd = options.open(path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n             fh.handles.insert(fh.low, FileHandle { file, flag });\n@@ -70,7 +92,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         if !this.machine.communicate {\n-            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+            throw_unsup_format!(\"`fcntl` not available when isolation is enabled\")\n         }\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -103,15 +125,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         if !this.machine.communicate {\n-            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+            throw_unsup_format!(\"`close` not available when isolation is enabled\")\n         }\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        this.remove_handle_and(\n-            fd,\n-            |handle, this| this.consume_result(handle.file.sync_all().map(|_| 0i32)),\n-        )\n+        this.remove_handle_and(fd, |handle, this| {\n+            this.consume_result(handle.file.sync_all().map(|_| 0i32))\n+        })\n     }\n \n     fn read(\n@@ -123,38 +144,71 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         if !this.machine.communicate {\n-            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+            throw_unsup_format!(\"`read` not available when isolation is enabled\")\n         }\n \n         let tcx = &{ this.tcx.tcx };\n \n-        let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n         let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        // Reading zero bytes should not change `buf`\n+        if count == 0 {\n+            return Ok(0);\n+        }\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let buf_scalar = this.read_scalar(buf_op)?.not_undef()?;\n \n         // Remove the file handle to avoid borrowing issues\n-        this.remove_handle_and(\n-            fd,\n-            |mut handle, this| {\n-                let bytes = handle\n-                    .file\n-                    .read(this.memory_mut().get_mut(buf.alloc_id)?.get_bytes_mut(\n-                        tcx,\n-                        buf,\n-                        Size::from_bytes(count),\n-                    )?)\n-                    .map(|bytes| bytes as i64);\n-                // Reinsert the file handle\n-                this.machine.file_handler.handles.insert(fd, handle);\n-                this.consume_result(bytes)\n-            },\n-        )\n+        this.remove_handle_and(fd, |mut handle, this| {\n+            // Don't use `?` to avoid returning before reinserting the handle\n+            let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n+                this.memory_mut()\n+                    .get_mut(buf.alloc_id)?\n+                    .get_bytes_mut(tcx, buf, Size::from_bytes(count))\n+                    .map(|buffer| handle.file.read(buffer))\n+            });\n+            // Reinsert the file handle\n+            this.machine.file_handler.handles.insert(fd, handle);\n+            this.consume_result(bytes?.map(|bytes| bytes as i64))\n+        })\n+    }\n+\n+    fn write(\n+        &mut self,\n+        fd_op: OpTy<'tcx, Tag>,\n+        buf_op: OpTy<'tcx, Tag>,\n+        count_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i64> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.machine.communicate {\n+            throw_unsup_format!(\"`write` not available when isolation is enabled\")\n+        }\n+\n+        let tcx = &{ this.tcx.tcx };\n+\n+        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        // Writing zero bytes should not change `buf`\n+        if count == 0 {\n+            return Ok(0);\n+        }\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n+\n+        this.remove_handle_and(fd, |mut handle, this| {\n+            let bytes = this.memory().get(buf.alloc_id).and_then(|alloc| {\n+                alloc\n+                    .get_bytes(tcx, buf, Size::from_bytes(count))\n+                    .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))\n+            });\n+            this.machine.file_handler.handles.insert(fd, handle);\n+            this.consume_result(bytes?)\n+        })\n     }\n \n     /// Helper function that gets a `FileHandle` immutable reference and allows to manipulate it\n-    /// using `f`.\n+    /// using the `f` closure.\n     ///\n-    /// If the `fd` file descriptor does not corresponds to a file, this functions returns `Ok(-1)`\n+    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n     /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n     ///\n     /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n@@ -177,7 +231,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// to modify `MiriEvalContext` at the same time, so you can modify the handle and reinsert it\n     /// using `f`.\n     ///\n-    /// If the `fd` file descriptor does not corresponds to a file, this functions returns `Ok(-1)`\n+    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n     /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n     ///\n     /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n@@ -201,7 +255,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ///\n     /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n     /// functions return different integer types (like `read`, that returns an `i64`)\n-    fn consume_result<T: From<i32>>(&mut self, result: std::io::Result<T>) -> InterpResult<'tcx, T> {\n+    fn consume_result<T: From<i32>>(\n+        &mut self,\n+        result: std::io::Result<T>,\n+    ) -> InterpResult<'tcx, T> {\n         match result {\n             Ok(ok) => Ok(ok),\n             Err(e) => {"}, {"sha": "8ab686eafeb1f44702738c8b0f24f2567c36da6d", "filename": "tests/hello.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Fhello.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Fhello.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fhello.txt?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -1 +0,0 @@\n-Hello, World!"}, {"sha": "666abd65c12e12cb0b079900413983e4a6974646", "filename": "tests/run-pass/file_read.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0de1e9b9521fe86c94dabd6e21c8dface68379d/tests%2Frun-pass%2Ffile_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0de1e9b9521fe86c94dabd6e21c8dface68379d/tests%2Frun-pass%2Ffile_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffile_read.rs?ref=b0de1e9b9521fe86c94dabd6e21c8dface68379d", "patch": "@@ -2,12 +2,24 @@\n // compile-flags: -Zmiri-disable-isolation\n \n use std::fs::File;\n-use std::io::Read;\n+use std::io::{Read, Write};\n \n fn main() {\n-    // FIXME: create the file and delete it when `rm` is implemented.\n-    let mut file = File::open(\"./tests/hello.txt\").unwrap();\n-    let mut contents = String::new();\n-    file.read_to_string(&mut contents).unwrap();\n-    assert_eq!(\"Hello, World!\\n\", contents);\n+    // FIXME: remove the file and delete it when `rm` is implemented.\n+    let path = \"./tests/hello.txt\";\n+    let bytes = b\"Hello, World!\\n\";\n+    // Test creating, writing and closing a file (closing is tested when `file` is dropped).\n+    let mut file = File::create(path).unwrap();\n+    // Writing 0 bytes should not change the file contents.\n+    file.write(&mut []).unwrap();\n+\n+    file.write(bytes).unwrap();\n+    // Test opening, reading and closing a file.\n+    let mut file = File::open(path).unwrap();\n+    let mut contents = Vec::new();\n+    // Reading 0 bytes should not move the file pointer.\n+    file.read(&mut []).unwrap();\n+    // Reading until EOF should get the whole text.\n+    file.read_to_end(&mut contents).unwrap();\n+    assert_eq!(bytes, contents.as_slice());\n }"}]}