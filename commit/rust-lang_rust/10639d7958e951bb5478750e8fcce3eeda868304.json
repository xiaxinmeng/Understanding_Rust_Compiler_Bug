{"sha": "10639d7958e951bb5478750e8fcce3eeda868304", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNjM5ZDc5NThlOTUxYmI1NDc4NzUwZThmY2NlM2VlZGE4NjgzMDQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-19T18:12:18Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-20T16:40:04Z"}, "message": "Add early return, remove `else`, unindent.", "tree": {"sha": "c5784fd75a294074e70e35bcd0712aff36753c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5784fd75a294074e70e35bcd0712aff36753c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10639d7958e951bb5478750e8fcce3eeda868304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10639d7958e951bb5478750e8fcce3eeda868304", "html_url": "https://github.com/rust-lang/rust/commit/10639d7958e951bb5478750e8fcce3eeda868304", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10639d7958e951bb5478750e8fcce3eeda868304/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2436d7374caf1e25bfa8bacfb94c85d6d142332c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2436d7374caf1e25bfa8bacfb94c85d6d142332c", "html_url": "https://github.com/rust-lang/rust/commit/2436d7374caf1e25bfa8bacfb94c85d6d142332c"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "c2fbccf82da946ca7773434f1d490c468e264207", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/10639d7958e951bb5478750e8fcce3eeda868304/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10639d7958e951bb5478750e8fcce3eeda868304/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=10639d7958e951bb5478750e8fcce3eeda868304", "patch": "@@ -708,46 +708,46 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 if predicate.references_error() {\n-                } else {\n-                    // Typically, this ambiguity should only happen if\n-                    // there are unresolved type inference variables\n-                    // (otherwise it would suggest a coherence\n-                    // failure). But given #21974 that is not necessarily\n-                    // the case -- we can have multiple where clauses that\n-                    // are only distinguished by a region, which results\n-                    // in an ambiguity even when all types are fully\n-                    // known, since we don't dispatch based on region\n-                    // relationships.\n-\n-                    // This is kind of a hack: it frequently happens that some earlier\n-                    // error prevents types from being fully inferred, and then we get\n-                    // a bunch of uninteresting errors saying something like \"<generic\n-                    // #0> doesn't implement Sized\".  It may even be true that we\n-                    // could just skip over all checks where the self-ty is an\n-                    // inference variable, but I was afraid that there might be an\n-                    // inference variable created, registered as an obligation, and\n-                    // then never forced by writeback, and hence by skipping here we'd\n-                    // be ignoring the fact that we don't KNOW the type works\n-                    // out. Though even that would probably be harmless, given that\n-                    // we're only talking about builtin traits, which are known to be\n-                    // inhabited. But in any case I just threw in this check for\n-                    // has_errors() to be sure that compilation isn't happening\n-                    // anyway. In that case, why inundate the user.\n-                    if !self.tcx.sess.has_errors() {\n-                        if\n-                            self.tcx.lang_items.sized_trait()\n-                            .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                        {\n-                            self.need_type_info(obligation, self_ty);\n-                        } else {\n-                            let mut err = struct_span_err!(self.tcx.sess,\n-                                                           obligation.cause.span, E0283,\n-                                                           \"type annotations required: \\\n-                                                            cannot resolve `{}`\",\n-                                                           predicate);\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                        }\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. But in any case I just threw in this check for\n+                // has_errors() to be sure that compilation isn't happening\n+                // anyway. In that case, why inundate the user.\n+                if !self.tcx.sess.has_errors() {\n+                    if\n+                        self.tcx.lang_items.sized_trait()\n+                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                    {\n+                        self.need_type_info(obligation, self_ty);\n+                    } else {\n+                        let mut err = struct_span_err!(self.tcx.sess,\n+                                                        obligation.cause.span, E0283,\n+                                                        \"type annotations required: \\\n+                                                        cannot resolve `{}`\",\n+                                                        predicate);\n+                        self.note_obligation_cause(&mut err, obligation);\n+                        err.emit();\n                     }\n                 }\n             }"}]}