{"sha": "1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMTVlOWVmZWIyZjgxNmYyNjE1MDQyYmQ5ZTgxMjVlYmY0OGJjZmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-07-22T09:43:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-28T18:15:34Z"}, "message": "Fix regionck to account for the uniqueness requirements on ref mut reborrows", "tree": {"sha": "cf493b0ac7a66681e9fc4db7a64afda0d4378161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf493b0ac7a66681e9fc4db7a64afda0d4378161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "html_url": "https://github.com/rust-lang/rust/commit/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f60a7c4798e0c7e7b2c6814eb55b35f4b4769fe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f60a7c4798e0c7e7b2c6814eb55b35f4b4769fe2", "html_url": "https://github.com/rust-lang/rust/commit/f60a7c4798e0c7e7b2c6814eb55b35f4b4769fe2"}], "stats": {"total": 299, "additions": 211, "deletions": 88}, "files": [{"sha": "f54e650a173441e42300601809b8b7c43df45051", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 184, "deletions": 84, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "patch": "@@ -1381,8 +1381,8 @@ fn link_by_ref(rcx: &Rcx,\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-    let region_min = ty::ReScope(callee_scope);\n-    link_region(rcx, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n+    let borrow_region = ty::ReScope(callee_scope);\n+    link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n fn link_region_from_node_type(rcx: &Rcx,\n@@ -1408,102 +1408,54 @@ fn link_region_from_node_type(rcx: &Rcx,\n \n fn link_region(rcx: &Rcx,\n                span: Span,\n-               region_min: ty::Region,\n-               kind: ty::BorrowKind,\n-               cmt_borrowed: mc::cmt) {\n+               borrow_region: ty::Region,\n+               borrow_kind: ty::BorrowKind,\n+               borrow_cmt: mc::cmt) {\n     /*!\n-     * Informs the inference engine that a borrow of `cmt`\n-     * must have the borrow kind `kind` and lifetime `region_min`.\n-     * If `cmt` is a deref of a region pointer with\n-     * lifetime `r_borrowed`, this will add the constraint that\n-     * `region_min <= r_borrowed`.\n+     * Informs the inference engine that `borrow_cmt` is being\n+     * borrowed with kind `borrow_kind` and lifetime `borrow_region`.\n+     * In order to ensure borrowck is satisfied, this may create\n+     * constraints between regions, as explained in\n+     * `link_reborrowed_region()`.\n      */\n \n-    // Iterate through all the things that must be live at least\n-    // for the lifetime `region_min` for the borrow to be valid:\n-    let mut cmt_borrowed = cmt_borrowed;\n+    let mut borrow_cmt = borrow_cmt;\n+    let mut borrow_kind = borrow_kind;\n+\n     loop {\n-        debug!(\"link_region(region_min={}, kind={}, cmt_borrowed={})\",\n-               region_min.repr(rcx.tcx()),\n-               kind.repr(rcx.tcx()),\n-               cmt_borrowed.repr(rcx.tcx()));\n-        match cmt_borrowed.cat.clone() {\n-            mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) |\n-            mc::cat_deref(base, _, mc::Implicit(_, r_borrowed)) => {\n-                // References to an upvar `x` are translated to\n-                // `*x`, since that is what happens in the\n-                // underlying machine.  We detect such references\n-                // and treat them slightly differently, both to\n-                // offer better error messages and because we need\n-                // to infer the kind of borrow (mut, const, etc)\n-                // to use for each upvar.\n-                let cause = match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _) => {\n-                        match rcx.fcx.inh.upvar_borrow_map.borrow_mut()\n-                                 .find_mut(upvar_id) {\n-                            Some(upvar_borrow) => {\n-                                debug!(\"link_region: {} <= {}\",\n-                                       region_min.repr(rcx.tcx()),\n-                                       upvar_borrow.region.repr(rcx.tcx()));\n-                                adjust_upvar_borrow_kind_for_loan(\n-                                    *upvar_id,\n-                                    upvar_borrow,\n-                                    kind);\n-                                infer::ReborrowUpvar(span, *upvar_id)\n-                            }\n-                            None => {\n-                                rcx.tcx().sess.span_bug(\n-                                    span,\n-                                    format!(\"Illegal upvar id: {}\",\n-                                            upvar_id.repr(\n-                                                rcx.tcx())).as_slice());\n-                            }\n-                        }\n+        debug!(\"link_region(borrow_region={}, borrow_kind={}, borrow_cmt={})\",\n+               borrow_region.repr(rcx.tcx()),\n+               borrow_kind.repr(rcx.tcx()),\n+               borrow_cmt.repr(rcx.tcx()));\n+        match borrow_cmt.cat.clone() {\n+            mc::cat_deref(ref_cmt, _,\n+                          mc::Implicit(ref_kind, ref_region)) |\n+            mc::cat_deref(ref_cmt, _,\n+                          mc::BorrowedPtr(ref_kind, ref_region)) => {\n+                match link_reborrowed_region(rcx, span,\n+                                             borrow_region, borrow_kind,\n+                                             ref_cmt, ref_region, ref_kind) {\n+                    Some((c, k)) => {\n+                        borrow_cmt = c;\n+                        borrow_kind = k;\n                     }\n-\n-                    _ => {\n-                        infer::Reborrow(span)\n+                    None => {\n+                        return;\n                     }\n-                };\n-\n-                debug!(\"link_region: {} <= {}\",\n-                       region_min.repr(rcx.tcx()),\n-                       r_borrowed.repr(rcx.tcx()));\n-                rcx.fcx.mk_subr(cause, region_min, r_borrowed);\n-\n-                if kind != ty::ImmBorrow {\n-                    // If this is a mutable borrow, then the thing\n-                    // being borrowed will have to be unique.\n-                    // In user code, this means it must be an `&mut`\n-                    // borrow, but for an upvar, we might opt\n-                    // for an immutable-unique borrow.\n-                    adjust_upvar_borrow_kind_for_unique(rcx, base);\n                 }\n-\n-                // Borrowing an `&mut` pointee for `region_min` is\n-                // only valid if the pointer resides in a unique\n-                // location which is itself valid for\n-                // `region_min`.  We don't care about the unique\n-                // part, but we may need to influence the\n-                // inference to ensure that the location remains\n-                // valid.\n-                //\n-                // FIXME(#8624) fixing borrowck will require this\n-                // if m == ast::m_mutbl {\n-                //    cmt_borrowed = cmt_base;\n-                // } else {\n-                //    return;\n-                // }\n-                return;\n             }\n+\n             mc::cat_discr(cmt_base, _) |\n             mc::cat_downcast(cmt_base) |\n             mc::cat_deref(cmt_base, _, mc::GcPtr(..)) |\n             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n             mc::cat_interior(cmt_base, _) => {\n-                // Interior or owned data requires its base to be valid\n-                cmt_borrowed = cmt_base;\n+                // Borrowing interior or owned data requires the base\n+                // to be valid and borrowable in the same fashion.\n+                borrow_cmt = cmt_base;\n+                borrow_kind = borrow_kind;\n             }\n+\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n@@ -1519,6 +1471,154 @@ fn link_region(rcx: &Rcx,\n     }\n }\n \n+fn link_reborrowed_region(rcx: &Rcx,\n+                          span: Span,\n+                          borrow_region: ty::Region,\n+                          borrow_kind: ty::BorrowKind,\n+                          ref_cmt: mc::cmt,\n+                          ref_region: ty::Region,\n+                          ref_kind: ty::BorrowKind)\n+                          -> Option<(mc::cmt, ty::BorrowKind)>\n+{\n+    /*!\n+     * This is the most complicated case: the path being borrowed is\n+     * itself the referent of a borrowed pointer. Let me give an\n+     * example fragment of code to make clear(er) the situation:\n+     *\n+     *    let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n+     *    ...\n+     *    &'z *r                   // the reborrow has lifetime 'z\n+     *\n+     * Now, in this case, our primary job is to add the inference\n+     * constraint that `'z <= 'a`. Given this setup, let's clarify the\n+     * parameters in (roughly) terms of the example:\n+     *\n+     *     A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n+     *     borrow_region   ^~                 ref_region    ^~\n+     *     borrow_kind        ^~               ref_kind        ^~\n+     *     ref_cmt                 ^\n+     *\n+     * Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n+     *\n+     * Unfortunately, there are some complications beyond the simple\n+     * scenario I just painted:\n+     *\n+     * 1. The reference `r` might in fact be a \"by-ref\" upvar. In that\n+     *    case, we have two jobs. First, we are inferring whether this reference\n+     *    should be an `&T`, `&mut T`, or `&uniq T` reference, and we must\n+     *    adjust that based on this borrow (e.g., if this is an `&mut` borrow,\n+     *    then `r` must be an `&mut` reference). Second, whenever we link\n+     *    two regions (here, `'z <= 'a`), we supply a *cause*, and in this\n+     *    case we adjust the cause to indicate that the reference being\n+     *    \"reborrowed\" is itself an upvar. This provides a nicer error message\n+     *    should something go wrong.\n+     *\n+     * 2. There may in fact be more levels of reborrowing. In the\n+     *    example, I said the borrow was like `&'z *r`, but it might\n+     *    in fact be a borrow like `&'z **q` where `q` has type `&'a\n+     *    &'b mut T`. In that case, we want to ensure that `'z <= 'a`\n+     *    and `'z <= 'b`. This is explained more below.\n+     *\n+     * The return value of this function indicates whether we need to\n+     * recurse and process `ref_cmt` (see case 2 above).\n+     */\n+\n+    // Detect references to an upvar `x`:\n+    let cause = match ref_cmt.cat {\n+        mc::cat_upvar(ref upvar_id, _) => {\n+            let mut upvar_borrow_map =\n+                rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+            match upvar_borrow_map.find_mut(upvar_id) {\n+                Some(upvar_borrow) => {\n+                    // Adjust mutability that we infer for the upvar\n+                    // so it can accommodate being borrowed with\n+                    // mutability `kind`:\n+                    adjust_upvar_borrow_kind_for_loan(*upvar_id,\n+                                                      upvar_borrow,\n+                                                      borrow_kind);\n+\n+                    infer::ReborrowUpvar(span, *upvar_id)\n+                }\n+                None => {\n+                    rcx.tcx().sess.span_bug(\n+                        span,\n+                        format!(\"Illegal upvar id: {}\",\n+                                upvar_id.repr(\n+                                    rcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+\n+        _ => {\n+            infer::Reborrow(span)\n+        }\n+    };\n+\n+    debug!(\"link_reborrowed_region: {} <= {}\",\n+           borrow_region.repr(rcx.tcx()),\n+           ref_region.repr(rcx.tcx()));\n+    rcx.fcx.mk_subr(cause, borrow_region, ref_region);\n+\n+    // Decide whether we need to recurse and link any regions within\n+    // the `ref_cmt`. This is concerned for the case where the value\n+    // being reborrowed is in fact a borrowed pointer found within\n+    // another borrowed pointer. For example:\n+    //\n+    //    let p: &'b &'a mut T = ...;\n+    //    ...\n+    //    &'z **p\n+    //\n+    // What makes this case particularly tricky is that, if the data\n+    // being borrowed is a `&mut` or `&uniq` borrow, borrowck requires\n+    // not only that `'z <= 'a`, (as before) but also `'z <= 'b`\n+    // (otherwise the user might mutate through the `&mut T` reference\n+    // after `'b` expires and invalidate the borrow we are looking at\n+    // now).\n+    //\n+    // So let's re-examine our parameters in light of this more\n+    // complicated (possible) scenario:\n+    //\n+    //     A borrow of: `& 'z bk * * p` where `p` has type `&'b bk & 'a bk T`\n+    //     borrow_region   ^~                 ref_region             ^~\n+    //     borrow_kind        ^~               ref_kind                 ^~\n+    //     ref_cmt                 ^~~\n+    //\n+    // (Note that since we have not examined `ref_cmt.cat`, we don't\n+    // know whether this scenario has occurred; but I wanted to show\n+    // how all the types get adjusted.)\n+    match ref_kind {\n+        ty::ImmBorrow => {\n+            // The reference being reborrowed is a sharable ref of\n+            // type `&'a T`. In this case, it doesn't matter where we\n+            // *found* the `&T` pointer, the memory it references will\n+            // be valid and immutable for `'a`. So we can stop here.\n+            //\n+            // (Note that the `borrow_kind` must also be ImmBorrow or\n+            // else the user is borrowed imm memory as mut memory,\n+            // which means they'll get an error downstream in borrowck\n+            // anyhow.)\n+            return None;\n+        }\n+\n+        ty::MutBorrow | ty::UniqueImmBorrow => {\n+            // The reference being reborrowed is either an `&mut T` or\n+            // `&uniq T`. This is the case where recursion is needed.\n+            //\n+            // One interesting twist is that we can weaken the borrow\n+            // kind when we recurse: to reborrow an `&mut` referent as\n+            // mutable, borrowck requires a unique path to the `&mut`\n+            // reference but not necessarily a *mutable* path.\n+            let new_borrow_kind = match borrow_kind {\n+                ty::ImmBorrow =>\n+                    ty::ImmBorrow,\n+                ty::MutBorrow | ty::UniqueImmBorrow =>\n+                    ty::UniqueImmBorrow\n+            };\n+            return Some((ref_cmt, new_borrow_kind));\n+        }\n+    }\n+}\n+\n fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n     /*!"}, {"sha": "6360a9135005c3d465703f1045c5cb4c9c42140e", "filename": "src/test/compile-fail/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs?ref=1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "patch": "@@ -23,8 +23,7 @@ fn a(x: &int) {\n     let c1 = || set(&mut *x);\n     //~^ ERROR cannot borrow\n     let c2 = || set(&mut *x);\n-    //~^ ERROR closure requires unique access to `x`\n-    //~^^ ERROR cannot borrow\n+    //~^ ERROR cannot borrow\n }\n \n fn main() {"}, {"sha": "05cadfd536567aeadfd4d7302958c20cb1a05b34", "filename": "src/test/compile-fail/borrowck-reborrow-from-shorter-lived-andmut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-shorter-lived-andmut.rs?ref=1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "patch": "@@ -17,7 +17,7 @@ struct S<'a> {\n \n fn copy_borrowed_ptr<'a,'b>(p: &'a mut S<'b>) -> S<'b> {\n     S { pointer: &mut *p.pointer }\n-    //~^ ERROR lifetime of `p` is too short to guarantee its contents can be safely reborrowed\n+    //~^ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "4b1c7a2928b8ef1f67ba268a1b0afb120c3e4393", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs?ref=1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "patch": "@@ -13,7 +13,7 @@\n // for `'a` (which must be a sublifetime of `'b`).\n \n fn copy_borrowed_ptr<'a, 'b>(p: &'a mut &'b mut int) -> &'b mut int {\n-    &mut **p //~ ERROR lifetime of `p` is too short\n+    &mut **p //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "efe3994dbb7b98e928fb735fb4b635d014f7b81d", "filename": "src/test/run-pass/regions-infer-reborrow-ref-mut-recurse.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c15e9efeb2f816f2615042bd9e8125ebf48bcfa/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-reborrow-ref-mut-recurse.rs?ref=1c15e9efeb2f816f2615042bd9e8125ebf48bcfa", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an edge case in region inference: the lifetime of the borrow\n+// of `*x` must be extended to at least 'a.\n+\n+fn foo<'a,'b>(x: &'a &'b mut int) -> &'a int {\n+    let y = &*x; // should be inferred to have type &'a &'b mut int...\n+\n+    // ...because if we inferred, say, &'x &'b mut int where 'x <= 'a,\n+    // this reborrow would be illegal:\n+    &**y\n+}\n+\n+pub fn main() {\n+    /* Just want to know that it compiles. */\n+}"}]}