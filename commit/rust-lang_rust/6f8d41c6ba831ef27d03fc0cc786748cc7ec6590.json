{"sha": "6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "node_id": "C_kwDOAAsO6NoAKDZmOGQ0MWM2YmE4MzFlZjI3ZDAzZmMwY2M3ODY3NDhjYzdlYzY1OTA", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-09-16T11:07:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-16T11:07:17Z"}, "message": "Rollup merge of #101813 - GuillaumeGomez:check-css-variables, r=notriddle\n\nExtend CSS check to CSS variables\n\nThis PR is a bit big because the first commit is a rewrite of the CSS parser to something a bit simpler which still allows to get easily access to CSS properties name.\n\nThe other two are about adding tests and adding the CSS variables check.\n\nThis check was missing because we are relying more and more on CSS variables rather than CSS selectors in themes.\n\nr? `@notriddle`", "tree": {"sha": "8d1d5c2a6feed205384cddad248f3da95adbfae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1d5c2a6feed205384cddad248f3da95adbfae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjJFjlCRBK7hj4Ov3rIwAA/WwIAExhsXHH4yQnpLk5E0/A6QOf\nb+zRRlrPVva4D32FypWJBcAGxU+nzFP94uz2rkWVQ7flMNOa0P/uFzCDd+UfWA1+\nDk4A4rIq8s+Yn2xsrtiMoUyeagfnFUIaJJNUgdB5PkuPBWDP8KiOwhoLbmyhSUXW\nuA2yoCwsqznQDKjS/9cs1FQLNLUdV2hTl1dnRqZiyJ3WmqyhnH1aleATa0brLvY0\n11jMootjVNs+qEyOqTNbjjxSLpegN8WvOphltKC28oABeG2N66OVphW6430JarfY\nrKJzyK1gwAMnfShRrHu0Z2m4KrrQWJHmf5dJLuXjC4kbGm08FodARNcvOnRoB9g=\n=ln3m\n-----END PGP SIGNATURE-----\n", "payload": "tree 8d1d5c2a6feed205384cddad248f3da95adbfae3\nparent e96abefe80a5dcff603585c45b64dee9e4478ea7\nparent d3529ceb6c5eeaaecd3d88e97ad17740258772a8\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1663326437 +0200\ncommitter GitHub <noreply@github.com> 1663326437 +0200\n\nRollup merge of #101813 - GuillaumeGomez:check-css-variables, r=notriddle\n\nExtend CSS check to CSS variables\n\nThis PR is a bit big because the first commit is a rewrite of the CSS parser to something a bit simpler which still allows to get easily access to CSS properties name.\n\nThe other two are about adding tests and adding the CSS variables check.\n\nThis check was missing because we are relying more and more on CSS variables rather than CSS selectors in themes.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "html_url": "https://github.com/rust-lang/rust/commit/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96abefe80a5dcff603585c45b64dee9e4478ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96abefe80a5dcff603585c45b64dee9e4478ea7", "html_url": "https://github.com/rust-lang/rust/commit/e96abefe80a5dcff603585c45b64dee9e4478ea7"}, {"sha": "d3529ceb6c5eeaaecd3d88e97ad17740258772a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3529ceb6c5eeaaecd3d88e97ad17740258772a8", "html_url": "https://github.com/rust-lang/rust/commit/d3529ceb6c5eeaaecd3d88e97ad17740258772a8"}], "stats": {"total": 529, "additions": 296, "deletions": 233}, "files": [{"sha": "932533db05c14066f43ceed4dab20604847c42e0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "patch": "@@ -412,7 +412,13 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"check-theme\");\n         if !to_check.is_empty() {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n             let mut errors = 0;\n \n             println!(\"rustdoc: [check-theme] Starting tests! (Ignoring all other arguments)\");\n@@ -547,7 +553,13 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"theme\") {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n \n             for (theme_file, theme_s) in\n                 matches.opt_strs(\"theme\").iter().map(|s| (PathBuf::from(&s), s.to_owned()))"}, {"sha": "e7a26cb346ee6a2e26a33877f9208f23716cc00b", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 187, "deletions": 206, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "patch": "@@ -1,271 +1,252 @@\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map::Entry;\n use std::fs;\n-use std::hash::{Hash, Hasher};\n+use std::iter::Peekable;\n use std::path::Path;\n+use std::str::Chars;\n \n use rustc_errors::Handler;\n \n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug, Clone, Eq)]\n+#[derive(Debug)]\n pub(crate) struct CssPath {\n-    pub(crate) name: String,\n-    pub(crate) children: FxHashSet<CssPath>,\n-}\n-\n-// This PartialEq implementation IS NOT COMMUTATIVE!!!\n-//\n-// The order is very important: the second object must have all first's rules.\n-// However, the first is not required to have all of the second's rules.\n-impl PartialEq for CssPath {\n-    fn eq(&self, other: &CssPath) -> bool {\n-        if self.name != other.name {\n-            false\n-        } else {\n-            for child in &self.children {\n-                if !other.children.iter().any(|c| child == c) {\n-                    return false;\n-                }\n-            }\n-            true\n+    pub(crate) rules: FxHashMap<String, String>,\n+    pub(crate) children: FxHashMap<String, CssPath>,\n+}\n+\n+/// When encountering a `\"` or a `'`, returns the whole string, including the quote characters.\n+fn get_string(iter: &mut Peekable<Chars<'_>>, string_start: char, buffer: &mut String) {\n+    buffer.push(string_start);\n+    while let Some(c) = iter.next() {\n+        buffer.push(c);\n+        if c == '\\\\' {\n+            iter.next();\n+        } else if c == string_start {\n+            break;\n         }\n     }\n }\n \n-impl Hash for CssPath {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state);\n-        for x in &self.children {\n-            x.hash(state);\n+fn get_inside_paren(\n+    iter: &mut Peekable<Chars<'_>>,\n+    paren_start: char,\n+    paren_end: char,\n+    buffer: &mut String,\n+) {\n+    buffer.push(paren_start);\n+    while let Some(c) = iter.next() {\n+        handle_common_chars(c, buffer, iter);\n+        if c == paren_end {\n+            break;\n         }\n     }\n }\n \n-impl CssPath {\n-    fn new(name: String) -> CssPath {\n-        CssPath { name, children: FxHashSet::default() }\n+/// Skips a `/*` comment.\n+fn skip_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '*' && iter.next() == Some('/') {\n+            break;\n+        }\n     }\n }\n \n-/// All variants contain the position they occur.\n-#[derive(Debug, Clone, Copy)]\n-enum Events {\n-    StartLineComment(usize),\n-    StartComment(usize),\n-    EndComment(usize),\n-    InBlock(usize),\n-    OutBlock(usize),\n-}\n-\n-impl Events {\n-    fn get_pos(&self) -> usize {\n-        match *self {\n-            Events::StartLineComment(p)\n-            | Events::StartComment(p)\n-            | Events::EndComment(p)\n-            | Events::InBlock(p)\n-            | Events::OutBlock(p) => p,\n+/// Skips a line comment (`//`).\n+fn skip_line_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '\\n' {\n+            break;\n         }\n     }\n-\n-    fn is_comment(&self) -> bool {\n-        matches!(\n-            self,\n-            Events::StartLineComment(_) | Events::StartComment(_) | Events::EndComment(_)\n-        )\n-    }\n }\n \n-fn previous_is_line_comment(events: &[Events]) -> bool {\n-    matches!(events.last(), Some(&Events::StartLineComment(_)))\n-}\n-\n-fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n-    if let Some(&Events::StartComment(_)) = events.last() {\n-        return false;\n+fn handle_common_chars(c: char, buffer: &mut String, iter: &mut Peekable<Chars<'_>>) {\n+    match c {\n+        '\"' | '\\'' => get_string(iter, c, buffer),\n+        '/' if iter.peek() == Some(&'*') => skip_comment(iter),\n+        '/' if iter.peek() == Some(&'/') => skip_line_comment(iter),\n+        '(' => get_inside_paren(iter, c, ')', buffer),\n+        '[' => get_inside_paren(iter, c, ']', buffer),\n+        _ => buffer.push(c),\n     }\n-    v[pos + 1] == b'/'\n }\n \n-fn load_css_events(v: &[u8]) -> Vec<Events> {\n-    let mut pos = 0;\n-    let mut events = Vec::with_capacity(100);\n-\n-    while pos + 1 < v.len() {\n-        match v[pos] {\n-            b'/' if v[pos + 1] == b'*' => {\n-                events.push(Events::StartComment(pos));\n-                pos += 1;\n-            }\n-            b'/' if is_line_comment(pos, v, &events) => {\n-                events.push(Events::StartLineComment(pos));\n-                pos += 1;\n-            }\n-            b'\\n' if previous_is_line_comment(&events) => {\n-                events.push(Events::EndComment(pos));\n-            }\n-            b'*' if v[pos + 1] == b'/' => {\n-                events.push(Events::EndComment(pos + 2));\n-                pos += 1;\n-            }\n-            b'{' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::InBlock(pos + 1));\n-            }\n-            b'}' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::OutBlock(pos + 1));\n-            }\n-            _ => {}\n+/// Returns a CSS property name. Ends when encountering a `:` character.\n+///\n+/// If the `:` character isn't found, returns `None`.\n+///\n+/// If a `{` character is encountered, returns an error.\n+fn parse_property_name(iter: &mut Peekable<Chars<'_>>) -> Result<Option<String>, String> {\n+    let mut content = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ':' => return Ok(Some(content.trim().to_owned())),\n+            '{' => return Err(\"Unexpected `{` in a `{}` block\".to_owned()),\n+            '}' => break,\n+            _ => handle_common_chars(c, &mut content, iter),\n         }\n-        pos += 1;\n     }\n-    events\n-}\n-\n-fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n-    while *pos < events.len() {\n-        if !events[*pos].is_comment() {\n-            return Some(events[*pos]);\n+    Ok(None)\n+}\n+\n+/// Try to get the value of a CSS property (the `#fff` in `color: #fff`). It'll stop when it\n+/// encounters a `{` or a `;` character.\n+///\n+/// It returns the value string and a boolean set to `true` if the value is ended with a `}` because\n+/// it means that the parent block is done and that we should notify the parent caller.\n+fn parse_property_value(iter: &mut Peekable<Chars<'_>>) -> (String, bool) {\n+    let mut value = String::new();\n+    let mut out_block = false;\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ';' => break,\n+            '}' => {\n+                out_block = true;\n+                break;\n+            }\n+            _ => handle_common_chars(c, &mut value, iter),\n         }\n-        *pos += 1;\n     }\n-    None\n+    (value.trim().to_owned(), out_block)\n }\n \n-fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n-    let mut ret = Vec::with_capacity(3);\n+/// This is used to parse inside a CSS `{}` block. If we encounter a new `{` inside it, we consider\n+/// it as a new block and therefore recurse into `parse_rules`.\n+fn parse_rules(\n+    content: &str,\n+    selector: String,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut rules = FxHashMap::default();\n+    let mut children = FxHashMap::default();\n \n-    ret.push(events[pos].get_pos());\n-    if pos > 0 {\n-        pos -= 1;\n-    }\n     loop {\n-        if pos < 1 || !events[pos].is_comment() {\n-            let x = events[pos].get_pos();\n-            if *ret.last().unwrap() != x {\n-                ret.push(x);\n-            } else {\n-                ret.push(0);\n+        // If the parent isn't a \"normal\" CSS selector, we only expect sub-selectors and not CSS\n+        // properties.\n+        if selector.starts_with('@') {\n+            parse_selectors(content, iter, &mut children)?;\n+            break;\n+        }\n+        let rule = match parse_property_name(iter)? {\n+            Some(r) => {\n+                if r.is_empty() {\n+                    return Err(format!(\"Found empty rule in selector `{selector}`\"));\n+                }\n+                r\n+            }\n+            None => break,\n+        };\n+        let (value, out_block) = parse_property_value(iter);\n+        if value.is_empty() {\n+            return Err(format!(\"Found empty value for rule `{rule}` in selector `{selector}`\"));\n+        }\n+        match rules.entry(rule) {\n+            Entry::Occupied(mut o) => {\n+                *o.get_mut() = value;\n+            }\n+            Entry::Vacant(v) => {\n+                v.insert(value);\n             }\n+        }\n+        if out_block {\n             break;\n         }\n-        ret.push(events[pos].get_pos());\n-        pos -= 1;\n-    }\n-    if ret.len() & 1 != 0 && events[pos].is_comment() {\n-        ret.push(0);\n     }\n-    ret.iter().rev().cloned().collect()\n-}\n-\n-fn build_rule(v: &[u8], positions: &[usize]) -> String {\n-    minifier::css::minify(\n-        &positions\n-            .chunks(2)\n-            .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n-            .collect::<String>()\n-            .trim()\n-            .chars()\n-            .filter_map(|c| match c {\n-                '\\n' | '\\t' => Some(' '),\n-                '/' | '{' | '}' => None,\n-                c => Some(c),\n-            })\n-            .collect::<String>()\n-            .split(' ')\n-            .filter(|s| !s.is_empty())\n-            .intersperse(\" \")\n-            .collect::<String>(),\n-    )\n-    .map(|css| css.to_string())\n-    .unwrap_or_else(|_| String::new())\n-}\n-\n-fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n-    let mut paths = Vec::with_capacity(50);\n \n-    while *pos < events.len() {\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n-            break;\n+    match paths.entry(selector) {\n+        Entry::Occupied(mut o) => {\n+            let v = o.get_mut();\n+            for (key, value) in rules.into_iter() {\n+                v.rules.insert(key, value);\n+            }\n+            for (sel, child) in children.into_iter() {\n+                v.children.insert(sel, child);\n+            }\n         }\n-        if let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            paths.push(CssPath::new(build_rule(v, &get_previous_positions(events, *pos))));\n-            *pos += 1;\n+        Entry::Vacant(v) => {\n+            v.insert(CssPath { rules, children });\n         }\n-        while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            if let Some(ref mut path) = paths.last_mut() {\n-                for entry in inner(v, events, pos).iter() {\n-                    path.children.insert(entry.clone());\n-                }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn parse_selectors(\n+    content: &str,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut selector = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            '{' => {\n+                let s = minifier::css::minify(selector.trim()).map(|s| s.to_string())?;\n+                parse_rules(content, s, iter, paths)?;\n+                selector.clear();\n             }\n-        }\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n+            '}' => break,\n+            ';' => selector.clear(), // We don't handle inline selectors like `@import`.\n+            _ => handle_common_chars(c, &mut selector, iter),\n         }\n     }\n-    paths.iter().cloned().collect()\n-}\n-\n-pub(crate) fn load_css_paths(v: &[u8]) -> CssPath {\n-    let events = load_css_events(v);\n-    let mut pos = 0;\n-\n-    let mut parent = CssPath::new(\"parent\".to_owned());\n-    parent.children = inner(v, &events, &mut pos);\n-    parent\n-}\n-\n-pub(crate) fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n-    if against.name == other.name {\n-        for child in &against.children {\n-            let mut found = false;\n-            let mut found_working = false;\n-            let mut tmp = Vec::new();\n-\n-            for other_child in &other.children {\n-                if child.name == other_child.name {\n-                    if child != other_child {\n-                        get_differences(child, other_child, &mut tmp);\n-                    } else {\n-                        found_working = true;\n+    Ok(())\n+}\n+\n+/// The entry point to parse the CSS rules. Every time we encounter a `{`, we then parse the rules\n+/// inside it.\n+pub(crate) fn load_css_paths(content: &str) -> Result<FxHashMap<String, CssPath>, String> {\n+    let mut iter = content.chars().peekable();\n+    let mut paths = FxHashMap::default();\n+\n+    parse_selectors(content, &mut iter, &mut paths)?;\n+    Ok(paths)\n+}\n+\n+pub(crate) fn get_differences(\n+    origin: &FxHashMap<String, CssPath>,\n+    against: &FxHashMap<String, CssPath>,\n+    v: &mut Vec<String>,\n+) {\n+    for (selector, entry) in origin.iter() {\n+        match against.get(selector) {\n+            Some(a) => {\n+                get_differences(&entry.children, &a.children, v);\n+                if selector == \":root\" {\n+                    // We need to check that all variables have been set.\n+                    for rule in entry.rules.keys() {\n+                        if !a.rules.contains_key(rule) {\n+                            v.push(format!(\"  Missing CSS variable `{rule}` in `:root`\"));\n+                        }\n                     }\n-                    found = true;\n-                    break;\n                 }\n             }\n-            if !found {\n-                v.push(format!(\"  Missing \\\"{}\\\" rule\", child.name));\n-            } else if !found_working {\n-                v.extend(tmp.iter().cloned());\n-            }\n+            None => v.push(format!(\"  Missing rule `{selector}`\")),\n         }\n     }\n }\n \n pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n-    against: &CssPath,\n+    origin: &FxHashMap<String, CssPath>,\n     diag: &Handler,\n ) -> (bool, Vec<String>) {\n-    let data = match fs::read(f) {\n+    let against = match fs::read_to_string(f)\n+        .map_err(|e| e.to_string())\n+        .and_then(|data| load_css_paths(&data))\n+    {\n         Ok(c) => c,\n         Err(e) => {\n-            diag.struct_err(&e.to_string()).emit();\n+            diag.struct_err(&e).emit();\n             return (false, vec![]);\n         }\n     };\n \n-    let paths = load_css_paths(&data);\n     let mut ret = vec![];\n-    get_differences(against, &paths, &mut ret);\n+    get_differences(origin, &against, &mut ret);\n     (true, ret)\n }"}, {"sha": "08a174d27d35740f6e1aa6de553dc28d3957162b", "filename": "src/librustdoc/theme/tests.rs", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8d41c6ba831ef27d03fc0cc786748cc7ec6590/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme%2Ftests.rs?ref=6f8d41c6ba831ef27d03fc0cc786748cc7ec6590", "patch": "@@ -44,11 +44,7 @@ rule j end {}\n \"#;\n \n     let mut ret = Vec::new();\n-    get_differences(\n-        &load_css_paths(against.as_bytes()),\n-        &load_css_paths(text.as_bytes()),\n-        &mut ret,\n-    );\n+    get_differences(&load_css_paths(against).unwrap(), &load_css_paths(text).unwrap(), &mut ret);\n     assert!(ret.is_empty());\n }\n \n@@ -61,57 +57,131 @@ a\n c // sdf\n d {}\n \"#;\n-    let paths = load_css_paths(text.as_bytes());\n-    assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n+    let paths = load_css_paths(text).unwrap();\n+    assert!(paths.contains_key(&\"a b c d\".to_owned()));\n }\n \n #[test]\n fn test_comparison() {\n-    let x = r#\"\n-a {\n-    b {\n-        c {}\n-    }\n+    let origin = r#\"\n+@a {\n+    b {}\n+    c {}\n }\n \"#;\n \n-    let y = r#\"\n-a {\n+    let against = r#\"\n+@a {\n     b {}\n }\n \"#;\n \n-    let against = load_css_paths(y.as_bytes());\n-    let other = load_css_paths(x.as_bytes());\n+    let origin = load_css_paths(origin).unwrap();\n+    let against = load_css_paths(against).unwrap();\n \n     let mut ret = Vec::new();\n-    get_differences(&against, &other, &mut ret);\n+    get_differences(&against, &origin, &mut ret);\n     assert!(ret.is_empty());\n-    get_differences(&other, &against, &mut ret);\n-    assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n+    get_differences(&origin, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing rule `c`\".to_owned()]);\n }\n \n #[test]\n fn check_empty_css() {\n-    let events = load_css_events(&[]);\n-    assert_eq!(events.len(), 0);\n+    let paths = load_css_paths(\"\").unwrap();\n+    assert_eq!(paths.len(), 0);\n }\n \n #[test]\n fn check_invalid_css() {\n-    let events = load_css_events(b\"*\");\n-    assert_eq!(events.len(), 0);\n+    let paths = load_css_paths(\"*\").unwrap();\n+    assert_eq!(paths.len(), 0);\n }\n \n #[test]\n fn test_with_minification() {\n     let text = include_str!(\"../html/static/css/themes/dark.css\");\n     let minified = minifier::css::minify(&text).expect(\"CSS minification failed\").to_string();\n \n-    let against = load_css_paths(text.as_bytes());\n-    let other = load_css_paths(minified.as_bytes());\n+    let against = load_css_paths(text).unwrap();\n+    let other = load_css_paths(&minified).unwrap();\n+\n+    let mut ret = Vec::new();\n+    get_differences(&against, &other, &mut ret);\n+    assert!(ret.is_empty());\n+}\n+\n+#[test]\n+fn test_media() {\n+    let text = r#\"\n+@media (min-width: 701px) {\n+    a:hover {\n+        color: #fff;\n+    }\n+\n+    b {\n+        x: y;\n+    }\n+}\n+\n+@media (max-width: 1001px) {\n+    b {\n+        x: y;\n+    }\n+}\n+\"#;\n+\n+    let paths = load_css_paths(text).unwrap();\n+    let p = paths.get(\"@media (min-width:701px)\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert!(p.children.get(\"a:hover\").is_some());\n+    assert!(p.children.get(\"b\").is_some());\n+\n+    let p = paths.get(\"@media (max-width:1001px)\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert!(p.children.get(\"b\").is_some());\n+}\n+\n+#[test]\n+fn test_css_variables() {\n+    let x = r#\"\n+:root {\n+    --a: #fff;\n+}\n+\"#;\n+\n+    let y = r#\"\n+:root {\n+    --a: #fff;\n+    --b: #fff;\n+}\n+\"#;\n+\n+    let against = load_css_paths(x).unwrap();\n+    let other = load_css_paths(y).unwrap();\n \n     let mut ret = Vec::new();\n     get_differences(&against, &other, &mut ret);\n     assert!(ret.is_empty());\n+    get_differences(&other, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing CSS variable `--b` in `:root`\".to_owned()]);\n+}\n+\n+#[test]\n+fn test_weird_rule_value() {\n+    let x = r#\"\n+a[text=(\"a\")] {\n+    b: url({;}.png);\n+    c: #fff\n+}\n+\"#;\n+\n+    let paths = load_css_paths(&x).unwrap();\n+    let p = paths.get(\"a[text=(\\\"a\\\")]\");\n+    assert!(p.is_some());\n+    let p = p.unwrap();\n+    assert_eq!(p.rules.get(\"b\"), Some(&\"url({;}.png)\".to_owned()));\n+    assert_eq!(p.rules.get(\"c\"), Some(&\"#fff\".to_owned()));\n }"}]}