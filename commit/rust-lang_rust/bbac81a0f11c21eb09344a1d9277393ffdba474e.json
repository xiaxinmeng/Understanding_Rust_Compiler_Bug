{"sha": "bbac81a0f11c21eb09344a1d9277393ffdba474e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYWM4MWEwZjExYzIxZWIwOTM0NGExZDkyNzczOTNmZmRiYTQ3NGU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-23T21:56:23Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-03T17:19:29Z"}, "message": "Warn for #[must_use] in tuples", "tree": {"sha": "cc935e3d01222ac4e42e99a33e21720e5b5d7639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc935e3d01222ac4e42e99a33e21720e5b5d7639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbac81a0f11c21eb09344a1d9277393ffdba474e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbac81a0f11c21eb09344a1d9277393ffdba474e", "html_url": "https://github.com/rust-lang/rust/commit/bbac81a0f11c21eb09344a1d9277393ffdba474e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbac81a0f11c21eb09344a1d9277393ffdba474e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7840a0b753a065a41999f1fb6028f67d33e3fdd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7840a0b753a065a41999f1fb6028f67d33e3fdd5", "html_url": "https://github.com/rust-lang/rust/commit/7840a0b753a065a41999f1fb6028f67d33e3fdd5"}], "stats": {"total": 89, "additions": 53, "deletions": 36}, "files": [{"sha": "a765c0436a8c09d6f72a64a74f7211c46e058571", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bbac81a0f11c21eb09344a1d9277393ffdba474e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbac81a0f11c21eb09344a1d9277393ffdba474e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bbac81a0f11c21eb09344a1d9277393ffdba474e", "patch": "@@ -47,42 +47,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tables.expr_ty(&expr);\n-        let type_permits_lack_of_use = if t.is_unit()\n+        let ty = cx.tables.expr_ty(&expr);\n+        let type_permits_lack_of_use = if ty.is_unit()\n             || cx.tcx.is_ty_uninhabited_from(\n-                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), t)\n+                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), ty)\n         {\n             true\n         } else {\n-            match t.sty {\n-                ty::Adt(def, _) => check_must_use(cx, def.did, s.span, \"\", \"\"),\n-                ty::Opaque(def, _) => {\n-                    let mut must_use = false;\n-                    for (predicate, _) in &cx.tcx.predicates_of(def).predicates {\n-                        if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n-                            let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n-                            if check_must_use(cx, trait_ref.def_id, s.span, \"implementer of \", \"\") {\n-                                must_use = true;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    must_use\n-                }\n-                ty::Dynamic(binder, _) => {\n-                    let mut must_use = false;\n-                    for predicate in binder.skip_binder().iter() {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n-                            if check_must_use(cx, trait_ref.def_id, s.span, \"\", \" trait object\") {\n-                                must_use = true;\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    must_use\n-                }\n-                _ => false,\n-            }\n+            check_must_use_ty(cx, ty, s.span)\n         };\n \n         let mut fn_warned = false;\n@@ -108,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             _ => None\n         };\n         if let Some(def_id) = maybe_def_id {\n-            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \", \"\");\n+            fn_warned = check_must_use_def(cx, def_id, s.span, \"return value of \", \"\");\n         } else if type_permits_lack_of_use {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n@@ -162,18 +134,63 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(\n+        // Returns whether an error has been emitted (and thus another does not need to be later).\n+        fn check_must_use_ty(\n+            cx: &LateContext<'_, '_>,\n+            ty: ty::Ty<'_>,\n+            span: Span,\n+        ) -> bool {\n+            match ty.sty {\n+                ty::Adt(def, _) => check_must_use_def(cx, def.did, span, \"\", \"\"),\n+                ty::Opaque(def, _) => {\n+                    let mut has_emitted = false;\n+                    for (predicate, _) in &cx.tcx.predicates_of(def).predicates {\n+                        if let ty::Predicate::Trait(ref poly_trait_predicate) = predicate {\n+                            let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n+                            let def_id = trait_ref.def_id;\n+                            if check_must_use_def(cx, def_id, span, \"implementer of \", \"\") {\n+                                has_emitted = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    has_emitted\n+                }\n+                ty::Dynamic(binder, _) => {\n+                    let mut has_emitted = false;\n+                    for predicate in binder.skip_binder().iter() {\n+                        if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate {\n+                            let def_id = trait_ref.def_id;\n+                            if check_must_use_def(cx, def_id, span, \"\", \" trait object\") {\n+                                has_emitted = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    has_emitted\n+                }\n+                ty::Tuple(ref tys) => {\n+                    tys.iter().map(|k| k.expect_ty()).any(|ty| {\n+                        check_must_use_ty(cx, ty, span)\n+                    })\n+                }\n+                _ => false,\n+            }\n+        }\n+\n+        // Returns whether an error has been emitted (and thus another does not need to be later).\n+        fn check_must_use_def(\n             cx: &LateContext<'_, '_>,\n             def_id: DefId,\n-            sp: Span,\n+            span: Span,\n             descr_pre_path: &str,\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(sym::must_use) {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n                         descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n-                    let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n+                    let mut err = cx.struct_span_lint(UNUSED_MUST_USE, span, &msg);\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {\n                         err.note(&note.as_str());"}]}