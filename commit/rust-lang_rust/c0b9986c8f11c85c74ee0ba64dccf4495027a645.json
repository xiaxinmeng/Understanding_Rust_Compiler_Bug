{"sha": "c0b9986c8f11c85c74ee0ba64dccf4495027a645", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjk5ODZjOGYxMWM4NWM3NGVlMGJhNjRkY2NmNDQ5NTAyN2E2NDU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-25T17:50:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "libstd: change serialization2 to take &self argument methods\n\nUnfortunately this trips over issue (#3585), where auto-ref isn't\nplaying nicely with @T implementations. Most serializers don't\ncare, but prettyprint2 won't properly display \"@\" until #3585 is\nfixed.", "tree": {"sha": "a3bf26f36edf9c3ec25360fa076216e8a89fadc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3bf26f36edf9c3ec25360fa076216e8a89fadc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b9986c8f11c85c74ee0ba64dccf4495027a645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b9986c8f11c85c74ee0ba64dccf4495027a645", "html_url": "https://github.com/rust-lang/rust/commit/c0b9986c8f11c85c74ee0ba64dccf4495027a645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b9986c8f11c85c74ee0ba64dccf4495027a645/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd93441705b84ab36a314d7f0b721c2fb6b01ecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd93441705b84ab36a314d7f0b721c2fb6b01ecd", "html_url": "https://github.com/rust-lang/rust/commit/cd93441705b84ab36a314d7f0b721c2fb6b01ecd"}], "stats": {"total": 578, "additions": 339, "deletions": 239}, "files": [{"sha": "81941627ef64b9f5132495e9efc3ba91d94705d4", "filename": "src/libstd/serialization2.rs", "status": "modified", "additions": 197, "deletions": 169, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=c0b9986c8f11c85c74ee0ba64dccf4495027a645", "patch": "@@ -4,187 +4,222 @@\n Core serialization interfaces.\n */\n \n-trait Serializer {\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+#[forbid(non_camel_case_types)];\n+\n+pub trait Serializer {\n     // Primitive types:\n-    fn emit_nil();\n-    fn emit_uint(v: uint);\n-    fn emit_u64(v: u64);\n-    fn emit_u32(v: u32);\n-    fn emit_u16(v: u16);\n-    fn emit_u8(v: u8);\n-    fn emit_int(v: int);\n-    fn emit_i64(v: i64);\n-    fn emit_i32(v: i32);\n-    fn emit_i16(v: i16);\n-    fn emit_i8(v: i8);\n-    fn emit_bool(v: bool);\n-    fn emit_float(v: float);\n-    fn emit_f64(v: f64);\n-    fn emit_f32(v: f32);\n-    fn emit_str(v: &str);\n+    fn emit_nil(&self);\n+    fn emit_uint(&self, v: uint);\n+    fn emit_u64(&self, v: u64);\n+    fn emit_u32(&self, v: u32);\n+    fn emit_u16(&self, v: u16);\n+    fn emit_u8(&self, v: u8);\n+    fn emit_int(&self, v: int);\n+    fn emit_i64(&self, v: i64);\n+    fn emit_i32(&self, v: i32);\n+    fn emit_i16(&self, v: i16);\n+    fn emit_i8(&self, v: i8);\n+    fn emit_bool(&self, v: bool);\n+    fn emit_float(&self, v: float);\n+    fn emit_f64(&self, v: f64);\n+    fn emit_f32(&self, v: f32);\n+    fn emit_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(name: &str, f: fn());\n-    fn emit_enum_variant(v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(idx: uint, f: fn());\n-    fn emit_vec(len: uint, f: fn());\n-    fn emit_vec_elt(idx: uint, f: fn());\n-    fn emit_box(f: fn());\n-    fn emit_uniq(f: fn());\n-    fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn());\n-    fn emit_tup(sz: uint, f: fn());\n-    fn emit_tup_elt(idx: uint, f: fn());\n-}\n-\n-trait Deserializer {\n+    fn emit_enum(&self, name: &str, f: fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+    fn emit_vec(&self, len: uint, f: fn());\n+    fn emit_vec_elt(&self, idx: uint, f: fn());\n+    fn emit_box(&self, f: fn());\n+    fn emit_uniq(&self, f: fn());\n+    fn emit_rec(&self, f: fn());\n+    fn emit_rec_field(&self, f_name: &str, f_idx: uint, f: fn());\n+    fn emit_tup(&self, sz: uint, f: fn());\n+    fn emit_tup_elt(&self, idx: uint, f: fn());\n+}\n+\n+pub trait Deserializer {\n     // Primitive types:\n-    fn read_nil() -> ();\n-    fn read_uint() -> uint;\n-    fn read_u64() -> u64;\n-    fn read_u32() -> u32;\n-    fn read_u16() -> u16;\n-    fn read_u8() -> u8;\n-    fn read_int() -> int;\n-    fn read_i64() -> i64;\n-    fn read_i32() -> i32;\n-    fn read_i16() -> i16;\n-    fn read_i8() -> i8;\n-    fn read_bool() -> bool;\n-    fn read_f64() -> f64;\n-    fn read_f32() -> f32;\n-    fn read_float() -> float;\n-    fn read_str() -> ~str;\n+    fn read_nil(&self) -> ();\n+    fn read_uint(&self) -> uint;\n+    fn read_u64(&self) -> u64;\n+    fn read_u32(&self) -> u32;\n+    fn read_u16(&self) -> u16;\n+    fn read_u8(&self) -> u8;\n+    fn read_int(&self) -> int;\n+    fn read_i64(&self) -> i64;\n+    fn read_i32(&self) -> i32;\n+    fn read_i16(&self) -> i16;\n+    fn read_i8(&self) -> i8;\n+    fn read_bool(&self) -> bool;\n+    fn read_f64(&self) -> f64;\n+    fn read_f32(&self) -> f32;\n+    fn read_float(&self) -> float;\n+    fn read_str(&self) -> ~str;\n \n     // Compound types:\n-    fn read_enum<T>(name: ~str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T>(f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T>(f: fn() -> T) -> T;\n-    fn read_uniq<T>(f: fn() -> T) -> T;\n-    fn read_rec<T>(f: fn() -> T) -> T;\n-    fn read_rec_field<T>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T;\n-    fn read_tup<T>(sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T;\n-}\n-\n-trait Serializable {\n-    fn serialize<S: Serializer>(s: S);\n-    static fn deserialize<D: Deserializer>(d: D) -> self;\n-}\n-\n-impl uint: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_uint(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> uint { d.read_uint() }\n+    fn read_enum<T>(&self, name: ~str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_box<T>(&self, f: fn() -> T) -> T;\n+    fn read_uniq<T>(&self, f: fn() -> T) -> T;\n+    fn read_rec<T>(&self, f: fn() -> T) -> T;\n+    fn read_rec_field<T>(&self, f_name: ~str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+}\n+\n+pub trait Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S);\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n+}\n+\n+pub impl uint: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n+        d.read_uint()\n+    }\n }\n \n-impl u8: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_u8(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> u8 { d.read_u8() }\n+pub impl u8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n }\n \n-impl u16: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_u16(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> u16 { d.read_u16() }\n+pub impl u16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n }\n \n-impl u32: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_u32(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> u32 { d.read_u32() }\n+pub impl u32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n }\n \n-impl u64: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_u64(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> u64 { d.read_u64() }\n+pub impl u64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n }\n \n-impl int: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_int(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> int { d.read_int() }\n+pub impl int: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n }\n \n-impl i8: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_i8(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> i8 { d.read_i8() }\n+pub impl i8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n }\n \n-impl i16: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_i16(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> i16 { d.read_i16() }\n+pub impl i16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n }\n \n-impl i32: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_i32(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> i32 { d.read_i32() }\n+pub impl i32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n }\n \n-impl i64: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_i64(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> i64 { d.read_i64() }\n+pub impl i64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n }\n \n-impl ~str: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_str(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> ~str { d.read_str() }\n+pub impl ~str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_str(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n+        d.read_str()\n+    }\n }\n \n-impl float: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_float(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> float { d.read_float() }\n+pub impl float: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n }\n \n-impl f32: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_f32(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> f32 { d.read_f32() }\n+pub impl f32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n+        d.read_f32() }\n }\n \n-impl f64: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_f64(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> f64 { d.read_f64() }\n+pub impl f64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n }\n \n-impl bool: Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_bool(self) }\n-    static fn deserialize<D: Deserializer>(d: D) -> bool { d.read_bool() }\n+pub impl bool: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n }\n \n-impl (): Serializable {\n-    fn serialize<S: Serializer>(s: S) { s.emit_nil() }\n-    static fn deserialize<D: Deserializer>(d: D) -> () { d.read_nil() }\n+pub impl (): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n }\n \n-impl<T: Serializable> @T: Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n+pub impl<T: Serializable> @T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n         s.emit_box(|| (*self).serialize(s))\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> @T {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n         d.read_box(|| @deserialize(d))\n     }\n }\n \n-impl<T: Serializable> ~T: Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n+pub impl<T: Serializable> ~T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n         s.emit_uniq(|| (*self).serialize(s))\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> ~T {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n         d.read_uniq(|| ~deserialize(d))\n     }\n }\n \n-impl<T: Serializable> ~[T]: Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n+pub impl<T: Serializable> ~[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n         do s.emit_vec(self.len()) {\n             for self.eachi |i, e| {\n                 s.emit_vec_elt(i, || e.serialize(s))\n             }\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> ~[T] {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n         do d.read_vec |len| {\n             do vec::from_fn(len) |i| {\n                 d.read_vec_elt(i, || deserialize(d))\n@@ -193,10 +228,10 @@ impl<T: Serializable> ~[T]: Serializable {\n     }\n }\n \n-impl<T: Serializable> Option<T>: Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n+pub impl<T: Serializable> Option<T>: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n         do s.emit_enum(~\"option\") {\n-            match self {\n+            match *self {\n               None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n               },\n \n@@ -207,7 +242,7 @@ impl<T: Serializable> Option<T>: Serializable {\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> Option<T> {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n         do d.read_enum(~\"option\") {\n             do d.read_enum_variant |i| {\n                 match i {\n@@ -220,12 +255,12 @@ impl<T: Serializable> Option<T>: Serializable {\n     }\n }\n \n-impl<\n+pub impl<\n     T0: Serializable,\n     T1: Serializable\n > (T0, T1): Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n-        match self {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n             (t0, t1) => {\n                 do s.emit_tup(2) {\n                     s.emit_tup_elt(0, || t0.serialize(s));\n@@ -235,7 +270,7 @@ impl<\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1) {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n         do d.read_tup(2) {\n             (\n                 d.read_tup_elt(0, || deserialize(d)),\n@@ -245,13 +280,13 @@ impl<\n     }\n }\n \n-impl<\n+pub impl<\n     T0: Serializable,\n     T1: Serializable,\n     T2: Serializable\n > (T0, T1, T2): Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n-        match self {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n             (t0, t1, t2) => {\n                 do s.emit_tup(3) {\n                     s.emit_tup_elt(0, || t0.serialize(s));\n@@ -262,7 +297,7 @@ impl<\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2) {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n         do d.read_tup(3) {\n             (\n                 d.read_tup_elt(0, || deserialize(d)),\n@@ -273,14 +308,14 @@ impl<\n     }\n }\n \n-impl<\n+pub impl<\n     T0: Serializable,\n     T1: Serializable,\n     T2: Serializable,\n     T3: Serializable\n > (T0, T1, T2, T3): Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n-        match self {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n             (t0, t1, t2, t3) => {\n                 do s.emit_tup(4) {\n                     s.emit_tup_elt(0, || t0.serialize(s));\n@@ -292,7 +327,7 @@ impl<\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2, T3) {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n         do d.read_tup(4) {\n             (\n                 d.read_tup_elt(0, || deserialize(d)),\n@@ -304,15 +339,15 @@ impl<\n     }\n }\n \n-impl<\n+pub impl<\n     T0: Serializable,\n     T1: Serializable,\n     T2: Serializable,\n     T3: Serializable,\n     T4: Serializable\n > (T0, T1, T2, T3, T4): Serializable {\n-    fn serialize<S: Serializer>(s: S) {\n-        match self {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n             (t0, t1, t2, t3, t4) => {\n                 do s.emit_tup(5) {\n                     s.emit_tup_elt(0, || t0.serialize(s));\n@@ -325,7 +360,8 @@ impl<\n         }\n     }\n \n-    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2, T3, T4) {\n+    static fn deserialize<D: Deserializer>(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n         do d.read_tup(5) {\n             (\n                 d.read_tup_elt(0, || deserialize(d)),\n@@ -343,40 +379,32 @@ impl<\n //\n // In some cases, these should eventually be coded as traits.\n \n-fn emit_from_vec<S: Serializer, T>(s: S, v: ~[T], f: fn(T)) {\n-    do s.emit_vec(v.len()) {\n-        for v.eachi |i, e| {\n-            do s.emit_vec_elt(i) {\n-                f(*e)\n-            }\n-        }\n-    }\n+pub trait SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n }\n \n-fn read_to_vec<D: Deserializer, T: Copy>(d: D, f: fn() -> T) -> ~[T] {\n-    do d.read_vec |len| {\n-        do vec::from_fn(len) |i| {\n-            d.read_vec_elt(i, || f())\n+pub impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n+        do self.emit_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n+            }\n         }\n     }\n }\n \n-trait SerializerHelpers {\n-    fn emit_from_vec<T>(v: ~[T], f: fn(T));\n+pub trait DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n }\n \n-impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(v: ~[T], f: fn(T)) {\n-        emit_from_vec(self, v, f)\n-    }\n-}\n-\n-trait DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n-}\n-\n-impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T] {\n-        read_to_vec(self, f)\n+pub impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n+            }\n+        }\n     }\n }"}, {"sha": "548ec1c31b4665db2ff395c217c11da0c9614952", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=c0b9986c8f11c85c74ee0ba64dccf4495027a645", "patch": "@@ -144,7 +144,6 @@ mod unicode;\n mod test;\n #[legacy_exports]\n mod serialization;\n-#[legacy_exports]\n mod serialization2;\n \n // Local Variables:"}, {"sha": "264711584fcad0dd75a0c8f851ecd05bc84d4434", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=c0b9986c8f11c85c74ee0ba64dccf4495027a645", "patch": "@@ -232,9 +232,24 @@ fn mk_ser_method(\n         bounds: @~[ast::bound_trait(ser_bound)],\n     }];\n \n+    let ty_s = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n+\n     let ser_inputs = ~[{\n-        mode: ast::expl(ast::by_ref),\n-        ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_s,\n         ident: cx.ident_of(~\"__s\"),\n         id: cx.next_id(),\n     }];\n@@ -255,7 +270,7 @@ fn mk_ser_method(\n         ident: cx.ident_of(~\"serialize\"),\n         attrs: ~[],\n         tps: ser_tps,\n-        self_ty: { node: ast::sty_by_ref, span: span },\n+        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n         purity: ast::impure_fn,\n         decl: ser_decl,\n         body: ser_body,\n@@ -288,9 +303,24 @@ fn mk_deser_method(\n         bounds: @~[ast::bound_trait(deser_bound)],\n     }];\n \n+    let ty_d = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n+\n     let deser_inputs = ~[{\n-        mode: ast::expl(ast::by_ref),\n-        ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_d,\n         ident: cx.ident_of(~\"__d\"),\n         id: cx.next_id(),\n     }];\n@@ -608,11 +638,14 @@ fn mk_enum_ser_body(\n         }\n     };\n \n-    // ast for `match self { $(arms) }`\n+    // ast for `match *self { $(arms) }`\n     let match_expr = cx.expr(\n         span,\n         ast::expr_match(\n-            cx.expr_var(span, ~\"self\"),\n+            cx.expr(\n+                span,\n+                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n+            ),\n             arms\n         )\n     );"}, {"sha": "e395b1bfe5de57341d8e629cbf089f74c018f9e0", "filename": "src/test/run-pass/auto_serialize2-box.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2-box.rs?ref=c0b9986c8f11c85c74ee0ba64dccf4495027a645", "patch": "@@ -0,0 +1,73 @@\n+// xfail-test FIXME Blocked on (#3585)\n+\n+extern mod std;\n+\n+// These tests used to be separate files, but I wanted to refactor all\n+// the common code.\n+\n+use cmp::Eq;\n+use std::ebml2;\n+use io::Writer;\n+use std::serialization2::{Serializer, Serializable, deserialize};\n+use std::prettyprint2;\n+\n+fn test_ser_and_deser<A:Eq Serializable>(\n+    a1: A,\n+    expected: ~str\n+) {\n+    // check the pretty printer:\n+    let s = do io::with_str_writer |w| {\n+        a1.serialize(&prettyprint2::Serializer(w))\n+    };\n+    debug!(\"s == %?\", s);\n+    assert s == expected;\n+\n+    // check the EBML serializer:\n+    let bytes = do io::with_bytes_writer |wr| {\n+        let ebml_w = &ebml2::Serializer(wr);\n+        a1.serialize(ebml_w)\n+    };\n+    let d = ebml2::Doc(@bytes);\n+    let a2: A = deserialize(&ebml2::Deserializer(d));\n+    assert a1 == a2;\n+}\n+\n+#[auto_serialize2]\n+enum Expr {\n+    Val(uint),\n+    Plus(@Expr, @Expr),\n+    Minus(@Expr, @Expr)\n+}\n+\n+impl Expr : cmp::Eq {\n+    pure fn eq(other: &Expr) -> bool {\n+        match self {\n+            Val(e0a) => {\n+                match *other {\n+                    Val(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Plus(e0a, e1a) => {\n+                match *other {\n+                    Plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            Minus(e0a, e1a) => {\n+                match *other {\n+                    Minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Expr) -> bool { !self.eq(other) }\n+}\n+\n+fn main() {\n+    test_ser_and_deser(Plus(@Minus(@Val(3u), @Val(10u)),\n+                            @Plus(@Val(22u), @Val(5u))),\n+                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n+                        @Plus(@Val(22u), @Val(5u)))\");\n+}"}, {"sha": "ac526a8f0b6b03b94035ef7d04a44a5d842462da", "filename": "src/test/run-pass/auto_serialize2.rs", "status": "modified", "additions": 29, "deletions": 62, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b9986c8f11c85c74ee0ba64dccf4495027a645/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs?ref=c0b9986c8f11c85c74ee0ba64dccf4495027a645", "patch": "@@ -15,98 +15,71 @@ fn test_ser_and_deser<A:Eq Serializable>(\n ) {\n \n     // check the pretty printer:\n-    let s = io::with_str_writer(|w| a1.serialize(w));\n+    let s = do io::with_str_writer |w| {\n+        a1.serialize(&prettyprint2::Serializer(w))\n+    };\n     debug!(\"s == %?\", s);\n     assert s == expected;\n \n     // check the EBML serializer:\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = ebml2::Serializer(wr);\n+        let ebml_w = &ebml2::Serializer(wr);\n         a1.serialize(ebml_w)\n     };\n     let d = ebml2::Doc(@bytes);\n-    let a2: A = deserialize(ebml2::Deserializer(d));\n+    let a2: A = deserialize(&ebml2::Deserializer(d));\n     assert a1 == a2;\n }\n \n-#[auto_serialize2]\n-enum Expr {\n-    Val(uint),\n-    Plus(@Expr, @Expr),\n-    Minus(@Expr, @Expr)\n-}\n-\n impl AnEnum : cmp::Eq {\n-    pure fn eq(&&other: AnEnum) -> bool {\n+    pure fn eq(other: &AnEnum) -> bool {\n         self.v == other.v\n     }\n-    pure fn ne(&&other: AnEnum) -> bool { !self.eq(other) }\n+    pure fn ne(other: &AnEnum) -> bool { !self.eq(other) }\n }\n \n impl Point : cmp::Eq {\n-    pure fn eq(&&other: Point) -> bool {\n+    pure fn eq(other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n-    pure fn ne(&&other: Point) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Point) -> bool { !self.eq(other) }\n }\n \n impl<T:cmp::Eq> Quark<T> : cmp::Eq {\n-    pure fn eq(&&other: Quark<T>) -> bool {\n+    pure fn eq(other: &Quark<T>) -> bool {\n         match self {\n-          Top(ref q) => match other {\n-            Top(ref r) => q == r,\n-            Bottom(_) => false\n-          },\n-          Bottom(ref q) => match other {\n-            Top(_) => false,\n-            Bottom(ref r) => q == r\n-          }\n+            Top(ref q) => {\n+                match *other {\n+                    Top(ref r) => q == r,\n+                    Bottom(_) => false\n+                }\n+            },\n+            Bottom(ref q) => {\n+                match *other {\n+                    Top(_) => false,\n+                    Bottom(ref r) => q == r\n+                }\n+            },\n         }\n     }\n-    pure fn ne(&&other: Quark<T>) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Quark<T>) -> bool { !self.eq(other) }\n }\n \n impl CLike : cmp::Eq {\n-    pure fn eq(&&other: CLike) -> bool {\n-        self as int == other as int\n-    }\n-    pure fn ne(&&other: CLike) -> bool { !self.eq(other) }\n-}\n-\n-impl Expr : cmp::Eq {\n-    pure fn eq(&&other: Expr) -> bool {\n-        match self {\n-            Val(e0a) => {\n-                match other {\n-                    Val(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Plus(e0a, e1a) => {\n-                match other {\n-                    Plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Minus(e0a, e1a) => {\n-                match other {\n-                    Minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n+    pure fn eq(other: &CLike) -> bool {\n+        self as int == *other as int\n     }\n-    pure fn ne(&&other: Expr) -> bool { !self.eq(other) }\n+    pure fn ne(other: &CLike) -> bool { !self.eq(other) }\n }\n \n #[auto_serialize2]\n type Spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n-    pure fn eq(&&other: Spanned<T>) -> bool {\n-        self.lo == other.lo && self.hi == other.hi && self.node.eq(other.node)\n+    pure fn eq(other: &Spanned<T>) -> bool {\n+        self.lo == other.lo && self.hi == other.hi && self.node == other.node\n     }\n-    pure fn ne(&&other: Spanned<T>) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Spanned<T>) -> bool { !self.eq(other) }\n }\n \n #[auto_serialize2]\n@@ -128,12 +101,6 @@ enum Quark<T> {\n enum CLike { A, B, C }\n \n fn main() {\n-\n-    test_ser_and_deser(Plus(@Minus(@Val(3u), @Val(10u)),\n-                            @Plus(@Val(22u), @Val(5u))),\n-                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n-                        @Plus(@Val(22u), @Val(5u)))\");\n-\n     test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n                        ~\"{lo: 0u, hi: 5u, node: 22u}\");\n "}]}