{"sha": "515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNWMzYmM1OWJmYzIyN2NiYmI4MmY4MGI1M2M1YzEyNWJlNGZjMzA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T11:15:46Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T12:48:04Z"}, "message": "Cleanup", "tree": {"sha": "c4087228b2443a562c60906306f5a1385fb6968d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4087228b2443a562c60906306f5a1385fb6968d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "html_url": "https://github.com/rust-lang/rust/commit/515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7348f7883fa2bd571fff036c82e98c102d05c362", "url": "https://api.github.com/repos/rust-lang/rust/commits/7348f7883fa2bd571fff036c82e98c102d05c362", "html_url": "https://github.com/rust-lang/rust/commit/7348f7883fa2bd571fff036c82e98c102d05c362"}], "stats": {"total": 218, "additions": 110, "deletions": 108}, "files": [{"sha": "f2912d235360908c40f534671281fc7e4ec25d5e", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "patch": "@@ -516,8 +516,14 @@ impl AnalysisImpl {\n         let syntax = file.syntax();\n         let node = find_covering_node(syntax, range);\n         let parent_fn = node.ancestors().filter_map(FnDef::cast).next();\n-        let parent_fn = if let Some(p) = parent_fn { p } else { return Ok(None) };\n-        let function = ctry!(source_binder::function_from_source(&*self.db, file_id, parent_fn)?);\n+        let parent_fn = if let Some(p) = parent_fn {\n+            p\n+        } else {\n+            return Ok(None);\n+        };\n+        let function = ctry!(source_binder::function_from_source(\n+            &*self.db, file_id, parent_fn\n+        )?);\n         let infer = function.infer(&*self.db);\n         Ok(infer.type_of_node(node).map(|t| t.to_string()))\n     }"}, {"sha": "88bce19607fbd2030d7ccd58e45e5069642ac025", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 49, "deletions": 64, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "patch": "@@ -2,24 +2,21 @@ mod primitive;\n #[cfg(test)]\n mod tests;\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n use std::sync::Arc;\n-use std::collections::HashMap;\n use std::fmt;\n \n+use rustc_hash::{FxHashMap};\n+\n use ra_db::LocalSyntaxPtr;\n use ra_syntax::{\n-    TextRange, TextUnit, SmolStr,\n-    algo::visit::{visitor, Visitor},\n-    ast::{self, AstNode, DocCommentsOwner, NameOwner, LoopBodyOwner, ArgListOwner},\n+    SmolStr,\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner},\n     SyntaxNodeRef\n };\n \n use crate::{\n     FnScopes,\n     db::HirDatabase,\n-    arena::{Arena, Id},\n };\n \n // pub(crate) type TypeId = Id<Ty>;\n@@ -150,9 +147,17 @@ impl Ty {\n             TupleType(_inner) => Ty::Unknown, // TODO\n             NeverType(..) => Ty::Never,\n             PathType(inner) => {\n-                let path = if let Some(p) = inner.path() { p } else { return Ty::Unknown };\n+                let path = if let Some(p) = inner.path() {\n+                    p\n+                } else {\n+                    return Ty::Unknown;\n+                };\n                 if path.qualifier().is_none() {\n-                    let name = path.segment().and_then(|s| s.name_ref()).map(|n| n.text()).unwrap_or(SmolStr::new(\"\"));\n+                    let name = path\n+                        .segment()\n+                        .and_then(|s| s.name_ref())\n+                        .map(|n| n.text())\n+                        .unwrap_or(SmolStr::new(\"\"));\n                     if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n                         Ty::Int(int_ty)\n                     } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n@@ -167,16 +172,16 @@ impl Ty {\n                     // TODO\n                     Ty::Unknown\n                 }\n-            },\n-            PointerType(_inner) => Ty::Unknown, // TODO\n-            ArrayType(_inner) => Ty::Unknown, // TODO\n-            SliceType(_inner) => Ty::Unknown, // TODO\n-            ReferenceType(_inner) => Ty::Unknown, // TODO\n+            }\n+            PointerType(_inner) => Ty::Unknown,     // TODO\n+            ArrayType(_inner) => Ty::Unknown,       // TODO\n+            SliceType(_inner) => Ty::Unknown,       // TODO\n+            ReferenceType(_inner) => Ty::Unknown,   // TODO\n             PlaceholderType(_inner) => Ty::Unknown, // TODO\n-            FnPointerType(_inner) => Ty::Unknown, // TODO\n-            ForType(_inner) => Ty::Unknown, // TODO\n-            ImplTraitType(_inner) => Ty::Unknown, // TODO\n-            DynTraitType(_inner) => Ty::Unknown, // TODO\n+            FnPointerType(_inner) => Ty::Unknown,   // TODO\n+            ForType(_inner) => Ty::Unknown,         // TODO\n+            ImplTraitType(_inner) => Ty::Unknown,   // TODO\n+            DynTraitType(_inner) => Ty::Unknown,    // TODO\n         }\n     }\n \n@@ -203,7 +208,7 @@ impl fmt::Display for Ty {\n                 }\n                 write!(f, \")\")\n             }\n-            Ty::Unknown => write!(f, \"[unknown]\")\n+            Ty::Unknown => write!(f, \"[unknown]\"),\n         }\n     }\n }\n@@ -230,15 +235,15 @@ impl InferenceContext {\n     fn new(scopes: Arc<FnScopes>) -> Self {\n         InferenceContext {\n             type_for: FxHashMap::default(),\n-            scopes\n+            scopes,\n         }\n     }\n \n     fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n         self.type_for.insert(LocalSyntaxPtr::new(node), ty);\n     }\n \n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+    fn unify(&mut self, _ty1: &Ty, _ty2: &Ty) -> bool {\n         unimplemented!()\n     }\n \n@@ -303,7 +308,7 @@ impl InferenceContext {\n                 if let Some(expr) = e.iterable() {\n                     self.infer_expr(expr);\n                 }\n-                if let Some(pat) = e.pat() {\n+                if let Some(_pat) = e.pat() {\n                     // TODO write type for pat\n                 }\n                 if let Some(block) = e.loop_body() {\n@@ -313,7 +318,7 @@ impl InferenceContext {\n                 Ty::Unknown\n             }\n             ast::Expr::LambdaExpr(e) => {\n-                let body_ty = if let Some(body) = e.body() {\n+                let _body_ty = if let Some(body) = e.body() {\n                     self.infer_expr(body)\n                 } else {\n                     Ty::Unknown\n@@ -339,7 +344,7 @@ impl InferenceContext {\n                 Ty::Unknown\n             }\n             ast::Expr::MatchExpr(e) => {\n-                let ty = if let Some(match_expr) = e.expr() {\n+                let _ty = if let Some(match_expr) = e.expr() {\n                     self.infer_expr(match_expr)\n                 } else {\n                     Ty::Unknown\n@@ -348,7 +353,7 @@ impl InferenceContext {\n                     for arm in match_arm_list.arms() {\n                         // TODO type the bindings in pat\n                         // TODO type the guard\n-                        let ty = if let Some(e) = arm.expr() {\n+                        let _ty = if let Some(e) = arm.expr() {\n                             self.infer_expr(e)\n                         } else {\n                             Ty::Unknown\n@@ -360,12 +365,8 @@ impl InferenceContext {\n                     Ty::Unknown\n                 }\n             }\n-            ast::Expr::TupleExpr(e) => {\n-                Ty::Unknown\n-            }\n-            ast::Expr::ArrayExpr(e) => {\n-                Ty::Unknown\n-            }\n+            ast::Expr::TupleExpr(_e) => Ty::Unknown,\n+            ast::Expr::ArrayExpr(_e) => Ty::Unknown,\n             ast::Expr::PathExpr(e) => {\n                 if let Some(p) = e.path() {\n                     if p.qualifier().is_none() {\n@@ -392,22 +393,16 @@ impl InferenceContext {\n                     Ty::Unknown\n                 }\n             }\n-            ast::Expr::ContinueExpr(e) => {\n-                Ty::Never\n-            }\n-            ast::Expr::BreakExpr(e) => {\n-                Ty::Never\n-            }\n+            ast::Expr::ContinueExpr(_e) => Ty::Never,\n+            ast::Expr::BreakExpr(_e) => Ty::Never,\n             ast::Expr::ParenExpr(e) => {\n                 if let Some(e) = e.expr() {\n                     self.infer_expr(e)\n                 } else {\n                     Ty::Unknown\n                 }\n             }\n-            ast::Expr::Label(e) => {\n-                Ty::Unknown\n-            }\n+            ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n                 if let Some(e) = e.expr() {\n                     // TODO unify with return type\n@@ -419,29 +414,23 @@ impl InferenceContext {\n                 // Can this even occur outside of a match expression?\n                 Ty::Unknown\n             }\n-            ast::Expr::StructLit(e) => {\n-                Ty::Unknown\n-            }\n+            ast::Expr::StructLit(_e) => Ty::Unknown,\n             ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n                 // Can this even occur outside of a struct literal?\n                 Ty::Unknown\n             }\n-            ast::Expr::IndexExpr(e) => {\n-                Ty::Unknown\n-            }\n-            ast::Expr::FieldExpr(e) => {\n-                Ty::Unknown\n-            }\n+            ast::Expr::IndexExpr(_e) => Ty::Unknown,\n+            ast::Expr::FieldExpr(_e) => Ty::Unknown,\n             ast::Expr::TryExpr(e) => {\n-                let inner_ty = if let Some(e) = e.expr() {\n+                let _inner_ty = if let Some(e) = e.expr() {\n                     self.infer_expr(e)\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n             ast::Expr::CastExpr(e) => {\n-                let inner_ty = if let Some(e) = e.expr() {\n+                let _inner_ty = if let Some(e) = e.expr() {\n                     self.infer_expr(e)\n                 } else {\n                     Ty::Unknown\n@@ -451,30 +440,24 @@ impl InferenceContext {\n                 cast_ty\n             }\n             ast::Expr::RefExpr(e) => {\n-                let inner_ty = if let Some(e) = e.expr() {\n+                let _inner_ty = if let Some(e) = e.expr() {\n                     self.infer_expr(e)\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n             ast::Expr::PrefixExpr(e) => {\n-                let inner_ty = if let Some(e) = e.expr() {\n+                let _inner_ty = if let Some(e) = e.expr() {\n                     self.infer_expr(e)\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n-            ast::Expr::RangeExpr(e) => {\n-                Ty::Unknown\n-            }\n-            ast::Expr::BinExpr(e) => {\n-                Ty::Unknown\n-            }\n-            ast::Expr::Literal(e) => {\n-                Ty::Unknown\n-            }\n+            ast::Expr::RangeExpr(_e) => Ty::Unknown,\n+            ast::Expr::BinExpr(_e) => Ty::Unknown,\n+            ast::Expr::Literal(_e) => Ty::Unknown,\n         };\n         self.write_ty(expr.syntax(), ty.clone());\n         ty\n@@ -505,7 +488,7 @@ impl InferenceContext {\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) -> InferenceResult {\n+pub fn infer(_db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) -> InferenceResult {\n     let mut ctx = InferenceContext::new(scopes);\n \n     for param in node.param_list().unwrap().params() {\n@@ -522,5 +505,7 @@ pub fn infer(db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) ->\n \n     // TODO 'resolve' the types: replace inference variables by their inferred results\n \n-    InferenceResult { type_for: ctx.type_for }\n+    InferenceResult {\n+        type_for: ctx.type_for,\n+    }\n }"}, {"sha": "0880b51bc7cb6623765259a455c626999bde8e03", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "patch": "@@ -1,31 +1,38 @@\n use std::fmt::Write;\n-use std::sync::Arc;\n-use std::path::{Path, PathBuf};\n+use std::path::{PathBuf};\n \n-use salsa::Database;\n-use ra_db::{FilesDatabase, CrateGraph, SyntaxDatabase};\n-use ra_syntax::{SmolStr, algo::visit::{visitor, Visitor}, ast::{self, AstNode}};\n+use ra_db::{SyntaxDatabase};\n+use ra_syntax::ast::{self, AstNode};\n use test_utils::{project_dir, dir_tests};\n-use relative_path::RelativePath;\n-\n-use crate::{source_binder, mock::WORKSPACE, module::ModuleSourceNode};\n \n use crate::{\n-    self as hir,\n-    db::HirDatabase,\n+    source_binder,\n     mock::MockDatabase,\n };\n \n fn infer_file(content: &str) -> String {\n-    let (db, source_root, file_id) = MockDatabase::with_single_file(content);\n+    let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);\n     let mut acc = String::new();\n-    for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n-        let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap().unwrap();\n+    for fn_def in source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::FnDef::cast)\n+    {\n+        let func = source_binder::function_from_source(&db, file_id, fn_def)\n+            .unwrap()\n+            .unwrap();\n         let inference_result = func.infer(&db);\n         for (syntax_ptr, ty) in &inference_result.type_for {\n             let node = syntax_ptr.resolve(&source_file);\n-            write!(acc, \"{} '{}': {}\\n\", syntax_ptr.range(), ellipsize(node.text().to_string().replace(\"\\n\", \" \"), 15), ty);\n+            write!(\n+                acc,\n+                \"{} '{}': {}\\n\",\n+                syntax_ptr.range(),\n+                ellipsize(node.text().to_string().replace(\"\\n\", \" \"), 15),\n+                ty\n+            )\n+            .unwrap();\n         }\n     }\n     acc\n@@ -51,9 +58,7 @@ fn ellipsize(mut text: String, max_len: usize) -> String {\n \n #[test]\n pub fn infer_tests() {\n-    dir_tests(&test_data_dir(), &[\".\"], |text, _path| {\n-        infer_file(text)\n-    });\n+    dir_tests(&test_data_dir(), &[\".\"], |text, _path| infer_file(text));\n }\n \n fn test_data_dir() -> PathBuf {"}, {"sha": "2235dc401d937dddb15380809de860a59b209028", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515c3bc59bfc227cbbb82f80b53c5c125be4fc30/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=515c3bc59bfc227cbbb82f80b53c5c125be4fc30", "patch": "@@ -1,12 +1,10 @@\n extern crate ra_syntax;\n-#[macro_use]\n extern crate test_utils;\n extern crate walkdir;\n \n use std::{\n     fmt::Write,\n-    fs,\n-    path::{Path, PathBuf, Component},\n+    path::{PathBuf, Component},\n };\n \n use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n@@ -25,28 +23,36 @@ fn lexer_tests() {\n \n #[test]\n fn parser_tests() {\n-    dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n-        let file = SourceFileNode::parse(text);\n-        let errors = file.errors();\n-        assert_eq!(\n-            &*errors,\n-            &[] as &[ra_syntax::SyntaxError],\n-            \"There should be no errors in the file {:?}\",\n-            path.display()\n-        );\n-        dump_tree(file.syntax())\n-    });\n-    dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n-        let file = SourceFileNode::parse(text);\n-        let errors = file.errors();\n-        assert_ne!(\n-            &*errors,\n-            &[] as &[ra_syntax::SyntaxError],\n-            \"There should be errors in the file {:?}\",\n-            path.display()\n-        );\n-        dump_tree(file.syntax())\n-    });\n+    dir_tests(\n+        &test_data_dir(),\n+        &[\"parser/inline/ok\", \"parser/ok\"],\n+        |text, path| {\n+            let file = SourceFileNode::parse(text);\n+            let errors = file.errors();\n+            assert_eq!(\n+                &*errors,\n+                &[] as &[ra_syntax::SyntaxError],\n+                \"There should be no errors in the file {:?}\",\n+                path.display()\n+            );\n+            dump_tree(file.syntax())\n+        },\n+    );\n+    dir_tests(\n+        &test_data_dir(),\n+        &[\"parser/err\", \"parser/inline/err\"],\n+        |text, path| {\n+            let file = SourceFileNode::parse(text);\n+            let errors = file.errors();\n+            assert_ne!(\n+                &*errors,\n+                &[] as &[ra_syntax::SyntaxError],\n+                \"There should be errors in the file {:?}\",\n+                path.display()\n+            );\n+            dump_tree(file.syntax())\n+        },\n+    );\n }\n \n #[test]"}]}