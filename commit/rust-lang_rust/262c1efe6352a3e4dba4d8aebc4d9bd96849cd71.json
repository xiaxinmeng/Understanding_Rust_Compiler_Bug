{"sha": "262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MmMxZWZlNjM1MmEzZTRkYmE0ZDhhZWJjNGQ5YmQ5Njg0OWNkNzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T03:40:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T23:04:43Z"}, "message": "Register new snapshots", "tree": {"sha": "4096f26993c2db2e0c95181170ef63f46cf3cb7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4096f26993c2db2e0c95181170ef63f46cf3cb7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "comment_count": 20, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "html_url": "https://github.com/rust-lang/rust/commit/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "023dfb0c898d851dee6ace2f8339b73b5287136b", "url": "https://api.github.com/repos/rust-lang/rust/commits/023dfb0c898d851dee6ace2f8339b73b5287136b", "html_url": "https://github.com/rust-lang/rust/commit/023dfb0c898d851dee6ace2f8339b73b5287136b"}], "stats": {"total": 767, "additions": 11, "deletions": 756}, "files": [{"sha": "9fea4467db59a121bc48289edeb6c6c9f2579a73", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -989,20 +989,11 @@ pub trait ToString {\n }\n \n impl<T: fmt::Show> ToString for T {\n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     fn to_string(&self) -> String {\n         let mut buf = Vec::<u8>::new();\n         let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n         String::from_utf8(buf).unwrap()\n     }\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn to_string(&self) -> String {\n-        let mut buf = Vec::<u8>::new();\n-        let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);\n-        String::from_utf8(buf).unwrap()\n-    }\n }\n \n impl IntoCow<'static, String, str> for String {"}, {"sha": "3787ae33fdaad39d448e241bbf2f39aa87e104be", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -325,18 +325,9 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let mut filler = Filler { buf: &mut buf, end: &mut end };\n             match sign {\n-                // NOTE(stage0): Remove cfg after a snapshot\n-                #[cfg(not(stage0))]\n                 SignNeg => {\n                     let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n                 }\n-                // NOTE(stage0): Remove match arm after a snapshot\n-                #[cfg(stage0)]\n-                SignNeg => {\n-                    let _ = format_args!(|args| {\n-                        fmt::write(&mut filler, args)\n-                    }, \"{:-}\", exp);\n-                }\n             }\n         }\n     }"}, {"sha": "9d275c9da9cb377c3e986a5371bd5ee80201c437", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -70,21 +70,11 @@ pub trait FormatWriter {\n     /// This function will return an instance of `FormatError` on error.\n     fn write(&mut self, bytes: &[u8]) -> Result;\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n     fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n-\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Glue for usage of the `write!` macro with implementers of this trait.\n-    ///\n-    /// This method should generally not be invoked manually, but rather through\n-    /// the `write!` macro itself.\n-    fn write_fmt(&mut self, args: &Arguments) -> Result { write(self, args) }\n }\n \n /// A struct to represent both where to emit formatting strings to and how they\n@@ -204,17 +194,9 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Show for Arguments<'a> {\n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n-\n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        write(fmt.buf, self)\n-    }\n }\n \n /// When a format is not otherwise specified, types are formatted by ascribing\n@@ -287,8 +269,6 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n     }\n };\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -342,61 +322,6 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     Ok(())\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n-#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                  implementation detail which should not otherwise be exported\"]\n-pub fn write(output: &mut FormatWriter, args: &Arguments) -> Result {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: rt::AlignUnknown,\n-        fill: ' ',\n-        args: args.args,\n-        curarg: args.args.iter(),\n-    };\n-\n-    let mut pieces = args.pieces.iter();\n-\n-    match args.fmt {\n-        None => {\n-            // We can use default formatting parameters for all arguments.\n-            for _ in range(0, args.args.len()) {\n-                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n-                try!(formatter.run(&DEFAULT_ARGUMENT));\n-            }\n-        }\n-        Some(fmt) => {\n-            // Every spec has a corresponding argument that is preceded by\n-            // a string piece.\n-            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write(piece.as_bytes()));\n-                try!(formatter.run(arg));\n-            }\n-        }\n-    }\n-\n-    // There can be only one trailing string piece left.\n-    match pieces.next() {\n-        Some(piece) => {\n-            try!(formatter.buf.write(piece.as_bytes()));\n-        }\n-        None => {}\n-    }\n-\n-    Ok(())\n-}\n-\n impl<'a> Formatter<'a> {\n \n     // First up is the collection of functions used to execute a format string\n@@ -603,22 +528,12 @@ impl<'a> Formatter<'a> {\n         self.buf.write(data)\n     }\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Writes some formatted information into this instance\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Writes some formatted information into this instance\n-    #[unstable = \"reconciling core and I/O may alter this definition\"]\n-    pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {\n-        write(self.buf, fmt)\n-    }\n-\n     /// Flags for formatting (packed version of rt::Flag)\n     #[experimental = \"return type may change and method was just created\"]\n     pub fn flags(&self) -> uint { self.flags }"}, {"sha": "e8fbd9d930f3388c8c4b3622cc2bad7affc865ca", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -10,8 +10,6 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -32,44 +30,6 @@ macro_rules! panic {\n     });\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Entry point of task panic, for details, see std::macros\n-#[macro_export]\n-macro_rules! panic {\n-    () => (\n-        panic!(\"{}\", \"explicit panic\")\n-    );\n-    ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n-        ::core::panicking::panic(&_MSG_FILE_LINE)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // a closure can't have return type !, so we need a full\n-        // function to pass to format_args!, *and* we need the\n-        // file and line numbers right here; so an inner bare fn\n-        // is our only choice.\n-        //\n-        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n-        // is #[cold] and #[inline(never)] and because this is flagged as cold\n-        // as returning !. We really do want this to be inlined, however,\n-        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n-        // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to panic!()\n-        //\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        #[inline(always)]\n-        fn _run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-            ::core::panicking::panic_fmt(fmt, &_FILE_LINE)\n-        }\n-        format_args!(_run_fmt, $fmt, $($arg)*)\n-    });\n-}\n-\n /// Runtime assertion, for details see std::macros\n #[macro_export]\n macro_rules! assert {\n@@ -119,25 +79,12 @@ macro_rules! try {\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Writing a formatted string into a writer\n #[macro_export]\n macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Writing a formatted string into a writer\n-#[macro_export]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ({\n-        let dst = &mut *$dst;\n-        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n-    })\n-}\n-\n /// Writing a formatted string plus a newline into a writer\n #[macro_export]\n macro_rules! writeln {"}, {"sha": "af07869e95feb291c707b46634adfc97b33469ed", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -292,58 +292,6 @@ rem_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n rem_float_impl! { f32, fmodf }\n rem_float_impl! { f64, fmod }\n \n-/// The `Neg` trait is used to specify the functionality of unary `-`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n-/// `neg`, and therefore, `main` prints `Negating!`.\n-///\n-/// ```\n-/// #[deriving(Copy)]\n-/// struct Foo;\n-///\n-/// impl Neg<Foo> for Foo {\n-///     fn neg(&self) -> Foo {\n-///         println!(\"Negating!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     -Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"neg\"]\n-pub trait Neg<Result> for Sized? {\n-    /// The method for the unary `-` operator\n-    fn neg(&self) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! neg_impl {\n-    ($($t:ty)*) => ($(\n-        impl Neg<$t> for $t {\n-            #[inline]\n-            fn neg(&self) -> $t { -*self }\n-        }\n-    )*)\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! neg_uint_impl {\n-    ($t:ty, $t_signed:ty) => {\n-        impl Neg<$t> for $t {\n-            #[inline]\n-            fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n-        }\n-    }\n-}\n-\n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///\n /// # Example\n@@ -367,14 +315,12 @@ macro_rules! neg_uint_impl {\n ///     -Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"neg\"]\n pub trait Neg<Result> {\n     /// The method for the unary `-` operator\n     fn neg(self) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         impl Neg<$t> for $t {\n@@ -384,7 +330,6 @@ macro_rules! neg_impl {\n     )*)\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n         impl Neg<$t> for $t {\n@@ -403,48 +348,6 @@ neg_uint_impl! { u32, i32 }\n neg_uint_impl! { u64, i64 }\n \n \n-/// The `Not` trait is used to specify the functionality of unary `!`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n-/// `not`, and therefore, `main` prints `Not-ing!`.\n-///\n-/// ```\n-/// #[deriving(Copy)]\n-/// struct Foo;\n-///\n-/// impl Not<Foo> for Foo {\n-///     fn not(&self) -> Foo {\n-///         println!(\"Not-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     !Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"not\"]\n-pub trait Not<Result> for Sized? {\n-    /// The method for the unary `!` operator\n-    fn not(&self) -> Result;\n-}\n-\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! not_impl {\n-    ($($t:ty)*) => ($(\n-        impl Not<$t> for $t {\n-            #[inline]\n-            fn not(&self) -> $t { !*self }\n-        }\n-    )*)\n-}\n-\n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///\n /// # Example\n@@ -468,14 +371,12 @@ macro_rules! not_impl {\n ///     !Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"not\"]\n pub trait Not<Result> {\n     /// The method for the unary `!` operator\n     fn not(self) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         impl Not<$t> for $t {"}, {"sha": "61b4284e1dd9c08aa617571da9e4d08356846ed0", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -31,34 +31,14 @@\n #![allow(dead_code, missing_docs)]\n \n use fmt;\n-// NOTE(stage0): Remove import after a snapshot\n-#[cfg(stage0)] use intrinsics;\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n     let (expr, file, line) = *expr_file_line;\n     panic_fmt(format_args!(\"{}\", expr), &(file, line))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"panic\"]\n-pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n-    let (expr, file, line) = *expr_file_line;\n-    let ref file_line = (file, line);\n-    format_args!(|args| -> () {\n-        panic_fmt(args, file_line);\n-    }, \"{}\", expr);\n-\n-    unsafe { intrinsics::abort() }\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)]\n #[lang=\"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, uint),\n@@ -67,20 +47,6 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n                            len, index), file_line)\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)]\n-#[lang=\"panic_bounds_check\"]\n-fn panic_bounds_check(file_line: &(&'static str, uint),\n-                     index: uint, len: uint) -> ! {\n-    format_args!(|args| -> () {\n-        panic_fmt(args, file_line);\n-    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n-    unsafe { intrinsics::abort() }\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(improper_ctypes)]\n@@ -91,18 +57,3 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     let (file, line) = *file_line;\n     unsafe { panic_impl(fmt, file, line) }\n }\n-\n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cold] #[inline(never)]\n-pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    #[allow(improper_ctypes)]\n-    extern {\n-        #[lang = \"panic_fmt\"]\n-        fn panic_impl(fmt: &fmt::Arguments, file: &'static str,\n-                        line: uint) -> !;\n-\n-    }\n-    let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line) }\n-}"}, {"sha": "b30938ae7f57770e1ca517e52a6314052c250ce5", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -268,8 +268,6 @@ impl Drop for DefaultLogger {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// This function is called directly by the compiler when using the logging\n /// macros. This function does not take into account whether the log level\n /// specified is active or not, it will always log something if this method is\n@@ -304,42 +302,6 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     set_logger(logger);\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// This function is called directly by the compiler when using the logging\n-/// macros. This function does not take into account whether the log level\n-/// specified is active or not, it will always log something if this method is\n-/// called.\n-///\n-/// It is not recommended to call this function directly, rather it should be\n-/// invoked through the logging family of macros.\n-#[doc(hidden)]\n-pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n-    // Test the literal string from args against the current filter, if there\n-    // is one.\n-    match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n-        _ => {}\n-    }\n-\n-    // Completely remove the local logger from TLS in case anyone attempts to\n-    // frob the slot while we're doing the logging. This will destroy any logger\n-    // set during logging.\n-    let mut logger = LOCAL_LOGGER.with(|s| {\n-        s.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n-    });\n-    logger.log(&LogRecord {\n-        level: LogLevel(level),\n-        args: *args,\n-        file: loc.file,\n-        module_path: loc.module_path,\n-        line: loc.line,\n-    });\n-    set_logger(logger);\n-}\n-\n /// Getter for the global log level. This is a function so that it can be called\n /// safely\n #[doc(hidden)]"}, {"sha": "233d1c049f4e5e2bcdc69327f0c014a2e4069b98", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -12,8 +12,6 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a\n@@ -67,61 +65,6 @@ macro_rules! log {\n     })\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// The standard logging macro\n-///\n-/// This macro will generically log over a provided level (of type u32) with a\n-/// format!-based argument list. See documentation in `std::fmt` for details on\n-/// how to use the syntax.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n-///\n-/// fn main() {\n-///     log!(log::WARN, \"this is a warning {}\", \"message\");\n-///     log!(log::DEBUG, \"this is a debug message\");\n-///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n-/// }\n-/// ```\n-///\n-/// Assumes the binary is `main`:\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=warn ./main\n-/// WARN:main: this is a warning message\n-/// ```\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=debug ./main\n-/// DEBUG:main: this is a debug message\n-/// WARN:main: this is a warning message\n-/// ```\n-///\n-/// ```{.bash}\n-/// $ RUST_LOG=6 ./main\n-/// DEBUG:main: this is a debug message\n-/// WARN:main: this is a warning message\n-/// 6:main: this is a custom logging level: 6\n-/// ```\n-#[macro_export]\n-macro_rules! log {\n-    ($lvl:expr, $($arg:tt)+) => ({\n-        static LOC: ::log::LogLocation = ::log::LogLocation {\n-            line: line!(),\n-            file: file!(),\n-            module_path: module_path!(),\n-        };\n-        let lvl = $lvl;\n-        if log_enabled!(lvl) {\n-            format_args!(|args| { ::log::log(lvl, &LOC, args) }, $($arg)+)\n-        }\n-    })\n-}\n-\n /// A convenience macro for logging at the error log level.\n ///\n /// # Example"}, {"sha": "aeb4df402a2cff3ffa96169caac74a237dc00dee", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -241,17 +241,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl Not<$BitFlags> for $BitFlags {\n-            /// Returns the complement of this set of flags.\n-            #[inline]\n-            fn not(&self) -> $BitFlags {\n-                $BitFlags { bits: !self.bits } & $BitFlags::all()\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl Not<$BitFlags> for $BitFlags {\n             /// Returns the complement of this set of flags.\n             #[inline]"}, {"sha": "957dd54a037cf86376dd462d6996434e33c77791", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -406,8 +406,6 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n #[doc(hidden)]\n pub use core::fmt::{argument, argumentuint};\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n@@ -431,31 +429,6 @@ pub fn format(args: Arguments) -> string::String {\n     string::String::from_utf8(output).unwrap()\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n-///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-///\n-/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\".to_string());\n-/// ```\n-#[experimental = \"this is an implementation detail of format! and should not \\\n-                  be called directly\"]\n-pub fn format(args: &Arguments) -> string::String {\n-    let mut output = Vec::new();\n-    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n-    string::String::from_utf8(output).unwrap()\n-}\n-\n impl<'a> Writer for Formatter<'a> {\n     fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n         match (*self).write(b) {"}, {"sha": "8d5b125bb081fc268f93ffc03854ddfbb083c078", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -1017,8 +1017,6 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n-    // NOTE(stage0): Remove cfg after a snapshot\n-    #[cfg(not(stage0))]\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n@@ -1057,45 +1055,6 @@ pub trait Writer {\n     }\n \n \n-    // NOTE(stage0): Remove method after a snapshot\n-    #[cfg(stage0)]\n-    /// Writes a formatted string into this writer, returning any error\n-    /// encountered.\n-    ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return any I/O error reported while formatting.\n-    fn write_fmt(&mut self, fmt: &fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a FormatWriter and saves\n-        // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T:'a> {\n-            inner: &'a mut T,\n-            error: IoResult<()>,\n-        }\n-\n-        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n-            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                match self.inner.write(bytes) {\n-                    Ok(()) => Ok(()),\n-                    Err(e) => {\n-                        self.error = Err(e);\n-                        Err(fmt::Error)\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut output = Adaptor { inner: self, error: Ok(()) };\n-        match fmt::write(&mut output, fmt) {\n-            Ok(()) => Ok(()),\n-            Err(..) => output.error\n-        }\n-    }\n-\n     /// Write a rust string into this sink.\n     ///\n     /// The bytes written will be the UTF-8 encoded version of the input string."}, {"sha": "43d2e078035a6ef83c60982d836b7e17e261b8bd", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -378,38 +378,18 @@ pub fn println(s: &str) {\n     })\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n-/// with the `format_args!` macro.\n-pub fn print_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| write!(io, \"{}\", fmt))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n-/// compatible with the `format_args!` macro.\n-pub fn println_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n-}\n-\n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n     inner: StdSource"}, {"sha": "ebb64bc2f2d518a8081fe3b79ed1de3742ff9a17", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -17,8 +17,6 @@\n #![experimental]\n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The entry point for panic of Rust tasks.\n ///\n /// This macro is used to inject panic into a Rust task, causing the task to\n@@ -59,63 +57,6 @@ macro_rules! panic {\n     });\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// The entry point for panic of Rust tasks.\n-///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n-/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n-/// the value which is transmitted.\n-///\n-/// The multi-argument form of this macro panics with a string and has the\n-/// `format!` syntax for building a string.\n-///\n-/// # Example\n-///\n-/// ```should_fail\n-/// # #![allow(unreachable_code)]\n-/// panic!();\n-/// panic!(\"this is a terrible mistake!\");\n-/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n-/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n-/// ```\n-#[macro_export]\n-macro_rules! panic {\n-    () => ({\n-        panic!(\"explicit panic\")\n-    });\n-    ($msg:expr) => ({\n-        // static requires less code at runtime, more constant data\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // a closure can't have return type !, so we need a full\n-        // function to pass to format_args!, *and* we need the\n-        // file and line numbers right here; so an inner bare fn\n-        // is our only choice.\n-        //\n-        // LLVM doesn't tend to inline this, presumably because begin_unwind_fmt\n-        // is #[cold] and #[inline(never)] and because this is flagged as cold\n-        // as returning !. We really do want this to be inlined, however,\n-        // because it's just a tiny wrapper. Small wins (156K to 149K in size)\n-        // were seen when forcing this to be inlined, and that number just goes\n-        // up with the number of calls to panic!()\n-        //\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        #[inline(always)]\n-        fn _run_fmt(fmt: &::std::fmt::Arguments) -> ! {\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-            ::std::rt::begin_unwind_fmt(fmt, &_FILE_LINE)\n-        }\n-        format_args!(_run_fmt, $fmt, $($arg)*)\n-    });\n-}\n-\n /// Ensure that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the `panic!` macro if the provided expression cannot be\n@@ -289,8 +230,6 @@ macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///\n@@ -307,28 +246,6 @@ macro_rules! format {\n     ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! format {\n-    ($($arg:tt)*) => (\n-        format_args!(::std::fmt::format, $($arg)*)\n-    )\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n ///\n@@ -347,29 +264,6 @@ macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ({\n-        let dst = &mut *$dst;\n-        format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n-    })\n-}\n-\n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n@@ -380,8 +274,6 @@ macro_rules! writeln {\n     )\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -390,18 +282,6 @@ macro_rules! print {\n     ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Equivalent to the `println!` macro except that a newline is not printed at\n-/// the end of the message.\n-#[macro_export]\n-#[stable]\n-macro_rules! print {\n-    ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// Macro for printing to a task's stdout handle.\n ///\n /// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n@@ -420,26 +300,6 @@ macro_rules! println {\n     ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-/// Macro for printing to a task's stdout handle.\n-///\n-/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n-/// The syntax of this macro is the same as that used for `format!`. For more\n-/// information, see `std::fmt` and `std::io::stdio`.\n-///\n-/// # Example\n-///\n-/// ```\n-/// println!(\"hello there!\");\n-/// println!(\"format {} arguments\", \"some\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! println {\n-    ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n-}\n-\n /// Helper macro for unwrapping `Result` values while returning early with an\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`."}, {"sha": "0f35500a04a737469e510e52e7e7212b1c56881c", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -15,22 +15,12 @@\n \n #![macro_escape]\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))\n     } )\n }\n \n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rterrln {\n-    ($fmt:expr $($arg:tt)*) => ( {\n-        format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n-    } )\n-}\n-\n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n macro_rules! rtdebug {\n     ($($arg:tt)*) => ( {\n@@ -50,14 +40,6 @@ macro_rules! rtassert {\n     } )\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n macro_rules! rtabort {\n     ($($arg:tt)*) => (::rt::util::abort(format_args!($($arg)*)))\n }\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rtabort {\n-    ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n-}"}, {"sha": "c273c52daccadbb5551cbea9a79d6955685271de", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -477,8 +477,6 @@ pub mod eabi {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n #[cfg(not(test))]\n /// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n@@ -487,18 +485,6 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-#[cfg(not(test))]\n-/// Entry point of panic from the libcore crate.\n-#[lang = \"panic_fmt\"]\n-pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n-    begin_unwind_fmt(msg, &(file, line))\n-}\n-\n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call\n@@ -530,39 +516,6 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n     begin_unwind_inner(msg, file_line)\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-/// The entry point for unwinding with a formatted message.\n-///\n-/// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `panic!()` has as low an impact\n-/// on (e.g.) the inlining of other functions as possible), by moving\n-/// the actual formatting into this shared place.\n-#[inline(never)] #[cold]\n-pub fn begin_unwind_fmt(msg: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use fmt::FormatWriter;\n-\n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_unwind\n-    // below).\n-\n-    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n-\n-    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n-        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-            self.v.push_all(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut v = Vec::new();\n-    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n-\n-    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n-    begin_unwind_inner(msg, file_line)\n-}\n-\n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {"}, {"sha": "5448af3f753b33eeb7e415a99c181241e45e4be8", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -112,25 +112,11 @@ impl fmt::FormatWriter for Stdio {\n     }\n }\n \n-// NOTE(stage0): Remove cfg after a snapshot\n-#[cfg(not(stage0))]\n pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr.write_fmt(args);\n }\n \n-// NOTE(stage0): Remove function after a snapshot\n-#[cfg(stage0)]\n-pub fn dumb_print(args: &fmt::Arguments) {\n-    let mut w = Stderr;\n-    let _ = write!(&mut w, \"{}\", args);\n-}\n-\n-// NOTE(stage0): Remove wrappers after a snapshot\n-#[cfg(not(stage0))] pub fn abort(args: fmt::Arguments) -> ! { abort_(&args) }\n-#[cfg(stage0)] pub fn abort(args: &fmt::Arguments) -> ! { abort_(args) }\n-\n-// NOTE(stage0): Change to `pub fn abort(args: fmt::Arguments) -> !` after a snapshot\n-fn abort_(args: &fmt::Arguments) -> ! {\n+pub fn abort(args: fmt::Arguments) -> ! {\n     use fmt::FormatWriter;\n \n     struct BufWriter<'a> {"}, {"sha": "14dd2a1ac9b587208c3426338331c8c498808f72", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -189,22 +189,7 @@ macro_rules! __thread_local_inner {\n             }\n         };\n \n-        #[cfg(all(stage0, not(any(target_os = \"macos\", target_os = \"linux\"))))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n-            unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::destroy_value::<$t>(ptr);\n-            }\n-\n-            ::std::thread_local::KeyInner {\n-                inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::OsStaticKey {\n-                    inner: ::std::thread_local::OS_INIT_INNER,\n-                    dtor: ::std::option::Option::Some(__destroy),\n-                },\n-            }\n-        };\n-\n-        #[cfg(all(not(stage0), not(any(target_os = \"macos\", target_os = \"linux\"))))]\n+        #[cfg(all(not(any(target_os = \"macos\", target_os = \"linux\"))))]\n         const INIT: ::std::thread_local::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n                 ::std::thread_local::destroy_value::<$t>(ptr);\n@@ -346,16 +331,10 @@ mod imp {\n         // *should* be the case that this loop always terminates because we\n         // provide the guarantee that a TLS key cannot be set after it is\n         // flagged for destruction.\n-        #[cfg(not(stage0))]\n         static DTORS: os::StaticKey = os::StaticKey {\n             inner: os::INIT_INNER,\n             dtor: Some(run_dtors as unsafe extern \"C\" fn(*mut u8)),\n         };\n-        #[cfg(stage0)]\n-        static DTORS: os::StaticKey = os::StaticKey {\n-            inner: os::INIT_INNER,\n-            dtor: Some(run_dtors),\n-        };\n         type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n         if DTORS.get().is_null() {\n             let v: Box<List> = box Vec::new();"}, {"sha": "51564b539768d81fd063cf23c6258b0ec77b35af", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -262,20 +262,6 @@ impl Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Neg<Duration> for Duration {\n-    #[inline]\n-    fn neg(&self) -> Duration {\n-        if self.nanos == 0 {\n-            Duration { secs: -self.secs, nanos: 0 }\n-        } else {\n-            Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Neg<Duration> for Duration {\n     #[inline]\n     fn neg(self) -> Duration {"}, {"sha": "930aa0270647c1d84e46d20d981b24faa345cf21", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -24,8 +24,6 @@\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-#[cfg(stage0)]\n-extern crate serialize;\n extern crate \"serialize\" as rustc_serialize;\n extern crate libc;\n "}, {"sha": "6a9bfa07cf77121c11d3c450b8f389afcabcbcee", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/262c1efe6352a3e4dba4d8aebc4d9bd96849cd71/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=262c1efe6352a3e4dba4d8aebc4d9bd96849cd71", "patch": "@@ -1,3 +1,12 @@\n+S 2014-12-30 023dfb0\n+  freebsd-x86_64 41ecd0ac557c823831c46696c7d78dc250398f25\n+  linux-i386 fe6b59bf70a397e18629cb82264f7c6a70df34d4\n+  linux-x86_64 8ab3a223f65fbf6b0aa80fcf0564a6d0fb9122e8\n+  macos-i386 d23edb1be58b8683782a473cdc249c58a959c165\n+  macos-x86_64 ab87616fa5d427978db3acd2d705042133ca3c09\n+  winnt-i386 f2c26ac1ccb9d9a00886da9b504190681de89a5f\n+  winnt-x86_64 fa2c7636bb15583ae387554b561ab09babee281a\n+\n S 2014-12-20 8443b09\n   freebsd-x86_64 004f54dce86faeebc15abf92c8742634b53987e6\n   linux-i386 3daf531aed03f5769402f2fef852377e2838db98"}]}