{"sha": "6d236626891f206d5974e2fac03e3fa816279b74", "node_id": "C_kwDOAAsO6NoAKDZkMjM2NjI2ODkxZjIwNmQ1OTc0ZTJmYWMwM2UzZmE4MTYyNzliNzQ", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-09-24T19:46:50Z"}, "committer": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-10-03T18:04:58Z"}, "message": "Add {gather,scatter}_select_unchecked\n\nThis unsafe variant allows the thinnest API, in case LLVM cannot\nperform loop-invariant code motion on a hot loop when the safe\nform is used.\n\nAn unchecked variant could be added to other forms, but doesn't\nseem likely to improve anything, since it would just add heavier\ncodegen.", "tree": {"sha": "a8bcbbdce5411dc68bcc73d9da17b5bc2c4c7df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8bcbbdce5411dc68bcc73d9da17b5bc2c4c7df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d236626891f206d5974e2fac03e3fa816279b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d236626891f206d5974e2fac03e3fa816279b74", "html_url": "https://github.com/rust-lang/rust/commit/6d236626891f206d5974e2fac03e3fa816279b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d236626891f206d5974e2fac03e3fa816279b74/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "436ca7f7aa60f0ffe2591a1e5658e85f9e0af22f", "url": "https://api.github.com/repos/rust-lang/rust/commits/436ca7f7aa60f0ffe2591a1e5658e85f9e0af22f", "html_url": "https://github.com/rust-lang/rust/commit/436ca7f7aa60f0ffe2591a1e5658e85f9e0af22f"}], "stats": {"total": 72, "additions": 66, "deletions": 6}, "files": [{"sha": "82b440896f0d7ad383e9ec29c42d455e56483c4d", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6d236626891f206d5974e2fac03e3fa816279b74/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d236626891f206d5974e2fac03e3fa816279b74/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=6d236626891f206d5974e2fac03e3fa816279b74", "patch": "@@ -119,12 +119,42 @@ where\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n+        let mask: Mask<isize, LANES> = mask & idxs.lanes_lt(Simd::splat(slice.len()));\n+        // SAFETY: We have masked-off out-of-bounds lanes.\n+        unsafe { Self::gather_select_unchecked(slice, mask, idxs, or) }\n+    }\n+\n+    /// Unsafe SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// Masked indices instead select the value from the \"or\" vector.\n+    /// `gather_select_unchecked` is unsound if any unmasked index is out-of-bounds of the slice.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// // If this mask was used to gather, it would be unsound. Let's fix that.\n+    /// let mask = mask & idxs.lanes_lt(Simd::splat(vec.len()));\n+    ///\n+    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// let result = unsafe { Simd::gather_select_unchecked(&vec, mask, idxs, alt) };\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub unsafe fn gather_select_unchecked(\n+        slice: &[T],\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+        or: Self,\n+    ) -> Self {\n         let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n         // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, mask) }\n+        unsafe { intrinsics::simd_gather(or, ptrs, mask.to_int()) }\n     }\n \n     /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n@@ -168,12 +198,42 @@ where\n         mask: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        // We must construct our scatter mask before we derive a pointer!\n-        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n+        let mask: Mask<isize, LANES> = mask & idxs.lanes_lt(Simd::splat(slice.len()));\n+        // SAFETY: We have masked-off out-of-bounds lanes.\n+        unsafe { self.scatter_select_unchecked(slice, mask, idxs) }\n+    }\n+\n+    /// Unsafe SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds or masked indices are not written.\n+    /// `scatter_select_unchecked` is unsound if any unmasked index is out of bounds of the slice.\n+    /// `scatter_select_unchecked` writes \"in order\", so if the same index receives two writes, only the last is guaranteed.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::{Simd, Mask};\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n+    /// let mask = mask & idxs.lanes_lt(Simd::splat(vec.len()));\n+    ///\n+    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// unsafe { vals.scatter_select_unchecked(&mut vec, mask, idxs); }\n+    /// // index 0's second write is masked, thus was omitted.\n+    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub unsafe fn scatter_select_unchecked(\n+        self,\n+        slice: &mut [T],\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+    ) {\n         // SAFETY: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n         // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n-        // Even though this block is largely safe methods, it must be almost exactly this way\n+        // Even though this block is largely safe methods, it must be exactly this way\n         // to prevent invalidating the raw ptrs while they're live.\n         // Thus, entering this block requires all values to use being already ready:\n         // 0. idxs we want to write to, which are used to construct the mask.\n@@ -186,7 +246,7 @@ where\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, mask)\n+            intrinsics::simd_scatter(self, ptrs, mask.to_int())\n             // Cleared \u2622\ufe0f *mut T Zone\n         }\n     }"}]}