{"sha": "0e97240f984106ae9f21886c690d55220a2ee932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOTcyNDBmOTg0MTA2YWU5ZjIxODg2YzY5MGQ1NTIyMGEyZWU5MzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-05T23:42:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-09T12:26:05Z"}, "message": "isolate predecessor computation\n\nThe new `Predecessors` type computes a set of interesting targets and\ntheir HIR predecessors, and discards everything in between.", "tree": {"sha": "f3d469c40206d90d0681f40fba259de12d242827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3d469c40206d90d0681f40fba259de12d242827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e97240f984106ae9f21886c690d55220a2ee932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e97240f984106ae9f21886c690d55220a2ee932", "html_url": "https://github.com/rust-lang/rust/commit/0e97240f984106ae9f21886c690d55220a2ee932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e97240f984106ae9f21886c690d55220a2ee932/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b6dc20d8edcb72c45eeccf7fb0356fc991ca52", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b6dc20d8edcb72c45eeccf7fb0356fc991ca52", "html_url": "https://github.com/rust-lang/rust/commit/82b6dc20d8edcb72c45eeccf7fb0356fc991ca52"}], "stats": {"total": 139, "additions": 121, "deletions": 18}, "files": [{"sha": "536cefbbe3f0dc824bbb48ec66092319af3e26e2", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=0e97240f984106ae9f21886c690d55220a2ee932", "patch": "@@ -22,6 +22,12 @@ impl BitVector {\n         BitVector { data: vec![0; num_words] }\n     }\n \n+    pub fn clear(&mut self) {\n+        for p in &mut self.data {\n+            *p = 0;\n+        }\n+    }\n+\n     pub fn contains(&self, bit: usize) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0"}, {"sha": "4561a3d084c2064183aac1d611cf1850d514b608", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=0e97240f984106ae9f21886c690d55220a2ee932", "patch": "@@ -296,12 +296,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n                               start: NodeIndex,\n                               direction: Direction)\n                               -> DepthFirstTraversal<'a, N, E> {\n-        DepthFirstTraversal {\n-            graph: self,\n-            stack: vec![start],\n-            visited: BitVector::new(self.nodes.len()),\n-            direction: direction,\n-        }\n+        DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n }\n \n@@ -378,26 +373,57 @@ pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n     direction: Direction,\n }\n \n+impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n+    pub fn new(graph: &'g Graph<N, E>, direction: Direction) -> Self {\n+        let visited = BitVector::new(graph.len_nodes());\n+        DepthFirstTraversal {\n+            graph: graph,\n+            stack: vec![],\n+            visited: visited,\n+            direction: direction\n+        }\n+    }\n+\n+    pub fn with_start_node(graph: &'g Graph<N, E>,\n+                           start_node: NodeIndex,\n+                           direction: Direction)\n+                           -> Self {\n+        let mut visited = BitVector::new(graph.len_nodes());\n+        visited.insert(start_node.node_id());\n+        DepthFirstTraversal {\n+            graph: graph,\n+            stack: vec![start_node],\n+            visited: visited,\n+            direction: direction\n+        }\n+    }\n+\n+    pub fn reset(&mut self, start_node: NodeIndex) {\n+        self.stack.truncate(0);\n+        self.stack.push(start_node);\n+        self.visited.clear();\n+        self.visited.insert(start_node.node_id());\n+    }\n+\n+    fn visit(&mut self, node: NodeIndex) {\n+        if self.visited.insert(node.node_id()) {\n+            self.stack.push(node);\n+        }\n+    }\n+}\n+\n impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     type Item = NodeIndex;\n \n     fn next(&mut self) -> Option<NodeIndex> {\n-        while let Some(idx) = self.stack.pop() {\n-            if !self.visited.insert(idx.node_id()) {\n-                continue;\n-            }\n-\n+        let next = self.stack.pop();\n+        if let Some(idx) = next {\n             for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n                 let target = edge.source_or_target(self.direction);\n-                if !self.visited.contains(target.node_id()) {\n-                    self.stack.push(target);\n-                }\n+                self.visit(target);\n             }\n-\n-            return Some(idx);\n         }\n-\n-        return None;\n+        next\n     }\n }\n "}, {"sha": "344b05f095457ec4d5e2c6eccce7bf0b31afab94", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=0e97240f984106ae9f21886c690d55220a2ee932", "patch": "@@ -39,6 +39,14 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n+    pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n+        match *dep_node {\n+            DepNode::Hir(_) => true,\n+            DepNode::MetaData(def_id) => !def_id.is_local(),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<(DefId, u64)> {\n         match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:"}, {"sha": "634593bdeb09afbb21b500db3a739f07a8aafa58", "filename": "src/librustc_incremental/persist/preds.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e97240f984106ae9f21886c690d55220a2ee932/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=0e97240f984106ae9f21886c690d55220a2ee932", "patch": "@@ -0,0 +1,63 @@\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::hir::def_id::DefId;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n+\n+use super::hash::*;\n+\n+/// A data-structure that makes it easy to enumerate the hashable\n+/// predecessors of any given dep-node.\n+pub struct Predecessors<'query> {\n+    // - Keys: dep-nodes that may have work-products, output meta-data\n+    //   nodes.\n+    // - Values: transitive predecessors of the key that are hashable\n+    //   (e.g., HIR nodes, input meta-data nodes)\n+    pub inputs: FnvHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n+\n+    // - Keys: some hashable node\n+    // - Values: the hash thereof\n+    pub hashes: FnvHashMap<&'query DepNode<DefId>, u64>,\n+}\n+\n+impl<'q> Predecessors<'q> {\n+    pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n+        // Find nodes for which we want to know the full set of preds\n+        let mut dfs = DepthFirstTraversal::new(&query.graph, INCOMING);\n+        let all_nodes = query.graph.all_nodes();\n+        let tcx = hcx.tcx;\n+\n+        let inputs: FnvHashMap<_, _> = all_nodes.iter()\n+            .enumerate()\n+            .filter(|&(_, node)| match node.data {\n+                DepNode::WorkProduct(_) => true,\n+                DepNode::MetaData(ref def_id) => def_id.is_local(),\n+\n+                // if -Z query-dep-graph is passed, save more extended data\n+                // to enable better unit testing\n+                DepNode::TypeckItemBody(_) |\n+                DepNode::TransCrateItem(_) => tcx.sess.opts.debugging_opts.query_dep_graph,\n+\n+                _ => false,\n+            })\n+            .map(|(node_index, node)| {\n+                dfs.reset(NodeIndex(node_index));\n+                let inputs: Vec<_> = dfs.by_ref()\n+                    .map(|i| &all_nodes[i.node_id()].data)\n+                    .filter(|d| HashContext::is_hashable(d))\n+                    .collect();\n+                (&node.data, inputs)\n+            })\n+            .collect();\n+\n+        let mut hashes = FnvHashMap();\n+        for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n+            hashes.entry(input)\n+                  .or_insert_with(|| hcx.hash(input).unwrap().1);\n+        }\n+\n+        Predecessors {\n+            inputs: inputs,\n+            hashes: hashes,\n+        }\n+    }\n+}"}]}