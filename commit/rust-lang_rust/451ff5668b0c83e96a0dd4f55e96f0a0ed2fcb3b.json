{"sha": "451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MWZmNTY2OGIwYzgzZTk2YTBkZDRmNTVlOTZmMGEwZWQyZmNiM2I=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-05-20T09:59:34Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-05-20T10:05:02Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "9ab9964384834dcd86add24c425e3cf82c4eddaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ab9964384834dcd86add24c425e3cf82c4eddaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmCmNE8ACgkQHKDfKvWd\naKU0VxAAnOcjzrVGITIEMOaV4HJC1m5FSCGFzdIgzwzamcKmSG6jwi5WOwie1QCY\nOgyei1mo1LDLcib5Tq9FbW2y6fnh96yHNjTMOpAyEG5MxyT/ptvP+jJ2zL3tyuIv\nF/nKvMEF38SvNbQ7G/90WF/vUtCixf4n3Z/Mh6Ai4b3XTCR6oLyoE6ElV2E8uGuw\nJLw5eAbt019C0D8PUvjD5QjviEAnpuE0JxlpD7+v7jFGLPAa+3go/4mj4O0KfhJ/\neIVwaV5erj4+KFFowTFDmZ5R6y3RqqXdi9a82s3Kt+4rkEAArv4PusuTWQuOAMP8\nOjx0eEErxmqf58nrTsvaeIhHn1X4SbGEYKodRDgUSU5EgJv0+Pvr/oWBBmhK+qO9\nUr2IrF3Makv0LhAAKMEByKThFN8EEQb+X7DVTbjy2koJ9biZ3rfk9Tw2rS38Njtl\n6P1OGy5iULfMGWnNzxZtHc7ZIqTntkXhjCS2o+NFhNk/dDT/LXkPvZwnRA3su5IA\nqnhBchLEGu0ZrrGAWkaM9YtllbTec7f5kJmq2fHFcLHQZptMcC2bwxX4h5sP6Hi4\n1LkxdMqOWW+RPKqslGX1gR5EMO0NBrzPJd1UWb6Cnlg2TD4ZXhu9af5rReX6DjL3\nUtd4E2ruu1tqfhMF+K/zdBcgFx7PPr7iM4sNBGi/ipYYWyboEXU=\n=Q6V0\n-----END PGP SIGNATURE-----", "payload": "tree 9ab9964384834dcd86add24c425e3cf82c4eddaa\nparent 4f3b49fffa13518aa6006762c0eb6851c0c0b2d5\nparent 2d597b7fb9a0ce9a90a35c9146030770cb82544a\nauthor flip1995 <philipp.krones@embecosm.com> 1621504774 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1621505102 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "html_url": "https://github.com/rust-lang/rust/commit/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3b49fffa13518aa6006762c0eb6851c0c0b2d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3b49fffa13518aa6006762c0eb6851c0c0b2d5", "html_url": "https://github.com/rust-lang/rust/commit/4f3b49fffa13518aa6006762c0eb6851c0c0b2d5"}, {"sha": "2d597b7fb9a0ce9a90a35c9146030770cb82544a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d597b7fb9a0ce9a90a35c9146030770cb82544a", "html_url": "https://github.com/rust-lang/rust/commit/2d597b7fb9a0ce9a90a35c9146030770cb82544a"}], "stats": {"total": 3022, "additions": 2336, "deletions": 686}, "files": [{"sha": "e95ea224cb681361993f8643bd2be639d420a288", "filename": ".cargo/config", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -2,6 +2,7 @@\n uitest = \"test --test compile-test\"\n dev = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n lintcheck = \"run --target-dir lintcheck/target --package lintcheck --bin lintcheck --manifest-path lintcheck/Cargo.toml  -- \"\n+collect-metadata = \"test --test dogfood --features metadata-collector-lint -- run_metadata_collection_lint --ignored\"\n \n [build]\n rustflags = [\"-Zunstable-options\"]"}, {"sha": "f27fee87dc1653f508555f90661143aa338a5e2c", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -90,6 +90,11 @@ jobs:\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n+    # FIXME: should not be necessary once 1.24.2 is the default version on the windows runner\n+    - name: Update rustup\n+      run: rustup self update\n+      if: runner.os == 'Windows'\n+\n     - name: Install toolchain\n       run: rustup show active-toolchain\n "}, {"sha": "da5a0712c95dbdce9acf500b690a59ae33dbddab", "filename": "CHANGELOG.md", "status": "modified", "additions": 192, "deletions": 6, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -6,11 +6,195 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[6ed6f1e...master](https://github.com/rust-lang/rust-clippy/compare/6ed6f1e...master)\n+[7c7683c...master](https://github.com/rust-lang/rust-clippy/compare/7c7683c...master)\n+\n+## Rust 1.53\n+\n+Current beta, release 2021-06-17\n+\n+[6ed6f1e...7c7683c](https://github.com/rust-lang/rust-clippy/compare/6ed6f1e...7c7683c)\n+\n+### New Lints\n+\n+* [`option_filter_map`]\n+  [#6342](https://github.com/rust-lang/rust-clippy/pull/6342)\n+* [`branches_sharing_code`]\n+  [#6463](https://github.com/rust-lang/rust-clippy/pull/6463)\n+* [`needless_for_each`]\n+  [#6706](https://github.com/rust-lang/rust-clippy/pull/6706)\n+* [`if_then_some_else_none`]\n+  [#6859](https://github.com/rust-lang/rust-clippy/pull/6859)\n+* [`non_octal_unix_permissions`]\n+  [#7001](https://github.com/rust-lang/rust-clippy/pull/7001)\n+* [`unnecessary_self_imports`]\n+  [#7072](https://github.com/rust-lang/rust-clippy/pull/7072)\n+* [`bool_assert_comparison`]\n+  [#7083](https://github.com/rust-lang/rust-clippy/pull/7083)\n+* [`cloned_instead_of_copied`]\n+  [#7098](https://github.com/rust-lang/rust-clippy/pull/7098)\n+* [`flat_map_option`]\n+  [#7101](https://github.com/rust-lang/rust-clippy/pull/7101)\n+\n+### Moves and Deprecations\n+\n+* Deprecate [`filter_map`] lint\n+  [#7059](https://github.com/rust-lang/rust-clippy/pull/7059)\n+* Move [`transmute_ptr_to_ptr`] to `pedantic`\n+  [#7102](https://github.com/rust-lang/rust-clippy/pull/7102)\n+\n+### Enhancements\n+\n+* [`mem_replace_with_default`]: Also lint on common std constructors\n+  [#6820](https://github.com/rust-lang/rust-clippy/pull/6820)\n+* [`wrong_self_convention`]: Also lint on `to_*_mut` methods\n+  [#6828](https://github.com/rust-lang/rust-clippy/pull/6828)\n+* [`wildcard_enum_match_arm`], [`match_wildcard_for_single_variants`]:\n+  [#6863](https://github.com/rust-lang/rust-clippy/pull/6863)\n+    * Attempt to find a common path prefix in suggestion\n+    * Don't lint on `Option` and `Result`\n+    * Consider `Self` prefix\n+* [`explicit_deref_methods`]: Also lint on chained `deref` calls\n+  [#6865](https://github.com/rust-lang/rust-clippy/pull/6865)\n+* [`or_fun_call`]: Also lint on `unsafe` blocks\n+  [#6928](https://github.com/rust-lang/rust-clippy/pull/6928)\n+* [`vec_box`], [`linkedlist`], [`option_option`]: Also lint in `const` and\n+  `static` items [#6938](https://github.com/rust-lang/rust-clippy/pull/6938)\n+* [`search_is_some`]: Also check for `is_none`\n+  [#6942](https://github.com/rust-lang/rust-clippy/pull/6942)\n+* [`string_lit_as_bytes`]: Also lint on `into_bytes`\n+  [#6959](https://github.com/rust-lang/rust-clippy/pull/6959)\n+* [`len_without_is_empty`]: Also lint if function signatures of `len` and\n+  `is_empty` don't match\n+  [#6980](https://github.com/rust-lang/rust-clippy/pull/6980)\n+* [`redundant_pattern_matching`]: Also lint if the pattern is a `&` pattern\n+  [#6991](https://github.com/rust-lang/rust-clippy/pull/6991)\n+* [`clone_on_copy`]: Also lint on chained method calls taking `self` by value\n+  [#7000](https://github.com/rust-lang/rust-clippy/pull/7000)\n+* [`missing_panics_doc`]: Also lint on `assert_eq!` and `assert_ne!`\n+  [#7029](https://github.com/rust-lang/rust-clippy/pull/7029)\n+* [`needless_return`]: Also lint in `async` functions\n+  [#7067](https://github.com/rust-lang/rust-clippy/pull/7067)\n+* [`unused_io_amount`]: Also lint on expressions like `_.read().ok()?`\n+  [#7100](https://github.com/rust-lang/rust-clippy/pull/7100)\n+* [`iter_cloned_collect`]: Also lint on large arrays, since const-generics are\n+  now stable [#7138](https://github.com/rust-lang/rust-clippy/pull/7138)\n+\n+### False Positive Fixes\n+\n+* [`upper_case_acronyms`]: No longer lints on public items\n+  [#6805](https://github.com/rust-lang/rust-clippy/pull/6805)\n+* [`suspicious_map`]: No longer lints when side effects may occur inside the\n+  `map` call [#6831](https://github.com/rust-lang/rust-clippy/pull/6831)\n+* [`manual_map`], [`manual_unwrap_or`]: No longer lints in `const` functions\n+  [#6917](https://github.com/rust-lang/rust-clippy/pull/6917)\n+* [`wrong_self_convention`]: Now respects `Copy` types\n+  [#6924](https://github.com/rust-lang/rust-clippy/pull/6924)\n+* [`needless_question_mark`]: No longer lints if the `?` and the `Some(..)` come\n+  from different macro contexts [#6935](https://github.com/rust-lang/rust-clippy/pull/6935)\n+* [`map_entry`]: Better detect if the entry API can be used\n+  [#6937](https://github.com/rust-lang/rust-clippy/pull/6937)\n+* [`or_fun_call`]: No longer lints on some `len` function calls\n+  [#6950](https://github.com/rust-lang/rust-clippy/pull/6950)\n+* [`new_ret_no_self`]: No longer lints when `Self` is returned with different\n+  generic arguments [#6952](https://github.com/rust-lang/rust-clippy/pull/6952)\n+* [`upper_case_acronyms`]: No longer lints on public items\n+  [#6981](https://github.com/rust-lang/rust-clippy/pull/6981)\n+* [`explicit_into_iter_loop`]: Only lint when `into_iter` is an implementation\n+  of `IntoIterator` [#6982](https://github.com/rust-lang/rust-clippy/pull/6982)\n+* [`expl_impl_clone_on_copy`]: Take generic constraints into account before\n+  suggesting to use `derive` instead\n+  [#6993](https://github.com/rust-lang/rust-clippy/pull/6993)\n+* [`missing_panics_doc`]: No longer lints when only debug-assertions are used\n+  [#6996](https://github.com/rust-lang/rust-clippy/pull/6996)\n+* [`clone_on_copy`]: Only lint when using the `Clone` trait\n+  [#7000](https://github.com/rust-lang/rust-clippy/pull/7000)\n+* [`wrong_self_convention`]: No longer lints inside a trait implementation\n+  [#7002](https://github.com/rust-lang/rust-clippy/pull/7002)\n+* [`redundant_clone`]: No longer lints when the cloned value is modified while\n+  the clone is in use\n+  [#7011](https://github.com/rust-lang/rust-clippy/pull/7011)\n+* [`same_item_push`]: No longer lints if the `Vec` is used in the loop body\n+  [#7018](https://github.com/rust-lang/rust-clippy/pull/7018)\n+* [`cargo_common_metadata`]: Remove author requirement\n+  [#7026](https://github.com/rust-lang/rust-clippy/pull/7026)\n+* [`panic_in_result_fn`]: No longer lints on `debug_assert` family\n+  [#7060](https://github.com/rust-lang/rust-clippy/pull/7060)\n+* [`panic`]: No longer wrongfully lints on `debug_assert` with message\n+  [#7063](https://github.com/rust-lang/rust-clippy/pull/7063)\n+* [`wrong_self_convention`]: No longer lints in trait implementations where no\n+  `self` is involved [#7064](https://github.com/rust-lang/rust-clippy/pull/7064)\n+* [`missing_const_for_fn`]: No longer lints when unstable `const` function is\n+  involved [#7076](https://github.com/rust-lang/rust-clippy/pull/7076)\n+* [`suspicious_else_formatting`]: Allow Allman style braces\n+  [#7087](https://github.com/rust-lang/rust-clippy/pull/7087)\n+* [`inconsistent_struct_constructor`]: No longer lints in macros\n+  [#7097](https://github.com/rust-lang/rust-clippy/pull/7097)\n+* [`single_component_path_imports`]: No longer lints on macro re-exports\n+  [#7120](https://github.com/rust-lang/rust-clippy/pull/7120)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`redundant_pattern_matching`]: Add a note when applying this lint would\n+  change the drop order\n+  [#6568](https://github.com/rust-lang/rust-clippy/pull/6568)\n+* [`write_literal`], [`print_literal`]: Add auto-applicable suggestion\n+  [#6821](https://github.com/rust-lang/rust-clippy/pull/6821)\n+* [`manual_map`]: Fix suggestion for complex `if let ... else` chains\n+  [#6856](https://github.com/rust-lang/rust-clippy/pull/6856)\n+* [`inconsistent_struct_constructor`]: Make lint description and message clearer\n+  [#6892](https://github.com/rust-lang/rust-clippy/pull/6892)\n+* [`map_entry`]: Now suggests `or_insert`, `insert_with` or `match _.entry(_)`\n+  as appropriate [#6937](https://github.com/rust-lang/rust-clippy/pull/6937)\n+* [`manual_flatten`]: Suggest to insert `copied` if necessary\n+  [#6962](https://github.com/rust-lang/rust-clippy/pull/6962)\n+* [`redundant_slicing`]: Fix suggestion when a re-borrow might be required or\n+  when the value is from a macro call\n+  [#6975](https://github.com/rust-lang/rust-clippy/pull/6975)\n+* [`match_wildcard_for_single_variants`]: Fix suggestion for hidden variant\n+  [#6988](https://github.com/rust-lang/rust-clippy/pull/6988)\n+* [`clone_on_copy`]: Correct suggestion when the cloned value is a macro call\n+  [#7000](https://github.com/rust-lang/rust-clippy/pull/7000)\n+* [`manual_map`]: Fix suggestion at the end of an if chain\n+  [#7004](https://github.com/rust-lang/rust-clippy/pull/7004)\n+* Fix needless parenthesis output in multiple lint suggestions\n+  [#7013](https://github.com/rust-lang/rust-clippy/pull/7013)\n+* [`needless_collect`]: Better explanation in the lint message\n+  [#7020](https://github.com/rust-lang/rust-clippy/pull/7020)\n+* [`useless_vec`]: Now considers mutability\n+  [#7036](https://github.com/rust-lang/rust-clippy/pull/7036)\n+* [`useless_format`]: Wrap the content in braces if necessary\n+  [#7092](https://github.com/rust-lang/rust-clippy/pull/7092)\n+* [`single_match`]: Don't suggest an equality check for types which don't\n+  implement `PartialEq`\n+  [#7093](https://github.com/rust-lang/rust-clippy/pull/7093)\n+* [`from_over_into`]: Mention type in help message\n+  [#7099](https://github.com/rust-lang/rust-clippy/pull/7099)\n+* [`manual_unwrap_or`]: Fix invalid code suggestion due to a macro call\n+  [#7136](https://github.com/rust-lang/rust-clippy/pull/7136)\n+\n+### ICE Fixes\n+\n+* [`macro_use_imports`]\n+  [#7022](https://github.com/rust-lang/rust-clippy/pull/7022)\n+* [`missing_panics_doc`]\n+  [#7034](https://github.com/rust-lang/rust-clippy/pull/7034)\n+* [`tabs_in_doc_comments`]\n+  [#7039](https://github.com/rust-lang/rust-clippy/pull/7039)\n+* [`missing_const_for_fn`]\n+  [#7128](https://github.com/rust-lang/rust-clippy/pull/7128)\n+\n+### Others\n+\n+* [Clippy's lint\n+  list](https://rust-lang.github.io/rust-clippy/master/index.html) now supports\n+  themes [#7030](https://github.com/rust-lang/rust-clippy/pull/7030)\n+* Lints that were uplifted to `rustc` now mention the new `rustc` name in the\n+  deprecation warning\n+  [#7056](https://github.com/rust-lang/rust-clippy/pull/7056)\n \n ## Rust 1.52\n \n-Current beta, release 2021-05-06\n+Current stable, released 2021-05-06\n \n [3e41797...6ed6f1e](https://github.com/rust-lang/rust-clippy/compare/3e41797...6ed6f1e)\n \n@@ -99,7 +283,7 @@ Current beta, release 2021-05-06\n   [#6682](https://github.com/rust-lang/rust-clippy/pull/6682)\n * [`unit_arg`]: No longer lints on unit arguments when they come from a path expression.\n   [#6601](https://github.com/rust-lang/rust-clippy/pull/6601)\n-* [`cargo_common_metadata`]: No longer lints if \n+* [`cargo_common_metadata`]: No longer lints if\n   [`publish = false`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field)\n   is defined in the manifest\n   [#6650](https://github.com/rust-lang/rust-clippy/pull/6650)\n@@ -124,11 +308,11 @@ Current beta, release 2021-05-06\n \n * [`useless_format`]: Improved the documentation example\n   [#6854](https://github.com/rust-lang/rust-clippy/pull/6854)\n-* Clippy's [`README.md`]: Includes a new subsection on running Clippy as a rustc wrapper \n+* Clippy's [`README.md`]: Includes a new subsection on running Clippy as a rustc wrapper\n   [#6782](https://github.com/rust-lang/rust-clippy/pull/6782)\n \n ### Others\n-* Running `cargo clippy` after `cargo check` now works as expected \n+* Running `cargo clippy` after `cargo check` now works as expected\n   (`cargo clippy` and `cargo check` no longer shares the same build cache)\n   [#6687](https://github.com/rust-lang/rust-clippy/pull/6687)\n * Cargo now re-runs Clippy if arguments after `--` provided to `cargo clippy` are changed.\n@@ -145,7 +329,7 @@ Current beta, release 2021-05-06\n \n ## Rust 1.51\n \n-Current stable, released 2021-03-25\n+Released 2021-03-25\n \n [4911ab1...3e41797](https://github.com/rust-lang/rust-clippy/compare/4911ab1...3e41797)\n \n@@ -2365,6 +2549,7 @@ Released 2018-09-13\n [`mutex_integer`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_integer\n [`naive_bytecount`]: https://rust-lang.github.io/rust-clippy/master/index.html#naive_bytecount\n [`needless_arbitrary_self_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_arbitrary_self_type\n+[`needless_bitwise_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bitwise_bool\n [`needless_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bool\n [`needless_borrow`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n [`needless_borrowed_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrowed_reference\n@@ -2538,6 +2723,7 @@ Released 2018-09-13\n [`unsound_collection_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsound_collection_transmute\n [`unstable_as_mut_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_mut_slice\n [`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice\n+[`unused_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_async\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self"}, {"sha": "848476a9d05847b616f819117763dfb7bb02fe3d", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -49,7 +49,7 @@ rustc-workspace-hack = \"1.0.0\"\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n \n [features]\n-deny-warnings = []\n+deny-warnings = [\"clippy_lints/deny-warnings\"]\n integration = [\"tempfile\"]\n internal-lints = [\"clippy_lints/internal-lints\"]\n metadata-collector-lint = [\"internal-lints\", \"clippy_lints/metadata-collector-lint\"]"}, {"sha": "69f42aca8b6900a092fc09e73aff9b23eea1e817", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,5 +1,7 @@\n-#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![feature(once_cell)]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+// warn on lints, that are included in `rust-lang/rust`s bootstrap\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use itertools::Itertools;\n use regex::Regex;"}, {"sha": "7040c257c831b0e49ec02e340ecdb4878876d8a1", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,4 +1,6 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+// warn on lints, that are included in `rust-lang/rust`s bootstrap\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n \n use clap::{App, Arg, ArgMatches, SubCommand};\n use clippy_dev::{bless, fmt, ide_setup, new_lint, serve, stderr_length_check, update_lints};"}, {"sha": "48f2972ec58d1887c166ebdd6f1e6d043c3adb74", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -30,7 +30,7 @@ rustc-semver = \"1.1.0\"\n url = { version = \"2.1.0\", features = [\"serde\"] }\n \n [features]\n-deny-warnings = []\n+deny-warnings = [\"clippy_utils/deny-warnings\"]\n # build clippy with internal lints enabled, off by default\n internal-lints = [\"clippy_utils/internal-lints\"]\n metadata-collector-lint = [\"serde_json\", \"clippy_utils/metadata-collector-lint\"]"}, {"sha": "50ffc2e3f1905c989f7ff95fba684269d68ba6e4", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,6 +1,13 @@\n+/// This struct fakes the `Lint` declaration that is usually created by `declare_lint!`. This\n+/// enables the simple extraction of the metadata without changing the current deprecation\n+/// declaration.\n+pub struct ClippyDeprecatedLint;\n+\n macro_rules! declare_deprecated_lint {\n-    (pub $name: ident, $_reason: expr) => {\n-        declare_lint!(pub $name, Allow, \"deprecated lint\")\n+    { $(#[$attr:meta])* pub $name: ident, $_reason: expr} => {\n+        $(#[$attr])*\n+        #[allow(dead_code)]\n+        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {};\n     }\n }\n "}, {"sha": "840c1eba79d115ad120dffc8c8a9edaaebbfc792", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -12,7 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Span};\n+use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n@@ -310,15 +310,11 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &T\n     // there's a Copy impl for any instance of the adt.\n     if !is_copy(cx, ty) {\n         if ty_subs.non_erasable_generics().next().is_some() {\n-            let has_copy_impl = cx\n-                .tcx\n-                .all_local_trait_impls(())\n-                .get(&copy_id)\n-                .map_or(false, |impls| {\n-                    impls\n-                        .iter()\n-                        .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n-                });\n+            let has_copy_impl = cx.tcx.all_local_trait_impls(()).get(&copy_id).map_or(false, |impls| {\n+                impls\n+                    .iter()\n+                    .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n+            });\n             if !has_copy_impl {\n                 return;\n             }"}, {"sha": "e67ec4e06c547d3455f6cd83507ddd227d503a3e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -383,7 +383,7 @@ pub fn strip_doc_comment_decoration(doc: &str, comment_kind: CommentKind, span:\n     let mut no_stars = String::with_capacity(doc.len());\n     for line in doc.lines() {\n         let mut chars = line.chars();\n-        while let Some(c) = chars.next() {\n+        for c in &mut chars {\n             if c.is_whitespace() {\n                 no_stars.push(c);\n             } else {"}, {"sha": "08f28cd54c508637d9c231722be5c7935408beee", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -323,7 +323,7 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                         cx,\n                         SUBOPTIMAL_FLOPS,\n                         parent.span,\n-                        \"square can be computed more efficiently\",\n+                        \"multiply and add expressions can be calculated more efficiently and accurately\",\n                         \"consider using\",\n                         format!(\n                             \"{}.mul_add({}, {})\",\n@@ -337,16 +337,6 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                     return;\n                 }\n             }\n-\n-            span_lint_and_sugg(\n-                cx,\n-                SUBOPTIMAL_FLOPS,\n-                expr.span,\n-                \"square can be computed more efficiently\",\n-                \"consider using\",\n-                format!(\"{} * {}\", Sugg::hir(cx, &args[0], \"..\"), Sugg::hir(cx, &args[0], \"..\")),\n-                Applicability::MachineApplicable,\n-            );\n         }\n     }\n }"}, {"sha": "260a8f50157953076e286a66d4f3318a8cbd40a6", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -147,7 +147,11 @@ fn lint_implicit_returns(\n             visit_break_exprs(block, |break_expr, dest, sub_expr| {\n                 if dest.target_id.ok() == Some(expr.hir_id) {\n                     if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n-                        lint_break(cx, break_expr.span, sub_expr.unwrap().span);\n+                        // At this point sub_expr can be `None` in async functions which either diverge, or return the\n+                        // unit type.\n+                        if let Some(sub_expr) = sub_expr {\n+                            lint_break(cx, break_expr.span, sub_expr.span);\n+                        }\n                     } else {\n                         // the break expression is from a macro call, add a return to the loop\n                         add_return = true;"}, {"sha": "3b635071f28aa59109d367f0fd36e7d10671694f", "filename": "clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -58,7 +58,7 @@ declare_clippy_lint! {\n     /// Foo { x, y };\n     /// ```\n     pub INCONSISTENT_STRUCT_CONSTRUCTOR,\n-    style,\n+    pedantic,\n     \"the order of the field init shorthand is inconsistent with the order in the struct definition\"\n }\n "}, {"sha": "ee41c4aea2f7ec12366e016fc574f228c9f12b71", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 90, "deletions": 44, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,12 +1,13 @@\n //! lint on inherent implementations\n \n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::in_macro;\n-use rustc_hir::def_id::DefIdMap;\n-use rustc_hir::{Crate, Impl, Item, ItemKind};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::{in_macro, is_allowed};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{def_id::LocalDefId, Crate, Item, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n+use std::collections::hash_map::Entry;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for multiple inherent implementations of a struct\n@@ -40,51 +41,96 @@ declare_clippy_lint! {\n     \"Multiple inherent impl that could be grouped\"\n }\n \n-#[allow(clippy::module_name_repetitions)]\n-#[derive(Default)]\n-pub struct MultipleInherentImpl {\n-    impls: DefIdMap<Span>,\n-}\n-\n-impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n+declare_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n \n impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n-    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl(Impl {\n-            ref generics,\n-            of_trait: None,\n-            ..\n-        }) = item.kind\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n+        // Map from a type to it's first impl block. Needed to distinguish generic arguments.\n+        // e.g. `Foo<Bar>` and `Foo<Baz>`\n+        let mut type_map = FxHashMap::default();\n+        // List of spans to lint. (lint_span, first_span)\n+        let mut lint_spans = Vec::new();\n+\n+        for (_, impl_ids) in cx\n+            .tcx\n+            .crate_inherent_impls(())\n+            .inherent_impls\n+            .iter()\n+            .filter(|(&id, impls)| {\n+                impls.len() > 1\n+                    // Check for `#[allow]` on the type definition\n+                    && !is_allowed(\n+                        cx,\n+                        MULTIPLE_INHERENT_IMPL,\n+                        cx.tcx.hir().local_def_id_to_hir_id(id),\n+                    )\n+            })\n         {\n-            // Remember for each inherent implementation encountered its span and generics\n-            // but filter out implementations that have generic params (type or lifetime)\n-            // or are derived from a macro\n-            if !in_macro(item.span) && generics.params.is_empty() {\n-                self.impls.insert(item.def_id.to_def_id(), item.span);\n+            for impl_id in impl_ids.iter().map(|id| id.expect_local()) {\n+                match type_map.entry(cx.tcx.type_of(impl_id)) {\n+                    Entry::Vacant(e) => {\n+                        // Store the id for the first impl block of this type. The span is retrieved lazily.\n+                        e.insert(IdOrSpan::Id(impl_id));\n+                    },\n+                    Entry::Occupied(mut e) => {\n+                        if let Some(span) = get_impl_span(cx, impl_id) {\n+                            let first_span = match *e.get() {\n+                                IdOrSpan::Span(s) => s,\n+                                IdOrSpan::Id(id) => {\n+                                    if let Some(s) = get_impl_span(cx, id) {\n+                                        // Remember the span of the first block.\n+                                        *e.get_mut() = IdOrSpan::Span(s);\n+                                        s\n+                                    } else {\n+                                        // The first impl block isn't considered by the lint. Replace it with the\n+                                        // current one.\n+                                        *e.get_mut() = IdOrSpan::Span(span);\n+                                        continue;\n+                                    }\n+                                },\n+                            };\n+                            lint_spans.push((span, first_span));\n+                        }\n+                    },\n+                }\n             }\n+\n+            // Switching to the next type definition, no need to keep the current entries around.\n+            type_map.clear();\n         }\n-    }\n \n-    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'_>) {\n-        if !krate.items.is_empty() {\n-            // Retrieve all inherent implementations from the crate, grouped by type\n-            for impls in cx.tcx.crate_inherent_impls(()).inherent_impls.values() {\n-                // Filter out implementations that have generic params (type or lifetime)\n-                let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n-                if let Some(initial_span) = impl_spans.next() {\n-                    impl_spans.for_each(|additional_span| {\n-                        span_lint_and_then(\n-                            cx,\n-                            MULTIPLE_INHERENT_IMPL,\n-                            *additional_span,\n-                            \"multiple implementations of this structure\",\n-                            |diag| {\n-                                diag.span_note(*initial_span, \"first implementation here\");\n-                            },\n-                        )\n-                    })\n-                }\n-            }\n+        // `TyCtxt::crate_inherent_impls` doesn't have a defined order. Sort the lint output first.\n+        lint_spans.sort_by_key(|x| x.0.lo());\n+        for (span, first_span) in lint_spans {\n+            span_lint_and_note(\n+                cx,\n+                MULTIPLE_INHERENT_IMPL,\n+                span,\n+                \"multiple implementations of this structure\",\n+                Some(first_span),\n+                \"first implementation here\",\n+            );\n         }\n     }\n }\n+\n+/// Gets the span for the given impl block unless it's not being considered by the lint.\n+fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n+    let id = cx.tcx.hir().local_def_id_to_hir_id(id);\n+    if let Node::Item(&Item {\n+        kind: ItemKind::Impl(ref impl_item),\n+        span,\n+        ..\n+    }) = cx.tcx.hir().get(id)\n+    {\n+        (!in_macro(span) && impl_item.generics.params.is_empty() && !is_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n+            .then(|| span)\n+    } else {\n+        None\n+    }\n+}\n+\n+enum IdOrSpan {\n+    Id(LocalDefId),\n+    Span(Span),\n+}"}, {"sha": "2c83409b402a6a32eab18dae21d4017146363f6e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -6,7 +6,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(once_cell)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n #![feature(control_flow_enum)]\n@@ -163,6 +162,8 @@ macro_rules! extract_msrv_attr {\n mod consts;\n #[macro_use]\n mod utils;\n+#[cfg(feature = \"metadata-collector-lint\")]\n+mod deprecated_lints;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n mod absurd_extreme_comparisons;\n@@ -289,6 +290,7 @@ mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n mod needless_arbitrary_self_type;\n+mod needless_bitwise_bool;\n mod needless_bool;\n mod needless_borrow;\n mod needless_borrowed_ref;\n@@ -363,6 +365,7 @@ mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n+mod unused_async;\n mod unused_io_amount;\n mod unused_self;\n mod unused_unit;\n@@ -834,6 +837,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         mutex_atomic::MUTEX_ATOMIC,\n         mutex_atomic::MUTEX_INTEGER,\n         needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE,\n+        needless_bitwise_bool::NEEDLESS_BITWISE_BOOL,\n         needless_bool::BOOL_COMPARISON,\n         needless_bool::NEEDLESS_BOOL,\n         needless_borrow::NEEDLESS_BORROW,\n@@ -960,6 +964,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         unnecessary_wraps::UNNECESSARY_WRAPS,\n         unnested_or_patterns::UNNESTED_OR_PATTERNS,\n         unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n+        unused_async::UNUSED_ASYNC,\n         unused_io_amount::UNUSED_IO_AMOUNT,\n         unused_self::UNUSED_SELF,\n         unused_unit::UNUSED_UNIT,\n@@ -1008,7 +1013,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     #[cfg(feature = \"metadata-collector-lint\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n-            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::default());\n+            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::new());\n         }\n     }\n \n@@ -1019,6 +1024,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::Types::new(vec_box_size_threshold, type_complexity_threshold));\n     store.register_late_pass(|| box booleans::NonminimalBool);\n+    store.register_late_pass(|| box needless_bitwise_bool::NeedlessBitwiseBool);\n     store.register_late_pass(|| box eq_op::EqOp);\n     store.register_late_pass(|| box enum_clike::UnportableVariant);\n     store.register_late_pass(|| box float_literal::FloatLiteral);\n@@ -1155,7 +1161,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n+    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl);\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n     store.register_late_pass(|| box duration_subsec::DurationSubsec);\n@@ -1272,6 +1278,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box manual_map::ManualMap);\n     store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n     store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n+    store.register_late_pass(|| box unused_async::UnusedAsync);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(arithmetic::FLOAT_ARITHMETIC),\n@@ -1365,6 +1372,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(if_not_else::IF_NOT_ELSE),\n         LintId::of(implicit_hasher::IMPLICIT_HASHER),\n         LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n+        LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n         LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n         LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n         LintId::of(items_after_statements::ITEMS_AFTER_STATEMENTS),\n@@ -1392,6 +1400,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc::USED_UNDERSCORE_BINDING),\n         LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n         LintId::of(mut_mut::MUT_MUT),\n+        LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n         LintId::of(needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n@@ -1415,6 +1424,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(unit_types::LET_UNIT_VALUE),\n         LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n         LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n+        LintId::of(unused_async::UNUSED_ASYNC),\n         LintId::of(unused_self::UNUSED_SELF),\n         LintId::of(wildcard_imports::ENUM_GLOB_USE),\n         LintId::of(wildcard_imports::WILDCARD_IMPORTS),\n@@ -1511,7 +1521,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(identity_op::IDENTITY_OP),\n         LintId::of(if_let_mutex::IF_LET_MUTEX),\n         LintId::of(if_let_some_result::IF_LET_SOME_RESULT),\n-        LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n         LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n         LintId::of(infinite_iter::INFINITE_ITER),\n         LintId::of(inherent_to_string::INHERENT_TO_STRING),\n@@ -1764,7 +1773,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(functions::MUST_USE_UNIT),\n         LintId::of(functions::RESULT_UNIT_ERR),\n         LintId::of(if_let_some_result::IF_LET_SOME_RESULT),\n-        LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n         LintId::of(inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(len_zero::COMPARISON_TO_EMPTY),\n         LintId::of(len_zero::LEN_WITHOUT_IS_EMPTY),"}, {"sha": "47005aba38890927d0032c025252ab51c4a97f43", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "d34067808889c567805bd9174d4aa4934f41773b", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,16 +1,15 @@\n use super::NEEDLESS_COLLECT;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n-use clippy_utils::{is_trait_method, path_to_local_id, paths};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_trait_method, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{MultiSpan, Span};\n \n@@ -28,31 +27,45 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let Some(generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n-        if is_type_diagnostic_item(cx, ty, sym::vec_type)\n-            || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n-            || match_type(cx, ty, &paths::BTREEMAP)\n-            || is_type_diagnostic_item(cx, ty, sym::hashmap_type);\n-        if let Some(sugg) = match &*method.ident.name.as_str() {\n-            \"len\" => Some(\"count()\".to_string()),\n-            \"is_empty\" => Some(\"next().is_none()\".to_string()),\n-            \"contains\" => {\n-                let contains_arg = snippet(cx, args[1].span, \"??\");\n-                let (arg, pred) = contains_arg\n-                    .strip_prefix('&')\n-                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                Some(format!(\"any(|{}| x == {})\", arg, pred))\n-            }\n-            _ => None,\n-        };\n         then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let is_empty_sugg = \"next().is_none()\".to_string();\n+            let method_name = &*method.ident.name.as_str();\n+            let sugg = if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                        is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n+                        is_type_diagnostic_item(cx, ty, sym::LinkedList) ||\n+                        is_type_diagnostic_item(cx, ty, sym::BinaryHeap) {\n+                match method_name {\n+                    \"len\" => \"count()\".to_string(),\n+                    \"is_empty\" => is_empty_sugg,\n+                    \"contains\" => {\n+                        let contains_arg = snippet_with_applicability(cx, args[1].span, \"??\", &mut applicability);\n+                        let (arg, pred) = contains_arg\n+                            .strip_prefix('&')\n+                            .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                        format!(\"any(|{}| x == {})\", arg, pred)\n+                    }\n+                    _ => return,\n+                }\n+            }\n+            else if is_type_diagnostic_item(cx, ty, sym::BTreeMap) ||\n+                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n+                match method_name {\n+                    \"is_empty\" => is_empty_sugg,\n+                    _ => return,\n+                }\n+            }\n+            else {\n+                return;\n+            };\n             span_lint_and_sugg(\n                 cx,\n                 NEEDLESS_COLLECT,\n                 method0_span.with_hi(expr.span.hi()),\n                 NEEDLESS_COLLECT_MSG,\n                 \"replace with\",\n                 sugg,\n-                Applicability::MachineApplicable,\n+                applicability,\n             );\n         }\n     }\n@@ -86,7 +99,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n-                    match_type(cx, ty, &paths::LINKED_LIST);\n+                    is_type_diagnostic_item(cx, ty, sym::LinkedList);\n                 if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n                 if let [iter_call] = &*iter_calls;\n                 then {"}, {"sha": "63560047578a16aa0c39f8996745dbd02ab6c246", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 311, "deletions": 134, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,170 +1,347 @@\n-use super::utils::{LoopNestVisitor, Nesting};\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{\n-    get_enclosing_block, is_refutable, is_trait_method, last_path_segment, path_to_local, path_to_local_id,\n-};\n+use clippy_utils::{get_enclosing_loop, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource, Node, PatKind};\n+use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Node, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::sym;\n+use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Match(match_expr, arms, MatchSource::WhileLetDesugar) = expr.kind {\n-        let pat = &arms[0].pat.kind;\n-        if let (&PatKind::TupleStruct(ref qpath, pat_args, _), &ExprKind::MethodCall(method_path, _, method_args, _)) =\n-            (pat, &match_expr.kind)\n-        {\n-            let iter_expr = &method_args[0];\n-\n-            // Don't lint when the iterator is recreated on every iteration\n-            if_chain! {\n-                if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n-                if let Some(iter_def_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n+    let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n+        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        // check for `Some(..)` pattern\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let Res::Def(_, pat_did) = pat_path.res;\n+        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        // check for call to `Iterator::next`\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if method_name.ident.name == sym::next;\n+        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n+        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        // get the loop containing the match expression\n+        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n+        if !uses_iter(cx, &iter_expr, arm.body);\n+        then {\n+            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n+        } else {\n+            return;\n+        }\n+    };\n \n-            let lhs_constructor = last_path_segment(qpath);\n-            if method_path.ident.name == sym::next\n-                && is_trait_method(cx, match_expr, sym::Iterator)\n-                && lhs_constructor.ident.name == sym::Some\n-                && (pat_args.is_empty()\n-                    || !is_refutable(cx, pat_args[0])\n-                        && !is_used_inside(cx, iter_expr, arms[0].body)\n-                        && !is_iterator_used_after_while_let(cx, iter_expr)\n-                        && !is_nested(cx, expr, &method_args[0]))\n-            {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n-                let loop_var = if pat_args.is_empty() {\n-                    \"_\".to_string()\n-                } else {\n-                    snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n-                };\n-                span_lint_and_sugg(\n-                    cx,\n-                    WHILE_LET_ON_ITERATOR,\n-                    expr.span.with_hi(match_expr.span.hi()),\n-                    \"this loop could be written as a `for` loop\",\n-                    \"try\",\n-                    format!(\"for {} in {}\", loop_var, iterator),\n-                    applicability,\n-                );\n-            }\n+    let mut applicability = Applicability::MachineApplicable;\n+    let loop_var = if let Some(some_pat) = some_pat.first() {\n+        if is_refutable(cx, some_pat) {\n+            // Refutable patterns don't work with for loops.\n+            return;\n         }\n-    }\n-}\n+        snippet_with_applicability(cx, some_pat.span, \"..\", &mut applicability)\n+    } else {\n+        \"_\".into()\n+    };\n \n-fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(expr) {\n-        Some(id) => id,\n-        None => return false,\n+    // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n+    // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n+    // afterwards a mutable borrow of a field isn't necessary.\n+    let ref_mut = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+        \"&mut \"\n+    } else {\n+        \"\"\n     };\n-    if let Some(used_mutably) = mutated_variables(container, cx) {\n-        if used_mutably.contains(&def_id) {\n-            return true;\n+\n+    let iterator = snippet_with_applicability(cx, iter_expr.span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_ON_ITERATOR,\n+        expr.span.with_hi(scrutinee_expr.span.hi()),\n+        \"this loop could be written as a `for` loop\",\n+        \"try\",\n+        format!(\"for {} in {}{}\", loop_var, ref_mut, iterator),\n+        applicability,\n+    );\n+}\n+\n+#[derive(Debug)]\n+struct IterExpr {\n+    /// The span of the whole expression, not just the path and fields stored here.\n+    span: Span,\n+    /// The fields used, in order of child to parent.\n+    fields: Vec<Symbol>,\n+    /// The path being used.\n+    path: Res,\n+}\n+/// Parses any expression to find out which field of which variable is used. Will return `None` if\n+/// the expression might have side effects.\n+fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n+    let span = e.span;\n+    let mut fields = Vec::new();\n+    loop {\n+        match e.kind {\n+            ExprKind::Path(ref path) => {\n+                break Some(IterExpr {\n+                    span,\n+                    fields,\n+                    path: cx.qpath_res(path, e.hir_id),\n+                });\n+            },\n+            ExprKind::Field(base, name) => {\n+                fields.push(name.name);\n+                e = base;\n+            },\n+            // Dereferencing a pointer has no side effects and doesn't affect which field is being used.\n+            ExprKind::Unary(UnOp::Deref, base) if cx.typeck_results().expr_ty(base).is_ref() => e = base,\n+\n+            // Shouldn't have side effects, but there's no way to trace which field is used. So forget which fields have\n+            // already been seen.\n+            ExprKind::Index(base, idx) if !idx.can_have_side_effects() => {\n+                fields.clear();\n+                e = base;\n+            },\n+            ExprKind::Unary(UnOp::Deref, base) => {\n+                fields.clear();\n+                e = base;\n+            },\n+\n+            // No effect and doesn't affect which field is being used.\n+            ExprKind::DropTemps(base) | ExprKind::AddrOf(_, _, base) | ExprKind::Type(base, _) => e = base,\n+            _ => break None,\n         }\n     }\n-    false\n }\n \n-fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n-    let def_id = match path_to_local(iter_expr) {\n-        Some(id) => id,\n-        None => return false,\n-    };\n-    let mut visitor = VarUsedAfterLoopVisitor {\n-        def_id,\n-        iter_expr_id: iter_expr.hir_id,\n-        past_while_let: false,\n-        var_used_after_while_let: false,\n-    };\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n-        walk_block(&mut visitor, enclosing_block);\n+fn is_expr_same_field(cx: &LateContext<'_>, mut e: &Expr<'_>, mut fields: &[Symbol], path_res: Res) -> bool {\n+    loop {\n+        match (&e.kind, fields) {\n+            (&ExprKind::Field(base, name), [head_field, tail_fields @ ..]) if name.name == *head_field => {\n+                e = base;\n+                fields = tail_fields;\n+            },\n+            (ExprKind::Path(path), []) => {\n+                break cx.qpath_res(path, e.hir_id) == path_res;\n+            },\n+            (&(ExprKind::DropTemps(base) | ExprKind::AddrOf(_, _, base) | ExprKind::Type(base, _)), _) => e = base,\n+            _ => break false,\n+        }\n     }\n-    visitor.var_used_after_while_let\n }\n \n-fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n-        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n-        then {\n-            return is_loop_nested(cx, loop_expr, iter_expr)\n-        }\n+/// Checks if the given expression is the same field as, is a child of, or is the parent of the\n+/// given field. Used to check if the expression can be used while the given field is borrowed\n+/// mutably. e.g. if checking for `x.y`, then `x.y`, `x.y.z`, and `x` will all return true, but\n+/// `x.z`, and `y` will return false.\n+fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fields: &[Symbol], path_res: Res) -> bool {\n+    match expr.kind {\n+        ExprKind::Field(base, name) => {\n+            if let Some((head_field, tail_fields)) = fields.split_first() {\n+                if name.name == *head_field && is_expr_same_field(cx, base, fields, path_res) {\n+                    return true;\n+                }\n+                // Check if the expression is a parent field\n+                let mut fields_iter = tail_fields.iter();\n+                while let Some(field) = fields_iter.next() {\n+                    if *field == name.name && is_expr_same_field(cx, base, fields_iter.as_slice(), path_res) {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            // Check if the expression is a child field.\n+            let mut e = base;\n+            loop {\n+                match e.kind {\n+                    ExprKind::Field(..) if is_expr_same_field(cx, e, fields, path_res) => break true,\n+                    ExprKind::Field(base, _) | ExprKind::DropTemps(base) | ExprKind::Type(base, _) => e = base,\n+                    ExprKind::Path(ref path) if fields.is_empty() => {\n+                        break cx.qpath_res(path, e.hir_id) == path_res;\n+                    },\n+                    _ => break false,\n+                }\n+            }\n+        },\n+        // If the path matches, this is either an exact match, or the expression is a parent of the field.\n+        ExprKind::Path(ref path) => cx.qpath_res(path, expr.hir_id) == path_res,\n+        ExprKind::DropTemps(base) | ExprKind::Type(base, _) | ExprKind::AddrOf(_, _, base) => {\n+            is_expr_same_child_or_parent_field(cx, base, fields, path_res)\n+        },\n+        _ => false,\n     }\n-    false\n }\n \n-fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n-    let mut id = loop_expr.hir_id;\n-    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n-        id\n-    } else {\n-        return true;\n+/// Strips off all field and path expressions. This will return true if a field or path has been\n+/// skipped. Used to skip them after failing to check for equality.\n+fn skip_fields_and_path(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool) {\n+    let mut e = expr;\n+    let e = loop {\n+        match e.kind {\n+            ExprKind::Field(base, _) | ExprKind::DropTemps(base) | ExprKind::Type(base, _) => e = base,\n+            ExprKind::Path(_) => return (None, true),\n+            _ => break e,\n+        }\n     };\n-    loop {\n-        let parent = cx.tcx.hir().get_parent_node(id);\n-        if parent == id {\n-            return false;\n+    (Some(e), e.hir_id != expr.hir_id)\n+}\n+\n+/// Checks if the given expression uses the iterator.\n+fn uses_iter(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tcx Expr<'_>) -> bool {\n+    struct V<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        uses_iter: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, '_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n         }\n-        match cx.tcx.hir().find(parent) {\n-            Some(Node::Expr(expr)) => {\n-                if let ExprKind::Loop(..) = expr.kind {\n-                    return true;\n-                };\n-            },\n-            Some(Node::Block(block)) => {\n-                let mut block_visitor = LoopNestVisitor {\n-                    hir_id: id,\n-                    iterator: iter_id,\n-                    nesting: Nesting::Unknown,\n-                };\n-                walk_block(&mut block_visitor, block);\n-                if block_visitor.nesting == Nesting::RuledOut {\n-                    return false;\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.uses_iter {\n+                // return\n+            } else if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                self.uses_iter = true;\n+            } else if let (e, true) = skip_fields_and_path(e) {\n+                if let Some(e) = e {\n+                    self.visit_expr(e);\n                 }\n-            },\n-            Some(Node::Stmt(_)) => (),\n-            _ => {\n-                return false;\n-            },\n+            } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                if is_res_used(self.cx, self.iter_expr.path, id) {\n+                    self.uses_iter = true;\n+                }\n+            } else {\n+                walk_expr(self, e);\n+            }\n         }\n-        id = parent;\n     }\n-}\n \n-struct VarUsedAfterLoopVisitor {\n-    def_id: HirId,\n-    iter_expr_id: HirId,\n-    past_while_let: bool,\n-    var_used_after_while_let: bool,\n+    let mut v = V {\n+        cx,\n+        iter_expr,\n+        uses_iter: false,\n+    };\n+    v.visit_expr(container);\n+    v.uses_iter\n }\n \n-impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n-    type Map = Map<'tcx>;\n+#[allow(clippy::too_many_lines)]\n+fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr: &'tcx Expr<'_>) -> bool {\n+    struct AfterLoopVisitor<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        loop_id: HirId,\n+        after_loop: bool,\n+        used_iter: bool,\n+    }\n+    impl Visitor<'tcx> for AfterLoopVisitor<'_, '_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.past_while_let {\n-            if path_to_local_id(expr, self.def_id) {\n-                self.var_used_after_while_let = true;\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.used_iter {\n+                return;\n+            }\n+            if self.after_loop {\n+                if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                    self.used_iter = true;\n+                } else if let (e, true) = skip_fields_and_path(e) {\n+                    if let Some(e) = e {\n+                        self.visit_expr(e);\n+                    }\n+                } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                    self.used_iter = is_res_used(self.cx, self.iter_expr.path, id);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            } else if self.loop_id == e.hir_id {\n+                self.after_loop = true;\n+            } else {\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    struct NestedLoopVisitor<'a, 'b, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        iter_expr: &'b IterExpr,\n+        local_id: HirId,\n+        loop_id: HirId,\n+        after_loop: bool,\n+        found_local: bool,\n+        used_after: bool,\n+    }\n+    impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_local(&mut self, l: &'tcx Local<'_>) {\n+            if !self.after_loop {\n+                l.pat.each_binding_or_first(&mut |_, id, _, _| {\n+                    if id == self.local_id {\n+                        self.found_local = true;\n+                    }\n+                });\n+            }\n+            if let Some(e) = l.init {\n+                self.visit_expr(e);\n+            }\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.used_after {\n+                return;\n+            }\n+            if self.after_loop {\n+                if is_expr_same_child_or_parent_field(self.cx, e, &self.iter_expr.fields, self.iter_expr.path) {\n+                    self.used_after = true;\n+                } else if let (e, true) = skip_fields_and_path(e) {\n+                    if let Some(e) = e {\n+                        self.visit_expr(e);\n+                    }\n+                } else if let ExprKind::Closure(_, _, id, _, _) = e.kind {\n+                    self.used_after = is_res_used(self.cx, self.iter_expr.path, id);\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+            } else if e.hir_id == self.loop_id {\n+                self.after_loop = true;\n+            } else {\n+                walk_expr(self, e);\n             }\n-        } else if self.iter_expr_id == expr.hir_id {\n-            self.past_while_let = true;\n         }\n-        walk_expr(self, expr);\n     }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n+\n+    if let Some(e) = get_enclosing_loop(cx.tcx, loop_expr) {\n+        // The iterator expression will be used on the next iteration unless it is declared within the outer\n+        // loop.\n+        let local_id = match iter_expr.path {\n+            Res::Local(id) => id,\n+            _ => return true,\n+        };\n+        let mut v = NestedLoopVisitor {\n+            cx,\n+            iter_expr,\n+            local_id,\n+            loop_id: loop_expr.hir_id,\n+            after_loop: false,\n+            found_local: false,\n+            used_after: false,\n+        };\n+        v.visit_expr(e);\n+        v.used_after || !v.found_local\n+    } else {\n+        let mut v = AfterLoopVisitor {\n+            cx,\n+            iter_expr,\n+            loop_id: loop_expr.hir_id,\n+            after_loop: false,\n+            used_iter: false,\n+        };\n+        v.visit_expr(&cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n+        v.used_iter\n     }\n }"}, {"sha": "914b583186c2cda12612211673c9f59c0e7a6f87", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -47,7 +47,12 @@ pub struct MacroRefData {\n \n impl MacroRefData {\n     pub fn new(name: String, callee: Span, cx: &LateContext<'_>) -> Self {\n-        let mut path = cx.sess().source_map().span_to_filename(callee).prefer_local().to_string();\n+        let mut path = cx\n+            .sess()\n+            .source_map()\n+            .span_to_filename(callee)\n+            .prefer_local()\n+            .to_string();\n \n         // std lib paths are <::std::module::file type>\n         // so remove brackets, space and type.\n@@ -96,7 +101,8 @@ impl MacroUseImports {\n         let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n         if let Some(callee) = span.source_callee() {\n             if !self.collected.contains(&call_site) {\n-                self.mac_refs.push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.mac_refs\n+                    .push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n                 self.collected.insert(call_site);\n             }\n         }\n@@ -174,7 +180,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                                 .push((*item).to_string());\n                             check_dup.push((*item).to_string());\n                         }\n-                    }\n+                    },\n                     [root, rest @ ..] => {\n                         if rest.iter().all(|item| !check_dup.contains(&(*item).to_string())) {\n                             let filtered = rest\n@@ -198,7 +204,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                                 .push(rest.join(\"::\"));\n                             check_dup.extend(rest.iter().map(ToString::to_string));\n                         }\n-                    }\n+                    },\n                 }\n             }\n         }"}, {"sha": "2f579edd6ade5ec0407e834385e8a12297f36dff", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -53,21 +53,6 @@ impl LateLintPass<'_> for ManualUnwrapOr {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum Case {\n-    Option,\n-    Result,\n-}\n-\n-impl Case {\n-    fn unwrap_fn_path(&self) -> &str {\n-        match self {\n-            Case::Option => \"Option::unwrap_or\",\n-            Case::Result => \"Result::unwrap_or\",\n-        }\n-    }\n-}\n-\n fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n     fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n         if_chain! {\n@@ -86,6 +71,7 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n             if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n             if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n             if path_to_local_id(unwrap_arm.body, binding_hir_id);\n+            if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();\n             if !contains_return_break_continue_macro(or_arm.body);\n             then {\n                 Some(or_arm)\n@@ -98,10 +84,10 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if let Some(case) = if is_type_diagnostic_item(cx, ty, sym::option_type) {\n-            Some(Case::Option)\n+        if let Some(ty_name) = if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+            Some(\"Option\")\n         } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n-            Some(Case::Result)\n+            Some(\"Result\")\n         } else {\n             None\n         };\n@@ -124,7 +110,7 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n             span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n-                &format!(\"this pattern reimplements `{}`\", case.unwrap_fn_path()),\n+                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n                 \"replace with\",\n                 format!(\n                     \"{}.unwrap_or({})\","}, {"sha": "fcd3768701067f63465067a975a394faec1c133b", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1478,15 +1478,34 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n             );\n         },\n         PatKind::Wild => {\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_SINGLE_BINDING,\n-                expr.span,\n-                \"this match could be replaced by its body itself\",\n-                \"consider using the match body instead\",\n-                snippet_body,\n-                Applicability::MachineApplicable,\n-            );\n+            if ex.can_have_side_effects() {\n+                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n+                let sugg = format!(\n+                    \"{};\\n{}{}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    indent,\n+                    snippet_body\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its scrutinee and body\",\n+                    \"consider using the scrutinee and body instead\",\n+                    sugg,\n+                    applicability,\n+                )\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its body itself\",\n+                    \"consider using the match body instead\",\n+                    snippet_body,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n         },\n         _ => (),\n     }"}, {"sha": "e0d29682146b66f9b3e8b2e0dcbccdad8231081e", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1838,16 +1838,18 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                wrong_self_convention::check(\n-                    cx,\n-                    &name,\n-                    item.vis.node.is_pub(),\n-                    self_ty,\n-                    first_arg_ty,\n-                    first_arg.pat.span,\n-                    implements_trait,\n-                    false\n-                );\n+                if sig.decl.implicit_self.has_implicit_self() {\n+                    wrong_self_convention::check(\n+                        cx,\n+                        &name,\n+                        item.vis.node.is_pub(),\n+                        self_ty,\n+                        first_arg_ty,\n+                        first_arg.pat.span,\n+                        implements_trait,\n+                        false\n+                    );\n+                }\n             }\n         }\n \n@@ -1903,7 +1905,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n         if_chain! {\n             if let TraitItemKind::Fn(ref sig, _) = item.kind;\n+            if sig.decl.implicit_self.has_implicit_self();\n             if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n+\n             then {\n                 let first_arg_span = first_arg_ty.span;\n                 let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);"}, {"sha": "1773c26c251fe6ad94855d624c7686de3090578a", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -22,7 +22,7 @@ const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n     // Conversion using `to_` can use borrowed (non-Copy types) or owned (Copy types).\n     // Source: https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n     (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), \n-    Convention::IsTraitItem(false)], &[SelfKind::Ref]),\n+    Convention::IsTraitItem(false), Convention::ImplementsTrait(false)], &[SelfKind::Ref]),\n     (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), \n     Convention::IsTraitItem(false), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n ];"}, {"sha": "b5d2549242b2c25770e24900d8c94085714bf900", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -660,7 +660,14 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-        matches!(data.kind, ExpnKind::Macro { kind: MacroKind::Attr, name: _, proc_macro: _ })\n+        matches!(\n+            data.kind,\n+            ExpnKind::Macro {\n+                kind: MacroKind::Attr,\n+                name: _,\n+                proc_macro: _\n+            }\n+        )\n     } else {\n         false\n     }"}, {"sha": "533c5a22db0b6e6fef0e3ffcb1d91eac01e108c1", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "b30bfbd429443e6bdf4086f55e858147b17c992e", "filename": "clippy_lints/src/needless_bitwise_bool.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,86 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::in_macro;\n+use clippy_utils::source::snippet_opt;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for uses of bitwise and/or operators between booleans, where performance may be improved by using\n+    /// a lazy and.\n+    ///\n+    /// **Why is this bad?**\n+    /// The bitwise operators do not support short-circuiting, so it may hinder code performance.\n+    /// Additionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n+    ///\n+    /// **Known problems:**\n+    /// This lint evaluates only when the right side is determined to have no side effects. At this time, that\n+    /// determination is quite conservative.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x & !y {} // where both x and y are booleans\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x && !y {}\n+    /// ```\n+    pub NEEDLESS_BITWISE_BOOL,\n+    pedantic,\n+    \"Boolean expressions that use bitwise rather than lazy operators\"\n+}\n+\n+declare_lint_pass!(NeedlessBitwiseBool => [NEEDLESS_BITWISE_BOOL]);\n+\n+fn is_bitwise_operation(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if_chain! {\n+        if !in_macro(expr.span);\n+        if let (&ExprKind::Binary(ref op, _, right), &ty::Bool) = (&expr.kind, &ty.kind());\n+        if op.node == BinOpKind::BitAnd || op.node == BinOpKind::BitOr;\n+        if let ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..) = right.kind;\n+        if !right.can_have_side_effects();\n+        then {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn suggession_snippet(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n+    if let ExprKind::Binary(ref op, left, right) = expr.kind {\n+        if let (Some(l_snippet), Some(r_snippet)) = (snippet_opt(cx, left.span), snippet_opt(cx, right.span)) {\n+            let op_snippet = match op.node {\n+                BinOpKind::BitAnd => \"&&\",\n+                _ => \"||\",\n+            };\n+            return Some(format!(\"{} {} {}\", l_snippet, op_snippet, r_snippet));\n+        }\n+    }\n+    None\n+}\n+\n+impl LateLintPass<'_> for NeedlessBitwiseBool {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if is_bitwise_operation(cx, expr) {\n+            span_lint_and_then(\n+                cx,\n+                NEEDLESS_BITWISE_BOOL,\n+                expr.span,\n+                \"use of bitwise operator instead of lazy operator between booleans\",\n+                |diag| {\n+                    if let Some(sugg) = suggession_snippet(cx, expr) {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, Applicability::MachineApplicable);\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}"}, {"sha": "c64491c63e2dcfcd385df9797f79bf41f499c9be", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 19, "deletions": 93, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TyS;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -63,12 +62,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessQuestionMark => [NEEDLESS_QUESTION_MARK]);\n \n-#[derive(Debug)]\n-enum SomeOkCall<'a> {\n-    SomeCall(&'a Expr<'a>, &'a Expr<'a>),\n-    OkCall(&'a Expr<'a>, &'a Expr<'a>),\n-}\n-\n impl LateLintPass<'_> for NeedlessQuestionMark {\n     /*\n      * The question mark operator is compatible with both Result<T, E> and Option<T>,\n@@ -90,104 +83,37 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n      */\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n-        let e = match &expr.kind {\n-            ExprKind::Ret(Some(e)) => e,\n-            _ => return,\n-        };\n-\n-        if let Some(ok_some_call) = is_some_or_ok_call(cx, e) {\n-            emit_lint(cx, &ok_some_call);\n+        if let ExprKind::Ret(Some(e)) = expr.kind {\n+            check(cx, e);\n         }\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n-        // Function / Closure block\n-        let expr_opt = if let ExprKind::Block(block, _) = &body.value.kind {\n-            block.expr\n-        } else {\n-            // Single line closure\n-            Some(&body.value)\n-        };\n-\n-        if_chain! {\n-            if let Some(expr) = expr_opt;\n-            if let Some(ok_some_call) = is_some_or_ok_call(cx, expr);\n-            then {\n-                emit_lint(cx, &ok_some_call);\n-            }\n-        };\n+        check(cx, body.value.peel_blocks());\n     }\n }\n \n-fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n-    let (entire_expr, inner_expr) = match expr {\n-        SomeOkCall::OkCall(outer, inner) | SomeOkCall::SomeCall(outer, inner) => (outer, inner),\n+fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    let inner_expr = if_chain! {\n+        if let ExprKind::Call(path, [arg]) = &expr.kind;\n+        if let ExprKind::Path(ref qpath) = &path.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &arg.kind;\n+        if let ExprKind::Call(called, [inner_expr]) = &inner_expr_with_q.kind;\n+        if let ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)) = &called.kind;\n+        if expr.span.ctxt() == inner_expr.span.ctxt();\n+        let expr_ty = cx.typeck_results().expr_ty(expr);\n+        let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n+        if TyS::same_type(expr_ty, inner_ty);\n+        then { inner_expr } else { return; }\n     };\n-\n     span_lint_and_sugg(\n         cx,\n         NEEDLESS_QUESTION_MARK,\n-        entire_expr.span,\n+        expr.span,\n         \"question mark operator is useless here\",\n         \"try\",\n         format!(\"{}\", snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n         Applicability::MachineApplicable,\n     );\n }\n-\n-fn is_some_or_ok_call<'a>(cx: &'a LateContext<'_>, expr: &'a Expr<'_>) -> Option<SomeOkCall<'a>> {\n-    if_chain! {\n-        // Check outer expression matches CALL_IDENT(ARGUMENT) format\n-        if let ExprKind::Call(path, args) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n-\n-        // Extract inner expression from ARGUMENT\n-        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n-        if let ExprKind::Call(called, args) = &inner_expr_with_q.kind;\n-        if args.len() == 1;\n-\n-        if let ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)) = &called.kind;\n-        then {\n-            // Extract inner expr type from match argument generated by\n-            // question mark operator\n-            let inner_expr = &args[0];\n-\n-            // if the inner expr is inside macro but the outer one is not, do not lint (#6921)\n-            if  differing_macro_contexts(expr.span, inner_expr.span) {\n-                return None;\n-            }\n-\n-            let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n-            let outer_ty = cx.typeck_results().expr_ty(expr);\n-\n-            // Check if outer and inner type are Option\n-            let outer_is_some = is_type_diagnostic_item(cx, outer_ty, sym::option_type);\n-            let inner_is_some = is_type_diagnostic_item(cx, inner_ty, sym::option_type);\n-\n-            // Check for Option MSRV\n-            if outer_is_some && inner_is_some {\n-                return Some(SomeOkCall::SomeCall(expr, inner_expr));\n-            }\n-\n-            // Check if outer and inner type are Result\n-            let outer_is_result = is_type_diagnostic_item(cx, outer_ty, sym::result_type);\n-            let inner_is_result = is_type_diagnostic_item(cx, inner_ty, sym::result_type);\n-\n-            // Additional check: if the error type of the Result can be converted\n-            // via the From trait, then don't match\n-            let does_not_call_from = !has_implicit_error_from(cx, expr, inner_expr);\n-\n-            // Must meet Result MSRV\n-            if outer_is_result && inner_is_result && does_not_call_from {\n-                return Some(SomeOkCall::OkCall(expr, inner_expr));\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n-    return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n-}"}, {"sha": "52661416de67fa3430f175c41fe377ec7e44c176", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "b6af4175edfdabce7903ba40233b106a11d8daa7", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 5, "deletions": 42, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, get_enclosing_block, in_macro, is_lang_ctor};\n+use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n@@ -81,7 +81,6 @@ struct OptionIfLetElseOccurence {\n     method_sugg: String,\n     some_expr: String,\n     none_expr: String,\n-    wrap_braces: bool,\n }\n \n /// Extracts the body of a given arm. If the arm contains only an expression,\n@@ -106,37 +105,6 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n     }\n }\n \n-/// If this is the else body of an if/else expression, then we need to wrap\n-/// it in curly braces. Otherwise, we don't.\n-fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n-        let mut should_wrap = false;\n-\n-        if let Some(Expr {\n-            kind:\n-                ExprKind::Match(\n-                    _,\n-                    arms,\n-                    MatchSource::IfLetDesugar {\n-                        contains_else_clause: true,\n-                    },\n-                ),\n-            ..\n-        }) = parent.expr\n-        {\n-            should_wrap = expr.hir_id == arms[1].body.hir_id;\n-        } else if let Some(Expr {\n-            kind: ExprKind::If(_, _, Some(else_clause)),\n-            ..\n-        }) = parent.expr\n-        {\n-            should_wrap = expr.hir_id == else_clause.hir_id;\n-        }\n-\n-        should_wrap\n-    })\n-}\n-\n fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n@@ -161,20 +129,21 @@ fn detect_option_if_let_else<'tcx>(\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n         if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if !is_else_clause(cx.tcx, expr);\n         if arms.len() == 2;\n         if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n         if !contains_return_break_continue_macro(arms[0].body);\n         if !contains_return_break_continue_macro(arms[1].body);\n+\n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_arm(&arms[0])?;\n             let none_body = extract_body_from_arm(&arms[1])?;\n             let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let wrap_braces = should_wrap_in_braces(cx, expr);\n             let (as_ref, as_mut) = match &cond_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n@@ -190,7 +159,6 @@ fn detect_option_if_let_else<'tcx>(\n                 method_sugg: method_sugg.to_string(),\n                 some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n-                wrap_braces,\n             })\n         } else {\n             None\n@@ -208,13 +176,8 @@ impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n                 format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n                 \"try\",\n                 format!(\n-                    \"{}{}.{}({}, {}){}\",\n-                    if detection.wrap_braces { \"{ \" } else { \"\" },\n-                    detection.option,\n-                    detection.method_sugg,\n-                    detection.none_expr,\n-                    detection.some_expr,\n-                    if detection.wrap_braces { \" }\" } else { \"\" },\n+                    \"{}.{}({}, {})\",\n+                    detection.option, detection.method_sugg, detection.none_expr, detection.some_expr,\n                 ),\n                 Applicability::MaybeIncorrect,\n             );"}, {"sha": "19650c41b840a20889aa8bc2240d8d1e47863547", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -628,7 +628,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "0454214651683afbfae4ede5b4afdcbeedf0f0aa", "filename": "clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -8,7 +8,12 @@ use super::UNIT_CMP;\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n         if let Some(callee) = expr.span.source_callee() {\n-            if let ExpnKind::Macro { kind: MacroKind::Bang, name: symbol, proc_macro: _ } = callee.kind {\n+            if let ExpnKind::Macro {\n+                kind: MacroKind::Bang,\n+                name: symbol,\n+                proc_macro: _,\n+            } = callee.kind\n+            {\n                 if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n                     let op = cmp.node;\n                     if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {"}, {"sha": "18ee07d3a9587f2269cdd0ffa622676f4af889eb", "filename": "clippy_lints/src/unused_async.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_async.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,92 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, Item, ItemKind, YieldSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions that are declared `async` but have no `.await`s inside of them.\n+    ///\n+    /// **Why is this bad?** Async functions with no async code create overhead, both mentally and computationally.\n+    /// Callers of async methods either need to be calling from an async function themselves or run it on an executor, both of which\n+    /// causes runtime overhead and hassle for the caller.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// async fn get_random_number() -> i64 {\n+    ///     4 // Chosen by fair dice roll. Guaranteed to be random.\n+    /// }\n+    /// let number_future = get_random_number();\n+    ///\n+    /// // Good\n+    /// fn get_random_number_improved() -> i64 {\n+    ///     4 // Chosen by fair dice roll. Guaranteed to be random.\n+    /// }\n+    /// let number_future = async { get_random_number_improved() };\n+    /// ```\n+    pub UNUSED_ASYNC,\n+    pedantic,\n+    \"finds async functions with no await statements\"\n+}\n+\n+declare_lint_pass!(UnusedAsync => [UNUSED_ASYNC]);\n+\n+struct AsyncFnVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    found_await: bool,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for AsyncFnVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let ExprKind::Yield(_, YieldSource::Await { .. }) = ex.kind {\n+            self.found_await = true;\n+        }\n+        walk_expr(self, ex);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n+    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if let ItemKind::Trait(..) = item.kind {\n+            return;\n+        }\n+    }\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        fn_kind: FnKind<'tcx>,\n+        fn_decl: &'tcx FnDecl<'tcx>,\n+        body: &Body<'tcx>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }, _) = &fn_kind {\n+            if matches!(asyncness, IsAsync::Async) {\n+                let mut visitor = AsyncFnVisitor { cx, found_await: false };\n+                walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), span, hir_id);\n+                if !visitor.found_await {\n+                    span_lint_and_help(\n+                        cx,\n+                        UNUSED_ASYNC,\n+                        span,\n+                        \"unused `async` for function with no await statements\",\n+                        None,\n+                        \"consider removing the `async` from this function\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "2ad6fa77f4818ed8c93c890def8c5b52cf3a425e", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,20 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::same_type_and_consts;\n use clippy_utils::{in_macro, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::{\n-    def,\n+    self as hir,\n+    def::{self, DefKind},\n     def_id::LocalDefId,\n     intravisit::{walk_ty, NestedVisitorMap, Visitor},\n     Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n     QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{AssocKind, Ty, TyS};\n+use rustc_middle::ty::{AssocKind, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{BytePos, Span};\n@@ -459,7 +459,7 @@ fn in_impl(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> bool {\n \n fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n     if_chain! {\n-        if TyS::same_type(ty, self_ty);\n+        if same_type_and_consts(ty, self_ty);\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n         then {\n             !matches!(path.res, def::Res::SelfTy(..))"}, {"sha": "2be99fb761b18be18a119e8cfc48a8e1a4ca2831", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,13 +1,13 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, match_def_path, match_trait_method, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::sym;\n \n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(&args[0]);\n-                    if TyS::same_type(a, b) {\n+                    if same_type_and_consts(a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n                         span_lint_and_sugg(\n                             cx,\n@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     }\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(&args[0]);\n-                    if TyS::same_type(a, b) {\n+                    if same_type_and_consts(a, b) {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n                             cx,\n@@ -110,7 +110,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if is_type_diagnostic_item(cx, a, sym::result_type);\n                     if let ty::Adt(_, substs) = a.kind();\n                     if let Some(a_type) = substs.types().next();\n-                    if TyS::same_type(a_type, b);\n+                    if same_type_and_consts(a_type, b);\n+\n                     then {\n                         span_lint_and_help(\n                             cx,\n@@ -137,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             if is_type_diagnostic_item(cx, a, sym::result_type);\n                             if let ty::Adt(_, substs) = a.kind();\n                             if let Some(a_type) = substs.types().next();\n-                            if TyS::same_type(a_type, b);\n+                            if same_type_and_consts(a_type, b);\n \n                             then {\n                                 let hint = format!(\"consider removing `{}()`\", snippet(cx, path.span, \"TryFrom::try_from\"));\n@@ -154,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n \n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::FROM_FROM);\n-                            if TyS::same_type(a, b);\n+                            if same_type_and_consts(a, b);\n \n                             then {\n                                 let sugg = Sugg::hir_with_macro_callsite(cx, &args[0], \"<expr>\").maybe_par();"}, {"sha": "fd2dddb3b96e518ef7f81f4a109e1e8f237cbbf9", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -26,13 +26,13 @@ impl TryConf {\n \n macro_rules! define_Conf {\n     ($(\n-        #[$doc:meta]\n+        #[doc = $doc:literal]\n         $(#[conf_deprecated($dep:literal)])?\n         ($name:ident: $ty:ty = $default:expr),\n     )*) => {\n         /// Clippy lint configuration\n         pub struct Conf {\n-            $(#[$doc] pub $name: $ty,)*\n+            $(#[doc = $doc] pub $name: $ty,)*\n         }\n \n         mod defaults {\n@@ -89,6 +89,34 @@ macro_rules! define_Conf {\n                 Ok(TryConf { conf, errors })\n             }\n         }\n+\n+        #[cfg(feature = \"metadata-collector-lint\")]\n+        pub mod metadata {\n+            use crate::utils::internal_lints::metadata_collector::ClippyConfiguration;\n+\n+            macro_rules! wrap_option {\n+                () => (None);\n+                ($x:literal) => (Some($x));\n+            }\n+\n+            pub(crate) fn get_configuration_metadata() -> Vec<ClippyConfiguration> {\n+                vec![\n+                    $(\n+                        {\n+                            let deprecation_reason = wrap_option!($($dep)?);\n+\n+                            ClippyConfiguration::new(\n+                                stringify!($name),\n+                                stringify!($ty),\n+                                format!(\"{:?}\", super::defaults::$name()),\n+                                $doc,\n+                                deprecation_reason,\n+                            )\n+                        },\n+                    )+\n+                ]\n+            }\n+        }\n     };\n }\n "}, {"sha": "e9fa043b20f3714cc8fec6a9bf8bf97d37fe32a8", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 248, "deletions": 35, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -8,9 +8,6 @@\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n //! a simple mistake)\n \n-// # NITs\n-// - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n-\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n@@ -22,13 +19,14 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n use serde::{ser::SerializeStruct, Serialize, Serializer};\n use std::collections::BinaryHeap;\n+use std::fmt;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n use clippy_utils::{\n-    diagnostics::span_lint, last_path_segment, match_function_call, match_path, paths, ty::match_type,\n+    diagnostics::span_lint, last_path_segment, match_def_path, match_function_call, match_path, paths, ty::match_type,\n     ty::walk_ptrs_ty_depth,\n };\n \n@@ -39,8 +37,52 @@ const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"i\n /// These groups will be ignored by the lint group matcher. This is useful for collections like\n /// `clippy::all`\n const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n-/// Lints within this group will be excluded from the collection\n-const EXCLUDED_LINT_GROUPS: [&str; 1] = [\"clippy::internal\"];\n+/// Lints within this group will be excluded from the collection. These groups\n+/// have to be defined without the `clippy::` prefix.\n+const EXCLUDED_LINT_GROUPS: [&str; 1] = [\"internal\"];\n+/// Collected deprecated lint will be assigned to this group in the JSON output\n+const DEPRECATED_LINT_GROUP_STR: &str = \"deprecated\";\n+/// This is the lint level for deprecated lints that will be displayed in the lint list\n+const DEPRECATED_LINT_LEVEL: &str = \"none\";\n+/// This array holds Clippy's lint groups with their corresponding default lint level. The\n+/// lint level for deprecated lints is set in `DEPRECATED_LINT_LEVEL`.\n+const DEFAULT_LINT_LEVELS: [(&str, &str); 8] = [\n+    (\"correctness\", \"deny\"),\n+    (\"restriction\", \"allow\"),\n+    (\"style\", \"warn\"),\n+    (\"pedantic\", \"allow\"),\n+    (\"complexity\", \"warn\"),\n+    (\"perf\", \"warn\"),\n+    (\"cargo\", \"allow\"),\n+    (\"nursery\", \"allow\"),\n+];\n+/// This prefix is in front of the lint groups in the lint store. The prefix will be trimmed\n+/// to only keep the actual lint group in the output.\n+const CLIPPY_LINT_GROUP_PREFIX: &str = \"clippy::\";\n+\n+/// This template will be used to format the configuration section in the lint documentation.\n+/// The `configurations` parameter will be replaced with one or multiple formatted\n+/// `ClippyConfiguration` instances. See `CONFIGURATION_VALUE_TEMPLATE` for further customizations\n+macro_rules! CONFIGURATION_SECTION_TEMPLATE {\n+    () => {\n+        r#\"\n+**Configuration**\n+This lint has the following configuration variables:\n+\n+{configurations}\n+\"#\n+    };\n+}\n+/// This template will be used to format an individual `ClippyConfiguration` instance in the\n+/// lint documentation.\n+///\n+/// The format function will provide strings for the following parameters: `name`, `ty`, `doc` and\n+/// `default`\n+macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n+    () => {\n+        \"* {name}: {ty}: {doc} (defaults to `{default}`)\\n\"\n+    };\n+}\n \n const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n@@ -66,6 +108,7 @@ const SUGGESTION_FUNCTIONS: [&[&str]; 2] = [\n     &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg\"],\n     &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg_with_applicability\"],\n ];\n+const DEPRECATED_LINT_TYPE: [&str; 3] = [\"clippy_lints\", \"deprecated_lints\", \"ClippyDeprecatedLint\"];\n \n /// The index of the applicability name of `paths::APPLICABILITY_VALUES`\n const APPLICABILITY_NAME_INDEX: usize = 2;\n@@ -102,13 +145,33 @@ declare_clippy_lint! {\n impl_lint_pass!(MetadataCollector => [INTERNAL_METADATA_COLLECTOR]);\n \n #[allow(clippy::module_name_repetitions)]\n-#[derive(Debug, Clone, Default)]\n+#[derive(Debug, Clone)]\n pub struct MetadataCollector {\n     /// All collected lints\n     ///\n     /// We use a Heap here to have the lints added in alphabetic order in the export\n     lints: BinaryHeap<LintMetadata>,\n     applicability_info: FxHashMap<String, ApplicabilityInfo>,\n+    config: Vec<ClippyConfiguration>,\n+}\n+\n+impl MetadataCollector {\n+    pub fn new() -> Self {\n+        Self {\n+            lints: BinaryHeap::<LintMetadata>::default(),\n+            applicability_info: FxHashMap::<String, ApplicabilityInfo>::default(),\n+            config: collect_configs(),\n+        }\n+    }\n+\n+    fn get_lint_configs(&self, lint_name: &str) -> Option<String> {\n+        self.config\n+            .iter()\n+            .filter(|config| config.lints.iter().any(|lint| lint == lint_name))\n+            .map(ToString::to_string)\n+            .reduce(|acc, x| acc + &x)\n+            .map(|configurations| format!(CONFIGURATION_SECTION_TEMPLATE!(), configurations = configurations))\n+    }\n }\n \n impl Drop for MetadataCollector {\n@@ -143,18 +206,20 @@ struct LintMetadata {\n     id: String,\n     id_span: SerializableSpan,\n     group: String,\n+    level: &'static str,\n     docs: String,\n     /// This field is only used in the output and will only be\n     /// mapped shortly before the actual output.\n     applicability: Option<ApplicabilityInfo>,\n }\n \n impl LintMetadata {\n-    fn new(id: String, id_span: SerializableSpan, group: String, docs: String) -> Self {\n+    fn new(id: String, id_span: SerializableSpan, group: String, level: &'static str, docs: String) -> Self {\n         Self {\n             id,\n             id_span,\n             group,\n+            level,\n             docs,\n             applicability: None,\n         }\n@@ -182,7 +247,7 @@ impl SerializableSpan {\n         let loc: Loc = cx.sess().source_map().lookup_char_pos(span.lo());\n \n         Self {\n-            path: format!(\"{}\", loc.file.name),\n+            path: format!(\"{}\", loc.file.name.prefer_remapped()),\n             line: loc.line,\n         }\n     }\n@@ -214,6 +279,95 @@ impl Serialize for ApplicabilityInfo {\n     }\n }\n \n+// ==================================================================\n+// Configuration\n+// ==================================================================\n+#[derive(Debug, Clone, Default)]\n+pub struct ClippyConfiguration {\n+    name: String,\n+    config_type: &'static str,\n+    default: String,\n+    lints: Vec<String>,\n+    doc: String,\n+    deprecation_reason: Option<&'static str>,\n+}\n+\n+impl ClippyConfiguration {\n+    pub fn new(\n+        name: &'static str,\n+        config_type: &'static str,\n+        default: String,\n+        doc_comment: &'static str,\n+        deprecation_reason: Option<&'static str>,\n+    ) -> Self {\n+        let (lints, doc) = parse_config_field_doc(doc_comment)\n+            .unwrap_or_else(|| (vec![], \"[ERROR] MALFORMED DOC COMMENT\".to_string()));\n+\n+        Self {\n+            name: to_kebab(name),\n+            lints,\n+            doc,\n+            config_type,\n+            default,\n+            deprecation_reason,\n+        }\n+    }\n+}\n+\n+fn collect_configs() -> Vec<ClippyConfiguration> {\n+    crate::utils::conf::metadata::get_configuration_metadata()\n+}\n+\n+/// This parses the field documentation of the config struct.\n+///\n+/// ```rust, ignore\n+/// parse_config_field_doc(cx, \"Lint: LINT_NAME_1, LINT_NAME_2. Papa penguin, papa penguin\")\n+/// ```\n+///\n+/// Would yield:\n+/// ```rust, ignore\n+/// Some([\"lint_name_1\", \"lint_name_2\"], \"Papa penguin, papa penguin\")\n+/// ```\n+fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n+    const DOC_START: &str = \" Lint: \";\n+    if_chain! {\n+        if doc_comment.starts_with(DOC_START);\n+        if let Some(split_pos) = doc_comment.find('.');\n+        then {\n+            let mut doc_comment = doc_comment.to_string();\n+            let documentation = doc_comment.split_off(split_pos);\n+\n+            doc_comment.make_ascii_lowercase();\n+            let lints: Vec<String> = doc_comment.split_off(DOC_START.len()).split(\", \").map(str::to_string).collect();\n+\n+            Some((lints, documentation))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Transforms a given `snake_case_string` to a tasty `kebab-case-string`\n+fn to_kebab(config_name: &str) -> String {\n+    config_name.replace('_', \"-\")\n+}\n+\n+impl fmt::Display for ClippyConfiguration {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            CONFIGURATION_VALUE_TEMPLATE!(),\n+            name = self.name,\n+            ty = self.config_type,\n+            doc = self.doc,\n+            default = self.default\n+        )\n+    }\n+}\n+\n+// ==================================================================\n+// Lint pass\n+// ==================================================================\n impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// Collecting lint declarations like:\n     /// ```rust, ignore\n@@ -225,23 +379,48 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// }\n     /// ```\n     fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n-        if_chain! {\n-            // item validation\n-            if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind;\n-            if is_lint_ref_type(cx, ty);\n-            // blacklist check\n-            let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n-            if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n-            // metadata extraction\n-            if let Some(group) = get_lint_group_or_lint(cx, &lint_name, item);\n-            if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n-            then {\n-                self.lints.push(LintMetadata::new(\n-                    lint_name,\n-                    SerializableSpan::from_item(cx, item),\n-                    group,\n-                    docs,\n-                ));\n+        if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind {\n+            // Normal lint\n+            if_chain! {\n+                // item validation\n+                if is_lint_ref_type(cx, ty);\n+                // blacklist check\n+                let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n+                if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n+                // metadata extraction\n+                if let Some((group, level)) = get_lint_group_and_level_or_lint(cx, &lint_name, item);\n+                if let Some(mut docs) = extract_attr_docs_or_lint(cx, item);\n+                then {\n+                    if let Some(configuration_section) = self.get_lint_configs(&lint_name) {\n+                        docs.push_str(&configuration_section);\n+                    }\n+\n+                    self.lints.push(LintMetadata::new(\n+                        lint_name,\n+                        SerializableSpan::from_item(cx, item),\n+                        group,\n+                        level,\n+                        docs,\n+                    ));\n+                }\n+            }\n+\n+            if_chain! {\n+                if is_deprecated_lint(cx, ty);\n+                // blacklist check\n+                let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n+                if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n+                // Metadata the little we can get from a deprecated lint\n+                if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n+                then {\n+                    self.lints.push(LintMetadata::new(\n+                        lint_name,\n+                        SerializableSpan::from_item(cx, item),\n+                        DEPRECATED_LINT_GROUP_STR.to_string(),\n+                        DEPRECATED_LINT_LEVEL,\n+                        docs,\n+                    ));\n+                }\n             }\n         }\n     }\n@@ -268,7 +447,7 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n                 // - src/misc.rs:734:9\n                 // - src/methods/mod.rs:3545:13\n                 // - src/methods/mod.rs:3496:13\n-                // We are basically unable to resolve the lint name it self.\n+                // We are basically unable to resolve the lint name itself.\n                 return;\n             }\n \n@@ -318,15 +497,32 @@ fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n         })\n }\n \n-fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Item<'_>) -> Option<String> {\n+fn get_lint_group_and_level_or_lint(\n+    cx: &LateContext<'_>,\n+    lint_name: &str,\n+    item: &'hir Item<'_>,\n+) -> Option<(String, &'static str)> {\n     let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n-        get_lint_group(cx, lint_lst[0])\n-            .or_else(|| {\n-                lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+        if let Some(group) = get_lint_group(cx, lint_lst[0]) {\n+            if EXCLUDED_LINT_GROUPS.contains(&group.as_str()) {\n+                return None;\n+            }\n+\n+            if let Some(level) = get_lint_level_from_group(&group) {\n+                Some((group, level))\n+            } else {\n+                lint_collection_error_item(\n+                    cx,\n+                    item,\n+                    &format!(\"Unable to determine lint level for found group `{}`\", group),\n+                );\n                 None\n-            })\n-            .filter(|group| !EXCLUDED_LINT_GROUPS.contains(&group.as_str()))\n+            }\n+        } else {\n+            lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+            None\n+        }\n     } else {\n         lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n         None\n@@ -339,14 +535,31 @@ fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n             continue;\n         }\n \n-        if lints.iter().any(|x| *x == lint_id) {\n-            return Some((*group_name).to_string());\n+        if lints.iter().any(|group_lint| *group_lint == lint_id) {\n+            let group = group_name.strip_prefix(CLIPPY_LINT_GROUP_PREFIX).unwrap_or(group_name);\n+            return Some((*group).to_string());\n         }\n     }\n \n     None\n }\n \n+fn get_lint_level_from_group(lint_group: &str) -> Option<&'static str> {\n+    DEFAULT_LINT_LEVELS\n+        .iter()\n+        .find_map(|(group_name, group_level)| (*group_name == lint_group).then(|| *group_level))\n+}\n+\n+fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+    if let hir::TyKind::Path(ref path) = ty.kind {\n+        if let hir::def::Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, ty.hir_id) {\n+            return match_def_path(cx, def_id, &DEPRECATED_LINT_TYPE);\n+        }\n+    }\n+\n+    false\n+}\n+\n // ==================================================================\n // Lint emission\n // =================================================================="}, {"sha": "d0e79efa70df59e4fad331974e3c24416b9395fb", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -279,8 +279,15 @@ impl EarlyLintPass for Write {\n             span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprintln!`\");\n             self.lint_println_empty_string(cx, mac);\n         } else if mac.path == sym!(write) {\n-            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), dest) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n+                    let (nl_span, only_nl) = newline_span(&fmt_str);\n+                    let nl_span = match (dest, only_nl) {\n+                        // Special case of `write!(buf, \"\\n\")`: Mark everything from the end of\n+                        // `buf` for removal so no trailing comma [`writeln!(buf, )`] remains.\n+                        (Some(dest_expr), true) => Span::new(dest_expr.span.hi(), nl_span.hi(), nl_span.ctxt()),\n+                        _ => nl_span,\n+                    };\n                     span_lint_and_then(\n                         cx,\n                         WRITE_WITH_NEWLINE,\n@@ -289,10 +296,7 @@ impl EarlyLintPass for Write {\n                         |err| {\n                             err.multipart_suggestion(\n                                 \"use `writeln!()` instead\",\n-                                vec![\n-                                    (mac.path.span, String::from(\"writeln\")),\n-                                    (newline_span(&fmt_str), String::new()),\n-                                ],\n+                                vec![(mac.path.span, String::from(\"writeln\")), (nl_span, String::new())],\n                                 Applicability::MachineApplicable,\n                             );\n                         },\n@@ -329,12 +333,13 @@ impl EarlyLintPass for Write {\n \n /// Given a format string that ends in a newline and its span, calculates the span of the\n /// newline, or the format string itself if the format string consists solely of a newline.\n-fn newline_span(fmtstr: &StrLit) -> Span {\n+/// Return this and a boolean indicating whether it only consisted of a newline.\n+fn newline_span(fmtstr: &StrLit) -> (Span, bool) {\n     let sp = fmtstr.span;\n     let contents = &fmtstr.symbol.as_str();\n \n     if *contents == r\"\\n\" {\n-        return sp;\n+        return (sp, true);\n     }\n \n     let newline_sp_hi = sp.hi()\n@@ -351,7 +356,7 @@ fn newline_span(fmtstr: &StrLit) -> Span {\n         panic!(\"expected format string to contain a newline\");\n     };\n \n-    sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n+    (sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi), false)\n }\n \n /// Stores a list of replacement spans for each argument, but only if all the replacements used an\n@@ -613,7 +618,7 @@ impl Write {\n                     |err| {\n                         err.multipart_suggestion(\n                             &format!(\"use `{}!` instead\", suggested),\n-                            vec![(mac.path.span, suggested), (newline_span(&fmt_str), String::new())],\n+                            vec![(mac.path.span, suggested), (newline_span(&fmt_str).0, String::new())],\n                             Applicability::MachineApplicable,\n                         );\n                     },"}, {"sha": "93ed3b1840068416459a731f682cde21b01472a0", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -14,6 +14,7 @@ unicode-normalization = \"0.1\"\n rustc-semver=\"1.1.0\"\n \n [features]\n+deny-warnings = []\n internal-lints = []\n metadata-collector-lint = []\n "}, {"sha": "82250151aabc605f4275e628185cf0fb05799aa4", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,10 +1,16 @@\n #![feature(box_patterns)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n+// warn on the same lints as `clippy_lints`\n+#![warn(trivial_casts, trivial_numeric_casts)]\n+// warn on lints, that are included in `rust-lang/rust`s bootstrap\n+#![warn(rust_2018_idioms, unused_lifetimes)]\n+// warn on rustc internal lints\n+#![warn(rustc::internal)]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n@@ -855,6 +861,24 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n+/// Gets the loop enclosing the given expression, if any.\n+pub fn get_enclosing_loop(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    let map = tcx.hir();\n+    for (_, node) in map.parent_iter(expr.hir_id) {\n+        match node {\n+            Node::Expr(\n+                e @ Expr {\n+                    kind: ExprKind::Loop(..),\n+                    ..\n+                },\n+            ) => return Some(e),\n+            Node::Expr(_) | Node::Stmt(_) | Node::Block(_) | Node::Local(_) | Node::Arm(_) => (),\n+            _ => break,\n+        }\n+    }\n+    None\n+}\n+\n /// Gets the parent node if it's an impl block.\n pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n     let map = tcx.hir();\n@@ -947,7 +971,12 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n             let data = span.ctxt().outer_expn_data();\n             let new_span = data.call_site;\n \n-            if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n+            if let ExpnKind::Macro {\n+                kind: MacroKind::Bang,\n+                name: mac_name,\n+                proc_macro: _,\n+            } = data.kind\n+            {\n                 if mac_name.as_str() == name {\n                     return Some(new_span);\n                 }\n@@ -975,7 +1004,12 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n         let data = span.ctxt().outer_expn_data();\n         let new_span = data.call_site;\n \n-        if let ExpnKind::Macro { kind: MacroKind::Bang, name: mac_name, proc_macro: _ } = data.kind {\n+        if let ExpnKind::Macro {\n+            kind: MacroKind::Bang,\n+            name: mac_name,\n+            proc_macro: _,\n+        } = data.kind\n+        {\n             if mac_name.as_str() == name {\n                 return Some(new_span);\n             }"}, {"sha": "0c95066175771d6c87c20db69dfece1fbd65072a", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -289,7 +289,7 @@ fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n     if let Some('(') = chars.next() {\n         let mut depth = 1;\n-        while let Some(c) = chars.next() {\n+        for c in &mut chars {\n             if c == '(' {\n                 depth += 1;\n             } else if c == ')' {"}, {"sha": "c36e215f184adc2eac06e3962f1b8efa3a771df1", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -2,9 +2,8 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n-use std::collections::HashMap;\n-\n use rustc_ast::ast::Mutability;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{TyKind, Unsafety};\n@@ -184,14 +183,14 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n-    is_normalizable_helper(cx, param_env, ty, &mut HashMap::new())\n+    is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n fn is_normalizable_helper<'tcx>(\n     cx: &LateContext<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n-    cache: &mut HashMap<Ty<'tcx>, bool>,\n+    cache: &mut FxHashMap<Ty<'tcx>, bool>,\n ) -> bool {\n     if let Some(&cached_result) = cache.get(ty) {\n         return cached_result;\n@@ -322,3 +321,27 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     }\n     inner(ty, 0)\n }\n+\n+/// Returns `true` if types `a` and `b` are same types having same `Const` generic args,\n+/// otherwise returns `false`\n+pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    match (&a.kind(), &b.kind()) {\n+        (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n+            if did_a != did_b {\n+                return false;\n+            }\n+\n+            substs_a\n+                .iter()\n+                .zip(substs_b.iter())\n+                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n+                    (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n+                        same_type_and_consts(type_a, type_b)\n+                    },\n+                    _ => true,\n+                })\n+        },\n+        _ => a == b,\n+    }\n+}"}, {"sha": "ecdc666b5f690a63ed7aa132a640f7b78361328f", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,7 +1,7 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Block, Body, Destination, Expr, ExprKind, HirId, Stmt};\n+use rustc_hir::{def::Res, Arm, Block, Body, BodyId, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -218,6 +218,7 @@ impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n     }\n }\n \n+/// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n     node: impl Visitable<'tcx>,\n     f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n@@ -239,3 +240,36 @@ pub fn visit_break_exprs<'tcx>(\n \n     node.visit(&mut V(f));\n }\n+\n+/// Checks if the given resolved path is used in the given body.\n+pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: Res,\n+        found: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if self.found {\n+                return;\n+            }\n+\n+            if let ExprKind::Path(p) = &e.kind {\n+                if self.cx.qpath_res(p, e.hir_id) == self.res {\n+                    self.found = true;\n+                }\n+            } else {\n+                walk_expr(self, e)\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res, found: false };\n+    v.visit_expr(&cx.tcx.hir().body(body).value);\n+    v.found\n+}"}, {"sha": "e2e307ce4f6cf93df422f3c10afa1328191da276", "filename": "doc/basics.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -28,6 +28,8 @@ git clone git@github.com:<your-username>/rust-clippy\n If you've already cloned Clippy in the past, update it to the latest version:\n \n ```bash\n+# If the upstream remote has not been added yet\n+git remote add upstream https://github.com/rust-lang/rust-clippy\n # upstream has to be the remote of the rust-lang/rust-clippy repo\n git fetch upstream\n # make sure that you are on the master branch"}, {"sha": "5d9f128753f105fada9a0dfc3405cd9ea7e7b8ba", "filename": "tests/dogfood.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -22,14 +22,12 @@ fn dogfood_clippy() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let enable_metadata_collection = std::env::var(\"ENABLE_METADATA_COLLECTION\").unwrap_or_else(|_| \"0\".to_string());\n \n     let mut command = Command::new(&*CLIPPY_PATH);\n     command\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n-        .env(\"ENABLE_METADATA_COLLECTION\", &enable_metadata_collection)\n         .arg(\"clippy\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")\n@@ -157,10 +155,9 @@ fn dogfood_subprojects() {\n     if cargo::is_rustc_test_suite() {\n         return;\n     }\n-    let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n     // NOTE: `path_dep` crate is omitted on purpose here\n-    for d in &[\n+    for project in &[\n         \"clippy_workspace_tests\",\n         \"clippy_workspace_tests/src\",\n         \"clippy_workspace_tests/subcrate\",\n@@ -170,34 +167,49 @@ fn dogfood_subprojects() {\n         \"clippy_utils\",\n         \"rustc_tools_util\",\n     ] {\n-        let mut command = Command::new(&*CLIPPY_PATH);\n-        command\n-            .current_dir(root_dir.join(d))\n-            .env(\"CLIPPY_DOGFOOD\", \"1\")\n-            .env(\"CARGO_INCREMENTAL\", \"0\")\n-            .arg(\"clippy\")\n-            .arg(\"--all-targets\")\n-            .arg(\"--all-features\")\n-            .arg(\"--\")\n-            .args(&[\"-D\", \"clippy::all\"])\n-            .args(&[\"-D\", \"clippy::pedantic\"])\n-            .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n+        run_clippy_for_project(project);\n+    }\n+\n+    // NOTE: Since tests run in parallel we can't run cargo commands on the same workspace at the\n+    // same time, so we test this immediately after the dogfood for workspaces.\n+    test_no_deps_ignores_path_deps_in_workspaces();\n+}\n \n-        // internal lints only exist if we build with the internal-lints feature\n-        if cfg!(feature = \"internal-lints\") {\n-            command.args(&[\"-D\", \"clippy::internal\"]);\n-        }\n+#[test]\n+#[ignore]\n+#[cfg(feature = \"metadata-collector-lint\")]\n+fn run_metadata_collection_lint() {\n+    std::env::set_var(\"ENABLE_METADATA_COLLECTION\", \"1\");\n+    run_clippy_for_project(\"clippy_lints\");\n+}\n \n-        let output = command.output().unwrap();\n+fn run_clippy_for_project(project: &str) {\n+    let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n-        println!(\"status: {}\", output.status);\n-        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+    let mut command = Command::new(&*CLIPPY_PATH);\n \n-        assert!(output.status.success());\n+    command\n+        .current_dir(root_dir.join(project))\n+        .env(\"CLIPPY_DOGFOOD\", \"1\")\n+        .env(\"CARGO_INCREMENTAL\", \"0\")\n+        .arg(\"clippy\")\n+        .arg(\"--all-targets\")\n+        .arg(\"--all-features\")\n+        .arg(\"--\")\n+        .args(&[\"-D\", \"clippy::all\"])\n+        .args(&[\"-D\", \"clippy::pedantic\"])\n+        .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n+\n+    // internal lints only exist if we build with the internal-lints feature\n+    if cfg!(feature = \"internal-lints\") {\n+        command.args(&[\"-D\", \"clippy::internal\"]);\n     }\n \n-    // NOTE: Since tests run in parallel we can't run cargo commands on the same workspace at the\n-    // same time, so we test this immediately after the dogfood for workspaces.\n-    test_no_deps_ignores_path_deps_in_workspaces();\n+    let output = command.output().unwrap();\n+\n+    println!(\"status: {}\", output.status);\n+    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+    assert!(output.status.success());\n }"}, {"sha": "5595d8d1d626978d136f7c61e26daa74a07010dd", "filename": "tests/ui/crashes/ice-7231.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fcrashes%2Fice-7231.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fcrashes%2Fice-7231.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7231.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+#![allow(clippy::never_loop)]\n+\n+async fn f() {\n+    loop {\n+        break;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "85f7c531e398ae28af7c4056f87c9e1bf4ebd89e", "filename": "tests/ui/floating_point_powi.fixed", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -4,16 +4,17 @@\n fn main() {\n     let one = 1;\n     let x = 3f32;\n-    let _ = x * x;\n-    let _ = x * x;\n \n     let y = 4f32;\n     let _ = x.mul_add(x, y);\n     let _ = y.mul_add(y, x);\n     let _ = x.mul_add(x, y).sqrt();\n     let _ = y.mul_add(y, x).sqrt();\n     // Cases where the lint shouldn't be applied\n+    let _ = x.powi(2);\n+    let _ = x.powi(1 + 1);\n     let _ = x.powi(3);\n+    let _ = x.powi(4) + y;\n     let _ = x.powi(one + 1);\n     let _ = (x.powi(2) + y.powi(2)).sqrt();\n }"}, {"sha": "ece61d1bec42d4bb78b2d9bdc0f419369c11805c", "filename": "tests/ui/floating_point_powi.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -4,16 +4,17 @@\n fn main() {\n     let one = 1;\n     let x = 3f32;\n-    let _ = x.powi(2);\n-    let _ = x.powi(1 + 1);\n \n     let y = 4f32;\n     let _ = x.powi(2) + y;\n     let _ = x + y.powi(2);\n     let _ = (x.powi(2) + y).sqrt();\n     let _ = (x + y.powi(2)).sqrt();\n     // Cases where the lint shouldn't be applied\n+    let _ = x.powi(2);\n+    let _ = x.powi(1 + 1);\n     let _ = x.powi(3);\n+    let _ = x.powi(4) + y;\n     let _ = x.powi(one + 1);\n     let _ = (x.powi(2) + y.powi(2)).sqrt();\n }"}, {"sha": "37d840988bb23b3b422895d73c09fd6670109bcd", "filename": "tests/ui/floating_point_powi.stderr", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ffloating_point_powi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powi.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,40 +1,28 @@\n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:7:13\n-   |\n-LL |     let _ = x.powi(2);\n-   |             ^^^^^^^^^ help: consider using: `x * x`\n-   |\n-   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n-\n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:8:13\n-   |\n-LL |     let _ = x.powi(1 + 1);\n-   |             ^^^^^^^^^^^^^ help: consider using: `x * x`\n-\n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:11:13\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_powi.rs:9:13\n    |\n LL |     let _ = x.powi(2) + y;\n    |             ^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:12:13\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_powi.rs:10:13\n    |\n LL |     let _ = x + y.powi(2);\n    |             ^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n \n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:13:13\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_powi.rs:11:13\n    |\n LL |     let _ = (x.powi(2) + y).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n \n-error: square can be computed more efficiently\n-  --> $DIR/floating_point_powi.rs:14:13\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_powi.rs:12:13\n    |\n LL |     let _ = (x + y.powi(2)).sqrt();\n    |             ^^^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "39443775015365d7197d1fb036b4b35bd66bdb4f", "filename": "tests/ui/impl.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -33,4 +33,35 @@ impl fmt::Debug for MyStruct {\n     }\n }\n \n+// issue #5772\n+struct WithArgs<T>(T);\n+impl WithArgs<u32> {\n+    fn f1() {}\n+}\n+impl WithArgs<u64> {\n+    fn f2() {}\n+}\n+impl WithArgs<u64> {\n+    fn f3() {}\n+}\n+\n+// Ok, the struct is allowed to have multiple impls.\n+#[allow(clippy::multiple_inherent_impl)]\n+struct Allowed;\n+impl Allowed {}\n+impl Allowed {}\n+impl Allowed {}\n+\n+struct AllowedImpl;\n+#[allow(clippy::multiple_inherent_impl)]\n+impl AllowedImpl {}\n+// Ok, the first block is skipped by this lint.\n+impl AllowedImpl {}\n+\n+struct OneAllowedImpl;\n+impl OneAllowedImpl {}\n+#[allow(clippy::multiple_inherent_impl)]\n+impl OneAllowedImpl {}\n+impl OneAllowedImpl {} // Lint, only one of the three blocks is allowed.\n+\n fn main() {}"}, {"sha": "8703ecac93e898f16e63cd47ef979c096414bbb7", "filename": "tests/ui/impl.stderr", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -31,5 +31,33 @@ LL | |     fn first() {}\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: multiple implementations of this structure\n+  --> $DIR/impl.rs:44:1\n+   |\n+LL | / impl WithArgs<u64> {\n+LL | |     fn f3() {}\n+LL | | }\n+   | |_^\n+   |\n+note: first implementation here\n+  --> $DIR/impl.rs:41:1\n+   |\n+LL | / impl WithArgs<u64> {\n+LL | |     fn f2() {}\n+LL | | }\n+   | |_^\n+\n+error: multiple implementations of this structure\n+  --> $DIR/impl.rs:65:1\n+   |\n+LL | impl OneAllowedImpl {} // Lint, only one of the three blocks is allowed.\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first implementation here\n+  --> $DIR/impl.rs:62:1\n+   |\n+LL | impl OneAllowedImpl {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "3717f962745fb4da9a0e3097731343000be21a8b", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -163,4 +163,19 @@ mod issue6965 {\n     }\n }\n \n+use std::rc::Rc;\n+fn format_name(name: Option<&Rc<str>>) -> &str {\n+    match name {\n+        None => \"<anon>\",\n+        Some(name) => name,\n+    }\n+}\n+\n+fn implicit_deref_ref() {\n+    let _: &str = match Some(&\"bye\") {\n+        None => \"hi\",\n+        Some(s) => s,\n+    };\n+}\n+\n fn main() {}"}, {"sha": "989adde1f5bbb7518e8c41a22e24df5fa0cbe82b", "filename": "tests/ui/manual_unwrap_or.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -205,4 +205,19 @@ mod issue6965 {\n     }\n }\n \n+use std::rc::Rc;\n+fn format_name(name: Option<&Rc<str>>) -> &str {\n+    match name {\n+        None => \"<anon>\",\n+        Some(name) => name,\n+    }\n+}\n+\n+fn implicit_deref_ref() {\n+    let _: &str = match Some(&\"bye\") {\n+        None => \"hi\",\n+        Some(s) => s,\n+    };\n+}\n+\n fn main() {}"}, {"sha": "30bf64022533c7bbc452e04f3176756e74718a5e", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -94,10 +94,7 @@ fn main() {\n         0 => println!(\"Disabled branch\"),\n         _ => println!(\"Enabled branch\"),\n     }\n-    // Lint\n-    let x = 1;\n-    let y = 1;\n-    println!(\"Single branch\");\n+\n     // Ok\n     let x = 1;\n     let y = 1;"}, {"sha": "d8bb80d8b96c49fbe58722f9312e88f10f3e286b", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -106,15 +106,7 @@ fn main() {\n         0 => println!(\"Disabled branch\"),\n         _ => println!(\"Enabled branch\"),\n     }\n-    // Lint\n-    let x = 1;\n-    let y = 1;\n-    match match y {\n-        0 => 1,\n-        _ => 2,\n-    } {\n-        _ => println!(\"Single branch\"),\n-    }\n+\n     // Ok\n     let x = 1;\n     let y = 1;"}, {"sha": "795c8c3e24d7e44816419aabc3c3f2256feb2b4f", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -167,16 +167,5 @@ LL |             unwrapped\n LL |         })\n    |\n \n-error: this match could be replaced by its body itself\n-  --> $DIR/match_single_binding.rs:112:5\n-   |\n-LL | /     match match y {\n-LL | |         0 => 1,\n-LL | |         _ => 2,\n-LL | |     } {\n-LL | |         _ => println!(\"Single branch\"),\n-LL | |     }\n-   | |_____^ help: consider using the match body instead: `println!(\"Single branch\");`\n-\n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "a91fcc2125d4178087319b60b8c69dd285c15450", "filename": "tests/ui/match_single_binding2.fixed", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding2.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -34,4 +34,20 @@ fn main() {\n         },\n         None => println!(\"nothing\"),\n     }\n+\n+    fn side_effects() {}\n+\n+    // Lint (scrutinee has side effects)\n+    // issue #7094\n+    side_effects();\n+    println!(\"Side effects\");\n+\n+    // Lint (scrutinee has side effects)\n+    // issue #7094\n+    let x = 1;\n+    match x {\n+        0 => 1,\n+        _ => 2,\n+    };\n+    println!(\"Single branch\");\n }"}, {"sha": "476386ebabe20a5a731daac2f8bd03ec1ff0cc12", "filename": "tests/ui/match_single_binding2.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding2.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -34,4 +34,22 @@ fn main() {\n         },\n         None => println!(\"nothing\"),\n     }\n+\n+    fn side_effects() {}\n+\n+    // Lint (scrutinee has side effects)\n+    // issue #7094\n+    match side_effects() {\n+        _ => println!(\"Side effects\"),\n+    }\n+\n+    // Lint (scrutinee has side effects)\n+    // issue #7094\n+    let x = 1;\n+    match match x {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        _ => println!(\"Single branch\"),\n+    }\n }"}, {"sha": "4372f55af8767978d764ba5bc1b99c64384fbca0", "filename": "tests/ui/match_single_binding2.stderr", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fmatch_single_binding2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding2.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -30,5 +30,39 @@ LL |             let (a, b) = get_tup();\n LL |             println!(\"a {:?} and b {:?}\", a, b);\n    |\n \n-error: aborting due to 2 previous errors\n+error: this match could be replaced by its scrutinee and body\n+  --> $DIR/match_single_binding2.rs:42:5\n+   |\n+LL | /     match side_effects() {\n+LL | |         _ => println!(\"Side effects\"),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the scrutinee and body instead\n+   |\n+LL |     side_effects();\n+LL |     println!(\"Side effects\");\n+   |\n+\n+error: this match could be replaced by its scrutinee and body\n+  --> $DIR/match_single_binding2.rs:49:5\n+   |\n+LL | /     match match x {\n+LL | |         0 => 1,\n+LL | |         _ => 2,\n+LL | |     } {\n+LL | |         _ => println!(\"Single branch\"),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the scrutinee and body instead\n+   |\n+LL |     match x {\n+LL |         0 => 1,\n+LL |         _ => 2,\n+LL |     };\n+LL |     println!(\"Single branch\");\n+   |\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "5e1ea663a1077b8a5a69e4b5d1281dc5c6bac500", "filename": "tests/ui/needless_bitwise_bool.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bitwise_bool.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_bitwise_bool)]\n+\n+fn returns_bool() -> bool {\n+    true\n+}\n+\n+const fn const_returns_bool() -> bool {\n+    false\n+}\n+\n+fn main() {\n+    let (x, y) = (false, true);\n+    if x & y {\n+        println!(\"true\")\n+    }\n+    if returns_bool() & x {\n+        println!(\"true\")\n+    }\n+    if !returns_bool() & returns_bool() {\n+        println!(\"true\")\n+    }\n+    if y && !x {\n+        println!(\"true\")\n+    }\n+\n+    // BELOW: lints we hope to catch as `Expr::can_have_side_effects` improves.\n+    if y & !const_returns_bool() {\n+        println!(\"true\") // This is a const function, in an UnOp\n+    }\n+\n+    if y & \"abcD\".is_empty() {\n+        println!(\"true\") // This is a const method call\n+    }\n+\n+    if y & (0 < 1) {\n+        println!(\"true\") // This is a BinOp with no side effects\n+    }\n+}"}, {"sha": "f3075fba0a2d6b1468bd08ce13dac922e0390d34", "filename": "tests/ui/needless_bitwise_bool.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bitwise_bool.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_bitwise_bool)]\n+\n+fn returns_bool() -> bool {\n+    true\n+}\n+\n+const fn const_returns_bool() -> bool {\n+    false\n+}\n+\n+fn main() {\n+    let (x, y) = (false, true);\n+    if x & y {\n+        println!(\"true\")\n+    }\n+    if returns_bool() & x {\n+        println!(\"true\")\n+    }\n+    if !returns_bool() & returns_bool() {\n+        println!(\"true\")\n+    }\n+    if y & !x {\n+        println!(\"true\")\n+    }\n+\n+    // BELOW: lints we hope to catch as `Expr::can_have_side_effects` improves.\n+    if y & !const_returns_bool() {\n+        println!(\"true\") // This is a const function, in an UnOp\n+    }\n+\n+    if y & \"abcD\".is_empty() {\n+        println!(\"true\") // This is a const method call\n+    }\n+\n+    if y & (0 < 1) {\n+        println!(\"true\") // This is a BinOp with no side effects\n+    }\n+}"}, {"sha": "63c88ef63f52fc7ce871cd284e12245889492540", "filename": "tests/ui/needless_bitwise_bool.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_bitwise_bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bitwise_bool.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,10 @@\n+error: use of bitwise operator instead of lazy operator between booleans\n+  --> $DIR/needless_bitwise_bool.rs:24:8\n+   |\n+LL |     if y & !x {\n+   |        ^^^^^^ help: try: `y && !x`\n+   |\n+   = note: `-D clippy::needless-bitwise-bool` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "6ecbbcb62495553c3630cff05f0dc4dc871b6639", "filename": "tests/ui/needless_collect.fixed", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -2,7 +2,7 @@\n \n #![allow(unused, clippy::suspicious_map, clippy::iter_count)]\n \n-use std::collections::{BTreeSet, HashMap, HashSet};\n+use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList};\n \n #[warn(clippy::needless_collect)]\n #[allow(unused_variables, clippy::iter_cloned_collect, clippy::iter_next_slice)]\n@@ -13,9 +13,24 @@ fn main() {\n         // Empty\n     }\n     sample.iter().cloned().any(|x| x == 1);\n-    sample.iter().map(|x| (x, x)).count();\n+    // #7164 HashMap's and BTreeMap's `len` usage should not be linted\n+    sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n+    sample.iter().map(|x| (x, x)).collect::<BTreeMap<_, _>>().len();\n+\n+    sample.iter().map(|x| (x, x)).next().is_none();\n+    sample.iter().map(|x| (x, x)).next().is_none();\n+\n     // Notice the `HashSet`--this should not be linted\n     sample.iter().collect::<HashSet<_>>().len();\n     // Neither should this\n     sample.iter().collect::<BTreeSet<_>>().len();\n+\n+    sample.iter().count();\n+    sample.iter().next().is_none();\n+    sample.iter().cloned().any(|x| x == 1);\n+    sample.iter().any(|x| x == &1);\n+\n+    // `BinaryHeap` doesn't have `contains` method\n+    sample.iter().count();\n+    sample.iter().next().is_none();\n }"}, {"sha": "8dc69bcf5b38df30295e0539b1a038916613861e", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -2,7 +2,7 @@\n \n #![allow(unused, clippy::suspicious_map, clippy::iter_count)]\n \n-use std::collections::{BTreeSet, HashMap, HashSet};\n+use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList};\n \n #[warn(clippy::needless_collect)]\n #[allow(unused_variables, clippy::iter_cloned_collect, clippy::iter_next_slice)]\n@@ -13,9 +13,24 @@ fn main() {\n         // Empty\n     }\n     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n+    // #7164 HashMap's and BTreeMap's `len` usage should not be linted\n     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n+    sample.iter().map(|x| (x, x)).collect::<BTreeMap<_, _>>().len();\n+\n+    sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().is_empty();\n+    sample.iter().map(|x| (x, x)).collect::<BTreeMap<_, _>>().is_empty();\n+\n     // Notice the `HashSet`--this should not be linted\n     sample.iter().collect::<HashSet<_>>().len();\n     // Neither should this\n     sample.iter().collect::<BTreeSet<_>>().len();\n+\n+    sample.iter().collect::<LinkedList<_>>().len();\n+    sample.iter().collect::<LinkedList<_>>().is_empty();\n+    sample.iter().cloned().collect::<LinkedList<_>>().contains(&1);\n+    sample.iter().collect::<LinkedList<_>>().contains(&&1);\n+\n+    // `BinaryHeap` doesn't have `contains` method\n+    sample.iter().collect::<BinaryHeap<_>>().len();\n+    sample.iter().collect::<BinaryHeap<_>>().is_empty();\n }"}, {"sha": "039091627a8d632c3fed7cabff373e95e4315bfc", "filename": "tests/ui/needless_collect.stderr", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -19,10 +19,52 @@ LL |     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == 1)`\n \n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:16:35\n+  --> $DIR/needless_collect.rs:20:35\n    |\n-LL |     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n+LL |     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().is_empty();\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n \n-error: aborting due to 4 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:21:35\n+   |\n+LL |     sample.iter().map(|x| (x, x)).collect::<BTreeMap<_, _>>().is_empty();\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:28:19\n+   |\n+LL |     sample.iter().collect::<LinkedList<_>>().len();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:29:19\n+   |\n+LL |     sample.iter().collect::<LinkedList<_>>().is_empty();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:30:28\n+   |\n+LL |     sample.iter().cloned().collect::<LinkedList<_>>().contains(&1);\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == 1)`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:31:19\n+   |\n+LL |     sample.iter().collect::<LinkedList<_>>().contains(&&1);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == &1)`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:34:19\n+   |\n+LL |     sample.iter().collect::<BinaryHeap<_>>().len();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:35:19\n+   |\n+LL |     sample.iter().collect::<BinaryHeap<_>>().is_empty();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "f1fc81aa12b9e7cb6b325f7142a9027602f18483", "filename": "tests/ui/needless_question_mark.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -94,6 +94,11 @@ where\n     Ok(x?)\n }\n \n+// not quite needless\n+fn deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n fn main() {}\n \n // #6921 if a macro wraps an expr in Some(  ) and the ? is in the macro use,"}, {"sha": "44a0c5f61b5d5f71c9d6d7ebdc3eea35bb423572", "filename": "tests/ui/needless_question_mark.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -94,6 +94,11 @@ where\n     Ok(x?)\n }\n \n+// not quite needless\n+fn deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n fn main() {}\n \n // #6921 if a macro wraps an expr in Some(  ) and the ? is in the macro use,"}, {"sha": "02bf50d077abff4c523b38f8822fc1888b26095d", "filename": "tests/ui/needless_question_mark.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -67,7 +67,7 @@ LL |         return Ok(t.magic?);\n    |                ^^^^^^^^^^^^ help: try: `t.magic`\n \n error: question mark operator is useless here\n-  --> $DIR/needless_question_mark.rs:115:27\n+  --> $DIR/needless_question_mark.rs:120:27\n    |\n LL |         || -> Option<_> { Some(Some($expr)?) }()\n    |                           ^^^^^^^^^^^^^^^^^^ help: try: `Some($expr)`"}, {"sha": "769ccc14bc1e4c2ba27f1e0a21c46799f052a3cc", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -10,7 +10,11 @@ fn bad1(string: Option<&str>) -> (bool, &str) {\n fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n     if string.is_none() {\n         None\n-    } else { string.map_or(Some((false, \"\")), |x| Some((true, x))) }\n+    } else if let Some(x) = string {\n+        Some((true, x))\n+    } else {\n+        Some((false, \"\"))\n+    }\n }\n \n fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {"}, {"sha": "4ebb068d22ed52bd3de3a674f214639aad6417fc", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -10,17 +10,6 @@ LL | |     }\n    |\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n-error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:17:12\n-   |\n-LL |       } else if let Some(x) = string {\n-   |  ____________^\n-LL | |         Some((true, x))\n-LL | |     } else {\n-LL | |         Some((false, \"\"))\n-LL | |     }\n-   | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n-\n error: use Option::map_or instead of an if let/else\n   --> $DIR/option_if_let_else.rs:25:13\n    |\n@@ -159,5 +148,5 @@ error: use Option::map_or instead of an if let/else\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "4f4203f5fdbf67fd59049f85769d322ae2ff73ba", "filename": "tests/ui/unused_async.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_async.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,15 @@\n+// edition:2018\n+#![warn(clippy::unused_async)]\n+\n+async fn foo() -> i32 {\n+    4\n+}\n+\n+async fn bar() -> i32 {\n+    foo().await\n+}\n+\n+fn main() {\n+    foo();\n+    bar();\n+}"}, {"sha": "8b834d205b176970c8911b5f371c1282de83feb1", "filename": "tests/ui/unused_async.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Funused_async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Funused_async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_async.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -0,0 +1,13 @@\n+error: unused `async` for function with no await statements\n+  --> $DIR/unused_async.rs:4:1\n+   |\n+LL | / async fn foo() -> i32 {\n+LL | |     4\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::unused-async` implied by `-D warnings`\n+   = help: consider removing the `async` from this function\n+\n+error: aborting due to previous error\n+"}, {"sha": "631da6fe066dde1703ee467b7d7e56a837e44d54", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -462,3 +462,33 @@ mod issue6818 {\n         a: i32,\n     }\n }\n+\n+mod issue7206 {\n+    struct MyStruct<const C: char>;\n+    impl From<MyStruct<'a'>> for MyStruct<'b'> {\n+        fn from(_s: MyStruct<'a'>) -> Self {\n+            Self\n+        }\n+    }\n+\n+    // keep linting non-`Const` generic args\n+    struct S<'a> {\n+        inner: &'a str,\n+    }\n+\n+    struct S2<T> {\n+        inner: T,\n+    }\n+\n+    impl<T> S2<T> {\n+        fn new() -> Self {\n+            unimplemented!();\n+        }\n+    }\n+\n+    impl<'a> S2<S<'a>> {\n+        fn new_again() -> Self {\n+            Self::new()\n+        }\n+    }\n+}"}, {"sha": "7a10d755faa18e0ad96c21939b2694bc6c3ae27d", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -462,3 +462,33 @@ mod issue6818 {\n         a: i32,\n     }\n }\n+\n+mod issue7206 {\n+    struct MyStruct<const C: char>;\n+    impl From<MyStruct<'a'>> for MyStruct<'b'> {\n+        fn from(_s: MyStruct<'a'>) -> Self {\n+            Self\n+        }\n+    }\n+\n+    // keep linting non-`Const` generic args\n+    struct S<'a> {\n+        inner: &'a str,\n+    }\n+\n+    struct S2<T> {\n+        inner: T,\n+    }\n+\n+    impl<T> S2<T> {\n+        fn new() -> Self {\n+            unimplemented!();\n+        }\n+    }\n+\n+    impl<'a> S2<S<'a>> {\n+        fn new_again() -> Self {\n+            S2::new()\n+        }\n+    }\n+}"}, {"sha": "cf6222c9b453235e2eb8d068495e7d6843da097a", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -162,5 +162,11 @@ error: unnecessary structure name repetition\n LL |             A::new::<submod::B>(submod::B {})\n    |             ^ help: use the applicable keyword: `Self`\n \n-error: aborting due to 27 previous errors\n+error: unnecessary structure name repetition\n+  --> $DIR/use_self.rs:491:13\n+   |\n+LL |             S2::new()\n+   |             ^^ help: use the applicable keyword: `Self`\n+\n+error: aborting due to 28 previous errors\n "}, {"sha": "76aa82068d62e67bff5fbe7fc73c6a42e05f98a7", "filename": "tests/ui/useless_conversion.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -70,4 +70,23 @@ fn main() {\n     let a: i32 = 1;\n     let b: i32 = 1;\n     let _ = (a + b) * 3;\n+\n+    // see #7205\n+    let s: Foo<'a'> = Foo;\n+    let _: Foo<'b'> = s.into();\n+    let s2: Foo<'a'> = Foo;\n+    let _: Foo<'a'> = s2;\n+    let s3: Foo<'a'> = Foo;\n+    let _ = s3;\n+    let s4: Foo<'a'> = Foo;\n+    let _ = vec![s4, s4, s4].into_iter();\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Foo<const C: char>;\n+\n+impl From<Foo<'a'>> for Foo<'b'> {\n+    fn from(_s: Foo<'a'>) -> Self {\n+        Foo\n+    }\n }"}, {"sha": "ccee7abb404e68aa3f993d917b70536b5acdf62f", "filename": "tests/ui/useless_conversion.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -70,4 +70,23 @@ fn main() {\n     let a: i32 = 1;\n     let b: i32 = 1;\n     let _ = i32::from(a + b) * 3;\n+\n+    // see #7205\n+    let s: Foo<'a'> = Foo;\n+    let _: Foo<'b'> = s.into();\n+    let s2: Foo<'a'> = Foo;\n+    let _: Foo<'a'> = s2.into();\n+    let s3: Foo<'a'> = Foo;\n+    let _ = Foo::<'a'>::from(s3);\n+    let s4: Foo<'a'> = Foo;\n+    let _ = vec![s4, s4, s4].into_iter().into_iter();\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Foo<const C: char>;\n+\n+impl From<Foo<'a'>> for Foo<'b'> {\n+    fn from(_s: Foo<'a'>) -> Self {\n+        Foo\n+    }\n }"}, {"sha": "e6760f700f3423b1320e5dc01ed88733d247c56c", "filename": "tests/ui/useless_conversion.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fuseless_conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_conversion.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -70,5 +70,23 @@ error: useless conversion to the same type: `i32`\n LL |     let _ = i32::from(a + b) * 3;\n    |             ^^^^^^^^^^^^^^^^ help: consider removing `i32::from()`: `(a + b)`\n \n-error: aborting due to 11 previous errors\n+error: useless conversion to the same type: `Foo<'a'>`\n+  --> $DIR/useless_conversion.rs:78:23\n+   |\n+LL |     let _: Foo<'a'> = s2.into();\n+   |                       ^^^^^^^^^ help: consider removing `.into()`: `s2`\n+\n+error: useless conversion to the same type: `Foo<'a'>`\n+  --> $DIR/useless_conversion.rs:80:13\n+   |\n+LL |     let _ = Foo::<'a'>::from(s3);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider removing `Foo::<'a'>::from()`: `s3`\n+\n+error: useless conversion to the same type: `std::vec::IntoIter<Foo<'a'>>`\n+  --> $DIR/useless_conversion.rs:82:13\n+   |\n+LL |     let _ = vec![s4, s4, s4].into_iter().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into_iter()`: `vec![s4, s4, s4].into_iter()`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "c3e2cf0c4a4bd485e8a869e3a1b7f140eacdc9e3", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 143, "deletions": 32, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::while_let_on_iterator)]\n-#![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![allow(clippy::never_loop, unreachable_code, unused_mut, dead_code)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -38,13 +38,6 @@ fn base() {\n         println!(\"next: {:?}\", iter.next());\n     }\n \n-    // or this\n-    let mut iter = 1u32..20;\n-    while let Some(_) = iter.next() {\n-        break;\n-    }\n-    println!(\"Remaining iter {:?}\", iter);\n-\n     // or this\n     let mut iter = 1u32..20;\n     while let Some(_) = iter.next() {\n@@ -135,18 +128,6 @@ fn refutable2() {\n \n fn nested_loops() {\n     let a = [42, 1337];\n-    let mut y = a.iter();\n-    loop {\n-        // x is reused, so don't lint here\n-        while let Some(_) = y.next() {}\n-    }\n-\n-    let mut y = a.iter();\n-    for _ in 0..2 {\n-        while let Some(_) = y.next() {\n-            // y is reused, don't lint\n-        }\n-    }\n \n     loop {\n         let mut y = a.iter();\n@@ -167,10 +148,8 @@ fn issue1121() {\n }\n \n fn issue2965() {\n-    // This should not cause an ICE and suggest:\n-    //\n-    // for _ in values.iter() {}\n-    //\n+    // This should not cause an ICE\n+\n     use std::collections::HashSet;\n     let mut values = HashSet::new();\n     values.insert(1);\n@@ -205,13 +184,145 @@ fn issue1654() {\n     }\n }\n \n+fn issue6491() {\n+    // Used in outer loop, needs &mut\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        for m in &mut it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+\n+    // This is fine, inner loop uses a new iterator.\n+    let mut it = 1..40;\n+    for n in it {\n+        let mut it = 1..40;\n+        for m in it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Weird binding shouldn't change anything.\n+        let (mut it, _) = (1..40, 0);\n+        for m in it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Used after the loop, needs &mut.\n+        let mut it = 1..40;\n+        for m in &mut it {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"next item {}\", it.next().unwrap());\n+\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue6231() {\n+    // Closure in the outer loop, needs &mut\n+    let mut it = 1..40;\n+    let mut opt = Some(0);\n+    while let Some(n) = opt.take().or_else(|| it.next()) {\n+        for m in &mut it {\n+            if n % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue1924() {\n+    struct S<T>(T);\n+    impl<T: Iterator<Item = u32>> S<T> {\n+        fn f(&mut self) -> Option<u32> {\n+            // Used as a field.\n+            for i in &mut self.0 {\n+                if !(3..=7).contains(&i) {\n+                    return Some(i);\n+                }\n+            }\n+            None\n+        }\n+\n+        fn f2(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.next() {\n+                if i == 1 {\n+                    return self.f();\n+                }\n+            }\n+            None\n+        }\n+    }\n+    impl<T: Iterator<Item = u32>> S<(S<T>, Option<u32>)> {\n+        fn f3(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.0.f();\n+                }\n+            }\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.f3();\n+                }\n+            }\n+            // This one is fine, a different field is borrowed\n+            for i in &mut self.0.0.0 {\n+                if i == 1 {\n+                    return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    struct S2<T>(T, u32);\n+    impl<T: Iterator<Item = u32>> Iterator for S2<T> {\n+        type Item = u32;\n+        fn next(&mut self) -> Option<u32> {\n+            self.0.next()\n+        }\n+    }\n+\n+    // Don't lint, field of the iterator is accessed in the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == it.1 {\n+            break;\n+        }\n+    }\n+\n+    // Needs &mut, field of the iterator is accessed after the loop\n+    let mut it = S2(1..40, 0);\n+    for n in &mut it {\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"iterator field {}\", it.1);\n+}\n+\n fn main() {\n-    base();\n-    refutable();\n-    refutable2();\n-    nested_loops();\n-    issue1121();\n-    issue2965();\n-    issue3670();\n-    issue1654();\n+    let mut it = 0..20;\n+    for _ in it {\n+        println!(\"test\");\n+    }\n }"}, {"sha": "1717006a4490e59884b5e6db16858021ada5e383", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 143, "deletions": 32, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::while_let_on_iterator)]\n-#![allow(clippy::never_loop, unreachable_code, unused_mut)]\n+#![allow(clippy::never_loop, unreachable_code, unused_mut, dead_code)]\n \n fn base() {\n     let mut iter = 1..20;\n@@ -38,13 +38,6 @@ fn base() {\n         println!(\"next: {:?}\", iter.next());\n     }\n \n-    // or this\n-    let mut iter = 1u32..20;\n-    while let Some(_) = iter.next() {\n-        break;\n-    }\n-    println!(\"Remaining iter {:?}\", iter);\n-\n     // or this\n     let mut iter = 1u32..20;\n     while let Some(_) = iter.next() {\n@@ -135,18 +128,6 @@ fn refutable2() {\n \n fn nested_loops() {\n     let a = [42, 1337];\n-    let mut y = a.iter();\n-    loop {\n-        // x is reused, so don't lint here\n-        while let Some(_) = y.next() {}\n-    }\n-\n-    let mut y = a.iter();\n-    for _ in 0..2 {\n-        while let Some(_) = y.next() {\n-            // y is reused, don't lint\n-        }\n-    }\n \n     loop {\n         let mut y = a.iter();\n@@ -167,10 +148,8 @@ fn issue1121() {\n }\n \n fn issue2965() {\n-    // This should not cause an ICE and suggest:\n-    //\n-    // for _ in values.iter() {}\n-    //\n+    // This should not cause an ICE\n+\n     use std::collections::HashSet;\n     let mut values = HashSet::new();\n     values.insert(1);\n@@ -205,13 +184,145 @@ fn issue1654() {\n     }\n }\n \n+fn issue6491() {\n+    // Used in outer loop, needs &mut\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+\n+    // This is fine, inner loop uses a new iterator.\n+    let mut it = 1..40;\n+    while let Some(n) = it.next() {\n+        let mut it = 1..40;\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Weird binding shouldn't change anything.\n+        let (mut it, _) = (1..40, 0);\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+\n+        // Used after the loop, needs &mut.\n+        let mut it = 1..40;\n+        while let Some(m) = it.next() {\n+            if m % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"next item {}\", it.next().unwrap());\n+\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue6231() {\n+    // Closure in the outer loop, needs &mut\n+    let mut it = 1..40;\n+    let mut opt = Some(0);\n+    while let Some(n) = opt.take().or_else(|| it.next()) {\n+        while let Some(m) = it.next() {\n+            if n % 10 == 0 {\n+                break;\n+            }\n+            println!(\"doing something with m: {}\", m);\n+        }\n+        println!(\"n still is {}\", n);\n+    }\n+}\n+\n+fn issue1924() {\n+    struct S<T>(T);\n+    impl<T: Iterator<Item = u32>> S<T> {\n+        fn f(&mut self) -> Option<u32> {\n+            // Used as a field.\n+            while let Some(i) = self.0.next() {\n+                if i < 3 || i > 7 {\n+                    return Some(i);\n+                }\n+            }\n+            None\n+        }\n+\n+        fn f2(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.next() {\n+                if i == 1 {\n+                    return self.f();\n+                }\n+            }\n+            None\n+        }\n+    }\n+    impl<T: Iterator<Item = u32>> S<(S<T>, Option<u32>)> {\n+        fn f3(&mut self) -> Option<u32> {\n+            // Don't lint, self borrowed inside the loop\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.0.f();\n+                }\n+            }\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.f3();\n+                }\n+            }\n+            // This one is fine, a different field is borrowed\n+            while let Some(i) = self.0.0.0.next() {\n+                if i == 1 {\n+                    return self.0.1.take();\n+                } else {\n+                    self.0.1 = Some(i);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    struct S2<T>(T, u32);\n+    impl<T: Iterator<Item = u32>> Iterator for S2<T> {\n+        type Item = u32;\n+        fn next(&mut self) -> Option<u32> {\n+            self.0.next()\n+        }\n+    }\n+\n+    // Don't lint, field of the iterator is accessed in the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == it.1 {\n+            break;\n+        }\n+    }\n+\n+    // Needs &mut, field of the iterator is accessed after the loop\n+    let mut it = S2(1..40, 0);\n+    while let Some(n) = it.next() {\n+        if n == 0 {\n+            break;\n+        }\n+    }\n+    println!(\"iterator field {}\", it.1);\n+}\n+\n fn main() {\n-    base();\n-    refutable();\n-    refutable2();\n-    nested_loops();\n-    issue1121();\n-    issue2965();\n-    issue3670();\n-    issue1654();\n+    let mut it = 0..20;\n+    while let Some(..) = it.next() {\n+        println!(\"test\");\n+    }\n }"}, {"sha": "eff559bef7e3b87a3ab9491876558389070393a9", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -19,28 +19,96 @@ LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:101:9\n+  --> $DIR/while_let_on_iterator.rs:94:9\n    |\n LL |         while let Some([..]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:108:9\n+  --> $DIR/while_let_on_iterator.rs:101:9\n    |\n LL |         while let Some([_x]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:121:9\n+  --> $DIR/while_let_on_iterator.rs:114:9\n    |\n LL |         while let Some(x @ [_]) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:153:9\n+  --> $DIR/while_let_on_iterator.rs:134:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n-error: aborting due to 7 previous errors\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:191:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:202:5\n+   |\n+LL |     while let Some(n) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:204:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:213:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:222:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:239:9\n+   |\n+LL |         while let Some(m) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:254:13\n+   |\n+LL |             while let Some(i) = self.0.next() {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0`\n+\n+error: manual `!RangeInclusive::contains` implementation\n+  --> $DIR/while_let_on_iterator.rs:255:20\n+   |\n+LL |                 if i < 3 || i > 7 {\n+   |                    ^^^^^^^^^^^^^^ help: use: `!(3..=7).contains(&i)`\n+   |\n+   = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:286:13\n+   |\n+LL |             while let Some(i) = self.0.0.0.next() {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in &mut self.0.0.0`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:315:5\n+   |\n+LL |     while let Some(n) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:325:5\n+   |\n+LL |     while let Some(..) = it.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n+\n+error: aborting due to 18 previous errors\n "}, {"sha": "cecc2ea9406aa77c140875cdff363b0124551010", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -51,8 +51,8 @@ LL |     write!(&mut v, \"/n\");\n    |\n help: use `writeln!()` instead\n    |\n-LL |     writeln!(&mut v, );\n-   |     ^^^^^^^         --\n+LL |     writeln!(&mut v);\n+   |     ^^^^^^^       --\n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:36:5"}, {"sha": "3a72174d03d68f6970d6070d5ec2dcc3081aa7ea", "filename": "tests/ui/wrong_self_convention2.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrong_self_convention2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrong_self_convention2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.rs?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -23,7 +23,7 @@ mod issue6983 {\n     }\n \n     struct FooNoCopy;\n-    // trigger lint\n+    // don't trigger\n     impl ToU64 for FooNoCopy {\n         fn to_u64(self) -> u64 {\n             2\n@@ -42,3 +42,30 @@ mod issue7032 {\n         }\n     }\n }\n+\n+mod issue7179 {\n+    pub struct S(i32);\n+\n+    impl S {\n+        // don't trigger (`s` is not `self`)\n+        pub fn from_be(s: Self) -> Self {\n+            S(i32::from_be(s.0))\n+        }\n+\n+        // lint\n+        pub fn from_be_self(self) -> Self {\n+            S(i32::from_be(self.0))\n+        }\n+    }\n+\n+    trait T {\n+        // don't trigger (`s` is not `self`)\n+        fn from_be(s: Self) -> Self;\n+        // lint\n+        fn from_be_self(self) -> Self;\n+    }\n+\n+    trait Foo: Sized {\n+        fn as_byte_slice(slice: &[Self]) -> &[u8];\n+    }\n+}"}, {"sha": "d2d74ce099e3da46a3134b20385a2ac82ff4f519", "filename": "tests/ui/wrong_self_convention2.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrong_self_convention2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b/tests%2Fui%2Fwrong_self_convention2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.stderr?ref=451ff5668b0c83e96a0dd4f55e96f0a0ed2fcb3b", "patch": "@@ -1,11 +1,19 @@\n-error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n-  --> $DIR/wrong_self_convention2.rs:28:19\n+error: methods called `from_*` usually take no `self`\n+  --> $DIR/wrong_self_convention2.rs:56:29\n    |\n-LL |         fn to_u64(self) -> u64 {\n-   |                   ^^^^\n+LL |         pub fn from_be_self(self) -> Self {\n+   |                             ^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n    = help: consider choosing a less ambiguous name\n \n-error: aborting due to previous error\n+error: methods called `from_*` usually take no `self`\n+  --> $DIR/wrong_self_convention2.rs:65:25\n+   |\n+LL |         fn from_be_self(self) -> Self;\n+   |                         ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n+error: aborting due to 2 previous errors\n "}]}