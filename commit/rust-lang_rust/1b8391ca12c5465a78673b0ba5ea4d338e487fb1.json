{"sha": "1b8391ca12c5465a78673b0ba5ea4d338e487fb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiODM5MWNhMTJjNTQ2NWE3ODY3M2IwYmE1ZWE0ZDMzOGU0ODdmYjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-22T02:48:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:34Z"}, "message": "librustc: De-`@mut` `MoveData::moves`", "tree": {"sha": "7b740afe6d2059480a22e65855dba02e11e46d60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b740afe6d2059480a22e65855dba02e11e46d60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b8391ca12c5465a78673b0ba5ea4d338e487fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8391ca12c5465a78673b0ba5ea4d338e487fb1", "html_url": "https://github.com/rust-lang/rust/commit/1b8391ca12c5465a78673b0ba5ea4d338e487fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b8391ca12c5465a78673b0ba5ea4d338e487fb1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ded423505b4f36087912497b868acfccd02a7f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ded423505b4f36087912497b868acfccd02a7f7", "html_url": "https://github.com/rust-lang/rust/commit/1ded423505b4f36087912497b868acfccd02a7f7"}], "stats": {"total": 46, "additions": 30, "deletions": 16}, "files": [{"sha": "d4c5fa5c454bc157018d4d1d3bf8e6dab077ea1f", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1b8391ca12c5465a78673b0ba5ea4d338e487fb1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8391ca12c5465a78673b0ba5ea4d338e487fb1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=1b8391ca12c5465a78673b0ba5ea4d338e487fb1", "patch": "@@ -38,7 +38,7 @@ pub struct MoveData {\n     path_map: HashMap<@LoanPath, MovePathIndex>,\n \n     /// Each move or uninitialized variable gets an entry here.\n-    moves: ~[Move],\n+    moves: RefCell<~[Move]>,\n \n     /// Assignments to a variable, like `x = foo`. These are assigned\n     /// bits for dataflow, since we must track them to ensure that\n@@ -167,7 +167,7 @@ impl MoveData {\n         MoveData {\n             paths: RefCell::new(~[]),\n             path_map: HashMap::new(),\n-            moves: ~[],\n+            moves: RefCell::new(~[]),\n             path_assignments: ~[],\n             var_assignments: ~[],\n             assignee_ids: HashSet::new(),\n@@ -216,7 +216,8 @@ impl MoveData {\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n-        self.moves[*index].next_move\n+        let moves = self.moves.borrow();\n+        moves.get()[*index].next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -349,17 +350,23 @@ impl MoveData {\n                kind);\n \n         let path_index = self.move_path(tcx, lp);\n-        let move_index = MoveIndex(self.moves.len());\n+        let move_index = {\n+            let moves = self.moves.borrow();\n+            MoveIndex(moves.get().len())\n+        };\n \n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n-        self.moves.push(Move {\n-            path: path_index,\n-            id: id,\n-            kind: kind,\n-            next_move: next_move\n-        });\n+        {\n+            let mut moves = self.moves.borrow_mut();\n+            moves.get().push(Move {\n+                path: path_index,\n+                id: id,\n+                kind: kind,\n+                next_move: next_move\n+            });\n+        }\n     }\n \n     pub fn add_assignment(&mut self,\n@@ -411,8 +418,11 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        for (i, move) in self.moves.iter().enumerate() {\n-            dfcx_moves.add_gen(move.id, i);\n+        {\n+            let moves = self.moves.borrow();\n+            for (i, move) in moves.get().iter().enumerate() {\n+                dfcx_moves.add_gen(move.id, i);\n+            }\n         }\n \n         for (i, assignment) in self.var_assignments.iter().enumerate() {\n@@ -523,12 +533,14 @@ impl FlowedMoveData {\n                body: &ast::Block)\n                -> FlowedMoveData\n     {\n-        let mut dfcx_moves =\n+        let mut dfcx_moves = {\n+            let moves = move_data.moves.borrow();\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  MoveDataFlowOperator,\n                                  id_range,\n-                                 move_data.moves.len());\n+                                 moves.get().len())\n+        };\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n                                  method_map,\n@@ -554,7 +566,8 @@ impl FlowedMoveData {\n          */\n \n         self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n-            let move = &self.move_data.moves[index];\n+            let moves = self.move_data.moves.borrow();\n+            let move = &moves.get()[index];\n             let moved_path = move.path;\n             f(move, self.move_data.path_loan_path(moved_path))\n         })\n@@ -592,7 +605,8 @@ impl FlowedMoveData {\n         let mut ret = true;\n \n         self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n-            let move = &self.move_data.moves[index];\n+            let moves = self.move_data.moves.borrow();\n+            let move = &moves.get()[index];\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of"}]}