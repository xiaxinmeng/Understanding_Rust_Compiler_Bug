{"sha": "6194092086045cb430e3391dc0bca0ac2368bdd2", "node_id": "C_kwDOAAsO6NoAKDYxOTQwOTIwODYwNDVjYjQzMGUzMzkxZGMwYmNhMGFjMjM2OGJkZDI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-31T10:56:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-31T10:56:42Z"}, "message": "Complete local fn and closure params from surrounding locals scope", "tree": {"sha": "35183f8618ef20e198cec24a7bbc0139c9a8104a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35183f8618ef20e198cec24a7bbc0139c9a8104a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6194092086045cb430e3391dc0bca0ac2368bdd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6194092086045cb430e3391dc0bca0ac2368bdd2", "html_url": "https://github.com/rust-lang/rust/commit/6194092086045cb430e3391dc0bca0ac2368bdd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6194092086045cb430e3391dc0bca0ac2368bdd2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf7b70a0f8f7fc1e49d2bf0365752be3b4aab8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf7b70a0f8f7fc1e49d2bf0365752be3b4aab8b", "html_url": "https://github.com/rust-lang/rust/commit/ddf7b70a0f8f7fc1e49d2bf0365752be3b4aab8b"}], "stats": {"total": 287, "additions": 199, "deletions": 88}, "files": [{"sha": "a210574a06e5ac939c287462b3c562091d331635", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6194092086045cb430e3391dc0bca0ac2368bdd2", "patch": "@@ -389,8 +389,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.scope(node)\n     }\n \n-    pub fn scope_at_offset(&self, token: &SyntaxToken, offset: TextSize) -> SemanticsScope<'db> {\n-        self.imp.scope_at_offset(&token.parent().unwrap(), offset)\n+    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n+        self.imp.scope_at_offset(&node, offset)\n     }\n \n     pub fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {"}, {"sha": "961681c20cb754d790238f17658e8782e3ad0fa1", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=6194092086045cb430e3391dc0bca0ac2368bdd2", "patch": "@@ -1,9 +1,11 @@\n //! See [`complete_fn_param`].\n \n+use hir::HirDisplay;\n use rustc_hash::FxHashMap;\n use syntax::{\n+    algo,\n     ast::{self, HasModuleItem},\n-    match_ast, AstNode, SyntaxKind,\n+    match_ast, AstNode, Direction, SyntaxKind,\n };\n \n use crate::{\n@@ -15,14 +17,48 @@ use crate::{\n /// functions in a file have a `spam: &mut Spam` parameter, a completion with\n /// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n /// suggested.\n+///\n+/// Also complete parameters for closure or local functions from the surrounding defined locals.\n pub(crate) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let param_of_fn =\n-        matches!(ctx.pattern_ctx, Some(PatternContext { is_param: Some(ParamKind::Function), .. }));\n+    let (param_list, _, param_kind) = match &ctx.pattern_ctx {\n+        Some(PatternContext { param_ctx: Some(kind), .. }) => kind,\n+        _ => return None,\n+    };\n+\n+    let comma_wrapper = comma_wrapper(ctx);\n+    let mut add_new_item_to_acc = |label: &str, lookup: String| {\n+        let mk_item = |label: &str| {\n+            CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label)\n+        };\n+        let mut item = match &comma_wrapper {\n+            Some(fmt) => mk_item(&fmt(&label)),\n+            None => mk_item(label),\n+        };\n+        item.lookup_by(lookup);\n+        item.add_to(acc)\n+    };\n \n-    if !param_of_fn {\n-        return None;\n+    match param_kind {\n+        ParamKind::Function(function) => {\n+            fill_fn_params(ctx, function, &param_list, add_new_item_to_acc);\n+        }\n+        ParamKind::Closure(closure) => {\n+            let stmt_list = closure.syntax().ancestors().find_map(ast::StmtList::cast)?;\n+            params_from_stmt_list_scope(ctx, stmt_list, |name, ty| {\n+                add_new_item_to_acc(&format!(\"{name}: {ty}\"), name.to_string());\n+            });\n+        }\n     }\n \n+    Some(())\n+}\n+\n+fn fill_fn_params(\n+    ctx: &CompletionContext,\n+    function: &ast::Fn,\n+    param_list: &ast::ParamList,\n+    mut add_new_item_to_acc: impl FnMut(&str, String),\n+) {\n     let mut file_params = FxHashMap::default();\n \n     let mut extract_params = |f: ast::Fn| {\n@@ -56,23 +92,46 @@ pub(crate) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n         };\n     }\n \n-    let function = ctx.token.ancestors().find_map(ast::Fn::cast)?;\n-    let param_list = function.param_list()?;\n+    if let Some(stmt_list) = function.syntax().parent().and_then(ast::StmtList::cast) {\n+        params_from_stmt_list_scope(ctx, stmt_list, |name, ty| {\n+            file_params.entry(format!(\"{name}: {ty}\")).or_insert(name.to_string());\n+        });\n+    }\n \n     remove_duplicated(&mut file_params, param_list.params());\n-\n     let self_completion_items = [\"self\", \"&self\", \"mut self\", \"&mut self\"];\n     if should_add_self_completions(ctx, param_list) {\n-        self_completion_items.into_iter().for_each(|self_item| {\n-            add_new_item_to_acc(ctx, acc, self_item.to_string(), self_item.to_string())\n-        });\n+        self_completion_items\n+            .into_iter()\n+            .for_each(|self_item| add_new_item_to_acc(self_item, self_item.to_string()));\n     }\n \n-    file_params.into_iter().try_for_each(|(whole_param, binding)| {\n-        Some(add_new_item_to_acc(ctx, acc, surround_with_commas(ctx, whole_param), binding))\n-    })?;\n+    file_params\n+        .into_iter()\n+        .for_each(|(whole_param, binding)| add_new_item_to_acc(&whole_param, binding));\n+}\n \n-    Some(())\n+fn params_from_stmt_list_scope(\n+    ctx: &CompletionContext,\n+    stmt_list: ast::StmtList,\n+    mut cb: impl FnMut(hir::Name, String),\n+) {\n+    let syntax_node = match stmt_list.syntax().last_child() {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    let scope = ctx.sema.scope_at_offset(stmt_list.syntax(), syntax_node.text_range().end());\n+    let module = match scope.module() {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    scope.process_all_names(&mut |name, def| {\n+        if let hir::ScopeDef::Local(local) = def {\n+            if let Ok(ty) = local.ty(ctx.db).display_source_code(ctx.db, module.into()) {\n+                cb(name, ty);\n+            }\n+        }\n+    });\n }\n \n fn remove_duplicated(\n@@ -96,52 +155,32 @@ fn remove_duplicated(\n     })\n }\n \n-fn should_add_self_completions(ctx: &CompletionContext, param_list: ast::ParamList) -> bool {\n+fn should_add_self_completions(ctx: &CompletionContext, param_list: &ast::ParamList) -> bool {\n     let inside_impl = ctx.impl_def.is_some();\n     let no_params = param_list.params().next().is_none() && param_list.self_param().is_none();\n \n     inside_impl && no_params\n }\n \n-fn surround_with_commas(ctx: &CompletionContext, param: String) -> String {\n-    match fallible_surround_with_commas(ctx, &param) {\n-        Some(surrounded) => surrounded,\n-        // fallback to the original parameter\n-        None => param,\n-    }\n-}\n-\n-fn fallible_surround_with_commas(ctx: &CompletionContext, param: &str) -> Option<String> {\n-    let next_token = {\n+fn comma_wrapper(ctx: &CompletionContext) -> Option<impl Fn(&str) -> String> {\n+    let next_token_kind = {\n         let t = ctx.token.next_token()?;\n-        match t.kind() {\n-            SyntaxKind::WHITESPACE => t.next_token()?,\n-            _ => t,\n-        }\n+        let t = algo::skip_whitespace_token(t, Direction::Next)?;\n+        t.kind()\n     };\n-\n-    let trailing_comma_missing = matches!(next_token.kind(), SyntaxKind::IDENT);\n-    let trailing = if trailing_comma_missing { \",\" } else { \"\" };\n-\n-    let previous_token = if matches!(ctx.token.kind(), SyntaxKind::IDENT | SyntaxKind::WHITESPACE) {\n-        ctx.previous_token.as_ref()?\n-    } else {\n-        &ctx.token\n+    let prev_token_kind = {\n+        let t = ctx.previous_token.clone()?;\n+        let t = algo::skip_whitespace_token(t, Direction::Prev)?;\n+        t.kind()\n     };\n \n-    let needs_leading = !matches!(previous_token.kind(), SyntaxKind::L_PAREN | SyntaxKind::COMMA);\n-    let leading = if needs_leading { \", \" } else { \"\" };\n+    let has_trailing_comma =\n+        matches!(next_token_kind, SyntaxKind::COMMA | SyntaxKind::R_PAREN | SyntaxKind::PIPE);\n+    let trailing = if has_trailing_comma { \"\" } else { \",\" };\n \n-    Some(format!(\"{}{}{}\", leading, param, trailing))\n-}\n+    let has_leading_comma =\n+        matches!(prev_token_kind, SyntaxKind::COMMA | SyntaxKind::L_PAREN | SyntaxKind::PIPE);\n+    let leading = if has_leading_comma { \"\" } else { \", \" };\n \n-fn add_new_item_to_acc(\n-    ctx: &CompletionContext,\n-    acc: &mut Completions,\n-    label: String,\n-    lookup: String,\n-) {\n-    let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label);\n-    item.lookup_by(lookup);\n-    item.add_to(acc)\n+    Some(move |param: &_| format!(\"{}{}{}\", leading, param, trailing))\n }"}, {"sha": "59c16c08d6cec7ede97c183136e1ddb7fd00f750", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=6194092086045cb430e3391dc0bca0ac2368bdd2", "patch": "@@ -27,6 +27,8 @@ use crate::{\n     CompletionConfig,\n };\n \n+const COMPLETION_MARKER: &str = \"intellijRulezz\";\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum PatternRefutability {\n     Refutable,\n@@ -68,7 +70,7 @@ pub(crate) struct PathCompletionContext {\n #[derive(Debug)]\n pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n-    pub(super) is_param: Option<ParamKind>,\n+    pub(super) param_ctx: Option<(ast::ParamList, ast::Param, ParamKind)>,\n     pub(super) has_type_ascription: bool,\n }\n \n@@ -80,10 +82,10 @@ pub(super) enum LifetimeContext {\n     LabelDef,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ParamKind {\n-    Function,\n-    Closure,\n+    Function(ast::Fn),\n+    Closure(ast::ClosureExpr),\n }\n \n /// `CompletionContext` is created early during completion to figure out, where\n@@ -382,15 +384,15 @@ impl<'a> CompletionContext<'a> {\n         // actual completion.\n         let file_with_fake_ident = {\n             let parse = db.parse(file_id);\n-            let edit = Indel::insert(offset, \"intellijRulezz\".to_string());\n+            let edit = Indel::insert(offset, COMPLETION_MARKER.to_string());\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token =\n             file_with_fake_ident.syntax().token_at_offset(offset).right_biased()?;\n \n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token, offset);\n+        let scope = sema.scope_at_offset(&token.parent()?, offset);\n         let krate = scope.krate();\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n@@ -723,7 +725,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n             ast::NameLike::Name(name) => {\n-                self.pattern_ctx = Self::classify_name(&self.sema, name);\n+                self.pattern_ctx = Self::classify_name(&self.sema, original_file, name);\n             }\n         }\n     }\n@@ -750,7 +752,11 @@ impl<'a> CompletionContext<'a> {\n         })\n     }\n \n-    fn classify_name(_sema: &Semantics<RootDatabase>, name: ast::Name) -> Option<PatternContext> {\n+    fn classify_name(\n+        _sema: &Semantics<RootDatabase>,\n+        original_file: &SyntaxNode,\n+        name: ast::Name,\n+    ) -> Option<PatternContext> {\n         let bind_pat = name.syntax().parent().and_then(ast::IdentPat::cast)?;\n         let is_name_in_field_pat = bind_pat\n             .syntax()\n@@ -763,7 +769,7 @@ impl<'a> CompletionContext<'a> {\n         if !bind_pat.is_simple_ident() {\n             return None;\n         }\n-        Some(pattern_context_for(bind_pat.into()))\n+        Some(pattern_context_for(original_file, bind_pat.into()))\n     }\n \n     fn classify_name_ref(\n@@ -799,15 +805,15 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::RecordPat(it) => {\n-                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::PathPat(it) => {\n-                        pat_ctx = Some(pattern_context_for(it.into()));\n+                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => it.excl_token().and(Some(PathKind::Mac)),\n@@ -824,12 +830,7 @@ impl<'a> CompletionContext<'a> {\n             path_ctx.use_tree_parent = use_tree_parent;\n             path_ctx.qualifier = path\n                 .segment()\n-                .and_then(|it| {\n-                    find_node_with_range::<ast::PathSegment>(\n-                        original_file,\n-                        it.syntax().text_range(),\n-                    )\n-                })\n+                .and_then(|it| find_node_in_file(original_file, &it))\n                 .map(|it| it.parent_path());\n             return Some((path_ctx, pat_ctx));\n         }\n@@ -864,7 +865,7 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn pattern_context_for(pat: ast::Pat) -> PatternContext {\n+fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternContext {\n     let mut is_param = None;\n     let (refutability, has_type_ascription) =\n     pat\n@@ -877,18 +878,21 @@ fn pattern_context_for(pat: ast::Pat) -> PatternContext {\n                 match node {\n                     ast::LetStmt(let_) => return (PatternRefutability::Irrefutable, let_.ty().is_some()),\n                     ast::Param(param) => {\n-                        let is_closure_param = param\n-                            .syntax()\n-                            .ancestors()\n-                            .nth(2)\n-                            .and_then(ast::ClosureExpr::cast)\n-                            .is_some();\n-                        is_param = Some(if is_closure_param {\n-                            ParamKind::Closure\n-                        } else {\n-                            ParamKind::Function\n-                        });\n-                        return (PatternRefutability::Irrefutable, param.ty().is_some())\n+                        let has_type_ascription = param.ty().is_some();\n+                        is_param = (|| {\n+                            let fake_param_list = param.syntax().parent().and_then(ast::ParamList::cast)?;\n+                            let param_list = find_node_in_file_compensated(original_file, &fake_param_list)?;\n+                            let param_list_owner = param_list.syntax().parent()?;\n+                            let kind = match_ast! {\n+                                match param_list_owner {\n+                                    ast::ClosureExpr(closure) => ParamKind::Closure(closure),\n+                                    ast::Fn(fn_) => ParamKind::Function(fn_),\n+                                    _ => return None,\n+                                }\n+                            };\n+                            Some((param_list, param, kind))\n+                        })();\n+                        return (PatternRefutability::Irrefutable, has_type_ascription)\n                     },\n                     ast::MatchArm(_) => PatternRefutability::Refutable,\n                     ast::Condition(_) => PatternRefutability::Refutable,\n@@ -898,11 +902,29 @@ fn pattern_context_for(pat: ast::Pat) -> PatternContext {\n             };\n             (refutability, false)\n         });\n-    PatternContext { refutability, is_param, has_type_ascription }\n+    PatternContext { refutability, param_ctx: is_param, has_type_ascription }\n+}\n+\n+fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n+    let syntax_range = syntax.text_range();\n+    let range = node.syntax().text_range();\n+    let intersection = range.intersect(syntax_range)?;\n+    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n }\n \n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n-    syntax.covering_element(range).ancestors().find_map(N::cast)\n+/// Compensates for the offset introduced by the fake ident\n+/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n+fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n+    let syntax_range = syntax.text_range();\n+    let range = node.syntax().text_range();\n+    let end = range.end().checked_sub(TextSize::try_from(COMPLETION_MARKER.len()).ok()?)?;\n+    if end < range.start() {\n+        return None;\n+    }\n+    let range = TextRange::new(range.start(), end);\n+    // our inserted ident could cause `range` to be go outside of the original syntax, so cap it\n+    let intersection = range.intersect(syntax_range)?;\n+    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n }\n \n fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {"}, {"sha": "e486d9f2b91e497570ae14b808866df63156d012", "filename": "crates/ide_completion/src/render/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fpattern.rs?ref=6194092086045cb430e3391dc0bca0ac2368bdd2", "patch": "@@ -87,7 +87,7 @@ fn render_pat(\n     if matches!(\n         ctx.completion.pattern_ctx,\n         Some(PatternContext {\n-            is_param: Some(ParamKind::Function),\n+            param_ctx: Some((.., ParamKind::Function(_))),\n             has_type_ascription: false,\n             ..\n         })"}, {"sha": "662fbe309bcfe06942ae5380842c8aa6844df990", "filename": "crates/ide_completion/src/tests/fn_param.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6194092086045cb430e3391dc0bca0ac2368bdd2/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs?ref=6194092086045cb430e3391dc0bca0ac2368bdd2", "patch": "@@ -156,3 +156,53 @@ impl A {\n         \"#]],\n     )\n }\n+\n+// doesn't complete qux due to there being no expression after\n+// see source_analyzer::adjust comment\n+#[test]\n+fn local_fn_shows_locals_for_params() {\n+    check(\n+        r#\"\n+fn outer() {\n+    let foo = 3;\n+    {\n+        let bar = 3;\n+        fn inner($0) {}\n+        let baz = 3;\n+        let qux = 3;\n+    }\n+    let fez = 3;\n+}\n+\"#,\n+        expect![[r#\"\n+            bn foo: i32\n+            bn baz: i32\n+            bn bar: i32\n+            kw mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn closure_shows_locals_for_params() {\n+    check(\n+        r#\"\n+fn outer() {\n+    let foo = 3;\n+    {\n+        let bar = 3;\n+        |$0| {};\n+        let baz = 3;\n+        let qux = 3;\n+    }\n+    let fez = 3;\n+}\n+\"#,\n+        expect![[r#\"\n+            bn baz: i32\n+            bn bar: i32\n+            bn foo: i32\n+            kw mut\n+        \"#]],\n+    )\n+}"}]}