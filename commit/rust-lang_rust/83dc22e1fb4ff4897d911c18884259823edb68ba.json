{"sha": "83dc22e1fb4ff4897d911c18884259823edb68ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZGMyMmUxZmI0ZmY0ODk3ZDkxMWMxODg4NDI1OTgyM2VkYjY4YmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-05T12:44:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-05T12:44:00Z"}, "message": "Merge #3019\n\n3019: Better cursor placement when merging arms r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8b93c76fb362f5ebfba308edfcb9d682a3610977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b93c76fb362f5ebfba308edfcb9d682a3610977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83dc22e1fb4ff4897d911c18884259823edb68ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeOriQCRBK7hj4Ov3rIwAAdHIIAHCaVHh+3PTPjpAcwe6zyiLG\nD4xM80OBpGeVInXwUIqFwS7Yzd2lzABQF8YeIFSeHnJdMa/R0b56bMjGTGK4kOM+\nx1o58OiILAs+A2w03Wy4fVo48GoRrrgdWjRlg161uWY/qwUnFXf3/kRgvBxLr69A\nRnCINIkf2f1pk9ibGEC7m7sxzpuI6jOk//UaPxjmvwfn24cGtw46tBt4APRA4Puq\n0cMnB5KttRcYsTywNt26PijWUAkKKJuhkTXVvu6qbiXE1TBFJ9xUnHyB6PDNgBe9\nZNzt15+rKvA1oXhrMbuzntGebmBdUwxIcTtg+F4vo+GyFkkXloeo2LN5nzJ2k6w=\n=xfBt\n-----END PGP SIGNATURE-----\n", "payload": "tree 8b93c76fb362f5ebfba308edfcb9d682a3610977\nparent 1b1bca4567ec6228835720a3dbadf4fa22703d87\nparent f756d5da063461c99c20266dc4896d8388fe28b9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1580906640 +0000\ncommitter GitHub <noreply@github.com> 1580906640 +0000\n\nMerge #3019\n\n3019: Better cursor placement when merging arms r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83dc22e1fb4ff4897d911c18884259823edb68ba", "html_url": "https://github.com/rust-lang/rust/commit/83dc22e1fb4ff4897d911c18884259823edb68ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83dc22e1fb4ff4897d911c18884259823edb68ba/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b1bca4567ec6228835720a3dbadf4fa22703d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1bca4567ec6228835720a3dbadf4fa22703d87", "html_url": "https://github.com/rust-lang/rust/commit/1b1bca4567ec6228835720a3dbadf4fa22703d87"}, {"sha": "f756d5da063461c99c20266dc4896d8388fe28b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f756d5da063461c99c20266dc4896d8388fe28b9", "html_url": "https://github.com/rust-lang/rust/commit/f756d5da063461c99c20266dc4896d8388fe28b9"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "64c9379da18c16289e693bd0b8a3ab8096de06d0", "filename": "crates/ra_assists/src/assists/merge_match_arms.rs", "status": "modified", "additions": 91, "deletions": 36, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/83dc22e1fb4ff4897d911c18884259823edb68ba/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83dc22e1fb4ff4897d911c18884259823edb68ba/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmerge_match_arms.rs?ref=83dc22e1fb4ff4897d911c18884259823edb68ba", "patch": "@@ -1,6 +1,12 @@\n-use crate::{Assist, AssistCtx, AssistId, TextRange, TextUnit};\n+use std::iter::successors;\n+\n use hir::db::HirDatabase;\n-use ra_syntax::ast::{AstNode, MatchArm};\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Direction, TextUnit,\n+};\n+\n+use crate::{Assist, AssistCtx, AssistId, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -27,62 +33,80 @@ use ra_syntax::ast::{AstNode, MatchArm};\n // }\n // ```\n pub(crate) fn merge_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let current_arm = ctx.find_node_at_offset::<MatchArm>()?;\n-\n-    // We check if the following match arm matches this one. We could, but don't,\n-    // compare to the previous match arm as well.\n-    let next = current_arm.syntax().next_sibling();\n-    let next_arm = MatchArm::cast(next?)?;\n-\n+    let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n-    if current_arm.guard().is_some() || next_arm.guard().is_some() {\n+    if current_arm.guard().is_some() {\n         return None;\n     }\n-\n     let current_expr = current_arm.expr()?;\n-    let next_expr = next_arm.expr()?;\n+    let current_text_range = current_arm.syntax().text_range();\n \n-    // Check for match arm equality by comparing lengths and then string contents\n-    if current_expr.syntax().text_range().len() != next_expr.syntax().text_range().len() {\n-        return None;\n+    enum CursorPos {\n+        InExpr(TextUnit),\n+        InPat(TextUnit),\n     }\n-    if current_expr.syntax().text() != next_expr.syntax().text() {\n+    let cursor_pos = ctx.frange.range.start();\n+    let cursor_pos = if current_expr.syntax().text_range().contains(cursor_pos) {\n+        CursorPos::InExpr(current_text_range.end() - cursor_pos)\n+    } else {\n+        CursorPos::InPat(cursor_pos)\n+    };\n+\n+    // We check if the following match arms match this one. We could, but don't,\n+    // compare to the previous match arm as well.\n+    let arms_to_merge = successors(Some(current_arm), next_arm)\n+        .take_while(|arm| {\n+            if arm.guard().is_some() {\n+                return false;\n+            }\n+            match arm.expr() {\n+                Some(expr) => expr.syntax().text() == current_expr.syntax().text(),\n+                None => false,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n+    if arms_to_merge.len() <= 1 {\n         return None;\n     }\n \n-    let cursor_to_end = current_arm.syntax().text_range().end() - ctx.frange.range.start();\n-\n     ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", |edit| {\n-        fn contains_placeholder(a: &MatchArm) -> bool {\n-            a.pats().any(|x| match x {\n-                ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n-                _ => false,\n-            })\n-        }\n-\n-        let pats = if contains_placeholder(&current_arm) || contains_placeholder(&next_arm) {\n+        let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {\n-            let ps: Vec<String> = current_arm\n-                .pats()\n+            arms_to_merge\n+                .iter()\n+                .flat_map(ast::MatchArm::pats)\n                 .map(|x| x.syntax().to_string())\n-                .chain(next_arm.pats().map(|x| x.syntax().to_string()))\n-                .collect();\n-            ps.join(\" | \")\n+                .collect::<Vec<String>>()\n+                .join(\" | \")\n         };\n \n         let arm = format!(\"{} => {}\", pats, current_expr.syntax().text());\n-        let offset = TextUnit::from_usize(arm.len()) - cursor_to_end;\n \n-        let start = current_arm.syntax().text_range().start();\n-        let end = next_arm.syntax().text_range().end();\n+        let start = arms_to_merge.first().unwrap().syntax().text_range().start();\n+        let end = arms_to_merge.last().unwrap().syntax().text_range().end();\n \n-        edit.target(current_arm.syntax().text_range());\n+        edit.target(current_text_range);\n+        edit.set_cursor(match cursor_pos {\n+            CursorPos::InExpr(back_offset) => start + TextUnit::from_usize(arm.len()) - back_offset,\n+            CursorPos::InPat(offset) => offset,\n+        });\n         edit.replace(TextRange::from_to(start, end), arm);\n-        edit.set_cursor(start + offset);\n     })\n }\n \n+fn contains_placeholder(a: &ast::MatchArm) -> bool {\n+    a.pats().any(|x| match x {\n+        ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n+        _ => false,\n+    })\n+}\n+\n+fn next_arm(arm: &ast::MatchArm) -> Option<ast::MatchArm> {\n+    arm.syntax().siblings(Direction::Next).skip(1).find_map(ast::MatchArm::cast)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::merge_match_arms;\n@@ -184,6 +208,37 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn merges_all_subsequent_arms() {\n+        check_assist(\n+            merge_match_arms,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A<|> => 92,\n+                    X::B => 92,\n+                    X::C => 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum X { A, B, C, D, E }\n+\n+            fn main() {\n+                match X::A {\n+                    X::A<|> | X::B | X::C => 92,\n+                    X::D => 62,\n+                    _ => panic!(),\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn merge_match_arms_rejects_guards() {\n         check_assist_not_applicable("}]}