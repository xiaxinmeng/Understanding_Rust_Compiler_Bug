{"sha": "33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYjE2NzZiZGFiNmMwYThjMzZjNTdjMGY0ZGMzYzk1ODZiNGY5MGI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-06T09:29:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-06T09:29:14Z"}, "message": "Merge pull request #75 from oli-obk/master\n\nimplement more drop stuff", "tree": {"sha": "4ba00773c917c7bd6a1fca1942827faf8e6113b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ba00773c917c7bd6a1fca1942827faf8e6113b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "html_url": "https://github.com/rust-lang/rust/commit/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea7db1426ea10704345182027d282527fc4830af", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7db1426ea10704345182027d282527fc4830af", "html_url": "https://github.com/rust-lang/rust/commit/ea7db1426ea10704345182027d282527fc4830af"}, {"sha": "9c85e203c56949a887035ab66e6da5d34dea1c82", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c85e203c56949a887035ab66e6da5d34dea1c82", "html_url": "https://github.com/rust-lang/rust/commit/9c85e203c56949a887035ab66e6da5d34dea1c82"}], "stats": {"total": 438, "additions": 396, "deletions": 42}, "files": [{"sha": "689ef9245363e051f1587c845c030631c9684785", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -285,11 +285,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn monomorphize_field_ty(&self, f: ty::FieldDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        let substituted = &f.ty(self.tcx, substs);\n-        self.tcx.normalize_associated_type(&substituted)\n-    }\n-\n     pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         let substituted = ty.subst(self.tcx, substs);\n         self.tcx.normalize_associated_type(&substituted)\n@@ -1120,13 +1115,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    /// ensures this Value is not a ByRef\n+    fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(ptr) => match self.read_value(ptr, ty)? {\n-                Value::ByRef(_) => bug!(\"read_value can't result in `ByRef`\"),\n-                Value::ByVal(primval) => Ok(primval),\n-                Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n-            },\n+            Value::ByRef(ptr) => self.read_value(ptr, ty),\n+            other => Ok(other),\n+        }\n+    }\n+\n+    fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        match self.follow_by_ref_value(value, ty)? {\n+            Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n             Value::ByVal(primval) => {\n                 let new_primval = self.transmute_primval(primval, ty)?;\n@@ -1511,8 +1510,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n-                    let src_fty = self.monomorphize_field_ty(src_f, substs_a);\n-                    let dst_fty = self.monomorphize_field_ty(dst_f, substs_b);\n+                    let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n+                    let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n                     if self.type_size(dst_fty) == 0 {\n                         continue;\n                     }\n@@ -1729,3 +1728,9 @@ impl IntegerExt for layout::Integer {\n         }\n     }\n }\n+\n+\n+pub fn monomorphize_field_ty<'a, 'tcx:'a >(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: ty::FieldDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    let substituted = &f.ty(tcx, substs);\n+    tcx.normalize_associated_type(&substituted)\n+}"}, {"sha": "9161f6e35b4e1d8c4f2abd44217a5eab1a540348", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -18,6 +18,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n+        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx, ()> {\n         let arg_vals: EvalResult<Vec<Value>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n@@ -123,10 +124,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"drop_in_place\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr_ty = self.tcx.mk_mut_ptr(ty);\n+                let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n+                    Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n+                    Value::ByVal(ptr) => Lvalue::from_ptr(ptr.expect_ptr(\"drop_in_place first arg not a pointer\")),\n+                    Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n+                        ptr: ptr.expect_ptr(\"drop_in_place first arg not a pointer\"),\n+                        extra: match extra.try_as_ptr() {\n+                            Some(vtable) => LvalueExtra::Vtable(vtable),\n+                            None => LvalueExtra::Length(extra.expect_uint(\"either pointer or not, but not neither\")),\n+                        },\n+                    },\n+                };\n                 let mut drops = Vec::new();\n-                self.drop(Lvalue::from_ptr(ptr), ty, &mut drops)?;\n-                self.eval_drop_impls(drops)?;\n+                self.drop(lvalue, ty, &mut drops)?;\n+                // need to change the block before pushing the drop impl stack frames\n+                // we could do this for all intrinsics before evaluating the intrinsics, but if\n+                // the evaluation fails, we should not have moved forward\n+                self.goto_block(target);\n+                return self.eval_drop_impls(drops);\n             }\n \n             \"fabsf32\" => {\n@@ -330,6 +346,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n \n+        self.goto_block(target);\n+\n         // Since we pushed no stack frame, the main loop will act\n         // as if the call just completed and it's returning to the\n         // current frame."}, {"sha": "f99a23a22ae6ae0cce3ba325ada6ea2553d65d5b", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 147, "deletions": 23, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -3,7 +3,7 @@ use rustc::mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use std::rc::Rc;\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -12,7 +12,7 @@ use syntax::{ast, attr};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n use primval::PrimVal;\n-use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup};\n+use super::{EvalContext, Lvalue, IntegerExt, StackPopCleanup, LvalueExtra, monomorphize_field_ty};\n use super::value::Value;\n \n mod intrinsics;\n@@ -146,9 +146,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Pointer, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n+    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n         let span = self.frame().span;\n-        for (drop_def_id, adt_ptr, substs) in drops {\n+        // add them to the stack in reverse order, because the impl that needs to run the last\n+        // is the one that needs to be at the bottom of the stack\n+        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n             // FIXME: supply a real span\n             let mir = self.load_mir(drop_def_id)?;\n             trace!(\"substs for drop glue: {:?}\", substs);\n@@ -165,7 +167,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n             let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n             let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(Value::ByVal(PrimVal::from_ptr(adt_ptr)), dest, ty)?;\n+            self.write_value(self_arg, dest, ty)?;\n         }\n         Ok(())\n     }\n@@ -185,8 +187,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout)?;\n-                self.goto_block(target);\n+                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n                 Ok(())\n             }\n \n@@ -518,7 +519,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         lval: Lvalue<'tcx>,\n         ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Pointer, &'tcx Substs<'tcx>)>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n     ) -> EvalResult<'tcx, ()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n@@ -530,18 +531,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // special case `Box` to deallocate the inner allocation\n             ty::TyBox(contents_ty) => {\n                 let val = self.read_lvalue(lval)?;\n-                let contents_ptr = val.read_ptr(&self.memory)?;\n-                self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                trace!(\"-deallocating box\");\n-                self.memory.deallocate(contents_ptr)?;\n+                // we are going through the read_value path, because that already does all the\n+                // checks for the trait object types. We'd only be repeating ourselves here.\n+                let val = self.follow_by_ref_value(val, ty)?;\n+                trace!(\"box dealloc on {:?}\", val);\n+                match val {\n+                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n+                    Value::ByVal(ptr) => {\n+                        assert!(self.type_is_sized(contents_ty));\n+                        let contents_ptr = ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n+                    },\n+                    Value::ByValPair(prim_ptr, extra) => {\n+                        let ptr = prim_ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        let extra = match extra.try_as_ptr() {\n+                            Some(vtable) => LvalueExtra::Vtable(vtable),\n+                            None => LvalueExtra::Length(extra.expect_uint(\"slice length\")),\n+                        };\n+                        self.drop(\n+                            Lvalue::Ptr {\n+                                ptr: ptr,\n+                                extra: extra,\n+                            },\n+                            contents_ty,\n+                            drop,\n+                        )?;\n+                    },\n+                }\n+                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n+                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n+                // this is somewhat hacky, but hey, there's no representation difference between\n+                // pointers and references, so\n+                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n+                // is the same as\n+                // fn drop(&mut self) if Self is Box<T>\n+                drop.push((box_free_fn, val, substs));\n             },\n \n             ty::TyAdt(adt_def, substs) => {\n                 // FIXME: some structs are represented as ByValPair\n-                let adt_ptr = self.force_allocation(lval)?.to_ptr();\n+                let lval = self.force_allocation(lval)?;\n+                let adt_ptr = match lval {\n+                    Lvalue::Ptr { ptr, .. } => ptr,\n+                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n+                };\n                 // run drop impl before the fields' drop impls\n                 if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, adt_ptr, substs));\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::from_ptr(adt_ptr)), substs));\n                 }\n                 let layout = self.type_layout(ty);\n                 let fields = match *layout {\n@@ -565,27 +601,115 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n                         }\n                     },\n+                    Layout::RawNullablePointer { nndiscr, .. } => {\n+                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n+                        if discr == nndiscr {\n+                            assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n+                            let field_ty = &adt_def.variants[discr as usize].fields[0];\n+                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n+                            // FIXME: once read_discriminant_value works with lvalue, don't force\n+                            // alloc in the RawNullablePointer case\n+                            self.drop(lval, field_ty, drop)?;\n+                            return Ok(());\n+                        } else {\n+                            // FIXME: the zst variant might contain zst types that impl Drop\n+                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n+                        }\n+                    },\n                     _ => bug!(\"{:?} is not an adt layout\", layout),\n                 };\n-                for (field_ty, offset) in fields {\n-                    let field_ty = self.monomorphize_field_ty(field_ty, substs);\n-                    self.drop(Lvalue::from_ptr(adt_ptr.offset(offset.bytes() as isize)), field_ty, drop)?;\n-                }\n+                let tcx = self.tcx;\n+                self.drop_fields(\n+                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    lval,\n+                    drop,\n+                )?;\n             },\n             ty::TyTuple(fields) => {\n-                // FIXME: some tuples are represented as ByValPair\n-                let ptr = self.force_allocation(lval)?.to_ptr();\n-                for (i, field_ty) in fields.iter().enumerate() {\n-                    let offset = self.get_field_offset(ty, i)?.bytes() as isize;\n-                    self.drop(Lvalue::from_ptr(ptr.offset(offset)), field_ty, drop)?;\n+                let offsets = match *self.type_layout(ty) {\n+                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n+                    _ => bug!(\"tuples must be univariant\"),\n+                };\n+                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n+            },\n+            ty::TyTrait(_) => {\n+                let (ptr, vtable) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n+                    _ => bug!(\"expected an lvalue with a vtable\"),\n+                };\n+                let drop_fn = self.memory.read_ptr(vtable)?;\n+                // some values don't need to call a drop impl, so the value is null\n+                if !drop_fn.points_to_zst() {\n+                    let (def_id, substs, ty) = self.memory.get_fn(drop_fn.alloc_id)?;\n+                    let fn_sig = self.tcx.erase_late_bound_regions_and_normalize(&ty.sig);\n+                    let real_ty = fn_sig.inputs[0];\n+                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n+                    drop.push((def_id, Value::ByVal(PrimVal::from_ptr(ptr)), substs));\n+                } else {\n+                    // just a sanity check\n+                    assert_eq!(drop_fn.offset, 0);\n+                }\n+            },\n+            ty::TySlice(elem_ty) => {\n+                let (ptr, len) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n+                    _ => bug!(\"expected an lvalue with a length\"),\n+                };\n+                let size = self.type_size(elem_ty) as isize;\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..len {\n+                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n                 }\n             },\n+            ty::TyArray(elem_ty, len) => {\n+                let lval = self.force_allocation(lval)?;\n+                let (ptr, extra) = match lval {\n+                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+                    _ => bug!(\"expected an lvalue with optional extra data\"),\n+                };\n+                let size = self.type_size(elem_ty) as isize;\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..len {\n+                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i as isize * size), extra: extra }, elem_ty, drop)?;\n+                }\n+            },\n+            // FIXME: what about TyClosure and TyAnon?\n             // other types do not need to process drop\n             _ => {},\n         }\n \n         Ok(())\n     }\n+\n+    fn drop_fields<\n+        I: Iterator<Item=(Ty<'tcx>, ty::layout::Size)>,\n+    >(\n+        &mut self,\n+        mut fields: I,\n+        lval: Lvalue<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx, ()> {\n+        // FIXME: some aggregates may be represented by Value::ByValPair\n+        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n+        // manual iteration, because we need to be careful about the last field if it is unsized\n+        while let Some((field_ty, offset)) = fields.next() {\n+            let ptr = adt_ptr.offset(offset.bytes() as isize);\n+            if self.type_is_sized(field_ty) {\n+                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n+            } else {\n+                let lvalue = Lvalue::Ptr {\n+                    ptr: ptr,\n+                    extra: extra,\n+                };\n+                self.drop(lvalue, field_ty, drop)?;\n+                break; // if it is not sized, then this is the last field anyway\n+            }\n+        }\n+        assert!(fields.next().is_none());\n+        Ok(())\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "17f2c6b7020ce43e7aebe2758973d282dffa23de", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -84,8 +84,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let ptr_size = self.memory.pointer_size();\n         let vtable = self.memory.allocate(ptr_size * (3 + methods.len()), ptr_size)?;\n \n-        // FIXME: generate a destructor for the vtable.\n-        // trans does this with glue::get_drop_glue(ccx, trait_ref.self_ty())\n+        // in case there is no drop function to be called, this still needs to be initialized\n+        self.memory.write_usize(vtable, 0)?;\n+        if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n+            if let Some(drop_def_id) = adt_def.destructor() {\n+                let ty_scheme = self.tcx.lookup_item_type(drop_def_id);\n+                let fn_ty = match ty_scheme.ty.sty {\n+                    ty::TyFnDef(_, _, fn_ty) => fn_ty,\n+                    _ => bug!(\"drop method is not a TyFnDef\"),\n+                };\n+                let fn_ptr = self.memory.create_fn_ptr(drop_def_id, substs, fn_ty);\n+                self.memory.write_ptr(vtable, fn_ptr)?;\n+            }\n+        }\n \n         self.memory.write_usize(vtable.offset(ptr_size as isize), size as u64)?;\n         self.memory.write_usize(vtable.offset((ptr_size * 2) as isize), align as u64)?;"}, {"sha": "2d8b50076234f46bc142d9e8747f68c8e5ee17aa", "filename": "src/primval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -289,7 +289,7 @@ pub fn binary_op<'tcx>(\n         }\n \n         (None, None) => {}\n-        _ => unimplemented!(),\n+        _ => return Err(EvalError::ReadPointerAsBytes),\n     }\n \n     let (l, r) = (left.bits, right.bits);"}, {"sha": "dc93965b7e552520781c15ed87586381103a96a8", "filename": "tests/compile-fail/tag-align-dyn-u64.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Fcompile-fail%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Fcompile-fail%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftag-align-dyn-u64.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+use std::mem;\n+\n+enum Tag<A> {\n+    Tag2(A)\n+}\n+\n+struct Rec {\n+    c8: u8,\n+    t: Tag<u64>\n+}\n+\n+fn mk_rec() -> Rec {\n+    return Rec { c8:0, t:Tag::Tag2(0) };\n+}\n+\n+fn is_u64_aligned(u: &Tag<u64>) -> bool {\n+    let p: usize = unsafe { mem::transmute(u) };\n+    let u64_align = std::mem::align_of::<u64>();\n+    return (p & (u64_align - 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+}\n+\n+pub fn main() {\n+    let x = mk_rec();\n+    assert!(is_u64_aligned(&x.t));\n+}"}, {"sha": "80dd63de5e9a5aa35e96789bdb293443c4ba5017", "filename": "tests/run-pass/call_drop_on_array_elements.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,16 @@\n+struct Bar;\n+\n+static mut DROP_COUNT: usize = 0;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_COUNT += 1; }\n+    }\n+}\n+\n+fn main() {\n+    let b = [Bar, Bar, Bar, Bar];\n+    assert_eq!(unsafe { DROP_COUNT }, 0);\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n+}"}, {"sha": "a1ab5c45e358c84b60cdf043f3b8f151cc9b2e69", "filename": "tests/run-pass/call_drop_on_fat_ptr_array_elements.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,20 @@\n+trait Foo {}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+\n+static mut DROP_COUNT: usize = 0;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_COUNT += 1; }\n+    }\n+}\n+\n+fn main() {\n+    let b: [Box<Foo>; 4] = [Box::new(Bar), Box::new(Bar), Box::new(Bar), Box::new(Bar)];\n+    assert_eq!(unsafe { DROP_COUNT }, 0);\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n+}"}, {"sha": "3ec6be65ed8b6f8bc8bb35d560a42ef3c2f0dfb5", "filename": "tests/run-pass/call_drop_through_owned_slice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,16 @@\n+struct Bar;\n+\n+static mut DROP_COUNT: usize = 0;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_COUNT += 1; }\n+    }\n+}\n+\n+fn main() {\n+    let b: Box<[Bar]> = vec![Bar, Bar, Bar, Bar].into_boxed_slice();\n+    assert_eq!(unsafe { DROP_COUNT }, 0);\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n+}"}, {"sha": "9b6acf0b14746567e2d8aca45c6ae07a4720ec97", "filename": "tests/run-pass/call_drop_through_trait_object.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,20 @@\n+trait Foo {}\n+\n+struct Bar;\n+\n+static mut DROP_CALLED: bool = false;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_CALLED = true; }\n+    }\n+}\n+\n+impl Foo for Bar {}\n+\n+fn main() {\n+    let b: Box<Foo> = Box::new(Bar);\n+    assert!(unsafe { !DROP_CALLED });\n+    drop(b);\n+    assert!(unsafe { DROP_CALLED });\n+}"}, {"sha": "ce56ca6a1cafdd5d589f76e6e7ee12b16a106327", "filename": "tests/run-pass/call_drop_through_trait_object_rc.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,22 @@\n+trait Foo {}\n+\n+struct Bar;\n+\n+static mut DROP_CALLED: bool = false;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_CALLED = true; }\n+    }\n+}\n+\n+impl Foo for Bar {}\n+\n+use std::rc::Rc;\n+\n+fn main() {\n+    let b: Rc<Foo> = Rc::new(Bar);\n+    assert!(unsafe { !DROP_CALLED });\n+    drop(b);\n+    assert!(unsafe { DROP_CALLED });\n+}"}, {"sha": "d44c83763b7c448875c91a2e7ac37a2c0eddb1e6", "filename": "tests/run-pass/move-arg-2-unique.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-2-unique.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_features, unused_variables)]\n+#![feature(box_syntax)]\n+\n+fn test(foo: Box<Vec<isize>> ) { assert_eq!((*foo)[0], 10); }\n+\n+pub fn main() {\n+    let x = box vec![10];\n+    // Test forgetting a local by move-in\n+    test(x);\n+}"}, {"sha": "1aef95d8a3f30b4d5917ec80a574f360ac713440", "filename": "tests/run-pass/regions-lifetime-nonfree-late-bound.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs?ref=33b1676bdab6c0a8c36c57c0f4dc3c9586b4f90b", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a regression test for the ICE from issue #10846.\n+//\n+// The original issue causing the ICE: the LUB-computations during\n+// type inference were encountering late-bound lifetimes, and\n+// asserting that such lifetimes should have already been substituted\n+// with a concrete lifetime.\n+//\n+// However, those encounters were occurring within the lexical scope\n+// of the binding for the late-bound lifetime; that is, the late-bound\n+// lifetimes were perfectly valid.  The core problem was that the type\n+// folding code was over-zealously passing back all lifetimes when\n+// doing region-folding, when really all clients of the region-folding\n+// case only want to see FREE lifetime variables, not bound ones.\n+\n+// pretty-expanded FIXME #23616\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    fn explicit() {\n+        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<for<'a> FnMut(&'a isize)>) {}\n+        test(Some(box |_f: Box<for<'a> FnMut(&'a isize)>| {}));\n+    }\n+\n+    // The code below is shorthand for the code above (and more likely\n+    // to represent what one encounters in practice).\n+    fn implicit() {\n+        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<        FnMut(&   isize)>) {}\n+        test(Some(box |_f: Box<        FnMut(&   isize)>| {}));\n+    }\n+\n+    explicit();\n+    implicit();\n+}"}]}