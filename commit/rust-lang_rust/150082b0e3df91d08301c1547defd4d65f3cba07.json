{"sha": "150082b0e3df91d08301c1547defd4d65f3cba07", "node_id": "C_kwDOAAsO6NoAKDE1MDA4MmIwZTNkZjkxZDA4MzAxYzE1NDdkZWZkNGQ2NWYzY2JhMDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T11:45:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T11:45:42Z"}, "message": "Auto merge of #14878 - lowr:feat/metavar-expr-count, r=Veykril\n\nImplement `${count()}` metavariable expression\n\nThis PR implements `${count()}` metavariable expression for MBE as described in [RFC 3086][rfc]. See [this section][sec-count] of the RFC for its semantics.\n\nAdditionally, this PR changes the type of depth parameter of `${index()}` from u32 to usize so as to match how [rustc parses it][index-usize].\n\nPart of #11952\nFixes #14871\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/3086\n[sec-count]: https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md#count\n[index-usize]:https://github.com/rust-lang/rust/blob/ddad0576caf8d0515ed453e04b468977c7d3dfc1/compiler/rustc_expand/src/mbe/metavar_expr.rs#L22", "tree": {"sha": "0677369a5a8fae58cf8ba0acb7f91018145ca11d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0677369a5a8fae58cf8ba0acb7f91018145ca11d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/150082b0e3df91d08301c1547defd4d65f3cba07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/150082b0e3df91d08301c1547defd4d65f3cba07", "html_url": "https://github.com/rust-lang/rust/commit/150082b0e3df91d08301c1547defd4d65f3cba07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/150082b0e3df91d08301c1547defd4d65f3cba07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e3a87bf9478574f8c64ac2efec125bc19b1c64", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e3a87bf9478574f8c64ac2efec125bc19b1c64", "html_url": "https://github.com/rust-lang/rust/commit/f6e3a87bf9478574f8c64ac2efec125bc19b1c64"}, {"sha": "0d4d1d7e3b820c241e8197926b62830b9d2d3b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d4d1d7e3b820c241e8197926b62830b9d2d3b24", "html_url": "https://github.com/rust-lang/rust/commit/0d4d1d7e3b820c241e8197926b62830b9d2d3b24"}], "stats": {"total": 596, "additions": 481, "deletions": 115}, "files": [{"sha": "553ffe3d0b88bfdea40fb21eaf4d96aa6cc225c1", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -4,6 +4,7 @@\n mod tt_conversion;\n mod matching;\n mod meta_syntax;\n+mod metavar_expr;\n mod regression;\n \n use expect_test::expect;\n@@ -1614,92 +1615,6 @@ struct Foo;\n     )\n }\n \n-#[test]\n-fn test_dollar_dollar() {\n-    check(\n-        r#\"\n-macro_rules! register_struct { ($Struct:ident) => {\n-    macro_rules! register_methods { ($$($method:ident),*) => {\n-        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n-            struct $Struct;\n-            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n-        }}\n-    }}\n-}}\n-\n-register_struct!(Foo);\n-register_methods!(alpha, beta);\n-implement_methods!(1, 2, 3);\n-\"#,\n-        expect![[r#\"\n-macro_rules! register_struct { ($Struct:ident) => {\n-    macro_rules! register_methods { ($$($method:ident),*) => {\n-        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n-            struct $Struct;\n-            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n-        }}\n-    }}\n-}}\n-\n-macro_rules !register_methods {\n-    ($($method: ident), *) = > {\n-        macro_rules!implement_methods {\n-            ($$($val: expr), *) = > {\n-                struct Foo;\n-                impl Foo {\n-                    $(fn $method()-> &'static[u32] {\n-                        &[$$($$val), *]\n-                    }\n-                    )*\n-                }\n-            }\n-        }\n-    }\n-}\n-macro_rules !implement_methods {\n-    ($($val: expr), *) = > {\n-        struct Foo;\n-        impl Foo {\n-            fn alpha()-> &'static[u32] {\n-                &[$($val), *]\n-            }\n-            fn beta()-> &'static[u32] {\n-                &[$($val), *]\n-            }\n-        }\n-    }\n-}\n-struct Foo;\n-impl Foo {\n-    fn alpha() -> &'static[u32] {\n-        &[1, 2, 3]\n-    }\n-    fn beta() -> &'static[u32] {\n-        &[1, 2, 3]\n-    }\n-}\n-\"#]],\n-    )\n-}\n-\n-#[test]\n-fn test_metavar_exprs() {\n-    check(\n-        r#\"\n-macro_rules! m {\n-    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n-}\n-const _: i32 = m!(a b c);\n-    \"#,\n-        expect![[r#\"\n-macro_rules! m {\n-    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n-}\n-const _: i32 = -0--1--2;\n-    \"#]],\n-    );\n-}\n-\n #[test]\n fn test_punct_without_space() {\n     // Puncts are \"glued\" greedily."}, {"sha": "967b5ad36babffcada722d76c0664e80dbdcd9c7", "filename": "crates/hir-def/src/macro_expansion_tests/mbe/metavar_expr.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -0,0 +1,311 @@\n+//! Tests for RFC 3086 metavariable expressions.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn test_dollar_dollar() {\n+    check(\n+        r#\"\n+macro_rules! register_struct { ($Struct:ident) => {\n+    macro_rules! register_methods { ($$($method:ident),*) => {\n+        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n+            struct $Struct;\n+            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n+        }}\n+    }}\n+}}\n+\n+register_struct!(Foo);\n+register_methods!(alpha, beta);\n+implement_methods!(1, 2, 3);\n+\"#,\n+        expect![[r#\"\n+macro_rules! register_struct { ($Struct:ident) => {\n+    macro_rules! register_methods { ($$($method:ident),*) => {\n+        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n+            struct $Struct;\n+            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n+        }}\n+    }}\n+}}\n+\n+macro_rules !register_methods {\n+    ($($method: ident), *) = > {\n+        macro_rules!implement_methods {\n+            ($$($val: expr), *) = > {\n+                struct Foo;\n+                impl Foo {\n+                    $(fn $method()-> &'static[u32] {\n+                        &[$$($$val), *]\n+                    }\n+                    )*\n+                }\n+            }\n+        }\n+    }\n+}\n+macro_rules !implement_methods {\n+    ($($val: expr), *) = > {\n+        struct Foo;\n+        impl Foo {\n+            fn alpha()-> &'static[u32] {\n+                &[$($val), *]\n+            }\n+            fn beta()-> &'static[u32] {\n+                &[$($val), *]\n+            }\n+        }\n+    }\n+}\n+struct Foo;\n+impl Foo {\n+    fn alpha() -> &'static[u32] {\n+        &[1, 2, 3]\n+    }\n+    fn beta() -> &'static[u32] {\n+        &[1, 2, 3]\n+    }\n+}\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn test_metavar_exprs() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n+}\n+const _: i32 = m!(a b c);\n+    \"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n+}\n+const _: i32 = -0--1--2;\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_basic() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t)}\n+    }\n+}\n+\n+fn test() {\n+    m!();\n+    m!(a);\n+    m!(a, a);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t)}\n+    }\n+}\n+\n+fn test() {\n+    0;\n+    1;\n+    2;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_with_depth() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($( $( $($t:ident)* ),* );*) => {\n+        $(\n+            {\n+                let depth_none = ${count(t)};\n+                let depth_zero = ${count(t, 0)};\n+                let depth_one = ${count(t, 1)};\n+            }\n+        )*\n+    }\n+}\n+\n+fn bar() {\n+    foo!(\n+        a a a, a, a a;\n+        a a a\n+    )\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($( $( $($t:ident)* ),* );*) => {\n+        $(\n+            {\n+                let depth_none = ${count(t)};\n+                let depth_zero = ${count(t, 0)};\n+                let depth_one = ${count(t, 1)};\n+            }\n+        )*\n+    }\n+}\n+\n+fn bar() {\n+     {\n+        let depth_none = 6;\n+        let depth_zero = 3;\n+        let depth_one = 6;\n+    } {\n+        let depth_none = 3;\n+        let depth_zero = 1;\n+        let depth_one = 3;\n+    }\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_depth_out_of_bounds() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { ${count(t, 1)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 1)};)* }\n+}\n+macro_rules! bar {\n+    ($($t:ident)*) => { ${count(t, 1024)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 8192)};)* }\n+}\n+\n+fn test() {\n+    foo!(a b);\n+    foo!(1 2; 3);\n+    bar!(a b);\n+    bar!(1 2; 3);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { ${count(t, 1)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 1)};)* }\n+}\n+macro_rules! bar {\n+    ($($t:ident)*) => { ${count(t, 1024)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 8192)};)* }\n+}\n+\n+fn test() {\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn misplaced_count() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { $(${count(t)})* };\n+    ($l:literal) => { ${count(l)} }\n+}\n+\n+fn test() {\n+    foo!(a b c);\n+    foo!(1);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { $(${count(t)})* };\n+    ($l:literal) => { ${count(l)} }\n+}\n+\n+fn test() {\n+    /* error: ${count} misplaced */;\n+    /* error: ${count} misplaced */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn malformed_count() {\n+    check(\n+        r#\"\n+macro_rules! too_many_args {\n+    ($($t:ident)*) => { ${count(t, 1, leftover)} }\n+}\n+macro_rules! depth_suffixed {\n+    ($($t:ident)*) => { ${count(t, 0usize)} }\n+}\n+macro_rules! depth_too_large {\n+    ($($t:ident)*) => { ${count(t, 18446744073709551616)} }\n+}\n+\n+fn test() {\n+    too_many_args!();\n+    depth_suffixed!();\n+    depth_too_large!();\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! too_many_args {\n+    ($($t:ident)*) => { ${count(t, 1, leftover)} }\n+}\n+macro_rules! depth_suffixed {\n+    ($($t:ident)*) => { ${count(t, 0usize)} }\n+}\n+macro_rules! depth_too_large {\n+    ($($t:ident)*) => { ${count(t, 18446744073709551616)} }\n+}\n+\n+fn test() {\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_interaction_with_empty_binding() {\n+    // FIXME: Should this error? rustc currently accepts it.\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t, 100)}\n+    }\n+}\n+\n+fn test() {\n+    m!();\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t, 100)}\n+    }\n+}\n+\n+fn test() {\n+    0;\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "d28dd17def3789ff550b379dbfe4c4b276c9118a", "filename": "crates/mbe/src/benchmark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -195,7 +195,7 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 });\n                 parent.token_trees.push(subtree.into());\n             }\n-            Op::Ignore { .. } | Op::Index { .. } => {}\n+            Op::Ignore { .. } | Op::Index { .. } | Op::Count { .. } => {}\n         };\n \n         // Simple linear congruential generator for deterministic result"}, {"sha": "474826079d733af289ee1edd4a0f6c07981c04a9", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -567,7 +567,9 @@ fn match_loop_inner<'t>(\n                 item.is_error = true;\n                 error_items.push(item);\n             }\n-            OpDelimited::Op(Op::Ignore { .. } | Op::Index { .. }) => {}\n+            OpDelimited::Op(Op::Ignore { .. } | Op::Index { .. } | Op::Count { .. }) => {\n+                stdx::never!(\"metavariable expression in lhs found\");\n+            }\n             OpDelimited::Open => {\n                 if matches!(src.peek_n(0), Some(tt::TokenTree::Subtree(..))) {\n                     item.dot.next();\n@@ -811,7 +813,9 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n             Op::Var { name, .. } => collector_fun(name.clone()),\n             Op::Subtree { tokens, .. } => collect_vars(collector_fun, tokens),\n             Op::Repeat { tokens, .. } => collect_vars(collector_fun, tokens),\n-            Op::Ignore { .. } | Op::Index { .. } | Op::Literal(_) | Op::Ident(_) | Op::Punct(_) => {\n+            Op::Literal(_) | Op::Ident(_) | Op::Punct(_) => {}\n+            Op::Ignore { .. } | Op::Index { .. } | Op::Count { .. } => {\n+                stdx::never!(\"metavariable expression in lhs found\");\n             }\n         }\n     }"}, {"sha": "6161af185871dbce3928f73e696f4178926de822", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 113, "deletions": 15, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -7,21 +7,31 @@ use crate::{\n     expander::{Binding, Bindings, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt::{self, Delimiter},\n-    ExpandError, ExpandResult, MetaTemplate,\n+    CountError, ExpandError, ExpandResult, MetaTemplate,\n };\n \n impl Bindings {\n     fn contains(&self, name: &str) -> bool {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<Fragment, ExpandError> {\n+    fn get(&self, name: &str) -> Result<&Binding, ExpandError> {\n+        match self.inner.get(name) {\n+            Some(binding) => Ok(binding),\n+            None => Err(ExpandError::binding_error(format!(\"could not find binding `{name}`\"))),\n+        }\n+    }\n+\n+    fn get_fragment(\n+        &self,\n+        name: &str,\n+        nesting: &mut [NestingState],\n+    ) -> Result<Fragment, ExpandError> {\n         macro_rules! binding_err {\n             ($($arg:tt)*) => { ExpandError::binding_error(format!($($arg)*)) };\n         }\n \n-        let mut b: &Binding =\n-            self.inner.get(name).ok_or_else(|| binding_err!(\"could not find binding `{name}`\"))?;\n+        let mut b = self.get(name)?;\n         for nesting_state in nesting.iter_mut() {\n             nesting_state.hit = true;\n             b = match b {\n@@ -133,7 +143,7 @@ fn expand_subtree(\n     // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n     let start_elements = arena.len();\n     let mut err = None;\n-    for op in template.iter() {\n+    'ops: for op in template.iter() {\n         match op {\n             Op::Literal(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n             Op::Ident(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n@@ -161,13 +171,12 @@ fn expand_subtree(\n             }\n             Op::Ignore { name, id } => {\n                 // Expand the variable, but ignore the result. This registers the repetition count.\n+                // FIXME: Any emitted errors are dropped.\n                 expand_var(ctx, name, *id);\n             }\n             Op::Index { depth } => {\n-                let index = ctx\n-                    .nesting\n-                    .get(ctx.nesting.len() - 1 - (*depth as usize))\n-                    .map_or(0, |nest| nest.idx);\n+                let index =\n+                    ctx.nesting.get(ctx.nesting.len() - 1 - depth).map_or(0, |nest| nest.idx);\n                 arena.push(\n                     tt::Leaf::Literal(tt::Literal {\n                         text: index.to_string().into(),\n@@ -176,6 +185,65 @@ fn expand_subtree(\n                     .into(),\n                 );\n             }\n+            Op::Count { name, depth } => {\n+                let mut binding = match ctx.bindings.get(name.as_str()) {\n+                    Ok(b) => b,\n+                    Err(e) => {\n+                        if err.is_none() {\n+                            err = Some(e);\n+                        }\n+                        continue;\n+                    }\n+                };\n+                for state in ctx.nesting.iter_mut() {\n+                    state.hit = true;\n+                    match binding {\n+                        Binding::Fragment(_) | Binding::Missing(_) => {\n+                            // `count()` will report an error.\n+                            break;\n+                        }\n+                        Binding::Nested(bs) => {\n+                            if let Some(b) = bs.get(state.idx) {\n+                                binding = b;\n+                            } else {\n+                                state.at_end = true;\n+                                continue 'ops;\n+                            }\n+                        }\n+                        Binding::Empty => {\n+                            state.at_end = true;\n+                            // FIXME: Breaking here and proceeding to `count()` isn't the most\n+                            // correct thing to do here. This could be a binding of some named\n+                            // fragment which we don't know the depth of, so `count()` will just\n+                            // return 0 for this no matter what `depth` is. See test\n+                            // `count_interaction_with_empty_binding` for example.\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                let c = match count(ctx, binding, 0, *depth) {\n+                    Ok(c) => c,\n+                    Err(e) => {\n+                        // XXX: It *might* make sense to emit a dummy integer value like `0` here.\n+                        // That would type inference a bit more robust in cases like\n+                        // `v[${count(t)}]` where index doesn't matter, but also coult also lead to\n+                        // wrong infefrence for cases like `tup.${count(t)}` where index itself\n+                        // does matter.\n+                        if err.is_none() {\n+                            err = Some(e.into());\n+                        }\n+                        continue;\n+                    }\n+                };\n+                arena.push(\n+                    tt::Leaf::Literal(tt::Literal {\n+                        text: c.to_string().into(),\n+                        span: tt::TokenId::unspecified(),\n+                    })\n+                    .into(),\n+                );\n+            }\n         }\n     }\n     // drain the elements added in this instance of expand_subtree\n@@ -218,12 +286,9 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n         .into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else {\n-        ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n+        ctx.bindings.get_fragment(v, &mut ctx.nesting).map_or_else(\n             |e| ExpandResult {\n-                value: Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: tt::Delimiter::unspecified(),\n-                    token_trees: vec![],\n-                })),\n+                value: Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree::empty())),\n                 err: Some(e),\n             },\n             ExpandResult::ok,\n@@ -245,6 +310,7 @@ fn expand_repeat(\n     let limit = 65536;\n     let mut has_seps = 0;\n     let mut counter = 0;\n+    let mut err = None;\n \n     loop {\n         let ExpandResult { value: mut t, err: e } = expand_subtree(ctx, template, None, arena);\n@@ -272,6 +338,7 @@ fn expand_repeat(\n         }\n \n         if e.is_some() {\n+            err = err.or(e);\n             continue;\n         }\n \n@@ -317,7 +384,7 @@ fn expand_repeat(\n             err: Some(ExpandError::UnexpectedToken),\n         };\n     }\n-    ExpandResult::ok(Fragment::Tokens(tt))\n+    ExpandResult { value: Fragment::Tokens(tt), err }\n }\n \n fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n@@ -343,3 +410,34 @@ fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n         _ => buf.push(tt.into()),\n     }\n }\n+\n+/// Handles `${count(t, depth)}`. `our_depth` is the recursion depth and `count_depth` is the depth\n+/// defined by the metavar expression.\n+fn count(\n+    ctx: &ExpandCtx<'_>,\n+    binding: &Binding,\n+    our_depth: usize,\n+    count_depth: Option<usize>,\n+) -> Result<usize, CountError> {\n+    match binding {\n+        Binding::Nested(bs) => match count_depth {\n+            None => bs.iter().map(|b| count(ctx, b, our_depth + 1, None)).sum(),\n+            Some(0) => Ok(bs.len()),\n+            Some(d) => bs.iter().map(|b| count(ctx, b, our_depth + 1, Some(d - 1))).sum(),\n+        },\n+        Binding::Empty => Ok(0),\n+        Binding::Fragment(_) | Binding::Missing(_) => {\n+            if our_depth == 0 {\n+                // `${count(t)}` is placed inside the innermost repetition. This includes cases\n+                // where `t` is not a repeated fragment.\n+                Err(CountError::Misplaced)\n+            } else if count_depth.is_none() {\n+                Ok(1)\n+            } else {\n+                // We've reached at the innermost repeated fragment, but the user wants us to go\n+                // further!\n+                Err(CountError::OutOfBounds)\n+            }\n+        }\n+    }\n+}"}, {"sha": "5ef20ff8a9b0524d524e81b7a504116ae67ae62b", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -19,6 +19,7 @@ mod benchmark;\n mod token_map;\n \n use ::tt::token_id as tt;\n+use stdx::impl_from;\n \n use std::fmt;\n \n@@ -77,8 +78,11 @@ pub enum ExpandError {\n     LimitExceeded,\n     NoMatchingRule,\n     UnexpectedToken,\n+    CountError(CountError),\n }\n \n+impl_from!(CountError for ExpandError);\n+\n impl ExpandError {\n     fn binding_error(e: impl Into<Box<str>>) -> ExpandError {\n         ExpandError::BindingError(Box::new(e.into()))\n@@ -94,6 +98,23 @@ impl fmt::Display for ExpandError {\n             ExpandError::ConversionError => f.write_str(\"could not convert tokens\"),\n             ExpandError::LimitExceeded => f.write_str(\"Expand exceed limit\"),\n             ExpandError::LeftoverTokens => f.write_str(\"leftover tokens\"),\n+            ExpandError::CountError(e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n+// FIXME: Showing these errors could be nicer.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n+pub enum CountError {\n+    OutOfBounds,\n+    Misplaced,\n+}\n+\n+impl fmt::Display for CountError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CountError::OutOfBounds => f.write_str(\"${count} out of bounds\"),\n+            CountError::Misplaced => f.write_str(\"${count} misplaced\"),\n         }\n     }\n }"}, {"sha": "7a143e7466a93c8784fcc524766689af1658f804", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -52,7 +52,8 @@ impl MetaTemplate {\n pub(crate) enum Op {\n     Var { name: SmolStr, kind: Option<MetaVarKind>, id: tt::TokenId },\n     Ignore { name: SmolStr, id: tt::TokenId },\n-    Index { depth: u32 },\n+    Index { depth: usize },\n+    Count { name: SmolStr, depth: Option<usize> },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Subtree { tokens: MetaTemplate, delimiter: tt::Delimiter },\n     Literal(tt::Literal),\n@@ -295,9 +296,13 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n             let ident = args.expect_ident()?;\n             Op::Ignore { name: ident.text.clone(), id: ident.span }\n         }\n-        \"index\" => {\n-            let depth = if args.len() == 0 { 0 } else { args.expect_u32_literal()? };\n-            Op::Index { depth }\n+        \"index\" => Op::Index { depth: parse_depth(&mut args)? },\n+        \"count\" => {\n+            let ident = args.expect_ident()?;\n+            // `${count(t)}` and `${count(t,)}` have different meanings. Not sure if this is a bug\n+            // but that's how it's implemented in rustc as of this writing. See rust-lang/rust#111904.\n+            let depth = if try_eat_comma(&mut args) { Some(parse_depth(&mut args)?) } else { None };\n+            Op::Count { name: ident.text.clone(), depth }\n         }\n         _ => return Err(()),\n     };\n@@ -308,3 +313,22 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n \n     Ok(op)\n }\n+\n+fn parse_depth(src: &mut TtIter<'_>) -> Result<usize, ()> {\n+    if src.len() == 0 {\n+        Ok(0)\n+    } else if let tt::Leaf::Literal(lit) = src.expect_literal()? {\n+        // Suffixes are not allowed.\n+        lit.text.parse().map_err(|_| ())\n+    } else {\n+        Err(())\n+    }\n+}\n+\n+fn try_eat_comma(src: &mut TtIter<'_>) -> bool {\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', .. }))) = src.peek_n(0) {\n+        let _ = src.next();\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "59dbf156800d4d160fd709bc2600e2863259a2af", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150082b0e3df91d08301c1547defd4d65f3cba07/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=150082b0e3df91d08301c1547defd4d65f3cba07", "patch": "@@ -73,13 +73,6 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_u32_literal(&mut self) -> Result<u32, ()> {\n-        match self.expect_literal()? {\n-            tt::Leaf::Literal(lit) => lit.text.parse().map_err(drop),\n-            _ => Err(()),\n-        }\n-    }\n-\n     pub(crate) fn expect_single_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n         match self.expect_leaf()? {\n             tt::Leaf::Punct(it) => Ok(it),"}]}