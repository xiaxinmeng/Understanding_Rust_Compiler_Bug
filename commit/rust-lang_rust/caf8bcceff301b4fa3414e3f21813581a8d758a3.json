{"sha": "caf8bcceff301b4fa3414e3f21813581a8d758a3", "node_id": "C_kwDOAAsO6NoAKGNhZjhiY2NlZmYzMDFiNGZhMzQxNGUzZjIxODEzNTgxYThkNzU4YTM", "commit": {"author": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2022-05-07T16:34:57Z"}, "committer": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2022-06-23T20:10:47Z"}, "message": "Optimize `Wtf8Buf::into_string` for the case where it contains UTF-8.\n\nAdd a `is_known_utf8` flag to `Wtf8Buf`, which tracks whether the\nstring is known to contain UTF-8. This is efficiently computed in many\ncommon situations, such as when a `Wtf8Buf` is constructed from a `String`\nor `&str`, or with `Wtf8Buf::from_wide` which is already doing UTF-16\ndecoding and already checking for surrogates.\n\nThis makes `OsString::into_string` O(1) rather than O(N) on Windows in\ncommon cases.\n\nAnd, it eliminates the need to scan through the string for surrogates in\n`Args::next` and `Vars::next`, because the strings are already being\ntranslated with `Wtf8Buf::from_wide`.\n\nMany things on Windows construct `OsString`s with `Wtf8Buf::from_wide`,\nsuch as `DirEntry::file_name` and `fs::read_link`, so with this patch,\nusers of those functions can subsequently call `.into_string()` without\npaying for an extra scan through the string for surrogates.", "tree": {"sha": "a9111e4c5d5b49b70878a7290737cae316c8532b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9111e4c5d5b49b70878a7290737cae316c8532b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caf8bcceff301b4fa3414e3f21813581a8d758a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caf8bcceff301b4fa3414e3f21813581a8d758a3", "html_url": "https://github.com/rust-lang/rust/commit/caf8bcceff301b4fa3414e3f21813581a8d758a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caf8bcceff301b4fa3414e3f21813581a8d758a3/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f4ce324baf7cfb7ce2b2096662b82b79204944", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944", "html_url": "https://github.com/rust-lang/rust/commit/10f4ce324baf7cfb7ce2b2096662b82b79204944"}], "stats": {"total": 405, "additions": 366, "deletions": 39}, "files": [{"sha": "4bdd8c505ff256e6ef5c13c1f5ee9c985dfa2766", "filename": "library/std/src/sys/windows/os_str.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos_str.rs?ref=caf8bcceff301b4fa3414e3f21813581a8d758a3", "patch": "@@ -164,9 +164,7 @@ impl Slice {\n     }\n \n     pub fn to_owned(&self) -> Buf {\n-        let mut buf = Wtf8Buf::with_capacity(self.inner.len());\n-        buf.push_wtf8(&self.inner);\n-        Buf { inner: buf }\n+        Buf { inner: self.inner.to_owned() }\n     }\n \n     pub fn clone_into(&self, buf: &mut Buf) {"}, {"sha": "a674ced88bbb399088df1aacda8140ead04c1e7c", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=caf8bcceff301b4fa3414e3f21813581a8d758a3", "patch": "@@ -89,6 +89,24 @@ impl CodePoint {\n         self.value\n     }\n \n+    /// Returns the numeric value of the code point if it is a leading surrogate.\n+    #[inline]\n+    pub fn to_lead_surrogate(&self) -> Option<u16> {\n+        match self.value {\n+            lead @ 0xD800..=0xDBFF => Some(lead as u16),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns the numeric value of the code point if it is a trailing surrogate.\n+    #[inline]\n+    pub fn to_trail_surrogate(&self) -> Option<u16> {\n+        match self.value {\n+            trail @ 0xDC00..=0xDFFF => Some(trail as u16),\n+            _ => None,\n+        }\n+    }\n+\n     /// Optionally returns a Unicode scalar value for the code point.\n     ///\n     /// Returns `None` if the code point is a surrogate (from U+D800 to U+DFFF).\n@@ -117,6 +135,14 @@ impl CodePoint {\n #[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\n pub struct Wtf8Buf {\n     bytes: Vec<u8>,\n+\n+    /// Do we know that `bytes` holds a valid UTF-8 encoding? We can easily\n+    /// know this if we're constructed from a `String` or `&str`.\n+    ///\n+    /// It is possible for `bytes` to have valid UTF-8 without this being\n+    /// set, such as when we're concatenating `&Wtf8`'s and surrogates become\n+    /// paired, as we don't bother to rescan the entire string.\n+    is_known_utf8: bool,\n }\n \n impl ops::Deref for Wtf8Buf {\n@@ -147,13 +173,13 @@ impl Wtf8Buf {\n     /// Creates a new, empty WTF-8 string.\n     #[inline]\n     pub fn new() -> Wtf8Buf {\n-        Wtf8Buf { bytes: Vec::new() }\n+        Wtf8Buf { bytes: Vec::new(), is_known_utf8: true }\n     }\n \n     /// Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Wtf8Buf {\n-        Wtf8Buf { bytes: Vec::with_capacity(capacity) }\n+        Wtf8Buf { bytes: Vec::with_capacity(capacity), is_known_utf8: true }\n     }\n \n     /// Creates a WTF-8 string from a UTF-8 `String`.\n@@ -163,7 +189,7 @@ impl Wtf8Buf {\n     /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n     #[inline]\n     pub fn from_string(string: String) -> Wtf8Buf {\n-        Wtf8Buf { bytes: string.into_bytes() }\n+        Wtf8Buf { bytes: string.into_bytes(), is_known_utf8: true }\n     }\n \n     /// Creates a WTF-8 string from a UTF-8 `&str` slice.\n@@ -173,11 +199,12 @@ impl Wtf8Buf {\n     /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n     #[inline]\n     pub fn from_str(str: &str) -> Wtf8Buf {\n-        Wtf8Buf { bytes: <[_]>::to_vec(str.as_bytes()) }\n+        Wtf8Buf { bytes: <[_]>::to_vec(str.as_bytes()), is_known_utf8: true }\n     }\n \n     pub fn clear(&mut self) {\n-        self.bytes.clear()\n+        self.bytes.clear();\n+        self.is_known_utf8 = true;\n     }\n \n     /// Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n@@ -195,15 +222,17 @@ impl Wtf8Buf {\n                     let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                     // Skip the WTF-8 concatenation check,\n                     // surrogate pairs are already decoded by decode_utf16\n-                    string.push_code_point_unchecked(code_point)\n+                    string.push_code_point_unchecked(code_point);\n+                    // The string now contains an unpaired surrogate.\n+                    string.is_known_utf8 = false;\n                 }\n             }\n         }\n         string\n     }\n \n     /// Copied from String::push\n-    /// This does **not** include the WTF-8 concatenation check.\n+    /// This does **not** include the WTF-8 concatenation check or `is_known_utf8` check.\n     fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n         let mut bytes = [0; 4];\n         let bytes = char::encode_utf8_raw(code_point.value, &mut bytes);\n@@ -217,6 +246,9 @@ impl Wtf8Buf {\n \n     #[inline]\n     pub fn as_mut_slice(&mut self) -> &mut Wtf8 {\n+        // Safety: `Wtf8` doesn't expose any way to mutate the bytes that would\n+        // cause them to change from well-formed UTF-8 to ill-formed UTF-8,\n+        // which would break the assumptions of the `is_known_utf8` field.\n         unsafe { Wtf8::from_mut_bytes_unchecked(&mut self.bytes) }\n     }\n \n@@ -313,7 +345,15 @@ impl Wtf8Buf {\n                 self.push_char(decode_surrogate_pair(lead, trail));\n                 self.bytes.extend_from_slice(other_without_trail_surrogate);\n             }\n-            _ => self.bytes.extend_from_slice(&other.bytes),\n+            _ => {\n+                self.bytes.extend_from_slice(&other.bytes);\n+\n+                // If we're pushing a string containing a surrogate, we may no\n+                // longer have UTF-8.\n+                if other.next_surrogate(0).is_some() {\n+                    self.is_known_utf8 = false;\n+                }\n+            }\n         }\n     }\n \n@@ -330,13 +370,19 @@ impl Wtf8Buf {\n     /// like concatenating ill-formed UTF-16 strings effectively would.\n     #[inline]\n     pub fn push(&mut self, code_point: CodePoint) {\n-        if let trail @ 0xDC00..=0xDFFF = code_point.to_u32() {\n+        if let Some(trail) = code_point.to_trail_surrogate() {\n             if let Some(lead) = (&*self).final_lead_surrogate() {\n                 let len_without_lead_surrogate = self.len() - 3;\n                 self.bytes.truncate(len_without_lead_surrogate);\n-                self.push_char(decode_surrogate_pair(lead, trail as u16));\n+                self.push_char(decode_surrogate_pair(lead, trail));\n                 return;\n             }\n+\n+            // We're pushing a trailing surrogate.\n+            self.is_known_utf8 = false;\n+        } else if code_point.to_lead_surrogate().is_some() {\n+            // We're pushing a leading surrogate.\n+            self.is_known_utf8 = false;\n         }\n \n         // No newly paired surrogates at the boundary.\n@@ -363,9 +409,10 @@ impl Wtf8Buf {\n     /// (that is, if the string contains surrogates),\n     /// the original WTF-8 string is returned instead.\n     pub fn into_string(self) -> Result<String, Wtf8Buf> {\n-        match self.next_surrogate(0) {\n-            None => Ok(unsafe { String::from_utf8_unchecked(self.bytes) }),\n-            Some(_) => Err(self),\n+        if self.is_known_utf8 || self.next_surrogate(0).is_none() {\n+            Ok(unsafe { String::from_utf8_unchecked(self.bytes) })\n+        } else {\n+            Err(self)\n         }\n     }\n \n@@ -375,6 +422,11 @@ impl Wtf8Buf {\n     ///\n     /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d)\n     pub fn into_string_lossy(mut self) -> String {\n+        // Fast path: If we already have UTF-8, we can return it immediately.\n+        if self.is_known_utf8 {\n+            return unsafe { String::from_utf8_unchecked(self.bytes) };\n+        }\n+\n         let mut pos = 0;\n         loop {\n             match self.next_surrogate(pos) {\n@@ -397,7 +449,7 @@ impl Wtf8Buf {\n     /// Converts a `Box<Wtf8>` into a `Wtf8Buf`.\n     pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf {\n         let bytes: Box<[u8]> = unsafe { mem::transmute(boxed) };\n-        Wtf8Buf { bytes: bytes.into_vec() }\n+        Wtf8Buf { bytes: bytes.into_vec(), is_known_utf8: false }\n     }\n }\n \n@@ -575,6 +627,11 @@ impl Wtf8 {\n         }\n     }\n \n+    /// Creates an owned `Wtf8Buf` from a borrowed `Wtf8`.\n+    pub fn to_owned(&self) -> Wtf8Buf {\n+        Wtf8Buf { bytes: self.bytes.to_vec(), is_known_utf8: false }\n+    }\n+\n     /// Lossily converts the string to UTF-8.\n     /// Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n     ///\n@@ -664,7 +721,8 @@ impl Wtf8 {\n     }\n \n     pub fn clone_into(&self, buf: &mut Wtf8Buf) {\n-        self.bytes.clone_into(&mut buf.bytes)\n+        self.bytes.clone_into(&mut buf.bytes);\n+        buf.is_known_utf8 = false;\n     }\n \n     /// Boxes this `Wtf8`.\n@@ -704,12 +762,18 @@ impl Wtf8 {\n \n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> Wtf8Buf {\n-        Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n+        Wtf8Buf {\n+            bytes: self.bytes.to_ascii_lowercase(),\n+            is_known_utf8: self.next_surrogate(0).is_none(),\n+        }\n     }\n \n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> Wtf8Buf {\n-        Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n+        Wtf8Buf {\n+            bytes: self.bytes.to_ascii_uppercase(),\n+            is_known_utf8: self.next_surrogate(0).is_none(),\n+        }\n     }\n \n     #[inline]"}, {"sha": "8360e3da215aae7b766ecb2f9f33bc736320f046", "filename": "library/std/src/sys_common/wtf8/tests.rs", "status": "modified", "additions": 284, "deletions": 19, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf8bcceff301b4fa3414e3f21813581a8d758a3/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs?ref=caf8bcceff301b4fa3414e3f21813581a8d758a3", "patch": "@@ -19,6 +19,36 @@ fn code_point_to_u32() {\n     assert_eq!(c(0x10FFFF).to_u32(), 0x10FFFF);\n }\n \n+#[test]\n+fn code_point_to_lead_surrogate() {\n+    fn c(value: u32) -> CodePoint {\n+        CodePoint::from_u32(value).unwrap()\n+    }\n+    assert_eq!(c(0).to_lead_surrogate(), None);\n+    assert_eq!(c(0xE9).to_lead_surrogate(), None);\n+    assert_eq!(c(0xD800).to_lead_surrogate(), Some(0xD800));\n+    assert_eq!(c(0xDBFF).to_lead_surrogate(), Some(0xDBFF));\n+    assert_eq!(c(0xDC00).to_lead_surrogate(), None);\n+    assert_eq!(c(0xDFFF).to_lead_surrogate(), None);\n+    assert_eq!(c(0x1F4A9).to_lead_surrogate(), None);\n+    assert_eq!(c(0x10FFFF).to_lead_surrogate(), None);\n+}\n+\n+#[test]\n+fn code_point_to_trail_surrogate() {\n+    fn c(value: u32) -> CodePoint {\n+        CodePoint::from_u32(value).unwrap()\n+    }\n+    assert_eq!(c(0).to_trail_surrogate(), None);\n+    assert_eq!(c(0xE9).to_trail_surrogate(), None);\n+    assert_eq!(c(0xD800).to_trail_surrogate(), None);\n+    assert_eq!(c(0xDBFF).to_trail_surrogate(), None);\n+    assert_eq!(c(0xDC00).to_trail_surrogate(), Some(0xDC00));\n+    assert_eq!(c(0xDFFF).to_trail_surrogate(), Some(0xDFFF));\n+    assert_eq!(c(0x1F4A9).to_trail_surrogate(), None);\n+    assert_eq!(c(0x10FFFF).to_trail_surrogate(), None);\n+}\n+\n #[test]\n fn code_point_from_char() {\n     assert_eq!(CodePoint::from_char('a').to_u32(), 0x61);\n@@ -70,73 +100,113 @@ fn wtf8buf_from_string() {\n \n #[test]\n fn wtf8buf_from_wide() {\n-    assert_eq!(Wtf8Buf::from_wide(&[]).bytes, b\"\");\n-    assert_eq!(\n-        Wtf8Buf::from_wide(&[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes,\n-        b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\"\n-    );\n+    let buf = Wtf8Buf::from_wide(&[]);\n+    assert_eq!(buf.bytes, b\"\");\n+    assert!(buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0x61, 0xE9, 0x20, 0xD83D, 0xDCA9]);\n+    assert_eq!(buf.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert!(buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]);\n+    assert_eq!(buf.bytes, b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\");\n+    assert!(!buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0xD800]);\n+    assert_eq!(buf.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0xDBFF]);\n+    assert_eq!(buf.bytes, b\"\\xED\\xAF\\xBF\");\n+    assert!(!buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0xDC00]);\n+    assert_eq!(buf.bytes, b\"\\xED\\xB0\\x80\");\n+    assert!(!buf.is_known_utf8);\n+\n+    let buf = Wtf8Buf::from_wide(&[0xDFFF]);\n+    assert_eq!(buf.bytes, b\"\\xED\\xBF\\xBF\");\n+    assert!(!buf.is_known_utf8);\n }\n \n #[test]\n fn wtf8buf_push_str() {\n     let mut string = Wtf8Buf::new();\n     assert_eq!(string.bytes, b\"\");\n+    assert!(string.is_known_utf8);\n+\n     string.push_str(\"a\u00e9 \ud83d\udca9\");\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert!(string.is_known_utf8);\n }\n \n #[test]\n fn wtf8buf_push_char() {\n     let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n+    assert!(string.is_known_utf8);\n+\n     string.push_char('\ud83d\udca9');\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert!(string.is_known_utf8);\n }\n \n #[test]\n fn wtf8buf_push() {\n     let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \");\n+    assert!(string.is_known_utf8);\n+\n     string.push(CodePoint::from_char('\ud83d\udca9'));\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert!(string.is_known_utf8);\n \n     fn c(value: u32) -> CodePoint {\n         CodePoint::from_u32(value).unwrap()\n     }\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xD83D)); // lead\n+    assert!(!string.is_known_utf8);\n     string.push(c(0xDCA9)); // trail\n     assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xD83D)); // lead\n+    assert!(!string.is_known_utf8);\n     string.push(c(0x20)); // not surrogate\n     string.push(c(0xDCA9)); // trail\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xD800)); // lead\n+    assert!(!string.is_known_utf8);\n     string.push(c(0xDBFF)); // lead\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xD800)); // lead\n+    assert!(!string.is_known_utf8);\n     string.push(c(0xE000)); // not surrogate\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xD7FF)); // not surrogate\n+    assert!(string.is_known_utf8);\n     string.push(c(0xDC00)); // trail\n+    assert!(!string.is_known_utf8);\n     assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0x61)); // not surrogate, < 3 bytes\n+    assert!(string.is_known_utf8);\n     string.push(c(0xDC00)); // trail\n+    assert!(!string.is_known_utf8);\n     assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n \n     let mut string = Wtf8Buf::new();\n     string.push(c(0xDC00)); // trail\n+    assert!(!string.is_known_utf8);\n     assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n }\n \n@@ -146,6 +216,7 @@ fn wtf8buf_push_wtf8() {\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9\");\n     string.push_wtf8(Wtf8::from_str(\" \ud83d\udca9\"));\n     assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert!(string.is_known_utf8);\n \n     fn w(v: &[u8]) -> &Wtf8 {\n         unsafe { Wtf8::from_bytes_unchecked(v) }\n@@ -161,37 +232,68 @@ fn wtf8buf_push_wtf8() {\n     string.push_wtf8(w(b\" \")); // not surrogate\n     string.push_wtf8(w(b\"\\xED\\xB2\\xA9\")); // trail\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+    assert!(!string.is_known_utf8);\n \n     let mut string = Wtf8Buf::new();\n     string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n     string.push_wtf8(w(b\"\\xED\\xAF\\xBF\")); // lead\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+    assert!(!string.is_known_utf8);\n \n     let mut string = Wtf8Buf::new();\n     string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n     string.push_wtf8(w(b\"\\xEE\\x80\\x80\")); // not surrogate\n     assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+    assert!(!string.is_known_utf8);\n \n     let mut string = Wtf8Buf::new();\n     string.push_wtf8(w(b\"\\xED\\x9F\\xBF\")); // not surrogate\n     string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n     assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+    assert!(!string.is_known_utf8);\n \n     let mut string = Wtf8Buf::new();\n     string.push_wtf8(w(b\"a\")); // not surrogate, < 3 bytes\n     string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n     assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n+    assert!(!string.is_known_utf8);\n \n     let mut string = Wtf8Buf::new();\n     string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n     assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n+    assert!(!string.is_known_utf8);\n }\n \n #[test]\n fn wtf8buf_truncate() {\n     let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+    assert!(string.is_known_utf8);\n+\n+    string.truncate(3);\n+    assert_eq!(string.bytes, b\"a\\xC3\\xA9\");\n+    assert!(string.is_known_utf8);\n+\n     string.truncate(1);\n     assert_eq!(string.bytes, b\"a\");\n+    assert!(string.is_known_utf8);\n+\n+    string.truncate(0);\n+    assert_eq!(string.bytes, b\"\");\n+    assert!(string.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8buf_truncate_around_non_bmp() {\n+    let mut string = Wtf8Buf::from_str(\"\ud83d\udca9\");\n+    assert!(string.is_known_utf8);\n+\n+    string.truncate(4);\n+    assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\");\n+    assert!(string.is_known_utf8);\n+\n+    string.truncate(0);\n+    assert_eq!(string.bytes, b\"\");\n+    assert!(string.is_known_utf8);\n }\n \n #[test]\n@@ -208,11 +310,37 @@ fn wtf8buf_truncate_fail_longer() {\n     string.truncate(4);\n }\n \n+#[test]\n+#[should_panic]\n+fn wtf8buf_truncate_splitting_non_bmp3() {\n+    let mut string = Wtf8Buf::from_str(\"\ud83d\udca9\");\n+    assert!(string.is_known_utf8);\n+    string.truncate(3);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn wtf8buf_truncate_splitting_non_bmp2() {\n+    let mut string = Wtf8Buf::from_str(\"\ud83d\udca9\");\n+    assert!(string.is_known_utf8);\n+    string.truncate(2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn wtf8buf_truncate_splitting_non_bmp1() {\n+    let mut string = Wtf8Buf::from_str(\"\ud83d\udca9\");\n+    assert!(string.is_known_utf8);\n+    string.truncate(1);\n+}\n+\n #[test]\n fn wtf8buf_into_string() {\n     let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+    assert!(string.is_known_utf8);\n     assert_eq!(string.clone().into_string(), Ok(String::from(\"a\u00e9 \ud83d\udca9\")));\n     string.push(CodePoint::from_u32(0xD800).unwrap());\n+    assert!(!string.is_known_utf8);\n     assert_eq!(string.clone().into_string(), Err(string));\n }\n \n@@ -229,15 +357,33 @@ fn wtf8buf_from_iterator() {\n     fn f(values: &[u32]) -> Wtf8Buf {\n         values.iter().map(|&c| CodePoint::from_u32(c).unwrap()).collect::<Wtf8Buf>()\n     }\n-    assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert_eq!(\n+        f(&[0x61, 0xE9, 0x20, 0x1F4A9]),\n+        Wtf8Buf { bytes: b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\".to_vec(), is_known_utf8: true }\n+    );\n \n     assert_eq!(f(&[0xD83D, 0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n-    assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n-    assert_eq!(f(&[0xD800, 0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n-    assert_eq!(f(&[0xD800, 0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n-    assert_eq!(f(&[0xD7FF, 0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n-    assert_eq!(f(&[0x61, 0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n-    assert_eq!(f(&[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n+    assert_eq!(\n+        f(&[0xD83D, 0x20, 0xDCA9]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        f(&[0xD800, 0xDBFF]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        f(&[0xD800, 0xE000]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        f(&[0xD7FF, 0xDC00]),\n+        Wtf8Buf { bytes: b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        f(&[0x61, 0xDC00]),\n+        Wtf8Buf { bytes: b\"\\x61\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(f(&[0xDC00]), Wtf8Buf { bytes: b\"\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false });\n }\n \n #[test]\n@@ -251,15 +397,36 @@ fn wtf8buf_extend() {\n         string\n     }\n \n-    assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    assert_eq!(\n+        e(&[0x61, 0xE9], &[0x20, 0x1F4A9]),\n+        Wtf8Buf { bytes: b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\".to_vec(), is_known_utf8: true }\n+    );\n \n     assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n-    assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n-    assert_eq!(e(&[0xD800], &[0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n-    assert_eq!(e(&[0xD800], &[0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n-    assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n-    assert_eq!(e(&[0x61], &[0xDC00]).bytes, b\"\\x61\\xED\\xB0\\x80\");\n-    assert_eq!(e(&[], &[0xDC00]).bytes, b\"\\xED\\xB0\\x80\");\n+    assert_eq!(\n+        e(&[0xD83D, 0x20], &[0xDCA9]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        e(&[0xD800], &[0xDBFF]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        e(&[0xD800], &[0xE000]),\n+        Wtf8Buf { bytes: b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        e(&[0xD7FF], &[0xDC00]),\n+        Wtf8Buf { bytes: b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        e(&[0x61], &[0xDC00]),\n+        Wtf8Buf { bytes: b\"\\x61\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false }\n+    );\n+    assert_eq!(\n+        e(&[], &[0xDC00]),\n+        Wtf8Buf { bytes: b\"\\xED\\xB0\\x80\".to_vec(), is_known_utf8: false }\n+    );\n }\n \n #[test]\n@@ -407,3 +574,101 @@ fn wtf8_encode_wide_size_hint() {\n     assert_eq!((0, Some(0)), iter.size_hint());\n     assert!(iter.next().is_none());\n }\n+\n+#[test]\n+fn wtf8_clone_into() {\n+    let mut string = Wtf8Buf::new();\n+    Wtf8::from_str(\"green\").clone_into(&mut string);\n+    assert_eq!(string.bytes, b\"green\");\n+\n+    let mut string = Wtf8Buf::from_str(\"green\");\n+    Wtf8::from_str(\"\").clone_into(&mut string);\n+    assert_eq!(string.bytes, b\"\");\n+\n+    let mut string = Wtf8Buf::from_str(\"red\");\n+    Wtf8::from_str(\"green\").clone_into(&mut string);\n+    assert_eq!(string.bytes, b\"green\");\n+\n+    let mut string = Wtf8Buf::from_str(\"green\");\n+    Wtf8::from_str(\"red\").clone_into(&mut string);\n+    assert_eq!(string.bytes, b\"red\");\n+\n+    let mut string = Wtf8Buf::from_str(\"green\");\n+    assert!(string.is_known_utf8);\n+    unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").clone_into(&mut string) };\n+    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!string.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8_to_ascii_lowercase() {\n+    let lowercase = Wtf8::from_str(\"\").to_ascii_lowercase();\n+    assert_eq!(lowercase.bytes, b\"\");\n+    assert!(lowercase.is_known_utf8);\n+\n+    let lowercase = Wtf8::from_str(\"GrEeN gRaPeS! \ud83c\udf47\").to_ascii_lowercase();\n+    assert_eq!(lowercase.bytes, b\"green grapes! \\xf0\\x9f\\x8d\\x87\");\n+    assert!(lowercase.is_known_utf8);\n+\n+    let lowercase = unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").to_ascii_lowercase() };\n+    assert_eq!(lowercase.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!lowercase.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8_to_ascii_uppercase() {\n+    let uppercase = Wtf8::from_str(\"\").to_ascii_uppercase();\n+    assert_eq!(uppercase.bytes, b\"\");\n+    assert!(uppercase.is_known_utf8);\n+\n+    let uppercase = Wtf8::from_str(\"GrEeN gRaPeS! \ud83c\udf47\").to_ascii_uppercase();\n+    assert_eq!(uppercase.bytes, b\"GREEN GRAPES! \\xf0\\x9f\\x8d\\x87\");\n+    assert!(uppercase.is_known_utf8);\n+\n+    let uppercase = unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").to_ascii_uppercase() };\n+    assert_eq!(uppercase.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!uppercase.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8_make_ascii_lowercase() {\n+    let mut lowercase = Wtf8Buf::from_str(\"\");\n+    lowercase.make_ascii_lowercase();\n+    assert_eq!(lowercase.bytes, b\"\");\n+    assert!(lowercase.is_known_utf8);\n+\n+    let mut lowercase = Wtf8Buf::from_str(\"GrEeN gRaPeS! \ud83c\udf47\");\n+    lowercase.make_ascii_lowercase();\n+    assert_eq!(lowercase.bytes, b\"green grapes! \\xf0\\x9f\\x8d\\x87\");\n+    assert!(lowercase.is_known_utf8);\n+\n+    let mut lowercase = unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").to_owned() };\n+    lowercase.make_ascii_lowercase();\n+    assert_eq!(lowercase.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!lowercase.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8_make_ascii_uppercase() {\n+    let mut uppercase = Wtf8Buf::from_str(\"\");\n+    uppercase.make_ascii_uppercase();\n+    assert_eq!(uppercase.bytes, b\"\");\n+    assert!(uppercase.is_known_utf8);\n+\n+    let mut uppercase = Wtf8Buf::from_str(\"GrEeN gRaPeS! \ud83c\udf47\");\n+    uppercase.make_ascii_uppercase();\n+    assert_eq!(uppercase.bytes, b\"GREEN GRAPES! \\xf0\\x9f\\x8d\\x87\");\n+    assert!(uppercase.is_known_utf8);\n+\n+    let mut uppercase = unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").to_owned() };\n+    uppercase.make_ascii_uppercase();\n+    assert_eq!(uppercase.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!uppercase.is_known_utf8);\n+}\n+\n+#[test]\n+fn wtf8_to_owned() {\n+    let string = unsafe { Wtf8::from_bytes_unchecked(b\"\\xED\\xA0\\x80\").to_owned() };\n+    assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\");\n+    assert!(!string.is_known_utf8);\n+}"}]}