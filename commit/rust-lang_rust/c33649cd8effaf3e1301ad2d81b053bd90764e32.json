{"sha": "c33649cd8effaf3e1301ad2d81b053bd90764e32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMzY0OWNkOGVmZmFmM2UxMzAxYWQyZDgxYjA1M2JkOTA3NjRlMzI=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-19T03:17:01Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-30T18:32:41Z"}, "message": "Run rustfmt on quoted.rs", "tree": {"sha": "ba31177f8dfd60fa22dce2ccdfa2c33bdbac5c78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba31177f8dfd60fa22dce2ccdfa2c33bdbac5c78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c33649cd8effaf3e1301ad2d81b053bd90764e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c33649cd8effaf3e1301ad2d81b053bd90764e32", "html_url": "https://github.com/rust-lang/rust/commit/c33649cd8effaf3e1301ad2d81b053bd90764e32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c33649cd8effaf3e1301ad2d81b053bd90764e32/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "html_url": "https://github.com/rust-lang/rust/commit/bb8110c1fcc33117fbf8bed985c0f472b3816bc3"}], "stats": {"total": 31, "additions": 21, "deletions": 10}, "files": [{"sha": "13764ebfca1e1920269bafde81bbe98f556f3338", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c33649cd8effaf3e1301ad2d81b053bd90764e32/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c33649cd8effaf3e1301ad2d81b053bd90764e32/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=c33649cd8effaf3e1301ad2d81b053bd90764e32", "patch": "@@ -241,7 +241,7 @@ pub fn parse(\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n fn parse_tree<I>(\n     tree: tokenstream::TokenTree,\n-    trees: &mut I,\n+    trees: &mut Peekable<I>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n ) -> TokenTree\n@@ -339,15 +339,21 @@ fn kleene_op(token: &token::Token) -> Option<KleeneOp> {\n /// - Ok(Ok(op)) if the next token tree is a KleeneOp\n /// - Ok(Err(tok, span)) if the next token tree is a token but not a KleeneOp\n /// - Err(span) if the next token tree is not a token\n-fn parse_kleene_op<I>(input: &mut I, span: Span) -> Result<Result<KleeneOp, (token::Token, Span)>, Span>\n-    where I: Iterator<Item = tokenstream::TokenTree>,\n+fn parse_kleene_op<I>(\n+    input: &mut I,\n+    span: Span,\n+) -> Result<Result<KleeneOp, (token::Token, Span)>, Span>\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n {\n     match input.next() {\n         Some(tokenstream::TokenTree::Token(span, tok)) => match kleene_op(&tok) {\n             Some(op) => Ok(Ok(op)),\n             None => Ok(Err((tok, span))),\n-        }\n-        tree => Err(tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span)),\n+        },\n+        tree => Err(tree.as_ref()\n+            .map(tokenstream::TokenTree::span)\n+            .unwrap_or(span)),\n     }\n }\n \n@@ -363,9 +369,13 @@ fn parse_kleene_op<I>(input: &mut I, span: Span) -> Result<Result<KleeneOp, (tok\n /// session `sess`. If the next one (or possibly two) tokens in `input` correspond to a Kleene\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n-fn parse_sep_and_kleene_op<I>(input: &mut Peekable<I>, span: Span, sess: &ParseSess)\n-                              -> (Option<token::Token>, KleeneOp)\n-    where I: Iterator<Item = tokenstream::TokenTree>,\n+fn parse_sep_and_kleene_op<I>(\n+    input: &mut Peekable<I>,\n+    span: Span,\n+    sess: &ParseSess,\n+) -> (Option<token::Token>, KleeneOp)\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n {\n     // We basically look at two token trees here, denoted as #1 and #2 below\n     let span = match parse_kleene_op(input, span) {\n@@ -415,12 +425,13 @@ fn parse_sep_and_kleene_op<I>(input: &mut Peekable<I>, span: Span, sess: &ParseS\n \n             // #2 is not a token at all :(\n             Err(span) => span,\n-        }\n+        },\n \n         // #1 is not a token\n         Err(span) => span,\n     };\n \n-    sess.span_diagnostic.span_err(span, \"expected one of: `*`,  `+`, or `?`\");\n+    sess.span_diagnostic\n+        .span_err(span, \"expected one of: `*`,  `+`, or `?`\");\n     (None, KleeneOp::ZeroOrMore)\n }"}]}