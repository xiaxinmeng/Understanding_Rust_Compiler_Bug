{"sha": "c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZThmM2I0ODFmZDQxZjgwMWMzZTc5ZDQzODYxZThlODZjZDFhNDQ=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-12T20:01:38Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-15T08:47:09Z"}, "message": "Add a memoize! macro and use it throughout rustc", "tree": {"sha": "8e920ec925da803e681427efa07ef962382075cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e920ec925da803e681427efa07ef962382075cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "html_url": "https://github.com/rust-lang/rust/commit/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/comments", "author": null, "committer": null, "parents": [{"sha": "5201bf17e6a051dd1411513346d8efc4afcb3c36", "url": "https://api.github.com/repos/rust-lang/rust/commits/5201bf17e6a051dd1411513346d8efc4afcb3c36", "html_url": "https://github.com/rust-lang/rust/commit/5201bf17e6a051dd1411513346d8efc4afcb3c36"}], "stats": {"total": 238, "additions": 125, "deletions": 113}, "files": [{"sha": "e3b6e5e01761a8bbb251ae07bf7fabf1256b6f4d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "patch": "@@ -97,6 +97,7 @@ pub mod middle {\n     pub mod intrinsicck;\n     pub mod lang_items;\n     pub mod liveness;\n+    pub mod macros;\n     pub mod mem_categorization;\n     pub mod pat_util;\n     pub mod privacy;"}, {"sha": "3d38e0fd5ed979d6d5efd7b19afc4330b34b169a", "filename": "src/librustc/middle/macros.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmacros.rs?ref=c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+macro_rules! memoize_expand_block(\n+    ($cache_map:expr, $cache_key:expr, $($param_name:ident: $param_ty:ty),*) => { {\n+        match ($cache_map).borrow().find(&$cache_key) {\n+            Some(ref result) => return (*result).clone(),\n+            None => {}\n+        }\n+        let result = inner($($param_name), *);\n+        ($cache_map).borrow_mut().insert($cache_key, result.clone());\n+        result\n+    } }\n+)\n+\n+/// Memoizes a function using a cache that is available by evaluating the\n+/// `$cache_map` exression in the context of the function's arguments.\n+/// `$cache_key` is the expression that will be used to compute the cache key\n+/// for each function invocation.\n+///\n+/// The macro assumes the cache to be a RefCell containing a HashMap,\n+/// which is in practice how most caching in rustc is currently carried out.\n+///\n+/// # Example\n+///\n+/// ```\n+/// struct Context {\n+///     fibonacci_cache: RefCell<HashMap<uint, uint>>\n+/// }\n+///\n+/// memoize!(context.fibonacci_cache, n,\n+/// fn fibonacci(context: &Context, n: uint) -> uint {\n+///     match n {\n+///         0 | 1 => n,\n+///         _ => fibonacci(n - 2) + fibonacci(n - 1)\n+///     }\n+/// }\n+/// )\n+/// ```\n+macro_rules! memoize(\n+    ($cache_map:expr, $cache_key:expr,\n+        fn $name:ident(\n+            $($param_name:ident: $param_ty:ty),*\n+        ) -> $output_ty:ty $block:block\n+    ) => {\n+        fn $name($($param_name: $param_ty), *) -> $output_ty {\n+            fn inner($($param_name: $param_ty), *) -> $output_ty $block\n+            memoize_expand_block!($cache_map, $cache_key, $($param_name: $param_ty), *)\n+        }\n+    };\n+\n+    ($cache_map:expr, $cache_key:expr,\n+        pub fn $name:ident(\n+            $($param_name:ident: $param_ty:ty),*\n+        ) -> $output_ty:ty $block:block\n+    ) => {\n+        pub fn $name($($param_name: $param_ty), *) -> $output_ty {\n+            fn inner($($param_name: $param_ty), *) -> $output_ty $block\n+            memoize_expand_block!($cache_map, $cache_key, $($param_name: $param_ty), *)\n+        }\n+    }\n+)"}, {"sha": "21d65c1e8eed36fa2d02ce0f8617ac13fa6cb023", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 53, "deletions": 113, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e8f3b481fd41f801c3e79d43861e8e86cd1a44/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c2e8f3b481fd41f801c3e79d43861e8e86cd1a44", "patch": "@@ -2117,55 +2117,38 @@ pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n-    match cx.needs_unwind_cleanup_cache.borrow().find(&ty) {\n-        Some(&result) => return result,\n-        None => ()\n-    }\n-\n-    let mut tycache = HashSet::new();\n-    let needs_unwind_cleanup =\n-        type_needs_unwind_cleanup_(cx, ty, &mut tycache);\n-    cx.needs_unwind_cleanup_cache.borrow_mut().insert(ty, needs_unwind_cleanup);\n-    needs_unwind_cleanup\n-}\n-\n-fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n-                              tycache: &mut HashSet<t>) -> bool {\n-\n+memoize!(cx.needs_unwind_cleanup_cache, ty,\n+fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut HashSet<t>) -> bool {\n     // Prevent infinite recursion\n     if !tycache.insert(ty) {\n         return false;\n     }\n \n     let mut needs_unwind_cleanup = false;\n     maybe_walk_ty(ty, |ty| {\n-        let result = match get(ty).sty {\n-          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_tup(_) | ty_ptr(_) => {\n-            true\n-          }\n-          ty_enum(did, ref substs) => {\n-            for v in (*enum_variants(cx, did)).iter() {\n-                for aty in v.args.iter() {\n-                    let t = aty.subst(cx, substs);\n-                    needs_unwind_cleanup |=\n-                        type_needs_unwind_cleanup_(cx, t, tycache);\n-                }\n-            }\n-            !needs_unwind_cleanup\n-          }\n-          _ => {\n-            needs_unwind_cleanup = true;\n-            false\n-          }\n-        };\n+        needs_unwind_cleanup |= match get(ty).sty {\n+            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) |\n+            ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n+\n+            ty_enum(did, ref substs) =>\n+                enum_variants(cx, did).iter().any(|v|\n+                    v.args.iter().any(|aty| {\n+                        let t = aty.subst(cx, substs);\n+                        type_needs_unwind_cleanup_(cx, t, tycache)\n+                    })\n+                ),\n \n-        result\n+            _ => true\n+        };\n+        !needs_unwind_cleanup\n     });\n-\n     needs_unwind_cleanup\n }\n+)\n+\n+pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n+    type_needs_unwind_cleanup_(cx, ty, &mut HashSet::new())\n+}\n \n /**\n  * Type contents is how the type checker reasons about kinds.\n@@ -2179,6 +2162,7 @@ fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n  * easier for me (nmatsakis) to think about what is contained within\n  * a type than to think about what is *not* contained within a type.\n  */\n+#[deriving(Clone)]\n pub struct TypeContents {\n     pub bits: u64\n }\n@@ -2358,19 +2342,9 @@ pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).interior_unsafe()\n }\n \n+memoize!(cx.tc_cache, type_id(ty),\n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n-    let ty_id = type_id(ty);\n-\n-    match cx.tc_cache.borrow().find(&ty_id) {\n-        Some(tc) => { return *tc; }\n-        None => {}\n-    }\n-\n-    let mut cache = HashMap::new();\n-    let result = tc_ty(cx, ty, &mut cache);\n-\n-    cx.tc_cache.borrow_mut().insert(ty_id, result);\n-    return result;\n+    return tc_ty(cx, ty, &mut HashMap::new());\n \n     fn tc_ty(cx: &ctxt,\n              ty: t,\n@@ -2685,6 +2659,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         }\n     }\n }\n+)\n \n pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n@@ -4033,28 +4008,23 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n \n /// Returns true if the given ID refers to an associated type and false if it\n /// refers to anything else.\n+memoize!(cx.associated_types, id,\n pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n-    let result = match cx.associated_types.borrow_mut().find(&id) {\n-        Some(result) => return *result,\n-        None if id.krate == ast::LOCAL_CRATE => {\n-            match cx.impl_or_trait_items.borrow().find(&id) {\n-                Some(ref item) => {\n-                    match **item {\n-                        TypeTraitItem(_) => true,\n-                        MethodTraitItem(_) => false,\n-                    }\n+    if id.krate == ast::LOCAL_CRATE {\n+        match cx.impl_or_trait_items.borrow().find(&id) {\n+            Some(ref item) => {\n+                match **item {\n+                    TypeTraitItem(_) => true,\n+                    MethodTraitItem(_) => false,\n                 }\n-                None => false,\n             }\n+            None => false,\n         }\n-        None => {\n-            csearch::is_associated_type(&cx.sess.cstore, id)\n-        }\n-    };\n-\n-    cx.associated_types.borrow_mut().insert(id, result);\n-    result\n+    } else {\n+        csearch::is_associated_type(&cx.sess.cstore, id)\n+    }\n }\n+)\n \n /// Returns the parameter index that the given associated type corresponds to.\n pub fn associated_type_parameter_index(cx: &ctxt,\n@@ -4110,13 +4080,9 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n     })\n }\n \n+memoize!(cx.impl_trait_cache, id,\n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n-    match cx.impl_trait_cache.borrow().find(&id) {\n-        Some(ret) => { return ret.clone(); }\n-        None => {}\n-    }\n-\n-    let ret = if id.krate == ast::LOCAL_CRATE {\n+    if id.krate == ast::LOCAL_CRATE {\n         debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         match cx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n@@ -4136,11 +4102,9 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n         }\n     } else {\n         csearch::get_impl_trait(cx, id)\n-    };\n-\n-    cx.impl_trait_cache.borrow_mut().insert(id, ret.clone());\n-    ret\n+    }\n }\n+)\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n@@ -4324,13 +4288,9 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n      }\n }\n \n+memoize!(cx.enum_var_cache, id,\n pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n-    match cx.enum_var_cache.borrow().find(&id) {\n-        Some(variants) => return variants.clone(),\n-        _ => { /* fallthrough */ }\n-    }\n-\n-    let result = if ast::LOCAL_CRATE != id.krate {\n+    if ast::LOCAL_CRATE != id.krate {\n         Rc::new(csearch::get_enum_variants(cx, id))\n     } else {\n         /*\n@@ -4385,12 +4345,9 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n             }\n             _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n-    };\n-\n-    cx.enum_var_cache.borrow_mut().insert(id, result.clone());\n-    result\n+    }\n }\n-\n+)\n \n // Returns information about the enum variant with the given ID:\n pub fn enum_variant_with_id(cx: &ctxt,\n@@ -4415,22 +4372,12 @@ pub fn lookup_item_type(cx: &ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n+memoize!(cx.trait_defs, did,\n pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n-    let mut trait_defs = cx.trait_defs.borrow_mut();\n-    match trait_defs.find_copy(&did) {\n-        Some(trait_def) => {\n-            // The item is in this crate. The caller should have added it to the\n-            // type cache already\n-            trait_def\n-        }\n-        None => {\n-            assert!(did.krate != ast::LOCAL_CRATE);\n-            let trait_def = Rc::new(csearch::get_trait_def(cx, did));\n-            trait_defs.insert(did, trait_def.clone());\n-            trait_def\n-        }\n-    }\n+    assert!(did.krate != ast::LOCAL_CRATE);\n+    Rc::new(csearch::get_trait_def(cx, did))\n }\n+)\n \n /// Given a reference to a trait, returns the bounds declared on the\n /// trait, with appropriate substitutions applied.\n@@ -4489,13 +4436,9 @@ pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n }\n \n /// Obtain the representation annotation for a struct definition.\n+memoize!(tcx.repr_hint_cache, did,\n pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-    match tcx.repr_hint_cache.borrow().find(&did) {\n-        None => {}\n-        Some(ref hints) => return (*hints).clone(),\n-    }\n-\n-    let acc = if did.krate == LOCAL_CRATE {\n+    Rc::new(if did.krate == LOCAL_CRATE {\n         let mut acc = Vec::new();\n         ty::each_attr(tcx, did, |meta| {\n             acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(),\n@@ -4505,12 +4448,9 @@ pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         acc\n     } else {\n         csearch::get_repr_attrs(&tcx.sess.cstore, did)\n-    };\n-\n-    let acc = Rc::new(acc);\n-    tcx.repr_hint_cache.borrow_mut().insert(did, acc.clone());\n-    acc\n+    })\n }\n+)\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic"}]}