{"sha": "6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "node_id": "C_kwDOAAsO6NoAKDZhNjkxYjFkOTJjMGMzNGVlOGI0M2E2ZDA0ZGYzMGM5MDhjNGQ2YTM", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-08T21:10:00Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-12-07T02:06:58Z"}, "message": "Refer to const params as \"const params\" and not \"type params\"", "tree": {"sha": "5a58122addfaf3e878270fb4280ad3c06fd2b383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a58122addfaf3e878270fb4280ad3c06fd2b383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "html_url": "https://github.com/rust-lang/rust/commit/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fd15c8404626c6622555e66299c9f3442bf2322", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd15c8404626c6622555e66299c9f3442bf2322", "html_url": "https://github.com/rust-lang/rust/commit/3fd15c8404626c6622555e66299c9f3442bf2322"}], "stats": {"total": 86, "additions": 48, "deletions": 38}, "files": [{"sha": "739987e850a0112aae211a791415e9e2fdd037ce", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n+use rustc_middle::ty::{self, Const, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -305,6 +305,15 @@ pub enum UnderspecifiedArgKind {\n     Const { is_parameter: bool },\n }\n \n+impl UnderspecifiedArgKind {\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { .. } => \"const\",\n+        }\n+    }\n+}\n+\n impl InferenceDiagnosticsData {\n     /// Generate a label for a generic argument which can't be inferred. When not\n     /// much is known about the argument, `use_diag` may be used to describe the\n@@ -587,6 +596,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let param_type = arg_data.kind.descr();\n         let suffix = match local_visitor.found_node_ty {\n             Some(ty) if ty.is_closure() => {\n                 let substs =\n@@ -625,15 +635,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n+                format!(\"the explicit type `{}`, with the {} parameters specified\", ty, param_type)\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n                 let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n                 let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n                 let ty = ty_to_string(ty);\n                 format!(\n-                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, arg_data.name,\n+                    \"the explicit type `{}`, where the {} parameter `{}` is specified\",\n+                    ty, param_type, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -910,7 +920,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-/// Turn resolved type params into `[type error]` to signal we don't want to display them.\n+/// Turn *resolved* type params into `[type error]` to signal we don't want to display them. After\n+/// performing that replacement, we'll turn all remaining infer type params to use their name from\n+/// their definition, and replace all the `[type error]`s back to being infer so they display in\n+/// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n+/// by their name *or* `_`, neither of which is desireable: we want to show all types that we could\n+/// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n struct ResolvedTypeParamEraser<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     level: usize,\n@@ -920,7 +935,18 @@ impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Self {\n         ResolvedTypeParamEraser { tcx, level: 0 }\n     }\n+\n+    /// Replace not yet inferred const params with their def name.\n+    fn replace_infers(&self, c: &'tcx Const<'tcx>, index: u32, name: Symbol) -> &'tcx Const<'tcx> {\n+        match c.val {\n+            ty::ConstKind::Infer(..) => {\n+                self.tcx().mk_const_param(index, name, c.ty)\n+            }\n+            _ => c,\n+        }\n+    }\n }\n+\n impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -940,29 +966,22 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n                     .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n                         (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n                         (crate::infer::GenericArgKind::Const(c), _) => {\n-                            match c.val {\n-                                ty::ConstKind::Infer(..) => {\n-                                    // Replace not yet inferred const params with their def name.\n-                                    self.tcx().mk_const_param(param.index, param.name, c.ty).into()\n-                                }\n-                                _ => subst,\n-                            }\n+                            self.replace_infers(c, param.index, param.name).into()\n                         }\n                         _ => subst.super_fold_with(self),\n                     })\n                     .collect();\n-                if self.level == 1\n-                    || substs.iter().any(|subst| match subst.unpack() {\n-                        ty::subst::GenericArgKind::Type(t) => match t.kind() {\n-                            ty::Error(_) => false,\n-                            _ => true,\n-                        },\n-                        // Account for `const` params here, otherwise `doesnt_infer.rs`\n-                        // shows `_` instead of `Foo<{ _: u32 }>`\n-                        ty::subst::GenericArgKind::Const(_) => true,\n-                        _ => false,\n-                    })\n-                {\n+                let should_keep = |subst: &GenericArg<'_>| match subst.unpack() {\n+                    ty::subst::GenericArgKind::Type(t) => match t.kind() {\n+                        ty::Error(_) => false,\n+                        _ => true,\n+                    },\n+                    // Account for `const` params here, otherwise `doesnt_infer.rs`\n+                    // shows `_` instead of `Foo<{ _: u32 }>`\n+                    ty::subst::GenericArgKind::Const(_) => true,\n+                    _ => false,\n+                };\n+                if self.level == 1 || substs.iter().any(should_keep) {\n                     let substs = self.tcx().intern_substs(&substs[..]);\n                     self.tcx().mk_ty(ty::Adt(def, substs))\n                 } else {\n@@ -986,18 +1005,9 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n             | ty::Opaque(..)\n             | ty::Projection(_)\n             | ty::Never => t.super_fold_with(self),\n-            ty::Array(ty, c) => {\n-                self.tcx().mk_ty(ty::Array(\n-                    self.fold_ty(ty),\n-                    match c.val {\n-                        ty::ConstKind::Infer(..) => {\n-                            // Replace not yet inferred const params with their def name.\n-                            self.tcx().mk_const_param(0, Symbol::intern(\"N\"), c.ty).into()\n-                        }\n-                        _ => c,\n-                    },\n-                ))\n-            }\n+            ty::Array(ty, c) => self\n+                .tcx()\n+                .mk_ty(ty::Array(self.fold_ty(ty), self.replace_infers(c, 0, Symbol::intern(\"N\")))),\n             // We don't want to hide type params that haven't been resolved yet.\n             // This would be the type that will be written out with the type param\n             // name in the output."}, {"sha": "d6c64d58be5f39c9975650203301179d702f500f", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `Foo<{_: u32}>`\n LL |     let foo = Foo::foo();\n    |         ---   ^^^^^^^^ cannot infer the value of const parameter `N`\n    |         |\n-   |         consider giving `foo` the explicit type `Foo<N>`, where the type parameter `N` is specified\n+   |         consider giving `foo` the explicit type `Foo<N>`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}, {"sha": "9ca8f35fd545a4abb34cbae54e3ee8b9a8765443", "filename": "src/test/ui/inference/issue-83606.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr?ref=6a691b1d92c0c34ee8b43a6d04df30c908c4d6a3", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `[usize; _]`\n LL |     let _ = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n    |         -   ^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n    |         |\n-   |         consider giving this pattern the explicit type `[_; N]`, where the type parameter `N` is specified\n+   |         consider giving this pattern the explicit type `[_; N]`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}]}