{"sha": "125bebbf60acf13bcbebaab2d68d2c68d5a06f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNWJlYmJmNjBhY2YxM2JjYmViYWFiMmQ2OGQyYzY4ZDVhMDZmNzc=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-01T01:20:10Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-01T03:15:11Z"}, "message": "Modify trans.rs to allow blocks to result in boxed values", "tree": {"sha": "6316eea3a5876bdc29ada84c6bd5af5bd4bcc1f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6316eea3a5876bdc29ada84c6bd5af5bd4bcc1f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/125bebbf60acf13bcbebaab2d68d2c68d5a06f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/125bebbf60acf13bcbebaab2d68d2c68d5a06f77", "html_url": "https://github.com/rust-lang/rust/commit/125bebbf60acf13bcbebaab2d68d2c68d5a06f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/125bebbf60acf13bcbebaab2d68d2c68d5a06f77/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1c61548ec2ddde4d85dbef88eed6627b536d13", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1c61548ec2ddde4d85dbef88eed6627b536d13", "html_url": "https://github.com/rust-lang/rust/commit/bd1c61548ec2ddde4d85dbef88eed6627b536d13"}], "stats": {"total": 59, "additions": 59, "deletions": 0}, "files": [{"sha": "6c072c61e83b1f61cdcddedf86483a0d20c5eb75", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/125bebbf60acf13bcbebaab2d68d2c68d5a06f77/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/125bebbf60acf13bcbebaab2d68d2c68d5a06f77/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=125bebbf60acf13bcbebaab2d68d2c68d5a06f77", "patch": "@@ -1026,6 +1026,18 @@ fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n     }\n }\n \n+fn find_outer_scope_cx(@block_ctxt cx) -> @block_ctxt {\n+    auto scope_cx = find_scope_cx(cx);\n+    alt (cx.parent) {\n+        case (parent_some(?b)) {\n+            be find_scope_cx(b);\n+        }\n+        case (parent_none) {\n+            fail;\n+        }\n+    }\n+}\n+\n fn umax(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n     ret cx.build.Select(cond, b, a);\n@@ -5368,8 +5380,55 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n         case (some[@ast.expr](?e)) {\n             r = trans_expr(bcx, e);\n             bcx = r.bcx;\n+\n             if (is_terminated(bcx)) {\n                 ret r;\n+            } else {\n+                // The value resulting from the block gets copied into an\n+                // alloca created in an enclosing scope and it's refcount\n+                // bumped so that it can escape this block. This means that\n+                // it will definitely live until the end of the enclosing\n+                // scope, even if nobody uses it, which may be something of\n+                // a surprise.\n+\n+                auto r_ty = ty.expr_ty(e);\n+\n+                fn is_nil(@ty.t r_ty) -> bool {\n+                    alt (r_ty.struct) {\n+                        case (ty.ty_nil) {\n+                            ret true;\n+                        }\n+                        case (_) {\n+                            ret false;\n+                        }\n+                    }\n+                }\n+\n+                // FIXME: This is a temporary hack to prevent compile\n+                // failures. There's some expression variant that claims\n+                // to be ty_nil but but does not translate to T_nil. Need\n+                // to hunt it down.\n+                if (!is_nil(r_ty)) {\n+                    // This alloca is declared at the function level, above\n+                    // the block scope\n+                    auto res_alloca = alloc_ty(bcx, r_ty);\n+                    bcx = res_alloca.bcx;\n+                    auto res_copy = copy_ty(bcx, INIT,\n+                                            res_alloca.val, r.val, r_ty);\n+                    bcx = res_copy.bcx;\n+\n+                    fn drop_hoisted_ty(@block_ctxt cx,\n+                                       ValueRef alloca_val,\n+                                       @ty.t t) -> result {\n+                        auto reg_val = load_scalar_or_boxed(cx,\n+                                                            alloca_val, t);\n+                        ret drop_ty(cx, reg_val, t);\n+                    }\n+\n+                    auto cleanup = bind drop_hoisted_ty(_, res_alloca.val,\n+                                                        r_ty);\n+                    find_outer_scope_cx(bcx).cleanups += vec(clean(cleanup));\n+                }\n             }\n         }\n         case (none[@ast.expr]) {"}]}