{"sha": "a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OTFmNmVkZmViNGQ3YjA2MWEyMTViYTE2MGZjYTBlNDgwNGZmZDI=", "commit": {"author": {"name": "Cl\u00e9ment Renault", "email": "clement@meilisearch.com", "date": "2020-12-10T09:16:29Z"}, "committer": {"name": "Cl\u00e9ment Renault", "email": "clement@meilisearch.com", "date": "2020-12-10T09:16:29Z"}, "message": "Introduce the GroupBy and GroupByMut Iterators", "tree": {"sha": "268ac9128fb52fcce238b6f87261252d147beace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/268ac9128fb52fcce238b6f87261252d147beace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEAUNXpSBlykwfjB4xkq2k6TXnH6QFAl/R520ACgkQkq2k6TXn\nH6TrnRAAinxV27OqGhcofxxIwxbwWl+mlGM7EVzyXW+8nwAcZ/gXilL1V0gPJN1w\nPPXx8ATEU4zjJ7yHrubW4b29Oe66DyY1AgoP+eGFHA3j1XE4093d3EluuTEuLyiz\nxf7x+BuhUxbeRvh11nnSpTO71gp6UBU/+/WrEEHILEC/13Wgc2pw4ntU8HUyuuhY\noAiz8OHnhA491J/KGYUA8m/j8WdfuAxJiyWNdRJpFXiKcm5gk8wPEFTet7EiRX5s\na0fagAIU/Fe+exuydYaLcWTFYHC3t4XByqrGRHRFdIi2g6os7CJTRPNp+Ay5oG6c\nKKrkUnGXSqA5puxE4opQEXftWti2HTakbE8BcFue0SFF5qv8a6K3msotJ5dvy1uk\naPhvACqSKyIOIaANfT6wb0hK7UUZpGDf2fPV947+j56SKo9gcKqqxe4kem6estcr\n7CxoCb97b08pxd8BlzWrySuhUpeHP8G5djzjWeLoL+VfzsCi9g0y6u//zoKt48bL\nyFbfyEW4kTrsgxGhS5PolqJQYm/Blu8gTngOgpe72tHvNd9kUPajm+MlVQVT6vM8\n+YptCwvCg9N8+DFpuDolSTZKpUe4qIRAyLlj9YaYPD87ScgKJ27T1VNVYxljoVuy\nJSHnuP+f9O/GYLHiMkEodNPCA5lSzJra/Ff6NutlDASeV1zPDGU=\n=0lO4\n-----END PGP SIGNATURE-----", "payload": "tree 268ac9128fb52fcce238b6f87261252d147beace\nparent e413d89aa706060ddc347e1e06d551ec86d3f471\nauthor Cl\u00e9ment Renault <clement@meilisearch.com> 1607591789 +0100\ncommitter Cl\u00e9ment Renault <clement@meilisearch.com> 1607591789 +0100\n\nIntroduce the GroupBy and GroupByMut Iterators\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "html_url": "https://github.com/rust-lang/rust/commit/a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/comments", "author": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kerollmops", "id": 3610253, "node_id": "MDQ6VXNlcjM2MTAyNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3610253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kerollmops", "html_url": "https://github.com/Kerollmops", "followers_url": "https://api.github.com/users/Kerollmops/followers", "following_url": "https://api.github.com/users/Kerollmops/following{/other_user}", "gists_url": "https://api.github.com/users/Kerollmops/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kerollmops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kerollmops/subscriptions", "organizations_url": "https://api.github.com/users/Kerollmops/orgs", "repos_url": "https://api.github.com/users/Kerollmops/repos", "events_url": "https://api.github.com/users/Kerollmops/events{/privacy}", "received_events_url": "https://api.github.com/users/Kerollmops/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e413d89aa706060ddc347e1e06d551ec86d3f471", "url": "https://api.github.com/repos/rust-lang/rust/commits/e413d89aa706060ddc347e1e06d551ec86d3f471", "html_url": "https://github.com/rust-lang/rust/commit/e413d89aa706060ddc347e1e06d551ec86d3f471"}], "stats": {"total": 280, "additions": 280, "deletions": 0}, "files": [{"sha": "34102d9c4036a4354f2c3b029624047f7f13a07a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -140,6 +140,7 @@\n #![feature(try_trait)]\n #![feature(type_alias_impl_trait)]\n #![feature(associated_type_bounds)]\n+#![feature(slice_group_by)]\n // Allow testing this library\n \n #[cfg(test)]"}, {"sha": "bfa317ffd73c8cc4d867302e395a2d81764b3a9c", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -118,6 +118,8 @@ pub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+pub use core::slice::{GroupBy, GroupByMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods"}, {"sha": "268153242c778fe11eeb2a69e94eadb880f0a8a7", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -21,6 +21,7 @@\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n #![feature(vecdeque_binary_search)]\n+#![feature(slice_group_by)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "e2fdb5a6b5a73edb2511f0aa87a3acbe60474221", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -1898,3 +1898,30 @@ fn subslice_patterns() {\n     m!(&mut v, [..] => ());\n     m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n }\n+\n+#[test]\n+fn test_group_by() {\n+    let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+\n+    assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+\n+    assert_eq!(iter.remaining(), &[3, 3, 2, 2, 2]);\n+\n+    assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next(), None);\n+}\n+\n+#[test]\n+fn test_group_by_rev() {\n+    let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+\n+    assert_eq!(iter.next_back(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&[1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), None);\n+}"}, {"sha": "917997f902aec7e8f4b406049da77f777ca82e7c", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -2967,3 +2967,183 @@ unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n         false\n     }\n }\n+\n+macro_rules! group_by {\n+    (struct $name:ident, $elem:ty, $mkslice:ident) => {\n+        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+        impl<'a, T: 'a, P> $name<'a, T, P> {\n+            #[inline]\n+            fn is_empty(&self) -> bool {\n+                self.ptr == self.end\n+            }\n+\n+            #[inline]\n+            fn remaining_len(&self) -> usize {\n+                unsafe { self.end.offset_from(self.ptr) as usize }\n+            }\n+        }\n+\n+        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+        impl<'a, T: 'a, P> Iterator for $name<'a, T, P>\n+        where P: FnMut(&T, &T) -> bool,\n+        {\n+            type Item = $elem;\n+\n+            fn next(&mut self) -> Option<Self::Item> {\n+                // we use an unsafe block to avoid bounds checking here.\n+                // this is safe because the only thing we do here is to get\n+                // two elements at `ptr` and `ptr + 1`, bounds checking is done by hand.\n+                unsafe {\n+                    if self.is_empty() { return None }\n+\n+                    let mut i = 0;\n+                    let mut ptr = self.ptr;\n+\n+                    // we need to get *two* contiguous elements so we check that:\n+                    //  - the first element is at the `end - 1` position because\n+                    //  - the second one will be read from `ptr + 1` that must\n+                    //    be lower or equal to `end`\n+                    while ptr != self.end.sub(1) {\n+                        let a = &*ptr;\n+                        ptr = ptr.add(1);\n+                        let b = &*ptr;\n+\n+                        i += 1;\n+\n+                        if !(self.predicate)(a, b) {\n+                            let slice = $mkslice(self.ptr, i);\n+                            self.ptr = ptr;\n+                            return Some(slice)\n+                        }\n+                    }\n+\n+                    // `i` is either `0` or the slice `length - 1` because either:\n+                    //  - we have not entered the loop and so `i` is equal to `0`\n+                    //    the slice length is necessarily `1` because we ensure it is not empty\n+                    //  - we have entered the loop and we have not early returned\n+                    //    so `i` is equal to the slice `length - 1`\n+                    let slice = $mkslice(self.ptr, i + 1);\n+                    self.ptr = self.end;\n+                    Some(slice)\n+                }\n+            }\n+\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                if self.is_empty() { return (0, Some(0)) }\n+                let len = self.remaining_len();\n+                (1, Some(len))\n+            }\n+\n+            fn last(mut self) -> Option<Self::Item> {\n+                self.next_back()\n+            }\n+        }\n+\n+        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+        impl<'a, T: 'a, P> DoubleEndedIterator for $name<'a, T, P>\n+        where P: FnMut(&T, &T) -> bool,\n+        {\n+            fn next_back(&mut self) -> Option<Self::Item> {\n+                // during the loop we retrieve two elements at `ptr` and `ptr - 1`.\n+                unsafe {\n+                    if self.is_empty() { return None }\n+\n+                    let mut i = 0;\n+                    // we ensure that the first element that will be read\n+                    // is not under `end` because `end` is out of bound.\n+                    let mut ptr = self.end.sub(1);\n+\n+                    while ptr != self.ptr {\n+                        // we first get `a` that is at the left of `ptr`\n+                        // then `b` that is under the `ptr` position.\n+                        let a = &*ptr.sub(1);\n+                        let b = &*ptr;\n+\n+                        i += 1;\n+\n+                        if !(self.predicate)(a, b) {\n+                            // the slice to return starts at the `ptr` position\n+                            // and `i` is the length of it.\n+                            let slice = $mkslice(ptr, i);\n+\n+                            // because `end` is always an invalid bound\n+                            // we use `ptr` as `end` for the future call to `next`.\n+                            self.end = ptr;\n+                            return Some(slice)\n+                        }\n+\n+                        ptr = ptr.sub(1);\n+                    }\n+\n+                    let slice = $mkslice(self.ptr, i + 1);\n+                    self.ptr = self.end;\n+                    Some(slice)\n+                }\n+            }\n+        }\n+\n+        #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+        impl<'a, T: 'a, P> FusedIterator for $name<'a, T, P>\n+        where P: FnMut(&T, &T) -> bool,\n+        { }\n+    }\n+}\n+\n+/// An iterator over slice in (non-overlapping) chunks separated by a predicate.\n+///\n+/// This struct is created by the [`group_by`] method on [slices].\n+///\n+/// [`group_by`]: ../../std/primitive.slice.html#method.group_by\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+#[derive(Debug)] // FIXME implement Debug to be more user friendly\n+pub struct GroupBy<'a, T: 'a, P> {\n+    ptr: *const T,\n+    end: *const T,\n+    predicate: P,\n+    _phantom: marker::PhantomData<&'a T>,\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> GroupBy<'a, T, P>\n+where P: FnMut(&T, &T) -> bool,\n+{\n+    /// Returns the remainder of the original slice that is going to be\n+    /// returned by the iterator.\n+    pub fn remaining(&self) -> &[T] {\n+        let len = self.remaining_len();\n+        unsafe { from_raw_parts(self.ptr, len) }\n+    }\n+}\n+\n+group_by!{ struct GroupBy, &'a [T], from_raw_parts }\n+\n+/// An iterator over slice in (non-overlapping) mutable chunks separated\n+/// by a predicate.\n+///\n+/// This struct is created by the [`group_by_mut`] method on [slices].\n+///\n+/// [`group_by_mut`]: ../../std/primitive.slice.html#method.group_by_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+#[derive(Debug)] // FIXME implement Debug to be more user friendly\n+pub struct GroupByMut<'a, T: 'a, P> {\n+    ptr: *mut T,\n+    end: *mut T,\n+    predicate: P,\n+    _phantom: marker::PhantomData<&'a T>,\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+impl<'a, T: 'a, P> GroupByMut<'a, T, P>\n+where P: FnMut(&T, &T) -> bool,\n+{\n+    /// Returns the remainder of the original slice that is going to be\n+    /// returned by the iterator.\n+    pub fn into_remaining(self) -> &'a mut [T] {\n+        let len = self.remaining_len();\n+        unsafe { from_raw_parts_mut(self.ptr, len) }\n+    }\n+}\n+\n+group_by!{ struct GroupByMut, &'a mut [T], from_raw_parts_mut }"}, {"sha": "e366baa34c6655d9abb5f2172cc06a5be78a47b9", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -1207,6 +1207,74 @@ impl<T> [T] {\n         RChunksExactMut::new(self, chunk_size)\n     }\n \n+    /// Returns an iterator over the slice producing non-overlapping runs\n+    /// of elements using the predicate to separate them.\n+    ///\n+    /// The predicate is called on two elements following themselves,\n+    /// it means the predicate is called on `slice[0]` and `slice[1]`\n+    /// then on `slice[1]` and `slice[2]` and so on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n+    ///\n+    /// let mut iter = slice.group_by(|a, b| a == b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+    /// assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+    #[inline]\n+    pub fn group_by<F>(&self, pred: F) -> GroupBy<T, F>\n+    where F: FnMut(&T, &T) -> bool\n+    {\n+        GroupBy {\n+            ptr: self.as_ptr(),\n+            end: unsafe { self.as_ptr().add(self.len()) },\n+            predicate: pred,\n+            _phantom: marker::PhantomData,\n+        }\n+    }\n+\n+    /// Returns an iterator over the slice producing non-overlapping mutable\n+    /// runs of elements using the predicate to separate them.\n+    ///\n+    /// The predicate is called on two elements following themselves,\n+    /// it means the predicate is called on `slice[0]` and `slice[1]`\n+    /// then on `slice[1]` and `slice[2]` and so on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];\n+    ///\n+    /// let mut iter = slice.group_by_mut(|a, b| a == b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_group_by\", issue = \"0\")]\n+    #[inline]\n+    pub fn group_by_mut<F>(&mut self, pred: F) -> GroupByMut<T, F>\n+    where F: FnMut(&T, &T) -> bool\n+    {\n+        GroupByMut {\n+            ptr: self.as_mut_ptr(),\n+            end: unsafe { self.as_mut_ptr().add(self.len()) },\n+            predicate: pred,\n+            _phantom: marker::PhantomData,\n+        }\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "1199fa4abbce996850a9ef2e81a6fba22a0ca7bf", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a891f6edfeb4d7b061a215ba160fca0e4804ffd2/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a891f6edfeb4d7b061a215ba160fca0e4804ffd2", "patch": "@@ -65,6 +65,7 @@\n #![feature(nonzero_leading_trailing_zeros)]\n #![feature(const_option)]\n #![feature(integer_atomics)]\n+#![feature(slice_group_by)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}]}