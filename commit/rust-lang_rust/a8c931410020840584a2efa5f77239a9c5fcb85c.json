{"sha": "a8c931410020840584a2efa5f77239a9c5fcb85c", "node_id": "C_kwDOAAsO6NoAKGE4YzkzMTQxMDAyMDg0MDU4NGEyZWZhNWY3NzIzOWE5YzVmY2I4NWM", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T21:44:48Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T21:44:48Z"}, "message": "remove implicit .await from `core::future::join`", "tree": {"sha": "d3f06e850829622313c288895591285784d75aab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3f06e850829622313c288895591285784d75aab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8c931410020840584a2efa5f77239a9c5fcb85c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c931410020840584a2efa5f77239a9c5fcb85c", "html_url": "https://github.com/rust-lang/rust/commit/a8c931410020840584a2efa5f77239a9c5fcb85c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8c931410020840584a2efa5f77239a9c5fcb85c/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d07cef22b0397eee2649807cd1dddf6d983e215f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d07cef22b0397eee2649807cd1dddf6d983e215f", "html_url": "https://github.com/rust-lang/rust/commit/d07cef22b0397eee2649807cd1dddf6d983e215f"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "bed9f3dd51cc5184acba31bbf7cf7e45c44bfa3b", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a8c931410020840584a2efa5f77239a9c5fcb85c/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c931410020840584a2efa5f77239a9c5fcb85c/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=a8c931410020840584a2efa5f77239a9c5fcb85c", "patch": "@@ -22,7 +22,7 @@ use crate::task::Poll;\n /// async fn two() -> usize { 2 }\n ///\n /// # let _ =  async {\n-/// let x = join!(one(), two());\n+/// let x = join!(one(), two()).await;\n /// assert_eq!(x, (1, 2));\n /// # };\n /// ```\n@@ -39,7 +39,7 @@ use crate::task::Poll;\n /// async fn three() -> usize { 3 }\n ///\n /// # let _ = async {\n-/// let x = join!(one(), two(), three());\n+/// let x = join!(one(), two(), three()).await;\n /// assert_eq!(x, (1, 2, 3));\n /// # };\n /// ```\n@@ -71,61 +71,63 @@ pub macro join {\n         },\n         @rest: ()\n     ) => {{\n-        // The futures and whether they have completed\n-        let mut state = ( $( UnsafeCell::new(($fut, false)), )* );\n+        async move {\n+            // The futures and whether they have completed\n+            let mut state = ( $( UnsafeCell::new(($fut, false)), )* );\n \n-        // Make sure the futures don't panic\n-        // if polled after completion, and\n-        // store their output separately\n-        let mut futures = ($(\n-            ({\n-                let ( $($pos,)* state, .. ) = &state;\n+            // Make sure the futures don't panic\n+            // if polled after completion, and\n+            // store their output separately\n+            let mut futures = ($(\n+                ({\n+                    let ( $($pos,)* state, .. ) = &state;\n \n-                poll_fn(move |cx| {\n-                    // SAFETY: each future borrows a distinct element\n-                    // of the tuple\n-                    let (fut, done) = unsafe { &mut *state.get() };\n+                    poll_fn(move |cx| {\n+                        // SAFETY: each future borrows a distinct element\n+                        // of the tuple\n+                        let (fut, done) = unsafe { &mut *state.get() };\n \n-                    if *done {\n-                        return Poll::Ready(None)\n-                    }\n+                        if *done {\n+                            return Poll::Ready(None)\n+                        }\n \n-                    // SAFETY: The futures are never moved\n-                    match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n-                        Poll::Ready(val) => {\n-                            *done = true;\n-                            Poll::Ready(Some(val))\n+                        // SAFETY: The futures are never moved\n+                        match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n+                            Poll::Ready(val) => {\n+                                *done = true;\n+                                Poll::Ready(Some(val))\n+                            }\n+                            Poll::Pending => Poll::Pending\n                         }\n-                        Poll::Pending => Poll::Pending\n-                    }\n-                })\n-            }, None),\n-        )*);\n+                    })\n+                }, None),\n+            )*);\n \n-        poll_fn(move |cx| {\n-            let mut done = true;\n+            poll_fn(move |cx| {\n+                let mut done = true;\n \n-            $(\n-                let ( $($pos,)* (fut, out), .. ) = &mut futures;\n+                $(\n+                    let ( $($pos,)* (fut, out), .. ) = &mut futures;\n \n-                // SAFETY: The futures are never moved\n-                match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n-                    Poll::Ready(Some(val)) => *out = Some(val),\n-                    // the future was already done\n-                    Poll::Ready(None) => {},\n-                    Poll::Pending => done = false,\n-                }\n-            )*\n+                    // SAFETY: The futures are never moved\n+                    match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n+                        Poll::Ready(Some(val)) => *out = Some(val),\n+                        // the future was already done\n+                        Poll::Ready(None) => {},\n+                        Poll::Pending => done = false,\n+                    }\n+                )*\n \n-            if done {\n-                // Extract all the outputs\n-                Poll::Ready(($({\n-                    let ( $($pos,)* (_, val), .. ) = &mut futures;\n-                    val.unwrap()\n-                }),*))\n-            } else {\n-                Poll::Pending\n-            }\n-        }).await\n+                if done {\n+                    // Extract all the outputs\n+                    Poll::Ready(($({\n+                        let ( $($pos,)* (_, val), .. ) = &mut futures;\n+                        val.unwrap()\n+                    }),*))\n+                } else {\n+                    Poll::Pending\n+                }\n+            }).await\n+        }\n     }}\n }"}, {"sha": "73249b1b8a4355d899df06664e84a40e11751aa5", "filename": "library/core/tests/future.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8c931410020840584a2efa5f77239a9c5fcb85c/library%2Fcore%2Ftests%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8c931410020840584a2efa5f77239a9c5fcb85c/library%2Fcore%2Ftests%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffuture.rs?ref=a8c931410020840584a2efa5f77239a9c5fcb85c", "patch": "@@ -32,13 +32,13 @@ fn poll_n(val: usize, num: usize) -> PollN {\n #[test]\n fn test_join() {\n     block_on(async move {\n-        let x = join!(async { 0 });\n+        let x = join!(async { 0 }).await;\n         assert_eq!(x, 0);\n \n-        let x = join!(async { 0 }, async { 1 });\n+        let x = join!(async { 0 }, async { 1 }).await;\n         assert_eq!(x, (0, 1));\n \n-        let x = join!(async { 0 }, async { 1 }, async { 2 });\n+        let x = join!(async { 0 }, async { 1 }, async { 2 }).await;\n         assert_eq!(x, (0, 1, 2));\n \n         let x = join!(\n@@ -50,8 +50,17 @@ fn test_join() {\n             poll_n(5, 3),\n             poll_n(6, 4),\n             poll_n(7, 1)\n-        );\n+        )\n+        .await;\n         assert_eq!(x, (0, 1, 2, 3, 4, 5, 6, 7));\n+\n+        let y = String::new();\n+        let x = join!(async {\n+            println!(\"{}\", &y);\n+            1\n+        })\n+        .await;\n+        assert_eq!(x, 1);\n     });\n }\n "}]}