{"sha": "c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "node_id": "C_kwDOAAsO6NoAKGM2MjY2NWUwOWMxMWViMWM5ZDhlYTAyZGY1YjcyMzM2NGEwYjhiYTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T15:58:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-26T15:58:08Z"}, "message": "Auto merge of #107328 - matthiaskrgr:rollup-lfqwo0o, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #106904 (Preserve split DWARF files when building archives.)\n - #106971 (Handle diagnostics customization on the fluent side (for one specific diagnostic))\n - #106978 (Migrate mir_build's borrow conflicts)\n - #107150 (`ty::tls` cleanups)\n - #107168 (Use a type-alias-impl-trait in `ObligationForest`)\n - #107189 (Encode info for Adt in a single place.)\n - #107322 (Custom mir: Add support for some remaining, easy to support constructs)\n - #107323 (Disable ConstGoto opt in cleanup blocks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a0c4d3611f56418397a874d965fe908390481843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0c4d3611f56418397a874d965fe908390481843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "html_url": "https://github.com/rust-lang/rust/commit/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0", "html_url": "https://github.com/rust-lang/rust/commit/3e977638728922d3a6cc7bea34a2fdb8ae97f7c0"}, {"sha": "4ed8cfc2024a86aa18783a86e9ed51adeef12a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed8cfc2024a86aa18783a86e9ed51adeef12a63", "html_url": "https://github.com/rust-lang/rust/commit/4ed8cfc2024a86aa18783a86e9ed51adeef12a63"}], "stats": {"total": 1252, "additions": 641, "deletions": 611}, "files": [{"sha": "e0e814cfc0ac812e94655a920a909da4809555bb", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -367,18 +367,6 @@ fn check_opaque_type_parameter_valid(\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n         let arg_is_param = match arg.unpack() {\n             GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n             GenericArgKind::Lifetime(lt) => {\n                 matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n             }"}, {"sha": "4ac7bea03ebc01e7a77abcfb8597673e3bf0d3ca", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -1301,12 +1301,6 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> (bool, bool) {\n         return (false, false);\n     }\n \n-    // If we're only producing artifacts that are archives, no need to preserve\n-    // the objects as they're losslessly contained inside the archives.\n-    if sess.crate_types().iter().all(|&x| x.is_archive()) {\n-        return (false, false);\n-    }\n-\n     match (sess.split_debuginfo(), sess.opts.unstable_opts.split_dwarf_kind) {\n         // If there is no split debuginfo then do not preserve objects.\n         (SplitDebuginfo::Off, _) => (false, false),"}, {"sha": "dda422c6dd07ee60cb67674282b657d053976890", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -139,8 +139,7 @@ pub enum ProcessResult<O, E> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n struct ObligationTreeId(usize);\n \n-type ObligationTreeIdGenerator =\n-    std::iter::Map<std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n+type ObligationTreeIdGenerator = impl Iterator<Item = ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to [Self::process_obligations],"}, {"sha": "0021638c10268c9ce5fcf68c7ffac5d0793d570c", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -123,4 +123,7 @@ borrowck_cannot_move_when_borrowed =\n \n borrowck_opaque_type_non_generic_param =\n     expected generic {$kind} parameter, found `{$ty}`\n-    .label = this generic parameter must be used with a generic {$kind} parameter\n+    .label = {STREQ($ty, \"'static\") ->\n+        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+        *[other] this generic parameter must be used with a generic {$kind} parameter\n+    }"}, {"sha": "bcc1d9002dfdebe040e00726a48a8a34dceac576", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -147,8 +147,6 @@ infer_region_explanation = {$pref_kind ->\n }{$desc_kind ->\n     *[should_not_happen] [{$desc_kind}]\n     [restatic] the static lifetime\n-    [reempty] the empty lifetime\n-    [reemptyuni] the empty lifetime in universe {$desc_arg}\n     [revar] lifetime {$desc_arg}\n \n     [as_defined] the lifetime `{$desc_arg}` as defined here"}, {"sha": "f9bda721df34dcb30830c092aa5dd918691c8b9b", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -299,10 +299,18 @@ mir_build_borrow_of_moved_value = borrow of moved value\n     .suggestion = borrow this binding in the pattern to avoid moving the value\n \n mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n-    .label = first mutable borrow, by `{$name}`, occurs here\n-    .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n-    .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n-    .moved = also moved into `{$name_moved}` here\n+\n+mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n+\n+mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n+\n+mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n+\n+mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n+\n+mir_build_borrow = value is borrowed by `{$name}` here\n+\n+mir_build_moved = value is moved into `{$name}` here\n \n mir_build_union_pattern = cannot use unions in constant patterns\n "}, {"sha": "f053bdc3809be30d5377cae4abc3960f503644b9", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -182,6 +182,9 @@ pub fn fluent_bundle(\n     trace!(?locale);\n     let mut bundle = new_bundle(vec![locale]);\n \n+    // Add convenience functions available to ftl authors.\n+    register_functions(&mut bundle);\n+\n     // Fluent diagnostics can insert directionality isolation markers around interpolated variables\n     // indicating that there may be a shift from right-to-left to left-to-right text (or\n     // vice-versa). These are disabled because they are sometimes visible in the error output, but\n@@ -244,6 +247,15 @@ pub fn fluent_bundle(\n     Ok(Some(bundle))\n }\n \n+fn register_functions(bundle: &mut FluentBundle) {\n+    bundle\n+        .add_function(\"STREQ\", |positional, _named| match positional {\n+            [FluentValue::String(a), FluentValue::String(b)] => format!(\"{}\", (a == b)).into(),\n+            _ => FluentValue::Error,\n+        })\n+        .expect(\"Failed to add a function to the bundle.\");\n+}\n+\n /// Type alias for the result of `fallback_fluent_bundle` - a reference-counted pointer to a lazily\n /// evaluated fluent bundle.\n pub type LazyFallbackBundle = Lrc<Lazy<FluentBundle, impl FnOnce() -> FluentBundle>>;\n@@ -256,6 +268,9 @@ pub fn fallback_fluent_bundle(\n ) -> LazyFallbackBundle {\n     Lrc::new(Lazy::new(move || {\n         let mut fallback_bundle = new_bundle(vec![langid!(\"en-US\")]);\n+\n+        register_functions(&mut fallback_bundle);\n+\n         // See comment in `fluent_bundle`.\n         fallback_bundle.set_use_isolating(with_directionality_markers);\n "}, {"sha": "29eba278750b1299c434d73570f05c518aab76eb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 45, "deletions": 113, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -38,7 +38,6 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_target::abi::VariantIdx;\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -1189,8 +1188,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n-                let params_in_repr = self.tcx.params_in_repr(def_id);\n-                record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+                self.encode_info_for_adt(def_id);\n             }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n@@ -1213,46 +1211,53 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn encode_info_for_adt(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n-        let variant = &def.variant(index);\n-        let def_id = variant.def_id;\n-        debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+        let adt_def = tcx.adt_def(def_id);\n+        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n-            assert!(f.did.is_local());\n-            f.did.index\n-        }));\n-        if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+        let params_in_repr = self.tcx.params_in_repr(def_id);\n+        record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+\n+        if adt_def.is_enum() {\n+            record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                for variant in tcx.adt_def(def_id).variants() {\n+                    yield variant.def_id.index;\n+                    // Encode constructors which take a separate slot in value namespace.\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        yield ctor_def_id.index;\n+                    }\n+                }\n+            ));\n+        } else {\n+            // For non-enum, there is only one variant, and its def_id is the adt's.\n+            debug_assert_eq!(adt_def.variants().len(), 1);\n+            debug_assert_eq!(adt_def.non_enum_variant().def_id, def_id);\n+            // Therefore, the loop over variants will encode its fields as the adt's children.\n         }\n-    }\n \n-    fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n-        let variant = &def.variant(index);\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n+        for variant in adt_def.variants().iter() {\n+            let data = VariantData {\n+                discr: variant.discr,\n+                ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n+                is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+            };\n+            record!(self.tables.variant_data[variant.def_id] <- data);\n \n-        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n+                assert!(f.did.is_local());\n+                f.did.index\n+            }));\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n+            if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n+                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                let fn_sig = tcx.fn_sig(ctor_def_id);\n+                record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n+                // FIXME only encode signature for ctor_def_id\n+                record!(self.tables.fn_sig[variant.def_id] <- fn_sig);\n+            }\n         }\n     }\n \n@@ -1305,25 +1310,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        let variant = adt_def.non_enum_variant();\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n-\n-        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n-        }\n-    }\n-\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n@@ -1532,33 +1518,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n                 }\n             }\n-            hir::ItemKind::Enum(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                self.tables.constness.set(def_id.index, hir::Constness::Const);\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n@@ -1597,31 +1556,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n-                    for variant in tcx.adt_def(def_id).variants() {\n-                        yield variant.def_id.index;\n-                        // Encode constructors which take a separate slot in value namespace.\n-                        if let Some(ctor_def_id) = variant.ctor_def_id() {\n-                            yield ctor_def_id.index;\n-                        }\n-                    }\n-                ))\n-            }\n-            hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record_array!(self.tables.children[def_id] <-\n-                    self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    })\n-                )\n-            }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record_array!(self.tables.children[def_id] <-\n@@ -1649,17 +1592,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // so it's easier to do that here then to wait until we would encounter\n         // normally in the visitor walk.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                for (i, _) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-                    self.encode_enum_variant_ctor(def, i);\n-                }\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                self.encode_struct_ctor(def);\n-            }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n                     self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()"}, {"sha": "95148de251824ad0aceb5dbe48777fcbceaeddbc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -43,6 +43,7 @@\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(type_alias_impl_trait)]\n+#![feature(strict_provenance)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]"}, {"sha": "a60c55e8af4d2305571698677e720600568596a1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 178, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -2,6 +2,8 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n+pub mod tls;\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n@@ -1212,178 +1214,6 @@ CloneLiftImpls! { for<'tcx> {\n     Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n } }\n \n-pub mod tls {\n-    use super::{ptr_eq, GlobalCtxt, TyCtxt};\n-\n-    use crate::dep_graph::TaskDepsRef;\n-    use crate::ty::query;\n-    use rustc_data_structures::sync::{self, Lock};\n-    use rustc_errors::Diagnostic;\n-    use std::mem;\n-    use thin_vec::ThinVec;\n-\n-    #[cfg(not(parallel_compiler))]\n-    use std::cell::Cell;\n-\n-    #[cfg(parallel_compiler)]\n-    use rustc_rayon_core as rayon_core;\n-\n-    /// This is the implicit state of rustc. It contains the current\n-    /// `TyCtxt` and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a `TyCtxt` value available\n-    /// you should also have access to an `ImplicitCtxt` through the functions\n-    /// in this module.\n-    #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current `TyCtxt`.\n-        pub tcx: TyCtxt<'tcx>,\n-\n-        /// The current query job, if any. This is updated by `JobOwner::start` in\n-        /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<query::QueryJobId>,\n-\n-        /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n-        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n-\n-        /// Used to prevent queries from calling too deeply.\n-        pub query_depth: usize,\n-\n-        /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them.\n-        pub task_deps: TaskDepsRef<'a>,\n-    }\n-\n-    impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n-        pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n-            let tcx = TyCtxt { gcx };\n-            ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                query_depth: 0,\n-                task_deps: TaskDepsRef::Ignore,\n-            }\n-        }\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        rayon_core::tlv::with(value, f)\n-    }\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    pub fn get_tlv() -> usize {\n-        rayon_core::tlv::get()\n-    }\n-\n-    #[cfg(not(parallel_compiler))]\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<usize> = const { Cell::new(0) };\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        let old = get_tlv();\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n-        TLV.with(|tlv| tlv.set(value));\n-        f()\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn get_tlv() -> usize {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n-    #[inline]\n-    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        set_tlv(context as *const _ as usize, || f(&context))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n-    #[inline]\n-    pub fn with_context_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n-    {\n-        let context = get_tlv();\n-        if context == 0 {\n-            f(None)\n-        } else {\n-            // We could get an `ImplicitCtxt` pointer from another thread.\n-            // Ensure that `ImplicitCtxt` is `Sync`.\n-            sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n-\n-            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n-        }\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_context<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n-    /// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n-    /// as the `TyCtxt` passed in.\n-    /// This will panic if you pass it a `TyCtxt` which is different from the current\n-    /// `ImplicitCtxt`'s `tcx` field.\n-    #[inline]\n-    pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n-    {\n-        with_context(|context| unsafe {\n-            assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-            let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-            f(context)\n-        })\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        with_context(|context| f(context.tcx))\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// The closure is passed None if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n-    }\n-}\n-\n macro_rules! sty_debug_print {\n     ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n@@ -2416,12 +2246,6 @@ pub struct DeducedParamAttrs {\n     pub read_only: bool,\n }\n \n-// We are comparing types with different invariant lifetimes, so `ptr::eq`\n-// won't work for us.\n-fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n-    t as *const () == u as *const ()\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);"}, {"sha": "71b025dc1be4b6523d343cdc3269508141a92560", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -0,0 +1,187 @@\n+use super::{GlobalCtxt, TyCtxt};\n+\n+use crate::dep_graph::TaskDepsRef;\n+use crate::ty::query;\n+use rustc_data_structures::sync::{self, Lock};\n+use rustc_errors::Diagnostic;\n+use std::mem;\n+use std::ptr;\n+use thin_vec::ThinVec;\n+\n+/// This is the implicit state of rustc. It contains the current\n+/// `TyCtxt` and query. It is updated when creating a local interner or\n+/// executing a new query. Whenever there's a `TyCtxt` value available\n+/// you should also have access to an `ImplicitCtxt` through the functions\n+/// in this module.\n+#[derive(Clone)]\n+pub struct ImplicitCtxt<'a, 'tcx> {\n+    /// The current `TyCtxt`.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The current query job, if any. This is updated by `JobOwner::start` in\n+    /// `ty::query::plumbing` when executing a query.\n+    pub query: Option<query::QueryJobId>,\n+\n+    /// Where to store diagnostics for the current query job, if any.\n+    /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n+    pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n+    /// Used to prevent queries from calling too deeply.\n+    pub query_depth: usize,\n+\n+    /// The current dep graph task. This is used to add dependencies to queries\n+    /// when executing them.\n+    pub task_deps: TaskDepsRef<'a>,\n+}\n+\n+impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n+    pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n+        let tcx = TyCtxt { gcx };\n+        ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            query_depth: 0,\n+            task_deps: TaskDepsRef::Ignore,\n+        }\n+    }\n+}\n+\n+#[cfg(parallel_compiler)]\n+mod tlv {\n+    use rustc_rayon_core as rayon_core;\n+    use std::ptr;\n+\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        ptr::from_exposed_addr(rayon_core::tlv::get())\n+    }\n+\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n+    /// to `value` during the call to `f`. It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        rayon_core::tlv::with(value.expose_addr(), f)\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+mod tlv {\n+    use std::cell::Cell;\n+    use std::ptr;\n+\n+    thread_local! {\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+        static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n+    }\n+\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        TLV.with(|tlv| tlv.get())\n+    }\n+\n+    /// Sets TLV to `value` during the call to `f`.\n+    /// It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        let old = get_tlv();\n+        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        TLV.with(|tlv| tlv.set(value));\n+        f()\n+    }\n+}\n+\n+#[inline]\n+fn erase(context: &ImplicitCtxt<'_, '_>) -> *const () {\n+    context as *const _ as *const ()\n+}\n+\n+#[inline]\n+unsafe fn downcast<'a, 'tcx>(context: *const ()) -> &'a ImplicitCtxt<'a, 'tcx> {\n+    &*(context as *const ImplicitCtxt<'a, 'tcx>)\n+}\n+\n+/// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n+#[inline]\n+pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    tlv::with_tlv(erase(context), || f(&context))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n+#[inline]\n+pub fn with_context_opt<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n+{\n+    let context = tlv::get_tlv();\n+    if context.is_null() {\n+        f(None)\n+    } else {\n+        // We could get an `ImplicitCtxt` pointer from another thread.\n+        // Ensure that `ImplicitCtxt` is `Sync`.\n+        sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n+\n+        unsafe { f(Some(downcast(context))) }\n+    }\n+}\n+\n+/// Allows access to the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_context<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n+/// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n+/// as the `TyCtxt` passed in.\n+/// This will panic if you pass it a `TyCtxt` which is different from the current\n+/// `ImplicitCtxt`'s `tcx` field.\n+#[inline]\n+pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n+{\n+    with_context(|context| {\n+        // The two gcx have different invariant lifetimes, so we need to erase them for the comparison.\n+        assert!(ptr::eq(\n+            context.tcx.gcx as *const _ as *const (),\n+            tcx.gcx as *const _ as *const ()\n+        ));\n+\n+        let context: &ImplicitCtxt<'_, '_> = unsafe { mem::transmute(context) };\n+\n+        f(context)\n+    })\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+{\n+    with_context(|context| f(context.tcx))\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// The closure is passed None if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_opt<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n+}"}, {"sha": "dbba529aef7a5ea6adbf1959bd923111b42db8fd", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -18,6 +18,9 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_storage_dead\", args) => {\n                 Ok(StatementKind::StorageDead(self.parse_local(args[0])?))\n             },\n+            @call(\"mir_deinit\", args) => {\n+                Ok(StatementKind::Deinit(Box::new(self.parse_place(args[0])?)))\n+            },\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n@@ -141,6 +144,14 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"rvalue\",\n             @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n+            @call(\"mir_checked\", args) => {\n+                parse_by_kind!(self, args[0], _, \"binary op\",\n+                    ExprKind::Binary { op, lhs, rhs } => Ok(Rvalue::CheckedBinaryOp(\n+                        *op, Box::new((self.parse_operand(*lhs)?, self.parse_operand(*rhs)?))\n+                    )),\n+                )\n+            },\n+            @call(\"mir_len\", args) => Ok(Rvalue::Len(self.parse_place(args[0])?)),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -153,6 +164,9 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             ExprKind::Unary { op, arg } => Ok(\n                 Rvalue::UnaryOp(*op, self.parse_operand(*arg)?)\n             ),\n+            ExprKind::Repeat { value, count } => Ok(\n+                Rvalue::Repeat(self.parse_operand(*value)?, *count)\n+            ),\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "ced251267d36f9deb95438e76ca848604a6b8b3a", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -600,32 +600,56 @@ pub struct BorrowOfMovedValue<'tcx> {\n pub struct MultipleMutBorrows {\n     #[primary_span]\n     pub span: Span,\n-    #[label]\n-    pub binding_span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<MultipleMutBorrowOccurence>,\n-    pub name: Ident,\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_already_borrowed)]\n+pub struct AlreadyBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_already_mut_borrowed)]\n+pub struct AlreadyMutBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_moved_while_borrowed)]\n+pub struct MovedWhileBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n }\n \n #[derive(Subdiagnostic)]\n-pub enum MultipleMutBorrowOccurence {\n-    #[label(mutable_borrow)]\n-    Mutable {\n+pub enum Conflict {\n+    #[label(mir_build_mutable_borrow)]\n+    Mut {\n         #[primary_span]\n         span: Span,\n-        name_mut: Ident,\n+        name: Ident,\n     },\n-    #[label(immutable_borrow)]\n-    Immutable {\n+    #[label(mir_build_borrow)]\n+    Ref {\n         #[primary_span]\n         span: Span,\n-        name_immut: Ident,\n+        name: Ident,\n     },\n-    #[label(moved)]\n+    #[label(mir_build_moved)]\n     Moved {\n         #[primary_span]\n         span: Span,\n-        name_moved: Ident,\n+        name: Ident,\n     },\n }\n "}, {"sha": "2640ca56b00e9764bdab912961dfa530798e3aac", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -926,58 +926,55 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     sub.each_binding(|_, hir_id, span, name| {\n         match typeck_results.extract_binding_mode(sess, hir_id, span) {\n             Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n-                (Mutability::Not, Mutability::Not) => {} // Both sides are `ref`.\n-                (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n-                _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n+                // Both sides are `ref`.\n+                (Mutability::Not, Mutability::Not) => {}\n+                // 2x `ref mut`.\n+                (Mutability::Mut, Mutability::Mut) => {\n+                    conflicts_mut_mut.push(Conflict::Mut { span, name })\n+                }\n+                (Mutability::Not, Mutability::Mut) => {\n+                    conflicts_mut_ref.push(Conflict::Mut { span, name })\n+                }\n+                (Mutability::Mut, Mutability::Not) => {\n+                    conflicts_mut_ref.push(Conflict::Ref { span, name })\n+                }\n             },\n             Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n-                conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n+                conflicts_move.push(Conflict::Moved { span, name }) // `ref mut?` + by-move conflict.\n             }\n             Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n         }\n     });\n \n+    let report_mut_mut = !conflicts_mut_mut.is_empty();\n+    let report_mut_ref = !conflicts_mut_ref.is_empty();\n+    let report_move_conflict = !conflicts_move.is_empty();\n+\n+    let mut occurences = match mut_outer {\n+        Mutability::Mut => vec![Conflict::Mut { span: binding_span, name }],\n+        Mutability::Not => vec![Conflict::Ref { span: binding_span, name }],\n+    };\n+    occurences.extend(conflicts_mut_mut);\n+    occurences.extend(conflicts_mut_ref);\n+    occurences.extend(conflicts_move);\n+\n     // Report errors if any.\n-    if !conflicts_mut_mut.is_empty() {\n+    if report_mut_mut {\n         // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-        let mut occurences = vec![];\n-\n-        for (span, name_mut) in conflicts_mut_mut {\n-            occurences.push(MultipleMutBorrowOccurence::Mutable { span, name_mut });\n-        }\n-        for (span, name_immut) in conflicts_mut_ref {\n-            occurences.push(MultipleMutBorrowOccurence::Immutable { span, name_immut });\n-        }\n-        for (span, name_moved) in conflicts_move {\n-            occurences.push(MultipleMutBorrowOccurence::Moved { span, name_moved });\n-        }\n-        sess.emit_err(MultipleMutBorrows { span: pat.span, binding_span, occurences, name });\n-    } else if !conflicts_mut_ref.is_empty() {\n+        sess.emit_err(MultipleMutBorrows { span: pat.span, occurences });\n+    } else if report_mut_ref {\n         // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n-        let (primary, also) = match mut_outer {\n-            Mutability::Mut => (\"mutable\", \"immutable\"),\n-            Mutability::Not => (\"immutable\", \"mutable\"),\n+        match mut_outer {\n+            Mutability::Mut => {\n+                sess.emit_err(AlreadyMutBorrowed { span: pat.span, occurences });\n+            }\n+            Mutability::Not => {\n+                sess.emit_err(AlreadyBorrowed { span: pat.span, occurences });\n+            }\n         };\n-        let msg =\n-            format!(\"cannot borrow value as {} because it is also borrowed as {}\", also, primary);\n-        let mut err = sess.struct_span_err(pat.span, &msg);\n-        err.span_label(binding_span, format!(\"{} borrow, by `{}`, occurs here\", primary, name));\n-        for (span, name) in conflicts_mut_ref {\n-            err.span_label(span, format!(\"{} borrow, by `{}`, occurs here\", also, name));\n-        }\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"also moved into `{}` here\", name));\n-        }\n-        err.emit();\n-    } else if !conflicts_move.is_empty() {\n+    } else if report_move_conflict {\n         // Report by-ref and by-move conflicts, e.g. `ref x @ y`.\n-        let mut err =\n-            sess.struct_span_err(pat.span, \"cannot move out of value because it is borrowed\");\n-        err.span_label(binding_span, format!(\"value borrowed, by `{}`, here\", name));\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"value moved into `{}` here\", name));\n-        }\n-        err.emit();\n+        sess.emit_err(MovedWhileBorrowed { span: pat.span, occurences });\n     }\n }\n "}, {"sha": "da101ca7ad279e32a64967ba76fa7ef75c999d2e", "filename": "compiler/rustc_mir_transform/src/const_goto.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -57,6 +57,15 @@ impl<'tcx> MirPass<'tcx> for ConstGoto {\n }\n \n impl<'tcx> Visitor<'tcx> for ConstGotoOptimizationFinder<'_, 'tcx> {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        if data.is_cleanup {\n+            // Because of the restrictions around control flow in cleanup blocks, we don't perform\n+            // this optimization at all in such blocks.\n+            return;\n+        }\n+        self.super_basic_block_data(block, data);\n+    }\n+\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         let _: Option<_> = try {\n             let target = terminator.kind.as_goto()?;"}, {"sha": "706c97975f760e45b8f79b5166d8e3e500335d87", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -864,18 +864,6 @@ pub enum CrateType {\n     ProcMacro,\n }\n \n-impl CrateType {\n-    /// When generated, is this crate type an archive?\n-    pub fn is_archive(&self) -> bool {\n-        match *self {\n-            CrateType::Rlib | CrateType::Staticlib => true,\n-            CrateType::Executable | CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n-                false\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum Passes {\n     Some(Vec<String>),"}, {"sha": "3d7ccffa1735c97f5f54666aad381d06a22b5043", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -211,13 +211,16 @@\n //!\n //! #### Statements\n //!  - Assign statements work via normal Rust assignment.\n-//!  - [`Retag`] statements have an associated function.\n+//!  - [`Retag`], [`StorageLive`], [`StorageDead`], [`Deinit`] statements have an associated function.\n //!\n //! #### Rvalues\n //!\n //!  - Operands implicitly convert to `Use` rvalues.\n //!  - `&`, `&mut`, `addr_of!`, and `addr_of_mut!` all work to create their associated rvalue.\n-//!  - [`Discriminant`] has an associated function.\n+//!  - [`Discriminant`] and [`Len`] have associated functions.\n+//!  - Unary and binary operations use their normal Rust syntax - `a * b`, `!c`, etc.\n+//!  - Checked binary operations are represented by wrapping the associated binop in [`Checked`].\n+//!  - Array repetition syntax (`[foo; 10]`) creates the associated rvalue.\n //!\n //! #### Terminators\n //!\n@@ -261,6 +264,9 @@ define!(\"mir_drop_and_replace\", fn DropAndReplace<T>(place: T, value: T, goto: B\n define!(\"mir_call\", fn Call<T>(place: T, goto: BasicBlock, call: T));\n define!(\"mir_storage_live\", fn StorageLive<T>(local: T));\n define!(\"mir_storage_dead\", fn StorageDead<T>(local: T));\n+define!(\"mir_deinit\", fn Deinit<T>(place: T));\n+define!(\"mir_checked\", fn Checked<T>(binop: T) -> (T, bool));\n+define!(\"mir_len\", fn Len<T>(place: T) -> usize);\n define!(\"mir_retag\", fn Retag<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);"}, {"sha": "4c9212728859667b11e4ecb3ff2e0bf7b01051c4", "filename": "tests/mir-opt/building/custom/arrays.arrays.built.after.mir", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.arrays.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.arrays.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.arrays.built.after.mir?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -0,0 +1,14 @@\n+// MIR for `arrays` after built\n+\n+fn arrays() -> usize {\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/arrays.rs:+0:32: +0:37\n+    let mut _1: [i32; C];                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: usize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = [const 5_i32; C];           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _2 = Len(_1);                    // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _0 = _2;                         // scope 0 at $DIR/arrays.rs:+4:9: +4:16\n+        return;                          // scope 0 at $DIR/arrays.rs:+5:9: +5:17\n+    }\n+}"}, {"sha": "8e0a1fd7a4390bf87fb2fa38303088c080f83d06", "filename": "tests/mir-opt/building/custom/arrays.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Farrays.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -0,0 +1,19 @@\n+#![feature(custom_mir, core_intrinsics, inline_const)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR arrays.arrays.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn arrays<const C: usize>() -> usize {\n+    mir!({\n+        let x = [5_i32; C];\n+        let c = Len(x);\n+        RET = c;\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    assert_eq!(arrays::<20>(), 20);\n+}"}, {"sha": "eca5b792ec0a26ebaae0c0d4c1e07d2a2742b726", "filename": "tests/mir-opt/building/custom/enums.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -86,6 +86,7 @@ fn switch_option_repr(option: Bool) -> bool {\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n fn set_discr(option: &mut Option<()>) {\n     mir!({\n+        Deinit(*option);\n         SetDiscriminant(*option, 0);\n         Return()\n     })"}, {"sha": "6d07473658acefad878248a707c740c5ec7eb577", "filename": "tests/mir-opt/building/custom/enums.set_discr.built.after.mir", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,7 +4,8 @@ fn set_discr(_1: &mut Option<()>) -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/enums.rs:+0:39: +0:39\n \n     bb0: {\n-        discriminant((*_1)) = 0;         // scope 0 at $DIR/enums.rs:+2:9: +2:36\n-        return;                          // scope 0 at $DIR/enums.rs:+3:9: +3:17\n+        Deinit((*_1));                   // scope 0 at $DIR/enums.rs:+2:9: +2:24\n+        discriminant((*_1)) = 0;         // scope 0 at $DIR/enums.rs:+3:9: +3:36\n+        return;                          // scope 0 at $DIR/enums.rs:+4:9: +4:17\n     }\n }"}, {"sha": "cb43d5e6ed7c7e888c854bb4edffeabc101b9051", "filename": "tests/mir-opt/building/custom/operators.f.built.after.mir", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.f.built.after.mir?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -2,6 +2,7 @@\n \n fn f(_1: i32, _2: bool) -> i32 {\n     let mut _0: i32;                     // return place in scope 0 at $DIR/operators.rs:+0:30: +0:33\n+    let mut _3: (i32, bool);             // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n \n     bb0: {\n         _1 = Neg(_1);                    // scope 0 at $DIR/operators.rs:+2:9: +2:15\n@@ -20,7 +21,10 @@ fn f(_1: i32, _2: bool) -> i32 {\n         _2 = Le(_1, _1);                 // scope 0 at $DIR/operators.rs:+15:9: +15:19\n         _2 = Ge(_1, _1);                 // scope 0 at $DIR/operators.rs:+16:9: +16:19\n         _2 = Gt(_1, _1);                 // scope 0 at $DIR/operators.rs:+17:9: +17:18\n-        _0 = _1;                         // scope 0 at $DIR/operators.rs:+18:9: +18:16\n-        return;                          // scope 0 at $DIR/operators.rs:+19:9: +19:17\n+        _3 = CheckedAdd(_1, _1);         // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _2 = (_3.1: bool);               // scope 0 at $DIR/operators.rs:+19:9: +19:18\n+        _1 = (_3.0: i32);                // scope 0 at $DIR/operators.rs:+20:9: +20:18\n+        _0 = _1;                         // scope 0 at $DIR/operators.rs:+21:9: +21:16\n+        return;                          // scope 0 at $DIR/operators.rs:+22:9: +22:17\n     }\n }"}, {"sha": "db7a48317d9284896ee36f3148e08e4acaa5881f", "filename": "tests/mir-opt/building/custom/operators.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Foperators.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -22,6 +22,9 @@ pub fn f(a: i32, b: bool) -> i32 {\n         b = a <= a;\n         b = a >= a;\n         b = a > a;\n+        let res = Checked(a + a);\n+        b = res.1;\n+        a = res.0;\n         RET = a;\n         Return()\n     })"}, {"sha": "44cda0d3d117f8bfec9ff71bea889ee811153ba2", "filename": "tests/run-make-fulldeps/split-debuginfo/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -254,12 +254,12 @@ unpacked-remapped-single:\n \t$(RUSTC) $(UNSTABLEOPTS) -C split-debuginfo=unpacked -C debuginfo=2 \\\n \t\t-Z split-dwarf-kind=single --remap-path-prefix $(TMPDIR)=/a foo.rs -g\n \tobjdump -Wi $(TMPDIR)/foo | grep DW_AT_GNU_dwo_name | (! grep $(TMPDIR)) || exit 1\n-\tls $(TMPDIR)/*.o\n+\trm $(TMPDIR)/*.o\n \tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n \tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n \trm $(TMPDIR)/$(call BIN,foo)\n \n-unpacked-crosscrate: packed-crosscrate-split packed-crosscrate-single\n+unpacked-crosscrate: unpacked-crosscrate-split unpacked-crosscrate-single\n \n # - Debuginfo in `.dwo` files\n # - (bar) `.rlib` file created, contains `.dwo`"}, {"sha": "5835f06753bb11242967e095fead9a0a55b747b6", "filename": "tests/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,17 +4,17 @@ error: cannot borrow value as mutable because it is also borrowed as immutable\n LL |         ref foo @ [.., ref mut bar] => (),\n    |         -------^^^^^^^^-----------^\n    |         |              |\n-   |         |              mutable borrow, by `bar`, occurs here\n-   |         immutable borrow, by `foo`, occurs here\n+   |         |              value is mutably borrowed by `bar` here\n+   |         value is borrowed by `foo` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:120:9\n    |\n LL |         ref foo @ Some(box ref mut s) => (),\n    |         -------^^^^^^^^^^^^---------^\n    |         |                  |\n-   |         |                  mutable borrow, by `s`, occurs here\n-   |         immutable borrow, by `foo`, occurs here\n+   |         |                  value is mutably borrowed by `s` here\n+   |         value is borrowed by `foo` here\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:18:5"}, {"sha": "29cd6c45c34b58410d02148ea7ca9b83754a7ae4", "filename": "tests/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,8 +4,8 @@ error: cannot move out of value because it is borrowed\n LL |         Some(ref _y @ _z) => {}\n    |              ------^^^--\n    |              |        |\n-   |              |        value moved into `_z` here\n-   |              value borrowed, by `_y`, here\n+   |              |        value is moved into `_z` here\n+   |              value is borrowed by `_y` here\n \n error: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:19:14\n@@ -28,8 +28,8 @@ error: cannot move out of value because it is borrowed\n LL |         Some(ref mut _y @ _z) => {}\n    |              ----------^^^--\n    |              |            |\n-   |              |            value moved into `_z` here\n-   |              value borrowed, by `_y`, here\n+   |              |            value is moved into `_z` here\n+   |              value is mutably borrowed by `_y` here\n \n error: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:33:14"}, {"sha": "2c123b01e173e7c12f5217aebd80ef72001692f2", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,71 +4,71 @@ error: cannot move out of value because it is borrowed\n LL |     let ref a @ box b = Box::new(NC);\n    |         -----^^^^^^^-\n    |         |           |\n-   |         |           value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |           value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:34:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(nc());\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:36:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:38:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:42:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n    |         -----^^^^^^^---------\n    |         |           |\n-   |         |           mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:48:9\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n    |         ---------^^^^^^^-----\n    |         |               |\n-   |         |               immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |               value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:62:9\n    |\n LL |         ref mut a @ box ref b => {\n    |         ---------^^^^^^^-----\n    |         |               |\n-   |         |               immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |               value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:54:11\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n    |           ---------^^^^^^^-----\n    |           |               |\n-   |           |               immutable borrow, by `b`, occurs here\n-   |           mutable borrow, by `a`, occurs here\n+   |           |               value is borrowed by `b` here\n+   |           value is mutably borrowed by `a` here\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-at-and-box.rs:31:9"}, {"sha": "4f7fbc9e04b04591f7f3bf967ef57fbd64ffa8ec", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,234 +4,234 @@ error: cannot move out of value because it is borrowed\n LL |     let ref a @ b = U;\n    |         -----^^^-\n    |         |       |\n-   |         |       value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |       value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n    |         |                |              |\n-   |         |                |              value moved into `e` here\n-   |         |                value moved into `c` here\n-   |         value borrowed, by `a`, here\n+   |         |                |              value is moved into `e` here\n+   |         |                value is moved into `c` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                  -----^^^-----\n    |                  |       |\n-   |                  |       value moved into `c` here\n-   |                  value borrowed, by `b`, here\n+   |                  |       value is moved into `c` here\n+   |                  value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:26:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (U, U);\n    |                                 -----^^^-\n    |                                 |       |\n-   |                                 |       value moved into `e` here\n-   |                                 value borrowed, by `d`, here\n+   |                                 |       value is moved into `e` here\n+   |                                 value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:30:9\n    |\n LL |     let ref mut a @ [b, mut c] = [U, U];\n    |         ---------^^^^-^^-----^\n    |         |            |  |\n-   |         |            |  value moved into `c` here\n-   |         |            value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |            |  value is moved into `c` here\n+   |         |            value is moved into `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n    |\n LL |     let ref a @ b = u();\n    |         -----^^^-\n    |         |       |\n-   |         |       value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |       value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:9\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |         -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n    |         |                |              |\n-   |         |                |              value moved into `e` here\n-   |         |                value moved into `c` here\n-   |         value borrowed, by `a`, here\n+   |         |                |              value is moved into `e` here\n+   |         |                value is moved into `c` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                  -----^^^-----\n    |                  |       |\n-   |                  |       value moved into `c` here\n-   |                  value borrowed, by `b`, here\n+   |                  |       value is moved into `c` here\n+   |                  value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n    |                                 -----^^^-\n    |                                 |       |\n-   |                                 |       value moved into `e` here\n-   |                                 value borrowed, by `d`, here\n+   |                                 |       value is moved into `e` here\n+   |                                 value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:42:9\n    |\n LL |     let ref mut a @ [b, mut c] = [u(), u()];\n    |         ---------^^^^-^^-----^\n    |         |            |  |\n-   |         |            |  value moved into `c` here\n-   |         |            value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |            |  value is moved into `c` here\n+   |         |            value is moved into `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:47:9\n    |\n LL |         ref a @ Some(b) => {}\n    |         -----^^^^^^^^-^\n    |         |            |\n-   |         |            value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |            value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n    |         |                     |              |\n-   |         |                     |              value moved into `e` here\n-   |         |                     value moved into `c` here\n-   |         value borrowed, by `a`, here\n+   |         |                     |              value is moved into `e` here\n+   |         |                     value is moved into `c` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       -----^^^-----\n    |                       |       |\n-   |                       |       value moved into `c` here\n-   |                       value borrowed, by `b`, here\n+   |                       |       value is moved into `c` here\n+   |                       value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:52:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      -----^^^-\n    |                                      |       |\n-   |                                      |       value moved into `e` here\n-   |                                      value borrowed, by `d`, here\n+   |                                      |       value is moved into `e` here\n+   |                                      value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:59:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n    |         ---------^^^^^^^^^-^^-----^^\n    |         |                 |  |\n-   |         |                 |  value moved into `c` here\n-   |         |                 value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |                 |  value is moved into `c` here\n+   |         |                 value is moved into `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:64:9\n    |\n LL |         ref a @ Some(b) => {}\n    |         -----^^^^^^^^-^\n    |         |            |\n-   |         |            value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |            value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:9\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |         -----^^^^^^^^^^^^^^^^^-----^^^^^^^^^^-^^\n    |         |                     |              |\n-   |         |                     |              value moved into `e` here\n-   |         |                     value moved into `c` here\n-   |         value borrowed, by `a`, here\n+   |         |                     |              value is moved into `e` here\n+   |         |                     value is moved into `c` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                       -----^^^-----\n    |                       |       |\n-   |                       |       value moved into `c` here\n-   |                       value borrowed, by `b`, here\n+   |                       |       value is moved into `c` here\n+   |                       value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n    |                                      -----^^^-\n    |                                      |       |\n-   |                                      |       value moved into `e` here\n-   |                                      value borrowed, by `d`, here\n+   |                                      |       value is moved into `e` here\n+   |                                      value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:78:9\n    |\n LL |         ref mut a @ Some([b, mut c]) => {}\n    |         ---------^^^^^^^^^-^^-----^^\n    |         |                 |  |\n-   |         |                 |  value moved into `c` here\n-   |         |                 value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |                 |  value is moved into `c` here\n+   |         |                 value is moved into `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:11:11\n    |\n LL |     fn f1(ref a @ b: U) {}\n    |           -----^^^-\n    |           |       |\n-   |           |       value moved into `b` here\n-   |           value borrowed, by `a`, here\n+   |           |       value is moved into `b` here\n+   |           value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:11\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |           -----^^^^^^^^^^^^-----^^^^^^^^^^-^\n    |           |                |              |\n-   |           |                |              value moved into `e` here\n-   |           |                value moved into `c` here\n-   |           value borrowed, by `a`, here\n+   |           |                |              value is moved into `e` here\n+   |           |                value is moved into `c` here\n+   |           value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:20\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                    -----^^^-----\n    |                    |       |\n-   |                    |       value moved into `c` here\n-   |                    value borrowed, by `b`, here\n+   |                    |       value is moved into `c` here\n+   |                    value is borrowed by `b` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:35\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n    |                                   -----^^^-\n    |                                   |       |\n-   |                                   |       value moved into `e` here\n-   |                                   value borrowed, by `d`, here\n+   |                                   |       value is moved into `e` here\n+   |                                   value is borrowed by `d` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:20:11\n    |\n LL |     fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n    |           ---------^^^^-^^-----^\n    |           |            |  |\n-   |           |            |  value moved into `c` here\n-   |           |            value moved into `b` here\n-   |           value borrowed, by `a`, here\n+   |           |            |  value is moved into `c` here\n+   |           |            value is moved into `b` here\n+   |           value is mutably borrowed by `a` here\n \n error[E0382]: borrow of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:30:9"}, {"sha": "f51b5041858c6ac43f01a7811839e925e8119791", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,295 +4,295 @@ error: cannot borrow value as immutable because it is also borrowed as mutable\n LL |         ref mut z @ &mut Some(ref a) => {\n    |         ---------^^^^^^^^^^^^^-----^\n    |         |                     |\n-   |         |                     immutable borrow, by `a`, occurs here\n-   |         mutable borrow, by `z`, occurs here\n+   |         |                     value is borrowed by `a` here\n+   |         value is mutably borrowed by `z` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:33:9\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |         ---------^^^^-----------------^\n    |         |            |       |\n-   |         |            |       another mutable borrow, by `c`, occurs here\n-   |         |            also borrowed as immutable, by `b`, here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |            |       value is mutably borrowed by `c` here\n+   |         |            value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:33:22\n    |\n LL |     let ref mut a @ (ref b @ ref mut c) = u(); // sub-in-sub\n    |                      -----^^^---------\n    |                      |       |\n-   |                      |       mutable borrow, by `c`, occurs here\n-   |                      immutable borrow, by `b`, occurs here\n+   |                      |       value is mutably borrowed by `c` here\n+   |                      value is borrowed by `b` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:37:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |       value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:39:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |           value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:41:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow, by `c`, occurs here\n-   |         |        mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |        |          value is mutably borrowed by `c` here\n+   |         |        value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:43:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n    |         |            |      |\n-   |         |            |      immutable borrow, by `c`, occurs here\n-   |         |            immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |            |      value is borrowed by `c` here\n+   |         |            value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:46:9\n    |\n LL |     let ref mut a @ ref b = u();\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |           value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:51:9\n    |\n LL |     let ref a @ ref mut b = u();\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |       value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:57:9\n    |\n LL |     let ref mut a @ ref b = U;\n    |         ---------^^^-----\n    |         |           |\n-   |         |           immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |           value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:61:9\n    |\n LL |     let ref a @ ref mut b = U;\n    |         -----^^^---------\n    |         |       |\n-   |         |       mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |       value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:67:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |              value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:67:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) => {\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow, by `b`, occurs here\n-   |                                 mutable borrow, by `a`, occurs here\n+   |                                 |               value is borrowed by `b` here\n+   |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |          value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow, by `b`, occurs here\n-   |                                 immutable borrow, by `a`, occurs here\n+   |                                 |           value is mutably borrowed by `b` here\n+   |                                 value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:87:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |          value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:87:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { *b = U; false } => {}\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow, by `b`, occurs here\n-   |                                 immutable borrow, by `a`, occurs here\n+   |                                 |           value is mutably borrowed by `b` here\n+   |                                 value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:94:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |              value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:94:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { *a = Err(U); false } => {}\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow, by `b`, occurs here\n-   |                                 mutable borrow, by `a`, occurs here\n+   |                                 |               value is borrowed by `b` here\n+   |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:101:9\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |         -----^^^^^^---------^\n    |         |          |\n-   |         |          mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |          value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:101:33\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) if { drop(b); false } => {}\n    |                                 -----^^^^^^^---------^\n    |                                 |           |\n-   |                                 |           mutable borrow, by `b`, occurs here\n-   |                                 immutable borrow, by `a`, occurs here\n+   |                                 |           value is mutably borrowed by `b` here\n+   |                                 value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:109:9\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |         ---------^^^^^^-----^\n    |         |              |\n-   |         |              immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |              value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:109:33\n    |\n LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false } => {}\n    |                                 ---------^^^^^^^-----^\n    |                                 |               |\n-   |                                 |               immutable borrow, by `b`, occurs here\n-   |                                 mutable borrow, by `a`, occurs here\n+   |                                 |               value is borrowed by `b` here\n+   |                                 value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:117:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow, by `c`, occurs here\n-   |         |        mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |        |          value is mutably borrowed by `c` here\n+   |         |        value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow, by `c`, occurs here\n-   |         |        mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |        |          value is mutably borrowed by `c` here\n+   |         |        value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:129:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n    |         -----^^^^---------^^---------^\n    |         |        |          |\n-   |         |        |          mutable borrow, by `c`, occurs here\n-   |         |        mutable borrow, by `b`, occurs here\n-   |         immutable borrow, by `a`, occurs here\n+   |         |        |          value is mutably borrowed by `c` here\n+   |         |        value is mutably borrowed by `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:134:9\n    |\n LL |     let ref mut a @ (ref b, ref c) = (U, U);\n    |         ---------^^^^-----^^-----^\n    |         |            |      |\n-   |         |            |      immutable borrow, by `c`, occurs here\n-   |         |            immutable borrow, by `b`, occurs here\n-   |         mutable borrow, by `a`, occurs here\n+   |         |            |      value is borrowed by `c` here\n+   |         |            value is borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:22:11\n    |\n LL |     fn f1(ref a @ ref mut b: U) {}\n    |           -----^^^---------\n    |           |       |\n-   |           |       mutable borrow, by `b`, occurs here\n-   |           immutable borrow, by `a`, occurs here\n+   |           |       value is mutably borrowed by `b` here\n+   |           value is borrowed by `a` here\n \n error: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:24:11\n    |\n LL |     fn f2(ref mut a @ ref b: U) {}\n    |           ---------^^^-----\n    |           |           |\n-   |           |           immutable borrow, by `b`, occurs here\n-   |           mutable borrow, by `a`, occurs here\n+   |           |           value is borrowed by `b` here\n+   |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:26:11\n    |\n LL |     fn f3(ref a @ [ref b, ref mut mid @ .., ref c]: [U; 4]) {}\n    |           -----^^^^^^^^^^^----------------^^^^^^^^\n    |           |               |\n-   |           |               mutable borrow, by `mid`, occurs here\n-   |           immutable borrow, by `a`, occurs here\n+   |           |               value is mutably borrowed by `mid` here\n+   |           value is borrowed by `a` here\n \n error: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:22\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                      -----^^^-------------\n    |                      |       |           |\n-   |                      |       |           also moved into `c` here\n-   |                      |       mutable borrow, by `b`, occurs here\n-   |                      immutable borrow, by `a`, occurs here\n+   |                      |       |           value is moved into `c` here\n+   |                      |       value is mutably borrowed by `b` here\n+   |                      value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:30\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                              ---------^^^-\n    |                              |           |\n-   |                              |           value moved into `c` here\n-   |                              value borrowed, by `b`, here\n+   |                              |           value is moved into `c` here\n+   |                              value is mutably borrowed by `b` here\n \n error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:8:31"}, {"sha": "a0cb04a064e06dd05796771dedeafd28b6cea917", "filename": "tests/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,63 +4,63 @@ error: cannot borrow value as mutable more than once at a time\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:29:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:33:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:36:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:39:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n    |         ---------^^^---------\n    |         |           |\n-   |         |           another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |           value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:44:9\n    |\n LL |       let ref mut a @ (\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow, by `a`, occurs here\n+   |  _________value is mutably borrowed by `a` here\n    | |\n LL | |\n LL | |         ref mut b,\n-   | |         --------- another mutable borrow, by `b`, occurs here\n+   | |         --------- value is mutably borrowed by `b` here\n LL | |         [\n LL | |             ref mut c,\n-   | |             --------- another mutable borrow, by `c`, occurs here\n+   | |             --------- value is mutably borrowed by `c` here\n LL | |             ref mut d,\n-   | |             --------- another mutable borrow, by `d`, occurs here\n+   | |             --------- value is mutably borrowed by `d` here\n LL | |             ref e,\n-   | |             ----- also borrowed as immutable, by `e`, here\n+   | |             ----- value is borrowed by `e` here\n LL | |         ]\n LL | |     ) = (U, [U, U, U]);\n    | |_____^\n@@ -71,18 +71,18 @@ error: cannot borrow value as mutable more than once at a time\n LL |       let ref mut a @ (\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow, by `a`, occurs here\n+   |  _________value is mutably borrowed by `a` here\n    | |\n LL | |\n LL | |             ref mut b,\n-   | |             --------- another mutable borrow, by `b`, occurs here\n+   | |             --------- value is mutably borrowed by `b` here\n LL | |             [\n LL | |                 ref mut c,\n-   | |                 --------- another mutable borrow, by `c`, occurs here\n+   | |                 --------- value is mutably borrowed by `c` here\n LL | |                 ref mut d,\n-   | |                 --------- another mutable borrow, by `d`, occurs here\n+   | |                 --------- value is mutably borrowed by `d` here\n LL | |                 ref e,\n-   | |                 ----- also borrowed as immutable, by `e`, here\n+   | |                 ----- value is borrowed by `e` here\n LL | |             ]\n LL | |         ) = (u(), [u(), u(), u()]);\n    | |_________^\n@@ -157,103 +157,103 @@ error: cannot borrow value as mutable more than once at a time\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |              value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:76:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow, by `b`, occurs here\n-   |                                     first mutable borrow, by `a`, occurs here\n+   |                                     |               value is mutably borrowed by `b` here\n+   |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:82:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |              value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:82:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow, by `b`, occurs here\n-   |                                     first mutable borrow, by `a`, occurs here\n+   |                                     |               value is mutably borrowed by `b` here\n+   |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |              value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow, by `b`, occurs here\n-   |                                     first mutable borrow, by `a`, occurs here\n+   |                                     |               value is mutably borrowed by `b` here\n+   |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:9\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |         ---------^^^^^^---------^\n    |         |              |\n-   |         |              another mutable borrow, by `b`, occurs here\n-   |         first mutable borrow, by `a`, occurs here\n+   |         |              value is mutably borrowed by `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:37\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n    |                                     ---------^^^^^^^---------^\n    |                                     |               |\n-   |                                     |               another mutable borrow, by `b`, occurs here\n-   |                                     first mutable borrow, by `a`, occurs here\n+   |                                     |               value is mutably borrowed by `b` here\n+   |                                     value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:8:11\n    |\n LL |     fn f1(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n    |           |           |\n-   |           |           another mutable borrow, by `b`, occurs here\n-   |           first mutable borrow, by `a`, occurs here\n+   |           |           value is mutably borrowed by `b` here\n+   |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:10:11\n    |\n LL |     fn f2(ref mut a @ ref mut b: U) {}\n    |           ---------^^^---------\n    |           |           |\n-   |           |           another mutable borrow, by `b`, occurs here\n-   |           first mutable borrow, by `a`, occurs here\n+   |           |           value is mutably borrowed by `b` here\n+   |           value is mutably borrowed by `a` here\n \n error: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:13:9\n    |\n LL |           ref mut a @ [\n    |           ^--------\n    |           |\n-   |  _________first mutable borrow, by `a`, occurs here\n+   |  _________value is mutably borrowed by `a` here\n    | |\n LL | |\n LL | |             [ref b @ .., _],\n-   | |              ---------- also borrowed as immutable, by `b`, here\n+   | |              ---------- value is borrowed by `b` here\n LL | |             [_, ref mut mid @ ..],\n-   | |                 ---------------- another mutable borrow, by `mid`, occurs here\n+   | |                 ---------------- value is mutably borrowed by `mid` here\n LL | |             ..,\n LL | |             [..],\n LL | |         ] : [[U; 4]; 5]\n@@ -265,18 +265,18 @@ error: cannot borrow value as mutable more than once at a time\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                      ---------^^^-------------\n    |                      |           |           |\n-   |                      |           |           also moved into `c` here\n-   |                      |           another mutable borrow, by `b`, occurs here\n-   |                      first mutable borrow, by `a`, occurs here\n+   |                      |           |           value is moved into `c` here\n+   |                      |           value is mutably borrowed by `b` here\n+   |                      value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:21:34\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                                  ---------^^^-\n    |                                  |           |\n-   |                                  |           value moved into `c` here\n-   |                                  value borrowed, by `b`, here\n+   |                                  |           value is moved into `c` here\n+   |                                  value is mutably borrowed by `b` here\n \n error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:29:9"}, {"sha": "73ebbf48118daebf4cdd798f82374b856a949f5a", "filename": "tests/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -4,26 +4,26 @@ error: cannot move out of value because it is borrowed\n LL |     let ref a @ b = NotCopy;\n    |         -----^^^-\n    |         |       |\n-   |         |       value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |       value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:29:9\n    |\n LL |     let ref mut a @ b = NotCopy;\n    |         ---------^^^-\n    |         |           |\n-   |         |           value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |           value is moved into `b` here\n+   |         value is mutably borrowed by `a` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:34:12\n    |\n LL |         Ok(ref a @ b) | Err(b @ ref a) => {\n    |            -----^^^-\n    |            |       |\n-   |            |       value moved into `b` here\n-   |            value borrowed, by `a`, here\n+   |            |       value is moved into `b` here\n+   |            value is borrowed by `a` here\n \n error: borrow of moved value\n   --> $DIR/default-binding-modes-both-sides-independent.rs:34:29\n@@ -46,8 +46,8 @@ error: cannot move out of value because it is borrowed\n LL |         ref a @ b => {\n    |         -----^^^-\n    |         |       |\n-   |         |       value moved into `b` here\n-   |         value borrowed, by `a`, here\n+   |         |       value is moved into `b` here\n+   |         value is borrowed by `a` here\n \n error[E0382]: borrow of moved value\n   --> $DIR/default-binding-modes-both-sides-independent.rs:29:9"}, {"sha": "7b194259349b8c090f5d82d463fde2ad62897b80", "filename": "tests/ui/suggestions/ref-pattern-binding.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fref-pattern-binding.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -19,17 +19,17 @@ error: cannot move out of value because it is borrowed\n LL |     let ref _moved @ _from = String::from(\"foo\");\n    |         ----------^^^-----\n    |         |            |\n-   |         |            value moved into `_from` here\n-   |         value borrowed, by `_moved`, here\n+   |         |            value is moved into `_from` here\n+   |         value is borrowed by `_moved` here\n \n error: cannot move out of value because it is borrowed\n   --> $DIR/ref-pattern-binding.rs:15:9\n    |\n LL |     let ref _moved @ S { f } = S { f: String::from(\"foo\") };\n    |         ----------^^^^^^^-^^\n    |         |                |\n-   |         |                value moved into `f` here\n-   |         value borrowed, by `_moved`, here\n+   |         |                value is moved into `f` here\n+   |         value is borrowed by `_moved` here\n \n error: borrow of moved value\n   --> $DIR/ref-pattern-binding.rs:18:9"}, {"sha": "eeb5dca07f06a4bd86bc34fc0f2e2e26e5b8a7db", "filename": "tests/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -8,7 +8,7 @@ type X<'a> = impl Into<&'static str> + From<&'a str>;\n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n     //~^ WARNING unnecessary lifetime parameter\n     t\n-    //~^ ERROR non-defining opaque type use\n+    //~^ ERROR expected generic lifetime parameter, found `'static`\n }\n \n fn extend_lt<'a>(o: &'a str) -> &'static str {"}, {"sha": "94882597a62e6fd823ceb778ca1e5c18bebe16c8", "filename": "tests/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -6,7 +6,7 @@ LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n-error: non-defining opaque type use in defining scope\n+error[E0792]: expected generic lifetime parameter, found `'static`\n   --> $DIR/bounds-are-checked.rs:10:5\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n@@ -17,3 +17,4 @@ LL |     t\n \n error: aborting due to previous error; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0792`."}, {"sha": "e7b8567b9a217d7e629343116d52655ac114e04a", "filename": "tests/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -19,7 +19,7 @@ fn concrete_ty() -> OneTy<u32> {\n \n fn concrete_lifetime() -> OneLifetime<'static> {\n     6u32\n-    //~^ ERROR non-defining opaque type use in defining scope\n+    //~^ ERROR expected generic lifetime parameter, found `'static`\n }\n \n fn concrete_const() -> OneConst<{ 123 }> {"}, {"sha": "966fe823f024dd99e4f3e6d1e70688ffb674aa97", "filename": "tests/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c62665e09c11eb1c9d8ea02df5b723364a0b8ba4/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=c62665e09c11eb1c9d8ea02df5b723364a0b8ba4", "patch": "@@ -7,7 +7,7 @@ LL | type OneTy<T> = impl Debug;\n LL |     5u32\n    |     ^^^^\n \n-error: non-defining opaque type use in defining scope\n+error[E0792]: expected generic lifetime parameter, found `'static`\n   --> $DIR/generic_nondefining_use.rs:21:5\n    |\n LL | type OneLifetime<'a> = impl Debug;"}]}