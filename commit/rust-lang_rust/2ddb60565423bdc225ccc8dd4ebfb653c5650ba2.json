{"sha": "2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZGI2MDU2NTQyM2JkYzIyNWNjYzhkZDRlYmZiNjUzYzU2NTBiYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T06:46:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T06:46:58Z"}, "message": "auto merge of #13088 : thestinger/rust/hashmap, r=cmr\n\nCloses #5283", "tree": {"sha": "3d878e1f45ced463d7178aed9c4dff9cc19ebf01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d878e1f45ced463d7178aed9c4dff9cc19ebf01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "html_url": "https://github.com/rust-lang/rust/commit/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d9fdf71656aa51c65f167e19b0d8cb54023b05e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9fdf71656aa51c65f167e19b0d8cb54023b05e", "html_url": "https://github.com/rust-lang/rust/commit/3d9fdf71656aa51c65f167e19b0d8cb54023b05e"}, {"sha": "3829ac2a52f12b08501cb25d82de32f39fbe801e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3829ac2a52f12b08501cb25d82de32f39fbe801e", "html_url": "https://github.com/rust-lang/rust/commit/3829ac2a52f12b08501cb25d82de32f39fbe801e"}], "stats": {"total": 383, "additions": 203, "deletions": 180}, "files": [{"sha": "07f3181d218e591f0b21c37d4b8f32eeb66f6b4f", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -15,7 +15,7 @@\n \n use std::num::Bitwise;\n \n-#[deriving(Clone, Eq, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "5ec5db45f275fcac2687354f44fbc82366bf65b4", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -12,7 +12,7 @@\n \n use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use std::clone::Clone;\n-use std::cmp::{Eq, Equiv, max};\n+use std::cmp::{Eq, TotalEq, Equiv, max};\n use std::default::Default;\n use std::fmt;\n use std::fmt::Show;\n@@ -140,6 +140,7 @@ mod table {\n     }\n \n     /// A hash that is not zero, since we use that to represent empty buckets.\n+    #[deriving(Eq)]\n     pub struct SafeHash {\n         priv hash: u64,\n     }\n@@ -149,10 +150,6 @@ mod table {\n         pub fn inspect(&self) -> u64 { self.hash }\n     }\n \n-    impl Eq for SafeHash {\n-        fn eq(&self, other: &SafeHash) -> bool { self.hash == other.hash }\n-    }\n-\n     /// We need to remove hashes of 0. That's reserved for empty buckets.\n     /// This function wraps up `hash_keyed` to be the only way outside this\n     /// module to generate a SafeHash.\n@@ -698,7 +695,7 @@ fn grow_at(capacity: uint, load_factor: Fraction) -> uint {\n     fraction_mul(capacity, load_factor)\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Get the number of elements which will force the capacity to shrink.\n     /// When size == self.shrink_at(), we halve the capacity.\n     fn shrink_at(&self) -> uint {\n@@ -799,12 +796,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint { self.table.size() }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.minimum_capacity = self.table.size();\n@@ -819,7 +816,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n }\n \n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         self.search(k).map(|idx| {\n             let (_, v) = self.table.read(&idx);\n@@ -832,7 +829,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         match self.search(k) {\n             None => None,\n@@ -969,7 +966,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n     }\n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n+impl<K: Hash + TotalEq, V> HashMap<K, V, sip::SipHasher> {\n     /// Create an empty HashMap.\n     pub fn new() -> HashMap<K, V, sip::SipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n@@ -984,7 +981,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1296,7 +1293,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n@@ -1308,7 +1305,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -1321,7 +1318,7 @@ impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f.buf, r\"\\{\"));\n \n@@ -1334,7 +1331,7 @@ impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H>\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n     fn default() -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, Default::default())\n     }\n@@ -1358,7 +1355,7 @@ pub type Keys<'a, K, V> =\n pub type Values<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iterator<T: Iterator<(K, V)>>(iter: &mut T) -> HashMap<K, V, H> {\n         let (lower, _) = iter.size_hint();\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n@@ -1367,7 +1364,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for Has\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n+impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<(K, V)>>(&mut self, iter: &mut T) {\n         for (k, v) in *iter {\n             self.insert(k, v);\n@@ -1391,7 +1388,7 @@ pub struct HashSet<T, H = sip::SipHasher> {\n     priv map: HashMap<T, (), H>\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n     // FIXME #11998: Since the value is a (), and `find` returns a Some(&()),\n     // we trigger #11998 when matching on it. I've fallen back to manual\n     // iteration until this is fixed.\n@@ -1402,17 +1399,17 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n     }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n     /// Return the number of elements in the set\n     fn len(&self) -> uint { self.map.len() }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.search(value).is_some() }\n \n@@ -1433,7 +1430,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n@@ -1443,7 +1440,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n+impl<T: Hash + TotalEq> HashSet<T, sip::SipHasher> {\n     /// Create an empty HashSet\n     pub fn new() -> HashSet<T, sip::SipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n@@ -1456,7 +1453,7 @@ impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n     }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1529,7 +1526,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n }\n \n-impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f.buf, r\"\\{\"));\n \n@@ -1542,7 +1539,7 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n     fn from_iterator<I: Iterator<T>>(iter: &mut I) -> HashSet<T, H> {\n         let (lower, _) = iter.size_hint();\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n@@ -1551,15 +1548,15 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T,\n     }\n }\n \n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n     fn extend<I: Iterator<T>>(&mut self, iter: &mut I) {\n         for k in *iter {\n             self.insert(k);\n         }\n     }\n }\n \n-impl<T: Eq + Hash> Default for HashSet<T, sip::SipHasher> {\n+impl<T: TotalEq + Hash> Default for HashSet<T, sip::SipHasher> {\n     fn default() -> HashSet<T> { HashSet::new() }\n }\n \n@@ -1601,7 +1598,7 @@ mod test_map {\n \n     local_data_key!(drop_vector: vec::Vec<int>)\n \n-    #[deriving(Hash, Eq)]\n+    #[deriving(Hash, Eq, TotalEq)]\n     struct Dropable {\n         k: int\n     }"}, {"sha": "e328b41cc0fff83cc06b093fa2caf7fe0e711141", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -74,6 +74,8 @@ impl<K: Eq> Eq for KeyRef<K> {\n     }\n }\n \n+impl<K: TotalEq> TotalEq for KeyRef<K> {}\n+\n impl<K, V> LruEntry<K, V> {\n     fn new() -> LruEntry<K, V> {\n         LruEntry {\n@@ -94,7 +96,7 @@ impl<K, V> LruEntry<K, V> {\n     }\n }\n \n-impl<K: Hash + Eq, V> LruCache<K, V> {\n+impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     /// Create an LRU Cache that holds at most `capacity` items.\n     pub fn new(capacity: uint) -> LruCache<K, V> {\n         let cache = LruCache {\n@@ -218,7 +220,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     }\n }\n \n-impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n+impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -247,14 +249,14 @@ impl<A: fmt::Show + Hash + Eq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     }\n }\n \n-impl<K: Hash + Eq, V> Container for LruCache<K, V> {\n+impl<K: Hash + TotalEq, V> Container for LruCache<K, V> {\n     /// Return the number of key-value pairs in the cache.\n     fn len(&self) -> uint {\n         self.map.len()\n     }\n }\n \n-impl<K: Hash + Eq, V> Mutable for LruCache<K, V> {\n+impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n     /// Clear the cache of all key-value pairs.\n     fn clear(&mut self) {\n         self.map.clear();"}, {"sha": "d7d936a704893860cef1a74e4da88cc18affb3d5", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -205,7 +205,7 @@ pub struct BorrowStats {\n //\n // Note that there is no entry with derefs:3---the type of that expression\n // is T, which is not a box.\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct root_map_key {\n     id: ast::NodeId,\n     derefs: uint\n@@ -243,13 +243,13 @@ pub enum LoanCause {\n     RefBinding,\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs"}, {"sha": "1eb6ab4a8b889064a78b9521e69eb3fe492a7f6c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -95,7 +95,7 @@ pub struct CopiedUpvar {\n }\n \n // different kinds of pointers:\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -105,26 +105,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Eq, Hash, Show)]\n+#[deriving(Eq, TotalEq, Hash, Show)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable."}, {"sha": "d86e05395b4c8b5a218ed6dd9ac948fb05c0542b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -107,7 +107,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n enum Namespace {\n     TypeNS,\n     ValueNS"}, {"sha": "78700bab3f24d55a81bd3f1c6b75898fe22a5464", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -710,7 +710,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<@Vec<mono_id> >),\n     mono_any,\n@@ -720,7 +720,7 @@ pub enum mono_param_id {\n               datum::RvalueMode),\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum MonoDataClass {\n     MonoBits,    // Anything not treated differently from arbitrary integer data\n     MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n@@ -742,7 +742,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     }\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct mono_id_ {\n     def: ast::DefId,\n     params: Vec<mono_param_id> }"}, {"sha": "4ca2b5a47b05e282aac8073b6ce104564e9a419d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -82,7 +82,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,"}, {"sha": "425ac4f85e16ed353daf43aa193b3e482bca9eae", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -62,7 +62,7 @@ pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct field {\n     ident: ast::Ident,\n     mt: mt\n@@ -123,20 +123,20 @@ pub struct Impl {\n     ident: Ident,\n     methods: Vec<@Method> }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash, Show)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_slice(Region)\n }\n \n-#[deriving(Clone, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum TraitStore {\n     UniqTraitStore,             // ~Trait\n     RegionTraitStore(Region),   // &Trait\n@@ -150,7 +150,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct creader_cache_key {\n     cnum: CrateNum,\n     pos: uint,\n@@ -177,6 +177,8 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+impl TotalEq for intern_key {}\n+\n impl<W:Writer> Hash<W> for intern_key {\n     fn hash(&self, s: &mut W) {\n         unsafe { (*self.sty).hash(s) }\n@@ -382,7 +384,7 @@ pub struct t_box_ {\n // alive, and using ty::get is unsafe when the ctxt is no longer alive.\n enum t_opaque {}\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct t { priv inner: *t_opaque }\n \n impl fmt::Show for t {\n@@ -413,14 +415,14 @@ pub fn type_has_regions(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct BareFnTy {\n     purity: ast::Purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct ClosureTy {\n     purity: ast::Purity,\n     sigil: ast::Sigil,\n@@ -442,22 +444,22 @@ pub struct ClosureTy {\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct FnSig {\n     binder_id: ast::NodeId,\n     inputs: Vec<t>,\n     output: t,\n     variadic: bool\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct param_ty {\n     idx: uint,\n     def_id: DefId\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -498,13 +500,13 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct UpvarId {\n     var_id: ast::NodeId,\n     closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -642,7 +644,7 @@ pub enum BoundRegion {\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(OwnedSlice<ty::Region>)\n@@ -665,7 +667,7 @@ pub enum RegionSubsts {\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct substs {\n     self_ty: Option<ty::t>,\n     tps: Vec<t>,\n@@ -720,7 +722,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -755,7 +757,7 @@ pub enum sty {\n     ty_unboxed_vec(mt),\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct TyTrait {\n     def_id: DefId,\n     substs: substs,\n@@ -764,7 +766,7 @@ pub struct TyTrait {\n     bounds: BuiltinBounds\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct TraitRef {\n     def_id: DefId,\n     substs: substs\n@@ -826,14 +828,14 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct ParamBounds {\n     builtin_bounds: BuiltinBounds,\n     trait_bounds: Vec<@TraitRef> }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Encodable, Eq, Decodable, Hash, Show)]\n+#[deriving(Clone, Encodable, Eq, TotalEq, Decodable, Hash, Show)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n@@ -865,28 +867,28 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct TyVid(uint);\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct IntVid(uint);\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct FloatVid(uint);\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct RegionVid {\n     id: uint\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Clone, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, TotalEq, Hash, Show)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, BoundRegion)"}, {"sha": "567916a59f8f5e56e5d2bd156dc69f84c194ec08", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -32,15 +32,15 @@ use syntax::ast;\n \n mod doc;\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region),\n     ConstrainRegSubReg(Region, Region),\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n     b: Region,"}, {"sha": "67db5b7f39620f12c220e1b3478d384bb4a70cca", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -148,7 +148,7 @@ pub struct MethodCallee {\n     substs: ty::substs\n }\n \n-#[deriving(Clone, Eq, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n pub struct MethodCall {\n     expr_id: ast::NodeId,\n     autoderef: u32"}, {"sha": "ac4db178a008be244aff317b8097325ba4185471", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -27,7 +27,7 @@ pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n pub mod FnvHashMap {\n     use std::hash::Hash;\n     use collections::HashMap;\n-    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n+    pub fn new<K: Hash<super::FnvState> + TotalEq, V>() -> super::FnvHashMap<K, V> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }"}, {"sha": "bb823c2d8cae79c05b9b146bb7d6c16ca63776f0", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -165,7 +165,7 @@ impl<\n \n impl<\n     E: Encoder,\n-    K: Encodable<E> + Hash<S> + Eq,\n+    K: Encodable<E> + Hash<S> + TotalEq,\n     V: Encodable<E>,\n     S,\n     H: Hasher<S>\n@@ -184,7 +184,7 @@ impl<\n \n impl<\n     D: Decoder,\n-    K: Decodable<D> + Hash<S> + Eq,\n+    K: Decodable<D> + Hash<S> + TotalEq,\n     V: Decodable<D>,\n     S,\n     H: Hasher<S> + Default\n@@ -205,7 +205,7 @@ impl<\n \n impl<\n     E: Encoder,\n-    T: Encodable<E> + Hash<S> + Eq,\n+    T: Encodable<E> + Hash<S> + TotalEq,\n     S,\n     H: Hasher<S>\n > Encodable<E> for HashSet<T, H> {\n@@ -222,7 +222,7 @@ impl<\n \n impl<\n     D: Decoder,\n-    T: Decodable<D> + Hash<S> + Eq,\n+    T: Decodable<D> + Hash<S> + TotalEq,\n     S,\n     H: Hasher<S> + Default\n > Decodable<D> for HashSet<T, H> {"}, {"sha": "67088e6f4f8c8aed0970b13be5b6f4f5c7785575", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -121,7 +121,7 @@ pub enum Method<'a> {\n }\n \n /// A selector for what pluralization a plural method should take\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum PluralSelector {\n     /// One of the plural keywords should be used\n     Keyword(PluralKeyword),\n@@ -143,7 +143,7 @@ pub struct PluralArm<'a> {\n /// specially placed in the `Plural` variant of `Method`\n ///\n /// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n #[allow(missing_doc)]\n pub enum PluralKeyword {\n     Zero, One, Two, Few, Many"}, {"sha": "512b20ebf4ccf68c59a4199df1b47b240b8aa4db", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -13,7 +13,7 @@\n use container::Container;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n-use cmp::Eq;\n+use cmp::{Eq, TotalEq};\n use from_str::FromStr;\n use io::Writer;\n use iter::{AdditiveIterator, Extendable, Iterator, Map};\n@@ -69,6 +69,8 @@ impl Eq for Path {\n     }\n }\n \n+impl TotalEq for Path {}\n+\n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n         Path::new_opt(s)"}, {"sha": "81da2f50f8de55952725f1de54b40e9385187633", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -15,7 +15,7 @@ use c_str::{CString, ToCStr};\n use cast;\n use clone::Clone;\n use container::Container;\n-use cmp::Eq;\n+use cmp::{Eq, TotalEq};\n use from_str::FromStr;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n@@ -93,6 +93,8 @@ impl Eq for Path {\n     }\n }\n \n+impl TotalEq for Path {}\n+\n impl FromStr for Path {\n     fn from_str(s: &str) -> Option<Path> {\n         Path::new_opt(s)"}, {"sha": "504c613bf4c1763e4e7f15eb53895b37df395c67", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -19,7 +19,7 @@ use mem;\n use option::{Option, Some, None};\n use intrinsics;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::{Eq, TotalEq, Ord};\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n@@ -272,6 +272,9 @@ impl<T> Eq for *T {\n     fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n }\n \n+#[cfg(not(test))]\n+impl<T> TotalEq for *T {}\n+\n #[cfg(not(test))]\n impl<T> Eq for *mut T {\n     #[inline]\n@@ -282,6 +285,9 @@ impl<T> Eq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n+#[cfg(not(test))]\n+impl<T> TotalEq for *mut T {}\n+\n // Equivalence for pointers\n #[cfg(not(test))]\n impl<T> Equiv<*mut T> for *T {"}, {"sha": "d26038f508f35b081463473a08ae46e981e3485b", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -26,7 +26,7 @@ pointers, and then storing the parent pointers as `Weak` pointers.\n use cast::transmute;\n use cell::Cell;\n use clone::Clone;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n use kinds::marker;\n use ops::{Deref, Drop};\n use option::{Option, Some, None};\n@@ -127,6 +127,8 @@ impl<T: Eq> Eq for Rc<T> {\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n }\n \n+impl<T: TotalEq> TotalEq for Rc<T> {}\n+\n impl<T: Ord> Ord for Rc<T> {\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n@@ -141,6 +143,11 @@ impl<T: Ord> Ord for Rc<T> {\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n }\n \n+impl<T: TotalOrd> TotalOrd for Rc<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n+}\n+\n /// Weak reference to a reference-counted box\n #[unsafe_no_drop_flag]\n pub struct Weak<T> {"}, {"sha": "b833eea6b560cf151dedba0e7eae4b90fdf1c7a7", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -14,7 +14,7 @@ use std::fmt::Show;\n #[deriving(Eq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -65,7 +65,7 @@ pub enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct AbiSet {\n     priv bits: u32   // each bit represents one of the abis below\n }"}, {"sha": "24b8a3457763881d69bf2594eeafb9c1af888d2c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -113,7 +113,7 @@ impl<D:Decoder> Decodable<D> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n@@ -124,7 +124,7 @@ pub struct Lifetime {\n // for instance: std::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Path {\n     span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -136,7 +136,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     identifier: Ident,\n@@ -170,21 +170,21 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send and Share.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     RegionTyParamBound\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TyParam {\n     ident: Ident,\n     id: NodeId,\n     bounds: OwnedSlice<TyParamBound>,\n     default: Option<P<Ty>>\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     lifetimes: Vec<Lifetime>,\n     ty_params: OwnedSlice<TyParam>,\n@@ -202,13 +202,13 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum MethodProvenance {\n     FromTrait(DefId),\n     FromImpl(DefId),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(DefId, Purity),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, Purity),\n@@ -245,7 +245,7 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n-#[deriving(Clone, Eq, Hash, Encodable, Decodable, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Encodable, Decodable, Show)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n@@ -257,7 +257,7 @@ pub enum DefRegion {\n // used to drive conditional compilation\n pub type CrateConfig = Vec<@MetaItem> ;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     module: Mod,\n     attrs: Vec<Attribute> ,\n@@ -267,7 +267,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[deriving(Clone, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Encodable, Decodable, TotalEq, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, Vec<@MetaItem> ),\n@@ -299,7 +299,7 @@ impl Eq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Block {\n     view_items: Vec<ViewItem> ,\n     stmts: Vec<@Stmt> ,\n@@ -309,26 +309,26 @@ pub struct Block {\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Pat {\n     id: NodeId,\n     node: Pat_,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     ident: Ident,\n     pat: @Pat,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -353,13 +353,13 @@ pub enum Pat_ {\n     PatVec(Vec<@Pat> , Option<@Pat>, Vec<@Pat> )\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash, Show)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n@@ -376,14 +376,14 @@ impl fmt::Show for Sigil {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -405,7 +405,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -416,7 +416,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n     StmtDecl(@Decl, NodeId),\n@@ -434,7 +434,7 @@ pub enum Stmt_ {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Local {\n     ty: P<Ty>,\n     pat: @Pat,\n@@ -445,22 +445,22 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n     // an item binding:\n     DeclItem(@Item),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pats: Vec<@Pat> ,\n     guard: Option<@Expr>,\n     body: @Expr,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Field {\n     ident: SpannedIdent,\n     expr: @Expr,\n@@ -469,26 +469,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Expr {\n     id: NodeId,\n     node: Expr_,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n@@ -557,7 +557,7 @@ pub enum Expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     // a single token\n@@ -631,7 +631,7 @@ pub enum TokenTree {\n //\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Matcher_ {\n     // match one token\n     MatchTok(::parse::token::Token),\n@@ -648,20 +648,20 @@ pub type Mac = Spanned<Mac_>;\n // is being invoked, and the vector of token-trees contains the source\n // of the macro invocation.\n // There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(uint)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n@@ -677,20 +677,20 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct MutTy {\n     ty: P<Ty>,\n     mutbl: Mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TypeField {\n     ident: Ident,\n     mt: MutTy,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     ident: Ident,\n     attrs: Vec<Attribute> ,\n@@ -705,13 +705,13 @@ pub struct TypeMethod {\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(@Method),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum IntTy {\n     TyI,\n     TyI8,\n@@ -726,7 +726,7 @@ impl fmt::Show for IntTy {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum UintTy {\n     TyU,\n     TyU8,\n@@ -741,7 +741,7 @@ impl fmt::Show for UintTy {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum FloatTy {\n     TyF32,\n     TyF64,\n@@ -754,15 +754,15 @@ impl fmt::Show for FloatTy {\n }\n \n // NB Eq method appears below.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Ty {\n     id: NodeId,\n     node: Ty_,\n     span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -772,7 +772,7 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -787,7 +787,7 @@ impl fmt::Show for Onceness {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n     sigil: Sigil,\n     region: Option<Lifetime>,\n@@ -802,15 +802,15 @@ pub struct ClosureTy {\n     bounds: Option<OwnedSlice<TyParamBound>>,\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     purity: Purity,\n     abis: AbiSet,\n     lifetimes: Vec<Lifetime>,\n     decl: P<FnDecl>\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -830,13 +830,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct InlineAsm {\n     asm: InternedString,\n     asm_str_style: StrStyle,\n@@ -848,7 +848,7 @@ pub struct InlineAsm {\n     dialect: AsmDialect\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     ty: P<Ty>,\n     pat: @Pat,\n@@ -875,15 +875,15 @@ impl Arg {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     inputs: Vec<Arg> ,\n     output: P<Ty>,\n     cf: RetStyle,\n     variadic: bool\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Purity {\n     UnsafeFn, // declared with \"unsafe fn\"\n     ImpureFn, // declared with \"fn\"\n@@ -900,14 +900,14 @@ impl fmt::Show for Purity {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum RetStyle {\n     NoReturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     Return, // everything else\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n     SelfValue,                                 // `self`\n@@ -917,7 +917,7 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Method {\n     ident: Ident,\n     attrs: Vec<Attribute> ,\n@@ -931,37 +931,37 @@ pub struct Method {\n     vis: Visibility,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Mod {\n     view_items: Vec<ViewItem> ,\n     items: Vec<@Item> ,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     abis: AbiSet,\n     view_items: Vec<ViewItem> ,\n     items: Vec<@ForeignItem> ,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct VariantArg {\n     ty: P<Ty>,\n     id: NodeId,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg> ),\n     StructVariantKind(@StructDef),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n     variants: Vec<P<Variant>> ,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     name: Ident,\n     attrs: Vec<Attribute> ,\n@@ -973,7 +973,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct PathListIdent_ {\n     name: Ident,\n     id: NodeId,\n@@ -983,7 +983,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ViewPath_ {\n \n     // quux = foo::bar::baz\n@@ -1000,15 +1000,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListIdent> , NodeId)\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     node: ViewItem_,\n     attrs: Vec<Attribute> ,\n     vis: Visibility,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional (InternedString,StrStyle): if present, this is a location\n@@ -1024,14 +1024,14 @@ pub type Attribute = Spanned<Attribute_>;\n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Attribute_ {\n     style: AttrStyle,\n     value: @MetaItem,\n@@ -1045,13 +1045,13 @@ pub struct Attribute_ {\n   If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct TraitRef {\n     path: Path,\n     ref_id: NodeId,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Visibility {\n     Public,\n     Private,\n@@ -1067,7 +1067,7 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct StructField_ {\n     kind: StructFieldKind,\n     id: NodeId,\n@@ -1077,13 +1077,13 @@ pub struct StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     UnnamedField // element of a tuple-like struct\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n     fields: Vec<StructField> , /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1095,7 +1095,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Item {\n     ident: Ident,\n     attrs: Vec<Attribute> ,\n@@ -1105,7 +1105,7 @@ pub struct Item {\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n     ItemFn(P<FnDecl>, Purity, AbiSet, Generics, P<Block>),\n@@ -1123,7 +1123,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     ident: Ident,\n     attrs: Vec<Attribute> ,\n@@ -1133,7 +1133,7 @@ pub struct ForeignItem {\n     vis: Visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1142,7 +1142,7 @@ pub enum ForeignItem_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, Encodable, Decodable, Hash)]\n+#[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n     IIItem(@Item),\n     IIMethod(DefId /* impl id */, bool /* is provided */, @Method),"}, {"sha": "325df5fda60e7fce7cabbadb50639ad3aefe189a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -22,7 +22,6 @@ source code snippets, etc.\n */\n \n use std::cell::RefCell;\n-use std::cmp;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -33,7 +32,7 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[deriving(Clone, Eq, Hash, Ord, Show)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Ord, Show)]\n pub struct BytePos(u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n@@ -94,19 +93,21 @@ pub struct Span {\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n \n-#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Spanned<T> {\n     node: T,\n     span: Span,\n }\n \n-impl cmp::Eq for Span {\n+impl Eq for Span {\n     fn eq(&self, other: &Span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n     fn ne(&self, other: &Span) -> bool { !(*self).eq(other) }\n }\n \n+impl TotalEq for Span {}\n+\n impl<S:Encoder> Encodable<S> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) {"}, {"sha": "d5b90821897f46803803009f8c05bee1ce4e990a", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -119,6 +119,8 @@ impl<T: Eq> Eq for OwnedSlice<T> {\n     }\n }\n \n+impl<T: TotalEq> TotalEq for OwnedSlice<T> {}\n+\n impl<T> Container for OwnedSlice<T> {\n     fn len(&self) -> uint { self.len }\n }"}, {"sha": "63b3fb09ee3cd55da52b8badc91fc3c81540b1ba", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -23,7 +23,7 @@ use parse::parser::Parser;\n use parse::token;\n \n /// The specific types of unsupported syntax\n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n pub enum ObsoleteSyntax {\n     ObsoleteSwap,\n     ObsoleteUnsafeBlock,"}, {"sha": "15525912955fcce4f15a82b2231607744e91b492", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -24,7 +24,7 @@ use std::local_data;\n use std::path::BytesContainer;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n pub enum BinOp {\n     PLUS,\n     MINUS,\n@@ -39,7 +39,7 @@ pub enum BinOp {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n+#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -103,7 +103,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(@ast::Item),"}, {"sha": "9b73cf533a7411971be517814f71c3f7f699a750", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -28,7 +28,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n+impl<T: TotalEq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),"}, {"sha": "222aff3746519c9dad344e9788440a0b892e1008", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -424,7 +424,7 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n+pub fn freq_count<T: Iterator<U>, U: TotalEq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n     let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n     for elem in iter {\n         map.insert_or_update_with(elem, 1, |_, count| *count += 1);"}, {"sha": "3876aa45753c7f351082543f764ff623e60f946b", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -14,7 +14,7 @@ extern crate collections;\n \n use collections::HashSet;\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n struct XYZ {\n     x: int,\n     y: int,"}, {"sha": "c38df0f7a225ab22378bc374171d0cb82501c5d5", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddb60565423bdc225ccc8dd4ebfb653c5650ba2/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=2ddb60565423bdc225ccc8dd4ebfb653c5650ba2", "patch": "@@ -42,6 +42,8 @@ impl<'tcx> Eq for TypeStructure<'tcx> {\n     }\n }\n \n+impl<'tcx> TotalEq for TypeStructure<'tcx> {}\n+\n struct TypeContext<'tcx, 'ast> {\n     ty_arena: &'tcx Arena,\n     types: Vec<Type<'tcx>> ,\n@@ -86,7 +88,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     }\n }\n \n-#[deriving(Eq, Hash)]\n+#[deriving(Eq, TotalEq, Hash)]\n struct NodeId {\n     id: uint\n }"}]}