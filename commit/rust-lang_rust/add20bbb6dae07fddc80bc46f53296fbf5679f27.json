{"sha": "add20bbb6dae07fddc80bc46f53296fbf5679f27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZDIwYmJiNmRhZTA3ZmRkYzgwYmM0NmY1MzI5NmZiZjU2NzlmMjc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-11T12:47:46Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-11T12:47:51Z"}, "message": "Move error to typeck::check", "tree": {"sha": "9e3d1ac2355dd06d3fd0ca47929b3c19bec1adff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3d1ac2355dd06d3fd0ca47929b3c19bec1adff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add20bbb6dae07fddc80bc46f53296fbf5679f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add20bbb6dae07fddc80bc46f53296fbf5679f27", "html_url": "https://github.com/rust-lang/rust/commit/add20bbb6dae07fddc80bc46f53296fbf5679f27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add20bbb6dae07fddc80bc46f53296fbf5679f27/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1832779483df51b59367250850213d8e7fe159a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1832779483df51b59367250850213d8e7fe159a", "html_url": "https://github.com/rust-lang/rust/commit/e1832779483df51b59367250850213d8e7fe159a"}], "stats": {"total": 130, "additions": 50, "deletions": 80}, "files": [{"sha": "300b9aaf10060cf02b68f92c3786cda435dd2ba1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=add20bbb6dae07fddc80bc46f53296fbf5679f27", "patch": "@@ -26,9 +26,6 @@\n //! a `pub fn new()`.\n use self::MethodContext::*;\n \n-\n-use fmt_macros::{Parser, Piece, Position};\n-\n use metadata::csearch;\n use middle::def::*;\n use middle::subst::Substs;\n@@ -1924,63 +1921,3 @@ impl LintPass for UnstableFeatures {\n         }\n     }\n }\n-\n-/// Checks usage of `#[on_unimplemented]`\n-#[derive(Copy)]\n-pub struct BadOnUnimplemented;\n-\n-declare_lint!(BAD_ON_UNIMPLEMENTED, Deny,\n-              \"Checks usage of `#[on_unimplemented]`\");\n-\n-impl LintPass for BadOnUnimplemented {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(BAD_ON_UNIMPLEMENTED)\n-    }\n-    fn check_item(&mut self, ctx: &Context, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemTrait(_, ref generics, _, _) => {\n-                if let Some(ref attr) = item.attrs.iter().find(|&: a| {\n-                    a.check_name(\"on_unimplemented\")\n-                }) {\n-                    if let Some(ref istring) = attr.value_str() {\n-                        let mut parser = Parser::new(istring.get());\n-                        let types = generics.ty_params.as_slice();\n-                        for token in parser {\n-                            match token {\n-                                Piece::String(_) => (), // Normal string, no need to check it\n-                                Piece::NextArgument(a) => match a.position {\n-                                    // `{Self}` is allowed\n-                                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n-                                    // So is `{A}` if A is a type parameter\n-                                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                                        t.ident.as_str() == s\n-                                    }) {\n-                                        Some(_) => (),\n-                                        None => {\n-                                            ctx.span_lint(BAD_ON_UNIMPLEMENTED, attr.span,\n-                                                         format!(\"there is no type parameter \\\n-                                                                    {} on trait {}\",\n-                                                                    s, item.ident.as_str())\n-                                                           .as_slice());\n-                                        }\n-                                    },\n-                                    // `{:1}` and `{}` are not to be used\n-                                    Position::ArgumentIs(_) | Position::ArgumentNext => {\n-                                        ctx.span_lint(BAD_ON_UNIMPLEMENTED, attr.span,\n-                                                     \"only named substitution \\\n-                                                     parameters are allowed\");\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        ctx.span_lint(BAD_ON_UNIMPLEMENTED, attr.span,\n-                                     \"this attribute must have a value, \\\n-                                      eg `#[on_unimplemented = \\\"foo\\\"]`\")\n-                    }\n-                }\n-            },\n-            _ => () // Not a trait def, move along\n-        }\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "95e1e8d44bfc5044aec739ec98f5c89ec5aaeb7e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=add20bbb6dae07fddc80bc46f53296fbf5679f27", "patch": "@@ -211,7 +211,6 @@ impl LintStore {\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n-                     BadOnUnimplemented,\n         );\n \n         add_builtin_with_new!(sess,"}, {"sha": "de6c884d6d71b450a4438a53ca04501f4c2eab51", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=add20bbb6dae07fddc80bc46f53296fbf5679f27", "patch": "@@ -83,6 +83,7 @@ use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv};\n use check::_match::pat_ctxt;\n+use fmt_macros::{Parser, Piece, Position};\n use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n@@ -113,6 +114,7 @@ use std::mem::replace;\n use std::rc::Rc;\n use std::iter::repeat;\n use syntax::{self, abi, attr};\n+use syntax::attr::AttrMetaMethods;\n use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{self, local_def, PostExpansionMethod};\n use syntax::codemap::{self, Span};\n@@ -726,7 +728,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         }\n \n       }\n-      ast::ItemTrait(_, _, _, ref trait_methods) => {\n+      ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n+        check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in trait_methods.iter() {\n             match *trait_method {\n@@ -776,6 +779,51 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n+fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               generics: &ast::Generics,\n+                               item: &ast::Item) {\n+    if let Some(ref attr) = item.attrs.iter().find(|&: a| {\n+        a.check_name(\"on_unimplemented\")\n+    }) {\n+        if let Some(ref istring) = attr.value_str() {\n+            let mut parser = Parser::new(istring.get());\n+            let types = generics.ty_params.as_slice();\n+            for token in parser {\n+                match token {\n+                    Piece::String(_) => (), // Normal string, no need to check it\n+                    Piece::NextArgument(a) => match a.position {\n+                        // `{Self}` is allowed\n+                        Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                        // So is `{A}` if A is a type parameter\n+                        Position::ArgumentNamed(s) => match types.iter().find(|t| {\n+                            t.ident.as_str() == s\n+                        }) {\n+                            Some(_) => (),\n+                            None => {\n+                                ccx.tcx.sess.span_err(attr.span,\n+                                                 format!(\"there is no type parameter \\\n+                                                          {} on trait {}\",\n+                                                           s, item.ident.as_str())\n+                                            .as_slice());\n+                            }\n+                        },\n+                        // `{:1}` and `{}` are not to be used\n+                        Position::ArgumentIs(_) | Position::ArgumentNext => {\n+                            ccx.tcx.sess.span_err(attr.span,\n+                                                  \"only named substitution \\\n+                                                   parameters are allowed\");\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            ccx.tcx.sess.span_err(attr.span,\n+                                  \"this attribute must have a value, \\\n+                                   eg `#[on_unimplemented = \\\"foo\\\"]`\")\n+        }\n+    }\n+}\n+\n /// Type checks a method body.\n ///\n /// # Parameters"}, {"sha": "68b152dee233b4ea86be313adcf9076049d2e6f8", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=add20bbb6dae07fddc80bc46f53296fbf5679f27", "patch": "@@ -84,6 +84,7 @@ This API is completely unstable and subject to change.\n #[macro_use] extern crate syntax;\n \n extern crate arena;\n+extern crate fmt_macros;\n extern crate rustc;\n \n pub use rustc::lint;"}, {"sha": "20b4448ea77721837c440f6808094e9d300873e1", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add20bbb6dae07fddc80bc46f53296fbf5679f27/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=add20bbb6dae07fddc80bc46f53296fbf5679f27", "patch": "@@ -26,26 +26,11 @@ fn collect<A, I: Iterator<Item=A>, B: MyFromIterator<A>>(it: I) -> B {\n     MyFromIterator::my_from_iter(it)\n }\n \n-#[on_unimplemented] //~ ERROR the #[on_unimplemented] attribute on trait definition for BadAnnotation1 must have a value, eg `#[on_unimplemented = \"foo\"]`\n-trait BadAnnotation1 {}\n-\n-#[on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n-//~^ ERROR the #[on_unimplemented] attribute on trait definition for BadAnnotation2<A, B> refers to non-existent type parameter C\n-trait BadAnnotation2<A,B> {}\n-\n-fn trigger1<T: BadAnnotation1>(t: T)  {}\n-fn trigger2<A, B, T: BadAnnotation2<A,B>>(t: T) {}\n-\n pub fn main() {\n     let x = vec!(1u8, 2, 3, 4);\n     let y: Option<Vec<u8>> = collect(x.iter()); // this should give approximately the same error for x.iter().collect()\n     //~^ ERROR\n     //~^^ NOTE a collection of type `core::option::Option<collections::vec::Vec<u8>>` cannot be built from an iterator over elements of type `&u8`\n     let x: String = foobar(); //~ ERROR\n     //~^ NOTE test error `collections::string::String` with `u8` `_` `u32`\n-\n-    // The following two have errors in their annotations, so the regular error should be thrown\n-    trigger1(1u8); //~ ERROR the trait `BadAnnotation1` is not implemented for the type `u8`\n-    trigger2::<u8, u8, u8>(1u8); //~ ERROR the trait `BadAnnotation2<u8, u8>` is not implemented\n-\n }"}]}