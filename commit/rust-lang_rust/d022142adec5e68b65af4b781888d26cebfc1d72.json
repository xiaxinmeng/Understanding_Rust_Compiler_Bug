{"sha": "d022142adec5e68b65af4b781888d26cebfc1d72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMjIxNDJhZGVjNWU2OGI2NWFmNGI3ODE4ODhkMjZjZWJmYzFkNzI=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:23:37Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2021-03-10T22:32:14Z"}, "message": "Moved more of the capture related types into closure.rs", "tree": {"sha": "151175e5e4294d2f0660af4ffca41a78663a1acd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151175e5e4294d2f0660af4ffca41a78663a1acd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d022142adec5e68b65af4b781888d26cebfc1d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d022142adec5e68b65af4b781888d26cebfc1d72", "html_url": "https://github.com/rust-lang/rust/commit/d022142adec5e68b65af4b781888d26cebfc1d72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d022142adec5e68b65af4b781888d26cebfc1d72/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43", "html_url": "https://github.com/rust-lang/rust/commit/90cbb39d74dbe7065f9a0ba55ce13f7e99d13b43"}], "stats": {"total": 345, "additions": 173, "deletions": 172}, "files": [{"sha": "76ac6c4e08e910f588c4841824946f5f6cbd3450", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 173, "deletions": 2, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/d022142adec5e68b65af4b781888d26cebfc1d72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022142adec5e68b65af4b781888d26cebfc1d72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=d022142adec5e68b65af4b781888d26cebfc1d72", "patch": "@@ -1,4 +1,6 @@\n-use crate::hir::place::{Place as HirPlace, PlaceBase as HirPlaceBase};\n+use crate::hir::place::{\n+    Place as HirPlace, PlaceBase as HirPlaceBase, ProjectionKind as HirProjectionKind,\n+};\n use crate::ty;\n \n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n@@ -7,7 +9,9 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_span::Span;\n \n-use super::{BorrowKind, CaptureInfo, Ty, TyCtxt};\n+use super::{Ty, TyCtxt};\n+\n+use self::BorrowKind::*;\n \n #[derive(\n     Clone,\n@@ -165,3 +169,170 @@ impl CapturedPlace<'tcx> {\n         }\n     }\n }\n+\n+/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n+/// for a particular capture as well as identifying the part of the source code\n+/// that triggered this capture to occur.\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n+pub struct CaptureInfo<'tcx> {\n+    /// Expr Id pointing to use that resulted in selecting the current capture kind\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let mut t = (0,1);\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\",t); // L1\n+    ///     t.1 = 4; // L2\n+    /// };\n+    /// ```\n+    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n+    /// use on L1.\n+    ///\n+    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n+    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n+    /// None. In such case we fallback on uvpars_mentioned for span.\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let x = 5;\n+    ///\n+    /// let c = || {\n+    ///     let _ = x\n+    /// };\n+    /// ```\n+    ///\n+    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n+    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n+    pub capture_kind_expr_id: Option<hir::HirId>,\n+    /// Expr Id pointing to use that resulted the corresponding place being captured\n+    ///\n+    /// See `capture_kind_expr_id` for example.\n+    ///\n+    pub path_expr_id: Option<hir::HirId>,\n+\n+    /// Capture mode that was selected\n+    pub capture_kind: UpvarCapture<'tcx>,\n+}\n+\n+pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n+    let name = match place.base {\n+        HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n+        _ => bug!(\"Capture_information should only contain upvars\"),\n+    };\n+    let mut curr_string = name;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        match proj.kind {\n+            HirProjectionKind::Deref => {\n+                curr_string = format!(\"*{}\", curr_string);\n+            }\n+            HirProjectionKind::Field(idx, variant) => match place.ty_before_projection(i).kind() {\n+                ty::Adt(def, ..) => {\n+                    curr_string = format!(\n+                        \"{}.{}\",\n+                        curr_string,\n+                        def.variants[variant].fields[idx as usize].ident.name.as_str()\n+                    );\n+                }\n+                ty::Tuple(_) => {\n+                    curr_string = format!(\"{}.{}\", curr_string, idx);\n+                }\n+                _ => {\n+                    bug!(\n+                        \"Field projection applied to a type other than Adt or Tuple: {:?}.\",\n+                        place.ty_before_projection(i).kind()\n+                    )\n+                }\n+            },\n+            proj => bug!(\"{:?} unexpected because it isn't captured\", proj),\n+        }\n+    }\n+\n+    curr_string.to_string()\n+}\n+\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    ImmBorrow,\n+\n+    /// Data must be immutable but not aliasable. This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when the closure\n+    /// is borrowing or mutating a mutable referent, e.g.:\n+    ///\n+    /// ```\n+    /// let x: &mut isize = ...;\n+    /// let y = || *x += 5;\n+    /// ```\n+    ///\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    ///\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    ///\n+    /// This is then illegal because you cannot mutate a `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    ///\n+    /// ```\n+    /// struct Env { x: & &mut isize }\n+    /// let x: &mut isize = ...;\n+    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    ///\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    UniqueImmBorrow,\n+\n+    /// Data is mutable and not aliasable.\n+    MutBorrow,\n+}\n+\n+impl BorrowKind {\n+    pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n+        match m {\n+            hir::Mutability::Mut => MutBorrow,\n+            hir::Mutability::Not => ImmBorrow,\n+        }\n+    }\n+\n+    /// Returns a mutability `m` such that an `&m T` pointer could be used to obtain this borrow\n+    /// kind. Because borrow kinds are richer than mutabilities, we sometimes have to pick a\n+    /// mutability that is stronger than necessary so that it at least *would permit* the borrow in\n+    /// question.\n+    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n+        match self {\n+            MutBorrow => hir::Mutability::Mut,\n+            ImmBorrow => hir::Mutability::Not,\n+\n+            // We have no type corresponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            UniqueImmBorrow => hir::Mutability::Mut,\n+        }\n+    }\n+\n+    pub fn to_user_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mutable\",\n+            ImmBorrow => \"immutable\",\n+            UniqueImmBorrow => \"uniquely immutable\",\n+        }\n+    }\n+}"}, {"sha": "f5aef108927dbfb49d3a8ac256e6919217fdbd0f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d022142adec5e68b65af4b781888d26cebfc1d72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d022142adec5e68b65af4b781888d26cebfc1d72/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d022142adec5e68b65af4b781888d26cebfc1d72", "patch": "@@ -20,9 +20,6 @@ pub use closure::*;\n pub use generics::*;\n \n use crate::hir::exports::ExportMap;\n-use crate::hir::place::{\n-    Place as HirPlace, PlaceBase as HirPlaceBase, ProjectionKind as HirProjectionKind,\n-};\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::mir::{Body, GeneratorLayout};\n@@ -352,140 +349,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, TypeFoldable, Copy, HashStable)]\n-pub enum BorrowKind {\n-    /// Data must be immutable and is aliasable.\n-    ImmBorrow,\n-\n-    /// Data must be immutable but not aliasable. This kind of borrow\n-    /// cannot currently be expressed by the user and is used only in\n-    /// implicit closure bindings. It is needed when the closure\n-    /// is borrowing or mutating a mutable referent, e.g.:\n-    ///\n-    /// ```\n-    /// let x: &mut isize = ...;\n-    /// let y = || *x += 5;\n-    /// ```\n-    ///\n-    /// If we were to try to translate this closure into a more explicit\n-    /// form, we'd encounter an error with the code as written:\n-    ///\n-    /// ```\n-    /// struct Env { x: & &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    ///\n-    /// This is then illegal because you cannot mutate a `&mut` found\n-    /// in an aliasable location. To solve, you'd have to translate with\n-    /// an `&mut` borrow:\n-    ///\n-    /// ```\n-    /// struct Env { x: & &mut isize }\n-    /// let x: &mut isize = ...;\n-    /// let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n-    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n-    /// ```\n-    ///\n-    /// Now the assignment to `**env.x` is legal, but creating a\n-    /// mutable pointer to `x` is not because `x` is not mutable. We\n-    /// could fix this by declaring `x` as `let mut x`. This is ok in\n-    /// user code, if awkward, but extra weird for closures, since the\n-    /// borrow is hidden.\n-    ///\n-    /// So we introduce a \"unique imm\" borrow -- the referent is\n-    /// immutable, but not aliasable. This solves the problem. For\n-    /// simplicity, we don't give users the way to express this\n-    /// borrow, it's just used when translating closures.\n-    UniqueImmBorrow,\n-\n-    /// Data is mutable and not aliasable.\n-    MutBorrow,\n-}\n-\n-pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n-    let name = match place.base {\n-        HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n-        _ => bug!(\"Capture_information should only contain upvars\"),\n-    };\n-    let mut curr_string = name;\n-\n-    for (i, proj) in place.projections.iter().enumerate() {\n-        match proj.kind {\n-            HirProjectionKind::Deref => {\n-                curr_string = format!(\"*{}\", curr_string);\n-            }\n-            HirProjectionKind::Field(idx, variant) => match place.ty_before_projection(i).kind() {\n-                ty::Adt(def, ..) => {\n-                    curr_string = format!(\n-                        \"{}.{}\",\n-                        curr_string,\n-                        def.variants[variant].fields[idx as usize].ident.name.as_str()\n-                    );\n-                }\n-                ty::Tuple(_) => {\n-                    curr_string = format!(\"{}.{}\", curr_string, idx);\n-                }\n-                _ => {\n-                    bug!(\n-                        \"Field projection applied to a type other than Adt or Tuple: {:?}.\",\n-                        place.ty_before_projection(i).kind()\n-                    )\n-                }\n-            },\n-            proj => bug!(\"{:?} unexpected because it isn't captured\", proj),\n-        }\n-    }\n-\n-    curr_string.to_string()\n-}\n-\n-/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n-/// for a particular capture as well as identifying the part of the source code\n-/// that triggered this capture to occur.\n-#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CaptureInfo<'tcx> {\n-    /// Expr Id pointing to use that resulted in selecting the current capture kind\n-    ///\n-    /// Eg:\n-    /// ```rust,no_run\n-    /// let mut t = (0,1);\n-    ///\n-    /// let c = || {\n-    ///     println!(\"{}\",t); // L1\n-    ///     t.1 = 4; // L2\n-    /// };\n-    /// ```\n-    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n-    /// use on L1.\n-    ///\n-    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n-    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n-    /// None. In such case we fallback on uvpars_mentioned for span.\n-    ///\n-    /// Eg:\n-    /// ```rust,no_run\n-    /// let x = 5;\n-    ///\n-    /// let c = || {\n-    ///     let _ = x\n-    /// };\n-    /// ```\n-    ///\n-    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n-    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n-    pub capture_kind_expr_id: Option<hir::HirId>,\n-    /// Expr Id pointing to use that resulted the corresponding place being captured\n-    ///\n-    /// See `capture_kind_expr_id` for example.\n-    ///\n-    pub path_expr_id: Option<hir::HirId>,\n-\n-    /// Capture mode that was selected\n-    pub capture_kind: UpvarCapture<'tcx>,\n-}\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -1655,39 +1518,6 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-impl BorrowKind {\n-    pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n-        match m {\n-            hir::Mutability::Mut => MutBorrow,\n-            hir::Mutability::Not => ImmBorrow,\n-        }\n-    }\n-\n-    /// Returns a mutability `m` such that an `&m T` pointer could be used to obtain this borrow\n-    /// kind. Because borrow kinds are richer than mutabilities, we sometimes have to pick a\n-    /// mutability that is stronger than necessary so that it at least *would permit* the borrow in\n-    /// question.\n-    pub fn to_mutbl_lossy(self) -> hir::Mutability {\n-        match self {\n-            MutBorrow => hir::Mutability::Mut,\n-            ImmBorrow => hir::Mutability::Not,\n-\n-            // We have no type corresponding to a unique imm borrow, so\n-            // use `&mut`. It gives all the capabilities of an `&uniq`\n-            // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::Mutability::Mut,\n-        }\n-    }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mutable\",\n-            ImmBorrow => \"immutable\",\n-            UniqueImmBorrow => \"uniquely immutable\",\n-        }\n-    }\n-}\n-\n pub type Attributes<'tcx> = &'tcx [ast::Attribute];\n \n #[derive(Debug, PartialEq, Eq)]"}]}