{"sha": "6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNTE0OGJkYTEzNjRiZDQ2NjA3YTNjNGViZGNmYjBmNDA4ZTA4NTA=", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2015-03-14T23:34:21Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2015-03-19T23:25:22Z"}, "message": "Introduce rsplit", "tree": {"sha": "7b1644c37465b8e6367eefb2d007c70dea9c951a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b1644c37465b8e6367eefb2d007c70dea9c951a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "html_url": "https://github.com/rust-lang/rust/commit/6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f53b943f94b338e4c5401f1ce9efbe7da92b0c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f53b943f94b338e4c5401f1ce9efbe7da92b0c5", "html_url": "https://github.com/rust-lang/rust/commit/7f53b943f94b338e4c5401f1ce9efbe7da92b0c5"}], "stats": {"total": 135, "additions": 132, "deletions": 3}, "files": [{"sha": "6379155800b1706ef15f6fbd487b5a8cc392d151", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "patch": "@@ -74,8 +74,8 @@ use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n-pub use core::str::{Split, SplitTerminator};\n-pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{Split, SplitTerminator, SplitN};\n+pub use core::str::{RSplit, RSplitN};\n pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n@@ -699,6 +699,34 @@ impl str {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// starting from the end of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(&self[..], pat)\n+    }\n+\n     /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n     /// starting from the end of the string.\n     ///"}, {"sha": "2498b27395a4c569ae459e771127b80304b82d1f", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "patch": "@@ -910,6 +910,20 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_rsplit() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplit(' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"l\u00e4mb\\nLittle\", \"little\", \"\u00e4\", \"h\u00e4d\", \"\\nM\u00e4ry\"]);\n+\n+    let split: Vec<&str> = data.rsplit(\"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nLittle \", \"\\nM\u00e4ry h\u00e4d \u00e4 little \"]);\n+\n+    let split: Vec<&str> = data.rsplit(|c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"mb\\nLittle l\", \" little l\", \"d \", \"ry h\", \"\\nM\"]);\n+}\n+\n #[test]\n fn test_words() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "fc2aa256f05f4417c2465a413abdf85745eb3e54", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5148bda1364bd46607a3c4ebdcfb0f408e0850/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "patch": "@@ -111,7 +111,24 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-    }\n+    };\n+    (pattern reverse $te:ty : $ti:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, P: Pattern<'a>> Iterator for $ti\n+            where P::Searcher: ReverseSearcher<'a>\n+        {\n+            type Item = $te;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                self.0.size_hint()\n+            }\n+        }\n+    };\n }\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n@@ -553,6 +570,19 @@ struct CharSplitsN<'a, P: Pattern<'a>> {\n     invert: bool,\n }\n \n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, in reverse order.\n+struct RCharSplits<'a, P: Pattern<'a>> {\n+    /// The slice remaining to be iterated\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n+    /// Whether an empty string at the end of iteration is allowed\n+    allow_final_empty: bool,\n+    finished: bool,\n+}\n+\n+\n /// An iterator over the lines of a string, separated by `\\n`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<'a> {\n@@ -646,6 +676,43 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n     }\n }\n \n+impl<'a, P: Pattern<'a>> RCharSplits<'a, P> {\n+    #[inline]\n+    fn get_remainder(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_final_empty || self.end - self.start > 0) {\n+            self.finished = true;\n+            unsafe {\n+                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n+                Some(string)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.slice_unchecked(b, self.end);\n+                self.end = a;\n+                Some(elt)\n+            },\n+            None => self.get_remainder(),\n+        }\n+    }\n+}\n+\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n@@ -1321,6 +1388,11 @@ delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n+/// Return type of `StrExt::rsplit`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n+\n /// Return type of `StrExt::rsplitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n@@ -1340,6 +1412,8 @@ pub trait StrExt {\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n     #[allow(deprecated) /* for SplitStr */]\n@@ -1436,6 +1510,19 @@ impl StrExt for str {\n         })\n     }\n \n+    #[inline]\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplit(RCharSplits {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_final_empty: true,\n+            finished: false,\n+        })\n+    }\n+\n     #[inline]\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n         RSplitN(CharSplitsN {"}]}