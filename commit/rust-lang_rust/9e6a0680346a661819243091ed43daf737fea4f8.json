{"sha": "9e6a0680346a661819243091ed43daf737fea4f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNmEwNjgwMzQ2YTY2MTgxOTI0MzA5MWVkNDNkYWY3MzdmZWE0Zjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T07:14:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T21:37:30Z"}, "message": "replace last_use with liveness info", "tree": {"sha": "a8ddc7967a018a551983ce2653f8fb157256c2e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8ddc7967a018a551983ce2653f8fb157256c2e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e6a0680346a661819243091ed43daf737fea4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e6a0680346a661819243091ed43daf737fea4f8", "html_url": "https://github.com/rust-lang/rust/commit/9e6a0680346a661819243091ed43daf737fea4f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e6a0680346a661819243091ed43daf737fea4f8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "html_url": "https://github.com/rust-lang/rust/commit/62fe587f8114aca19e1aa6ab421d06b320ac1b4b"}], "stats": {"total": 603, "additions": 122, "deletions": 481}, "files": [{"sha": "76b7cfa76cddb9f9ae6366d2fe7b19fdb9be9acf", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -4,8 +4,7 @@ import session::session;\n import syntax::parse;\n import syntax::{ast, codemap};\n import syntax::attr;\n-import middle::{trans, resolve, freevars, kind, ty, typeck,\n-                last_use, lint};\n+import middle::{trans, resolve, freevars, kind, ty, typeck, lint};\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n@@ -192,29 +191,27 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_loop::check_crate(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n-    let _last_use_map =\n+    let (last_use_map, spill_map) =\n         time(time_passes, \"liveness checking\",\n              bind middle::liveness::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n     let (root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n         bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n-    let (copy_map, ref_map) =\n+    let (copy_map, _ref_map) =\n         time(time_passes, \"alias checking\",\n              bind middle::alias::check_crate(ty_cx, crate));\n-    let (last_uses, spill_map) = time(time_passes, \"last use finding\",\n-        bind last_use::find_last_uses(crate, def_map, ref_map, ty_cx));\n     time(time_passes, \"kind checking\",\n-         bind kind::check_crate(ty_cx, method_map, last_uses, crate));\n+         bind kind::check_crate(ty_cx, method_map, last_use_map, crate));\n \n     lint::check_crate(ty_cx, crate, sess.opts.lint_opts, time_passes);\n \n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n-                copy_map: copy_map, last_uses: last_uses,\n+                copy_map: copy_map, last_use_map: last_use_map,\n                 impl_map: impl_map, method_map: method_map,\n                 vtable_map: vtable_map, spill_map: spill_map};\n "}, {"sha": "af19496c9b87f490670617564b5019cce2b3964c", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -1,5 +1,6 @@\n import util::ppaux::ty_to_str;\n \n+import dvec::extensions;\n import syntax::ast;\n import syntax::fold;\n import syntax::visit;\n@@ -18,7 +19,7 @@ import std::serialization::serializer_helpers;\n import std::serialization::deserializer_helpers;\n import std::prettyprint::serializer;\n import std::smallintmap::map;\n-import middle::{ty, typeck, last_use};\n+import middle::{ty, typeck};\n import middle::typeck::{method_origin,\n                         serialize_method_origin,\n                         deserialize_method_origin,\n@@ -52,11 +53,11 @@ type maps = {\n     mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n     copy_map: middle::alias::copy_map,\n-    last_uses: middle::last_use::last_uses,\n+    last_use_map: middle::liveness::last_use_map,\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n-    spill_map: middle::last_use::spill_map\n+    spill_map: middle::liveness::spill_map\n };\n \n type decode_ctxt = @{\n@@ -539,10 +540,6 @@ impl helper for ebml::ebml_deserializer {\n         let fv = deserialize_method_origin(self);\n         fv.tr(xcx)\n     }\n-    fn read_is_last_use(xcx: extended_decode_ctxt) -> last_use::is_last_use {\n-        let lu = last_use::deserialize_is_last_use(self);\n-        lu.tr(xcx)\n-    }\n }\n \n impl of tr for method_origin {\n@@ -561,17 +558,6 @@ impl of tr for method_origin {\n     }\n }\n \n-impl of tr for last_use::is_last_use {\n-    fn tr(xcx: extended_decode_ctxt) -> last_use::is_last_use {\n-        alt self {\n-          last_use::is_last_use { self }\n-          last_use::closes_over(ids) {\n-            last_use::closes_over(vec::map(ids, {|id| xcx.tr_id(id)}))\n-          }\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n@@ -844,11 +830,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(maps.last_uses.find(id)) {|m|\n+    option::iter(maps.last_use_map.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val) {||\n-                last_use::serialize_is_last_use(ebml_w, m)\n+                ebml_w.emit_from_vec((*m).get()) {|id|\n+                    ebml_w.emit_int(id);\n+                }\n             }\n         }\n     }\n@@ -975,7 +963,11 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let bounds = val_dsr.read_bounds(xcx);\n                 dcx.tcx.ty_param_bounds.insert(id, bounds);\n             } else if tag == (c::tag_table_last_use as uint) {\n-                dcx.maps.last_uses.insert(id, val_dsr.read_is_last_use(xcx));\n+                let ids = val_dsr.read_to_vec {||\n+                    xcx.tr_id(val_dsr.read_int())\n+                };\n+                let dvec = @dvec::from_vec(vec::to_mut(ids));\n+                dcx.maps.last_use_map.insert(id, dvec);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(id,\n                                            val_dsr.read_method_origin(xcx));"}, {"sha": "d6e7ce1b99078633311fe76341dde0a13f326bba", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -138,10 +138,10 @@ enum loan_path {\n // a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n-fn save_and_restore<T:copy,U>(&t: T, f: fn() -> U) -> U {\n-    let old_t = t;\n+fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n+    let old_save_and_restore_t = save_and_restore_t;\n     let u <- f();\n-    t = old_t;\n+    save_and_restore_t = old_save_and_restore_t;\n     ret u;\n }\n \n@@ -888,6 +888,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n+    #debug[\"purity on entry=%?\", self.declared_purity];\n     save_and_restore(self.in_ctor) {||\n         save_and_restore(self.declared_purity) {||\n             // In principle, we could consider fk_anon(*) or\n@@ -909,6 +910,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n         }\n     }\n+    #debug[\"purity on exit=%?\", self.declared_purity];\n }\n \n fn check_loans_in_expr(expr: @ast::expr,"}, {"sha": "cebefa01abcfbff2b919d62816125d02134d127a", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -8,6 +8,7 @@ import std::map::hashmap;\n import util::ppaux::{ty_to_str, tys_to_str};\n import syntax::print::pprust::expr_to_str;\n import freevars::freevar_entry;\n+import dvec::extensions;\n \n // Kind analysis pass.\n //\n@@ -56,15 +57,15 @@ type rval_map = std::map::hashmap<node_id, ()>;\n type ctx = {tcx: ty::ctxt,\n             rval_map: rval_map,\n             method_map: typeck::method_map,\n-            last_uses: last_use::last_uses};\n+            last_use_map: liveness::last_use_map};\n \n fn check_crate(tcx: ty::ctxt, method_map: typeck::method_map,\n-               last_uses: last_use::last_uses, crate: @crate)\n+               last_use_map: liveness::last_use_map, crate: @crate)\n     -> rval_map {\n     let ctx = {tcx: tcx,\n                rval_map: std::map::int_hash(),\n                method_map: method_map,\n-               last_uses: last_uses};\n+               last_use_map: last_use_map};\n     let visit = visit::mk_vt(@{\n         visit_expr: check_expr,\n         visit_stmt: check_stmt,\n@@ -177,11 +178,10 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             // if this is the last use of the variable, then it will be\n             // a move and not a copy\n             let is_move = {\n-                let last_uses = alt check cx.last_uses.find(fn_id) {\n-                  some(last_use::closes_over(vars)) { vars }\n-                  none { [] }\n-                };\n-                last_uses.contains(id)\n+                alt check cx.last_use_map.find(fn_id) {\n+                  some(vars) {(*vars).contains(id)}\n+                  none {false}\n+                }\n             };\n \n             let ty = ty::node_id_to_type(cx.tcx, id);\n@@ -367,7 +367,7 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n \n fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n     if ty::expr_is_lval(cx.method_map, ex) &&\n-       !cx.last_uses.contains_key(ex.id) &&\n+       !cx.last_use_map.contains_key(ex.id) &&\n        !is_nullary_variant(cx, ex) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n         check_copy(cx, ty, ex.span);"}, {"sha": "0c49196a0cde7116103875da807f2c90f90c8bc1", "filename": "src/rustc/middle/last_use.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fe587f8114aca19e1aa6ab421d06b320ac1b4b/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=62fe587f8114aca19e1aa6ab421d06b320ac1b4b", "patch": "@@ -1,393 +0,0 @@\n-import syntax::{visit, ast_util};\n-import syntax::ast::*;\n-import syntax::codemap::span;\n-import std::list::{is_not_empty, list, nil, cons, tail};\n-import core::unreachable;\n-import std::list;\n-import std::map::hashmap;\n-\n-// Last use analysis pass.\n-//\n-// Finds the last read of each value stored in a local variable or\n-// callee-owned argument (arguments with by-move or by-copy passing\n-// style). This is a limited form of liveness analysis, peformed\n-// (perhaps foolishly) directly on the AST.\n-//\n-// The algorithm walks the AST, keeping a set of (def, last_use)\n-// pairs. When the function is exited, or the local is overwritten,\n-// the current set of last uses is marked with 'true' in a table.\n-// Other branches may later overwrite them with 'false' again, since\n-// they may find a use coming after them. (Marking an expression as a\n-// last use is only done if it has not already been marked with\n-// 'false'.)\n-//\n-// Some complexity is added to deal with joining control flow branches\n-// (by `break` or conditionals), and for handling loops.\n-\n-// Marks expr_paths that are last uses.\n-#[auto_serialize]\n-enum is_last_use {\n-    is_last_use,\n-    closes_over([node_id]),\n-}\n-type last_uses = std::map::hashmap<node_id, is_last_use>;\n-type spill_map = std::map::hashmap<node_id, ()>;\n-\n-enum seen { unset, seen(node_id), }\n-enum block_type { func, lp, }\n-\n-enum use { var_use(node_id), close_over(node_id), }\n-type set = [{def: node_id, uses: @list<use>}];\n-type bl = @{type: block_type, mut second: bool, mut exits: [set]};\n-\n-enum use_id { path(node_id), close(node_id, node_id) }\n-fn hash_use_id(id: use_id) -> uint {\n-    (alt id { path(i) { i } close(i, j) { (i << 10) + j } }) as uint\n-}\n-\n-type ctx = {last_uses: std::map::hashmap<use_id, bool>,\n-            spill_map: std::map::hashmap<node_id, ()>,\n-            def_map: resolve::def_map,\n-            ref_map: alias::ref_map,\n-            tcx: ty::ctxt,\n-            // The current set of local last uses\n-            mut current: set,\n-            mut blocks: @list<bl>};\n-\n-fn find_last_uses(c: @crate, def_map: resolve::def_map,\n-                  ref_map: alias::ref_map, tcx: ty::ctxt)\n-    -> (last_uses, spill_map) {\n-    let v = visit::mk_vt(@{visit_expr: visit_expr,\n-                           visit_stmt: visit_stmt,\n-                           visit_fn: visit_fn\n-                           with *visit::default_visitor()});\n-    let cx = {last_uses: std::map::hashmap(hash_use_id, {|a, b| a == b}),\n-              spill_map: std::map::int_hash(),\n-              def_map: def_map,\n-              ref_map: ref_map,\n-              tcx: tcx,\n-              mut current: [],\n-              mut blocks: @nil};\n-    visit::visit_crate(*c, cx, v);\n-    let mini_table = std::map::int_hash();\n-    for cx.last_uses.each {|key, val|\n-        if val {\n-            alt key {\n-              path(id) {\n-                mini_table.insert(id, is_last_use);\n-                let def_node = ast_util::def_id_of_def(def_map.get(id)).node;\n-                cx.spill_map.insert(def_node, ());\n-              }\n-              close(fn_id, local_id) {\n-                cx.spill_map.insert(local_id, ());\n-                let known = alt check mini_table.find(fn_id) {\n-                  some(closes_over(ids)) { ids }\n-                  none { [] }\n-                };\n-                mini_table.insert(fn_id, closes_over(known + [local_id]));\n-              }\n-            }\n-        }\n-    }\n-    ret (mini_table, cx.spill_map);\n-}\n-\n-fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n-    alt ex.node {\n-      expr_ret(oexpr) {\n-        visit::visit_expr_opt(oexpr, cx, v);\n-        if !add_block_exit(cx, func) { leave_fn(cx); }\n-      }\n-      expr_fail(oexpr) {\n-        visit::visit_expr_opt(oexpr, cx, v);\n-        leave_fn(cx);\n-      }\n-      expr_break { add_block_exit(cx, lp); }\n-      expr_while(_, _) | expr_loop(_) {\n-        visit_block(lp, cx) {|| visit::visit_expr(ex, cx, v);}\n-      }\n-      expr_alt(input, arms, _) {\n-        v.visit_expr(input, cx, v);\n-        let before = cx.current;\n-        let mut sets = [];\n-        for arms.each {|arm|\n-            cx.current = before;\n-            v.visit_arm(arm, cx, v);\n-            sets += [cx.current];\n-        }\n-        cx.current = join_branches(sets);\n-      }\n-      expr_if(cond, then, els) {\n-        v.visit_expr(cond, cx, v);\n-        let mut cur = cx.current;\n-        visit::visit_block(then, cx, v);\n-        cx.current <-> cur;\n-        visit::visit_expr_opt(els, cx, v);\n-        cx.current = join_branches([cur, cx.current]);\n-      }\n-      expr_path(_) {\n-        let my_def = cx.def_map.get(ex.id);\n-        let my_def_id = ast_util::def_id_of_def(my_def).node;\n-        alt cx.ref_map.find(my_def_id) {\n-          option::some(root_id) {\n-            clear_in_current(cx, root_id, false);\n-          }\n-          _ {\n-            option::iter(def_is_owned_local(cx, my_def)) {|nid|\n-                clear_in_current(cx, nid, false);\n-                cx.current += [{def: nid,\n-                                uses: @cons(var_use(ex.id), @nil)}];\n-            }\n-          }\n-        }\n-      }\n-      expr_swap(lhs, rhs) {\n-        clear_if_path(cx, lhs, v, false);\n-        clear_if_path(cx, rhs, v, false);\n-      }\n-      expr_move(dest, src) | expr_assign(dest, src) {\n-        v.visit_expr(src, cx, v);\n-        clear_if_path(cx, dest, v, true);\n-      }\n-      expr_assign_op(_, dest, src) {\n-        v.visit_expr(src, cx, v);\n-        v.visit_expr(dest, cx, v);\n-        clear_if_path(cx, dest, v, true);\n-      }\n-      expr_fn_block(_, _, cap_clause) |\n-      expr_fn(_, _, _, cap_clause) {\n-        // n.b.: safe to ignore copies, as if they are unused\n-        // then they are ignored, otherwise they will show up\n-        // as freevars in the body.\n-        for (*cap_clause).each { |ci|\n-            if ci.is_move {\n-                clear_def_if_local(cx, cx.def_map.get(ci.id), false);\n-            }\n-        }\n-        visit::visit_expr(ex, cx, v);\n-      }\n-      expr_call(f, args, _) {\n-        v.visit_expr(f, cx, v);\n-        let mut fns = [];\n-        let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n-        vec::iter2(args, arg_ts) {|arg, arg_t|\n-            alt arg.node {\n-              expr_fn(*) | expr_fn_block(*)\n-              if is_blockish(ty::ty_fn_proto(arg_t.ty)) {\n-                fns += [arg];\n-              }\n-              _ {\n-                alt ty::arg_mode(cx.tcx, arg_t) {\n-                  by_mutbl_ref { clear_if_path(cx, arg, v, false); }\n-                  _ { v.visit_expr(arg, cx, v); }\n-                }\n-              }\n-            }\n-        }\n-        for fns.each {|f| v.visit_expr(f, cx, v); }\n-        vec::iter2(args, arg_ts) {|arg, arg_t|\n-            alt arg.node {\n-              expr_path(_) {\n-                alt ty::arg_mode(cx.tcx, arg_t) {\n-                  by_ref | by_val | by_mutbl_ref {\n-                    let def = cx.def_map.get(arg.id);\n-                    option::iter(def_is_owned_local(cx, def)) {|id|\n-                        clear_in_current(cx, id, false);\n-                        cx.spill_map.insert(id, ());\n-                    }\n-                  }\n-                  _ {}\n-                }\n-              }\n-              _ {}\n-            }\n-        }\n-      }\n-      _ { visit::visit_expr(ex, cx, v); }\n-    }\n-}\n-\n-fn visit_stmt(s: @stmt, cx: ctx, v: visit::vt<ctx>) {\n-    alt s.node {\n-      stmt_decl(@{node: decl_local(ls), _}, _) {\n-        shadow_in_current(cx, {|id|\n-            let mut rslt = false;\n-            for ls.each {|local|\n-                let mut found = false;\n-                pat_util::pat_bindings(cx.tcx.def_map, local.node.pat,\n-                                       {|pid, _a, _b|\n-                    if pid == id { found = true; }\n-                });\n-                if found { rslt = true; break; }\n-            }\n-            rslt\n-        });\n-      }\n-      _ {}\n-    }\n-    visit::visit_stmt(s, cx, v);\n-}\n-\n-fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-            sp: span, id: node_id,\n-            cx: ctx, v: visit::vt<ctx>) {\n-    let fty = ty::node_id_to_type(cx.tcx, id);\n-    let proto = ty::ty_fn_proto(fty);\n-    alt proto {\n-      proto_any | proto_block {\n-        visit_block(func, cx, {||\n-            shadow_in_current(cx, {|id|\n-                vec::any(decl.inputs, {|arg| arg.id == id})\n-            });\n-            visit::visit_fn(fk, decl, body, sp, id, cx, v);\n-        });\n-      }\n-      proto_box | proto_uniq | proto_bare {\n-        alt cx.tcx.freevars.find(id) {\n-          some(vars) {\n-            for vec::each(*vars) {|v|\n-                option::iter(def_is_owned_local(cx, v.def)) {|nid|\n-                    clear_in_current(cx, nid, false);\n-                    cx.current += [{def: nid,\n-                                    uses: @cons(close_over(id), @nil)}];\n-                }\n-            }\n-          }\n-          _ {}\n-        }\n-        let mut old_cur = [], old_blocks = @nil;\n-        cx.blocks <-> old_blocks;\n-        cx.current <-> old_cur;\n-        visit::visit_fn(fk, decl, body, sp, id, cx, v);\n-        cx.blocks <-> old_blocks;\n-        leave_fn(cx);\n-        cx.current <-> old_cur;\n-      }\n-    }\n-}\n-\n-fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n-    let local = @{type: tp, mut second: false, mut exits: []};\n-    cx.blocks = @cons(local, cx.blocks);\n-    visit();\n-    local.second = true;\n-    local.exits = [];\n-    visit();\n-    let cx_blocks = cx.blocks;\n-    cx.blocks = tail(cx_blocks);\n-    local.exits += [cx.current];\n-    cx.current = join_branches(local.exits);\n-}\n-\n-fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n-    let mut cur = cx.blocks;\n-    loop {\n-        alt *cur {\n-          cons(b, tail) {\n-            if (b.type == tp) {\n-                if !b.second { b.exits += [cx.current]; }\n-                ret true;\n-            }\n-            cur = tail;\n-          }\n-          nil {\n-            ret false;\n-          }\n-        }\n-    }\n-}\n-\n-fn join_branches(branches: [set]) -> set {\n-    let mut found: set = [], i = 0u;\n-    let l = vec::len(branches);\n-    for branches.each {|set|\n-        i += 1u;\n-        for set.each {|elt|\n-            if !vec::any(found, {|v| v.def == elt.def}) {\n-                let mut j = i, nne = elt.uses;\n-                while j < l {\n-                    for vec::each(branches[j]) {|elt2|\n-                        if elt2.def == elt.def {\n-                            list::iter(elt2.uses) {|e|\n-                                if !list::has(nne, e) { nne = @cons(e, nne); }\n-                            }\n-                        }\n-                    }\n-                    j += 1u;\n-                }\n-                found += [{def: elt.def, uses: nne}];\n-            }\n-        }\n-    }\n-    ret found;\n-}\n-\n-fn leave_fn(cx: ctx) {\n-    for cx.current.each {|elt|\n-        list::iter(elt.uses) {|use|\n-            let key = alt use {\n-              var_use(pth_id) { path(pth_id) }\n-              close_over(fn_id) { close(fn_id, elt.def) }\n-            };\n-            if !cx.last_uses.contains_key(key) {\n-                cx.last_uses.insert(key, true);\n-            }\n-        }\n-    }\n-}\n-\n-fn shadow_in_current(cx: ctx, p: fn(node_id) -> bool) {\n-    let mut out = [];\n-    cx.current <-> out;\n-    for out.each {|e| if !p(e.def) { cx.current += [e]; } }\n-}\n-\n-fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n-    for cx.current.each {|elt|\n-        if elt.def == my_def {\n-            list::iter(elt.uses) {|use|\n-                let key = alt use {\n-                  var_use(pth_id) { path(pth_id) }\n-                  close_over(fn_id) { close(fn_id, elt.def) }\n-                };\n-                if !to || !cx.last_uses.contains_key(key) {\n-                    cx.last_uses.insert(key, to);\n-                }\n-            }\n-            cx.current = vec::filter(copy cx.current, {|x| x.def != my_def});\n-            break;\n-        }\n-    }\n-}\n-\n-fn def_is_owned_local(cx: ctx, d: def) -> option<node_id> {\n-    alt d {\n-      def_local(id, _) { some(id) }\n-      def_arg(id, m) {\n-        alt ty::resolved_mode(cx.tcx, m) {\n-          by_copy | by_move { some(id) }\n-          by_ref | by_val | by_mutbl_ref { none }\n-        }\n-      }\n-      def_upvar(_, d, fn_id) {\n-        if is_blockish(ty::ty_fn_proto(ty::node_id_to_type(cx.tcx, fn_id))) {\n-            def_is_owned_local(cx, *d)\n-        } else { none }\n-      }\n-      _ { none }\n-    }\n-}\n-\n-fn clear_def_if_local(cx: ctx, d: def, to: bool) {\n-    alt def_is_owned_local(cx, d) {\n-      some(nid) { clear_in_current(cx, nid, to); }\n-      _ {}\n-    }\n-}\n-\n-fn clear_if_path(cx: ctx, ex: @expr, v: visit::vt<ctx>, to: bool) {\n-    alt ex.node {\n-      expr_path(_) { clear_def_if_local(cx, cx.def_map.get(ex.id), to); }\n-      _ { v.visit_expr(ex, cx, v); }\n-    }\n-}"}, {"sha": "add1484e190fe2fcc19bb00119cb1b4a9915b57d", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 81, "deletions": 39, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -57,6 +57,7 @@ import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n \n export check_crate;\n export last_use_map;\n+export spill_map;\n \n // Maps from an expr id to a list of variable ids for which this expr\n // is the last use.  Typically, the expr is a path and the node id is\n@@ -84,7 +85,7 @@ enum live_node_kind {\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               crate: @crate) -> last_use_map {\n+               crate: @crate) -> (last_use_map, spill_map) {\n     let visitor = visit::mk_vt(@{\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -98,7 +99,7 @@ fn check_crate(tcx: ty::ctxt,\n                                 last_use_map, spill_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    ret last_use_map;\n+    ret (last_use_map, spill_map);\n }\n \n impl of to_str::to_str for live_node {\n@@ -141,7 +142,13 @@ enum relevant_def { rdef_var(node_id), rdef_self }\n \n type capture_info = {ln: live_node, is_move: bool, rv: relevant_def};\n \n-type var_info = {id: node_id, name: str};\n+enum var_kind {\n+    vk_arg(node_id, str, rmode),\n+    vk_local(node_id, str),\n+    vk_field(str),\n+    vk_self,\n+    vk_implicit_ret\n+}\n \n fn relevant_def(def: def) -> option<relevant_def> {\n     alt def {\n@@ -163,7 +170,7 @@ class ir_maps {\n     let variable_map: hashmap<node_id, variable>;\n     let field_map: hashmap<str, variable>;\n     let capture_map: hashmap<node_id, @[capture_info]>;\n-    let mut var_infos: [var_info];\n+    let mut var_kinds: [var_kind];\n     let mut lnks: [live_node_kind];\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n@@ -179,7 +186,7 @@ class ir_maps {\n         self.variable_map = int_hash();\n         self.capture_map = int_hash();\n         self.field_map = str_hash();\n-        self.var_infos = [];\n+        self.var_kinds = [];\n         self.lnks = [];\n     }\n \n@@ -200,13 +207,23 @@ class ir_maps {\n         #debug[\"%s is node %d\", ln.to_str(), node_id];\n     }\n \n-    fn add_variable(node_id: node_id, name: str) -> variable {\n+    fn add_variable(vk: var_kind) -> variable {\n         let v = variable(self.num_vars);\n-        self.variable_map.insert(node_id, v);\n-        self.var_infos += [{id:node_id, name:name}];\n+        self.var_kinds += [vk];\n         self.num_vars += 1u;\n \n-        #debug[\"%s is node %d\", v.to_str(), node_id];\n+        alt vk {\n+          vk_local(node_id, _) | vk_arg(node_id, _, _) {\n+            self.variable_map.insert(node_id, v);\n+          }\n+          vk_field(name) {\n+            self.field_map.insert(name, v);\n+          }\n+          vk_self | vk_implicit_ret {\n+          }\n+        }\n+\n+        #debug[\"%s is %?\", v.to_str(), vk];\n \n         v\n     }\n@@ -221,6 +238,15 @@ class ir_maps {\n         }\n     }\n \n+    fn variable_name(var: variable) -> str {\n+        alt self.var_kinds[*var] {\n+          vk_local(_, name) | vk_arg(_, name, _) {name}\n+          vk_field(name) {\"self.\" + name}\n+          vk_self {\"self\"}\n+          vk_implicit_ret {\"<implicit-ret>\"}\n+        }\n+    }\n+\n     fn set_captures(node_id: node_id, +cs: [capture_info]) {\n         self.capture_map.insert(node_id, @cs);\n     }\n@@ -238,24 +264,40 @@ class ir_maps {\n         self.lnks[*ln]\n     }\n \n-    fn add_last_use(expr_id: node_id, var: variable) {\n-        let v = alt self.last_use_map.find(expr_id) {\n-          some(v) { v }\n-          none {\n-            let v = @dvec();\n-            self.last_use_map.insert(expr_id, v);\n-            v\n+    fn add_spill(var: variable) {\n+        let vk = self.var_kinds[*var];\n+        alt vk {\n+          vk_local(id, _) | vk_arg(id, _, by_val) {\n+            #debug[\"adding spill for %?\", vk];\n+            self.spill_map.insert(id, ());\n           }\n-        };\n-        let {id, name} = self.var_infos[*var];\n-        #debug[\"Node %d is a last use of variable %d / %s\",\n-               expr_id, id, name];\n-        (*v).push(id);\n+          vk_arg(*) | vk_field(_) | vk_self | vk_implicit_ret {}\n+        }\n     }\n \n-    fn add_spill(var: variable) {\n-        let id = self.var_infos[*var].id;\n-        if id != 0 { self.spill_map.insert(id, ()); }\n+    fn add_last_use(expr_id: node_id, var: variable) {\n+        let vk = self.var_kinds[*var];\n+        #debug[\"Node %d is a last use of variable %?\", expr_id, vk];\n+        alt vk {\n+          vk_arg(id, name, by_move) |\n+          vk_arg(id, name, by_copy) |\n+          vk_local(id, name) {\n+            let v = alt self.last_use_map.find(expr_id) {\n+              some(v) { v }\n+              none {\n+                let v = @dvec();\n+                self.last_use_map.insert(expr_id, v);\n+                v\n+              }\n+            };\n+\n+            (*v).push(id);\n+          }\n+          vk_arg(_, _, by_ref) | vk_arg(_, _, by_mutbl_ref) |\n+          vk_arg(_, _, by_val) | vk_self | vk_field(_) | vk_implicit_ret {\n+            #debug[\"--but it is not owned\"];\n+          }\n+        }\n     }\n }\n \n@@ -272,7 +314,8 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     for decl.inputs.each { |arg|\n         #debug[\"adding argument %d\", arg.id];\n-        (*fn_maps).add_variable(arg.id, arg.ident);\n+        let mode = ty::resolved_mode(self.tcx, arg.mode);\n+        (*fn_maps).add_variable(vk_arg(arg.id, arg.ident, mode));\n     };\n \n     // gather up the various local variables, significant expressions,\n@@ -293,8 +336,8 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     let specials = {\n         exit_ln: (*fn_maps).add_live_node(lnk_exit),\n         fallthrough_ln: (*fn_maps).add_live_node(lnk_exit),\n-        no_ret_var: (*fn_maps).add_variable(0, \"<no_ret>\"),\n-        self_var: (*fn_maps).add_variable(0, \"self\")\n+        no_ret_var: (*fn_maps).add_variable(vk_implicit_ret),\n+        self_var: (*fn_maps).add_variable(vk_self)\n     };\n \n     // compute liveness\n@@ -317,8 +360,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n fn add_class_fields(self: @ir_maps, did: def_id) {\n     for ty::lookup_class_fields(self.tcx, did).each { |field_ty|\n         assert field_ty.id.crate == local_crate;\n-        let var = (*self).add_variable(\n-            field_ty.id.node, #fmt[\"self.%s\", field_ty.ident]);\n+        let var = (*self).add_variable(vk_field(field_ty.ident));\n         self.field_map.insert(field_ty.ident, var);\n     }\n }\n@@ -329,7 +371,7 @@ fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n         #debug[\"adding local variable %d\", p_id];\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n-        (*self).add_variable(p_id, name);\n+        (*self).add_variable(vk_local(p_id, name));\n     }\n     visit::visit_local(local, self, vt);\n }\n@@ -730,6 +772,9 @@ class liveness {\n             }\n         }\n \n+        // as above, the \"self\" variable is a non-owned variable\n+        self.acc(self.s.exit_ln, self.s.self_var, ACC_READ);\n+\n         // in a ctor, there is an implicit use of self.f for all fields f:\n         for self.ir.field_map.each_value { |var|\n             self.acc(self.s.exit_ln, var, ACC_READ|ACC_USE);\n@@ -938,8 +983,8 @@ class liveness {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_expr(r, succ);\n-            self.propagate_through_lvalue_components(l, succ)\n+            let succ = self.propagate_through_lvalue_components(l, succ);\n+            self.propagate_through_expr(r, succ)\n           }\n \n           expr_swap(l, r) {\n@@ -1063,14 +1108,11 @@ class liveness {\n         // ----------------------++-----------------------\n         //                       ||\n         //         |             ||           |\n-        //         |             ||           v\n-        //         |             ||   (lvalue components)\n-        //         |             ||           |\n         //         v             ||           v\n         //     (rvalue)          ||       (rvalue)\n         //         |             ||           |\n-        //         v             ||           |\n-        // (write of lvalue)     ||           |\n+        //         v             ||           v\n+        // (write of lvalue)     ||   (lvalue components)\n         //         |             ||           |\n         //         v             ||           v\n         //      (succ)           ||        (succ)\n@@ -1604,7 +1646,7 @@ impl check_methods for @liveness {\n           possibly_uninitialized_field {\"possibly uninitialized field\"}\n           moved_variable {\"moved variable\"}\n         };\n-        let name = self.ir.var_infos[*var].name;\n+        let name = (*self.ir).variable_name(var);\n         alt lnk {\n           lnk_freevar(span) {\n             self.tcx.sess.span_err(\n@@ -1625,7 +1667,7 @@ impl check_methods for @liveness {\n     }\n \n     fn should_warn(var: variable) -> option<str> {\n-        let name = self.ir.var_infos[*var].name;\n+        let name = (*self.ir).variable_name(var);\n         if name[0] == ('_' as u8) {none} else {some(name)}\n     }\n "}, {"sha": "e2feeed49df170e4788c483bf21bb2e8862cf917", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -2832,7 +2832,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     } else if arg_mode == ast::by_copy || arg_mode == ast::by_move {\n         let alloc = alloc_ty(bcx, arg.ty);\n         let move_out = arg_mode == ast::by_move ||\n-            ccx.maps.last_uses.contains_key(e.id);\n+            ccx.maps.last_use_map.contains_key(e.id);\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n         if lv.kind == owned || !ty::type_is_immediate(arg.ty) {\n             memmove_ty(bcx, alloc, val, arg.ty);\n@@ -3561,7 +3561,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             let src_r = trans_temp_lval(bcx, src);\n             let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n             assert kind == owned;\n-            let is_last_use = bcx.ccx().maps.last_uses.contains_key(src.id);\n+            let is_last_use =\n+                bcx.ccx().maps.last_use_map.contains_key(src.id);\n             ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n                                 expr_ty(bcx, src), is_last_use);\n           }\n@@ -3639,10 +3640,10 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n }\n \n fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let last_uses = bcx.ccx().maps.last_uses;\n+    let last_use_map = bcx.ccx().maps.last_use_map;\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n-    let last_use = (lv.kind == owned && last_uses.contains_key(e.id));\n+    let last_use = (lv.kind == owned && last_use_map.contains_key(e.id));\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n "}, {"sha": "348f90ae6aceb106d0b1acd38673fa8db855c4eb", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -18,6 +18,7 @@ import util::ppaux::ty_to_str;\n import syntax::ast_map::{path, path_mod, path_name};\n import driver::session::session;\n import std::map::hashmap;\n+import dvec::extensions;\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -307,9 +308,9 @@ fn build_closure(bcx0: block,\n             env_vals += [env_ref(lv.val, ty, lv.kind)];\n           }\n           capture::cap_copy {\n-            let mv = alt check ccx.maps.last_uses.find(id) {\n+            let mv = alt check ccx.maps.last_use_map.find(id) {\n               none { false }\n-              some(last_use::closes_over(vars)) { vec::contains(vars, nid) }\n+              some(vars) { (*vars).contains(nid) }\n             };\n             if mv { env_vals += [env_move(lv.val, ty, lv.kind)]; }\n             else { env_vals += [env_copy(lv.val, ty, lv.kind)]; }"}, {"sha": "81f5f467847a53ce37d59628a24f321b07eb00bf", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -71,7 +71,6 @@ mod middle {\n     mod lint;\n     mod borrowck;\n     mod alias;\n-    mod last_use;\n     mod liveness;\n     mod block_use;\n     mod kind;"}, {"sha": "d2bd85afc2a515a65237e799e41d4b846b4853d2", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e6a0680346a661819243091ed43daf737fea4f8/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e6a0680346a661819243091ed43daf737fea4f8/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=9e6a0680346a661819243091ed43daf737fea4f8", "patch": "@@ -10,7 +10,7 @@ fn start(+token: int) {\n     let mut ch = comm::chan(p);\n     int::range(2, n_threads + 1) { |i|\n         let id = n_threads + 2 - i;\n-        let to_child = task::spawn_listener::<int> {|p|\n+        let to_child = task::spawn_listener::<int> {|p, copy ch|\n             roundtrip(id, p, ch)\n         };\n         ch = to_child;"}]}