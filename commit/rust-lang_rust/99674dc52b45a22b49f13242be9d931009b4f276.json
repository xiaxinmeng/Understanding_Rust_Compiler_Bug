{"sha": "99674dc52b45a22b49f13242be9d931009b4f276", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5Njc0ZGM1MmI0NWEyMmI0OWYxMzI0MmJlOWQ5MzEwMDliNGYyNzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-24T23:23:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-25T12:45:52Z"}, "message": "avoid capture of bound regions when infering types for closure\nexpressions. cc #2981", "tree": {"sha": "368255f6b91bc748058b3aaaa7dbe4deb3b19103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/368255f6b91bc748058b3aaaa7dbe4deb3b19103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99674dc52b45a22b49f13242be9d931009b4f276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99674dc52b45a22b49f13242be9d931009b4f276", "html_url": "https://github.com/rust-lang/rust/commit/99674dc52b45a22b49f13242be9d931009b4f276", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99674dc52b45a22b49f13242be9d931009b4f276/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "html_url": "https://github.com/rust-lang/rust/commit/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24"}], "stats": {"total": 226, "additions": 189, "deletions": 37}, "files": [{"sha": "1471bbd1acbe3752acade8e1f9aa8f1cdb6b720c", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -160,6 +160,12 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n         w.write_str(*s);\n         w.write_char(']')\n       }\n+      ty::br_cap_avoid(id, br) {\n+        w.write_char('c');\n+        w.write_int(id);\n+        w.write_char('|');\n+        enc_bound_region(w, *br);\n+      }\n     }\n }\n "}, {"sha": "bb175be3903b332412e962a2c098be49bd8dd2c4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -100,7 +100,7 @@ export ty_self, mk_self, type_has_self;\n export ty_class;\n export region, bound_region, encl_region;\n export re_bound, re_free, re_scope, re_static, re_var;\n-export br_self, br_anon, br_named;\n+export br_self, br_anon, br_named, br_cap_avoid;\n export get, type_has_params, type_needs_infer, type_has_regions;\n export type_has_resources, type_id;\n export tbox_has_flag;\n@@ -351,9 +351,24 @@ enum region {\n }\n \n enum bound_region {\n-    br_self,      // The self region for classes, impls\n-    br_anon,      // The anonymous region parameter for a given function.\n-    br_named(ast::ident) // A named region parameter.\n+    /// The self region for classes, impls (&T in a type defn or &self/T)\n+    br_self,\n+\n+    /// Anonymous region parameter for a given fn (&T)\n+    br_anon,\n+\n+    /// Named region parameters for functions (a in &a/T)\n+    br_named(ast::ident),\n+\n+    /// Handles capture-avoiding substitution in a rather subtle case.  If you\n+    /// have a closure whose argument types are being inferred based on the\n+    /// expected type, and the expected type includes bound regions, then we\n+    /// will wrap those bound regions in a br_cap_avoid() with the id of the\n+    /// fn expression.  This ensures that the names are not \"captured\" by the\n+    /// enclosing scope, which may define the same names.  For an example of\n+    /// where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n+    /// and regions-ret-borrowed-1.rs.\n+    br_cap_avoid(ast::node_id, @bound_region),\n }\n \n type opt_region = option<region>;\n@@ -1665,7 +1680,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     ret result;\n }\n \n-// True if instantiating an instance of `ty` requires an instance of `r_ty`.\n+// True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n@@ -2001,6 +2016,7 @@ fn hash_bound_region(br: bound_region) -> uint {\n       ty::br_self { 0u }\n       ty::br_anon { 1u }\n       ty::br_named(str) { str::hash(*str) }\n+      ty::br_cap_avoid(id, br) { id as uint | hash_bound_region(*br) }\n     }\n }\n "}, {"sha": "599bfc18b136bcb5d5410848f632ec8e99bb519d", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -1084,11 +1084,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                      expected: option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n+        // Find the expected input/output types (if any).  Careful to\n+        // avoid capture of bound regions in the expected type.  See\n+        // def'n of br_cap_avoid() for a more lengthy explanation of\n+        // what's going on here.\n         let expected_tys = do unpack_expected(fcx, expected) |sty| {\n             alt sty {\n-              ty::ty_fn(fn_ty) {some({inputs:fn_ty.inputs,\n-                                      output:fn_ty.output})}\n-              _ {none}\n+              ty::ty_fn(fn_ty) => {\n+                let {fn_ty, _} =\n+                    replace_bound_regions_in_fn_ty(\n+                        tcx, @nil, none, fn_ty,\n+                        |br| ty::re_bound(ty::br_cap_avoid(expr.id, @br)));\n+                some({inputs:fn_ty.inputs,\n+                      output:fn_ty.output})\n+              }\n+              _ => {none}\n             }\n         };\n \n@@ -1984,15 +1994,26 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n \n+/// Checks whether a type can be created without an instance of itself.\n+/// This is similar but different from the question of whether a type\n+/// can be represented.  For example, the following type:\n+///\n+///     enum foo { none, some(foo) }\n+///\n+/// is instantiable but is not representable.  Similarly, the type\n+///\n+///     enum foo { some(@foo) }\n+///\n+/// is representable, but not instantiable.\n fn check_instantiable(tcx: ty::ctxt,\n                       sp: span,\n                       item_id: ast::node_id) {\n-    let rty = ty::node_id_to_type(tcx, item_id);\n-    if !ty::is_instantiable(tcx, rty) {\n+    let item_ty = ty::node_id_to_type(tcx, item_id);\n+    if !ty::is_instantiable(tcx, item_ty) {\n         tcx.sess.span_err(sp, #fmt[\"this type cannot be instantiated \\\n                                     without an instance of itself; \\\n                                     consider using `option<%s>`\",\n-                                   ty_to_str(tcx, rty)]);\n+                                   ty_to_str(tcx, item_ty)]);\n     }\n }\n \n@@ -2063,6 +2084,9 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     }\n \n     // Check that it is possible to instantiate this enum:\n+    //\n+    // This *sounds* like the same that as representable, but it's\n+    // not.  See def'n of `check_instantiable()` for details.\n     check_instantiable(ccx.tcx, sp, id);\n }\n "}, {"sha": "b114e659c4c0106a6566f0ee7ff76aaca3253391", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -1,6 +1,7 @@\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n+import middle::ty::{arg, canon_mode};\n+import middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n import middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n@@ -20,10 +21,20 @@ import driver::session::session;\n \n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n     alt br {\n-      br_anon                        { ~\"&\" }\n-      br_named(str)                  { #fmt[\"&%s\", *str] }\n-      br_self if cx.sess.ppregions() { ~\"&<self>\" }\n-      br_self                        { ~\"&self\" }\n+      br_anon                        => { ~\"&\" }\n+      br_named(str)                  => { #fmt[\"&%s\", *str] }\n+      br_self if cx.sess.ppregions() => { ~\"&<self>\" }\n+      br_self                        => { ~\"&self\" }\n+\n+      // FIXME(#3011) -- even if this arm is removed, exhaustiveness checking\n+      // does not fail\n+      br_cap_avoid(id, br) => {\n+        if cx.sess.ppregions() {\n+            #fmt[\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br)]\n+        } else {\n+            bound_region_to_str(cx, *br)\n+        }\n+      }\n     }\n }\n "}, {"sha": "fa100d12437cb7c21166d69a8eab114584e422c3", "filename": "src/test/compile-fail/borrowck-call-sendfn.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-sendfn.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -0,0 +1,8 @@\n+// xfail-test #2978\n+\n+fn call(x: @{mut f: fn~()}) {\n+    x.f(); //~ ERROR foo\n+    //~^ NOTE bar\n+}\n+\n+fn main() {}"}, {"sha": "7978ffc9550b4d45966c9f5a340a60d82a3b803e", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -5,7 +5,7 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n }\n \n fn borrow_from_arg_mut_ref(&v: ~int) {\n-    borrow(v); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "005689a9897694f344d0b44680c4b6c1bd77ac11", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -1,7 +1,7 @@\n enum foo = ~int;\n \n fn borrow(x: @mut foo) {\n-    let y = &***x; //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    let _y = &***x; //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     *x = foo(~4); //~ NOTE impure due to assigning to dereference of mutable @ pointer\n }\n "}, {"sha": "b7cb1202c3d50768c177a24373d5d5feee72ffe6", "filename": "src/test/compile-fail/borrowck-pure-scope-in-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -4,7 +4,7 @@ fn test1(x: @mut ~int) {\n     // Here, evaluating the second argument actually invalidates the\n     // first borrow, even though it occurs outside of the scope of the\n     // borrow!\n-    pure_borrow(*x, *x = ~5);  //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    pure_borrow(*x, *x = ~5);  //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to assigning to dereference of mutable @ pointer\n }\n "}, {"sha": "130a6f6bd85cc94dd0ec3028e9b0a2d7965b4bb0", "filename": "src/test/compile-fail/borrowck-uniq-via-box.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-box.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -1,22 +1,22 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: @mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_rec_mut(v: @{mut f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_mut_rec(v: @mut {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_mut_recs(v: @mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n@@ -33,27 +33,27 @@ fn box_imm_recs(v: @{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: @const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_rec_const(v: @{const f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_recs_const(v: @{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_const_rec(v: @const {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_const_recs(v: @const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "e52b3c7807d2daf7c84c5f6df7ad3cede41ef3bd", "filename": "src/test/compile-fail/borrowck-uniq-via-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-ref.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -1,22 +1,22 @@\n fn borrow(_v: &int) {}\n \n fn box_mut(v: &mut ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_rec_mut(v: &{mut f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_mut_rec(v: &mut {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_mut_recs(v: &mut {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n     //~^ NOTE impure due to access to impure function\n }\n \n@@ -33,27 +33,27 @@ fn box_imm_recs(v: &{f: {g: {h: ~int}}}) {\n }\n \n fn box_const(v: &const ~int) {\n-    borrow(*v); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(*v); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_rec_const(v: &{const f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_recs_const(v: &{f: {g: {const h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_const_rec(v: &const {f: ~int}) {\n-    borrow(v.f); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n \n fn box_const_recs(v: &const {f: {g: {h: ~int}}}) {\n-    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    borrow(v.f.g.h); //~ ERROR illegal borrow unless pure: creating immutable alias to aliasable, const memory\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "415e66fbda2f2fc0b8ba3ab9945d60466fff25ae", "filename": "src/test/compile-fail/regions-escape-via-iface-or-not.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -0,0 +1,24 @@\n+iface deref {\n+    fn get() -> int;\n+}\n+\n+impl of deref for &int {\n+    fn get() -> int {\n+        *self\n+    }\n+}\n+\n+fn with<R: deref>(f: fn(x: &int) -> R) -> int {\n+    f(&3).get()\n+}\n+\n+fn return_it() -> int {\n+    with(|o| o)\n+    //~^ ERROR reference is not valid outside of its lifetime, &\n+    //~^^ ERROR reference is not valid outside of its lifetime, &\n+}\n+\n+fn main() {\n+    let x = return_it();\n+    #debug[\"foo=%d\", x];\n+}"}, {"sha": "86210b25a101631a7a7141f2783a9e392633a857", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -0,0 +1,17 @@\n+// Similar to regions-ret-borrowed.rs, but using a named lifetime.  At\n+// some point regions-ret-borrowed reported an error but this file did\n+// not, due to special hardcoding around the anonymous region.\n+\n+fn with<R>(f: fn(x: &a/int) -> R) -> R {\n+    f(&3)\n+}\n+\n+fn return_it() -> &a/int {\n+    with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR reference is not valid outside of its lifetime\n+}\n+\n+fn main() {\n+    let x = return_it();\n+    #debug[\"foo=%d\", *x];\n+}"}, {"sha": "3bd3deefcf5f2936568c87a14fcd57cba015cd65", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -0,0 +1,20 @@\n+// Ensure that you cannot use generic types to return a region outside\n+// of its bound.  Here, in the `return_it()` fn, we call with() but\n+// with R bound to &int from the return_it.  Meanwhile, with()\n+// provides a value that is only good within its own stack frame. This\n+// used to successfully compile because we failed to account for the\n+// fact that fn(x: &int) rebound the region &.\n+\n+fn with<R>(f: fn(x: &int) -> R) -> R {\n+    f(&3)\n+}\n+\n+fn return_it() -> &int {\n+    with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR reference is not valid outside of its lifetime\n+}\n+\n+fn main() {\n+    let x = return_it();\n+    #debug[\"foo=%d\", *x];\n+}"}, {"sha": "c01a9feab7dd342ba978955c2bff038f3f377e0f", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99674dc52b45a22b49f13242be9d931009b4f276/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=99674dc52b45a22b49f13242be9d931009b4f276", "patch": "@@ -0,0 +1,26 @@\n+type ints = {sum: ~int, values: ~[int]};\n+\n+fn add_int(x: &mut ints, v: int) {\n+    *x.sum += v;\n+    let mut values = ~[];\n+    x.values <-> values;\n+    vec::push(values, v);\n+    x.values <- values;\n+}\n+\n+fn iter_ints(x: &ints, f: fn(x: &int) -> bool) {\n+    let l = x.values.len();\n+    uint::range(0, l, |i| f(&x.values[i]))\n+}\n+\n+fn main() {\n+    let mut ints = ~{sum: ~0, values: ~[]};\n+    add_int(ints, 22);\n+    add_int(ints, 44);\n+\n+    for iter_ints(ints) |i| {\n+        #error[\"int = %d\", *i];\n+    }\n+\n+    #error[\"ints=%?\", ints];\n+}"}]}