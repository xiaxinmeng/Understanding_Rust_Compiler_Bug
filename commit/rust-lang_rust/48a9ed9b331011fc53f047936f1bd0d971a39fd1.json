{"sha": "48a9ed9b331011fc53f047936f1bd0d971a39fd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YTllZDliMzMxMDExZmM1M2YwNDc5MzZmMWJkMGQ5NzFhMzlmZDE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-07T08:02:34Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-07T08:02:34Z"}, "message": "Merge pull request #122 from Manishearth/strings\n\nNew string_add_assign lint", "tree": {"sha": "b1ae26d58719b7c080c8dfa483b9edd5f602a818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ae26d58719b7c080c8dfa483b9edd5f602a818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a9ed9b331011fc53f047936f1bd0d971a39fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a9ed9b331011fc53f047936f1bd0d971a39fd1", "html_url": "https://github.com/rust-lang/rust/commit/48a9ed9b331011fc53f047936f1bd0d971a39fd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a9ed9b331011fc53f047936f1bd0d971a39fd1/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ebb9b1551de419369e0272623ca5763d54ccc81", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ebb9b1551de419369e0272623ca5763d54ccc81", "html_url": "https://github.com/rust-lang/rust/commit/6ebb9b1551de419369e0272623ca5763d54ccc81"}, {"sha": "27f8fa75e19a5f821776aa06e40c03652ff28d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/27f8fa75e19a5f821776aa06e40c03652ff28d86", "html_url": "https://github.com/rust-lang/rust/commit/27f8fa75e19a5f821776aa06e40c03652ff28d86"}], "stats": {"total": 350, "additions": 210, "deletions": 140}, "files": [{"sha": "fcd8d38a3b3913033403c93a74166584796080b0", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -29,6 +29,7 @@ Lints included in this crate:\n  - `inline_always`: Warns on `#[inline(always)]`, because in most cases it is a bad idea\n  - `collapsible_if`: Warns on cases where two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n  - `zero_width_space`: Warns on encountering a unicode zero-width space\n+ - `string_add_assign`: Warns on `x = x + ..` where `x` is a `String` and suggests using `push_str(..)` instead.\n \n To use, add the following lines to your Cargo.toml:\n "}, {"sha": "1000d310e39480ff046daf6236d03e13becfac10", "filename": "src/eq_op.rs", "status": "modified", "additions": 138, "deletions": 139, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -23,238 +23,237 @@ impl LintPass for EqOp {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_cmp_or_bit(op) && is_exp_equal(left, right) {\n                 span_lint(cx, EQ_OP, e.span, &format!(\n-\t\t\t\t\t\"equal expressions as operands to {}\", \n-\t\t\t\t\t\tast_util::binop_to_string(op.node)));\n+                    \"equal expressions as operands to {}\", \n+                        ast_util::binop_to_string(op.node)));\n             }\n         }\n     }\n }\n \n-fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n-\tmatch (&left.node, &right.node) {\n-\t\t(&ExprBinary(ref lop, ref ll, ref lr), \n-\t\t\t\t&ExprBinary(ref rop, ref rl, ref rr)) => \n-\t\t\tlop.node == rop.node && \n-\t\t\tis_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n-\t\t(&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) => \n-\t\t\tboth(lpl, rpl, |l, r| is_exp_equal(l, r)) && \n-\t\t\t\tis_exp_equal(lbox, rbox),\n-\t\t(&ExprCall(ref lcallee, ref largs), \n-\t\t &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee, \n-\t\t\trcallee) && is_exps_equal(largs, rargs),\n-\t\t(&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) => \n-\t\t\tis_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n-\t\t(&ExprField(ref lfexp, ref lfident), \n-\t\t\t\t&ExprField(ref rfexp, ref rfident)) => \n-\t\t\tlfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n-\t\t(&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-\t\t(&ExprMethodCall(ref lident, ref lcty, ref lmargs), \n-\t\t\t\t&ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n-\t\t\tlident.node == rident.node && is_tys_equal(lcty, rcty) && \n-\t\t\t\tis_exps_equal(lmargs, rmargs),\n-\t\t(&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n-\t\t(_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n-\t\t(&ExprPath(ref lqself, ref lsubpath), \n-\t\t\t\t&ExprPath(ref rqself, ref rsubpath)) => \n-\t\t\tboth(lqself, rqself, |l, r| is_qself_equal(l, r)) && \n-\t\t\t\tis_path_equal(lsubpath, rsubpath),\t\t\n-\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => \n-\t\t\tis_exps_equal(ltup, rtup),\n-\t\t(&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) => \n-\t\t\tlunop == runop && is_exp_equal(l, r), \n-\t\t(&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n-\t\t_ => false\n-\t}\n+pub fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n+    match (&left.node, &right.node) {\n+        (&ExprBinary(ref lop, ref ll, ref lr), \n+                &ExprBinary(ref rop, ref rl, ref rr)) => \n+            lop.node == rop.node && \n+            is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n+        (&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) => \n+            both(lpl, rpl, |l, r| is_exp_equal(l, r)) && \n+                is_exp_equal(lbox, rbox),\n+        (&ExprCall(ref lcallee, ref largs), \n+         &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee, \n+            rcallee) && is_exps_equal(largs, rargs),\n+        (&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) => \n+            is_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n+        (&ExprField(ref lfexp, ref lfident), \n+                &ExprField(ref rfexp, ref rfident)) => \n+            lfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n+        (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+        (&ExprMethodCall(ref lident, ref lcty, ref lmargs), \n+                &ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n+            lident.node == rident.node && is_tys_equal(lcty, rcty) && \n+                is_exps_equal(lmargs, rmargs),\n+        (&ExprParen(ref lparen), _) => is_exp_equal(lparen, right),\n+        (_, &ExprParen(ref rparen)) => is_exp_equal(left, rparen),\n+        (&ExprPath(ref lqself, ref lsubpath), \n+                &ExprPath(ref rqself, ref rsubpath)) => \n+            both(lqself, rqself, |l, r| is_qself_equal(l, r)) && \n+                is_path_equal(lsubpath, rsubpath),      \n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => \n+            is_exps_equal(ltup, rtup),\n+        (&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) => \n+            lunop == runop && is_exp_equal(l, r), \n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n+        _ => false\n+    }\n }\n \n fn is_exps_equal(left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n-\tover(left, right, |l, r| is_exp_equal(l, r))\n+    over(left, right, |l, r| is_exp_equal(l, r))\n }\n \n fn is_path_equal(left : &Path, right : &Path) -> bool {\n     // The == of idents doesn't work with different contexts,\n-    // we have to be explicit about hygeine\n-\tleft.global == right.global\n-    && left.segments.iter().zip(right.segments.iter())\n-           .all( |(l,r)| l.identifier.name == r.identifier.name\n-                         && l.identifier.ctxt == r.identifier.ctxt\n-                         && l.parameters == r.parameters)\n+    // we have to be explicit about hygiene\n+    left.global == right.global && over(&left.segments, &right.segments, \n+        |l, r| l.identifier.name == r.identifier.name\n+              && l.identifier.ctxt == r.identifier.ctxt\n+               && l.parameters == r.parameters)\n }\n \n fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n-\tleft.ty.node == right.ty.node && left.position == right.position\n+    left.ty.node == right.ty.node && left.position == right.position\n }\n \n fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n-\tmatch (&left.node, &right.node) {\n-\t(&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n-\t(&TyFixedLengthVec(ref lfvty, ref lfvexp), \n-\t\t\t&TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n-\t\tis_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n-\t(&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n-\t(&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n-\t\tboth(ltime, rtime, is_lifetime_equal) && \n-\t\tis_mut_ty_equal(lrmut, rrmut),\n-\t(&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => \n-\t\tis_bare_fn_ty_equal(lbare, rbare),\n+    match (&left.node, &right.node) {\n+    (&TyVec(ref lvec), &TyVec(ref rvec)) => is_ty_equal(lvec, rvec),\n+    (&TyFixedLengthVec(ref lfvty, ref lfvexp), \n+            &TyFixedLengthVec(ref rfvty, ref rfvexp)) => \n+        is_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n+    (&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n+    (&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n+        both(ltime, rtime, is_lifetime_equal) && \n+        is_mut_ty_equal(lrmut, rrmut),\n+    (&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => \n+        is_bare_fn_ty_equal(lbare, rbare),\n     (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n-\t(&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => \n-\t\tboth(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n+    (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => \n+        both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n     (&TyObjectSum(ref lsumty, ref lobounds), \n-\t\t\t&TyObjectSum(ref rsumty, ref robounds)) => \n-\t\tis_ty_equal(lsumty, rsumty) && \n-\t\tis_param_bounds_equal(lobounds, robounds),\n-\t(&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => \n-\t\tis_param_bounds_equal(ltbounds, rtbounds),\n+            &TyObjectSum(ref rsumty, ref robounds)) => \n+        is_ty_equal(lsumty, rsumty) && \n+        is_param_bounds_equal(lobounds, robounds),\n+    (&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => \n+        is_param_bounds_equal(ltbounds, rtbounds),\n     (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n     (&TyTypeof(ref lof), &TyTypeof(ref rof)) => is_exp_equal(lof, rof),\n-\t(&TyInfer, &TyInfer) => true,\n-\t_ => false\n-\t}\n+    (&TyInfer, &TyInfer) => true,\n+    _ => false\n+    }\n }\n \n fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) \n-\t\t-> bool {\n-\tmatch(left, right) {\n-\t(&TraitTyParamBound(ref lpoly, ref lmod), \n-\t\t\t&TraitTyParamBound(ref rpoly, ref rmod)) => \n-\t\tlmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n+        -> bool {\n+    match(left, right) {\n+    (&TraitTyParamBound(ref lpoly, ref lmod), \n+            &TraitTyParamBound(ref rpoly, ref rmod)) => \n+        lmod == rmod && is_poly_traitref_equal(lpoly, rpoly),\n     (&RegionTyParamBound(ref ltime), &RegionTyParamBound(ref rtime)) => \n-\t\tis_lifetime_equal(ltime, rtime),\n+        is_lifetime_equal(ltime, rtime),\n     _ => false\n-\t}\n+    }\n }\n \n fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef)\n-\t\t-> bool {\n-\tis_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes)\n-\t\t&& is_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n+        -> bool {\n+    is_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes)\n+        && is_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n }\n \n fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds)\n-\t\t-> bool {\n-\tover(left, right, is_param_bound_equal)\n+        -> bool {\n+    over(left, right, is_param_bound_equal)\n }\n \n fn is_mut_ty_equal(left : &MutTy, right : &MutTy) -> bool {\n-\tleft.mutbl == right.mutbl && is_ty_equal(&left.ty, &right.ty)\n+    left.mutbl == right.mutbl && is_ty_equal(&left.ty, &right.ty)\n }\n \n fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n-\tleft.unsafety == right.unsafety && left.abi == right.abi && \n-\t\tis_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) && \n-\t\t\tis_fndecl_equal(&left.decl, &right.decl)\n+    left.unsafety == right.unsafety && left.abi == right.abi && \n+        is_lifetimedefs_equal(&left.lifetimes, &right.lifetimes) && \n+            is_fndecl_equal(&left.decl, &right.decl)\n } \n \n fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n-\tleft.variadic == right.variadic && \n-\t\tis_args_equal(&left.inputs, &right.inputs) && \n-\t\tis_fnret_ty_equal(&left.output, &right.output)\n+    left.variadic == right.variadic && \n+        is_args_equal(&left.inputs, &right.inputs) && \n+        is_fnret_ty_equal(&left.output, &right.output)\n }\n \n fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy) \n-\t\t-> bool {\n-\tmatch (left, right) {\n-\t(&NoReturn(_), &NoReturn(_)) | \n-\t(&DefaultReturn(_), &DefaultReturn(_)) => true,\n-\t(&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n-\t_ => false\t\n-\t}\n+        -> bool {\n+    match (left, right) {\n+    (&NoReturn(_), &NoReturn(_)) | \n+    (&DefaultReturn(_), &DefaultReturn(_)) => true,\n+    (&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n+    _ => false  \n+    }\n }\n \n fn is_arg_equal(l: &Arg, r : &Arg) -> bool {\n-\tis_ty_equal(&l.ty, &r.ty) && is_pat_equal(&l.pat, &r.pat)\n+    is_ty_equal(&l.ty, &r.ty) && is_pat_equal(&l.pat, &r.pat)\n }\n \n fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n-\tover(left, right, is_arg_equal)\n+    over(left, right, is_arg_equal)\n }\n \n fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n-\tmatch(&left.node, &right.node) {\n-\t(&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n-\t(&PatIdent(ref lmode, ref lident, Option::None), \n-\t\t\t&PatIdent(ref rmode, ref rident, Option::None)) =>\n-\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node),\n-\t(&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)), \n-\t\t\t&PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n-\t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node) && \n-\t\t\tis_pat_equal(lpat, rpat),\n+    match(&left.node, &right.node) {\n+    (&PatWild(lwild), &PatWild(rwild)) => lwild == rwild,\n+    (&PatIdent(ref lmode, ref lident, Option::None), \n+            &PatIdent(ref rmode, ref rident, Option::None)) =>\n+        lmode == rmode && is_ident_equal(&lident.node, &rident.node),\n+    (&PatIdent(ref lmode, ref lident, Option::Some(ref lpat)), \n+            &PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n+        lmode == rmode && is_ident_equal(&lident.node, &rident.node) && \n+            is_pat_equal(lpat, rpat),\n     (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) => \n-\t\tis_path_equal(lpath, rpath) && both(lenum, renum, |l, r| \n-\t\t\tis_pats_equal(l, r)),\n+        is_path_equal(lpath, rpath) && both(lenum, renum, |l, r| \n+            is_pats_equal(l, r)),\n     (&PatStruct(ref lpath, ref lfieldpat, lbool), \n-\t\t\t&PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n-\t\tlbool == rbool && is_path_equal(lpath, rpath) && \n-\t\t\tis_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n+            &PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n+        lbool == rbool && is_path_equal(lpath, rpath) && \n+            is_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n     (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup), \n     (&PatBox(ref lboxed), &PatBox(ref rboxed)) => \n-\t\tis_pat_equal(lboxed, rboxed),\n+        is_pat_equal(lboxed, rboxed),\n     (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => \n-\t\tis_pat_equal(lpat, rpat) && lmut == rmut,\n-\t(&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n+        is_pat_equal(lpat, rpat) && lmut == rmut,\n+    (&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n     (&PatRange(ref lfrom, ref lto), &PatRange(ref rfrom, ref rto)) =>\n-\t\tis_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n+        is_exp_equal(lfrom, rfrom) && is_exp_equal(lto, rto),\n     (&PatVec(ref lfirst, Option::None, ref llast), \n-\t\t\t&PatVec(ref rfirst, Option::None, ref rlast)) =>\n-\t\tis_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n+            &PatVec(ref rfirst, Option::None, ref rlast)) =>\n+        is_pats_equal(lfirst, rfirst) && is_pats_equal(llast, rlast),\n     (&PatVec(ref lfirst, Option::Some(ref lpat), ref llast), \n-\t\t\t&PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n-\t\tis_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && \n-\t\t\tis_pats_equal(llast, rlast),\n-\t// I don't match macros for now, the code is slow enough as is ;-)\n-\t_ => false\n-\t}\n+            &PatVec(ref rfirst, Option::Some(ref rpat), ref rlast)) =>\n+        is_pats_equal(lfirst, rfirst) && is_pat_equal(lpat, rpat) && \n+            is_pats_equal(llast, rlast),\n+    // I don't match macros for now, the code is slow enough as is ;-)\n+    _ => false\n+    }\n }\n \n fn is_spanned_fieldpats_equal(left : &[code::Spanned<FieldPat>], \n-\t\tright : &[code::Spanned<FieldPat>]) -> bool {\n-\tover(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n+        right : &[code::Spanned<FieldPat>]) -> bool {\n+    over(left, right, |l, r| is_fieldpat_equal(&l.node, &r.node))\n }\n \n fn is_fieldpat_equal(left : &FieldPat, right : &FieldPat) -> bool {\n-\tleft.is_shorthand == right.is_shorthand && \n-\t\tis_ident_equal(&left.ident, &right.ident) && \n-\t\tis_pat_equal(&left.pat, &right.pat) \n+    left.is_shorthand == right.is_shorthand && \n+        is_ident_equal(&left.ident, &right.ident) && \n+        is_pat_equal(&left.pat, &right.pat) \n }\n \n fn is_ident_equal(left : &Ident, right : &Ident) -> bool {\n-\t&left.name == &right.name && left.ctxt == right.ctxt\n+    &left.name == &right.name && left.ctxt == right.ctxt\n }\n \n fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n-\tover(left, right, |l, r| is_pat_equal(l, r))\n+    over(left, right, |l, r| is_pat_equal(l, r))\n }\n \n fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n-\t\t-> bool {\n-\tis_lifetime_equal(&left.lifetime, &right.lifetime) && \n-\t\tover(&left.bounds, &right.bounds, is_lifetime_equal)\n+        -> bool {\n+    is_lifetime_equal(&left.lifetime, &right.lifetime) && \n+        over(&left.bounds, &right.bounds, is_lifetime_equal)\n }\n \n fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef]) \n-\t\t-> bool {\n-\tover(left, right, is_lifetimedef_equal)\n+        -> bool {\n+    over(left, right, is_lifetimedef_equal)\n }\n \n fn is_lifetime_equal(left : &Lifetime, right : &Lifetime) -> bool {\n-\tleft.name == right.name\n+    left.name == right.name\n }\n \n fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n-\tover(left, right, |l, r| is_ty_equal(l, r))\n+    over(left, right, |l, r| is_ty_equal(l, r))\n }\n \n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool \n-\t\twhere F: FnMut(&X, &X) -> bool {\n+        where F: FnMut(&X, &X) -> bool {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| \n-\t\teq_fn(x, y))\n+        eq_fn(x, y))\n }\n \n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool \n-\t\twhere F: FnMut(&X, &X) -> bool {\n-\tl.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n-\t\t|y| eq_fn(x, y)))\n+        where F: FnMut(&X, &X) -> bool {\n+    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n+        |y| eq_fn(x, y)))\n }\n \n fn is_cmp_or_bit(op : &BinOp) -> bool {"}, {"sha": "d0d0b6374689afb84776c0458f35279b4903cc8a", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -28,6 +28,7 @@ pub mod attrs;\n pub mod collapsible_if;\n pub mod unicode;\n pub mod utils;\n+pub mod strings;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -51,6 +52,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box attrs::AttrPass as LintPassObject);\n     reg.register_lint_pass(box collapsible_if::CollapsibleIf as LintPassObject);\n     reg.register_lint_pass(box unicode::Unicode as LintPassObject);\n+    reg.register_lint_pass(box strings::StringAdd as LintPassObject);\n     \n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH, misc::STR_TO_STRING,\n@@ -70,5 +72,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n                                            attrs::INLINE_ALWAYS,\n                                            collapsible_if::COLLAPSIBLE_IF,\n                                            unicode::ZERO_WIDTH_SPACE,\n+                                           strings::STRING_ADD_ASSIGN,\n                                            ]);\n }"}, {"sha": "75133ec125457050ec4b3080b7b983028216e135", "filename": "src/strings.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -0,0 +1,55 @@\n+//! This LintPass catches both string addition and string addition + assignment\n+//! \n+//! Note that since we have two lints where one subsumes the other, we try to\n+//! disable the subsumed lint unless it has a higher level\n+\n+use rustc::lint::*;\n+use rustc::middle::ty::TypeVariants::TyStruct;\n+use syntax::ast::*;\n+use syntax::codemap::{Span, Spanned};\n+use eq_op::is_exp_equal;\n+use misc::walk_ty;\n+use types::match_ty_unwrap;\n+use utils::{match_def_path, span_lint};\n+\n+declare_lint! {\n+    pub STRING_ADD_ASSIGN,\n+    Warn,\n+    \"Warn on `x = x + ..` where x is a `String`\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct StringAdd;\n+\n+impl LintPass for StringAdd {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(STRING_ADD_ASSIGN)\n+    }\n+    \n+    fn check_expr(&mut self, cx: &Context, e: &Expr) {\n+        if let &ExprAssign(ref target, ref  src) = &e.node {\n+            if is_string(cx, target) && is_add(src, target) { \n+                span_lint(cx, STRING_ADD_ASSIGN, e.span, \n+                    \"You assign the result of adding something to this string. \\\n+                    Consider using `String::push_str(..) instead.\")\n+            }\n+        }\n+    }\n+}\n+\n+fn is_string(cx: &Context, e: &Expr) -> bool {\n+    if let TyStruct(def_id, _) = walk_ty(cx.tcx.expr_ty(e)).sty {\n+        match_def_path(cx, def_id, &[\"std\", \"string\", \"String\"])\n+    } else { false }\n+}\n+\n+fn is_add(src: &Expr, target: &Expr) -> bool {\n+    match &src.node {\n+        &ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) =>\n+            is_exp_equal(target, left),\n+        &ExprBlock(ref block) => block.stmts.is_empty() && \n+            block.expr.as_ref().map_or(false, |expr| is_add(&*expr, target)),\n+        &ExprParen(ref expr) => is_add(&*expr, target),\n+        _ => false\n+    }\n+}"}, {"sha": "4a87f4b3a2ef6d549c82a36f10bab47eff43b464", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -41,7 +41,7 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n \tpath.segments.iter().rev().zip(segments.iter().rev()).all(\n-\t\t|(a,b)| a.identifier.name == b)\n+\t\t|(a,b)| &a.identifier.name.as_str() == b)\n }\n \n /// convert a span to a code snippet if available, otherwise use default, e.g."}, {"sha": "2b200f1d07e0625efb06fa5b091dbd5f39affbc6", "filename": "tests/compile-fail/strings.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48a9ed9b331011fc53f047936f1bd0d971a39fd1/tests%2Fcompile-fail%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a9ed9b331011fc53f047936f1bd0d971a39fd1/tests%2Fcompile-fail%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstrings.rs?ref=48a9ed9b331011fc53f047936f1bd0d971a39fd1", "patch": "@@ -0,0 +1,12 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(string_add_assign)]\n+\n+fn main() {\n+\tlet x = \"\".to_owned();\n+\t\n+\tfor i in (1..3) {\n+\t\tx = x + \".\"; //~ERROR\n+\t}\n+}"}]}