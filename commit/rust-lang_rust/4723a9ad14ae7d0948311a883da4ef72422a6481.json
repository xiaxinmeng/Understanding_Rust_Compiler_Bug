{"sha": "4723a9ad14ae7d0948311a883da4ef72422a6481", "node_id": "C_kwDOAAsO6NoAKDQ3MjNhOWFkMTRhZTdkMDk0ODMxMWE4ODNkYTRlZjcyNDIyYTY0ODE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-25T19:53:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-25T19:53:11Z"}, "message": "Rollup merge of #108333 - compiler-errors:new-solver-object-sound, r=lcnr\n\nMake object bound candidates sound in the new trait solver\n\nr? `@lcnr`", "tree": {"sha": "9cf4950d4b93bf614de76a7ae85c8eb6cdd6563b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cf4950d4b93bf614de76a7ae85c8eb6cdd6563b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4723a9ad14ae7d0948311a883da4ef72422a6481", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj+mcnCRBK7hj4Ov3rIwAAwgsIALDLStiu3B9H4fGSBsj59g/A\nrxU/E0G3bDdC4awsT+o9Bdy2dseGbIwKUAxWazM3Zu8LR38Jxy1ZdrwrxGD0jxZ4\nLllsBGo7u0IF7OyHg0WhS+CqIYqfQPKu9Aqc196B344H89OmdoGmREcz2gqdJyIV\nSTYM5ZWxAThR4vrmq31tIoGvwzDPcnP+tMsZ6u+QXANM5IlJA2vZc0MKr7Irf07D\nVp4LhA+BIovI9QnLbC00gZYZU9yiCcGUh7rsl1t3+VMql/Kjtu833yZIMMqU4jHj\nrQFJy057PcDaTsFRaiwaVCyorz7WobioQEbo5l6+r5JaSIxsKQDM/f8+bAzh+7Q=\n=qkBv\n-----END PGP SIGNATURE-----\n", "payload": "tree 9cf4950d4b93bf614de76a7ae85c8eb6cdd6563b\nparent 0b6b373f4885757d908ffbc524ad5aa73fc983bc\nparent ed30efff3b2d9e4636d3b1b9e9dc275362b64a62\nauthor Michael Goulet <michael@errs.io> 1677354791 -0800\ncommitter GitHub <noreply@github.com> 1677354791 -0800\n\nRollup merge of #108333 - compiler-errors:new-solver-object-sound, r=lcnr\n\nMake object bound candidates sound in the new trait solver\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4723a9ad14ae7d0948311a883da4ef72422a6481", "html_url": "https://github.com/rust-lang/rust/commit/4723a9ad14ae7d0948311a883da4ef72422a6481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4723a9ad14ae7d0948311a883da4ef72422a6481/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b6b373f4885757d908ffbc524ad5aa73fc983bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6b373f4885757d908ffbc524ad5aa73fc983bc", "html_url": "https://github.com/rust-lang/rust/commit/0b6b373f4885757d908ffbc524ad5aa73fc983bc"}, {"sha": "ed30efff3b2d9e4636d3b1b9e9dc275362b64a62", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed30efff3b2d9e4636d3b1b9e9dc275362b64a62", "html_url": "https://github.com/rust-lang/rust/commit/ed30efff3b2d9e4636d3b1b9e9dc275362b64a62"}], "stats": {"total": 312, "additions": 309, "deletions": 3}, "files": [{"sha": "dec9f8016b0c18845d2ae581c0eada8915de7e50", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -99,6 +99,15 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n+    // Consider a clause specifically for a `dyn Trait` self type. This requires\n+    // additionally checking all of the supertraits and object bounds to hold,\n+    // since they're not implied by the well-formedness of the object type.\n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -455,7 +464,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n+            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "88fd8bb8bd095ca111b723f20c25d2270a243371", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -128,6 +128,51 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.probe(|ecx| {\n+                let assumption_projection_pred =\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        ecx,\n+                        goal.param_env,\n+                        goal.predicate.projection_ty.trait_ref(tcx),\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,"}, {"sha": "5c499c36e9bf4686b239734410b73c21f2339fbc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -86,6 +86,46 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n+            // FIXME: Constness and polarity\n+            ecx.probe(|ecx| {\n+                let assumption_trait_pred =\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        ecx,\n+                        goal.param_env,\n+                        goal.predicate.trait_ref,\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_auto_trait_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "f7d1b4be74bf833ec7256705aba67e090b5a0396", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 112, "deletions": 2, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -1,6 +1,7 @@\n-use rustc_hir::{Movability, Mutability};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{def_id::DefId, Movability, Mutability};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable};\n \n use crate::solve::EvalCtxt;\n \n@@ -231,3 +232,112 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         }\n     }\n }\n+\n+/// Assemble a list of predicates that would be present on a theoretical\n+/// user impl for an object type. These predicates must be checked any time\n+/// we assemble a built-in object candidate for an object type, since they\n+/// are not implied by the well-formedness of the type.\n+///\n+/// For example, given the following traits:\n+///\n+/// ```rust,ignore (theoretical code)\n+/// trait Foo: Baz {\n+///     type Bar: Copy;\n+/// }\n+///\n+/// trait Baz {}\n+/// ```\n+///\n+/// For the dyn type `dyn Foo<Item = Ty>`, we can imagine there being a\n+/// pair of theoretical impls:\n+///\n+/// ```rust,ignore (theoretical code)\n+/// impl Foo for dyn Foo<Item = Ty>\n+/// where\n+///     Self: Baz,\n+///     <Self as Foo>::Bar: Copy,\n+/// {\n+///     type Bar = Ty;\n+/// }\n+///\n+/// impl Baz for dyn Foo<Item = Ty> {}\n+/// ```\n+///\n+/// However, in order to make such impls well-formed, we need to do an\n+/// additional step of eagerly folding the associated types in the where\n+/// clauses of the impl. In this example, that means replacing\n+/// `<Self as Foo>::Bar` with `Ty` in the first impl.\n+pub(crate) fn predicates_for_object_candidate<'tcx>(\n+    ecx: &EvalCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    object_bound: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n+) -> Vec<ty::Predicate<'tcx>> {\n+    let tcx = ecx.tcx();\n+    let mut requirements = vec![];\n+    requirements.extend(\n+        tcx.super_predicates_of(trait_ref.def_id).instantiate(tcx, trait_ref.substs).predicates,\n+    );\n+    for item in tcx.associated_items(trait_ref.def_id).in_definition_order() {\n+        // FIXME(associated_const_equality): Also add associated consts to\n+        // the requirements here.\n+        if item.kind == ty::AssocKind::Type {\n+            requirements.extend(tcx.item_bounds(item.def_id).subst(tcx, trait_ref.substs));\n+        }\n+    }\n+\n+    let mut replace_projection_with = FxHashMap::default();\n+    for bound in object_bound {\n+        if let ty::ExistentialPredicate::Projection(proj) = bound.skip_binder() {\n+            let proj = proj.with_self_ty(tcx, trait_ref.self_ty());\n+            let old_ty = replace_projection_with.insert(proj.def_id(), bound.rebind(proj));\n+            assert_eq!(\n+                old_ty,\n+                None,\n+                \"{} has two substitutions: {} and {}\",\n+                proj.projection_ty,\n+                proj.term,\n+                old_ty.unwrap()\n+            );\n+        }\n+    }\n+\n+    requirements.fold_with(&mut ReplaceProjectionWith {\n+        ecx,\n+        param_env,\n+        mapping: replace_projection_with,\n+    })\n+}\n+\n+struct ReplaceProjectionWith<'a, 'tcx> {\n+    ecx: &'a EvalCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    mapping: FxHashMap<DefId, ty::PolyProjectionPredicate<'tcx>>,\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.ecx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n+            && let Some(replacement) = self.mapping.get(&alias_ty.def_id)\n+        {\n+            // We may have a case where our object type's projection bound is higher-ranked,\n+            // but the where clauses we instantiated are not. We can solve this by instantiating\n+            // the binder at the usage site.\n+            let proj = self.ecx.instantiate_binder_with_infer(*replacement);\n+            // FIXME: Technically this folder could be fallible?\n+            let nested = self\n+                .ecx\n+                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .expect(\"expected to be able to unify goal projection with dyn's projection\");\n+            // FIXME: Technically we could register these too..\n+            assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");\n+            proj.term.ty().unwrap()\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+}"}, {"sha": "c886aeeda3e4690e6f246c4698b41d46a3dd364c", "filename": "tests/ui/traits/new-solver/higher-ranked-dyn-bounds.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Trait<'a> {\n+    type Item: for<'b> Trait2<'b>;\n+}\n+\n+trait Trait2<'a> {}\n+impl Trait2<'_> for () {}\n+\n+fn needs_trait(_: Box<impl for<'a> Trait<'a> + ?Sized>) {}\n+\n+fn foo(x: Box<dyn for<'a> Trait<'a, Item = ()>>) {\n+    needs_trait(x);\n+}\n+\n+fn main() {}"}, {"sha": "712759ef0e612097d623ba6f0b6fbd79a3357495", "filename": "tests/ui/traits/new-solver/more-object-bound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+// From #80800\n+\n+trait SuperTrait {\n+    type A;\n+    type B;\n+}\n+\n+trait Trait: SuperTrait<A = <Self as SuperTrait>::B> {}\n+\n+fn transmute<A, B>(x: A) -> B {\n+    foo::<A, B, dyn Trait<A = A, B = B>>(x)\n+    //~^ ERROR type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+}\n+\n+fn foo<A, B, T: ?Sized>(x: T::A) -> B\n+where\n+    T: Trait<B = B>,\n+{\n+    x\n+}\n+\n+static X: u8 = 0;\n+fn main() {\n+    let x = transmute::<&u8, &[u8; 1_000_000]>(&X);\n+    println!(\"{:?}\", x[100_000]);\n+}"}, {"sha": "208fdecb08fc9f6856f075e615429466577c59ac", "filename": "tests/ui/traits/new-solver/more-object-bound.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -0,0 +1,19 @@\n+error[E0283]: type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+  --> $DIR/more-object-bound.rs:12:5\n+   |\n+LL |     foo::<A, B, dyn Trait<A = A, B = B>>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+note: required by a bound in `foo`\n+  --> $DIR/more-object-bound.rs:18:8\n+   |\n+LL | fn foo<A, B, T: ?Sized>(x: T::A) -> B\n+   |    --- required by a bound in this function\n+LL | where\n+LL |     T: Trait<B = B>,\n+   |        ^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "7bdd863a762c4069d3f1fdcb5a1e7f8c5c519981", "filename": "tests/ui/traits/new-solver/object-unsafety.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Setup {\n+    type From: Copy;\n+}\n+\n+fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+    *from\n+}\n+\n+pub fn copy_any<T>(t: &T) -> T {\n+    copy::<dyn Setup<From=T>>(t)\n+    //~^ ERROR the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+}\n+\n+fn main() {\n+    let x = String::from(\"Hello, world\");\n+    let y = copy_any(&x);\n+    println!(\"{y}\");\n+}"}, {"sha": "198ac623df8a6836339851d26131f2bc5b3cd380", "filename": "tests/ui/traits/new-solver/object-unsafety.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4723a9ad14ae7d0948311a883da4ef72422a6481/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr?ref=4723a9ad14ae7d0948311a883da4ef72422a6481", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+  --> $DIR/object-unsafety.rs:12:12\n+   |\n+LL |     copy::<dyn Setup<From=T>>(t)\n+   |            ^^^^^^^^^^^^^^^^^ the trait `Setup` is not implemented for `dyn Setup<From = T>`\n+   |\n+note: required by a bound in `copy`\n+  --> $DIR/object-unsafety.rs:7:12\n+   |\n+LL | fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+   |            ^^^^^ required by this bound in `copy`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub fn copy_any<T>(t: &T) -> T where dyn Setup<From = T>: Setup {\n+   |                                ++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}