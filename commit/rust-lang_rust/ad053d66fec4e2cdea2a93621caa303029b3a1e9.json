{"sha": "ad053d66fec4e2cdea2a93621caa303029b3a1e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMDUzZDY2ZmVjNGUyY2RlYTJhOTM2MjFjYWEzMDMwMjliM2ExZTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-06T15:55:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-07T10:48:29Z"}, "message": "change the block and stmt position after a function call returns\n\npreviously we moved to the target block *before* calling a function, so when inspecting\nthe stack, it appeared as if we were in the first statement of the next block.", "tree": {"sha": "d0e1bdd16bd6c9191d67ee007a4758be0a9f85d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0e1bdd16bd6c9191d67ee007a4758be0a9f85d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad053d66fec4e2cdea2a93621caa303029b3a1e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXz/CGAAoJEFbW7qD8Z6xGoiUQAKtXh+pJ6orp6KExXRz/S0kU\nggqh2REZaa5QSPOKx8r8IB4w4A31KHV7Tu4t9K8Qnv4gEBmb6Jkzzk1OkmlkPDDT\nAZsJpkUVj10m2Y1vkD5HTKst2AH+/9N7wREZnNCxYp//G5/68UrK8Yjx/VK7ogWp\ni4PoRU/+gOqkhcliZUhsF2oswlxuj0TT3vJ9oDkexRWyxNvopuAYCy0Jft2WEYHS\ngMyXbOVKrTbz5Dffwl+g4v+KJ7kzYOoOVUb2lmRLNLNOoTRtxb7ZoBx1qvLYF5nH\nPL7po6LoQiHVxjZra9ZsL5F/IOqKamakqGxfhFUAAkQ9htifnwNo2VwdXiDXvfda\nx5r92R3TSTE0gNykfO1x3WvmarDzYr415JWtQuB43CVxqK3hYGATZDUNIu6qMCMr\nf6F5A/jexPUD5HD5sP5lbeAcqQzAa6WlB+CuUmOP9CmKkAZG4CVWsO+uCghhnKfc\na405wAJMjWdZz7OnhfNwLu/Gcu8zwpXXrzz/jF05uPCVpwyO8n57CTB8ku46s861\nhXiy/408FfA1ZcrjF19hqBCXOZAIxv241c6BkVfNQoT2PO7ipH85tGaKXUgRf860\nJXHYT9DX97Seta8aTnRFUR8qe5FOr9wSIAkQ0M403pMusm2s3a/XdqwM49g3vaKY\n7Pc3xz262wSTfVv6ELF5\n=5P1+\n-----END PGP SIGNATURE-----", "payload": "tree d0e1bdd16bd6c9191d67ee007a4758be0a9f85d2\nparent be23dcdb8c5d038c4d594e924e4e17f02c0161ce\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467820505 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1473245309 +0200\n\nchange the block and stmt position after a function call returns\n\npreviously we moved to the target block *before* calling a function, so when inspecting\nthe stack, it appeared as if we were in the first statement of the next block.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad053d66fec4e2cdea2a93621caa303029b3a1e9", "html_url": "https://github.com/rust-lang/rust/commit/ad053d66fec4e2cdea2a93621caa303029b3a1e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad053d66fec4e2cdea2a93621caa303029b3a1e9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be23dcdb8c5d038c4d594e924e4e17f02c0161ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/be23dcdb8c5d038c4d594e924e4e17f02c0161ce", "html_url": "https://github.com/rust-lang/rust/commit/be23dcdb8c5d038c4d594e924e4e17f02c0161ce"}], "stats": {"total": 83, "additions": 49, "deletions": 34}, "files": [{"sha": "a8d29f787585704c0c5dc9b1ed2ece242bdab80a", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -71,6 +71,9 @@ pub struct Frame<'a, 'tcx: 'a> {\n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n     pub return_ptr: Option<Pointer>,\n \n+    /// The block to return to when returning from the current stack frame\n+    pub return_to_block: Option<mir::BasicBlock>,\n+\n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n     /// and the temporaries at `self.temp_offset`.\n@@ -305,6 +308,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>,\n+        return_to_block: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n@@ -325,6 +329,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n+            return_to_block: return_to_block,\n             locals: locals?,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n@@ -342,7 +347,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn pop_stack_frame(&mut self) {\n         ::log_settings::settings().indentation -= 1;\n-        let _frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        if let Some(target) = frame.return_to_block {\n+            self.goto_block(target);\n+        }\n         // TODO(solson): Deallocate local variables.\n     }\n \n@@ -961,7 +969,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr))\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), None)\n         .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {"}, {"sha": "3684f525ba632909572dfd3103cc10a84c2c9871", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -87,8 +87,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx, ()> {\n-        // after a terminator we go to a new block\n-        self.frame_mut().stmt = 0;\n         trace!(\"{:?}\", terminator.kind);\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n@@ -125,7 +123,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr))\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), None)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -170,7 +168,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n-                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr))\n+                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr), None)\n                 });\n             }\n         }"}, {"sha": "36e2c05f4f3ee0b92e1b65924ae5d557c0358e84", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -15,6 +15,12 @@ use error::{EvalError, EvalResult};\n use memory::{Pointer, FunctionDefinition};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+\n+    pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n+        self.frame_mut().block = target;\n+        self.frame_mut().stmt = 0;\n+    }\n+\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -23,14 +29,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match terminator.kind {\n             Return => self.pop_stack_frame(),\n \n-            Goto { target } => {\n-                self.frame_mut().block = target;\n-            },\n+            Goto { target } => self.goto_block(target),\n \n             If { ref cond, targets: (then_target, else_target) } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 let cond_val = self.memory.read_bool(cond_ptr)?;\n-                self.frame_mut().block = if cond_val { then_target } else { else_target };\n+                self.goto_block(if cond_val { then_target } else { else_target });\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n@@ -59,7 +63,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n \n-                self.frame_mut().block = target_block;\n+                self.goto_block(target_block);\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n@@ -70,19 +74,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n \n                 match matching {\n-                    Some(i) => {\n-                        self.frame_mut().block = targets[i];\n-                    },\n+                    Some(i) => self.goto_block(targets[i]),\n                     None => return Err(EvalError::InvalidDiscriminant),\n                 }\n             }\n \n             Call { ref func, ref args, ref destination, .. } => {\n-                let mut return_ptr = None;\n-                if let Some((ref lv, target)) = *destination {\n-                    self.frame_mut().block = target;\n-                    return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n-                }\n+                let destination = match *destination {\n+                    Some((ref lv, target)) => Some((self.eval_lvalue(lv)?.to_ptr(), target)),\n+                    None => None,\n+                };\n \n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n@@ -93,11 +94,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if fn_ty != bare_fn_ty {\n                             return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n                         }\n-                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, destination, args,\n                                           terminator.source_info.span)?\n                     },\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n+                        self.eval_fn_call(def_id, substs, fn_ty, destination, args,\n                                           terminator.source_info.span)?\n                     }\n \n@@ -109,13 +110,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.eval_lvalue(location)?.to_ptr();\n                 let ty = self.lvalue_ty(location);\n                 self.drop(ptr, ty)?;\n-                self.frame_mut().block = target;\n+                self.goto_block(target);\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 if expected == self.memory.read_bool(cond_ptr)? {\n-                    self.frame_mut().block = target;\n+                    self.goto_block(target);\n                 } else {\n                     return match *msg {\n                         mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n@@ -143,7 +144,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n-        return_ptr: Option<Pointer>,\n+        destination: Option<(Pointer, mir::BasicBlock)>,\n         args: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n@@ -152,14 +153,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Abi::RustIntrinsic => {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n-                let ret = return_ptr.unwrap();\n-                self.call_intrinsic(def_id, substs, args, ret, layout)\n+                let (ret, target) = destination.unwrap();\n+                self.call_intrinsic(def_id, substs, args, ret, layout)?;\n+                self.goto_block(target);\n+                Ok(())\n             }\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n                 let size = self.type_size(ty);\n-                self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                let (ret, target) = destination.unwrap();\n+                self.call_c_abi(def_id, args, ret, size)?;\n+                self.goto_block(target);\n+                Ok(())\n             }\n \n             Abi::Rust | Abi::RustCall => {\n@@ -203,7 +209,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 let mir = self.load_mir(resolved_def_id);\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr)?;\n+                let (return_ptr, return_to_block) = match destination {\n+                    Some((ptr, block)) => (Some(ptr), Some(block)),\n+                    None => (None, None),\n+                };\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];"}, {"sha": "e9b2536a7005a85823fbee69085184554d41925c", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n     fn f() {}\n \n-    let g = unsafe { //~ ERROR tried to call a function of type\n+    let g = unsafe {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42)\n+    g(42) //~ ERROR tried to call a function of type\n }"}, {"sha": "8d3c9df0320ba24e53a707cb1457ceacf5b8fa55", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -4,7 +4,6 @@ fn main() {\n     let x = box 42;\n     unsafe {\n         let f = std::mem::transmute::<Box<i32>, fn()>(x);\n-        //~^ ERROR: tried to treat a memory pointer as a function pointer\n-        f()\n+        f() //~ ERROR: tried to treat a memory pointer as a function pointer\n     }\n }"}, {"sha": "be56240af4767454c3a5dd1285987d6dffaa7357", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad053d66fec4e2cdea2a93621caa303029b3a1e9/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=ad053d66fec4e2cdea2a93621caa303029b3a1e9", "patch": "@@ -6,6 +6,6 @@ fn bar() {\n     assert_eq!(x, 6);\n }\n \n-fn main() { //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n-    bar();\n+fn main() {\n+    bar(); //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n }"}]}