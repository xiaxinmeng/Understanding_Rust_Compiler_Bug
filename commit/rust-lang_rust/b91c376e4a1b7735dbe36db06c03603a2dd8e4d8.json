{"sha": "b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MWMzNzZlNGExYjc3MzVkYmUzNmRiMDZjMDM2MDNhMmRkOGU0ZDg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-03T11:31:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T11:31:25Z"}, "message": "Rollup merge of #70725 - Centril:nix-unwraps, r=estebank\n\nAvoid `.unwrap()`s on `.span_to_snippet(...)`s\n\nFirst commit fixes https://github.com/rust-lang/rust/issues/70724 and the others fix similar issues found by grepping.\n\nr? @estebank", "tree": {"sha": "86909ffd14dad0005365f5a2df02ad112be33da7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86909ffd14dad0005365f5a2df02ad112be33da7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehx6NCRBK7hj4Ov3rIwAAdHIIAKdZOHWCyMp3xDd8Uw/7NNFR\ndf8tWXOcCqGic/VpDt8TjvHQnD0zlv+dGX0oeZy9bhGIhnk0C8oJ6q0UmM13AFqE\nJDhW9XWBDv5ZnoMfz/7BisDXWZ0rtmKBoe6xK2JJZOJKzcyeQ4QQADR2MppNn21V\nOuUYka+2Z9URPx8/4WPtDO065iwiBL4dT1x1UsfmnzUbG2i2zDpXjwaxFTgCVaCJ\nKO4ShuVZtatd07+i9y1YrftEYrnDBJCLOWw1yptMH0CaYozcQv4sMPtv3H+eWqMC\n5etAJshR4dhU//a5vyRvEOkVVAMcn6NbwlR2CWrpcpYZG37Z2XvzEQLs8gH6Wm0=\n=Lt/o\n-----END PGP SIGNATURE-----\n", "payload": "tree 86909ffd14dad0005365f5a2df02ad112be33da7\nparent 5082fe21a814e16f25cb8cfb0ebae7fff5541d0a\nparent 5cb5ddeb3c8463ecb9472bea03b69a9521e87c5c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585913485 +0200\ncommitter GitHub <noreply@github.com> 1585913485 +0200\n\nRollup merge of #70725 - Centril:nix-unwraps, r=estebank\n\nAvoid `.unwrap()`s on `.span_to_snippet(...)`s\n\nFirst commit fixes https://github.com/rust-lang/rust/issues/70724 and the others fix similar issues found by grepping.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "html_url": "https://github.com/rust-lang/rust/commit/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5082fe21a814e16f25cb8cfb0ebae7fff5541d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5082fe21a814e16f25cb8cfb0ebae7fff5541d0a", "html_url": "https://github.com/rust-lang/rust/commit/5082fe21a814e16f25cb8cfb0ebae7fff5541d0a"}, {"sha": "5cb5ddeb3c8463ecb9472bea03b69a9521e87c5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cb5ddeb3c8463ecb9472bea03b69a9521e87c5c", "html_url": "https://github.com/rust-lang/rust/commit/5cb5ddeb3c8463ecb9472bea03b69a9521e87c5c"}], "stats": {"total": 191, "additions": 116, "deletions": 75}, "files": [{"sha": "b3764d2d47be14aa587994edb16fe78a9f47ee9a", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -165,9 +165,9 @@ impl<'a> Parser<'a> {\n                     // Rewind to before attempting to parse the type and continue parsing.\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n-\n-                    let snippet = self.span_to_snippet(pat.span).unwrap();\n-                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n+                    if let Ok(snip) = self.span_to_snippet(pat.span) {\n+                        err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snip));\n+                    }\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n             }"}, {"sha": "5a9a96887f66a31f41a4b737d677d2d4b24c006e", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -65,7 +65,7 @@ pub trait InferCtxtExt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>);\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -611,10 +611,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     )\n                 } else {\n                     let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n+                        .and_then(|did| {\n+                            let node = self.tcx.hir().get_if_local(did)?;\n+                            let (found_span, found) = self.get_fn_like_arguments(node)?;\n+                            Some((Some(found_span), found))\n                         })\n                         .unwrap_or((found_span, found));\n \n@@ -672,43 +672,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n-        match node {\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+        let sm = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n+        Some(match node {\n             Node::Expr(&hir::Expr {\n                 kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n-                self.tcx\n-                    .hir()\n-                    .body(id)\n+                sm.guess_head_span(span),\n+                hir.body(id)\n                     .params\n                     .iter()\n                     .map(|arg| {\n                         if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n                             *arg.pat\n                         {\n-                            ArgKind::Tuple(\n+                            Some(ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter()\n                                     .map(|pat| {\n-                                        let snippet = self\n-                                            .tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .span_to_snippet(pat.span)\n-                                            .unwrap();\n-                                        (snippet, \"_\".to_owned())\n+                                        sm.span_to_snippet(pat.span)\n+                                            .ok()\n+                                            .map(|snippet| (snippet, \"_\".to_owned()))\n                                     })\n-                                    .collect::<Vec<_>>(),\n-                            )\n+                                    .collect::<Option<Vec<_>>>()?,\n+                            ))\n                         } else {\n-                            let name =\n-                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n-                            ArgKind::Arg(name, \"_\".to_owned())\n+                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n+                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n                         }\n                     })\n-                    .collect::<Vec<ArgKind>>(),\n+                    .collect::<Option<Vec<ArgKind>>>()?,\n             ),\n             Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n             | Node::ImplItem(&hir::ImplItem {\n@@ -721,7 +716,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n+                sm.guess_head_span(span),\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -735,16 +730,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .collect::<Vec<ArgKind>>(),\n             ),\n             Node::Ctor(ref variant_data) => {\n-                let span = variant_data\n-                    .ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span(hir_id))\n-                    .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().guess_head_span(span);\n-\n+                let span = variant_data.ctor_hir_id().map(|id| hir.span(id)).unwrap_or(DUMMY_SP);\n+                let span = sm.guess_head_span(span);\n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        }\n+        })\n     }\n \n     /// Reports an error when the number of arguments needed by a"}, {"sha": "fcec29aaa8ecb51688a98cf79d091d50edc39088", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -732,12 +732,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 true\n             };\n \n+        let sm = self.tcx.sess.source_map();\n         let (snippet, last_ty) =\n             if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n                 // Verify that we're dealing with a return `dyn Trait`\n                 ret_ty.span.overlaps(span),\n                 &ret_ty.kind,\n-                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                sm.span_to_snippet(ret_ty.span),\n                 // If any of the return types does not conform to the trait, then we can't\n                 // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n                 all_returns_conform_to_trait,\n@@ -775,26 +776,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if is_object_safe {\n                 // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n                 // Get all the return values and collect their span and suggestion.\n-                let mut suggestions = visitor\n+                if let Some(mut suggestions) = visitor\n                     .returns\n                     .iter()\n                     .map(|expr| {\n-                        (\n-                            expr.span,\n-                            format!(\n-                                \"Box::new({})\",\n-                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n-                            ),\n-                        )\n+                        let snip = sm.span_to_snippet(expr.span).ok()?;\n+                        Some((expr.span, format!(\"Box::new({})\", snip)))\n                     })\n-                    .collect::<Vec<_>>();\n-                // Add the suggestion for the return type.\n-                suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n-                err.multipart_suggestion(\n-                    \"return a boxed trait object instead\",\n-                    suggestions,\n-                    Applicability::MaybeIncorrect,\n-                );\n+                    .collect::<Option<Vec<_>>>()\n+                {\n+                    // Add the suggestion for the return type.\n+                    suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n+                    err.multipart_suggestion(\n+                        \"return a boxed trait object instead\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             } else {\n                 // This is currently not possible to trigger because E0038 takes precedence, but\n                 // leave it in for completeness in case anything changes in an earlier stage."}, {"sha": "2ccf7890c3042327dc23048edfd04990605d907a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -432,18 +432,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let expr_map_node = self.tcx.hir().get_if_local(expr_def_id).unwrap();\n+        let hir = self.tcx.hir();\n+        let expr_map_node = hir.get_if_local(expr_def_id).unwrap();\n         let expected_args: Vec<_> = expected_sig\n             .sig\n             .inputs()\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(ty, None))\n             .collect();\n-        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n-        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n+            Some((sp, args)) => (Some(sp), args),\n+            None => (None, Vec::new()),\n+        };\n+        let expected_span =\n+            expected_sig.cause_span.unwrap_or_else(|| hir.span_if_local(expr_def_id).unwrap());\n         self.report_arg_count_mismatch(\n             expected_span,\n-            Some(closure_span),\n+            closure_span,\n             expected_args,\n             found_args,\n             true,"}, {"sha": "cac9113fd5d30e2d3007ea229b156cd63efb4c4c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// If one of the types is an uncalled function and calling it would yield the other type,\n-    /// suggest calling the function. Returns whether a suggestion was given.\n+    /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n     fn add_type_neq_err_label(\n         &self,\n         err: &mut rustc_errors::DiagnosticBuilder<'_>,\n@@ -514,24 +514,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .lookup_op_method(fn_sig.output(), &[other_ty], Op::Binary(op, is_assign))\n                 .is_ok()\n             {\n-                let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n-                    (\n-                        format!(\"{}( /* arguments */ )\", source_map.span_to_snippet(span).unwrap()),\n-                        Applicability::HasPlaceholders,\n-                    )\n-                } else {\n-                    (\n-                        format!(\"{}()\", source_map.span_to_snippet(span).unwrap()),\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                };\n+                if let Ok(snippet) = source_map.span_to_snippet(span) {\n+                    let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n+                        (format!(\"{}( /* arguments */ )\", snippet), Applicability::HasPlaceholders)\n+                    } else {\n+                        (format!(\"{}()\", snippet), Applicability::MaybeIncorrect)\n+                    };\n \n-                err.span_suggestion(\n-                    span,\n-                    \"you might have forgotten to call this function\",\n-                    variable_snippet,\n-                    applicability,\n-                );\n+                    err.span_suggestion(\n+                        span,\n+                        \"you might have forgotten to call this function\",\n+                        variable_snippet,\n+                        applicability,\n+                    );\n+                }\n                 return true;\n             }\n         }"}, {"sha": "c2683157f797fa4bfaa58e7e8ae063a05cd1ec83", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.rs?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -0,0 +1,10 @@\n+fn a() -> i32 {\n+    3\n+}\n+\n+pub fn main() {\n+    assert_eq!(a, 0);\n+    //~^ ERROR binary operation `==` cannot\n+    //~| ERROR mismatched types\n+    //~| ERROR doesn't implement\n+}"}, {"sha": "467c15cc52d45d5efd4f9d87f1a6440f80f52bdf", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "patch": "@@ -0,0 +1,41 @@\n+error[E0369]: binary operation `==` cannot be applied to type `fn() -> i32 {a}`\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     fn() -> i32 {a}\n+   |     {integer}\n+   |     help: you might have forgotten to call this function: `*left_val()`\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^ expected fn item, found integer\n+   |\n+   = note: expected fn item `fn() -> i32 {a}`\n+                 found type `i32`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `fn() -> i32 {a}` doesn't implement `std::fmt::Debug`\n+  --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n+   |\n+LL | fn a() -> i32 {\n+   |    - consider calling this function\n+...\n+LL |     assert_eq!(a, 0);\n+   |     ^^^^^^^^^^^^^^^^^ `fn() -> i32 {a}` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `fn() -> i32 {a}`\n+   = help: use parentheses to call the function: `a()`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `&fn() -> i32 {a}`\n+   = note: required by `std::fmt::Debug::fmt`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0369.\n+For more information about an error, try `rustc --explain E0277`."}]}