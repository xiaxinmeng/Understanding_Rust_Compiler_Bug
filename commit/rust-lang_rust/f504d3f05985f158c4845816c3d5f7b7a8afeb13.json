{"sha": "f504d3f05985f158c4845816c3d5f7b7a8afeb13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MDRkM2YwNTk4NWYxNThjNDg0NTgxNmMzZDVmN2I3YThhZmViMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T12:18:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T12:18:19Z"}, "message": "Auto merge of #56487 - nikic:discard-modules-earlier, r=alexcrichton\n\nDiscard LLVM modules earlier when performing ThinLTO\n\nCurrently ThinLTO is performed by first compiling all modules (and keeping them in memory), and then serializing them into ThinLTO buffers in a separate, synchronized step. Modules are later read back from ThinLTO buffers when running the ThinLTO optimization pipeline.\n\nWe can also find the following comment in `lto.rs`:\n\n        // FIXME: right now, like with fat LTO, we serialize all in-memory\n        //        modules before working with them and ThinLTO. We really\n        //        shouldn't do this, however, and instead figure out how to\n        //        extract a summary from an in-memory module and then merge that\n        //        into the global index. It turns out that this loop is by far\n        //        the most expensive portion of this small bit of global\n        //        analysis!\n\nI don't think that what is suggested here is the right approach: One of the primary benefits of using ThinLTO over ordinary LTO is that it's not necessary to keep all the modules (merged or not) in memory for the duration of the linking step.\n\nHowever, we currently don't really make use of this (at least for crate-local ThinLTO), because we keep all modules in memory until the start of the LTO step. This PR changes the implementation to instead perform the serialization into ThinLTO buffers directly after the initial optimization step.\n\nMost of the changes here are plumbing to separate out fat and thin lto handling in `write.rs`, as these now use different intermediate artifacts. For fat lto this will be in-memory modules, for thin lto it will be ThinLTO buffers.\n\nr? @alexcrichton", "tree": {"sha": "93f41c10caba38d981162a3e02347f8f66512f8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f41c10caba38d981162a3e02347f8f66512f8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f504d3f05985f158c4845816c3d5f7b7a8afeb13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f504d3f05985f158c4845816c3d5f7b7a8afeb13", "html_url": "https://github.com/rust-lang/rust/commit/f504d3f05985f158c4845816c3d5f7b7a8afeb13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f504d3f05985f158c4845816c3d5f7b7a8afeb13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc84f5f837a3e1b9b9bc992dd603d3d968502288", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc84f5f837a3e1b9b9bc992dd603d3d968502288", "html_url": "https://github.com/rust-lang/rust/commit/fc84f5f837a3e1b9b9bc992dd603d3d968502288"}, {"sha": "8128d0d1a95f5d77b672558c202cbf37d595fba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8128d0d1a95f5d77b672558c202cbf37d595fba3", "html_url": "https://github.com/rust-lang/rust/commit/8128d0d1a95f5d77b672558c202cbf37d595fba3"}], "stats": {"total": 397, "additions": 231, "deletions": 166}, "files": [{"sha": "bddb45da10b004c914169a4f550877552e93b09b", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=f504d3f05985f158c4845816c3d5f7b7a8afeb13", "patch": "@@ -48,18 +48,11 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-/// Performs LTO, which in the case of full LTO means merging all modules into\n-/// a single one and returning it for further optimizing. For ThinLTO, it will\n-/// do the global analysis necessary and return two lists, one of the modules\n-/// the need optimization and another for modules that can simply be copied over\n-/// from the incr. comp. cache.\n-pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                  modules: Vec<ModuleCodegen<ModuleLlvm>>,\n-                  cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-                  timeline: &mut Timeline)\n-    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+               timeline: &mut Timeline,\n+               diag_handler: &Handler)\n+    -> Result<(Vec<CString>, Vec<(SerializedModule<ModuleBuffer>, CString)>), FatalError>\n {\n-    let diag_handler = cgcx.create_diag_handler();\n     let export_threshold = match cgcx.lto {\n         // We're just doing LTO for our one crate\n         Lto::ThinLocal => SymbolExportLevel::Rust,\n@@ -144,36 +137,74 @@ pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n     }\n \n+    Ok((symbol_white_list, upstream_modules))\n+}\n+\n+/// Performs fat LTO by merging all modules into a single one and returning it\n+/// for further optimization.\n+pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                      modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                      timeline: &mut Timeline)\n+    -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    match cgcx.lto {\n-        Lto::Fat => {\n-            assert!(cached_modules.is_empty());\n-            let opt_jobs = fat_lto(cgcx,\n-                                   &diag_handler,\n-                                   modules,\n-                                   upstream_modules,\n-                                   &symbol_white_list,\n-                                   timeline);\n-            opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n-        }\n-        Lto::Thin |\n-        Lto::ThinLocal => {\n-            if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n-                unreachable!(\"We should never reach this case if the LTO step \\\n-                              is deferred to the linker\");\n-            }\n-            thin_lto(cgcx,\n-                     &diag_handler,\n-                     modules,\n-                     upstream_modules,\n-                     cached_modules,\n-                     &symbol_white_list,\n-                     timeline)\n+    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &symbol_white_list, timeline)\n+}\n+\n+/// Performs thin LTO by performing necessary global analysis and returning two\n+/// lists, one of the modules that need optimization and another for modules that\n+/// can simply be copied over from the incr. comp. cache.\n+pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                       modules: Vec<(String, ThinBuffer)>,\n+                       cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n+                       timeline: &mut Timeline)\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n+    let symbol_white_list = symbol_white_list.iter()\n+                                             .map(|c| c.as_ptr())\n+                                             .collect::<Vec<_>>();\n+    if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n+        unreachable!(\"We should never reach this case if the LTO step \\\n+                      is deferred to the linker\");\n+    }\n+    thin_lto(cgcx,\n+             &diag_handler,\n+             modules,\n+             upstream_modules,\n+             cached_modules,\n+             &symbol_white_list,\n+             timeline)\n+}\n+\n+pub(crate) fn prepare_thin(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: ModuleCodegen<ModuleLlvm>\n+) -> (String, ThinBuffer) {\n+    let name = module.name.clone();\n+    let buffer = ThinBuffer::new(module.module_llvm.llmod());\n+\n+    // We emit the module after having serialized it into a ThinBuffer\n+    // because only then it will contain the ThinLTO module summary.\n+    if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n+        if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n+            let path = incr_comp_session_dir\n+                .join(pre_lto_bitcode_filename(&name));\n+\n+            fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n+                panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                       path.display(),\n+                       e);\n+            });\n         }\n-        Lto::No => unreachable!(),\n     }\n+\n+    (name, buffer)\n }\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n@@ -182,7 +213,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleCodegen<LlvmCodegenBackend>>, FatalError>\n+    -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n@@ -271,10 +302,10 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         timeline.record(\"passes\");\n     }\n \n-    Ok(vec![LtoModuleCodegen::Fat {\n+    Ok(LtoModuleCodegen::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n-    }])\n+    })\n }\n \n struct Linker<'a>(&'a mut llvm::Linker<'a>);\n@@ -335,7 +366,7 @@ impl Drop for Linker<'a> {\n /// they all go out of scope.\n fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             diag_handler: &Handler,\n-            modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+            modules: Vec<(String, ThinBuffer)>,\n             serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n             cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n             symbol_white_list: &[*const libc::c_char],\n@@ -355,41 +386,17 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         let mut module_names = Vec::with_capacity(full_scope_len);\n         let mut thin_modules = Vec::with_capacity(full_scope_len);\n \n-        // FIXME: right now, like with fat LTO, we serialize all in-memory\n-        //        modules before working with them and ThinLTO. We really\n-        //        shouldn't do this, however, and instead figure out how to\n-        //        extract a summary from an in-memory module and then merge that\n-        //        into the global index. It turns out that this loop is by far\n-        //        the most expensive portion of this small bit of global\n-        //        analysis!\n-        for (i, module) in modules.into_iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.name);\n-            let name = CString::new(module.name.clone()).unwrap();\n-            let buffer = ThinBuffer::new(module.module_llvm.llmod());\n-\n-            // We emit the module after having serialized it into a ThinBuffer\n-            // because only then it will contain the ThinLTO module summary.\n-            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-                if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n-                    let path = incr_comp_session_dir\n-                        .join(pre_lto_bitcode_filename(&module.name));\n-\n-                    fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n-                        panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n-                               path.display(),\n-                               e);\n-                    });\n-                }\n-            }\n-\n+        for (i, (name, buffer)) in modules.into_iter().enumerate() {\n+            info!(\"local module: {} - {}\", i, name);\n+            let cname = CString::new(name.clone()).unwrap();\n             thin_modules.push(llvm::ThinLTOModule {\n-                identifier: name.as_ptr(),\n+                identifier: cname.as_ptr(),\n                 data: buffer.data().as_ptr(),\n                 len: buffer.data().len(),\n             });\n             thin_buffers.push(buffer);\n-            module_names.push(name);\n-            timeline.record(&module.name);\n+            module_names.push(cname);\n+            timeline.record(&name);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the"}, {"sha": "ff06d3759bd940e86bc98b2f039510a374f20a75", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=f504d3f05985f158c4845816c3d5f7b7a8afeb13", "patch": "@@ -176,13 +176,20 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     fn print_pass_timings(&self) {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n     }\n-    fn run_lto(\n+    fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<ModuleCodegen<Self::Module>>,\n+        timeline: &mut Timeline\n+    ) -> Result<LtoModuleCodegen<Self>, FatalError> {\n+        back::lto::run_fat(cgcx, modules, timeline)\n+    }\n+    fn run_thin_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n-        back::lto::run(cgcx, modules, cached_modules, timeline)\n+        back::lto::run_thin(cgcx, modules, cached_modules, timeline)\n     }\n     unsafe fn optimize(\n         cgcx: &CodegenContext<Self>,\n@@ -209,6 +216,12 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     ) -> Result<CompiledModule, FatalError> {\n         back::write::codegen(cgcx, diag_handler, module, config, timeline)\n     }\n+    fn prepare_thin(\n+        cgcx: &CodegenContext<Self>,\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ThinBuffer) {\n+        back::lto::prepare_thin(cgcx, module)\n+    }\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         module: &ModuleCodegen<Self::Module>,"}, {"sha": "59955ce77cde4ec385666e04ffdbf61343a32399", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 124, "deletions": 88, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=f504d3f05985f158c4845816c3d5f7b7a8afeb13", "patch": "@@ -252,30 +252,37 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n-    modules: Vec<ModuleCodegen<B::Module>>,\n+    needs_fat_lto: Vec<ModuleCodegen<B::Module>>,\n+    needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n     let mut timeline = cgcx.time_graph.as_ref().map(|tg| {\n         tg.start(CODEGEN_WORKER_TIMELINE,\n                  CODEGEN_WORK_PACKAGE_KIND,\n                  \"generate lto\")\n     }).unwrap_or(Timeline::noop());\n-    let (lto_modules, copy_jobs) = B::run_lto(cgcx, modules, import_only_modules, &mut timeline)\n-        .unwrap_or_else(|e| e.raise());\n \n-    let lto_modules = lto_modules.into_iter().map(|module| {\n+    let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n+        assert!(needs_thin_lto.is_empty());\n+        assert!(import_only_modules.is_empty());\n+        let lto_module = B::run_fat_lto(cgcx, needs_fat_lto, &mut timeline)\n+            .unwrap_or_else(|e| e.raise());\n+        (vec![lto_module], vec![])\n+    } else {\n+        assert!(needs_fat_lto.is_empty());\n+        B::run_thin_lto(cgcx, needs_thin_lto, import_only_modules, &mut timeline)\n+            .unwrap_or_else(|e| e.raise())\n+    };\n+\n+    lto_modules.into_iter().map(|module| {\n         let cost = module.cost();\n         (WorkItem::LTO(module), cost)\n-    });\n-\n-    let copy_jobs = copy_jobs.into_iter().map(|wp| {\n+    }).chain(copy_jobs.into_iter().map(|wp| {\n         (WorkItem::CopyPostLtoArtifacts(CachedModuleCodegen {\n             name: wp.cgu_name.clone(),\n             source: wp,\n         }), 0)\n-    });\n-\n-    lto_modules.chain(copy_jobs).collect()\n+    })).collect()\n }\n \n pub struct CompiledModules {\n@@ -671,16 +678,17 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n     }\n }\n \n-enum WorkItemResult<M> {\n+enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n-    NeedsLTO(ModuleCodegen<M>),\n+    NeedsFatLTO(ModuleCodegen<B::Module>),\n+    NeedsThinLTO(String, B::ThinBuffer),\n }\n \n fn execute_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     work_item: WorkItem<B>,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let module_config = cgcx.config(work_item.module_kind());\n \n     match work_item {\n@@ -696,75 +704,88 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     }\n }\n \n+// Actual LTO type we end up chosing based on multiple factors.\n+enum ComputedLtoType {\n+    No,\n+    Thin,\n+    Fat,\n+}\n+\n fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: ModuleCodegen<B::Module>,\n     module_config: &ModuleConfig,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n         B::optimize(cgcx, &diag_handler, &module, module_config, timeline)?;\n     }\n \n-    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n-\n     // After we've done the initial round of optimizations we need to\n     // decide whether to synchronously codegen this module or ship it\n     // back to the coordinator thread for further LTO processing (which\n     // has to wait for all the initial modules to be optimized).\n-    //\n-    // Here we dispatch based on the `cgcx.lto` and kind of module we're\n-    // codegenning...\n-    let needs_lto = match cgcx.lto {\n-        Lto::No => false,\n \n-        // If the linker does LTO, we don't have to do it. Note that we\n-        // keep doing full LTO, if it is requested, as not to break the\n-        // assumption that the output will be a single module.\n-        Lto::Thin | Lto::ThinLocal if linker_does_lto => false,\n+    // If the linker does LTO, we don't have to do it. Note that we\n+    // keep doing full LTO, if it is requested, as not to break the\n+    // assumption that the output will be a single module.\n+    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n \n-        // Here we've got a full crate graph LTO requested. We ignore\n-        // this, however, if the crate type is only an rlib as there's\n-        // no full crate graph to process, that'll happen later.\n-        //\n-        // This use case currently comes up primarily for targets that\n-        // require LTO so the request for LTO is always unconditionally\n-        // passed down to the backend, but we don't actually want to do\n-        // anything about it yet until we've got a final product.\n-        Lto::Fat | Lto::Thin => {\n-            cgcx.crate_types.len() != 1 ||\n-                cgcx.crate_types[0] != config::CrateType::Rlib\n-        }\n+    // When we're automatically doing ThinLTO for multi-codegen-unit\n+    // builds we don't actually want to LTO the allocator modules if\n+    // it shows up. This is due to various linker shenanigans that\n+    // we'll encounter later.\n+    let is_allocator = module.kind == ModuleKind::Allocator;\n \n-        // When we're automatically doing ThinLTO for multi-codegen-unit\n-        // builds we don't actually want to LTO the allocator modules if\n-        // it shows up. This is due to various linker shenanigans that\n-        // we'll encounter later.\n-        Lto::ThinLocal => {\n-            module.kind != ModuleKind::Allocator\n-        }\n-    };\n+    // We ignore a request for full crate grath LTO if the cate type\n+    // is only an rlib, as there is no full crate graph to process,\n+    // that'll happen later.\n+    //\n+    // This use case currently comes up primarily for targets that\n+    // require LTO so the request for LTO is always unconditionally\n+    // passed down to the backend, but we don't actually want to do\n+    // anything about it yet until we've got a final product.\n+    let is_rlib = cgcx.crate_types.len() == 1\n+        && cgcx.crate_types[0] == config::CrateType::Rlib;\n \n     // Metadata modules never participate in LTO regardless of the lto\n     // settings.\n-    let needs_lto = needs_lto && module.kind != ModuleKind::Metadata;\n-\n-    if needs_lto {\n-        Ok(WorkItemResult::NeedsLTO(module))\n+    let lto_type = if module.kind == ModuleKind::Metadata {\n+        ComputedLtoType::No\n     } else {\n-        let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config, timeline)? };\n-        Ok(WorkItemResult::Compiled(module))\n-    }\n+        match cgcx.lto {\n+            Lto::ThinLocal if !linker_does_lto && !is_allocator\n+                => ComputedLtoType::Thin,\n+            Lto::Thin if !linker_does_lto && !is_rlib\n+                => ComputedLtoType::Thin,\n+            Lto::Fat if !is_rlib => ComputedLtoType::Fat,\n+            _ => ComputedLtoType::No,\n+        }\n+    };\n+\n+    Ok(match lto_type {\n+        ComputedLtoType::No => {\n+            let module = unsafe {\n+                B::codegen(cgcx, &diag_handler, module, module_config, timeline)?\n+            };\n+            WorkItemResult::Compiled(module)\n+        }\n+        ComputedLtoType::Thin => {\n+            let (name, thin_buffer) = B::prepare_thin(cgcx, module);\n+            WorkItemResult::NeedsThinLTO(name, thin_buffer)\n+        }\n+        ComputedLtoType::Fat => WorkItemResult::NeedsFatLTO(module),\n+    })\n }\n \n fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n     _: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir\n                                     .as_ref()\n                                     .unwrap();\n@@ -826,7 +847,7 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n     mut module: lto::LtoModuleCodegen<B>,\n     module_config: &ModuleConfig,\n     timeline: &mut Timeline\n-) -> Result<WorkItemResult<B::Module>, FatalError> {\n+) -> Result<WorkItemResult<B>, FatalError> {\n     let diag_handler = cgcx.create_diag_handler();\n \n     unsafe {\n@@ -838,10 +859,15 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n \n pub enum Message<B: WriteBackendMethods> {\n     Token(io::Result<Acquired>),\n-    NeedsLTO {\n+    NeedsFatLTO {\n         result: ModuleCodegen<B::Module>,\n         worker_id: usize,\n     },\n+    NeedsThinLTO {\n+        name: String,\n+        thin_buffer: B::ThinBuffer,\n+        worker_id: usize,\n+    },\n     Done {\n         result: Result<CompiledModule, ()>,\n         worker_id: usize,\n@@ -1137,7 +1163,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         let mut compiled_modules = vec![];\n         let mut compiled_metadata_module = None;\n         let mut compiled_allocator_module = None;\n-        let mut needs_lto = Vec::new();\n+        let mut needs_fat_lto = Vec::new();\n+        let mut needs_thin_lto = Vec::new();\n         let mut lto_import_only_modules = Vec::new();\n         let mut started_lto = false;\n         let mut codegen_aborted = false;\n@@ -1166,7 +1193,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n               running > 0 ||\n               (!codegen_aborted && (\n                   work_items.len() > 0 ||\n-                  needs_lto.len() > 0 ||\n+                  needs_fat_lto.len() > 0 ||\n+                  needs_thin_lto.len() > 0 ||\n                   lto_import_only_modules.len() > 0 ||\n                   main_thread_worker_state != MainThreadWorkerState::Idle\n               ))\n@@ -1212,12 +1240,17 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                    running == 0 &&\n                    main_thread_worker_state == MainThreadWorkerState::Idle {\n                     assert!(!started_lto);\n-                    assert!(needs_lto.len() + lto_import_only_modules.len() > 0);\n                     started_lto = true;\n-                    let modules = mem::replace(&mut needs_lto, Vec::new());\n+\n+                    let needs_fat_lto =\n+                        mem::replace(&mut needs_fat_lto, Vec::new());\n+                    let needs_thin_lto =\n+                        mem::replace(&mut needs_thin_lto, Vec::new());\n                     let import_only_modules =\n                         mem::replace(&mut lto_import_only_modules, Vec::new());\n-                    for (work, cost) in generate_lto_work(&cgcx, modules, import_only_modules) {\n+\n+                    for (work, cost) in generate_lto_work(&cgcx, needs_fat_lto,\n+                                                          needs_thin_lto, import_only_modules) {\n                         let insertion_index = work_items\n                             .binary_search_by_key(&cost, |&(_, cost)| cost)\n                             .unwrap_or_else(|e| e);\n@@ -1284,6 +1317,21 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             // Relinquish accidentally acquired extra tokens\n             tokens.truncate(running);\n \n+            // If a thread exits successfully then we drop a token associated\n+            // with that worker and update our `running` count. We may later\n+            // re-acquire a token to continue running more work. We may also not\n+            // actually drop a token here if the worker was running with an\n+            // \"ephemeral token\"\n+            let mut free_worker = |worker_id| {\n+                if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n+                } else {\n+                    running -= 1;\n+                }\n+\n+                free_worker_ids.push(worker_id);\n+            };\n+\n             let msg = coordinator_receive.recv().unwrap();\n             match *msg.downcast::<Message<B>>().ok().unwrap() {\n                 // Save the token locally and the next turn of the loop will use\n@@ -1358,24 +1406,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     assert_eq!(main_thread_worker_state,\n                                MainThreadWorkerState::Codegenning);\n                 }\n-\n-                // If a thread exits successfully then we drop a token associated\n-                // with that worker and update our `running` count. We may later\n-                // re-acquire a token to continue running more work. We may also not\n-                // actually drop a token here if the worker was running with an\n-                // \"ephemeral token\"\n-                //\n-                // Note that if the thread failed that means it panicked, so we\n-                // abort immediately.\n                 Message::Done { result: Ok(compiled_module), worker_id } => {\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-\n-                    free_worker_ids.push(worker_id);\n-\n+                    free_worker(worker_id);\n                     match compiled_module.kind {\n                         ModuleKind::Regular => {\n                             compiled_modules.push(compiled_module);\n@@ -1390,15 +1422,15 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         }\n                     }\n                 }\n-                Message::NeedsLTO { result, worker_id } => {\n+                Message::NeedsFatLTO { result, worker_id } => {\n                     assert!(!started_lto);\n-                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n-                        main_thread_worker_state = MainThreadWorkerState::Idle;\n-                    } else {\n-                        running -= 1;\n-                    }\n-                    free_worker_ids.push(worker_id);\n-                    needs_lto.push(result);\n+                    free_worker(worker_id);\n+                    needs_fat_lto.push(result);\n+                }\n+                Message::NeedsThinLTO { name, thin_buffer, worker_id } => {\n+                    assert!(!started_lto);\n+                    free_worker(worker_id);\n+                    needs_thin_lto.push((name, thin_buffer));\n                 }\n                 Message::AddImportOnlyModule { module_data, work_product } => {\n                     assert!(!started_lto);\n@@ -1408,6 +1440,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     lto_import_only_modules.push((module_data, work_product));\n                     main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n+                // If the thread failed that means it panicked, so we abort immediately.\n                 Message::Done { result: Err(()), worker_id: _ } => {\n                     bug!(\"worker thread panicked\");\n                 }\n@@ -1485,7 +1518,7 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // we exit.\n         struct Bomb<B: ExtraBackendMethods> {\n             coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<WorkItemResult<B::Module>>,\n+            result: Option<WorkItemResult<B>>,\n             worker_id: usize,\n         }\n         impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n@@ -1495,8 +1528,11 @@ fn spawn_work<B: ExtraBackendMethods>(\n                     Some(WorkItemResult::Compiled(m)) => {\n                         Message::Done::<B> { result: Ok(m), worker_id }\n                     }\n-                    Some(WorkItemResult::NeedsLTO(m)) => {\n-                        Message::NeedsLTO::<B> { result: m, worker_id }\n+                    Some(WorkItemResult::NeedsFatLTO(m)) => {\n+                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                    }\n+                    Some(WorkItemResult::NeedsThinLTO(name, thin_buffer)) => {\n+                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n                     }\n                     None => Message::Done::<B> { result: Err(()), worker_id }\n                 };"}, {"sha": "edc5c2717bc4f39fb039de28ef9d095ff5dcd0b8", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f504d3f05985f158c4845816c3d5f7b7a8afeb13/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=f504d3f05985f158c4845816c3d5f7b7a8afeb13", "patch": "@@ -24,14 +24,19 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n \n-    /// Performs LTO, which in the case of full LTO means merging all modules into\n-    /// a single one and returning it for further optimizing. For ThinLTO, it will\n-    /// do the global analysis necessary and return two lists, one of the modules\n-    /// the need optimization and another for modules that can simply be copied over\n-    /// from the incr. comp. cache.\n-    fn run_lto(\n+    /// Performs fat LTO by merging all modules into a single one and returning it\n+    /// for further optimization.\n+    fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<ModuleCodegen<Self::Module>>,\n+        timeline: &mut Timeline,\n+    ) -> Result<LtoModuleCodegen<Self>, FatalError>;\n+    /// Performs thin LTO by performing necessary global analysis and returning two\n+    /// lists, one of the modules that need optimization and another for modules that\n+    /// can simply be copied over from the incr. comp. cache.\n+    fn run_thin_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline,\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError>;\n@@ -55,6 +60,10 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         config: &ModuleConfig,\n         timeline: &mut Timeline,\n     ) -> Result<CompiledModule, FatalError>;\n+    fn prepare_thin(\n+        cgcx: &CodegenContext<Self>,\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ThinBuffer);\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         llmod: &ModuleCodegen<Self::Module>,"}]}