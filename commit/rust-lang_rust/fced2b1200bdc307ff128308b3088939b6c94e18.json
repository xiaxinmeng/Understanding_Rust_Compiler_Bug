{"sha": "fced2b1200bdc307ff128308b3088939b6c94e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZWQyYjEyMDBiZGMzMDdmZjEyODMwOGIzMDg4OTM5YjZjOTRlMTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-05T13:38:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-10T12:22:31Z"}, "message": "fix SCCs containing mixture of universes\n\nAnd add a test showing a universe violation getting caught.", "tree": {"sha": "12134f0e59f63acb4f44e30f49f8987c0112d11f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12134f0e59f63acb4f44e30f49f8987c0112d11f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fced2b1200bdc307ff128308b3088939b6c94e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fced2b1200bdc307ff128308b3088939b6c94e18", "html_url": "https://github.com/rust-lang/rust/commit/fced2b1200bdc307ff128308b3088939b6c94e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fced2b1200bdc307ff128308b3088939b6c94e18/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0e3a09bb83e492c9bac45a0b4ce72cb0aecb456", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e3a09bb83e492c9bac45a0b4ce72cb0aecb456", "html_url": "https://github.com/rust-lang/rust/commit/f0e3a09bb83e492c9bac45a0b4ce72cb0aecb456"}], "stats": {"total": 89, "additions": 61, "deletions": 28}, "files": [{"sha": "214628600b370675e5708a51baa90ece318b7a96", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=fced2b1200bdc307ff128308b3088939b6c94e18", "patch": "@@ -319,23 +319,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         for variable in self.definitions.indices() {\n+            let scc = self.constraint_sccs.scc(variable);\n+\n             match self.definitions[variable].origin {\n                 NLLRegionVariableOrigin::FreeRegion => {\n                     // For each free, universally quantified region X:\n \n                     // Add all nodes in the CFG to liveness constraints\n-                    let variable_scc = self.constraint_sccs.scc(variable);\n                     self.liveness_constraints.add_all_points(variable);\n-                    self.scc_values.add_all_points(variable_scc);\n+                    self.scc_values.add_all_points(scc);\n \n                     // Add `end(X)` into the set for X.\n-                    self.add_element_to_scc_of(variable, variable);\n+                    self.scc_values.add_element(scc, variable);\n                 }\n \n                 NLLRegionVariableOrigin::BoundRegion(ui) => {\n                     // Each placeholder region X outlives its\n-                    // associated universe but nothing else.\n-                    self.add_element_to_scc_of(variable, ui);\n+                    // associated universe but nothing else. Every\n+                    // placeholder region is always in a universe that\n+                    // contains `ui` -- but when placeholder regions\n+                    // are placed into an SCC, that SCC may include\n+                    // things from other universes that do not include\n+                    // `ui`.\n+                    let scc_universe = self.scc_universes[scc];\n+                    if ui.is_subset_of(scc_universe) {\n+                        self.scc_values.add_element(scc, ui);\n+                    } else {\n+                        self.add_incompatible_universe(scc);\n+                    }\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -383,13 +394,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n-    /// Adds `elem` to the value of the SCC in which `v` appears.\n-    fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n-        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n-        let scc = self.constraint_sccs.scc(v);\n-        self.scc_values.add_element(scc, elem);\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -516,22 +520,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // merge the bits.\n                 self.scc_values.add_region(scc_a, scc_b);\n             } else {\n-                // Otherwise, the only way for `A` to outlive `B`\n-                // is for it to outlive static. This is actually stricter\n-                // than necessary: ideally, we'd support bounds like `for<'a: 'b`>`\n-                // that might then allow us to approximate `'a` with `'b` and not\n-                // `'static`. But it will have to do for now.\n-                //\n-                // The code here is a bit hacky: we grab the current\n-                // value of the SCC in which `'static` appears, but\n-                // this value may not be fully computed yet. That's ok\n-                // though: it will contain the base liveness values,\n-                // which include (a) the static free region element\n-                // and (b) all the points in the CFG, so it is \"good\n-                // enough\" to bring it in here for our purposes.\n-                let fr_static = self.universal_regions.fr_static;\n-                let scc_static = constraint_sccs.scc(fr_static);\n-                self.scc_values.add_region(scc_a, scc_static);\n+                self.add_incompatible_universe(scc_a);\n             }\n         }\n \n@@ -563,6 +552,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .all(|u| u.is_subset_of(universe_a))\n     }\n \n+    /// Extend `scc` so that it can outlive some placeholder region\n+    /// from a universe it can't name; at present, the only way for\n+    /// this to be true is if `scc` outlives `'static`. This is\n+    /// actually stricter than necessary: ideally, we'd support bounds\n+    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// `'a` with `'b` and not `'static`. But it will have to do for\n+    /// now.\n+    fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n+        let fr_static = self.universal_regions.fr_static;\n+        self.scc_values.add_all_points(scc);\n+        self.scc_values.add_element(scc, fr_static);\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}, {"sha": "cc86c8d02d3aac3214fdee460cf9583b3add305b", "filename": "src/test/ui/nll/relate_tys/universe-violation.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs?ref=fced2b1200bdc307ff128308b3088939b6c94e18", "patch": "@@ -0,0 +1,17 @@\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning either argument CANNOT be upcast to one\n+// that returns always its first argument.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> fn(&'static u32) -> &'static u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: fn(_) -> _ = make_it();\n+    let b: fn(&u32) -> &u32 = a;\n+    drop(a);\n+}"}, {"sha": "9de885f6aae01778753f28b9d0fe8f4b0ee85f8e", "filename": "src/test/ui/nll/relate_tys/universe-violation.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fced2b1200bdc307ff128308b3088939b6c94e18/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr?ref=fced2b1200bdc307ff128308b3088939b6c94e18", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/universe-violation.rs:14:9\n+   |\n+LL |     let a: fn(_) -> _ = make_it();\n+   |         ^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/universe-violation.rs:15:9\n+   |\n+LL |     let b: fn(&u32) -> &u32 = a;\n+   |         ^\n+\n+error: aborting due to 2 previous errors\n+"}]}