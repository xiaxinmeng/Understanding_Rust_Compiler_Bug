{"sha": "2d8d559bbecf6272eb41f8a800e319238aa9d621", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOGQ1NTliYmVjZjYyNzJlYjQxZjhhODAwZTMxOTIzOGFhOWQ2MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-10T02:09:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-10T02:09:41Z"}, "message": "Auto merge of #68078 - Centril:rollup-qvq052k, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #66463 (Point at opaque and closure type definitions in type errors)\n - #67501 (Reduce special treatment for zsts)\n - #67820 (Parse the syntax described in RFC 2632)\n - #67922 (rustc_ast_lowering: misc cleanup & rustc dep reductions)\n - #68071 (Extend support of `_` in type parameters)\n - #68073 (expect `fn` after `const unsafe` / `const extern`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c714e372e75f080c46ed07608912aa7df4211f9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c714e372e75f080c46ed07608912aa7df4211f9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d8d559bbecf6272eb41f8a800e319238aa9d621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8d559bbecf6272eb41f8a800e319238aa9d621", "html_url": "https://github.com/rust-lang/rust/commit/2d8d559bbecf6272eb41f8a800e319238aa9d621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d8d559bbecf6272eb41f8a800e319238aa9d621/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72b2bd55edbb1e63a930c5ddd08b25e4f9044786", "url": "https://api.github.com/repos/rust-lang/rust/commits/72b2bd55edbb1e63a930c5ddd08b25e4f9044786", "html_url": "https://github.com/rust-lang/rust/commit/72b2bd55edbb1e63a930c5ddd08b25e4f9044786"}, {"sha": "6f3f1c537b18f95bd4ea42700a1776334b165984", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3f1c537b18f95bd4ea42700a1776334b165984", "html_url": "https://github.com/rust-lang/rust/commit/6f3f1c537b18f95bd4ea42700a1776334b165984"}], "stats": {"total": 3110, "additions": 2072, "deletions": 1038}, "files": [{"sha": "012900f8af51b1ec19e6a094c226feb01d23582f", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, BoundVar, Ty, TyCtxt};\n-use crate::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;"}, {"sha": "5e5f39e6c7a22c1512104ddb1ab2f64df5c19f45", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 139, "deletions": 5, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -68,9 +68,12 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n \n-use errors::{struct_span_err, Applicability, DiagnosticBuilder, DiagnosticStyledString};\n+use errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticStyledString,\n+};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_error_codes::*;\n-use rustc_span::{Pos, Span};\n+use rustc_span::{DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::{cmp, fmt};\n \n@@ -1289,6 +1292,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         mut values: Option<ValuePairs<'tcx>>,\n         terr: &TypeError<'tcx>,\n     ) {\n+        let span = cause.span(self.tcx);\n+\n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n         match terr {\n@@ -1298,6 +1303,100 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => {}\n         }\n \n+        struct OpaqueTypesVisitor<'tcx> {\n+            types: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            found: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            ignore_span: Span,\n+            tcx: TyCtxt<'tcx>,\n+        }\n+\n+        impl<'tcx> OpaqueTypesVisitor<'tcx> {\n+            fn visit_expected_found(\n+                tcx: TyCtxt<'tcx>,\n+                expected: Ty<'tcx>,\n+                found: Ty<'tcx>,\n+                ignore_span: Span,\n+            ) -> Self {\n+                let mut types_visitor = OpaqueTypesVisitor {\n+                    types: Default::default(),\n+                    expected: Default::default(),\n+                    found: Default::default(),\n+                    ignore_span,\n+                    tcx,\n+                };\n+                // The visitor puts all the relevant encountered types in `self.types`, but in\n+                // here we want to visit two separate types with no relation to each other, so we\n+                // move the results from `types` to `expected` or `found` as appropriate.\n+                expected.visit_with(&mut types_visitor);\n+                std::mem::swap(&mut types_visitor.expected, &mut types_visitor.types);\n+                found.visit_with(&mut types_visitor);\n+                std::mem::swap(&mut types_visitor.found, &mut types_visitor.types);\n+                types_visitor\n+            }\n+\n+            fn report(&self, err: &mut DiagnosticBuilder<'_>) {\n+                self.add_labels_for_types(err, \"expected\", &self.expected);\n+                self.add_labels_for_types(err, \"found\", &self.found);\n+            }\n+\n+            fn add_labels_for_types(\n+                &self,\n+                err: &mut DiagnosticBuilder<'_>,\n+                target: &str,\n+                types: &FxHashMap<TyCategory, FxHashSet<Span>>,\n+            ) {\n+                for (key, values) in types.iter() {\n+                    let count = values.len();\n+                    let kind = key.descr();\n+                    for sp in values {\n+                        err.span_label(\n+                            *sp,\n+                            format!(\n+                                \"{}{}{} {}{}\",\n+                                if sp.is_desugaring(DesugaringKind::Async) {\n+                                    \"the `Output` of this `async fn`'s \"\n+                                } else if count == 1 {\n+                                    \"the \"\n+                                } else {\n+                                    \"\"\n+                                },\n+                                if count > 1 { \"one of the \" } else { \"\" },\n+                                target,\n+                                kind,\n+                                pluralize!(count),\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n+                    let span = self.tcx.def_span(def_id);\n+                    // Avoid cluttering the output when the \"found\" and error span overlap:\n+                    //\n+                    // error[E0308]: mismatched types\n+                    //   --> $DIR/issue-20862.rs:2:5\n+                    //    |\n+                    // LL |     |y| x + y\n+                    //    |     ^^^^^^^^^\n+                    //    |     |\n+                    //    |     the found closure\n+                    //    |     expected `()`, found closure\n+                    //    |\n+                    //    = note: expected unit type `()`\n+                    //                 found closure `[closure@$DIR/issue-20862.rs:2:5: 2:14 x:_]`\n+                    if !self.ignore_span.overlaps(span) {\n+                        self.types.entry(kind).or_default().insert(span);\n+                    }\n+                }\n+                t.super_visit_with(self)\n+            }\n+        }\n+\n         debug!(\"note_type_err(diag={:?})\", diag);\n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n@@ -1306,6 +1405,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ValuePairs::Types(exp_found) => {\n                         let is_simple_err =\n                             exp_found.expected.is_simple_text() && exp_found.found.is_simple_text();\n+                        OpaqueTypesVisitor::visit_expected_found(\n+                            self.tcx,\n+                            exp_found.expected,\n+                            exp_found.found,\n+                            span,\n+                        )\n+                        .report(diag);\n \n                         (is_simple_err, Some(exp_found))\n                     }\n@@ -1323,8 +1429,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let span = cause.span(self.tcx);\n-\n         // Ignore msg for object safe coercion\n         // since E0038 message will be printed\n         match terr {\n@@ -1336,7 +1440,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n-\n         if let Some((expected, found)) = expected_found {\n             let expected_label = exp_found.map_or(\"type\".into(), |ef| ef.expected.prefix_string());\n             let found_label = exp_found.map_or(\"type\".into(), |ef| ef.found.prefix_string());\n@@ -1933,3 +2036,34 @@ impl<'tcx> ObligationCause<'tcx> {\n         }\n     }\n }\n+\n+/// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n+/// extra information about each type, but we only care about the category.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+crate enum TyCategory {\n+    Closure,\n+    Opaque,\n+    Generator,\n+    Foreign,\n+}\n+\n+impl TyCategory {\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::Closure => \"closure\",\n+            Self::Opaque => \"opaque type\",\n+            Self::Generator => \"generator\",\n+            Self::Foreign => \"foreign type\",\n+        }\n+    }\n+\n+    pub fn from_ty(ty: Ty<'_>) -> Option<(Self, DefId)> {\n+        match ty.kind {\n+            ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n+            ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n+            ty::Generator(def_id, ..) => Some((Self::Generator, def_id)),\n+            ty::Foreign(def_id) => Some((Self::Foreign, def_id)),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "8ee8482e79dbc3f1b216cc79bdb161277e7e2831", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "cf424ffe7b2930f2dbf8029a8babcad37682ae62", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -100,7 +100,6 @@ pub mod ty;\n \n pub mod util {\n     pub mod bug;\n-    pub mod captures;\n     pub mod common;\n }\n "}, {"sha": "5b1e7673629b192fefb1c6cf5a01b331f253474b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -5,8 +5,8 @@\n use crate::hir::map as hir_map;\n use crate::hir::map::definitions::{DefKey, DefPathTable};\n use crate::session::search_paths::PathKind;\n-use crate::session::{CrateDisambiguator, Session};\n-use crate::ty::{self, TyCtxt};\n+use crate::session::CrateDisambiguator;\n+use crate::ty::TyCtxt;\n \n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, MetadataRef};\n@@ -208,7 +208,6 @@ pub trait CrateStore {\n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n-    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that."}, {"sha": "b9bb68798e588fa0321eb43daeb921410bf64082", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -6,7 +6,7 @@ use super::{\n     TraitNotObjectSafe,\n };\n \n-use crate::infer::error_reporting::TypeAnnotationNeeded as ErrorCode;\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt};\n use crate::mir::interpret::ErrorHandled;\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 flags.push((sym::from_method, Some(method.to_string())));\n             }\n         }\n-        if let Some(t) = self.get_parent_trait_ref(&obligation.cause.code) {\n+        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n             flags.push((sym::parent_trait, Some(t)));\n         }\n \n@@ -665,13 +665,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Gets the parent trait chain start\n-    fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n                 let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n-                    None => Some(parent_trait_ref.skip_binder().self_ty().to_string()),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n                 }\n             }\n             _ => None,\n@@ -719,9 +727,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             return;\n                         }\n                         let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        let (post_message, pre_message) = self\n+                        let (post_message, pre_message, type_def) = self\n                             .get_parent_trait_ref(&obligation.cause.code)\n-                            .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n                             .unwrap_or_default();\n \n                         let OnUnimplementedNote { message, label, note, enclosing_scope } =\n@@ -795,6 +809,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         } else {\n                             err.span_label(span, explanation);\n                         }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n                         if let Some(ref s) = note {\n                             // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n                             err.note(s.as_str());"}, {"sha": "738bbd936fea437c04ce67b2fac5cb29efde3a79", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -17,7 +17,6 @@ use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n-use crate::util::common::FN_OUTPUT_NAME;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n@@ -1364,7 +1363,7 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n         projection_ty: ty::ProjectionTy::from_ref_and_name(\n             tcx,\n             trait_ref,\n-            Ident::with_dummy_span(FN_OUTPUT_NAME),\n+            Ident::with_dummy_span(rustc_hir::FN_OUTPUT_NAME),\n         ),\n         ty: ret_type,\n     });"}, {"sha": "d1e37a4ea1151f09e8a1dc01e9d2c71ae784fc03", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -26,8 +26,8 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use crate::ty::walk::TypeWalker;\n-use crate::util::captures::Captures;\n use arena::SyncDroplessArena;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};"}, {"sha": "c89d045cebb739f7dda8e68f67a5fac6e79478e3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -13,11 +13,10 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable};\n use crate::ty::{List, ParamEnv, ParamEnvAnd, TyS};\n-use crate::util::captures::Captures;\n+use polonius_engine::Atom;\n+use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-\n-use polonius_engine::Atom;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Symbol};"}, {"sha": "9324b26a09b6f35071b1ee582d0714933457986a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -5,14 +5,9 @@ use rustc_data_structures::sync::Lock;\n use std::fmt::Debug;\n use std::time::{Duration, Instant};\n \n-use rustc_span::symbol::{sym, Symbol};\n-\n #[cfg(test)]\n mod tests;\n \n-// The name of the associated type for `Fn` return types.\n-pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n-\n pub use errors::ErrorReported;\n \n pub fn to_readable_str(mut val: usize) -> String {"}, {"sha": "beb53a19ac4ffae7bdbcb5e1be8111656b919dfa", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -25,19 +25,16 @@ pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n \n-impl<'a, 'lowering, 'hir> ItemLowerer<'a, 'lowering, 'hir> {\n-    fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n+impl ItemLowerer<'_, '_, '_> {\n+    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n         let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = if let &None = trait_impl_ref { false } else { true };\n+        self.lctx.is_in_trait_impl = if let &None = impl_ref { false } else { true };\n         f(self);\n         self.lctx.is_in_trait_impl = old;\n     }\n }\n \n-impl<'a, 'lowering, 'hir> Visitor<'a> for ItemLowerer<'a, 'lowering, 'hir> {\n+impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n         let hir_id = self.lctx.lower_node_id(n);\n \n@@ -71,6 +68,12 @@ impl<'a, 'lowering, 'hir> Visitor<'a> for ItemLowerer<'a, 'lowering, 'hir> {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n                 if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.kind {\n+                    if opt_trait_ref.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n+                        this.lctx\n+                            .diagnostic()\n+                            .span_err(item.span, \"const trait impls are not yet implemented\");\n+                    }\n+\n                     this.with_trait_impl_ref(opt_trait_ref, |this| visit::walk_item(this, item));\n                 } else {\n                     visit::walk_item(this, item);"}, {"sha": "527aa6796bc22269185aa885e8b1a8dae675315b", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 40, "deletions": 711, "changes": 751, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Lowers the AST to the HIR.\n //!\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n@@ -33,21 +31,20 @@\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(array_value_iter)]\n+#![feature(crate_visibility_modifier)]\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir::map::definitions::{DefKey, DefPathData, Definitions};\n use rustc::hir::map::Map;\n use rustc::lint;\n-use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n-use rustc::middle::cstore::CrateStore;\n-use rustc::util::captures::Captures;\n-use rustc::util::common::FN_OUTPUT_NAME;\n+use rustc::lint::builtin;\n use rustc::{bug, span_bug};\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_error_codes::*;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, DefIndex, CRATE_DEF_INDEX};\n@@ -58,14 +55,13 @@ use rustc_session::config::nightly_options;\n use rustc_session::node_id::NodeMap;\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::print::pprust;\n-use syntax::ptr::P as AstP;\n use syntax::sess::ParseSess;\n use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -86,6 +82,8 @@ macro_rules! arena_vec {\n \n mod expr;\n mod item;\n+mod pat;\n+mod path;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -173,7 +171,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n }\n \n pub trait Resolver {\n-    fn cstore(&self) -> &dyn CrateStore;\n+    fn def_key(&mut self, id: DefId) -> DefKey;\n+\n+    fn item_generics_num_lifetimes(&self, def: DefId, sess: &Session) -> usize;\n \n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n@@ -433,18 +433,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n             }\n \n-            fn with_hir_id_owner<F, T>(&mut self, owner: Option<NodeId>, f: F) -> T\n-            where\n-                F: FnOnce(&mut Self) -> T,\n-            {\n+            fn with_hir_id_owner<T>(\n+                &mut self,\n+                owner: Option<NodeId>,\n+                f: impl FnOnce(&mut Self) -> T,\n+            ) -> T {\n                 let old = mem::replace(&mut self.hir_id_owner, owner);\n                 let r = f(self);\n                 self.hir_id_owner = old;\n                 r\n             }\n         }\n \n-        impl<'tcx, 'lowering, 'hir> Visitor<'tcx> for MiscCollector<'tcx, 'lowering, 'hir> {\n+        impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n                 if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n                     // Doesn't generate a HIR node\n@@ -577,10 +578,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         lowered\n     }\n \n-    fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> hir::HirId\n-    where\n-        F: FnOnce(&mut Self) -> hir::HirId,\n-    {\n+    fn lower_node_id_generic(\n+        &mut self,\n+        ast_node_id: NodeId,\n+        alloc_hir_id: impl FnOnce(&mut Self) -> hir::HirId,\n+    ) -> hir::HirId {\n         if ast_node_id == DUMMY_NODE_ID {\n             return hir::DUMMY_HIR_ID;\n         }\n@@ -604,10 +606,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn with_hir_id_owner<F, T>(&mut self, owner: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_hir_id_owner<T>(&mut self, owner: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let counter = self\n             .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n@@ -736,15 +735,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n     /// parameter while `f` is running (and restored afterwards).\n-    fn collect_in_band_defs<T, F>(\n+    fn collect_in_band_defs<T>(\n         &mut self,\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: F,\n-    ) -> (Vec<hir::GenericParam<'hir>>, T)\n-    where\n-        F: FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n-    {\n+        f: impl FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n+    ) -> (Vec<hir::GenericParam<'hir>>, T) {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n@@ -847,10 +843,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // This is used to track which lifetimes have already been defined, and\n     // which are new in-band lifetimes that need to have a definition created\n     // for them.\n-    fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &[GenericParam], f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_in_scope_lifetime_defs<T>(\n+        &mut self,\n+        params: &[GenericParam],\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n@@ -870,16 +867,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n     /// parameter while `f` is running (and restored afterwards).\n-    fn add_in_band_defs<F, T>(\n+    fn add_in_band_defs<T>(\n         &mut self,\n         generics: &Generics,\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        f: F,\n-    ) -> (hir::Generics<'hir>, T)\n-    where\n-        F: FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n-    {\n+        f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n+    ) -> (hir::Generics<'hir>, T) {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n@@ -917,10 +911,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (lowered_generics, res)\n     }\n \n-    fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n \n@@ -931,10 +922,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         result\n     }\n \n-    fn with_new_scopes<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n+    fn with_new_scopes<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n@@ -949,14 +937,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn def_key(&mut self, id: DefId) -> DefKey {\n-        if id.is_local() {\n-            self.resolver.definitions().def_key(id.index)\n-        } else {\n-            self.resolver.cstore().def_key(id)\n-        }\n-    }\n-\n     fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n         self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n     }\n@@ -1635,403 +1615,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_qpath(\n-        &mut self,\n-        id: NodeId,\n-        qself: &Option<QSelf>,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::QPath<'hir> {\n-        let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n-\n-        let partial_res =\n-            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n-\n-        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n-        let path = self.arena.alloc(hir::Path {\n-            res: self.lower_res(partial_res.base_res()),\n-            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n-                |(i, segment)| {\n-                    let param_mode = match (qself_position, param_mode) {\n-                        (Some(j), ParamMode::Optional) if i < j => {\n-                            // This segment is part of the trait path in a\n-                            // qualified path - one of `a`, `b` or `Trait`\n-                            // in `<X as a::b::Trait>::T::U::method`.\n-                            ParamMode::Explicit\n-                        }\n-                        _ => param_mode,\n-                    };\n-\n-                    // Figure out if this is a type/trait segment,\n-                    // which may need lifetime elision performed.\n-                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n-                        krate: def_id.krate,\n-                        index: this.def_key(def_id).parent.expect(\"missing parent\"),\n-                    };\n-                    let type_def_id = match partial_res.base_res() {\n-                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Struct, def_id)\n-                        | Res::Def(DefKind::Union, def_id)\n-                        | Res::Def(DefKind::Enum, def_id)\n-                        | Res::Def(DefKind::TyAlias, def_id)\n-                        | Res::Def(DefKind::Trait, def_id)\n-                            if i + 1 == proj_start =>\n-                        {\n-                            Some(def_id)\n-                        }\n-                        _ => None,\n-                    };\n-                    let parenthesized_generic_args = match partial_res.base_res() {\n-                        // `a::b::Trait(Args)`\n-                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // `a::b::Trait(Args)::TraitItem`\n-                        Res::Def(DefKind::Method, _)\n-                        | Res::Def(DefKind::AssocConst, _)\n-                        | Res::Def(DefKind::AssocTy, _)\n-                            if i + 2 == proj_start =>\n-                        {\n-                            ParenthesizedGenericArgs::Ok\n-                        }\n-                        // Avoid duplicated errors.\n-                        Res::Err => ParenthesizedGenericArgs::Ok,\n-                        // An error\n-                        _ => ParenthesizedGenericArgs::Err,\n-                    };\n-\n-                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n-                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n-                            return n;\n-                        }\n-                        assert!(!def_id.is_local());\n-                        let item_generics = self\n-                            .resolver\n-                            .cstore()\n-                            .item_generics_cloned_untracked(def_id, self.sess);\n-                        let n = item_generics.own_counts().lifetimes;\n-                        self.type_def_lifetime_params.insert(def_id, n);\n-                        n\n-                    });\n-                    self.lower_path_segment(\n-                        p.span,\n-                        segment,\n-                        param_mode,\n-                        num_lifetimes,\n-                        parenthesized_generic_args,\n-                        itctx.reborrow(),\n-                        None,\n-                    )\n-                },\n-            )),\n-            span: p.span,\n-        });\n-\n-        // Simple case, either no projections, or only fully-qualified.\n-        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if partial_res.unresolved_segments() == 0 {\n-            return hir::QPath::Resolved(qself, path);\n-        }\n-\n-        // Create the innermost type that we're projecting from.\n-        let mut ty = if path.segments.is_empty() {\n-            // If the base path is empty that means there exists a\n-            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n-            qself.expect(\"missing QSelf for <T>::...\")\n-        } else {\n-            // Otherwise, the base path is an implicit `Self` type path,\n-            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n-            // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n-            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n-        };\n-\n-        // Anything after the base path are associated \"extensions\",\n-        // out of which all but the last one are associated types,\n-        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n-        // * base path is `std::vec::Vec<T>`\n-        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n-        // * type nodes are:\n-        //   1. `std::vec::Vec<T>` (created above)\n-        //   2. `<std::vec::Vec<T>>::IntoIter`\n-        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n-        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n-        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = self.arena.alloc(self.lower_path_segment(\n-                p.span,\n-                segment,\n-                param_mode,\n-                0,\n-                ParenthesizedGenericArgs::Err,\n-                itctx.reborrow(),\n-                None,\n-            ));\n-            let qpath = hir::QPath::TypeRelative(ty, segment);\n-\n-            // It's finished, return the extension of the right node type.\n-            if i == p.segments.len() - 1 {\n-                return qpath;\n-            }\n-\n-            // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n-            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n-        }\n-\n-        // We should've returned in the for loop above.\n-        span_bug!(\n-            p.span,\n-            \"lower_qpath: no final extension segment in {}..{}\",\n-            proj_start,\n-            p.segments.len()\n-        )\n-    }\n-\n-    fn lower_path_extra(\n-        &mut self,\n-        res: Res,\n-        p: &Path,\n-        param_mode: ParamMode,\n-        explicit_owner: Option<NodeId>,\n-    ) -> &'hir hir::Path<'hir> {\n-        self.arena.alloc(hir::Path {\n-            res,\n-            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n-                self.lower_path_segment(\n-                    p.span,\n-                    segment,\n-                    param_mode,\n-                    0,\n-                    ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::disallowed(),\n-                    explicit_owner,\n-                )\n-            })),\n-            span: p.span,\n-        })\n-    }\n-\n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> &'hir hir::Path<'hir> {\n-        let res = self.expect_full_res(id);\n-        let res = self.lower_res(res);\n-        self.lower_path_extra(res, p, param_mode, None)\n-    }\n-\n-    fn lower_path_segment(\n-        &mut self,\n-        path_span: Span,\n-        segment: &PathSegment,\n-        param_mode: ParamMode,\n-        expected_lifetimes: usize,\n-        parenthesized_generic_args: ParenthesizedGenericArgs,\n-        itctx: ImplTraitContext<'_, 'hir>,\n-        explicit_owner: Option<NodeId>,\n-    ) -> hir::PathSegment<'hir> {\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n-                }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n-                    ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n-                            // Do not suggest going from `Trait()` to `Trait<>`\n-                            if data.inputs.len() > 0 {\n-                                if let Some(split) = snippet.find('(') {\n-                                    let trait_name = &snippet[0..split];\n-                                    let args = &snippet[split + 1..snippet.len() - 1];\n-                                    err.span_suggestion(\n-                                        data.span,\n-                                        \"use angle brackets instead\",\n-                                        format!(\"{}<{}>\", trait_name, args),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        };\n-                        err.emit();\n-                        (\n-                            self.lower_angle_bracketed_parameter_data(\n-                                &data.as_angle_bracketed_args(),\n-                                param_mode,\n-                                itctx,\n-                            )\n-                            .0,\n-                            false,\n-                        )\n-                    }\n-                },\n-            }\n-        } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n-        };\n-\n-        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n-            GenericArg::Lifetime(_) => true,\n-            _ => false,\n-        });\n-        let first_generic_span = generic_args\n-            .args\n-            .iter()\n-            .map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span))\n-            .next();\n-        if !generic_args.parenthesized && !has_lifetimes {\n-            generic_args.args = self\n-                .elided_path_lifetimes(path_span, expected_lifetimes)\n-                .map(|lt| GenericArg::Lifetime(lt))\n-                .chain(generic_args.args.into_iter())\n-                .collect();\n-            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n-                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n-                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n-                let no_bindings = generic_args.bindings.is_empty();\n-                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated type\n-                    // bindings, our suggestion includes the angle brackets.\n-                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n-                } else {\n-                    // Otherwise (sorry, this is kind of gross) we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist.\n-                    let first_generic_span = first_generic_span\n-                        .expect(\"already checked that non-lifetime args or bindings exist\");\n-                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n-                };\n-                match self.anonymous_lifetime_mode {\n-                    // In create-parameter mode we error here because we don't want to support\n-                    // deprecated impl elision in new features like impl elision and `async fn`,\n-                    // both of which work using the `CreateParameter` mode:\n-                    //\n-                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    AnonymousLifetimeMode::CreateParameter => {\n-                        let mut err = struct_span_err!(\n-                            self.sess,\n-                            path_span,\n-                            E0726,\n-                            \"implicit elided lifetime not allowed here\"\n-                        );\n-                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n-                            &self.sess,\n-                            &mut err,\n-                            expected_lifetimes,\n-                            path_span,\n-                            incl_angl_brckt,\n-                            insertion_sp,\n-                            suggestion,\n-                        );\n-                        err.emit();\n-                    }\n-                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n-                            ELIDED_LIFETIMES_IN_PATHS,\n-                            CRATE_NODE_ID,\n-                            path_span,\n-                            \"hidden lifetime parameters in types are deprecated\",\n-                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                                expected_lifetimes,\n-                                path_span,\n-                                incl_angl_brckt,\n-                                insertion_sp,\n-                                suggestion,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        let res = self.expect_full_res(segment.id);\n-        let id = if let Some(owner) = explicit_owner {\n-            self.lower_node_id_with_owner(segment.id, owner)\n-        } else {\n-            self.lower_node_id(segment.id)\n-        };\n-        debug!(\n-            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n-            segment.ident, segment.id, id,\n-        );\n-\n-        hir::PathSegment {\n-            ident: segment.ident,\n-            hir_id: Some(id),\n-            res: Some(self.lower_res(res)),\n-            infer_args,\n-            args: if generic_args.is_empty() {\n-                None\n-            } else {\n-                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n-            },\n-        }\n-    }\n-\n-    fn lower_angle_bracketed_parameter_data(\n-        &mut self,\n-        data: &AngleBracketedArgs,\n-        param_mode: ParamMode,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n-        let has_non_lt_args = args.iter().any(|arg| match arg {\n-            ast::GenericArg::Lifetime(_) => false,\n-            ast::GenericArg::Type(_) => true,\n-            ast::GenericArg::Const(_) => true,\n-        });\n-        (\n-            GenericArgsCtor {\n-                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: self.arena.alloc_from_iter(\n-                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n-                ),\n-                parenthesized: false,\n-            },\n-            !has_non_lt_args && param_mode == ParamMode::Optional,\n-        )\n-    }\n-\n-    fn lower_parenthesized_parameter_data(\n-        &mut self,\n-        data: &ParenthesizedArgs,\n-    ) -> (GenericArgsCtor<'hir>, bool) {\n-        // Switch to `PassThrough` mode for anonymous lifetimes; this\n-        // means that we permit things like `&Ref<T>`, where `Ref` has\n-        // a hidden lifetime parameter. This is needed for backwards\n-        // compatibility, even in contexts like an impl header where\n-        // we generally don't permit such things (see #51008).\n-        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n-            let inputs = this.arena.alloc_from_iter(\n-                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n-            );\n-            let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n-                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n-            let binding = hir::TypeBinding {\n-                hir_id: this.next_id(),\n-                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                span: output_ty.span,\n-                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-            };\n-            (\n-                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n-                false,\n-            )\n-        })\n-    }\n-\n     fn lower_local(&mut self, l: &Local) -> (hir::Local<'hir>, SmallVec<[NodeId; 1]>) {\n         let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -2387,12 +1970,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // \"<Output = T>\"\n         let future_params = self.arena.alloc(hir::GenericArgs {\n             args: &[],\n-            bindings: arena_vec![self; hir::TypeBinding {\n-                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                kind: hir::TypeBindingKind::Equality { ty: output_ty },\n-                hir_id: self.next_id(),\n-                span,\n-            }],\n+            bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n         });\n \n@@ -2579,6 +2157,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n+        if p.trait_ref.constness.is_some() {\n+            self.diagnostic().span_err(p.span, \"`?const` on trait bounds is not yet implemented\");\n+        }\n+\n         let bound_generic_params = self.lower_generic_params(\n             &p.bound_generic_params,\n             &NodeMap::default(),\n@@ -2648,250 +2230,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        let node = match p.kind {\n-            PatKind::Wild => hir::PatKind::Wild,\n-            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                node\n-            }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-            PatKind::TupleStruct(ref path, ref pats) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-            }\n-            PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n-            }\n-            PatKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::PatKind::Path(qpath)\n-            }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                let qpath = self.lower_qpath(\n-                    p.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-\n-                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                    hir_id: self.next_id(),\n-                    ident: f.ident,\n-                    pat: self.lower_pat(&f.pat),\n-                    is_shorthand: f.is_shorthand,\n-                    span: f.span,\n-                }));\n-                hir::PatKind::Struct(qpath, fs, etc)\n-            }\n-            PatKind::Tuple(ref pats) => {\n-                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                hir::PatKind::Tuple(pats, ddpos)\n-            }\n-            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                self.lower_expr(e1),\n-                self.lower_expr(e2),\n-                self.lower_range_end(end),\n-            ),\n-            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-            PatKind::Rest => {\n-                // If we reach here the `..` pattern is not semantically allowed.\n-                self.ban_illegal_rest_pat(p.span)\n-            }\n-            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-        };\n-\n-        self.pat_with_node_id_of(p, node)\n-    }\n-\n-    fn lower_pat_tuple(\n-        &mut self,\n-        pats: &[AstP<Pat>],\n-        ctx: &str,\n-    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n-        let mut elems = Vec::with_capacity(pats.len());\n-        let mut rest = None;\n-\n-        let mut iter = pats.iter().enumerate();\n-        for (idx, pat) in iter.by_ref() {\n-            // Interpret the first `..` pattern as a sub-tuple pattern.\n-            // Note that unlike for slice patterns,\n-            // where `xs @ ..` is a legal sub-slice pattern,\n-            // it is not a legal sub-tuple pattern.\n-            if pat.is_rest() {\n-                rest = Some((idx, pat.span));\n-                break;\n-            }\n-            // It was not a sub-tuple pattern so lower it normally.\n-            elems.push(self.lower_pat(pat));\n-        }\n-\n-        for (_, pat) in iter {\n-            // There was a previous sub-tuple pattern; make sure we don't allow more...\n-            if pat.is_rest() {\n-                // ...but there was one again, so error.\n-                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n-            } else {\n-                elems.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n-    }\n-\n-    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n-    /// `hir::PatKind::Slice(before, slice, after)`.\n-    ///\n-    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n-    /// this is interpreted as a sub-slice pattern semantically.\n-    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n-    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind<'hir> {\n-        let mut before = Vec::new();\n-        let mut after = Vec::new();\n-        let mut slice = None;\n-        let mut prev_rest_span = None;\n-\n-        let mut iter = pats.iter();\n-        // Lower all the patterns until the first occurence of a sub-slice pattern.\n-        for pat in iter.by_ref() {\n-            match pat.kind {\n-                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n-                PatKind::Rest => {\n-                    prev_rest_span = Some(pat.span);\n-                    slice = Some(self.pat_wild_with_node_id_of(pat));\n-                    break;\n-                }\n-                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n-                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n-                    prev_rest_span = Some(sub.span);\n-                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n-                    slice = Some(self.pat_with_node_id_of(pat, node));\n-                    break;\n-                }\n-                // It was not a subslice pattern so lower it normally.\n-                _ => before.push(self.lower_pat(pat)),\n-            }\n-        }\n-\n-        // Lower all the patterns after the first sub-slice pattern.\n-        for pat in iter {\n-            // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n-                PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n-                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n-                    after.push(self.pat_wild_with_node_id_of(pat));\n-                    Some(sub.span)\n-                }\n-                _ => None,\n-            };\n-            if let Some(rest_span) = rest_span {\n-                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n-                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n-            } else {\n-                // Lower the pattern normally.\n-                after.push(self.lower_pat(pat));\n-            }\n-        }\n-\n-        hir::PatKind::Slice(\n-            self.arena.alloc_from_iter(before),\n-            slice,\n-            self.arena.alloc_from_iter(after),\n-        )\n-    }\n-\n-    fn lower_pat_ident(\n-        &mut self,\n-        p: &Pat,\n-        binding_mode: &BindingMode,\n-        ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n-    ) -> hir::PatKind<'hir> {\n-        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n-            // `None` can occur in body-less function signatures\n-            res @ None | res @ Some(Res::Local(_)) => {\n-                let canonical_id = match res {\n-                    Some(Res::Local(id)) => id,\n-                    _ => p.id,\n-                };\n-\n-                hir::PatKind::Binding(\n-                    self.lower_binding_mode(binding_mode),\n-                    self.lower_node_id(canonical_id),\n-                    ident,\n-                    lower_sub(self),\n-                )\n-            }\n-            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                None,\n-                self.arena.alloc(hir::Path {\n-                    span: ident.span,\n-                    res: self.lower_res(res),\n-                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n-                }),\n-            )),\n-        }\n-    }\n-\n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n-        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n-    }\n-\n-    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n-    }\n-\n-    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n-    }\n-\n-    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n-    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n-\n-        // We're not in a list context so `..` can be reasonably treated\n-        // as `_` because it should always be valid and roughly matches the\n-        // intent of `..` (notice that the rest of a single slot is that slot).\n-        hir::PatKind::Wild\n-    }\n-\n-    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n-        match *e {\n-            RangeEnd::Included(_) => hir::RangeEnd::Included,\n-            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n-        }\n-    }\n-\n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n         self.with_new_scopes(|this| hir::AnonConst {\n             hir_id: this.lower_node_id(c.id),\n@@ -2951,15 +2289,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n-        match *b {\n-            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n-        }\n-    }\n-\n     fn lower_unsafe_source(&mut self, u: UnsafeSource) -> hir::UnsafeSource {\n         match u {\n             CompilerGenerated => hir::UnsafeSource::CompilerGenerated,"}, {"sha": "cd69646d0c53ae57e9d7ec023fa53da53b8541fe", "filename": "src/librustc_ast_lowering/pat.rs", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,262 @@\n+use super::{ImplTraitContext, LoweringContext, ParamMode};\n+\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_span::{source_map::Spanned, Span};\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        let node = match p.kind {\n+            PatKind::Wild => hir::PatKind::Wild,\n+            PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                node\n+            }\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+            PatKind::TupleStruct(ref path, ref pats) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n+            }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n+            }\n+            PatKind::Path(ref qself, ref path) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    qself,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                hir::PatKind::Path(qpath)\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                let qpath = self.lower_qpath(\n+                    p.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+\n+                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                    hir_id: self.next_id(),\n+                    ident: f.ident,\n+                    pat: self.lower_pat(&f.pat),\n+                    is_shorthand: f.is_shorthand,\n+                    span: f.span,\n+                }));\n+                hir::PatKind::Struct(qpath, fs, etc)\n+            }\n+            PatKind::Tuple(ref pats) => {\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                hir::PatKind::Tuple(pats, ddpos)\n+            }\n+            PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+            PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n+            PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n+                self.lower_expr(e1),\n+                self.lower_expr(e2),\n+                self.lower_range_end(end),\n+            ),\n+            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+            PatKind::Rest => {\n+                // If we reach here the `..` pattern is not semantically allowed.\n+                self.ban_illegal_rest_pat(p.span)\n+            }\n+            PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n+\n+        self.pat_with_node_id_of(p, node)\n+    }\n+\n+    fn lower_pat_tuple(\n+        &mut self,\n+        pats: &[P<Pat>],\n+        ctx: &str,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n+        let mut elems = Vec::with_capacity(pats.len());\n+        let mut rest = None;\n+\n+        let mut iter = pats.iter().enumerate();\n+        for (idx, pat) in iter.by_ref() {\n+            // Interpret the first `..` pattern as a sub-tuple pattern.\n+            // Note that unlike for slice patterns,\n+            // where `xs @ ..` is a legal sub-slice pattern,\n+            // it is not a legal sub-tuple pattern.\n+            if pat.is_rest() {\n+                rest = Some((idx, pat.span));\n+                break;\n+            }\n+            // It was not a sub-tuple pattern so lower it normally.\n+            elems.push(self.lower_pat(pat));\n+        }\n+\n+        for (_, pat) in iter {\n+            // There was a previous sub-tuple pattern; make sure we don't allow more...\n+            if pat.is_rest() {\n+                // ...but there was one again, so error.\n+                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n+            } else {\n+                elems.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n+    }\n+\n+    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n+    /// `hir::PatKind::Slice(before, slice, after)`.\n+    ///\n+    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n+    /// this is interpreted as a sub-slice pattern semantically.\n+    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n+    fn lower_pat_slice(&mut self, pats: &[P<Pat>]) -> hir::PatKind<'hir> {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        let mut iter = pats.iter();\n+        // Lower all the patterns until the first occurence of a sub-slice pattern.\n+        for pat in iter.by_ref() {\n+            match pat.kind {\n+                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_wild_with_node_id_of(pat));\n+                    break;\n+                }\n+                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n+                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n+                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    break;\n+                }\n+                // It was not a subslice pattern so lower it normally.\n+                _ => before.push(self.lower_pat(pat)),\n+            }\n+        }\n+\n+        // Lower all the patterns after the first sub-slice pattern.\n+        for pat in iter {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.kind {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n+                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n+                    after.push(self.pat_wild_with_node_id_of(pat));\n+                    Some(sub.span)\n+                }\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                // Lower the pattern normally.\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n+    ) -> hir::PatKind<'hir> {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ None | res @ Some(Res::Local(_)) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                self.arena.alloc(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n+        match *b {\n+            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n+        }\n+    }\n+\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    }\n+\n+    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n+    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+        self.diagnostic()\n+            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n+            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n+            .span_label(prev_sp, \"previously used here\")\n+            .emit();\n+    }\n+\n+    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n+        self.diagnostic()\n+            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n+            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n+            .emit();\n+\n+        // We're not in a list context so `..` can be reasonably treated\n+        // as `_` because it should always be valid and roughly matches the\n+        // intent of `..` (notice that the rest of a single slot is that slot).\n+        hir::PatKind::Wild\n+    }\n+\n+    fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n+        match *e {\n+            RangeEnd::Included(_) => hir::RangeEnd::Included,\n+            RangeEnd::Excluded => hir::RangeEnd::Excluded,\n+        }\n+    }\n+}"}, {"sha": "9b504704ae06ca6103d7535b63d39400fc8fdebd", "filename": "src/librustc_ast_lowering/path.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,422 @@\n+use super::{AnonymousLifetimeMode, ImplTraitContext, LoweringContext, ParamMode};\n+use super::{GenericArgsCtor, ParenthesizedGenericArgs};\n+\n+use rustc::lint::builtin::{self, ELIDED_LIFETIMES_IN_PATHS};\n+use rustc::span_bug;\n+use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, PartialRes, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::GenericArg;\n+use rustc_span::Span;\n+use syntax::ast::{self, *};\n+\n+use log::debug;\n+use smallvec::smallvec;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: &Option<QSelf>,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::QPath<'hir> {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n+\n+        let partial_res =\n+            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let path = self.arena.alloc(hir::Path {\n+            res: self.lower_res(partial_res.base_res()),\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n+                    let param_mode = match (qself_position, param_mode) {\n+                        (Some(j), ParamMode::Optional) if i < j => {\n+                            // This segment is part of the trait path in a\n+                            // qualified path - one of `a`, `b` or `Trait`\n+                            // in `<X as a::b::Trait>::T::U::method`.\n+                            ParamMode::Explicit\n+                        }\n+                        _ => param_mode,\n+                    };\n+\n+                    // Figure out if this is a type/trait segment,\n+                    // which may need lifetime elision performed.\n+                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n+                        krate: def_id.krate,\n+                        index: this.resolver.def_key(def_id).parent.expect(\"missing parent\"),\n+                    };\n+                    let type_def_id = match partial_res.base_res() {\n+                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Struct, def_id)\n+                        | Res::Def(DefKind::Union, def_id)\n+                        | Res::Def(DefKind::Enum, def_id)\n+                        | Res::Def(DefKind::TyAlias, def_id)\n+                        | Res::Def(DefKind::Trait, def_id)\n+                            if i + 1 == proj_start =>\n+                        {\n+                            Some(def_id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n+                        // `a::b::Trait(Args)`\n+                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // `a::b::Trait(Args)::TraitItem`\n+                        Res::Def(DefKind::Method, _)\n+                        | Res::Def(DefKind::AssocConst, _)\n+                        | Res::Def(DefKind::AssocTy, _)\n+                            if i + 2 == proj_start =>\n+                        {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // Avoid duplicated errors.\n+                        Res::Err => ParenthesizedGenericArgs::Ok,\n+                        // An error\n+                        _ => ParenthesizedGenericArgs::Err,\n+                    };\n+\n+                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                            return n;\n+                        }\n+                        assert!(!def_id.is_local());\n+                        let n = self.resolver.item_generics_num_lifetimes(def_id, self.sess);\n+                        self.type_def_lifetime_params.insert(def_id, n);\n+                        n\n+                    });\n+                    self.lower_path_segment(\n+                        p.span,\n+                        segment,\n+                        param_mode,\n+                        num_lifetimes,\n+                        parenthesized_generic_args,\n+                        itctx.reborrow(),\n+                        None,\n+                    )\n+                },\n+            )),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if partial_res.unresolved_segments() == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let new_id = self.next_id();\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = self.arena.alloc(self.lower_path_segment(\n+                p.span,\n+                segment,\n+                param_mode,\n+                0,\n+                ParenthesizedGenericArgs::Err,\n+                itctx.reborrow(),\n+                None,\n+            ));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            let new_id = self.next_id();\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n+        }\n+\n+        // We should've returned in the for loop above.\n+        span_bug!(\n+            p.span,\n+            \"lower_qpath: no final extension segment in {}..{}\",\n+            proj_start,\n+            p.segments.len()\n+        )\n+    }\n+\n+    crate fn lower_path_extra(\n+        &mut self,\n+        res: Res,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        explicit_owner: Option<NodeId>,\n+    ) -> &'hir hir::Path<'hir> {\n+        self.arena.alloc(hir::Path {\n+            res,\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n+            span: p.span,\n+        })\n+    }\n+\n+    crate fn lower_path(\n+        &mut self,\n+        id: NodeId,\n+        p: &Path,\n+        param_mode: ParamMode,\n+    ) -> &'hir hir::Path<'hir> {\n+        let res = self.expect_full_res(id);\n+        let res = self.lower_res(res);\n+        self.lower_path_extra(res, p, param_mode, None)\n+    }\n+\n+    crate fn lower_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        segment: &PathSegment,\n+        param_mode: ParamMode,\n+        expected_lifetimes: usize,\n+        parenthesized_generic_args: ParenthesizedGenericArgs,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::PathSegment<'hir> {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n+            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n+            match **generic_args {\n+                GenericArgs::AngleBracketed(ref data) => {\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n+                }\n+                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Err => {\n+                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n+                            // Do not suggest going from `Trait()` to `Trait<>`\n+                            if data.inputs.len() > 0 {\n+                                if let Some(split) = snippet.find('(') {\n+                                    let trait_name = &snippet[0..split];\n+                                    let args = &snippet[split + 1..snippet.len() - 1];\n+                                    err.span_suggestion(\n+                                        data.span,\n+                                        \"use angle brackets instead\",\n+                                        format!(\"{}<{}>\", trait_name, args),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        };\n+                        err.emit();\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx,\n+                            )\n+                            .0,\n+                            false,\n+                        )\n+                    }\n+                },\n+            }\n+        } else {\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+        };\n+\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        let first_generic_span = generic_args\n+            .args\n+            .iter()\n+            .map(|a| a.span())\n+            .chain(generic_args.bindings.iter().map(|b| b.span))\n+            .next();\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            generic_args.args = self\n+                .elided_path_lifetimes(path_span, expected_lifetimes)\n+                .map(|lt| GenericArg::Lifetime(lt))\n+                .chain(generic_args.args.into_iter())\n+                .collect();\n+            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n+                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n+                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n+                let no_bindings = generic_args.bindings.is_empty();\n+                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n+                    // If there are no (non-implicit) generic args or associated type\n+                    // bindings, our suggestion includes the angle brackets.\n+                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n+                } else {\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n+                    // place to splice in the `'_, ` from the generics that do exist.\n+                    let first_generic_span = first_generic_span\n+                        .expect(\"already checked that non-lifetime args or bindings exist\");\n+                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                };\n+                match self.anonymous_lifetime_mode {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess,\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            incl_angl_brckt,\n+                            insertion_sp,\n+                            suggestion,\n+                        );\n+                        err.emit();\n+                    }\n+                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n+                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n+                            ELIDED_LIFETIMES_IN_PATHS,\n+                            CRATE_NODE_ID,\n+                            path_span,\n+                            \"hidden lifetime parameters in types are deprecated\",\n+                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                                expected_lifetimes,\n+                                path_span,\n+                                incl_angl_brckt,\n+                                insertion_sp,\n+                                suggestion,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        let res = self.expect_full_res(segment.id);\n+        let id = if let Some(owner) = explicit_owner {\n+            self.lower_node_id_with_owner(segment.id, owner)\n+        } else {\n+            self.lower_node_id(segment.id)\n+        };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n+\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n+            infer_args,\n+            args: if generic_args.is_empty() {\n+                None\n+            } else {\n+                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n+            },\n+        }\n+    }\n+\n+    fn lower_angle_bracketed_parameter_data(\n+        &mut self,\n+        data: &AngleBracketedArgs,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n+        let has_non_lt_args = args.iter().any(|arg| match arg {\n+            ast::GenericArg::Lifetime(_) => false,\n+            ast::GenericArg::Type(_) => true,\n+            ast::GenericArg::Const(_) => true,\n+        });\n+        (\n+            GenericArgsCtor {\n+                args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n+                bindings: self.arena.alloc_from_iter(\n+                    constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n+                ),\n+                parenthesized: false,\n+            },\n+            !has_non_lt_args && param_mode == ParamMode::Optional,\n+        )\n+    }\n+\n+    fn lower_parenthesized_parameter_data(\n+        &mut self,\n+        data: &ParenthesizedArgs,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n+        // means that we permit things like `&Ref<T>`, where `Ref` has\n+        // a hidden lifetime parameter. This is needed for backwards\n+        // compatibility, even in contexts like an impl header where\n+        // we generally don't permit such things (see #51008).\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n+            };\n+            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let binding = this.output_ty_binding(output_ty.span, output_ty);\n+            (\n+                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n+        })\n+    }\n+\n+    /// An associated type binding `Output = $ty`.\n+    crate fn output_ty_binding(\n+        &mut self,\n+        span: Span,\n+        ty: &'hir hir::Ty<'hir>,\n+    ) -> hir::TypeBinding<'hir> {\n+        let ident = Ident::with_dummy_span(hir::FN_OUTPUT_NAME);\n+        let kind = hir::TypeBindingKind::Equality { ty };\n+        hir::TypeBinding { hir_id: self.next_id(), span, ident, kind }\n+    }\n+}"}, {"sha": "26b90ebfd5f117076cd4a99d4f1c772e0e1a8e5d", "filename": "src/librustc_data_structures/captures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_data_structures%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_data_structures%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcaptures.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "previous_filename": "src/librustc/util/captures.rs"}, {"sha": "51a38a7d2ab9ce84a82f0b37d5faf8034a2bbb5e", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -67,6 +67,7 @@ macro_rules! unlikely {\n pub mod base_n;\n pub mod binary_search_util;\n pub mod box_region;\n+pub mod captures;\n pub mod const_cstr;\n pub mod flock;\n pub mod fx;"}, {"sha": "bd3d6b589d00acfb210de183690e5f1f95fdae5d", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -110,7 +110,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n-        ast::TraitRef { path, ref_id: ast::DUMMY_NODE_ID }\n+        ast::TraitRef { path, constness: None, ref_id: ast::DUMMY_NODE_ID }\n     }\n \n     pub fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef {"}, {"sha": "6a15cc5cb0fceee67e147d867e5e619f343aeed4", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -544,6 +544,12 @@ declare_features! (\n     /// For example, you can write `x @ Some(y)`.\n     (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n \n+    /// Allows `impl const Trait for T` syntax.\n+    (active, const_trait_impl, \"1.42.0\", Some(67792), None),\n+\n+    /// Allows `T: ?const Trait` syntax in bounds.\n+    (active, const_trait_bound_opt_out, \"1.42.0\", Some(67794), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -559,4 +565,6 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::or_patterns,\n     sym::let_chains,\n     sym::raw_dylib,\n+    sym::const_trait_impl,\n+    sym::const_trait_bound_opt_out,\n ];"}, {"sha": "603c21188e3ac03173643cf5da5f18b91ce32330", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1875,6 +1875,9 @@ pub enum ImplItemKind<'hir> {\n     OpaqueTy(GenericBounds<'hir>),\n }\n \n+// The name of the associated type for `Fn` return types.\n+pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n+\n /// Bind a type to an associated type (i.e., `A = Foo`).\n ///\n /// Bindings like `A: Debug` are represented as a special type `A ="}, {"sha": "30d049d143eabc576d5ea4af9f3399bd36019565", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -12,8 +12,7 @@ use rustc::session::{CrateDisambiguator, Session};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::CrateNum;\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n "}, {"sha": "f5a05751f4c407aa08b383db883e53ca5ffb0505", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -16,8 +16,8 @@ use rustc::mir::{self, interpret, BodyAndCache, Promoted};\n use rustc::session::Session;\n use rustc::ty::codec::TyDecoder;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::captures::Captures;\n use rustc::util::common::record_time;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;"}, {"sha": "eb5754bf99bfbcec0f808bb05be51f5694b6119c", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -478,17 +478,17 @@ impl CStore {\n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n         self.get_crate_data(cnum).source.clone()\n     }\n+\n+    pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n+        self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n+    }\n }\n \n impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n \n-    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n-        self.get_crate_data(def.krate).get_generics(def.index, sess)\n-    }\n-\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name\n     }"}, {"sha": "53f3b539bdaa0bdaea73174cbd29c8a8e71ac5ff", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -115,28 +115,31 @@ pub(super) fn op_to_const<'tcx>(\n         // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace()\n+        op.try_as_mplace(ecx)\n     };\n-    let val = match immediate {\n-        Ok(mplace) => {\n-            let ptr = mplace.ptr.assert_ptr();\n+\n+    let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n+        Scalar::Ptr(ptr) => {\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n+        Scalar::Raw { data, .. } => {\n+            assert!(mplace.layout.is_zst());\n+            assert_eq!(\n+                data,\n+                mplace.layout.align.abi.bytes().into(),\n+                \"this MPlaceTy must come from `try_as_mplace` being used on a zst, so we know what\n+                 value this integer address must have\",\n+            );\n+            ConstValue::Scalar(Scalar::zst())\n+        }\n+    };\n+    let val = match immediate {\n+        Ok(mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n             ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => {\n-                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n-                // argument and we will not need this. The only way we can already have an\n-                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n-                // comes from a constant so it can happen have `Undef`, because the indirect\n-                // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.assert_ptr();\n-                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { alloc, offset: ptr.offset }\n-            }\n+            ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {"}, {"sha": "2bf1efd4441e90e99d79bea3a45f7f5fc69e6cf3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -229,6 +229,7 @@ use self::SliceKind::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n@@ -243,7 +244,6 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc::lint;\n use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc::mir::Field;\n-use rustc::util::captures::Captures;\n use rustc::util::common::ErrorReported;\n \n use rustc_span::{Span, DUMMY_SP};"}, {"sha": "864f4f9487c88597a1e497af8de6c7eac0c5e1e1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -20,7 +20,7 @@ use rustc_macros::HashStable;\n use rustc_span::source_map::{self, Span, DUMMY_SP};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, Memory, OpTy, Operand, Place, PlaceTy,\n+    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUndef, StackPopInfo,\n };\n \n@@ -393,7 +393,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n-        metadata: Option<Scalar<M::PointerTag>>,\n+        metadata: MemPlaceMeta<M::PointerTag>,\n         layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n         if !layout.is_unsized() {\n@@ -465,14 +465,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n+                let vtable = metadata.unwrap_meta();\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len =\n-                    metadata.expect(\"slice fat ptr must have length\").to_machine_usize(self)?;\n+                let len = metadata.unwrap_meta().to_machine_usize(self)?;\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n@@ -818,8 +817,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n-                                    Some(meta) => format!(\" meta({:?})\", meta),\n-                                    None => String::new(),\n+                                    MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n+                                    MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n                             )\n                             .unwrap();"}, {"sha": "9b3a2fa36f7947c7ecdd5252e78a61d7ab385de5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -193,7 +193,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n             {\n                 // Validation has already errored on an invalid vtable pointer so we can safely not\n                 // do anything if this is not a real pointer.\n-                if let Scalar::Ptr(vtable) = mplace.meta.unwrap() {\n+                if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose `Immutable` here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n@@ -226,7 +226,8 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n                     | (InternMode::Const, hir::Mutability::Mut) => match referenced_ty.kind {\n                         ty::Array(_, n)\n                             if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n-                        ty::Slice(_) if mplace.meta.unwrap().to_machine_usize(self.ecx)? == 0 => {}\n+                        ty::Slice(_)\n+                            if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)? == 0 => {}\n                         _ => bug!(\"const qualif failed to prevent mutable references\"),\n                     },\n                 }"}, {"sha": "2e8fbb95ca2e58d143982323811de6817f27d678", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -20,7 +20,7 @@ pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one pla\n \n pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n \n-pub use self::place::{MPlaceTy, MemPlace, Place, PlaceTy};\n+pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n \n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n "}, {"sha": "ddd9776e89383e485d406f8f8150d992e57483ad", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -153,30 +153,6 @@ pub enum Operand<Tag = (), Id = AllocId> {\n     Indirect(MemPlace<Tag, Id>),\n }\n \n-impl<Tag> Operand<Tag> {\n-    #[inline]\n-    pub fn assert_mem_place(self) -> MemPlace<Tag>\n-    where\n-        Tag: ::std::fmt::Debug,\n-    {\n-        match self {\n-            Operand::Indirect(mplace) => mplace,\n-            _ => bug!(\"assert_mem_place: expected Operand::Indirect, got {:?}\", self),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn assert_immediate(self) -> Immediate<Tag>\n-    where\n-        Tag: ::std::fmt::Debug,\n-    {\n-        match self {\n-            Operand::Immediate(imm) => imm,\n-            _ => bug!(\"assert_immediate: expected Operand::Immediate, got {:?}\", self),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct OpTy<'tcx, Tag = ()> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n@@ -267,7 +243,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        match op.try_as_mplace() {\n+        match op.try_as_mplace(self) {\n             Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n             Err(imm) => Ok(imm.into()), // Nothing to cast/force\n         }\n@@ -335,7 +311,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n-        Ok(match src.try_as_mplace() {\n+        Ok(match src.try_as_mplace(self) {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n@@ -383,7 +359,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n         field: u64,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base = match op.try_as_mplace() {\n+        let base = match op.try_as_mplace(self) {\n             Ok(mplace) => {\n                 // The easy case\n                 let field = self.mplace_field(mplace, field)?;\n@@ -420,7 +396,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        Ok(match op.try_as_mplace() {\n+        Ok(match op.try_as_mplace(self) {\n             Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n@@ -439,30 +415,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            ConstantIndex { .. } | Index(_) if base.layout.is_zst() => {\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    // the actual index doesn't matter, so we just pick a convenient one like 0\n-                    layout: base.layout.field(self, 0)?,\n-                }\n-            }\n-            Subslice { from, to, from_end } if base.layout.is_zst() => {\n-                let elem_ty = if let ty::Array(elem_ty, _) = base.layout.ty.kind {\n-                    elem_ty\n-                } else {\n-                    bug!(\"slices shouldn't be zero-sized\");\n-                };\n-                assert!(!from_end, \"arrays shouldn't be subsliced from the end\");\n-\n-                OpTy {\n-                    op: Operand::Immediate(Scalar::zst().into()),\n-                    layout: self.layout_of(self.tcx.mk_array(elem_ty, (to - from) as u64))?,\n-                }\n-            }\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.assert_mem_place();\n+                let mplace = base.assert_mem_place(self);\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }\n         })"}, {"sha": "890627a54543a5bb74b73d0542d0c1e1062ae495", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 100, "deletions": 55, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -20,6 +20,47 @@ use super::{\n     RawConst, Scalar, ScalarMaybeUndef,\n };\n \n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n+/// Information required for the sound usage of a `MemPlace`.\n+pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n+    /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n+    Meta(Scalar<Tag, Id>),\n+    /// `Sized` types or unsized `extern type`\n+    None,\n+    /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n+    /// a ZST Operand with a backing allocation and being converted to an integer address. This\n+    /// should be impossible, because you can't take the address of an operand, but this is a second\n+    /// protection layer ensuring that we don't mess up.\n+    Poison,\n+}\n+\n+impl<Tag, Id> MemPlaceMeta<Tag, Id> {\n+    pub fn unwrap_meta(self) -> Scalar<Tag, Id> {\n+        match self {\n+            Self::Meta(s) => s,\n+            Self::None | Self::Poison => {\n+                bug!(\"expected wide pointer extra data (e.g. slice length or trait object vtable)\")\n+            }\n+        }\n+    }\n+    fn has_meta(self) -> bool {\n+        match self {\n+            Self::Meta(_) => true,\n+            Self::None | Self::Poison => false,\n+        }\n+    }\n+}\n+\n+impl<Tag> MemPlaceMeta<Tag> {\n+    pub fn erase_tag(self) -> MemPlaceMeta<()> {\n+        match self {\n+            Self::Meta(s) => MemPlaceMeta::Meta(s.erase_tag()),\n+            Self::None => MemPlaceMeta::None,\n+            Self::Poison => MemPlaceMeta::Poison,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n@@ -30,7 +71,7 @@ pub struct MemPlace<Tag = (), Id = AllocId> {\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n-    pub meta: Option<Scalar<Tag, Id>>,\n+    pub meta: MemPlaceMeta<Tag, Id>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -88,21 +129,17 @@ impl<Tag> MemPlace<Tag> {\n \n     #[inline]\n     pub fn erase_tag(self) -> MemPlace {\n-        MemPlace {\n-            ptr: self.ptr.erase_tag(),\n-            align: self.align,\n-            meta: self.meta.map(Scalar::erase_tag),\n-        }\n+        MemPlace { ptr: self.ptr.erase_tag(), align: self.align, meta: self.meta.erase_tag() }\n     }\n \n     #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        MemPlace { ptr, align, meta: None }\n+    fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n+        MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: &impl HasDataLayout) -> Self {\n+    fn null(cx: &impl HasDataLayout) -> Self {\n         Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1).unwrap())\n     }\n \n@@ -116,15 +153,19 @@ impl<Tag> MemPlace<Tag> {\n     #[inline(always)]\n     pub fn to_ref(self) -> Immediate<Tag> {\n         match self.meta {\n-            None => Immediate::Scalar(self.ptr.into()),\n-            Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::None => Immediate::Scalar(self.ptr.into()),\n+            MemPlaceMeta::Meta(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::Poison => bug!(\n+                \"MPlaceTy::dangling may never be used to produce a \\\n+                place that will have the address of its pointee taken\"\n+            ),\n         }\n     }\n \n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace {\n@@ -139,13 +180,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n-        MPlaceTy {\n-            mplace: MemPlace::from_scalar_ptr(\n-                Scalar::from_uint(layout.align.abi.bytes(), cx.pointer_size()),\n-                layout.align.abi,\n-            ),\n-            layout,\n-        }\n+        let align = layout.align.abi;\n+        let ptr = Scalar::from_uint(align.bytes(), cx.pointer_size());\n+        // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n+        MPlaceTy { mplace: MemPlace { ptr, align, meta: MemPlaceMeta::Poison }, layout }\n     }\n \n     /// Replace ptr tag, maintain vtable tag (if any)\n@@ -158,7 +196,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub fn offset(\n         self,\n         offset: Size,\n-        meta: Option<Scalar<Tag>>,\n+        meta: MemPlaceMeta<Tag>,\n         layout: TyLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n@@ -175,7 +213,9 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind {\n-                ty::Slice(..) | ty::Str => return self.mplace.meta.unwrap().to_machine_usize(cx),\n+                ty::Slice(..) | ty::Str => {\n+                    return self.mplace.meta.unwrap_meta().to_machine_usize(cx);\n+                }\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n@@ -191,7 +231,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     #[inline]\n     pub(super) fn vtable(self) -> Scalar<Tag> {\n         match self.layout.ty.kind {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -200,36 +240,36 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n // These are defined here because they produce a place.\n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n+    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n+    /// read from the resulting mplace, not to get its address back.\n+    pub fn try_as_mplace(\n+        self,\n+        cx: &impl HasDataLayout,\n+    ) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Immediate(_) if self.layout.is_zst() => {\n+                Ok(MPlaceTy::dangling(self.layout, cx))\n+            }\n             Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n-        self.try_as_mplace().unwrap()\n+    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n+    /// read from the resulting mplace, not to get its address back.\n+    pub fn assert_mem_place(self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n+        self.try_as_mplace(cx).unwrap()\n     }\n }\n \n impl<Tag: ::std::fmt::Debug> Place<Tag> {\n     /// Produces a Place that will error if attempted to be read from or written to\n     #[inline(always)]\n-    pub fn null(cx: &impl HasDataLayout) -> Self {\n+    fn null(cx: &impl HasDataLayout) -> Self {\n         Place::Ptr(MemPlace::null(cx))\n     }\n \n-    #[inline(always)]\n-    pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n-        Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n-    }\n-\n-    #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n-        Place::Ptr(MemPlace::from_ptr(ptr, align))\n-    }\n-\n     #[inline]\n     pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n@@ -270,8 +310,10 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n-            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n-            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, MemPlaceMeta::None),\n+            Immediate::ScalarPair(ptr, meta) => {\n+                (ptr.not_undef()?, MemPlaceMeta::Meta(meta.not_undef()?))\n+            }\n         };\n \n         let mplace = MemPlace {\n@@ -305,14 +347,14 @@ where\n     /// On success, returns `None` for zero-sized accesses (where nothing else is\n     /// left to do) and a `Pointer` to use for the actual access otherwise.\n     #[inline]\n-    pub fn check_mplace_access(\n+    pub(super) fn check_mplace_access(\n         &self,\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         size: Option<Size>,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let size = size.unwrap_or_else(|| {\n             assert!(!place.layout.is_unsized());\n-            assert!(place.meta.is_none());\n+            assert!(!place.meta.has_meta());\n             place.layout.size\n         });\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n@@ -338,7 +380,7 @@ where\n \n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n-    pub fn force_mplace_ptr(\n+    pub(super) fn force_mplace_ptr(\n         &self,\n         mut place: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n@@ -405,7 +447,7 @@ where\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct.\n-            (None, offset)\n+            (MemPlaceMeta::None, offset)\n         };\n \n         // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n@@ -415,7 +457,7 @@ where\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n-    pub fn mplace_array_fields(\n+    pub(super) fn mplace_array_fields(\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n@@ -427,10 +469,10 @@ where\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n-        Ok((0..len).map(move |i| base.offset(i * stride, None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(i * stride, MemPlaceMeta::None, layout, dl)))\n     }\n \n-    pub fn mplace_subslice(\n+    fn mplace_subslice(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         from: u64,\n@@ -460,29 +502,29 @@ where\n         let (meta, ty) = match base.layout.ty.kind {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) => (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_uint(inner_len, self.pointer_size());\n-                (Some(len), base.layout.ty)\n+                (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n             _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n     }\n \n-    pub fn mplace_downcast(\n+    pub(super) fn mplace_downcast(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        assert!(base.meta.is_none());\n+        assert!(!base.meta.has_meta());\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n     /// Project into an mplace\n-    pub fn mplace_projection(\n+    pub(super) fn mplace_projection(\n         &self,\n         base: MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: &mir::PlaceElem<'tcx>,\n@@ -971,7 +1013,7 @@ where\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n@@ -1016,7 +1058,7 @@ where\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        Ok(self.force_allocation_maybe_sized(place, None)?.0)\n+        Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n     }\n \n     pub fn allocate(\n@@ -1036,8 +1078,11 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n-        let mplace =\n-            MemPlace { ptr: ptr.into(), align: Align::from_bytes(1).unwrap(), meta: Some(meta) };\n+        let mplace = MemPlace {\n+            ptr: ptr.into(),\n+            align: Align::from_bytes(1).unwrap(),\n+            meta: MemPlaceMeta::Meta(meta),\n+        };\n \n         let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n         MPlaceTy { mplace, layout }\n@@ -1145,7 +1190,7 @@ where\n             assert_eq!(align, layout.align.abi);\n         }\n \n-        let mplace = MPlaceTy { mplace: MemPlace { meta: None, ..*mplace }, layout };\n+        let mplace = MPlaceTy { mplace: MemPlace { meta: MemPlaceMeta::None, ..*mplace }, layout };\n         Ok((instance, mplace))\n     }\n }"}, {"sha": "a8e67c8f208a94f564877fda13a0619a37fc43a1", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -23,7 +23,9 @@ use rustc_span::source_map::Span;\n use syntax::ast::Mutability;\n \n use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{Frame, Immediate, LocalValue, MemPlace, Memory, Operand, Place, ScalarMaybeUndef};\n+use super::{\n+    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n+};\n use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -205,6 +207,14 @@ impl_snapshot_for!(\n     }\n );\n \n+impl_snapshot_for!(\n+    enum MemPlaceMeta {\n+        Meta(s),\n+        None,\n+        Poison,\n+    }\n+);\n+\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     meta,"}, {"sha": "37dcab512b9918d65eb95f4fe02ddde69da3d72e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -378,7 +378,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].assert_mem_place()\n+                        args[0].assert_mem_place(self)\n                     }\n                 };\n                 // Find and consult vtable"}, {"sha": "12e8cb6071d92b31453da434edddfc1b29bf5d65", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -16,7 +16,7 @@ use rustc_span::symbol::{sym, Symbol};\n use std::hash::Hash;\n \n use super::{\n-    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, Scalar,\n+    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, MemPlaceMeta, OpTy,\n     ValueVisitor,\n };\n \n@@ -246,13 +246,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n \n     fn check_wide_ptr_meta(\n         &mut self,\n-        meta: Option<Scalar<M::PointerTag>>,\n+        meta: MemPlaceMeta<M::PointerTag>,\n         pointee: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind {\n             ty::Dynamic(..) => {\n-                let vtable = meta.unwrap();\n+                let vtable = meta.unwrap_meta();\n                 try_validation!(\n                     self.ecx.memory.check_ptr_access(\n                         vtable,\n@@ -276,7 +276,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n-                    meta.unwrap().to_machine_usize(self.ecx),\n+                    meta.unwrap_meta().to_machine_usize(self.ecx),\n                     \"non-integer slice length in wide pointer\",\n                     self.path\n                 );\n@@ -571,7 +571,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind {\n             ty::Str => {\n-                let mplace = op.assert_mem_place(); // strings are never immediate\n+                let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 try_validation!(\n                     self.ecx.read_str(mplace),\n                     \"uninitialized or non-UTF-8 data in str\",\n@@ -599,15 +599,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             {\n                 // Optimized handling for arrays of integer/float type.\n \n-                // bailing out for zsts is ok, since the array element type can only be int/float\n-                if op.layout.is_zst() {\n-                    return Ok(());\n-                }\n-                // non-ZST array cannot be immediate, slices are never immediate\n-                let mplace = op.assert_mem_place();\n+                // Arrays cannot be immediate, slices are never immediate.\n+                let mplace = op.assert_mem_place(self.ecx);\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n-                // zero length slices have nothing to be checked\n+                // Zero length slices have nothing to be checked.\n                 if len == 0 {\n                     return Ok(());\n                 }"}, {"sha": "d2594e8707104cf10e94f9c3cad066d7f3831fd7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -223,7 +223,7 @@ macro_rules! make_value_visitor {\n                 match v.layout().ty.kind {\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.assert_mem_place();\n+                        let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -292,13 +292,7 @@ macro_rules! make_value_visitor {\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n-                        let mplace = if v.layout().is_zst() {\n-                            // it's a ZST, the memory content cannot matter\n-                            MPlaceTy::dangling(v.layout(), self.ecx())\n-                        } else {\n-                            // non-ZST array/slice/str cannot be immediate\n-                            v.to_op(self.ecx())?.assert_mem_place()\n-                        };\n+                        let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields.\n                         let iter = self.ecx().mplace_array_fields(mplace)?\n                             .map(|f| f.and_then(|f| {"}, {"sha": "d5d56b36cf4c3934b67d5a0ca4e082f9282ec0aa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -707,7 +707,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 ScalarMaybeUndef::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n-                intern_const_alloc_recursive(&mut self.ecx, None, op.assert_mem_place())\n+                let mplace = op.assert_mem_place(&self.ecx);\n+                intern_const_alloc_recursive(&mut self.ecx, None, mplace)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }"}, {"sha": "075583711f5d3e8f9b129364cd1a0f9143327557", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -156,7 +156,7 @@ impl<'a> Parser<'a> {\n             self.expect_gt()?;\n             (params, span_lo.to(self.prev_span))\n         } else {\n-            (vec![], self.prev_span.between(self.token.span))\n+            (vec![], self.prev_span.shrink_to_hi())\n         };\n         Ok(ast::Generics {\n             params,"}, {"sha": "f6199da3f1d83d8b9f803d1919cf39ef9a2a607b", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -5,7 +5,7 @@ use crate::maybe_whole;\n \n use rustc_error_codes::*;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult, StashKey};\n-use rustc_span::source_map::{self, respan, Span};\n+use rustc_span::source_map::{self, respan, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::BytePos;\n use syntax::ast::{self, AttrKind, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n@@ -140,7 +140,7 @@ impl<'a> Parser<'a> {\n                     self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n                 let ext = self.parse_extern()?;\n-                self.bump(); // `fn`\n+                self.expect_keyword(kw::Fn)?;\n \n                 let header = FnHeader {\n                     unsafety,\n@@ -542,10 +542,11 @@ impl<'a> Parser<'a> {\n     ///    impl<'a, T> TYPE { /* impl items */ }\n     ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n     ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    ///    impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n     ///\n     /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    ///     `impl` GENERICS `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n-    ///     `impl` GENERICS `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    ///   `impl` GENERICS `const`? `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n+    ///   `impl` GENERICS `const`? `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n     fn parse_item_impl(\n         &mut self,\n         unsafety: Unsafety,\n@@ -555,7 +556,19 @@ impl<'a> Parser<'a> {\n         let mut generics = if self.choose_generics_over_qpath() {\n             self.parse_generics()?\n         } else {\n-            Generics::default()\n+            let mut generics = Generics::default();\n+            // impl A for B {}\n+            //    /\\ this is where `generics.span` should point when there are no type params.\n+            generics.span = self.prev_span.shrink_to_hi();\n+            generics\n+        };\n+\n+        let constness = if self.eat_keyword(kw::Const) {\n+            let span = self.prev_span;\n+            self.sess.gated_spans.gate(sym::const_trait_impl, span);\n+            Some(respan(span, Constness::Const))\n+        } else {\n+            None\n         };\n \n         // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n@@ -618,7 +631,8 @@ impl<'a> Parser<'a> {\n                         err_path(ty_first.span)\n                     }\n                 };\n-                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n+                let constness = constness.map(|c| c.node);\n+                let trait_ref = TraitRef { path, constness, ref_id: ty_first.id };\n \n                 ItemKind::Impl(\n                     unsafety,\n@@ -631,6 +645,13 @@ impl<'a> Parser<'a> {\n                 )\n             }\n             None => {\n+                // Reject `impl const Type {}` here\n+                if let Some(Spanned { node: Constness::Const, span }) = constness {\n+                    self.struct_span_err(span, \"`const` cannot modify an inherent impl\")\n+                        .help(\"only a trait impl can be `const`\")\n+                        .emit();\n+                }\n+\n                 // impl Type\n                 ItemKind::Impl(\n                     unsafety,"}, {"sha": "ea14aa278ac29e3f83455d4b551695b3b9286494", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -6,7 +6,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_error_codes::*;\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use syntax::ast::{\n     self, BareFnTy, FunctionRetTy, GenericParam, Ident, Lifetime, MutTy, Ty, TyKind,\n };\n@@ -17,6 +17,24 @@ use syntax::ast::{Mac, Mutability};\n use syntax::ptr::P;\n use syntax::token::{self, Token};\n \n+/// Any `?` or `?const` modifiers that appear at the start of a bound.\n+struct BoundModifiers {\n+    /// `?Trait`.\n+    maybe: Option<Span>,\n+\n+    /// `?const Trait`.\n+    maybe_const: Option<Span>,\n+}\n+\n+impl BoundModifiers {\n+    fn trait_bound_modifier(&self) -> TraitBoundModifier {\n+        match self.maybe {\n+            Some(_) => TraitBoundModifier::Maybe,\n+            None => TraitBoundModifier::None,\n+        }\n+    }\n+}\n+\n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n /// `IDENT<<u8 as Trait>::AssocTy>`.\n ///\n@@ -195,7 +213,9 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         parse_plus: bool,\n     ) -> PResult<'a, TyKind> {\n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        assert_ne!(self.token, token::Question);\n+\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, None, lo.to(self.prev_span));\n         let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n         if parse_plus {\n             self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n@@ -421,12 +441,15 @@ impl<'a> Parser<'a> {\n         let has_parens = self.eat(&token::OpenDelim(token::Paren));\n         let inner_lo = self.token.span;\n         let is_negative = self.eat(&token::Not);\n-        let question = self.eat(&token::Question).then_some(self.prev_span);\n+\n+        let modifiers = self.parse_ty_bound_modifiers();\n         let bound = if self.token.is_lifetime() {\n-            self.parse_generic_lt_bound(lo, inner_lo, has_parens, question)?\n+            self.error_lt_bound_with_modifiers(modifiers);\n+            self.parse_generic_lt_bound(lo, inner_lo, has_parens)?\n         } else {\n-            self.parse_generic_ty_bound(lo, has_parens, question)?\n+            self.parse_generic_ty_bound(lo, has_parens, modifiers)?\n         };\n+\n         Ok(if is_negative { Err(anchor_lo.to(self.prev_span)) } else { Ok(bound) })\n     }\n \n@@ -439,9 +462,7 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         inner_lo: Span,\n         has_parens: bool,\n-        question: Option<Span>,\n     ) -> PResult<'a, GenericBound> {\n-        self.error_opt_out_lifetime(question);\n         let bound = GenericBound::Outlives(self.expect_lifetime());\n         if has_parens {\n             // FIXME(Centril): Consider not erroring here and accepting `('lt)` instead,\n@@ -451,8 +472,17 @@ impl<'a> Parser<'a> {\n         Ok(bound)\n     }\n \n-    fn error_opt_out_lifetime(&self, question: Option<Span>) {\n-        if let Some(span) = question {\n+    /// Emits an error if any trait bound modifiers were present.\n+    fn error_lt_bound_with_modifiers(&self, modifiers: BoundModifiers) {\n+        if let Some(span) = modifiers.maybe_const {\n+            self.struct_span_err(\n+                span,\n+                \"`?const` may only modify trait bounds, not lifetime bounds\",\n+            )\n+            .emit();\n+        }\n+\n+        if let Some(span) = modifiers.maybe {\n             self.struct_span_err(span, \"`?` may only modify trait bounds, not lifetime bounds\")\n                 .emit();\n         }\n@@ -478,25 +508,58 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    /// Parses the modifiers that may precede a trait in a bound, e.g. `?Trait` or `?const Trait`.\n+    ///\n+    /// If no modifiers are present, this does not consume any tokens.\n+    ///\n+    /// ```\n+    /// TY_BOUND_MODIFIERS = \"?\" [\"const\" [\"?\"]]\n+    /// ```\n+    fn parse_ty_bound_modifiers(&mut self) -> BoundModifiers {\n+        if !self.eat(&token::Question) {\n+            return BoundModifiers { maybe: None, maybe_const: None };\n+        }\n+\n+        // `? ...`\n+        let first_question = self.prev_span;\n+        if !self.eat_keyword(kw::Const) {\n+            return BoundModifiers { maybe: Some(first_question), maybe_const: None };\n+        }\n+\n+        // `?const ...`\n+        let maybe_const = first_question.to(self.prev_span);\n+        self.sess.gated_spans.gate(sym::const_trait_bound_opt_out, maybe_const);\n+        if !self.eat(&token::Question) {\n+            return BoundModifiers { maybe: None, maybe_const: Some(maybe_const) };\n+        }\n+\n+        // `?const ? ...`\n+        let second_question = self.prev_span;\n+        BoundModifiers { maybe: Some(second_question), maybe_const: Some(maybe_const) }\n+    }\n+\n     /// Parses a type bound according to:\n     /// ```\n     /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n-    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n+    /// TY_BOUND_NOPAREN = [TY_BOUND_MODIFIERS] [for<LT_PARAM_DEFS>] SIMPLE_PATH\n     /// ```\n+    ///\n+    /// For example, this grammar accepts `?const ?for<'a: 'b> m::Trait<'a>`.\n     fn parse_generic_ty_bound(\n         &mut self,\n         lo: Span,\n         has_parens: bool,\n-        question: Option<Span>,\n+        modifiers: BoundModifiers,\n     ) -> PResult<'a, GenericBound> {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n         let path = self.parse_path(PathStyle::Type)?;\n         if has_parens {\n             self.expect(&token::CloseDelim(token::Paren))?;\n         }\n-        let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-        let modifier = question.map_or(TraitBoundModifier::None, |_| TraitBoundModifier::Maybe);\n-        Ok(GenericBound::Trait(poly_trait, modifier))\n+\n+        let constness = modifiers.maybe_const.map(|_| ast::Constness::NotConst);\n+        let poly_trait = PolyTraitRef::new(lifetime_defs, path, constness, lo.to(self.prev_span));\n+        Ok(GenericBound::Trait(poly_trait, modifiers.trait_bound_modifier()))\n     }\n \n     /// Optionally parses `for<$generic_params>`."}, {"sha": "724d717304c203a8772771a821e4ec2aa8fae413", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -24,6 +24,24 @@ use syntax::walk_list;\n \n use rustc_error_codes::*;\n \n+/// A syntactic context that disallows certain kinds of bounds (e.g., `?Trait` or `?const Trait`).\n+#[derive(Clone, Copy)]\n+enum BoundContext {\n+    ImplTrait,\n+    TraitBounds,\n+    TraitObject,\n+}\n+\n+impl BoundContext {\n+    fn description(&self) -> &'static str {\n+        match self {\n+            Self::ImplTrait => \"`impl Trait`\",\n+            Self::TraitBounds => \"supertraits\",\n+            Self::TraitObject => \"trait objects\",\n+        }\n+    }\n+}\n+\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n@@ -33,6 +51,12 @@ struct AstValidator<'a> {\n     /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<Span>,\n \n+    /// Keeps track of the `BoundContext` as we recurse.\n+    ///\n+    /// This is used to forbid `?const Trait` bounds in, e.g.,\n+    /// `impl Iterator<Item = Box<dyn ?const Trait>`.\n+    bound_context: Option<BoundContext>,\n+\n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n@@ -59,10 +83,20 @@ impl<'a> AstValidator<'a> {\n \n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n-        f(self);\n+        if outer.is_some() {\n+            self.with_bound_context(BoundContext::ImplTrait, |this| f(this));\n+        } else {\n+            f(self)\n+        }\n         self.outer_impl_trait = old;\n     }\n \n+    fn with_bound_context(&mut self, ctx: BoundContext, f: impl FnOnce(&mut Self)) {\n+        let old = self.bound_context.replace(ctx);\n+        f(self);\n+        self.bound_context = old;\n+    }\n+\n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n         match constraint.kind {\n             AssocTyConstraintKind::Equality { .. } => {}\n@@ -84,6 +118,9 @@ impl<'a> AstValidator<'a> {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n+            TyKind::TraitObject(..) => {\n+                self.with_bound_context(BoundContext::TraitObject, |this| visit::walk_ty(this, t));\n+            }\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n@@ -192,6 +229,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    // FIXME(ecstaticmorse): Instead, use `bound_context` to check this in `visit_param_bound`.\n     fn no_questions_in_bounds(&self, bounds: &GenericBounds, where_: &str, is_trait: bool) {\n         for bound in bounds {\n             if let GenericBound::Trait(ref poly, TraitBoundModifier::Maybe) = *bound {\n@@ -697,6 +735,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n+\n+                // Equivalent of `visit::walk_item` for `ItemKind::Trait` that inserts a bound\n+                // context for the supertraits.\n+                self.visit_vis(&item.vis);\n+                self.visit_ident(item.ident);\n+                self.visit_generics(generics);\n+                self.with_bound_context(BoundContext::TraitBounds, |this| {\n+                    walk_list!(this, visit_param_bound, bounds);\n+                });\n+                walk_list!(self, visit_trait_item, trait_items);\n+                walk_list!(self, visit_attribute, &item.attrs);\n+                return;\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -841,6 +891,29 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_generic_param(self, param);\n     }\n \n+    fn visit_param_bound(&mut self, bound: &'a GenericBound) {\n+        if let GenericBound::Trait(poly, maybe_bound) = bound {\n+            match poly.trait_ref.constness {\n+                Some(Constness::NotConst) => {\n+                    if *maybe_bound == TraitBoundModifier::Maybe {\n+                        self.err_handler()\n+                            .span_err(bound.span(), \"`?const` and `?` are mutually exclusive\");\n+                    }\n+\n+                    if let Some(ctx) = self.bound_context {\n+                        let msg = format!(\"`?const` is not permitted in {}\", ctx.description());\n+                        self.err_handler().span_err(bound.span(), &msg);\n+                    }\n+                }\n+\n+                Some(Constness::Const) => bug!(\"Parser should reject bare `const` on bounds\"),\n+                None => {}\n+            }\n+        }\n+\n+        visit::walk_param_bound(self, bound)\n+    }\n+\n     fn visit_pat(&mut self, pat: &'a Pat) {\n         match pat.kind {\n             PatKind::Lit(ref expr) => {\n@@ -949,6 +1022,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffe\n         session,\n         has_proc_macro_decls: false,\n         outer_impl_trait: None,\n+        bound_context: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         lint_buffer: lints,"}, {"sha": "9e4486e16f2ccb0a716ce8c7570f7b6c54e220da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -22,7 +22,7 @@ use Determinacy::*;\n \n use errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc::hir::exports::ExportMap;\n-use rustc::hir::map::Definitions;\n+use rustc::hir::map::{DefKey, Definitions};\n use rustc::lint;\n use rustc::middle::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc::session::Session;\n@@ -1027,8 +1027,12 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl rustc_ast_lowering::Resolver for Resolver<'_> {\n-    fn cstore(&self) -> &dyn CrateStore {\n-        self.cstore()\n+    fn def_key(&mut self, id: DefId) -> DefKey {\n+        if id.is_local() { self.definitions().def_key(id.index) } else { self.cstore().def_key(id) }\n+    }\n+\n+    fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n+        self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n     fn resolve_str_path("}, {"sha": "d9f4b72560ceb831f4d99db93ec25bb617936a79", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -219,6 +219,8 @@ symbols! {\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n         const_transmute,\n+        const_trait_bound_opt_out,\n+        const_trait_impl,\n         contents,\n         context,\n         convert,"}, {"sha": "7c7480339a5eebf65d09bfc029a362fa8848a6f9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -2803,7 +2803,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // allowed. `allow_ty_infer` gates this behavior.\n             crate::collect::placeholder_type_error(\n                 tcx,\n-                ident_span.unwrap_or(DUMMY_SP),\n+                ident_span.map(|sp| sp.shrink_to_hi()).unwrap_or(DUMMY_SP),\n                 generic_params,\n                 visitor.0,\n                 ident_span.is_some(),"}, {"sha": "5e73f8e3e128f0f03a24a07c8024f41977ae8e32", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -114,6 +114,7 @@ use rustc::ty::{\n     self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n     ToPredicate, Ty, TyCtxt, UserType,\n };\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -146,7 +147,6 @@ use crate::lint;\n use crate::require_c_abi_if_c_variadic;\n use crate::session::config::EntryFnType;\n use crate::session::Session;\n-use crate::util::captures::Captures;\n use crate::util::common::{indenter, ErrorReported};\n use crate::TypeAndSubsts;\n \n@@ -4746,14 +4746,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .join(\", \");\n                 }\n                 Some(Node::Expr(hir::Expr {\n-                    kind: ExprKind::Closure(_, _, body_id, closure_span, _),\n+                    kind: ExprKind::Closure(_, _, body_id, _, _),\n                     span: full_closure_span,\n                     ..\n                 })) => {\n                     if *full_closure_span == expr.span {\n                         return false;\n                     }\n-                    err.span_label(*closure_span, \"closure defined here\");\n                     msg = \"call this closure\";\n                     let body = hir.body(*body_id);\n                     sugg_call = body"}, {"sha": "3bb06d76349834043d2ffebd861203a0f1ffc858", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -32,7 +32,7 @@ use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate};\n-use rustc::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -127,7 +127,7 @@ struct CollectItemTypesVisitor<'tcx> {\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n crate fn placeholder_type_error(\n     tcx: TyCtxt<'tcx>,\n-    ident_span: Span,\n+    span: Span,\n     generics: &[hir::GenericParam<'_>],\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n@@ -153,7 +153,14 @@ crate fn placeholder_type_error(\n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, type_name.to_string())).collect();\n     if generics.is_empty() {\n-        sugg.push((ident_span.shrink_to_hi(), format!(\"<{}>\", type_name)));\n+        sugg.push((span, format!(\"<{}>\", type_name)));\n+    } else if let Some(arg) = generics.iter().find(|arg| match arg.name {\n+        hir::ParamName::Plain(Ident { name: kw::Underscore, .. }) => true,\n+        _ => false,\n+    }) {\n+        // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n+        // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n+        sugg.push((arg.span, format!(\"{}\", type_name)));\n     } else {\n         sugg.push((\n             generics.iter().last().unwrap().span.shrink_to_hi(),\n@@ -175,16 +182,20 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n     let (generics, suggest) = match &item.kind {\n         hir::ItemKind::Union(_, generics)\n         | hir::ItemKind::Enum(_, generics)\n-        | hir::ItemKind::Struct(_, generics) => (&generics.params[..], true),\n-        hir::ItemKind::TyAlias(_, generics) => (&generics.params[..], false),\n+        | hir::ItemKind::TraitAlias(generics, _)\n+        | hir::ItemKind::Trait(_, _, generics, ..)\n+        | hir::ItemKind::Impl(_, _, _, generics, ..)\n+        | hir::ItemKind::Struct(_, generics) => (generics, true),\n+        hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. })\n+        | hir::ItemKind::TyAlias(_, generics) => (generics, false),\n         // `static`, `fn` and `const` are handled elsewhere to suggest appropriate type.\n         _ => return,\n     };\n \n     let mut visitor = PlaceholderHirTyCollector::default();\n     visitor.visit_item(item);\n \n-    placeholder_type_error(tcx, item.ident.span, generics, visitor.0, suggest);\n+    placeholder_type_error(tcx, generics.span, &generics.params[..], visitor.0, suggest);\n }\n \n impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n@@ -1798,10 +1809,19 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n /// Whether `ty` is a type with `_` placeholders that can be infered. Used in diagnostics only to\n /// use inference to provide suggestions for the appropriate type if possible.\n fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n+    use hir::TyKind::*;\n     match &ty.kind {\n-        hir::TyKind::Infer => true,\n-        hir::TyKind::Slice(ty) | hir::TyKind::Array(ty, _) => is_suggestable_infer_ty(ty),\n-        hir::TyKind::Tup(tys) => tys.iter().any(|ty| is_suggestable_infer_ty(ty)),\n+        Infer => true,\n+        Slice(ty) | Array(ty, _) => is_suggestable_infer_ty(ty),\n+        Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n+        Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n+        Def(_, generic_args) => generic_args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                hir::GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            })\n+            .any(is_suggestable_infer_ty),\n         _ => false,\n     }\n }"}, {"sha": "1d3bb7d87686cfe81bd89853365c2339844bf708", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1033,7 +1033,7 @@ impl Expr {\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n-                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                PolyTraitRef::new(Vec::new(), path.clone(), None, self.span),\n                 TraitBoundModifier::None,\n             )),\n             _ => None,\n@@ -2376,6 +2376,15 @@ pub enum AttrKind {\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n+\n+    /// The `const` modifier, if any, that appears before this trait.\n+    ///\n+    /// |                | `constness`                 |\n+    /// |----------------|-----------------------------|\n+    /// | `Trait`        | `None`                      |\n+    /// | `const Trait`  | `Some(Constness::Const)`    |\n+    /// | `?const Trait` | `Some(Constness::NotConst)` |\n+    pub constness: Option<Constness>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2390,10 +2399,15 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n+    pub fn new(\n+        generic_params: Vec<GenericParam>,\n+        path: Path,\n+        constness: Option<Constness>,\n+        span: Span,\n+    ) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n-            trait_ref: TraitRef { path, ref_id: DUMMY_NODE_ID },\n+            trait_ref: TraitRef { path, constness, ref_id: DUMMY_NODE_ID },\n             span,\n         }\n     }"}, {"sha": "52eb20d320f7be759adef09fac1e7ba95fa310d3", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -909,6 +909,8 @@ pub fn check_crate(\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n+    gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");\n+    gate_all!(const_trait_impl, \"const trait impls are experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "264ba25cedecc78edb4d4eebc77b5c599b2d468f", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -838,7 +838,8 @@ pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut\n     }\n }\n \n-pub fn noop_visit_trait_ref<T: MutVisitor>(TraitRef { path, ref_id }: &mut TraitRef, vis: &mut T) {\n+pub fn noop_visit_trait_ref<T: MutVisitor>(tr: &mut TraitRef, vis: &mut T) {\n+    let TraitRef { path, ref_id, constness: _ } = tr;\n     vis.visit_path(path);\n     vis.visit_id(ref_id);\n }"}, {"sha": "dc3a4752fb1f7205613e8d4fbf375002c3b44317", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/dont-suggest-missing-await.rs:14:18\n    |\n+LL | async fn make_u32() -> u32 {\n+   |                        --- the `Output` of this `async fn`'s found opaque type\n+...\n LL |         take_u32(x)\n    |                  ^ expected `u32`, found opaque type\n    |"}, {"sha": "d6828172928dd7792826fbd92c8ee3ed18c23d72", "filename": "src/test/ui/async-await/issue-64130-3-other.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -3,6 +3,9 @@ error[E0277]: the trait bound `Foo: Qux` is not satisfied in `impl std::future::\n    |\n LL | fn is_qux<T: Qux>(t: T) { }\n    |    ------    --- required by this bound in `is_qux`\n+LL | \n+LL | async fn bar() {\n+   |                - within this `impl std::future::Future`\n ...\n LL |     is_qux(bar());\n    |     ^^^^^^ within `impl std::future::Future`, the trait `Qux` is not implemented for `Foo`"}, {"sha": "2703cec581ddfe39fcde31558a2017c8544fa6e6", "filename": "src/test/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await-closure.rs:16:18\n    |\n+LL | async fn make_u32() -> u32 {\n+   |                        --- the `Output` of this `async fn`'s found opaque type\n+...\n LL |         take_u32(x)\n    |                  ^\n    |                  |"}, {"sha": "6ac05a87aae8096e8e75f4798fa4ff9cd398dac9", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await.rs:13:14\n    |\n+LL | async fn make_u32() -> u32 {\n+   |                        --- the `Output` of this `async fn`'s found opaque type\n+...\n LL |     take_u32(x)\n    |              ^\n    |              |\n@@ -13,6 +16,9 @@ LL |     take_u32(x)\n error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await.rs:23:5\n    |\n+LL | async fn dummy() {}\n+   |                  - the `Output` of this `async fn`'s found opaque type\n+...\n LL |     dummy()\n    |     ^^^^^^^ expected `()`, found opaque type\n    |"}, {"sha": "3c4ae450764dae72ccb5da2579b3c3e32c8705d4", "filename": "src/test/ui/closures/closure-reform-bad.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fclosures%2Fclosure-reform-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fclosures%2Fclosure-reform-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-reform-bad.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/closure-reform-bad.rs:11:15\n    |\n+LL |     let f = |s: &str| println!(\"{}{}\", s, string);\n+   |             ------------------------------------- the found closure\n LL |     call_bare(f)\n    |               ^ expected fn pointer, found closure\n    |"}, {"sha": "7ced24808bf6ed4618a93a6c5a72fac2e90c27b3", "filename": "src/test/ui/consts/const-extern-fn/issue-68062-const-extern-fns-dont-need-fn-specifier-2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,7 @@\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn container() {\n+    const unsafe WhereIsFerris Now() {}\n+    //~^ ERROR expected one of `extern` or `fn`\n+}"}, {"sha": "5ec9e2a91f1dc28f4b33916bb0449e9540af1049", "filename": "src/test/ui/consts/const-extern-fn/issue-68062-const-extern-fns-dont-need-fn-specifier-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier-2.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `extern` or `fn`, found `WhereIsFerris`\n+  --> $DIR/issue-68062-const-extern-fns-dont-need-fn-specifier-2.rs:5:18\n+   |\n+LL |     const unsafe WhereIsFerris Now() {}\n+   |                  ^^^^^^^^^^^^^ expected one of `extern` or `fn`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1886bfccb4e3eb55f6091884c7e9ea286e512804", "filename": "src/test/ui/consts/const-extern-fn/issue-68062-const-extern-fns-dont-need-fn-specifier.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn container() {\n+    const extern \"Rust\" PUT_ANYTHING_YOU_WANT_HERE bug() -> usize { 1 }\n+    //~^ ERROR expected `fn`\n+    //~| ERROR `const extern fn` definitions are unstable\n+}"}, {"sha": "cf71ed4d59765bbd3c6a780a3c0d69bd71e0cfab", "filename": "src/test/ui/consts/const-extern-fn/issue-68062-const-extern-fns-dont-need-fn-specifier.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fissue-68062-const-extern-fns-dont-need-fn-specifier.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,18 @@\n+error: expected `fn`, found `PUT_ANYTHING_YOU_WANT_HERE`\n+  --> $DIR/issue-68062-const-extern-fns-dont-need-fn-specifier.rs:5:25\n+   |\n+LL |     const extern \"Rust\" PUT_ANYTHING_YOU_WANT_HERE bug() -> usize { 1 }\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `fn`\n+\n+error[E0658]: `const extern fn` definitions are unstable\n+  --> $DIR/issue-68062-const-extern-fns-dont-need-fn-specifier.rs:5:5\n+   |\n+LL |     const extern \"Rust\" PUT_ANYTHING_YOU_WANT_HERE bug() -> usize { 1 }\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/64926\n+   = help: add `#![feature(const_extern_fn)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "32b45ee10ad6f1c823a13d272419a20dcde6f077", "filename": "src/test/ui/extern/extern-types-distinct-types.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fextern%2Fextern-types-distinct-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fextern%2Fextern-types-distinct-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-types-distinct-types.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/extern-types-distinct-types.rs:9:5\n    |\n+LL |     type A;\n+   |     ------- the found foreign type\n+LL |     type B;\n+   |     ------- the expected foreign type\n+...\n LL |     r\n    |     ^ expected extern type `B`, found extern type `A`\n    |"}, {"sha": "0ebaac8945050ecd9d8fa97722092f989c4b88a2", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -112,6 +112,9 @@ LL | fn send<T: Send>(_: T) {}\n ...\n LL |     send(cycle2().clone());\n    |     ^^^^ `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n+...\n+LL | fn cycle2() -> impl Clone {\n+   |                ---------- within this `impl std::clone::Clone`\n    |\n    = help: within `impl std::clone::Clone`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n    = note: required because it appears within the type `impl std::clone::Clone`"}, {"sha": "a93b3dbc71b60c7b5a4302dd1db175cd38cd931c", "filename": "src/test/ui/impl-trait/auto-trait-leak2.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak2.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n   --> $DIR/auto-trait-leak2.rs:13:5\n    |\n+LL | fn before() -> impl Fn(i32) {\n+   |                ------------ within this `impl std::ops::Fn<(i32,)>`\n+...\n LL | fn send<T: Send>(_: T) {}\n    |    ----    ---- required by this bound in `send`\n ...\n@@ -19,6 +22,9 @@ LL | fn send<T: Send>(_: T) {}\n ...\n LL |     send(after());\n    |     ^^^^ `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+...\n+LL | fn after() -> impl Fn(i32) {\n+   |               ------------ within this `impl std::ops::Fn<(i32,)>`\n    |\n    = help: within `impl std::ops::Fn<(i32,)>`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n    = note: required because it appears within the type `[closure@$DIR/auto-trait-leak2.rs:24:5: 24:22 p:std::rc::Rc<std::cell::Cell<i32>>]`"}, {"sha": "b882514f61609361c9478ffc6a0d39de9f09e669", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/equality2.rs:25:18\n    |\n+LL | fn hide<T: Foo>(x: T) -> impl Foo {\n+   |                          -------- the found opaque type\n+...\n LL |     let _: u32 = hide(0_u32);\n    |            ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n    |            |\n@@ -12,6 +15,9 @@ LL |     let _: u32 = hide(0_u32);\n error[E0308]: mismatched types\n   --> $DIR/equality2.rs:31:18\n    |\n+LL | fn hide<T: Foo>(x: T) -> impl Foo {\n+   |                          -------- the found opaque type\n+...\n LL |     let _: i32 = Leak::leak(hide(0_i32));\n    |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found associated type\n    |            |\n@@ -25,6 +31,12 @@ LL |     let _: i32 = Leak::leak(hide(0_i32));\n error[E0308]: mismatched types\n   --> $DIR/equality2.rs:38:10\n    |\n+LL | fn hide<T: Foo>(x: T) -> impl Foo {\n+   |                          --------\n+   |                          |\n+   |                          the expected opaque type\n+   |                          the found opaque type\n+...\n LL |     x = (x.1,\n    |          ^^^ expected `u32`, found `i32`\n    |\n@@ -34,6 +46,12 @@ LL |     x = (x.1,\n error[E0308]: mismatched types\n   --> $DIR/equality2.rs:41:10\n    |\n+LL | fn hide<T: Foo>(x: T) -> impl Foo {\n+   |                          --------\n+   |                          |\n+   |                          the expected opaque type\n+   |                          the found opaque type\n+...\n LL |          x.0);\n    |          ^^^ expected `i32`, found `u32`\n    |"}, {"sha": "036c05fc848cf37fc0dbd8c8f91cc634489fc954", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-24036.rs:3:9\n    |\n+LL |     let mut x = |c| c + 1;\n+   |                 --------- the expected closure\n LL |     x = |c| c + 1;\n    |         ^^^^^^^^^ expected closure, found a different closure\n    |"}, {"sha": "39640e373991f06c0030031f7140f14c7f7699d1", "filename": "src/test/ui/kindck/kindck-nonsendable-1.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fkindck%2Fkindck-nonsendable-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fkindck%2Fkindck-nonsendable-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-nonsendable-1.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -5,7 +5,9 @@ LL | fn bar<F:FnOnce() + Send>(_: F) { }\n    |    ---              ---- required by this bound in `bar`\n ...\n LL |     bar(move|| foo(x));\n-   |     ^^^ `std::rc::Rc<usize>` cannot be sent between threads safely\n+   |     ^^^ ------------- within this `[closure@$DIR/kindck-nonsendable-1.rs:9:9: 9:22 x:std::rc::Rc<usize>]`\n+   |     |\n+   |     `std::rc::Rc<usize>` cannot be sent between threads safely\n    |\n    = help: within `[closure@$DIR/kindck-nonsendable-1.rs:9:9: 9:22 x:std::rc::Rc<usize>]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<usize>`\n    = note: required because it appears within the type `[closure@$DIR/kindck-nonsendable-1.rs:9:9: 9:22 x:std::rc::Rc<usize>]`"}, {"sha": "65946ee8a20cf8588ca193830159779fa497e307", "filename": "src/test/ui/no-send-res-ports.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fno-send-res-ports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fno-send-res-ports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-send-res-ports.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,13 +1,20 @@\n error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n   --> $DIR/no-send-res-ports.rs:29:5\n    |\n-LL |     thread::spawn(move|| {\n-   |     ^^^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n+LL |       thread::spawn(move|| {\n+   |  _____^^^^^^^^^^^^^_-\n+   | |     |\n+   | |     `std::rc::Rc<()>` cannot be sent between threads safely\n+LL | |\n+LL | |         let y = x;\n+LL | |         println!(\"{:?}\", y);\n+LL | |     });\n+   | |_____- within this `[closure@$DIR/no-send-res-ports.rs:29:19: 33:6 x:main::Foo]`\n    | \n   ::: $SRC_DIR/libstd/thread/mod.rs:LL:COL\n    |\n-LL |     F: Send + 'static,\n-   |        ---- required by this bound in `std::thread::spawn`\n+LL |       F: Send + 'static,\n+   |          ---- required by this bound in `std::thread::spawn`\n    |\n    = help: within `[closure@$DIR/no-send-res-ports.rs:29:19: 33:6 x:main::Foo]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n    = note: required because it appears within the type `Port<()>`"}, {"sha": "20c7f81cf5ef54a7de923b3570f10fec95fb8860", "filename": "src/test/ui/not-clone-closure.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fnot-clone-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-clone-closure.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,8 +1,14 @@\n error[E0277]: the trait bound `S: std::clone::Clone` is not satisfied in `[closure@$DIR/not-clone-closure.rs:7:17: 9:6 a:S]`\n   --> $DIR/not-clone-closure.rs:11:23\n    |\n-LL |     let hello = hello.clone();\n-   |                       ^^^^^ within `[closure@$DIR/not-clone-closure.rs:7:17: 9:6 a:S]`, the trait `std::clone::Clone` is not implemented for `S`\n+LL |       let hello = move || {\n+   |  _________________-\n+LL | |         println!(\"Hello {}\", a.0);\n+LL | |     };\n+   | |_____- within this `[closure@$DIR/not-clone-closure.rs:7:17: 9:6 a:S]`\n+LL | \n+LL |       let hello = hello.clone();\n+   |                         ^^^^^ within `[closure@$DIR/not-clone-closure.rs:7:17: 9:6 a:S]`, the trait `std::clone::Clone` is not implemented for `S`\n    |\n    = note: required because it appears within the type `[closure@$DIR/not-clone-closure.rs:7:17: 9:6 a:S]`\n "}, {"sha": "7a187a0518af9d7f404c031d1c3be8f25dbf175f", "filename": "src/test/ui/parser/bounds-type.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fparser%2Fbounds-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fparser%2Fbounds-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-type.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -8,6 +8,11 @@ struct S<\n     T: ?for<'a> Trait, // OK\n     T: Tr +, // OK\n     T: ?'a, //~ ERROR `?` may only modify trait bounds, not lifetime bounds\n+\n+    T: ?const Tr, // OK\n+    T: ?const ?Tr, // OK\n+    T: ?const Tr + 'a, // OK\n+    T: ?const 'a, //~ ERROR `?const` may only modify trait bounds, not lifetime bounds\n >;\n \n fn main() {}"}, {"sha": "9a1f2ed398240f48f8da6b140af1848eee8b5fea", "filename": "src/test/ui/parser/bounds-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fparser%2Fbounds-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fparser%2Fbounds-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbounds-type.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -4,5 +4,11 @@ error: `?` may only modify trait bounds, not lifetime bounds\n LL |     T: ?'a,\n    |        ^\n \n-error: aborting due to previous error\n+error: `?const` may only modify trait bounds, not lifetime bounds\n+  --> $DIR/bounds-type.rs:15:8\n+   |\n+LL |     T: ?const 'a,\n+   |        ^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "0bf337ad08dbfe682d8090f1a01023c8783d5696", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.gated.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.gated.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/feature-gate.rs:11:29\n+   |\n+LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n+   |                             ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "cf1ed30da0fcce22b8ca46b32439bf13404338d6", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,15 @@\n+// revisions: stock gated\n+// gate-test-const_trait_bound_opt_out\n+\n+#![cfg_attr(gated, feature(const_trait_bound_opt_out))]\n+#![allow(incomplete_features)]\n+\n+trait T {\n+    const CONST: i32;\n+}\n+\n+const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n+//[stock]~^ ERROR `?const` on trait bounds is experimental\n+//[stock,gated]~^^ ERROR `?const` on trait bounds is not yet implemented\n+\n+fn main() {}"}, {"sha": "64388004b5b72b7fca9b85d8994e4f3b7bf33410", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/feature-gate.stock.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Ffeature-gate.stock.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,18 @@\n+error[E0658]: `?const` on trait bounds is experimental\n+  --> $DIR/feature-gate.rs:11:29\n+   |\n+LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n+   |                             ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67794\n+   = help: add `#![feature(const_trait_bound_opt_out)]` to the crate attributes to enable\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/feature-gate.rs:11:29\n+   |\n+LL | const fn get_assoc_const<S: ?const T>() -> i32 { <S as T>::CONST }\n+   |                             ^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e4e6bedd93746b5b257e591719885360741fba13", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-impl-trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,25 @@\n+#![feature(const_trait_bound_opt_out)]\n+#![feature(associated_type_bounds)]\n+#![allow(incomplete_features)]\n+\n+trait T {}\n+struct S;\n+impl T for S {}\n+\n+fn rpit() -> impl ?const T { S }\n+//~^ ERROR `?const` is not permitted in `impl Trait`\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn apit(_: impl ?const T) {}\n+//~^ ERROR `?const` is not permitted in `impl Trait`\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n+//~^ ERROR `?const` is not permitted in `impl Trait`\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n+//~^ ERROR `?const` is not permitted in `impl Trait`\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn main() {}"}, {"sha": "f4abd4b714e8a2a3da06d8db048a2ac98b027f7f", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-impl-trait.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-impl-trait.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,50 @@\n+error: `?const` is not permitted in `impl Trait`\n+  --> $DIR/in-impl-trait.rs:9:19\n+   |\n+LL | fn rpit() -> impl ?const T { S }\n+   |                   ^^^^^^^^\n+\n+error: `?const` is not permitted in `impl Trait`\n+  --> $DIR/in-impl-trait.rs:13:17\n+   |\n+LL | fn apit(_: impl ?const T) {}\n+   |                 ^^^^^^^^\n+\n+error: `?const` is not permitted in `impl Trait`\n+  --> $DIR/in-impl-trait.rs:17:50\n+   |\n+LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n+   |                                                  ^^^^^^^^\n+\n+error: `?const` is not permitted in `impl Trait`\n+  --> $DIR/in-impl-trait.rs:21:48\n+   |\n+LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n+   |                                                ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-impl-trait.rs:9:19\n+   |\n+LL | fn rpit() -> impl ?const T { S }\n+   |                   ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-impl-trait.rs:13:17\n+   |\n+LL | fn apit(_: impl ?const T) {}\n+   |                 ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-impl-trait.rs:17:50\n+   |\n+LL | fn rpit_assoc_bound() -> impl IntoIterator<Item: ?const T> { Some(S) }\n+   |                                                  ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-impl-trait.rs:21:48\n+   |\n+LL | fn apit_assoc_bound(_: impl IntoIterator<Item: ?const T>) {}\n+   |                                                ^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "4523b46bc51f6e31a06ad2b8693891134cbc48c0", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-bounds.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+\n+trait Super {}\n+trait T: ?const Super {}\n+//~^ ERROR `?const` is not permitted in supertraits\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn main() {}"}, {"sha": "8003361be7d2efacc3df4a1fcb750a6cf7a2d6b9", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-bounds.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-bounds.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,14 @@\n+error: `?const` is not permitted in supertraits\n+  --> $DIR/in-trait-bounds.rs:5:10\n+   |\n+LL | trait T: ?const Super {}\n+   |          ^^^^^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-trait-bounds.rs:5:10\n+   |\n+LL | trait T: ?const Super {}\n+   |          ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6cfca7154867485c58159a5c1a27b731084e05bd", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-object.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(bare_trait_objects)]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+trait T {}\n+impl T for S {}\n+\n+// An inherent impl for the trait object `?const T`.\n+impl ?const T {}\n+//~^ ERROR `?const` is not permitted in trait objects\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn trait_object() -> &'static dyn ?const T { &S }\n+//~^ ERROR `?const` is not permitted in trait objects\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n+//~^ ERROR `?const` is not permitted in trait objects\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn main() {}"}, {"sha": "c059f16902250c1bd74d870c2729988065f02071", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/in-trait-object.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fin-trait-object.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,38 @@\n+error: `?const` is not permitted in trait objects\n+  --> $DIR/in-trait-object.rs:10:6\n+   |\n+LL | impl ?const T {}\n+   |      ^^^^^^^^\n+\n+error: `?const` is not permitted in trait objects\n+  --> $DIR/in-trait-object.rs:14:35\n+   |\n+LL | fn trait_object() -> &'static dyn ?const T { &S }\n+   |                                   ^^^^^^^^\n+\n+error: `?const` is not permitted in trait objects\n+  --> $DIR/in-trait-object.rs:18:61\n+   |\n+LL | fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n+   |                                                             ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-trait-object.rs:10:6\n+   |\n+LL | impl ?const T {}\n+   |      ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-trait-object.rs:14:35\n+   |\n+LL | fn trait_object() -> &'static dyn ?const T { &S }\n+   |                                   ^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/in-trait-object.rs:18:61\n+   |\n+LL | fn trait_object_in_apit(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n+   |                                                             ^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "01e941a8fba451fe03f59f59041d29a1c4fa1af2", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/opt-out-twice.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Z parse-only\n+\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+\n+struct S<T: ?const ?const Tr>;\n+//~^ ERROR expected identifier, found keyword `const`\n+//~| ERROR expected one of `(`, `+`, `,`, `::`, `<`, `=`, or `>`"}, {"sha": "f7924b3f24db39a0b176323c00824bdfca18d3d5", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/opt-out-twice.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fopt-out-twice.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,14 @@\n+error: expected identifier, found keyword `const`\n+  --> $DIR/opt-out-twice.rs:6:21\n+   |\n+LL | struct S<T: ?const ?const Tr>;\n+   |                     ^^^^^ expected identifier, found keyword\n+\n+error: expected one of `(`, `+`, `,`, `::`, `<`, `=`, or `>`, found `Tr`\n+  --> $DIR/opt-out-twice.rs:6:27\n+   |\n+LL | struct S<T: ?const ?const Tr>;\n+   |                           ^^ expected one of 7 possible tokens\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a0d9610bbb5e2b6517648d34923757c46894be62", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/syntax.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fsyntax.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Z parse-only\n+// check-pass\n+\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+\n+struct S<\n+    T: ?const ?for<'a> Tr<'a> + 'static + ?const std::ops::Add,\n+    T: ?const ?for<'a: 'b> m::Trait<'a>,\n+>;"}, {"sha": "425784f4e4326aa955b2cf36df8741d0489a6844", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/with-maybe-sized.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+\n+struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n+//~^ ERROR `?const` and `?` are mutually exclusive\n+//~| ERROR `?const` on trait bounds is not yet implemented\n+\n+fn main() {}"}, {"sha": "44f6d464ae6a83fac168c206f2e4428f8f835850", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/with-maybe-sized.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwith-maybe-sized.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,14 @@\n+error: `?const` and `?` are mutually exclusive\n+  --> $DIR/with-maybe-sized.rs:4:13\n+   |\n+LL | struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n+   |             ^^^^^^^^^^^^^\n+\n+error: `?const` on trait bounds is not yet implemented\n+  --> $DIR/with-maybe-sized.rs:4:13\n+   |\n+LL | struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n+   |             ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b904a2eec0dd0f531e998be78a2694059869f0f5", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/without-question-mark.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,7 @@\n+// compile-flags: -Z parse-only\n+\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+\n+struct S<T: const Tr>;\n+//~^ ERROR expected one of `!`, `(`, `,`, `=`, `>`, `?`, `for`, lifetime, or path"}, {"sha": "0dbca952c037ec8161df6a9bcc3a94d56328916a", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-trait-bound-opt-out/without-question-mark.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-trait-bound-opt-out%2Fwithout-question-mark.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `!`, `(`, `,`, `=`, `>`, `?`, `for`, lifetime, or path, found keyword `const`\n+  --> $DIR/without-question-mark.rs:6:13\n+   |\n+LL | struct S<T: const Tr>;\n+   |             ^^^^^ expected one of 9 possible tokens\n+\n+error: aborting due to previous error\n+"}, {"sha": "b196f9ef57380b255985db6f25379722c03105e2", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.gated.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.gated.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+error: const trait impls are not yet implemented\n+  --> $DIR/feature-gate.rs:9:1\n+   |\n+LL | impl const T for S {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "49b6c0926c50c18c2f940d2acc53cf7a5fa01303", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,13 @@\n+// revisions: stock gated\n+// gate-test-const_trait_impl\n+\n+#![cfg_attr(gated, feature(const_trait_impl))]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+trait T {}\n+impl const T for S {}\n+//[stock]~^ ERROR const trait impls are experimental\n+//[stock,gated]~^^ ERROR const trait impls are not yet implemented\n+\n+fn main() {}"}, {"sha": "093946f859ac36ab145bd830924cdced64253077", "filename": "src/test/ui/rfc-2632-const-trait-impl/feature-gate.stock.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ffeature-gate.stock.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,18 @@\n+error[E0658]: const trait impls are experimental\n+  --> $DIR/feature-gate.rs:9:6\n+   |\n+LL | impl const T for S {}\n+   |      ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/67792\n+   = help: add `#![feature(const_trait_impl)]` to the crate attributes to enable\n+\n+error: const trait impls are not yet implemented\n+  --> $DIR/feature-gate.rs:9:1\n+   |\n+LL | impl const T for S {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "98d3a220d8674d8b98f7eae5a3a2c52f5c3a291e", "filename": "src/test/ui/rfc-2632-const-trait-impl/impl-opt-out-trait.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_trait_bound_opt_out)]\n+#![feature(const_trait_impl)]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+trait T {}\n+\n+impl ?const T for S {}\n+//~^ ERROR expected a trait, found type\n+\n+fn main() {}"}, {"sha": "8f923efb093f3f0feffae3c9e765a661b0535a93", "filename": "src/test/ui/rfc-2632-const-trait-impl/impl-opt-out-trait.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-opt-out-trait.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,8 @@\n+error: expected a trait, found type\n+  --> $DIR/impl-opt-out-trait.rs:8:6\n+   |\n+LL | impl ?const T for S {}\n+   |      ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9cffe75addd63b76bbabc2874047119bca8ab4df", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Z parse-only\n+\n+#![feature(const_trait_impl)]\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n+#![allow(bare_trait_objects)]\n+\n+struct S;\n+trait T {}\n+\n+impl const T {}\n+//~^ ERROR `const` cannot modify an inherent impl\n+\n+fn main() {}"}, {"sha": "1d245576559513774c0f1ecea0c21f19e1b6be66", "filename": "src/test/ui/rfc-2632-const-trait-impl/inherent-impl.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Finherent-impl.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,10 @@\n+error: `const` cannot modify an inherent impl\n+  --> $DIR/inherent-impl.rs:11:6\n+   |\n+LL | impl const T {}\n+   |      ^^^^^\n+   |\n+   = help: only a trait impl can be `const`\n+\n+error: aborting due to previous error\n+"}, {"sha": "354d48d630f7b6c14a6d0b6e2a78005c8af5b91d", "filename": "src/test/ui/rfc-2632-const-trait-impl/syntax.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fsyntax.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -Z parse-only\n+// check-pass\n+\n+#![feature(const_trait_bound_opt_out)]\n+#![feature(const_trait_impl)]\n+#![allow(incomplete_features)]\n+\n+// For now, this parses since an error does not occur until AST lowering.\n+impl ?const T {}"}, {"sha": "232e54b5d37b24e2b2bb90e73dfd46ca6e14c4bf", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -236,7 +236,7 @@ error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:46:20\n    |\n LL |     let closure = || 42;\n-   |                   -- closure defined here\n+   |                   ----- the found closure\n LL |     let _: usize = closure;\n    |            -----   ^^^^^^^\n    |            |       |"}, {"sha": "167d61bdf7c704f176d8097b567b78dff3d61272", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/opaque-type-error.rs:20:9\n    |\n+LL |   fn thing_two() -> impl Future<Output = Result<(), ()>> {\n+   |                     ------------------------------------ the found opaque type\n+...\n LL | /     if true {\n LL | |         thing_one()\n    | |         ----------- expected because of this"}, {"sha": "9549074d4bf78d73650b511c95330ed9624b43cb", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -11,6 +11,9 @@ LL |     let z: i32 = x;\n    |            ---   ^ expected `i32`, found opaque type\n    |            |\n    |            expected due to this\n+...\n+LL | type WrongGeneric<T> = impl 'static;\n+   | ------------------------------------ the found opaque type\n    |\n    = note:     expected type `i32`\n            found opaque type `WrongGeneric::<&{integer}>`"}, {"sha": "5a7f9d74eba5b31ef38fb701c781deec6088c83b", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -11,6 +11,9 @@ LL |     let z: i32 = x;\n    |            ---   ^ expected `i32`, found opaque type\n    |            |\n    |            expected due to this\n+...\n+LL | type WrongGeneric<T> = impl 'static;\n+   | ------------------------------------ the found opaque type\n    |\n    = note:     expected type `i32`\n            found opaque type `WrongGeneric::<&{integer}>`"}, {"sha": "70c99c944d654d8f142f6c6992274b9f31b7cc45", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/never_reveal_concrete_type.rs:13:27\n    |\n+LL | type NoReveal = impl std::fmt::Debug;\n+   | ------------------------------------- the found opaque type\n+...\n LL |     let _: &'static str = x;\n    |            ------------   ^ expected `&str`, found opaque type\n    |            |"}, {"sha": "375c0bc7fe2ed078985862c3d54fc04778d6887d", "filename": "src/test/ui/type-alias-impl-trait/no_revealing_outside_defining_module.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/no_revealing_outside_defining_module.rs:15:19\n    |\n+LL |     pub type Boo = impl ::std::fmt::Debug;\n+   |     -------------------------------------- the found opaque type\n+...\n LL |     let _: &str = bomp();\n    |            ----   ^^^^^^ expected `&str`, found opaque type\n    |            |\n@@ -12,6 +15,9 @@ LL |     let _: &str = bomp();\n error[E0308]: mismatched types\n   --> $DIR/no_revealing_outside_defining_module.rs:19:5\n    |\n+LL |     pub type Boo = impl ::std::fmt::Debug;\n+   |     -------------------------------------- the expected opaque type\n+...\n LL | fn bomp() -> boo::Boo {\n    |              -------- expected `Boo` because of return type\n LL |     \"\""}, {"sha": "adecbd7e5b40ea24cfa447dad7edd77e43ddaaf4", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,3 +1,4 @@\n+#![feature(type_alias_impl_trait)] // Needed for single test `type Y = impl Trait<_>`\n // This test checks that it is not possible to enable global type\n // inference by using the `_` type placeholder.\n \n@@ -42,6 +43,16 @@ impl Test9 {\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n }\n \n+fn test11(x: &usize) -> &_ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    &x\n+}\n+\n+unsafe fn test12(x: *const usize) -> *const *const _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    &x\n+}\n+\n impl Clone for Test9 {\n     fn clone(&self) -> _ { Test9 }\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n@@ -131,3 +142,37 @@ trait T {\n     fn assoc_fn_test3() -> _;\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n }\n+\n+struct BadStruct<_>(_);\n+//~^ ERROR expected identifier, found reserved identifier `_`\n+//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n+trait BadTrait<_> {}\n+//~^ ERROR expected identifier, found reserved identifier `_`\n+impl BadTrait<_> for BadStruct<_> {}\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+fn impl_trait() -> impl BadTrait<_> {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    unimplemented!()\n+}\n+\n+struct BadStruct1<_, _>(_);\n+//~^ ERROR expected identifier, found reserved identifier `_`\n+//~| ERROR expected identifier, found reserved identifier `_`\n+//~| ERROR the name `_` is already used\n+//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n+struct BadStruct2<_, T>(_, T);\n+//~^ ERROR expected identifier, found reserved identifier `_`\n+//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+type X = Box<_>;\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+struct Struct;\n+trait Trait<T> {}\n+impl Trait<usize> for Struct {}\n+type Y = impl Trait<_>;\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+fn foo() -> Y {\n+    Struct\n+}"}, {"sha": "05326a3e07a9324c302cb3563c644dc5a86005ab", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 200, "deletions": 80, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d8d559bbecf6272eb41f8a800e319238aa9d621/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=2d8d559bbecf6272eb41f8a800e319238aa9d621", "patch": "@@ -1,5 +1,43 @@\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/typeck_type_placeholder_item.rs:146:18\n+   |\n+LL | struct BadStruct<_>(_);\n+   |                  ^ expected identifier, found reserved identifier\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/typeck_type_placeholder_item.rs:149:16\n+   |\n+LL | trait BadTrait<_> {}\n+   |                ^ expected identifier, found reserved identifier\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/typeck_type_placeholder_item.rs:159:19\n+   |\n+LL | struct BadStruct1<_, _>(_);\n+   |                   ^ expected identifier, found reserved identifier\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/typeck_type_placeholder_item.rs:159:22\n+   |\n+LL | struct BadStruct1<_, _>(_);\n+   |                      ^ expected identifier, found reserved identifier\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/typeck_type_placeholder_item.rs:164:19\n+   |\n+LL | struct BadStruct2<_, T>(_, T);\n+   |                   ^ expected identifier, found reserved identifier\n+\n+error[E0403]: the name `_` is already used for a generic parameter in this item's generic parameters\n+  --> $DIR/typeck_type_placeholder_item.rs:159:22\n+   |\n+LL | struct BadStruct1<_, _>(_);\n+   |                   -  ^ already used\n+   |                   |\n+   |                   first use of `_`\n+\n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:4:14\n+  --> $DIR/typeck_type_placeholder_item.rs:5:14\n    |\n LL | fn test() -> _ { 5 }\n    |              ^\n@@ -8,7 +46,7 @@ LL | fn test() -> _ { 5 }\n    |              help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:7:16\n+  --> $DIR/typeck_type_placeholder_item.rs:8:16\n    |\n LL | fn test2() -> (_, _) { (5, 5) }\n    |               -^--^-\n@@ -18,7 +56,7 @@ LL | fn test2() -> (_, _) { (5, 5) }\n    |               help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:10:15\n+  --> $DIR/typeck_type_placeholder_item.rs:11:15\n    |\n LL | static TEST3: _ = \"test\";\n    |               ^\n@@ -27,7 +65,7 @@ LL | static TEST3: _ = \"test\";\n    |               help: replace `_` with the correct type: `&'static str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:13:15\n+  --> $DIR/typeck_type_placeholder_item.rs:14:15\n    |\n LL | static TEST4: _ = 145;\n    |               ^\n@@ -36,13 +74,13 @@ LL | static TEST4: _ = 145;\n    |               help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:16:15\n+  --> $DIR/typeck_type_placeholder_item.rs:17:15\n    |\n LL | static TEST5: (_, _) = (1, 2);\n    |               ^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:19:13\n+  --> $DIR/typeck_type_placeholder_item.rs:20:13\n    |\n LL | fn test6(_: _) { }\n    |             ^ not allowed in type signatures\n@@ -53,7 +91,7 @@ LL | fn test6<T>(_: T) { }\n    |         ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:22:18\n+  --> $DIR/typeck_type_placeholder_item.rs:23:18\n    |\n LL | fn test6_b<T>(_: _, _: T) { }\n    |                  ^ not allowed in type signatures\n@@ -64,7 +102,7 @@ LL | fn test6_b<T, K>(_: K, _: T) { }\n    |             ^^^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:25:30\n+  --> $DIR/typeck_type_placeholder_item.rs:26:30\n    |\n LL | fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n    |                              ^ not allowed in type signatures\n@@ -75,7 +113,7 @@ LL | fn test6_c<T, K, L, A, B, C>(_: C, _: (T, K, L, A, B)) { }\n    |                         ^^^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:28:13\n+  --> $DIR/typeck_type_placeholder_item.rs:29:13\n    |\n LL | fn test7(x: _) { let _x: usize = x; }\n    |             ^ not allowed in type signatures\n@@ -86,13 +124,13 @@ LL | fn test7<T>(x: T) { let _x: usize = x; }\n    |         ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:31:22\n+  --> $DIR/typeck_type_placeholder_item.rs:32:22\n    |\n LL | fn test8(_f: fn() -> _) { }\n    |                      ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:31:22\n+  --> $DIR/typeck_type_placeholder_item.rs:32:22\n    |\n LL | fn test8(_f: fn() -> _) { }\n    |                      ^ not allowed in type signatures\n@@ -103,7 +141,25 @@ LL | fn test8<T>(_f: fn() -> T) { }\n    |         ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:54:8\n+  --> $DIR/typeck_type_placeholder_item.rs:46:26\n+   |\n+LL | fn test11(x: &usize) -> &_ {\n+   |                         -^\n+   |                         ||\n+   |                         |not allowed in type signatures\n+   |                         help: replace with the correct return type: `&&usize`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:51:52\n+   |\n+LL | unsafe fn test12(x: *const usize) -> *const *const _ {\n+   |                                      --------------^\n+   |                                      |             |\n+   |                                      |             not allowed in type signatures\n+   |                                      help: replace with the correct return type: `*const *const usize`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:65:8\n    |\n LL |     a: _,\n    |        ^ not allowed in type signatures\n@@ -122,7 +178,7 @@ LL |     b: (T, T),\n    |\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:60:21\n+  --> $DIR/typeck_type_placeholder_item.rs:71:21\n    |\n LL |     fn fn_test() -> _ { 5 }\n    |                     ^\n@@ -131,7 +187,7 @@ LL |     fn fn_test() -> _ { 5 }\n    |                     help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:63:23\n+  --> $DIR/typeck_type_placeholder_item.rs:74:23\n    |\n LL |     fn fn_test2() -> (_, _) { (5, 5) }\n    |                      -^--^-\n@@ -141,7 +197,7 @@ LL |     fn fn_test2() -> (_, _) { (5, 5) }\n    |                      help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:66:22\n+  --> $DIR/typeck_type_placeholder_item.rs:77:22\n    |\n LL |     static FN_TEST3: _ = \"test\";\n    |                      ^\n@@ -150,7 +206,7 @@ LL |     static FN_TEST3: _ = \"test\";\n    |                      help: replace `_` with the correct type: `&'static str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:69:22\n+  --> $DIR/typeck_type_placeholder_item.rs:80:22\n    |\n LL |     static FN_TEST4: _ = 145;\n    |                      ^\n@@ -159,13 +215,13 @@ LL |     static FN_TEST4: _ = 145;\n    |                      help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:72:22\n+  --> $DIR/typeck_type_placeholder_item.rs:83:22\n    |\n LL |     static FN_TEST5: (_, _) = (1, 2);\n    |                      ^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:75:20\n+  --> $DIR/typeck_type_placeholder_item.rs:86:20\n    |\n LL |     fn fn_test6(_: _) { }\n    |                    ^ not allowed in type signatures\n@@ -176,7 +232,7 @@ LL |     fn fn_test6<T>(_: T) { }\n    |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:78:20\n+  --> $DIR/typeck_type_placeholder_item.rs:89:20\n    |\n LL |     fn fn_test7(x: _) { let _x: usize = x; }\n    |                    ^ not allowed in type signatures\n@@ -187,13 +243,13 @@ LL |     fn fn_test7<T>(x: T) { let _x: usize = x; }\n    |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:81:29\n+  --> $DIR/typeck_type_placeholder_item.rs:92:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n    |                             ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:81:29\n+  --> $DIR/typeck_type_placeholder_item.rs:92:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n    |                             ^ not allowed in type signatures\n@@ -204,7 +260,7 @@ LL |     fn fn_test8<T>(_f: fn() -> T) { }\n    |                ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:104:12\n+  --> $DIR/typeck_type_placeholder_item.rs:115:12\n    |\n LL |         a: _,\n    |            ^ not allowed in type signatures\n@@ -223,21 +279,21 @@ LL |         b: (T, T),\n    |\n \n error[E0282]: type annotations needed\n-  --> $DIR/typeck_type_placeholder_item.rs:109:27\n+  --> $DIR/typeck_type_placeholder_item.rs:120:27\n    |\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                           ^^^^^^ cannot infer type\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:109:28\n+  --> $DIR/typeck_type_placeholder_item.rs:120:28\n    |\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                            ^  ^ not allowed in type signatures\n    |                            |\n    |                            not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:113:30\n+  --> $DIR/typeck_type_placeholder_item.rs:124:30\n    |\n LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n    |                             -^--^-\n@@ -247,7 +303,7 @@ LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n    |                             help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:116:33\n+  --> $DIR/typeck_type_placeholder_item.rs:127:33\n    |\n LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n    |                           ------^-\n@@ -256,7 +312,76 @@ LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n    |                           help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:121:31\n+  --> $DIR/typeck_type_placeholder_item.rs:146:21\n+   |\n+LL | struct BadStruct<_>(_);\n+   |                     ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | struct BadStruct<T>(T);\n+   |                  ^  ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:151:15\n+   |\n+LL | impl BadTrait<_> for BadStruct<_> {}\n+   |               ^                ^ not allowed in type signatures\n+   |               |\n+   |               not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | impl<T> BadTrait<T> for BadStruct<T> {}\n+   |     ^^^          ^                ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:154:34\n+   |\n+LL | fn impl_trait() -> impl BadTrait<_> {\n+   |                                  ^ not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:159:25\n+   |\n+LL | struct BadStruct1<_, _>(_);\n+   |                         ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | struct BadStruct1<T, _>(T);\n+   |                   ^     ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:164:25\n+   |\n+LL | struct BadStruct2<_, T>(_, T);\n+   |                         ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | struct BadStruct2<K, T>(K, T);\n+   |                   ^     ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:168:14\n+   |\n+LL | type X = Box<_>;\n+   |              ^ not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:42:27\n+   |\n+LL |     fn test10(&self, _x : _) { }\n+   |                           ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn test10<T>(&self, _x : T) { }\n+   |              ^^^             ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:132:31\n    |\n LL |     fn method_test1(&self, x: _);\n    |                               ^ not allowed in type signatures\n@@ -267,7 +392,7 @@ LL |     fn method_test1<T>(&self, x: T);\n    |                    ^^^           ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:123:31\n+  --> $DIR/typeck_type_placeholder_item.rs:134:31\n    |\n LL |     fn method_test2(&self, x: _) -> _;\n    |                               ^     ^ not allowed in type signatures\n@@ -280,7 +405,7 @@ LL |     fn method_test2<T>(&self, x: T) -> T;\n    |                    ^^^           ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:125:31\n+  --> $DIR/typeck_type_placeholder_item.rs:136:31\n    |\n LL |     fn method_test3(&self) -> _;\n    |                               ^ not allowed in type signatures\n@@ -291,7 +416,7 @@ LL |     fn method_test3<T>(&self) -> T;\n    |                    ^^^           ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:127:26\n+  --> $DIR/typeck_type_placeholder_item.rs:138:26\n    |\n LL |     fn assoc_fn_test1(x: _);\n    |                          ^ not allowed in type signatures\n@@ -302,7 +427,7 @@ LL |     fn assoc_fn_test1<T>(x: T);\n    |                      ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:129:26\n+  --> $DIR/typeck_type_placeholder_item.rs:140:26\n    |\n LL |     fn assoc_fn_test2(x: _) -> _;\n    |                          ^     ^ not allowed in type signatures\n@@ -315,7 +440,7 @@ LL |     fn assoc_fn_test2<T>(x: T) -> T;\n    |                      ^^^    ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:131:28\n+  --> $DIR/typeck_type_placeholder_item.rs:142:28\n    |\n LL |     fn assoc_fn_test3() -> _;\n    |                            ^ not allowed in type signatures\n@@ -326,47 +451,64 @@ LL |     fn assoc_fn_test3<T>() -> T;\n    |                      ^^^      ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:38:24\n+  --> $DIR/typeck_type_placeholder_item.rs:60:37\n    |\n-LL |     fn test9(&self) -> _ { () }\n-   |                        ^\n-   |                        |\n-   |                        not allowed in type signatures\n-   |                        help: replace with the correct return type: `()`\n+LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n+   |                                     ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n+   |                  ^^^                   ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:41:27\n+  --> $DIR/typeck_type_placeholder_item.rs:102:34\n    |\n-LL |     fn test10(&self, _x : _) { }\n-   |                           ^ not allowed in type signatures\n+LL |         fn fn_test10(&self, _x : _) { }\n+   |                                  ^ not allowed in type signatures\n    |\n help: use type parameters instead\n    |\n-LL |     fn test10<T>(&self, _x : T) { }\n-   |              ^^^             ^\n+LL |         fn fn_test10<T>(&self, _x : T) { }\n+   |                     ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:46:24\n+  --> $DIR/typeck_type_placeholder_item.rs:110:41\n    |\n-LL |     fn clone(&self) -> _ { Test9 }\n+LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n+   |                                         ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n+   |                      ^^^                   ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:174:21\n+   |\n+LL | type Y = impl Trait<_>;\n+   |                     ^ not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:39:24\n+   |\n+LL |     fn test9(&self) -> _ { () }\n    |                        ^\n    |                        |\n    |                        not allowed in type signatures\n-   |                        help: replace with the correct return type: `Test9`\n+   |                        help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:49:37\n+  --> $DIR/typeck_type_placeholder_item.rs:57:24\n    |\n-LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n-   |                                     ^ not allowed in type signatures\n-   |\n-help: use type parameters instead\n-   |\n-LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n-   |                  ^^^                   ^\n+LL |     fn clone(&self) -> _ { Test9 }\n+   |                        ^\n+   |                        |\n+   |                        not allowed in type signatures\n+   |                        help: replace with the correct return type: `Test9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:88:31\n+  --> $DIR/typeck_type_placeholder_item.rs:99:31\n    |\n LL |         fn fn_test9(&self) -> _ { () }\n    |                               ^\n@@ -375,37 +517,15 @@ LL |         fn fn_test9(&self) -> _ { () }\n    |                               help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:91:34\n-   |\n-LL |         fn fn_test10(&self, _x : _) { }\n-   |                                  ^ not allowed in type signatures\n-   |\n-help: use type parameters instead\n-   |\n-LL |         fn fn_test10<T>(&self, _x : T) { }\n-   |                     ^^^             ^\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:96:28\n+  --> $DIR/typeck_type_placeholder_item.rs:107:28\n    |\n LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            ^\n    |                            |\n    |                            not allowed in type signatures\n    |                            help: replace with the correct return type: `main::FnTest9`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:99:41\n-   |\n-LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n-   |                                         ^ not allowed in type signatures\n-   |\n-help: use type parameters instead\n-   |\n-LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n-   |                      ^^^                   ^\n-\n-error: aborting due to 40 previous errors\n+error: aborting due to 55 previous errors\n \n-Some errors have detailed explanations: E0121, E0282.\n+Some errors have detailed explanations: E0121, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}]}