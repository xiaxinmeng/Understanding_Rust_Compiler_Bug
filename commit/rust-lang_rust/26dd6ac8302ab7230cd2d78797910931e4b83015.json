{"sha": "26dd6ac8302ab7230cd2d78797910931e4b83015", "node_id": "C_kwDOAAsO6NoAKDI2ZGQ2YWM4MzAyYWI3MjMwY2QyZDc4Nzk3OTEwOTMxZTRiODMwMTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-19T05:45:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-19T05:45:30Z"}, "message": "Rollup merge of #93979 - SUPERCILEX:debug_check, r=dtolnay\n\nAdd debug assertions to validate NUL terminator in c strings\n\nThe `unchecked` variants from the stdlib usually perform the check anyway if debug assertions are on (for example, `unwrap_unchecked`). This PR does the same thing for `CStr` and `CString`, validating the correctness for the NUL byte in debug mode.", "tree": {"sha": "6a95f972dad56e61042c0636661de36f7eb9219d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a95f972dad56e61042c0636661de36f7eb9219d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26dd6ac8302ab7230cd2d78797910931e4b83015", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiEIP7CRBK7hj4Ov3rIwAAnkcIAHQLDcSmnoDvDX0TNuSd7+5h\nz3UPKzqYjrcnENRizwUv3z6B5wLRa5Zg/lHWZ/ZFaeItVFsU2caX/1e97G/R9oCQ\nSvH4fSl8MXSl2ZSqFua1PuRUJ+dFi0CyzTLekZEqDhufrcwirx5dFECYpH5+j+Vc\nRKoPRQdi11QYMfwE7YA3wqZgUAVC/BKCjY1CAx3FqenmBdi8sX0FPRLCoqYoA6R4\nrY4cu1+Ozd0xdvdO5dpQ8Xxq9n5zhpnc4YWPs5ulTK5Wy1ZwThZYH5jxuBTbqVDE\ns/DW74glZTTNDVIyqN2vCugNEm5l9rUsbTG6KTKm9ju5ICpjaYvdswRTXFhaQ9U=\n=4rAc\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a95f972dad56e61042c0636661de36f7eb9219d\nparent 554aea90b8e382678de0e87e07210af19f67f0ab\nparent 897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645249530 +0100\ncommitter GitHub <noreply@github.com> 1645249530 +0100\n\nRollup merge of #93979 - SUPERCILEX:debug_check, r=dtolnay\n\nAdd debug assertions to validate NUL terminator in c strings\n\nThe `unchecked` variants from the stdlib usually perform the check anyway if debug assertions are on (for example, `unwrap_unchecked`). This PR does the same thing for `CStr` and `CString`, validating the correctness for the NUL byte in debug mode.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26dd6ac8302ab7230cd2d78797910931e4b83015", "html_url": "https://github.com/rust-lang/rust/commit/26dd6ac8302ab7230cd2d78797910931e4b83015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26dd6ac8302ab7230cd2d78797910931e4b83015/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554aea90b8e382678de0e87e07210af19f67f0ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/554aea90b8e382678de0e87e07210af19f67f0ab", "html_url": "https://github.com/rust-lang/rust/commit/554aea90b8e382678de0e87e07210af19f67f0ab"}, {"sha": "897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc", "html_url": "https://github.com/rust-lang/rust/commit/897c8d0ab9d3cb2cf1c112f31c6ac3e93d9884bc"}], "stats": {"total": 49, "additions": 29, "deletions": 20}, "files": [{"sha": "1678367290e5103d1b85f2a5a3edc3a7f6a7904e", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26dd6ac8302ab7230cd2d78797910931e4b83015/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dd6ac8302ab7230cd2d78797910931e4b83015/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=26dd6ac8302ab7230cd2d78797910931e4b83015", "patch": "@@ -382,7 +382,7 @@ impl CString {\n                 let bytes: Vec<u8> = self.into();\n                 match memchr::memchr(0, &bytes) {\n                     Some(i) => Err(NulError(i, bytes)),\n-                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                    None => Ok(unsafe { CString::_from_vec_unchecked(bytes) }),\n                 }\n             }\n         }\n@@ -405,7 +405,7 @@ impl CString {\n             // This allows better optimizations if lto enabled.\n             match memchr::memchr(0, bytes) {\n                 Some(i) => Err(NulError(i, buffer)),\n-                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n+                None => Ok(unsafe { CString::_from_vec_unchecked(buffer) }),\n             }\n         }\n \n@@ -451,10 +451,15 @@ impl CString {\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n+    pub unsafe fn from_vec_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).is_none());\n+        unsafe { Self::_from_vec_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_unchecked(mut v: Vec<u8>) -> Self {\n         v.reserve_exact(1);\n         v.push(0);\n-        CString { inner: v.into_boxed_slice() }\n+        Self { inner: v.into_boxed_slice() }\n     }\n \n     /// Retakes ownership of a `CString` that was transferred to C via\n@@ -578,7 +583,7 @@ impl CString {\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes()).map_err(|e| IntoStringError {\n             error: e.utf8_error(),\n-            inner: unsafe { CString::from_vec_unchecked(e.into_bytes()) },\n+            inner: unsafe { Self::_from_vec_unchecked(e.into_bytes()) },\n         })\n     }\n \n@@ -735,6 +740,11 @@ impl CString {\n     #[must_use]\n     #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n+        debug_assert!(memchr::memchr(0, &v).unwrap() + 1 == v.len());\n+        unsafe { Self::_from_vec_with_nul_unchecked(v) }\n+    }\n+\n+    unsafe fn _from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n         Self { inner: v.into_boxed_slice() }\n     }\n \n@@ -778,7 +788,7 @@ impl CString {\n             Some(nul_pos) if nul_pos + 1 == v.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the vec.\n-                Ok(unsafe { Self::from_vec_with_nul_unchecked(v) })\n+                Ok(unsafe { Self::_from_vec_with_nul_unchecked(v) })\n             }\n             Some(nul_pos) => Err(FromVecWithNulError {\n                 error_kind: FromBytesWithNulErrorKind::InteriorNul(nul_pos),\n@@ -811,7 +821,7 @@ impl ops::Deref for CString {\n \n     #[inline]\n     fn deref(&self) -> &CStr {\n-        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n+        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n     }\n }\n \n@@ -928,7 +938,7 @@ impl From<Vec<NonZeroU8>> for CString {\n             };\n             // SAFETY: `v` cannot contain null bytes, given the type-level\n             // invariant of `NonZeroU8`.\n-            CString::from_vec_unchecked(v)\n+            Self::_from_vec_unchecked(v)\n         }\n     }\n }\n@@ -1225,7 +1235,7 @@ impl CStr {\n         unsafe {\n             let len = sys::strlen(ptr);\n             let ptr = ptr as *const u8;\n-            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n         }\n     }\n \n@@ -1268,7 +1278,7 @@ impl CStr {\n             Some(nul_pos) if nul_pos + 1 == bytes.len() => {\n                 // SAFETY: We know there is only one nul byte, at the end\n                 // of the byte slice.\n-                Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n+                Ok(unsafe { Self::_from_bytes_with_nul_unchecked(bytes) })\n             }\n             Some(nul_pos) => Err(FromBytesWithNulError::interior_nul(nul_pos)),\n             None => Err(FromBytesWithNulError::not_nul_terminated()),\n@@ -1297,12 +1307,19 @@ impl CStr {\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n+        // We're in a const fn, so this is the best we can do\n+        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n+        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n+    }\n+\n+    #[inline]\n+    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &Self {\n         // SAFETY: Casting to CStr is safe because its internal representation\n         // is a [u8] too (safe only inside std).\n         // Dereferencing the obtained pointer is safe because it comes from a\n         // reference. Making a reference is then safe because its lifetime\n         // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        unsafe { &*(bytes as *const [u8] as *const Self) }\n     }\n \n     /// Returns the inner pointer to this C string.\n@@ -1566,7 +1583,7 @@ impl ops::Index<ops::RangeFrom<usize>> for CStr {\n         // byte, since otherwise we could get an empty string that doesn't end\n         // in a null.\n         if index.start < bytes.len() {\n-            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+            unsafe { CStr::_from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n         } else {\n             panic!(\n                 \"index out of bounds: the len is {} but the index is {}\","}, {"sha": "00ba5460821ff356601febf2f8d13452725e0bb7", "filename": "library/std/src/ffi/c_str/tests.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dd6ac8302ab7230cd2d78797910931e4b83015/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dd6ac8302ab7230cd2d78797910931e4b83015/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=26dd6ac8302ab7230cd2d78797910931e4b83015", "patch": "@@ -32,14 +32,6 @@ fn build_with_zero2() {\n     assert!(CString::new(vec![0]).is_err());\n }\n \n-#[test]\n-fn build_with_zero3() {\n-    unsafe {\n-        let s = CString::from_vec_unchecked(vec![0]);\n-        assert_eq!(s.as_bytes(), b\"\\0\");\n-    }\n-}\n-\n #[test]\n fn formatted() {\n     let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();"}]}