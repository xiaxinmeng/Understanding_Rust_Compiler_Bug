{"sha": "33a205b56fbe5039d3f64743334b634be8dc4f0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYTIwNWI1NmZiZTUwMzlkM2Y2NDc0MzMzNGI2MzRiZThkYzRmMGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-16T20:12:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: collapse Layout::CEnum into Layout::General.", "tree": {"sha": "94c41cab6df4d1a5e8eb427bd5dd554c3ce86e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94c41cab6df4d1a5e8eb427bd5dd554c3ce86e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33a205b56fbe5039d3f64743334b634be8dc4f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33a205b56fbe5039d3f64743334b634be8dc4f0c", "html_url": "https://github.com/rust-lang/rust/commit/33a205b56fbe5039d3f64743334b634be8dc4f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33a205b56fbe5039d3f64743334b634be8dc4f0c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "658ebfc788d1926b6eaaeb38da52a13a424e1242", "url": "https://api.github.com/repos/rust-lang/rust/commits/658ebfc788d1926b6eaaeb38da52a13a424e1242", "html_url": "https://github.com/rust-lang/rust/commit/658ebfc788d1926b6eaaeb38da52a13a424e1242"}], "stats": {"total": 221, "additions": 86, "deletions": 135}, "files": [{"sha": "44039817e720664212fb888844e0b6984a6323b3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -47,10 +47,11 @@\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(i128_type)]\n-#![feature(match_default_bindings)]\n+#![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(macro_vis_matcher)]\n+#![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(nonzero)]\n #![feature(quote)]"}, {"sha": "5775fc957b5bb86e8ef0f4c727998fedc543cee9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 61, "deletions": 107, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n use std::i64;\n use std::iter;\n use std::mem;\n-use std::ops::{Deref, Add, Sub, Mul, AddAssign};\n+use std::ops::{Deref, Add, Sub, Mul, AddAssign, RangeInclusive};\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -841,9 +841,9 @@ impl<'a, 'tcx> Struct {\n             (&Scalar(Pointer), _) if !layout.ty.is_unsafe_ptr() => {\n                 Ok(Some((Size::from_bytes(0), Pointer)))\n             }\n-            (&CEnum { discr, .. }, &ty::TyAdt(def, _)) => {\n+            (&General { discr, .. }, &ty::TyAdt(def, _)) => {\n                 if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n-                    Ok(Some((Size::from_bytes(0), discr)))\n+                    Ok(Some((layout.fields.offset(0), discr)))\n                 } else {\n                     Ok(None)\n                 }\n@@ -1095,18 +1095,6 @@ pub enum Layout {\n \n     // Remaining variants are all ADTs such as structs, enums or tuples.\n \n-    /// C-like enums; basically an integer.\n-    CEnum {\n-        discr: Primitive,\n-        /// Inclusive discriminant range.\n-        /// If min > max, it represents min...u64::MAX followed by 0...max.\n-        // FIXME(eddyb) always use the shortest range, e.g. by finding\n-        // the largest space between two consecutive discriminants and\n-        // taking everything else as the (shortest) discriminant range.\n-        min: u64,\n-        max: u64\n-    },\n-\n     /// Single-case enums, and structs/tuples.\n     Univariant(Struct),\n \n@@ -1118,6 +1106,12 @@ pub enum Layout {\n     /// at a non-0 offset, after where the discriminant would go.\n     General {\n         discr: Primitive,\n+        /// Inclusive wrap-around range of discriminant values, that is,\n+        /// if min > max, it represents min..=u64::MAX followed by 0..=max.\n+        // FIXME(eddyb) always use the shortest range, e.g. by finding\n+        // the largest space between two consecutive discriminants and\n+        // taking everything else as the (shortest) discriminant range.\n+        discr_range: RangeInclusive<u64>,\n         variants: Vec<Struct>,\n         size: Size,\n         align: Align,\n@@ -1240,7 +1234,6 @@ impl<'a, 'tcx> Layout {\n                     FieldPlacement::union(def.struct_variant().fields.len())\n                 }\n \n-                CEnum { .. } |\n                 General { .. } => FieldPlacement::union(1),\n \n                 NullablePointer { ref discr_offset, .. } => {\n@@ -1250,19 +1243,17 @@ impl<'a, 'tcx> Layout {\n                 }\n             };\n             let abi = match *layout {\n-                Scalar(value) |\n-                CEnum { discr: value, .. } => Abi::Scalar(value),\n-\n+                Scalar(value) => Abi::Scalar(value),\n                 Vector { .. } => Abi::Vector,\n \n                 Array { .. } |\n                 FatPointer { .. } |\n                 Univariant(_) |\n-                UntaggedUnion(_) |\n-                General { .. } => Abi::Aggregate,\n+                UntaggedUnion(_) => Abi::Aggregate,\n \n-                NullablePointer { discr, discr_offset, .. } => {\n-                    if discr_offset.bytes() == 0 && discr.size(cx) == layout.size(cx) {\n+                General { discr, .. } |\n+                NullablePointer { discr, .. } => {\n+                    if fields.offset(0).bytes() == 0 && discr.size(cx) == layout.size(cx) {\n                         Abi::Scalar(discr)\n                     } else {\n                         Abi::Aggregate\n@@ -1431,82 +1422,54 @@ impl<'a, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                if def.variants.is_empty() {\n+                // Cache the field layouts.\n+                let variants = def.variants.iter().map(|v| {\n+                    v.fields.iter().map(|field| {\n+                        cx.layout_of(field.ty(tcx, substs))\n+                    }).collect::<Result<Vec<_>, _>>()\n+                }).collect::<Result<Vec<_>, _>>()?;\n+\n+                if variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n                     return success(Univariant(Struct::new(dl, &[],\n                           &def.repr, StructKind::AlwaysSizedUnivariant, ty)?));\n                 }\n \n-                if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n-                    // All bodies empty -> intlike\n-                    let (mut min, mut max) = (i64::max_value(), i64::min_value());\n-                    for discr in def.discriminants(tcx) {\n-                        let x = discr.to_u128_unchecked() as i64;\n-                        if x < min { min = x; }\n-                        if x > max { max = x; }\n-                    }\n-\n-                    // FIXME: should handle i128? signed-value based impl is weird and hard to\n-                    // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n-                    return success(CEnum {\n-                        discr: Int(discr, signed),\n-                        // FIXME: should be u128?\n-                        min: min as u64,\n-                        max: max as u64\n-                    });\n-                }\n-\n-                if !def.is_enum() || (def.variants.len() == 1 &&\n-                                      !def.repr.inhibit_enum_layout_opt()) {\n+                if !def.is_enum() || (variants.len() == 1 &&\n+                                      !def.repr.inhibit_enum_layout_opt() &&\n+                                      !variants[0].is_empty()) {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n+                    let kind = if def.is_enum() || variants[0].len() == 0 {\n                         StructKind::AlwaysSizedUnivariant\n                     } else {\n                         let param_env = tcx.param_env(def.did);\n-                        let fields = &def.variants[0].fields;\n-                        let last_field = &fields[fields.len()-1];\n+                        let last_field = def.variants[0].fields.last().unwrap();\n                         let always_sized = tcx.type_of(last_field.did)\n                           .is_sized(tcx, param_env, DUMMY_SP);\n                         if !always_sized { StructKind::MaybeUnsizedUnivariant }\n                         else { StructKind::AlwaysSizedUnivariant }\n                     };\n \n-                    let fields = def.variants[0].fields.iter().map(|field| {\n-                        cx.layout_of(field.ty(tcx, substs))\n-                    }).collect::<Result<Vec<_>, _>>()?;\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, &def.repr);\n-                        un.extend(dl, fields.iter().map(|&f| Ok(f.layout)), ty)?;\n+                        un.extend(dl, variants[0].iter().map(|&f| Ok(f.layout)), ty)?;\n                         UntaggedUnion(un)\n                     } else {\n-                        Univariant(Struct::new(dl, &fields, &def.repr, kind, ty)?)\n+                        Univariant(Struct::new(dl, &variants[0], &def.repr, kind, ty)?)\n                     };\n                     return success(layout);\n                 }\n \n-                // Since there's at least one\n-                // non-empty body, explicit discriminants should have\n-                // been rejected by a checker before this point.\n-                for (i, v) in def.variants.iter().enumerate() {\n-                    if v.discr != ty::VariantDiscr::Relative(i) {\n-                        bug!(\"non-C-like enum {} with specified discriminants\",\n-                            tcx.item_path_str(def.did));\n-                    }\n-                }\n+                let no_explicit_discriminants = def.variants.iter().enumerate()\n+                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i));\n \n-                // Cache the substituted and normalized variant field types.\n-                let variants = def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|field| {\n-                        cx.layout_of(field.ty(tcx, substs))\n-                    }).collect::<Result<Vec<_>, _>>()\n-                }).collect::<Result<Vec<_>, _>>()?;\n-\n-                if variants.len() == 2 && !def.repr.inhibit_enum_layout_opt() {\n+                if variants.len() == 2 &&\n+                   !def.repr.inhibit_enum_layout_opt() &&\n+                   no_explicit_discriminants {\n                     // Nullable pointer optimization\n                     let st0 = Struct::new(dl, &variants[0],\n                         &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n@@ -1554,16 +1517,23 @@ impl<'a, 'tcx> Layout {\n                     }\n                 }\n \n-                // The general case.\n-                let discr_max = (variants.len() - 1) as i64;\n-                assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n+                let (mut min, mut max) = (i64::max_value(), i64::min_value());\n+                for discr in def.discriminants(tcx) {\n+                    let x = discr.to_u128_unchecked() as i64;\n+                    if x < min { min = x; }\n+                    if x > max { max = x; }\n+                }\n+                // FIXME: should handle i128? signed-value based impl is weird and hard to\n+                // grok.\n+                let (min_ity, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n+\n                 let mut align = dl.aggregate_align;\n                 let mut primitive_align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n                 // We're interested in the smallest alignment, so start large.\n                 let mut start_align = Align::from_bytes(256, 256).unwrap();\n+                assert_eq!(Integer::for_abi_align(dl, start_align), None);\n \n                 // Create the set of structs that represent each variant.\n                 let mut variants = variants.into_iter().map(|fields| {\n@@ -1644,7 +1614,10 @@ impl<'a, 'tcx> Layout {\n                 }\n \n                 General {\n-                    discr: Int(ity, false),\n+                    discr: Int(ity, signed),\n+\n+                    // FIXME: should be u128?\n+                    discr_range: (min as u64)..=(max as u64),\n                     variants,\n                     size,\n                     align,\n@@ -1680,7 +1653,7 @@ impl<'a, 'tcx> Layout {\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n             Scalar(_) | Vector {..} | FatPointer {..} |\n-            CEnum {..} | UntaggedUnion {..} | General {..} |\n+            UntaggedUnion {..} | General {..} |\n             NullablePointer {..} => false,\n \n             Array { sized, .. } |\n@@ -1720,7 +1693,6 @@ impl<'a, 'tcx> Layout {\n                  metadata.size(dl)).abi_align(self.align(dl))\n             }\n \n-            CEnum { discr, .. } => discr.size(dl),\n             General { size, .. } => size,\n             UntaggedUnion(ref un) => un.stride(),\n \n@@ -1754,7 +1726,6 @@ impl<'a, 'tcx> Layout {\n                 Pointer.align(dl).max(metadata.align(dl))\n             }\n \n-            CEnum { discr, .. } => discr.align(dl),\n             Array { align, .. } | General { align, .. } => align,\n             UntaggedUnion(ref un) => un.align,\n \n@@ -1856,16 +1827,6 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        let build_primitive_info = |name: ast::Name, value: Primitive| {\n-            session::VariantInfo {\n-                name: Some(name.to_string()),\n-                kind: session::SizeKind::Exact,\n-                align: value.align(tcx).abi(),\n-                size: value.size(tcx).bytes(),\n-                fields: vec![],\n-            }\n-        };\n-\n         let build_variant_info = |n: Option<ast::Name>,\n                                   flds: &[(ast::Name, Ty<'tcx>)],\n                                   s: &Struct| {\n@@ -1959,17 +1920,6 @@ impl<'a, 'tcx> Layout {\n                 record(adt_kind.into(), None, Vec::new());\n             }\n \n-            Layout::CEnum { discr, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n-                let variant_infos: Vec<_> =\n-                    adt_def.variants.iter()\n-                                    .map(|variant_def| {\n-                                        build_primitive_info(variant_def.name, discr)\n-                                    })\n-                                    .collect();\n-                record(adt_kind.into(), Some(discr.size(tcx)), variant_infos);\n-            }\n-\n             // other cases provide little interesting (i.e. adjustable\n             // via representation tweaks) size info beyond total size.\n             Layout::Scalar(_) |\n@@ -2284,6 +2234,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n         FullLayout {\n             variant_index: Some(variant_index),\n             fields,\n+            abi: Abi::Aggregate,\n             ..*self\n         }\n     }\n@@ -2356,7 +2307,6 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                     match self.variant_index {\n                         None => match *self.layout {\n                             // Discriminant field for enums (where applicable).\n-                            CEnum { discr, .. } |\n                             General { discr, .. } |\n                             NullablePointer { discr, .. } => {\n                                 return [discr.to_ty(tcx)][i];\n@@ -2416,19 +2366,23 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n             FatPointer(ref metadata) => {\n                 metadata.hash_stable(hcx, hasher);\n             }\n-            CEnum { discr, min, max } => {\n-                discr.hash_stable(hcx, hasher);\n-                min.hash_stable(hcx, hasher);\n-                max.hash_stable(hcx, hasher);\n-            }\n             Univariant(ref variant) => {\n                 variant.hash_stable(hcx, hasher);\n             }\n             UntaggedUnion(ref un) => {\n                 un.hash_stable(hcx, hasher);\n             }\n-            General { discr, ref variants, size, align, primitive_align } => {\n+            General {\n+                discr,\n+                discr_range: RangeInclusive { start, end },\n+                ref variants,\n+                size,\n+                align,\n+                primitive_align\n+            } => {\n                 discr.hash_stable(hcx, hasher);\n+                start.hash_stable(hcx, hasher);\n+                end.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n                 size.hash_stable(hcx, hasher);\n                 align.hash_stable(hcx, hasher);"}, {"sha": "e1a65f37eff82e82384bd4e38010d6c9936d1233", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -69,7 +69,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let l = cx.layout_of(t);\n     debug!(\"finish_type_of: {} with layout {:#?}\", t, l);\n     match *l {\n-        layout::CEnum { .. } | layout::General { .. } | layout::UntaggedUnion { .. } => { }\n+        layout::General { .. } | layout::UntaggedUnion { .. } => { }\n         layout::Univariant { ..} | layout::NullablePointer { .. } => {\n             if let layout::Abi::Scalar(_) = l.abi {\n                 return;\n@@ -101,13 +101,12 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              t: Ty<'tcx>,\n                              name: Option<&str>) -> Type {\n     let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n+    debug!(\"adt::generic_type_of {:#?} name: {:?}\", l, name);\n+    if let layout::Abi::Scalar(value) = l.abi {\n+        return cx.llvm_type_of(value.to_ty(cx.tcx()));\n+    }\n     match *l {\n-        layout::CEnum { discr, .. } => cx.llvm_type_of(discr.to_ty(cx.tcx())),\n         layout::NullablePointer { nndiscr, ref nonnull, .. } => {\n-            if let layout::Abi::Scalar(_) = l.abi {\n-                return cx.llvm_type_of(l.field(cx, 0).ty);\n-            }\n             match name {\n                 None => {\n                     Type::struct_(cx, &struct_llfields(cx, l.for_variant(nndiscr as usize),"}, {"sha": "16bca343dd07df5f9dabc5f8492e1b4e46d9863f", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -1282,7 +1282,6 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            layout::CEnum { .. } => span_bug!(self.span, \"This should be unreachable.\"),\n             ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n         }\n     }\n@@ -1491,14 +1490,16 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let type_rep = cx.layout_of(enum_type);\n \n     let discriminant_type_metadata = match *type_rep {\n-        layout::CEnum { discr, .. } => {\n-            return FinalMetadata(discriminant_type_metadata(discr))\n-        },\n         layout::NullablePointer { .. } | layout::Univariant { .. } => None,\n         layout::General { discr, .. } => Some(discriminant_type_metadata(discr)),\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n \n+    match (type_rep.abi, discriminant_type_metadata) {\n+        (layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n+        _ => {}\n+    }\n+\n     let (enum_type_size, enum_type_align) = type_rep.size_and_align(cx);\n \n     let enum_name = CString::new(enum_name).unwrap();"}, {"sha": "dd33012e900faf1e6113e0ec179152775a3574a8", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -25,6 +25,7 @@\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n #![feature(i128)]\n+#![feature(inclusive_range)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "c8d8199a05eb766ad2094d4c969663971b8b5055", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -1091,23 +1091,22 @@ fn trans_const_adt<'a, 'tcx>(\n         _ => 0,\n     };\n     match *l {\n-        layout::CEnum { .. } => {\n+        layout::General { ref variants, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n                     adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n                            .to_u128_unchecked() as u64\n                 },\n                 _ => 0,\n             };\n-            assert_eq!(vals.len(), 0);\n-            Const::new(C_int(ccx.llvm_type_of(t), discr as i64), t)\n-        }\n-        layout::General { ref variants, .. } => {\n             let discr_ty = l.field(ccx, 0).ty;\n-            let variant = &variants[variant_index];\n-            let lldiscr = C_int(ccx.llvm_type_of(discr_ty), variant_index as i64);\n-            build_const_struct(ccx, l, &variant, vals,\n-                Some(Const::new(lldiscr, discr_ty)))\n+            let discr = Const::new(C_int(ccx.llvm_type_of(discr_ty), discr as i64),\n+                                   discr_ty);\n+            if let layout::Abi::Scalar(_) = l.abi {\n+                discr\n+            } else {\n+                build_const_struct(ccx, l, &variants[variant_index], vals, Some(discr))\n+            }\n         }\n         layout::UntaggedUnion(ref un) => {\n             assert_eq!(variant_index, 0);"}, {"sha": "f39e3cb78126c82030cbe6a7aef722b43f25284b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -367,8 +367,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"discriminant not scalar: {:#?}\", discr_layout)\n         };\n         let (min, max) = match *l {\n-            layout::CEnum { min, max, .. } => (min, max),\n-            layout::General { ref variants, .. } => (0, variants.len() as u64 - 1),\n+            layout::General { ref discr_range, .. } => (discr_range.start, discr_range.end),\n             _ => (0, u64::max_value()),\n         };\n         let max_next = max.wrapping_add(1);\n@@ -394,7 +393,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             }\n         };\n         match *l {\n-            layout::CEnum { .. } |\n             layout::General { .. } => {\n                 let signed = match discr_scalar {\n                     layout::Int(_, signed) => signed,\n@@ -419,7 +417,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n         match *l {\n-            layout::CEnum { .. } |\n             layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())), to as i64),"}, {"sha": "b7143f23691d9ef744295a2cbf4e98296d669c0e", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -277,16 +277,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let llval = operand.immediate();\n                         let l = bcx.ccx.layout_of(operand.ty);\n \n-                        if let Layout::CEnum { min, max, .. } = *l {\n-                            if max > min {\n+                        if let Layout::General { ref discr_range, .. } = *l {\n+                            if discr_range.end > discr_range.start {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most\n                                 // convenient place to put the `assume`.\n \n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_uint(ll_t_in, max)\n+                                    C_uint(ll_t_in, discr_range.end)\n                                 ));\n                             }\n                         }"}, {"sha": "eca6057db3663f17764206e21240d0c2dcca4d0b", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a205b56fbe5039d3f64743334b634be8dc4f0c/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=33a205b56fbe5039d3f64743334b634be8dc4f0c", "patch": "@@ -242,7 +242,6 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n         }\n         match **self {\n             Layout::Scalar { .. } |\n-            Layout::CEnum { .. } |\n             Layout::UntaggedUnion { .. } => {\n                 bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n             }"}]}