{"sha": "adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYzFkZjExYjRkOGVmMDA1MzYzNTg1ZGM0ZDNlZTJhMDNkZmVkMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T08:06:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T08:06:16Z"}, "message": "Auto merge of #4568 - mikerite:fix-4548, r=flip1995\n\nFix `nonminimal-bool` false positive\n\nCloses #4548\nCloses #3847\n\nchangelog: Fix `nonminimal-bool` false positive", "tree": {"sha": "154c51b92141d98210404485b4782dbf7f138e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/154c51b92141d98210404485b4782dbf7f138e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "html_url": "https://github.com/rust-lang/rust/commit/adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d30b08027f191e26431e0e62b5f17de76d273c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d30b08027f191e26431e0e62b5f17de76d273c5", "html_url": "https://github.com/rust-lang/rust/commit/4d30b08027f191e26431e0e62b5f17de76d273c5"}, {"sha": "89cdd26e71ecc7778f05b06c8878d641a258519a", "url": "https://api.github.com/repos/rust-lang/rust/commits/89cdd26e71ecc7778f05b06c8878d641a258519a", "html_url": "https://github.com/rust-lang/rust/commit/89cdd26e71ecc7778f05b06c8878d641a258519a"}], "stats": {"total": 157, "additions": 102, "deletions": 55}, "files": [{"sha": "dafa34dec1d30f10d51caf8781efe1ba02187f9b", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 76, "deletions": 49, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "patch": "@@ -1,5 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_then, SpanlessEq,\n+    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_sugg,\n+    span_lint_and_then, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc::hir::intravisit::*;\n@@ -159,46 +160,6 @@ struct SuggestContext<'a, 'tcx, 'v> {\n }\n \n impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n-    fn snip(&self, e: &Expr) -> Option<String> {\n-        snippet_opt(self.cx, e.span)\n-    }\n-\n-    fn simplify_not(&self, expr: &Expr) -> Option<String> {\n-        match &expr.node {\n-            ExprKind::Binary(binop, lhs, rhs) => {\n-                if !implements_ord(self.cx, lhs) {\n-                    return None;\n-                }\n-\n-                match binop.node {\n-                    BinOpKind::Eq => Some(\" != \"),\n-                    BinOpKind::Ne => Some(\" == \"),\n-                    BinOpKind::Lt => Some(\" >= \"),\n-                    BinOpKind::Gt => Some(\" <= \"),\n-                    BinOpKind::Le => Some(\" > \"),\n-                    BinOpKind::Ge => Some(\" < \"),\n-                    _ => None,\n-                }\n-                .and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n-            },\n-            ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n-                let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n-                if !match_type(self.cx, type_of_receiver, &paths::OPTION)\n-                    && !match_type(self.cx, type_of_receiver, &paths::RESULT)\n-                {\n-                    return None;\n-                }\n-                METHODS_WITH_NEGATION\n-                    .iter()\n-                    .cloned()\n-                    .flat_map(|(a, b)| vec![(a, b), (b, a)])\n-                    .find(|&(a, _)| a == path.ident.name.as_str())\n-                    .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", self.snip(&args[0])?, neg_method)))\n-            },\n-            _ => None,\n-        }\n-    }\n-\n     fn recurse(&mut self, suggestion: &Bool) -> Option<()> {\n         use quine_mc_cluskey::Bool::*;\n         match suggestion {\n@@ -217,12 +178,12 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 },\n                 Term(n) => {\n                     let terminal = self.terminals[n as usize];\n-                    if let Some(str) = self.simplify_not(terminal) {\n+                    if let Some(str) = simplify_not(self.cx, terminal) {\n                         self.simplified = true;\n                         self.output.push_str(&str)\n                     } else {\n                         self.output.push('!');\n-                        let snip = self.snip(terminal)?;\n+                        let snip = snippet_opt(self.cx, terminal.span)?;\n                         self.output.push_str(&snip);\n                     }\n                 },\n@@ -254,14 +215,55 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 }\n             },\n             &Term(n) => {\n-                let snip = self.snip(self.terminals[n as usize])?;\n+                let snip = snippet_opt(self.cx, self.terminals[n as usize].span)?;\n                 self.output.push_str(&snip);\n             },\n         }\n         Some(())\n     }\n }\n \n+fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<String> {\n+    match &expr.node {\n+        ExprKind::Binary(binop, lhs, rhs) => {\n+            if !implements_ord(cx, lhs) {\n+                return None;\n+            }\n+\n+            match binop.node {\n+                BinOpKind::Eq => Some(\" != \"),\n+                BinOpKind::Ne => Some(\" == \"),\n+                BinOpKind::Lt => Some(\" >= \"),\n+                BinOpKind::Gt => Some(\" <= \"),\n+                BinOpKind::Le => Some(\" > \"),\n+                BinOpKind::Ge => Some(\" < \"),\n+                _ => None,\n+            }\n+            .and_then(|op| {\n+                Some(format!(\n+                    \"{}{}{}\",\n+                    snippet_opt(cx, lhs.span)?,\n+                    op,\n+                    snippet_opt(cx, rhs.span)?\n+                ))\n+            })\n+        },\n+        ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n+            let type_of_receiver = cx.tables.expr_ty(&args[0]);\n+            if !match_type(cx, type_of_receiver, &paths::OPTION) && !match_type(cx, type_of_receiver, &paths::RESULT) {\n+                return None;\n+            }\n+            METHODS_WITH_NEGATION\n+                .iter()\n+                .cloned()\n+                .flat_map(|(a, b)| vec![(a, b), (b, a)])\n+                .find(|&(a, _)| a == path.ident.name.as_str())\n+                .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", snippet_opt(cx, args[0].span)?, neg_method)))\n+        },\n+        _ => None,\n+    }\n+}\n+\n // The boolean part of the return indicates whether some simplifications have been applied.\n fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n     let mut suggest_context = SuggestContext {\n@@ -330,7 +332,7 @@ fn terminal_stats(b: &Bool) -> Stats {\n }\n \n impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n-    fn bool_expr(&self, e: &Expr) {\n+    fn bool_expr(&self, e: &'tcx Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n             cx: self.cx,\n@@ -420,10 +422,8 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 );\n             };\n             if improvements.is_empty() {\n-                let suggest = suggest(self.cx, &expr, &h2q.terminals);\n-                if suggest.1 {\n-                    nonminimal_bool_lint(vec![suggest.0])\n-                }\n+                let mut visitor = NotSimplificationVisitor { cx: self.cx };\n+                visitor.visit_expr(e);\n             } else {\n                 nonminimal_bool_lint(\n                     improvements\n@@ -464,3 +464,30 @@ fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr) -> bool\n     let ty = cx.tables.expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n+\n+struct NotSimplificationVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprKind::Unary(UnNot, inner) = &expr.node {\n+            if let Some(suggestion) = simplify_not(self.cx, inner) {\n+                span_lint_and_sugg(\n+                    self.cx,\n+                    NONMINIMAL_BOOL,\n+                    expr.span,\n+                    \"this boolean expression can be simplified\",\n+                    \"try\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "ece20fb1eabb9ca9df68d0b10618c08f3ca27a81", "filename": "tests/ui/booleans.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/tests%2Fui%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/tests%2Fui%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.rs?ref=adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "patch": "@@ -142,3 +142,23 @@ fn dont_warn_for_negated_partial_ord_comparison() {\n     let _ = !(a > b);\n     let _ = !(a >= b);\n }\n+\n+fn issue3847(a: u32, b: u32) -> bool {\n+    const THRESHOLD: u32 = 1_000;\n+\n+    if a < THRESHOLD && b >= THRESHOLD || a >= THRESHOLD && b < THRESHOLD {\n+        return false;\n+    }\n+    true\n+}\n+\n+fn issue4548() {\n+    fn f(_i: u32, _j: u32) -> u32 {\n+        unimplemented!();\n+    }\n+\n+    let i = 0;\n+    let j = 0;\n+\n+    if i != j && f(i, j) != 0 || i == j && f(i, j) != 1 {}\n+}"}, {"sha": "ab0b54e26d70f65cf5c8602264fe9076fb3beb2e", "filename": "tests/ui/booleans.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/tests%2Fui%2Fbooleans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc1df11b4d8ef005363585dc4d3ee2a03dfed08/tests%2Fui%2Fbooleans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.stderr?ref=adc1df11b4d8ef005363585dc4d3ee2a03dfed08", "patch": "@@ -158,22 +158,22 @@ LL |     let _ = !(a.is_some() && !c);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: try: `c || a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:54:13\n+  --> $DIR/booleans.rs:54:26\n    |\n LL |     let _ = !(!c ^ c) || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `!(!c ^ c) || a.is_none()`\n+   |                          ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:55:13\n+  --> $DIR/booleans.rs:55:25\n    |\n LL |     let _ = (!c ^ c) || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(!c ^ c) || a.is_none()`\n+   |                         ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n-  --> $DIR/booleans.rs:56:13\n+  --> $DIR/booleans.rs:56:23\n    |\n LL |     let _ = !c ^ c || !a.is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try: `!c ^ c || a.is_none()`\n+   |                       ^^^^^^^^^^^^ help: try: `a.is_none()`\n \n error: this boolean expression can be simplified\n   --> $DIR/booleans.rs:128:8"}]}