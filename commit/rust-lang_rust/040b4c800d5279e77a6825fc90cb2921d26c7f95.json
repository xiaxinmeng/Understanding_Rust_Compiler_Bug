{"sha": "040b4c800d5279e77a6825fc90cb2921d26c7f95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MGI0YzgwMGQ1Mjc5ZTc3YTY4MjVmYzkwY2IyOTIxZDI2YzdmOTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:41:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:41:37Z"}, "message": "Fix GenericArgs grammar", "tree": {"sha": "17de1c83aa3d392902777c9eebbbb17f14b05e12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17de1c83aa3d392902777c9eebbbb17f14b05e12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040b4c800d5279e77a6825fc90cb2921d26c7f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040b4c800d5279e77a6825fc90cb2921d26c7f95", "html_url": "https://github.com/rust-lang/rust/commit/040b4c800d5279e77a6825fc90cb2921d26c7f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040b4c800d5279e77a6825fc90cb2921d26c7f95/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d21b5db891d605c7c10118daca1f06c09c14b07e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21b5db891d605c7c10118daca1f06c09c14b07e", "html_url": "https://github.com/rust-lang/rust/commit/d21b5db891d605c7c10118daca1f06c09c14b07e"}], "stats": {"total": 157, "additions": 107, "deletions": 50}, "files": [{"sha": "0a7be87a0c4a1562e939b299a5383f5065f08986", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=040b4c800d5279e77a6825fc90cb2921d26c7f95", "patch": "@@ -79,19 +79,25 @@ impl<'a> SubstituteTypeParams<'a> {\n         };\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-        // trait ref, and then go from the types in the substs back to the syntax)\n+        // trait ref, and then go from the types in the substs back to the syntax).\n         fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n             let target_trait = impl_def.target_trait()?;\n             let path_type = match target_trait {\n                 ast::Type::PathType(path) => path,\n                 _ => return None,\n             };\n-            let type_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n+            let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n+\n             let mut result = Vec::new();\n-            for type_arg in type_arg_list.type_args() {\n-                let type_arg: ast::TypeArg = type_arg;\n-                result.push(type_arg.ty()?);\n+            for generic_arg in generic_arg_list.generic_args() {\n+                match generic_arg {\n+                    ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n+                    ast::GenericArg::AssocTypeArg(_)\n+                    | ast::GenericArg::LifetimeArg(_)\n+                    | ast::GenericArg::ConstArg(_) => (),\n+                }\n             }\n+\n             Some(result)\n         }\n     }"}, {"sha": "d09fc66e4dcec0998d80dddde2961d9c56edd61b", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=040b4c800d5279e77a6825fc90cb2921d26c7f95", "patch": "@@ -151,30 +151,34 @@ pub(super) fn lower_generic_args(\n     node: ast::GenericArgList,\n ) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n-    for type_arg in node.type_args() {\n-        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.ty());\n-        args.push(GenericArg::Type(type_ref));\n-    }\n-    // lifetimes ignored for now\n     let mut bindings = Vec::new();\n-    for assoc_type_arg in node.assoc_type_args() {\n-        let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n-        if let Some(name_ref) = assoc_type_arg.name_ref() {\n-            let name = name_ref.as_name();\n-            let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n-            let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n-                l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n-            } else {\n-                Vec::new()\n-            };\n-            bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+    for generic_arg in node.generic_args() {\n+        match generic_arg {\n+            ast::GenericArg::TypeArg(type_arg) => {\n+                let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.ty());\n+                args.push(GenericArg::Type(type_ref));\n+            }\n+            ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n+                if let Some(name_ref) = assoc_type_arg.name_ref() {\n+                    let name = name_ref.as_name();\n+                    let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n+                    let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n+                        l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n+                    } else {\n+                        Vec::new()\n+                    };\n+                    bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+                }\n+            }\n+            // Lifetimes and constants are ignored for now.\n+            ast::GenericArg::LifetimeArg(_) | ast::GenericArg::ConstArg(_) => (),\n         }\n     }\n+\n     if args.is_empty() && bindings.is_empty() {\n-        None\n-    } else {\n-        Some(GenericArgs { args, has_self_type: false, bindings })\n+        return None;\n     }\n+    Some(GenericArgs { args, has_self_type: false, bindings })\n }\n \n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)"}, {"sha": "132c2ae8c342f75d6b5d8e48abb0e4fd142914f8", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040b4c800d5279e77a6825fc90cb2921d26c7f95/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=040b4c800d5279e77a6825fc90cb2921d26c7f95", "patch": "@@ -46,10 +46,7 @@ pub struct GenericArgList {\n impl GenericArgList {\n     pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n     pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n-    pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n-    pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n-    pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n+    pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -86,15 +83,6 @@ impl TypeArg {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LifetimeArg {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl LifetimeArg {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct AssocTypeArg {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -105,6 +93,15 @@ impl AssocTypeArg {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LifetimeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl LifetimeArg {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1272,6 +1269,13 @@ impl MacroStmts {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericArg {\n+    TypeArg(TypeArg),\n+    AssocTypeArg(AssocTypeArg),\n+    LifetimeArg(LifetimeArg),\n+    ConstArg(ConstArg),\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Type {\n     ArrayType(ArrayType),\n     DynTraitType(DynTraitType),\n@@ -1489,8 +1493,8 @@ impl AstNode for TypeArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LifetimeArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_ARG }\n+impl AstNode for AssocTypeArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_TYPE_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1500,8 +1504,8 @@ impl AstNode for LifetimeArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for AssocTypeArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_TYPE_ARG }\n+impl AstNode for LifetimeArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2765,6 +2769,44 @@ impl AstNode for MacroStmts {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl From<TypeArg> for GenericArg {\n+    fn from(node: TypeArg) -> GenericArg { GenericArg::TypeArg(node) }\n+}\n+impl From<AssocTypeArg> for GenericArg {\n+    fn from(node: AssocTypeArg) -> GenericArg { GenericArg::AssocTypeArg(node) }\n+}\n+impl From<LifetimeArg> for GenericArg {\n+    fn from(node: LifetimeArg) -> GenericArg { GenericArg::LifetimeArg(node) }\n+}\n+impl From<ConstArg> for GenericArg {\n+    fn from(node: ConstArg) -> GenericArg { GenericArg::ConstArg(node) }\n+}\n+impl AstNode for GenericArg {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_ARG | ASSOC_TYPE_ARG | LIFETIME_ARG | CONST_ARG => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            TYPE_ARG => GenericArg::TypeArg(TypeArg { syntax }),\n+            ASSOC_TYPE_ARG => GenericArg::AssocTypeArg(AssocTypeArg { syntax }),\n+            LIFETIME_ARG => GenericArg::LifetimeArg(LifetimeArg { syntax }),\n+            CONST_ARG => GenericArg::ConstArg(ConstArg { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            GenericArg::TypeArg(it) => &it.syntax,\n+            GenericArg::AssocTypeArg(it) => &it.syntax,\n+            GenericArg::LifetimeArg(it) => &it.syntax,\n+            GenericArg::ConstArg(it) => &it.syntax,\n+        }\n+    }\n+}\n impl From<ArrayType> for Type {\n     fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n }\n@@ -3380,6 +3422,11 @@ impl From<Item> for Stmt {\n impl From<LetStmt> for Stmt {\n     fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n }\n+impl std::fmt::Display for GenericArg {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for Type {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3470,12 +3517,12 @@ impl std::fmt::Display for TypeArg {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LifetimeArg {\n+impl std::fmt::Display for AssocTypeArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for AssocTypeArg {\n+impl std::fmt::Display for LifetimeArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }"}, {"sha": "fa18acbb36f777a9fbe31f03bc49a52813a3de53", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/040b4c800d5279e77a6825fc90cb2921d26c7f95/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/040b4c800d5279e77a6825fc90cb2921d26c7f95/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=040b4c800d5279e77a6825fc90cb2921d26c7f95", "patch": "@@ -8,12 +8,13 @@ PathSegment =\n | '<' PathType ('as' PathType)? '>'\n \n GenericArgList =\n-  '::'? '<'\n-    TypeArg*\n-    LifetimeArg*\n-    AssocTypeArg*\n-    ConstArg*\n-  '>'\n+  '::'? '<' (GenericArg (',' GenericArg)* ','?)? '>'\n+\n+GenericArg =\n+  TypeArg\n+| AssocTypeArg\n+| LifetimeArg\n+| ConstArg\n \n TypeArg =\n   Type\n@@ -27,7 +28,6 @@ LifetimeArg =\n ConstArg =\n   Literal | BlockExpr BlockExpr\n \n-\n SourceFile =\n   'shebang'?\n   Attr*"}]}